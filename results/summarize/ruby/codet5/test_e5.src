7	def cookie_jar return @cookie_jar if defined? ( @cookie_jar ) && @cookie_jar jar = @request . cookie_jar . dup headers . fetch ( :set_cookie , [ ] ) . each do | cookie | jar . parse ( cookie , @request . uri ) end @cookie_jar = jar end
6	def cookies hash = { } cookie_jar . cookies ( @request . uri ) . each do | cookie | hash [ cookie . name ] = cookie . value end hash end
2	def process_url_params ( url , headers ) url_params = nil headers . delete_if do | key , value | if key . to_s . downcase == 'params' && ( value . is_a? ( Hash ) || value . is_a? ( RestClient :: ParamsArray ) ) if url_params raise ArgumentError . new ( "Multiple 'params' options passed" ) end url_params = value true else false end end if url_params && ! url_params . empty? query_string = RestClient :: Utils . encode_query_string ( url_params ) if url . include? ( '?' ) url + '&' + query_string else url + '?' + query_string end else url end end
0	def preparse ( unparsed , args = [ ] , opts = { } ) case unparsed when Hash then opts . merge! unparsed when Array then unparsed . each { | e | preparse ( e , args , opts ) } else args << unparsed . to_s end [ args , opts ] end
8	def follow_get_redirection ( & block ) new_args = request . args . dup new_args [ :method ] = :get new_args . delete ( :payload ) _follow_redirection ( new_args , & block ) end
4	def maybe_convert_extension ( ext ) unless ext =~ / \A \z / return ext end types = MIME :: Types . type_for ( ext ) if types . empty? ext else types . first . content_type end end
3	def stringify_headers headers headers . inject ( { } ) do | result , ( key , value ) | if key . is_a? Symbol key = key . to_s . split ( / / ) . map ( & :capitalize ) . join ( '-' ) end if 'CONTENT-TYPE' == key . upcase result [ key ] = maybe_convert_extension ( value . to_s ) elsif 'ACCEPT' == key . upcase if value . is_a? Array target_values = value else target_values = value . to_s . split ',' end result [ key ] = target_values . map { | ext | maybe_convert_extension ( ext . to_s . strip ) } . join ( ', ' ) else result [ key ] = value . to_s end result end end
5	def [] ( suburl , & new_block ) case when block_given? then self . class . new ( concat_urls ( url , suburl ) , options , & new_block ) when block then self . class . new ( concat_urls ( url , suburl ) , options , & block ) else self . class . new ( concat_urls ( url , suburl ) , options ) end end
9	def _follow_redirection ( new_args , & block ) url = headers [ :location ] unless url raise exception_with_response end unless url . start_with? ( 'http' ) url = URI . parse ( request . url ) . merge ( url ) . to_s end new_args [ :url ] = url new_args [ :password ] = request . password new_args [ :user ] = request . user new_args [ :headers ] = request . headers new_args [ :max_redirects ] = request . max_redirects - 1 new_args [ :cookies ] = cookie_jar new_req = Request . new ( new_args ) new_req . redirection_history = history + [ self ] new_req . execute ( & block ) end
1	def to_s super + ":\n" + format_observation ( result . control ) + "\n" + result . candidates . map { | candidate | format_observation ( candidate ) } . join ( "\n" ) + "\n" end
