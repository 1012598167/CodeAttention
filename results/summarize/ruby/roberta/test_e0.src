902	def method_missing ( method , * args , & block ) klass = class_for_api_command ( method ) return klass . new ( @socket ) . send ( method , * args , & block ) if klass super ( method , * args , & block ) end
239	def field_for ( field_id ) fields . detect { | f | Support . snakify ( f . id ) == Support . snakify ( field_id ) } end
15	def soap_header_handler ( auth_handler , version , header_ns , default_ns ) auth_method = @config . read ( 'authentication.method' , :OAUTH2 ) handler_class = case auth_method when :OAUTH2 , :OAUTH2_SERVICE_ACCOUNT AdsCommon :: SavonHeaders :: OAuthHeaderHandler else raise AdsCommon :: Errors :: AuthError , "Unknown auth method: %s" % auth_method end return handler_class . new ( @credential_handler , auth_handler , header_ns , default_ns , version ) end
185	def restriction! ( restriction ) @nbuild [ NS_EWS_MESSAGES ] . Restriction { restriction . each_pair do | k , v | self . send normalize_type ( k ) , v end } end
1192	def summoner ( name_or_id , optional = { } ) region = optional [ :region ] || @sightstone . region uri = if name_or_id . is_a? Integer "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{name_or_id}" else "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/by-name/#{URI::encode(name_or_id)}" end response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) s = Summoner . new ( data . values [ 0 ] ) if block_given? yield s else return s end } end
71	def download_report_as_file ( report_definition , path , cid = nil ) report_body = download_report ( report_definition , cid ) save_to_file ( report_body , path ) return nil end
1375	def post_with_signature ( opts ) path = opts . fetch ( :path ) payload = opts . fetch ( :payload ) secret = opts . fetch ( :secret ) post path , { payload : payload } , generate_secret_header ( secret , URI . encode_www_form ( payload : payload ) ) end
171	def run unless @executables . empty? @config . executables = @executables end jobs = @jobs . flat_map do | job | BenchmarkDriver :: JobParser . parse ( { type : @config . runner_type , prelude : @prelude , loop_count : @loop_count , } . merge! ( job ) ) end BenchmarkDriver :: Runner . run ( jobs , config : @config ) end
201	def validate_created_item ( response ) msg = response . response_messages [ 0 ] if ( msg . status == 'Success' ) msg . items . empty? ? true : parse_created_item ( msg . items . first ) else raise EwsCreateItemError , "#{msg.code}: #{msg.message_text}" end end
726	def parse_response ( body ) report = CSV . new ( body , headers : true , header_converters : :symbol , converters : :all ) format = @format . to_s . downcase report_formatter = formatters . find ( format ) report_formatter . format report end
484	def ft_sugdel_all ( attribute : ) @model . all . each { | record | ft_sugdel ( record : record , attribute : attribute ) } rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
35	def process_hash_keys ( hash ) return hash . inject ( { } ) do | result , pair | key , value = pair result [ key . to_sym ] = value . is_a? ( Hash ) ? process_hash_keys ( value ) : value result end end
63	def handle_errors ( response ) if response . soap_fault? exception = exception_for_soap_fault ( response ) raise exception end if response . http_error? raise AdsCommon :: Errors :: HttpError , "HTTP Error occurred: %s" % response . http_error end end
32	def implode_parent ( data_type ) result = [ ] if data_type [ :base ] parent_type = @registry . get_type_signature ( data_type [ :base ] ) result += implode_parent ( parent_type ) end data_type [ :fields ] . each do | field | result . reject! { | parent_field | parent_field [ :name ] . eql? ( field [ :name ] ) } field [ :ns ] = data_type [ :ns ] if data_type [ :ns ] result << field end return result end
708	def get_vm_by_name ( organization , vdcName , vAppName , vmName ) result = nil get_vapp_by_name ( organization , vdcName , vAppName ) [ :vms_hash ] . each do | key , values | if key . downcase == vmName . downcase result = get_vm ( values [ :id ] ) end end result end
1327	def check_script ( path ) binary = path . split ( ' ' ) [ 0 ] raise "#{path} does not exist" unless File . exist? binary raise "#{path} is not executable" unless File . executable? binary path end
1276	def bind ( queue_name , exchange_name , * routing_keys , & block ) queue = create_queue ( queue_name , exchange_name , queue_options : { durable : true } , routing_keys : routing_keys ) subscribe ( queue , & block ) if block_given? end
991	def list ( type ) request = Net :: HTTP :: Get . new URI . join ( @base_uri . to_s , "cloudlets/api/v2/origins?type=#{type}" ) . to_s response = @http_host . request ( request ) response . body end
1261	def register_observer ( observer ) @observer_mutex . synchronize do log "EventListener: registering observer #{observer.class} #{observer.id}" @observers [ observer_key_for ( observer . class , observer . id ) ] = observer . observe_events ( client ) end end
949	def toggle ( outlet , status ) current_status = status ( outlet ) toggle_relay ( outlet ) if current_status != status status end
304	def consumer_key ( k ) bot . deprecated "Setting consumer_key outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :consumer_key ] = k end
186	def calendar_view! ( cal_view ) attribs = { } cal_view . each_pair { | k , v | attribs [ camel_case ( k ) ] = v . to_s } @nbuild [ NS_EWS_MESSAGES ] . CalendarView ( attribs ) end
374	def record_split_class ( main_file , * files ) if @reloader files = Unreloader . expand_paths ( files ) files . each do | file | record_dependency ( file , main_file ) end @reloader . skip_reload ( files ) end end
234	def run_request ( request ) url = request . absolute? ? request . url : base_url + request . url logger . info ( request : { url : url , query : request . query , header : request_headers } ) if logger Response . new ( self . class . get_http ( url , request_query ( request . query ) , request_headers , proxy_params , timeout_params ) , request ) end
29	def add_attribute ( node , key , name , value ) node [ :attributes! ] ||= { } node [ :attributes! ] [ key ] ||= { } if node [ :attributes! ] [ key ] . include? ( name ) node [ :attributes! ] [ key ] [ name ] = arrayize ( node [ :attributes! ] [ key ] [ name ] ) node [ :attributes! ] [ key ] [ name ] << value else node [ :attributes! ] [ key ] [ name ] = value end end
1030	def breadcrumbs ( root_depth : 0 , last_page_title : nil , nav_class : 'breadcrumbs' , div_class : 'scrollable' ) return if m . parent_at_depth ( root_depth ) . nil? h . content_tag :nav , class : nav_class do h . concat h . content_tag ( :div , breadcrumbs_ul ( breadcrumbs_list ( root_depth , last_page_title ) ) , class : div_class ) end end
996	def convert_currency ( valueToConvert , firstUnit , secondUnit ) dictionary_api if validate_usd_unit ( firstUnit ) && validate_usd_unit ( secondUnit ) return valueToConvert elsif validate_usd_unit ( firstUnit ) && validate_usd_unit ( secondUnit ) == false if validate_currency_unit ( secondUnit ) finalValue = valueToConvert * @hash [ secondUnit ] return finalValue else return 0 end elsif validate_usd_unit ( firstUnit ) == false && validate_usd_unit ( secondUnit ) if validate_currency_unit ( firstUnit ) finalValue = valueToConvert / @hash [ firstUnit ] return finalValue else return 0 end else if data_validate_api ( firstUnit , secondUnit ) finalValue = ( valueToConvert / @hash [ firstUnit ] ) * @hash [ secondUnit ] return finalValue else return 0 end end end
511	def suppressionlist ( page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" ) options = { :query => { :page => page , :pagesize => page_size , :orderfield => order_field , :orderdirection => order_direction } } response = get 'suppressionlist' , options Hashie :: Mash . new ( response ) end
132	def save ( file , overwrite : false , allow_negative_balance : false ) raise 'You have to join at least one wallet in' if empty? before = '' wallet = Wallet . new ( file ) before = wallet . digest if wallet . exists? Tempfile . open ( [ @id , Wallet :: EXT ] ) do | f | temp = Wallet . new ( f . path ) temp . init ( @id , @key , overwrite : overwrite , network : @network ) File . open ( f . path , 'a' ) do | t | @txns . each do | txn | next if Id :: BANNED . include? ( txn . bnf . to_s ) t . print "#{txn}\n" end end temp . refurbish if temp . balance . negative? && ! temp . id . root? && ! allow_negative_balance if wallet . exists? @log . info ( "The balance is negative, won't merge #{temp.mnemo} on top of #{wallet.mnemo}" ) else @log . info ( "The balance is negative, won't save #{temp.mnemo}" ) end else FileUtils . mkdir_p ( File . dirname ( file ) ) IO . write ( file , IO . read ( f . path ) ) end end before != wallet . digest end
1366	def echo_uploads_data = ( data ) parsed = JSON . parse Base64 . decode64 ( data ) unless parsed . is_a? Hash raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end parsed . each do | attr , attr_data | unless attr_data . is_a? Array raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end attr_data . each do | variant_data | unless variant_data . is_a? Hash raise ArgumentError , "Invalid JSON structure in: #{parsed.inspect}" end if meta = :: EchoUploads :: File . where ( id : variant_data [ 'id' ] , key : variant_data [ 'key' ] , temporary : true ) . first if send ( "#{attr}_tmp_metadata" ) . nil? send "#{attr}_tmp_metadata=" , [ ] end send ( "#{attr}_tmp_metadata" ) << meta end end end end
1108	def with ( hash , quiet : false ) old_values = data . values_at ( hash . keys ) log . debug "with #{hash}" , quiet : quiet do set hash yield end ensure hash . keys . each . with_index do | key , i | @data [ key ] = old_values [ i ] end end
954	def in ( set ) @collection = @collection . collect do | item | item if set . include? ( item . send ( @field_name . to_sym ) ) end . compact end
140	def format_column idx , format = nil , opts = { } opts [ :worksheet ] = self res = case idx when Integer column = nil if format column = Column . new ( idx , format , opts ) end @columns [ idx ] = column else idx . collect do | col | format_column col , format , opts end end shorten @columns res end
1231	def process ( operator , s ) s = coerce ( s ) || s raise "operand needs to be a SpreadSheet, " + "Numeric or Array" unless s . is_a? ( SpreadSheet ) result = [ ] rlabel = [ ] clabel = [ ] s1_row_count , s1_col_count = dim s2_row_count , s2_col_count = s . dim row_count = [ s1_row_count , s2_row_count ] . max col_count = [ s1_col_count , s2_col_count ] . max 0 . upto ( row_count - 1 ) do | r | r1 = r % s1_row_count r2 = r % s2_row_count rlabel << "#{row_labels[r1]}#{operator}#{s.row_labels[r2]}" element = [ ] 0 . upto ( col_count - 1 ) do | c | c1 = c % s1_col_count c2 = c % s2_col_count clabel << "#{col_labels[c1]}#{operator}#{s.col_labels[c2]}" element << rows [ r1 ] [ c1 ] . send ( operator , s . rows [ r2 ] [ c2 ] ) end result << element end SpreadSheet . new ( * result , row_labels : rlabel , col_labels : clabel ) end
182	def start_time_zone! ( zone ) attributes = { } attributes [ 'Id' ] = zone [ :id ] if zone [ :id ] attributes [ 'Name' ] = zone [ :name ] if zone [ :name ] nbuild [ NS_EWS_TYPES ] . StartTimeZone ( attributes ) end
1054	def add ( storable , * coordinate ) return add_local ( storable , * coordinate ) unless coordinate . empty? add_to_existing_container ( storable ) or add_to_new_subcontainer ( storable ) or out_of_bounds ( storable ) self end
1185	def with_friends data = api ( 'room.directory_graph' ) data [ 'rooms' ] . map do | ( attrs , friends ) | Room . new ( client , attrs . merge ( :friends => friends ) ) end end
94	def normalize_output_field ( field_data , field_def ) return case field_data when Array normalize_array_field ( field_data , field_def ) when Hash normalize_hash_field ( field_data , field_def ) else normalize_item ( field_data , field_def ) end end
552	def mark_tip_todo ( tip_id , options = { } ) response = connection . post do | req | req . url "tips/#{tip_id}/marktodo" , options end return_error_or_body ( response , response . body . response ) end
1139	def log_configuration_information Mako . logger . info "Configuration File: #{Mako.config.config_file}" Mako . logger . info "Theme: #{Mako.config.theme}" Mako . logger . info "Destination: #{Mako.config.destination}" end
129	def to_json @threads . map do | t | { name : t . name , status : t . status , alive : t . alive? , vars : Hash [ t . thread_variables . map { | v | [ v . to_s , t . thread_variable_get ( v ) ] } ] } end end
1320	def add ( path ) str = "#{path} filter=rgc diff=rgc" if content . include? ( str ) abort "`#{str}\n` is already included in #{@location}." end File . open ( @location , 'a' ) do | f | f . write ( "#{str}\n" ) end rescue Errno :: ENOENT abort "File #{@location} does not exists." rescue Errno :: EACCES abort "File #{@location} is not accessible for writing." end
619	def store ( node ) if ! node . nil? @children . push ( node ) if ! @children . include? ( Node ) node . parent = self if node . parent != self end node end
985	def update_ttl new_ttl = nil new_ttl = self . _default_expire if new_ttl . nil? new_ttl = - 1 if ! new_ttl . to_i . is_a? ( Fixnum ) || new_ttl . to_i < 0 Ohm . redis . expire ( self . key , new_ttl ) Ohm . redis . expire ( "#{self.key}:_indices" , new_ttl ) end
727	def find ( name ) formatter = formatters . find do | f | standardize ( f . name ) == standardize ( name ) end formatter || raise ( Rescuetime :: Errors :: InvalidFormatError ) end
545	def user_lists ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/lists" , options end return_error_or_body ( response , response . body . response . lists ) end
510	def people response = get "people" response . map { | item | Hashie :: Mash . new ( item ) } end
1342	def find_in_batches ( options = { } ) start = options [ :start ] || 0 marker = start batch_size = options [ :batch_size ] || 500 record_ids = redis . zrange ( index_key_for ( :id ) , marker , marker + batch_size - 1 ) while record_ids . length > 0 records_count = record_ids . length marker += records_count records = find ( record_ids ) yield records break if records_count < batch_size record_ids = redis . zrange ( index_key_for ( :id ) , marker , marker + batch_size - 1 ) end end
409	def verify_digests! references . each do | reference | node = referenced_node ( reference . uri ) canoned = node . canonicalize ( C14N , reference . namespaces ) digest = reference . digest_method . digest ( canoned ) if digest != reference . decoded_digest_value raise SignatureError . new ( "Reference validation error: Digest mismatch for #{reference.uri}" ) end end end
928	def create_table_statement ( table_name , table ) normalize_primary_key ( table ) add_line "create_table #{table_name.inspect}#{pretty_hash(table[:table_options])} do" indent do output_columns ( table [ :columns ] , table [ :primary_key ] ) output_indexes ( table [ :indexes ] ) output_primary_key ( table ) end add_line "end" end
1085	def classes raise StreamNotParsed , 'you must parse first' if @tree . nil? classes = statements . select do | node | node . is_a? ( ClassStatement ) end classes . map ( & :to_hash ) end
39	def get_job_results ( batch_job_url ) @api . utils_reporter . batch_job_utils_used ( ) xml_response = AdsCommon :: Http . get_response ( batch_job_url , @api . config ) begin return sanitize_result ( get_nori ( ) . parse ( xml_response . body ) [ :mutate_response ] [ :rval ] ) rescue return nil end end
1040	def to = ( location ) if location . nil? then raise ArgumentError . new ( "Specimen cannot be moved to an empty location" ) end self . to_container = location . container self . to_row = location . row self . to_column = location . column end
144	def set_custom_color idx , red , green , blue raise 'Invalid format' if [ red , green , blue ] . find { | c | ! ( 0 .. 255 ) . include? ( c ) } @palette [ idx ] = [ red , green , blue ] end
11	def options_call OmniAuth . config . before_options_phase . call ( env ) if OmniAuth . config . before_options_phase verbs = OmniAuth . config . allowed_request_methods . collect ( & :to_s ) . collect ( & :upcase ) . join ( ', ' ) [ 200 , { 'Allow' => verbs } , [ ] ] end
683	def add_vm_to_vapp ( vapp , vm , network_config = { } ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . RecomposeVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "name" => vapp [ :name ] ) { xml . SourcedItem { xml . Source ( "href" => "#{@api_url}/vAppTemplate/vm-#{vm[:template_id]}" , "name" => vm [ :vm_name ] ) xml . InstantiationParams { xml . NetworkConnectionSection ( "xmlns:ovf" => "http://schemas.dmtf.org/ovf/envelope/1" , "type" => "application/vnd.vmware.vcloud.networkConnectionSection+xml" , "href" => "#{@api_url}/vAppTemplate/vm-#{vm[:template_id]}/networkConnectionSection/" ) { xml [ 'ovf' ] . Info "Network config for sourced item" xml . PrimaryNetworkConnectionIndex "0" xml . NetworkConnection ( "network" => network_config [ :name ] ) { xml . NetworkConnectionIndex "0" xml . IsConnected "true" xml . IpAddressAllocationMode ( network_config [ :ip_allocation_mode ] || "POOL" ) } } } xml . NetworkAssignment ( "containerNetwork" => network_config [ :name ] , "innerNetwork" => network_config [ :name ] ) } xml . AllEULAsAccepted "true" } end params = { "method" => :post , "command" => "/vApp/vapp-#{vapp[:id]}/action/recomposeVApp" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.recomposeVAppParams+xml" ) task = response . css ( "Task[operationName='vdcRecomposeVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) task_id end
294	def request_payload ( resource , headers ) if headers format_specified = headers [ 'Content-Type' ] if format_specified . nil? resource . to_xml elsif format_specified . downcase . include? ( 'xml' ) resource . to_xml elsif format_specified . downcase . include? ( 'json' ) resource . to_json else resource . to_xml end else resource . to_xml end end
968	def set_belongs_to_attr ( col , owner , options = { } ) _col = column ( col ) unless belongs_to_synced? ( _col , owner ) _set_attr ( _col . name , owner ) rebuild_relation ( _col , owner , set_inverse : options [ :set_inverse ] ) if _col . polymorphic set_polymorphic_attr ( _col . name , owner ) else _set_attr ( _col . foreign_key , owner ? owner . id : nil ) end end owner end
772	def build_association ( value ) association = @form . create_association ( group : @group . to_s , type : @type . to_s , value : value ) association . persisted = @source . persisted? return association end
342	def show begin @datatable = EffectiveDatatables . find ( params [ :id ] ) @datatable . view = view_context EffectiveDatatables . authorize! ( self , :index , @datatable . collection_class ) render json : @datatable . to_json rescue => e EffectiveDatatables . authorized? ( self , :index , @datatable . try ( :collection_class ) ) render json : error_json ( e ) ExceptionNotifier . notify_exception ( e ) if defined? ( ExceptionNotifier ) raise e if Rails . env . development? end end
110	def init_config ( ) provided_logger = @config . read ( 'library.logger' ) self . logger = ( provided_logger . nil? ) ? create_default_logger ( ) : provided_logger provided_adapter = @config . read ( 'connection.adapter' ) @config . set ( 'connection.adapter' , :httpclient ) if provided_adapter . nil? symbolize_config_value ( 'authentication.method' ) end
156	def create_many! ( client , attributes_array , association = Association . new ( :class => self ) ) response = client . connection . post ( "#{association.generate_path}/create_many" ) do | req | req . body = { resource_name => attributes_array } yield req if block_given? end JobStatus . new_from_response ( client , response ) end
1203	def equal_type ( type , value , args , block ) filter_size_before = filter . size equal ( value , args , block ) types << type if filter_size_before < filter . size end
1016	def retrieve_methods ( script ) code = File . read ( script ) methods = code . scan ( / \s \s \s / ) result = [ ] methods . each do | method | result << method [ 0 ] end result end
335	def to_time second = ( ( 0b11111 & @dos_time ) ) * 2 minute = ( ( 0b111111 << 5 & @dos_time ) >> 5 ) hour = ( ( 0b11111 << 11 & @dos_time ) >> 11 ) day = ( ( 0b11111 << 16 & @dos_time ) >> 16 ) month = ( ( 0b1111 << 21 & @dos_time ) >> 21 ) year = ( ( 0b1111111 << 25 & @dos_time ) >> 25 ) + 1980 return Time . local ( year , month , day , hour , minute , second ) end
154	def save_associations self . class . associations . each do | association_data | association_name = association_data [ :name ] next unless send ( "#{association_name}_used?" ) && association = send ( association_name ) inline_creation = association_data [ :inline ] == :create && new_record? changed = association . is_a? ( Collection ) || association . changed? if association . respond_to? ( :save ) && changed && ! inline_creation && association . save send ( "#{association_name}=" , association ) end if ( association_data [ :inline ] == true || inline_creation ) && changed attributes [ association_name ] = association . to_param end end end
1141	def execute result = eval ( operation ) if outfile if result . is_a? ( SpreadSheet ) result . write ( outfile ) else puts puts "Warning: Result is no spread sheet and not written to file!" puts " To view the result use -p flag" unless print end end if print puts puts "Operation" puts "---------" operation . split ( ';' ) . each { | o | puts o } puts puts "Result" puts "------" if result . nil? || result . empty? puts result . inspect else puts result end puts end end
440	def display_flash_messages ( closable : true , key_matching : { } ) key_matching = DEFAULT_KEY_MATCHING . merge ( key_matching ) key_matching . default = :primary capture do flash . each do | key , value | next if ignored_key? ( key . to_sym ) alert_class = key_matching [ key . to_sym ] concat alert_box ( value , alert_class , closable ) end end end
295	def split ( subnets = 2 ) unless ( 1 .. ( 2 ** @prefix . host_prefix ) ) . include? subnets raise ArgumentError , "Value #{subnets} out of range" end networks = subnet ( newprefix ( subnets ) ) until networks . size == subnets networks = sum_first_found ( networks ) end return networks end
55	def to_statement ( ) @api . utils_reporter . statement_builder_used ( ) validate ( ) ordering = @ascending ? 'ASC' : 'DESC' pql_query = PQLQuery . new pql_query << SELECT % @select unless @select . to_s . empty? pql_query << FROM % @from unless @from . to_s . empty? pql_query << WHERE % @where unless @where . to_s . empty? pql_query << ORDER % [ @order_by , ordering ] unless @order_by . to_s . empty? pql_query << LIMIT % @limit unless @limit . nil? pql_query << OFFSET % @offset unless @offset . nil? return { :query => pql_query . to_s ( ) , :values => @pql_values . values } end
709	def poweroff_vm ( vmId ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . UndeployVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" ) { xml . UndeployPowerAction 'powerOff' } end params = { 'method' => :post , 'command' => "/vApp/vm-#{vmId}/action/undeploy" } response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.undeployVAppParams+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
227	def push_subscribe_folder ( folder , evtypes , url , status_frequency = nil , watermark = nil ) status_frequency ||= 30 psr = { :subscribe_to_all_folders => false , :folder_ids => [ { :id => folder [ :id ] , :change_key => folder [ :change_key ] } ] , :event_types => evtypes , :status_frequency => status_frequency , :uRL => url . to_s } psr [ :watermark ] = watermark if watermark subscribe ( [ { push_subscription_request : psr } ] ) end
1084	def imports raise StreamNotParsed , 'you must parse first' if @tree . nil? imports = statements . select do | node | node . is_a? ( ImportStatement ) end imports . map ( & :to_hash ) end
289	def sign ( tx_template ) return tx_template if @xpubs_by_signer . empty? @xpubs_by_signer . each do | signer_conn , xpubs | tx_template = signer_conn . singleton_batch_request ( '/sign-transaction' , transactions : [ tx_template ] , xpubs : xpubs , ) { | item | Transaction :: Template . new ( item ) } end tx_template end
625	def apply ( style ) if ! style . is_character_style? RTFError . fire ( "Non-character style specified to the " "CommandNode#apply() method." ) end root . colours << style . foreground unless style . foreground . nil? root . colours << style . background unless style . background . nil? root . fonts << style . font unless style . font . nil? node = CommandNode . new ( self , style . prefix ( root . fonts , root . colours ) ) yield node if block_given? self . store ( node ) end
930	def selenium_driver ( browser , browser_options ) target , options = browser_caps ( browser , browser_options ) create_selenium_driver ( target , options ) end
81	def check_for_errors ( response ) if response . code != 200 report_body = response . body check_for_xml_error ( report_body , response . code ) raise AdwordsApi :: Errors :: ReportError . new ( response . code , 'HTTP code: %d, body: %s' % [ response . code , response . body ] ) end return nil end
852	def sales_restriction_type = ( type ) composite = product . sales_restrictions . first if composite . nil? composite = ONIX :: SalesRestriction . new product . sales_restrictions << composite end composite . sales_restriction_type = type end
566	def special ( special_id , options = { } ) response = connection . get do | req | req . url "specials/#{special_id}" , options end return_error_or_body ( response , response . body . response . special ) end
82	def check_for_xml_error ( report_body , response_code ) unless report_body . nil? error_response = get_nori ( ) . parse ( report_body ) if error_response . include? ( :report_download_error ) and error_response [ :report_download_error ] . include? ( :api_error ) api_error = error_response [ :report_download_error ] [ :api_error ] raise AdwordsApi :: Errors :: ReportXmlError . new ( response_code , api_error [ :type ] , api_error [ :trigger ] , api_error [ :field_path ] ) end end end
363	def range ( start , limit , ratio : 8 ) check_greater ( start , 0 ) check_greater ( limit , start ) check_greater ( ratio , 2 ) items = [ ] count = start items << count ( limit / ratio ) . times do count *= ratio break if count >= limit items << count end items << limit if start != limit items end
556	def return_error_or_body ( response , response_body ) if response . body [ 'meta' ] . code == 200 response_body else raise Foursquare2 :: APIError . new ( response . body [ 'meta' ] , response . body [ 'response' ] ) end end
316	def get_oauth_verifier green "****************************************" green "****************************************" green "**** BOT AUTH TIME! ****" green "****************************************" green "****************************************" puts "You need to authorize your bot with Twitter.\n\nPlease login to Twitter under the bot's account. When you're ready, hit Enter.\n\nYour browser will open with the following URL, where you can authorize the bot.\n\n" url = request_token . authorize_url puts url puts "\nIf that doesn't work, you can open the URL in your browser manually." puts "\n\nHit enter to start.\n\n" STDIN . readline . chomp Launchy . open ( url ) sleep ( 2 ) puts "Paste your PIN and hit enter when you have completed authorization.\n\n" print "> " STDIN . readline . chomp . strip rescue Interrupt => e exit end
614	def to_rtf ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}{\\fonttbl" @fonts . each_index do | index | text << "\n#{prefix}{\\f#{index}#{@fonts[index].to_rtf}}" end text << "\n#{prefix}}" text . string end
1317	def key_press ( keys ) dump_caller_stack if keys =~ / \+ / filtered_keys = "^+#{$1}" elsif keys =~ / \+ \+ / filtered_keys = "^+#{$1.downcase}" elsif keys =~ / / filtered_keys = "!+#{$1}" elsif keys =~ / \+ \+ / filtered_keys = "!+#{$1.downcase}" else filtered_keys = keys end filtered_keys = keys . gsub ( "Alt+" , "!+" ) . gsub ( "Ctrl+" , "^+" ) RFormSpec :: Keyboard . press ( filtered_keys ) sleep 0.5 end
951	def encodeWithCoder ( coder ) columns . each do | attr | unless [ :belongs_to , :has_many , :has_one ] . include? column ( attr ) . type value = self . send ( attr ) unless value . nil? coder . encodeObject ( value , forKey : attr . to_s ) end end end end
84	def check_report_definition_hash ( report_definition ) REQUIRED_FIELDS . each do | field | unless report_definition . include? ( field ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , "Required field '%s' is missing in the definition" % field end end unless report_definition [ :selector ] . include? ( :fields ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'Fields list is required' end unless report_definition [ :selector ] [ :fields ] . kind_of? ( Array ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'Fields list must be an array' end if report_definition [ :selector ] [ :fields ] . empty? raise AdwordsApi :: Errors :: InvalidReportDefinitionError , 'At least one field needs to be requested' end end
1153	def can_hold_child? ( storable ) Specimen === storable and storable . specimen_class == specimen_class and specimen_types . include? ( storable . specimen_type ) end
790	def load_environment ( env = RACK_ENV ) require File . join ( root_path , 'config' , 'environments' , 'default.rb' ) env_file = File . join ( root_path , "config" , "environments" , "#{env}.rb" ) if File . exist? ( env_file ) require env_file else debug_msg = "Environment file: #{env_file} couldn't be found, using only the default environment config instead." unless env == 'development' end unless Object . const_defined? ( :LOGGER ) Object . const_set ( :LOGGER , Logger . new ( $stdout ) ) end LOGGER . debug ( debug_msg ) if debug_msg end
715	def get_vdc_by_name ( organization , vdcName ) result = nil organization [ :vdcs ] . each do | vdc | if vdc [ 0 ] . downcase == vdcName . downcase result = get_vdc ( vdc [ 1 ] ) end end result end
1015	def execute scripts = Dir . glob ( File . join ( @script_dir , @script_file ) ) scripts . each do | script | list [ script ] = [ ] if show_methods list [ script ] = retrieve_methods ( script ) end end list end
699	def get_vm_disk_info ( vmid ) response , headers = __get_disk_info ( vmid ) disks = [ ] response . css ( "Item" ) . each do | entry | resource = entry . css ( "rasd|HostResource" ) . first next unless resource name = entry . css ( "rasd|ElementName" ) . first name = name . text unless name . nil? capacity = resource . attribute ( "capacity" ) . text disks << { :name => name , :capacity => "#{capacity} MB" } end disks end
1193	def names ( ids , optional = { } ) region = optional [ :region ] || @sightstone . region ids = ids . join ( ',' ) uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.3/summoner/#{ids}/name" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) names_hash = Hash . new data . each do | id , name | names_hash [ id . to_i ] = name end if block_given? yield names_hash else return names_hash end } end
958	def gte ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator <= item end end
974	def handle_keyboard_will_hide ( notification ) return unless @table if UIEdgeInsetsEqualToEdgeInsets ( @table . contentInset , UIEdgeInsetsZero ) return end animationCurve = notification . userInfo . valueForKey ( UIKeyboardAnimationCurveUserInfoKey ) animationDuration = notification . userInfo . valueForKey ( UIKeyboardAnimationDurationUserInfoKey ) UIView . beginAnimations ( "changeTableViewContentInset" , context : nil ) UIView . setAnimationDuration ( animationDuration ) UIView . setAnimationCurve ( animationCurve ) @table . contentInset = UIEdgeInsetsZero ; UIView . commitAnimations end
92	def extract_exception_data ( soap_fault , exception_name ) exception_type = get_full_type_signature ( exception_name ) process_attributes ( soap_fault , false ) soap_fault = normalize_fields ( soap_fault , exception_type [ :fields ] ) return soap_fault end
964	def validate_presence ( field , value , setting ) if ( value . is_a? ( Numeric ) ) return true elsif value . is_a? ( String ) || value . nil? result = value . nil? || ( ( value . length == 0 ) == setting ) additional_message = setting ? "non-empty" : "non-empty" add_message ( field , "incorrect value supplied for #{field.to_s} -- should be #{additional_message}." ) if result return ! result end return false end
1218	def require_aether * deps @mini_aether_require_spec ||= MiniAether :: Spec . new @mini_aether_require_resolver ||= MiniAether :: Resolver . new spec = @mini_aether_require_spec resolver = @mini_aether_require_resolver if deps . last . kind_of? ( Hash ) hash = deps . pop [ hash [ :source ] , hash [ :sources ] ] . flatten . compact . each do | source | spec . source ( source ) end end deps . each { | coords | spec . jar ( coords ) } resolver . require ( spec . dependencies , spec . sources ) nil end
348	def traverse_dependecies ( traversed_nodes , starting_node , current_node , edges , dependencies , escalation ) dependencies . each do | node_edge | node = node_edge . first traversed_nodes << node if traversed_nodes . include? ( starting_node ) if escalation == :exception raise "Cycle from #{current_node} to #{node}, starting from #{starting_node} passing #{traversed_nodes}" else return true end end return true if traverse_dependecies ( traversed_nodes , starting_node , node , edges , node_edges ( edges , node ) , escalation ) end false end
900	def parse ( argv = [ ] ) @option_parser . parse! ( argv ) options . each do | option | if option . required? and ! option . has_value? Shebang . error ( "The -#{option.short} option is required" ) end end return argv end
1063	def meta_tag ( attr_name , options = { } ) key = normalize_meta_tag_name ( attr_name ) cached_meta_tags [ key ] ||= self . meta_tags . detect { | t | t . name == key } cached_meta_tags [ key ] ||= self . meta_tags . build ( :name => key ) if options [ :build ] cached_meta_tags [ key ] end
896	def delete ( pkg ) iterator = case pkg when Package pkg [ :sigmd5 ] ? each_match ( :sigmd5 , pkg [ :sigmd5 ] ) : each_match ( :label , pkg [ :label ] ) when String each_match ( :label , pkg ) when Dependency each_match ( :label , pkg . name ) . set_iterator_version ( pkg . version ) else raise TypeError , 'illegal argument type' end iterator . each do | header | ret = RPM :: C . rpmtsAddEraseElement ( @ptr , header . ptr , iterator . offset ) raise "Error while adding erase/#{pkg} to transaction" if ret != 0 end end
605	def batch_responses return [ @result ] unless @batch_response @result . map do | r | next r unless r . is_a? ( Hash ) hash = r [ SUCCESS ] || r [ ERROR ] Parse :: Response . new hash end end
563	def add_venuegroup ( options = { } ) response = connection . post do | req | req . url "venuegroups/add" , options end return_error_or_body ( response , response . body . response . venueGroup ) end
253	def cookie_params params = { } cookies . each do | value | value . split ( ';' ) . each do | param | param . strip! name , value = param . split ( '=' , 2 ) unless name =~ RESERVED_COOKIE_NAMES params [ name ] = ( value || '' ) end end end return params end
380	def request ( action , method = :get , payload = { } ) res = TwoCaptcha :: HTTP . request ( url : BASE_URL . gsub ( ':action' , action ) , timeout : timeout , method : method , payload : payload . merge ( key : key , soft_id : 800 ) ) validate_response ( res ) res end
1322	def parents page , parents = self , Array . new while page . parent page = page . parent parents << page end parents end
893	def add_group_result ( result , group : nil ) data = { result : result } if group data [ :group ] = group end if result . present? @group_results << data end end
244	def to_xml ( opts = { } ) builder = Builder :: XmlMarkup . new ( :indent => opts [ :indent ] || 0 ) builder . instruct! builder . cartridge_basiclti_link ( "xmlns" => "http://www.imsglobal.org/xsd/imslticc_v1p0" , "xmlns:blti" => 'http://www.imsglobal.org/xsd/imsbasiclti_v1p0' , "xmlns:lticm" => 'http://www.imsglobal.org/xsd/imslticm_v1p0' , "xmlns:lticp" => 'http://www.imsglobal.org/xsd/imslticp_v1p0' , "xmlns:xsi" => "http://www.w3.org/2001/XMLSchema-instance" , "xsi:schemaLocation" => "http://www.imsglobal.org/xsd/imslticc_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticc_v1p0.xsd http://www.imsglobal.org/xsd/imsbasiclti_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imsbasiclti_v1p0p1.xsd http://www.imsglobal.org/xsd/imslticm_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticm_v1p0.xsd http://www.imsglobal.org/xsd/imslticp_v1p0 http://www.imsglobal.org/xsd/lti/ltiv1p0/imslticp_v1p0.xsd" ) do | blti_node | %w{ title description launch_url secure_launch_url icon secure_icon } . each do | key | blti_node . blti key . to_sym , self . send ( key ) if self . send ( key ) end vendor_keys = %w{ name code description url } if vendor_keys . any? { | k | self . send ( "vendor_#{k}" ) } || vendor_contact_email blti_node . blti :vendor do | v_node | vendor_keys . each do | key | v_node . lticp key . to_sym , self . send ( "vendor_#{key}" ) if self . send ( "vendor_#{key}" ) end if vendor_contact_email v_node . lticp :contact do | c_node | c_node . lticp :name , vendor_contact_name c_node . lticp :email , vendor_contact_email end end end end if ! @custom_params . empty? blti_node . tag! ( "blti:custom" ) do | custom_node | @custom_params . keys . sort . each do | key | val = @custom_params [ key ] custom_node . lticm :property , val , 'name' => key end end end if ! @extensions . empty? @extensions . keys . sort . each do | ext_platform | ext_params = @extensions [ ext_platform ] blti_node . blti ( :extensions , :platform => ext_platform ) do | ext_node | ext_params . keys . sort . each do | key | val = ext_params [ key ] if val . is_a? ( Hash ) ext_node . lticm ( :options , :name => key ) do | type_node | val . keys . sort . each do | p_key | p_val = val [ p_key ] type_node . lticm :property , p_val , 'name' => p_key end end else ext_node . lticm :property , val , 'name' => key end end end end end blti_node . cartridge_bundle ( :identifierref => @cartridge_bundle ) if @cartridge_bundle blti_node . cartridge_icon ( :identifierref => @cartridge_icon ) if @cartridge_icon end end
1349	def followee_of? ( model ) 0 < self . followers . by_model ( model ) . limit ( 1 ) . count * model . followees . by_model ( self ) . limit ( 1 ) . count end
211	def copy_folder ( to_folder_id , * sources ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . CopyFolder { builder . nbuild . parent . default_namespace = @default_ns builder . to_folder_id! ( to_folder_id ) builder . folder_ids! ( sources . flatten ) } end end do_soap_request ( req ) end
993	def wrap ( num_lines ) cleaned = gsub ( / \s / , ' ' ) . strip chars_per_line = cleaned . size / num_lines . to_f lines = [ ] cleaned . split . each do | word | if lines . empty? lines << word else if ( lines [ - 1 ] . size + 1 + word . size ) <= chars_per_line || lines . size >= num_lines lines [ - 1 ] << ' ' unless lines [ - 1 ] . empty? lines [ - 1 ] << word else lines << word end end end Caption . new ( lines . join ( "\n" ) ) end
771	def unique_paths_for ( name , opts = { } ) tally = { } output = [ ] paths_for ( name , opts ) . reverse . each do | ary | tally [ ary [ 1 ] ] ||= ary [ 0 ] output << ary if tally [ ary [ 1 ] ] == ary [ 0 ] end output . reverse end
523	def spam ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "spam" , date , page , page_size , order_field , order_direction ) end
392	def reconnect! ( new_uri = nil ) @connection . close_connection configure ( new_uri ) if new_uri @auto_reconnect = true EM . next_tick { reconnect_connection } end
707	def get_vm ( vmId ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmId}" } response , headers = send_request ( params ) vm_name = response . css ( 'Vm' ) . attribute ( "name" ) vm_name = vm_name . text unless vm_name . nil? status = convert_vapp_status ( response . css ( 'Vm' ) . attribute ( "status" ) . text ) os_desc = response . css ( 'ovf|OperatingSystemSection ovf|Description' ) . first . text networks = { } response . css ( 'NetworkConnection' ) . each do | network | ip = network . css ( 'IpAddress' ) . first ip = ip . text if ip external_ip = network . css ( 'ExternalIpAddress' ) . first external_ip = external_ip . text if external_ip key = "#{network['network']}_#{network.css('NetworkConnectionIndex').first.text}" networks [ key ] = { :index => network . css ( 'NetworkConnectionIndex' ) . first . text , :ip => ip , :external_ip => external_ip , :is_connected => network . css ( 'IsConnected' ) . first . text , :mac_address => network . css ( 'MACAddress' ) . first . text , :ip_allocation_mode => network . css ( 'IpAddressAllocationMode' ) . first . text } end admin_password = response . css ( 'GuestCustomizationSection AdminPassword' ) . first admin_password = admin_password . text if admin_password guest_customizations = { :enabled => response . css ( 'GuestCustomizationSection Enabled' ) . first . text , :admin_passwd_enabled => response . css ( 'GuestCustomizationSection AdminPasswordEnabled' ) . first . text , :admin_passwd_auto => response . css ( 'GuestCustomizationSection AdminPasswordAuto' ) . first . text , :admin_passwd => admin_password , :reset_passwd_required => response . css ( 'GuestCustomizationSection ResetPasswordRequired' ) . first . text , :computer_name => response . css ( 'GuestCustomizationSection ComputerName' ) . first . text } { :id => vmId , :vm_name => vm_name , :os_desc => os_desc , :networks => networks , :guest_customizations => guest_customizations , :status => status } end
221	def get_room_lists req = build_soap! do | type , builder | if ( type == :header ) else builder . room_lists! end end do_soap_request ( req , response_class : EwsSoapRoomlistResponse ) end
321	def bot_config { :consumer_key => ENV [ "chatterbot_consumer_key" ] , :consumer_secret => ENV [ "chatterbot_consumer_secret" ] , :access_token => ENV [ "chatterbot_access_token" ] , :access_token_secret => ENV [ "chatterbot_access_secret" ] || ENV [ "chatterbot_access_token_secret" ] } . delete_if { | k , v | v . nil? } . merge ( slurp_file ( config_file ) || { } ) end
1188	def update ( attributes = { } ) assert_valid_keys ( attributes , :id ) id = attributes . delete ( :id ) update_id ( id ) if id true end
551	def add_tip ( options = { } ) response = connection . post do | req | req . url "tips/add" , options end return_error_or_body ( response , response . body . response . tip ) end
317	def get_api_key green "****************************************" green "****************************************" green "**** API SETUP TIME! ****" green "****************************************" green "****************************************" puts "\n\nWelcome to Chatterbot. Let's walk through the steps to get a bot running.\n\n" puts "Hey, looks like you need to get an API key from Twitter before you can get started.\n\n" app_already_exists = ask_yes_no ( "Have you already set up an app with Twitter?" ) if app_already_exists puts "Terrific! Let's get your bot running!\n\n" else puts "OK, I can help with that!\n\n" send_to_app_creation end print "\n\nPaste the 'Consumer Key' here: " STDOUT . flush config [ :consumer_key ] = STDIN . readline . chomp . strip print "Paste the 'Consumer Secret' here: " STDOUT . flush config [ :consumer_secret ] = STDIN . readline . chomp . strip puts "\n\nNow it's time to authorize your bot!\n\n" if ! app_already_exists && ask_yes_no ( "Do you want to authorize a bot using the account that created the app?" ) puts "OK, on the app page, you can click the 'Create my access token' button to proceed.\n\n" print "Paste the 'Access Token' here: " STDOUT . flush config [ :access_token ] = STDIN . readline . chomp . strip print "\n\nPaste the 'Access Token Secret' here: " STDOUT . flush config [ :access_token_secret ] = STDIN . readline . chomp . strip reset_client @screen_name = client . user . screen_name rescue nil else reset_client end rescue Interrupt => e exit end
662	def log ( error , context , trace = nil ) msg = String . new if error . respond_to? ( :backtrace ) msg << "unhandled exception: #{error.message} (#{context})" backtrace = error . backtrace msg << "\n#{backtrace.join("\n")}" if backtrace msg << "\n#{trace.join("\n")}" if trace else msg << "unhandled exception: #{args}" end @logger . error msg end
914	def pet_stats ( species_id , options = { } ) level = options [ :level ] || 1 breedId = options [ :breedId ] || 3 qualityId = options [ :qualityId ] || 1 BnetApi . make_request_with_params ( "/wow/pet/stats/#{species_id}" , { level : level , breedId : breedId , qualityId : qualityId } ) end
1346	def physical_processor_count @physical_processor_count ||= begin ppc = case RbConfig :: CONFIG [ "target_os" ] when / / IO . popen ( "/usr/sbin/sysctl -n hw.physicalcpu" ) . read . to_i when / / cores = { } phy = 0 IO . read ( "/proc/cpuinfo" ) . scan ( / / ) do | ln | if ln . start_with? ( "physical" ) phy = ln [ / \d / ] elsif ln . start_with? ( "core" ) cid = phy + ":" + ln [ / \d / ] cores [ cid ] = true if not cores [ cid ] end end cores . count when / / require 'win32ole' result_set = WIN32OLE . connect ( "winmgmts://" ) . ExecQuery ( "select NumberOfCores from Win32_Processor" ) result_set . to_enum . collect ( & :NumberOfCores ) . reduce ( :+ ) else processor_count end ppc > 0 ? ppc : processor_count end end
160	def destroy_many! ( client , ids , association = Association . new ( :class => self ) ) response = client . connection . delete ( "#{association.generate_path}/destroy_many" ) do | req | req . params = { :ids => ids . join ( ',' ) } yield req if block_given? end JobStatus . new_from_response ( client , response ) end
809	def read_pins p = FFI :: MemoryPointer . new ( :uchar , 1 ) check_result ( Ftdi . ftdi_read_pins ( ctx , p ) ) p . read_uchar end
438	def spinner ( name , locator ) define_method ( name ) do adapter . spinner ( locator ) . value end define_method ( "#{name}=" ) do | value | adapter . spinner ( locator ) . value = value end define_method ( "increment_#{name}" ) do adapter . spinner ( locator ) . increment end define_method ( "decrement_#{name}" ) do adapter . spinner ( locator ) . decrement end define_method ( "#{name}_view" ) do adapter . spinner ( locator ) . view end end
97	def determine_choice_type_override ( field_data , field_def ) result = nil if field_data . kind_of? ( Hash ) and field_def . include? ( :choices ) result = determine_choice ( field_data , field_def [ :choices ] ) end return result end
586	def all ( constraints = { } ) q = query ( { limit : :max } . merge ( constraints ) ) if block_given? return q . present? ? q . results ( & Proc . new ) : collection . each ( & Proc . new ) end q . present? ? q . results : collection end
77	def make_adhoc_request ( data , cid , & block ) @api . utils_reporter . report_utils_used ( ) url = @api . api_config . adhoc_report_download_url ( @version ) headers = get_report_request_headers ( url , cid ) log_request ( url , headers , data ) if block_given? AdsCommon :: Http . post_stream ( url , data , @api . config , headers , & block ) return nil else response = AdsCommon :: Http . post_response ( url , data , @api . config , headers ) log_headers ( response . headers ) check_for_errors ( response ) return response end end
449	def read ( from , overwrite = false , raise = true ) tempfile = Tempfile . new to = tempfile . path tempfile . unlink get from , to , overwrite , raise File . read to end
1037	def set_map_lat_lon ( latitude , longitude , zoom_level , animated = false ) coordinate = LocationCoordinate . new ( latitude , longitude ) set_center_coordinates ( coordinate , zoom_level , animated ) end
179	def additional_properties! ( addprops ) @nbuild [ NS_EWS_TYPES ] . AdditionalProperties { addprops . each_pair { | k , v | dispatch_field_uri! ( { k => v } , NS_EWS_TYPES ) } } end
649	def read_source ( file , read , size = nil ) if block_given? done = false while ! done and ! file . eof? read << file . getbyte done = yield read [ - 1 ] end else if size != nil if size > 0 total = 0 while ! file . eof? and total < size read << file . getbyte total += 1 end end else file . each_byte { | byte | read << byte } end end end
1325	def manager_ws_uri uri = URI . parse ( manager_uri ) uri . scheme = ( uri . scheme == "https" ? "wss" : "ws" ) uri . path = "/wsapi" return uri . to_s end
943	def button ( value = nil , options = { } ) options [ :button ] ||= { } options [ :container ] ||= { } options [ :container ] [ :class ] = arrayorize ( options [ :container ] [ :class ] ) << :: Formula . block_class @template . content_tag ( :: Formula . block_tag , options [ :container ] ) do submit value , options [ :button ] end end
135	def iterate ( log , farm : Farm :: Empty . new , threads : 1 ) raise 'Log can\'t be nil' if log . nil? raise 'Farm can\'t be nil' if farm . nil? Hands . exec ( threads , all ) do | r , idx | Thread . current . name = "remotes-#{idx}@#{r[:host]}:#{r[:port]}" start = Time . now best = farm . best [ 0 ] node = RemoteNode . new ( host : r [ :host ] , port : r [ :port ] , score : best . nil? ? Score :: ZERO : best , idx : idx , master : master? ( r [ :host ] , r [ :port ] ) , log : log , network : @network ) begin yield node raise 'Took too long to execute' if ( Time . now - start ) . round > @timeout unerror ( r [ :host ] , r [ :port ] ) if node . touched rescue StandardError => e error ( r [ :host ] , r [ :port ] ) if e . is_a? ( RemoteNode :: CantAssert ) || e . is_a? ( Fetch :: Error ) log . debug ( "#{Rainbow(node).red}: \"#{e.message.strip}\" in #{Age.new(start)}" ) else log . info ( "#{Rainbow(node).red}: \"#{e.message.strip}\" in #{Age.new(start)}" ) log . debug ( Backtrace . new ( e ) . to_s ) end remove ( r [ :host ] , r [ :port ] ) if r [ :errors ] > TOLERANCE end end end
1198	def method_missing ( id , * args , & block ) boolean_row_regex = %r{ \( \d \. \( \) \d \) \| \| \( \d \. \( \) \d \) }xi return boolean_row ( $1 , args , block ) if id =~ boolean_row_regex return equal ( $1 , args , block ) if id =~ / \d / return equal_type ( $1 , $2 , args , block ) if id =~ / \d / return range ( $1 , $2 , args , block ) if id =~ / \d \d / return range_type ( $1 , $2 , $3 , args , block ) if id =~ / \d \d / return regex ( $1 , args , block ) if id =~ / \/ \/ / return col_regex ( $1 , $2 , args , block ) if id =~ / \d \/ \/ / return date ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d \d / return date_range ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d \d \d \d \d / return number ( $1 , $2 , $3 , args , block ) if id =~ / \d \d / return number_range ( $1 , $2 , $3 , args , block ) if id =~ / \d \d \d / super end
527	def stringify_hash_keys ( hash ) new_hash = { } hash . each do | key , value | new_hash [ key . to_s ] = if value . is_a? Hash stringify_hash_keys value else value end end new_hash end
149	def << ( item ) fetch if item . is_a? ( Resource ) if item . is_a? ( @resource_class ) @resources << item else raise "this collection is for #{@resource_class}" end else @resources << wrap_resource ( item , true ) end end
873	def []= ( x , y , color ) check_coords ( x , y ) @pixels [ x ] [ y ] = color @hat [ map_coords ( x , y ) ] = color end
413	def complete ( execution_target , source_commandline = ENV . fetch ( 'COMP_LINE' ) , cursor_position = ENV . fetch ( 'COMP_POINT' ) . to_i ) commandline_processor = CommandlineProcessor . process_commandline ( source_commandline , cursor_position , @switches_definition ) if commandline_processor . completing_an_option? complete_option ( commandline_processor , execution_target ) elsif commandline_processor . parsing_error? return else complete_value ( commandline_processor , execution_target ) end end
207	def unsubscribe return true if @subscription_id . nil? resp = ews . unsubscribe ( @subscription_id ) rmsg = resp . response_messages . first if rmsg . success? @subscription_id , @watermark = nil , nil true else raise EwsSubscriptionError , "Could not unsubscribe: #{rmsg.code}: #{rmsg.message_text}" end end
812	def to_g_polygon_api2 ( polygon_options = { } , options = { } ) klass = if options [ :short_class ] 'GPolygon' else 'google.maps.Polygon' end poly_opts = if polygon_options [ :polygon_options ] Geos :: Helper . camelize_keys ( polygon_options [ :polygon_options ] ) end args = [ ( polygon_options [ :stroke_color ] ? "'#{Geos::Helper.escape_javascript(polygon_options[:stroke_color])}'" : 'null' ) , ( polygon_options [ :stroke_weight ] || 'null' ) , ( polygon_options [ :stroke_opacity ] || 'null' ) , ( polygon_options [ :fill_color ] ? "'#{Geos::Helper.escape_javascript(polygon_options[:fill_color])}'" : 'null' ) , ( polygon_options [ :fill_opacity ] || 'null' ) , ( poly_opts ? poly_opts . to_json : 'null' ) ] . join ( ', ' ) "new #{klass}([#{self.to_g_lat_lng_api2(options).join(', ')}], #{args})" end
398	def punsubscribe ( pattern ) @psub_callbacks . delete ( pattern ) @psubs . delete ( pattern ) raw_send_command ( :punsubscribe , [ pattern ] ) return pubsub_deferrable ( pattern ) end
941	def destroy_descendants return if right . nil? || left . nil? || skip_before_destroy if acts_as_nested_set_options [ :dependent ] == :destroy descendants . each do | model | model . skip_before_destroy = true model . destroy end else c = nested_set_scope . where ( left_field_name . to_sym . gt => left , right_field_name . to_sym . lt => right ) scope_class . where ( c . selector ) . delete_all end diff = right - left + 1 scope_class . with ( :safe => true ) . where ( nested_set_scope . where ( left_field_name . to_sym . gt => right ) . selector ) . inc ( left_field_name , - diff ) scope_class . with ( :safe => true ) . where ( nested_set_scope . where ( right_field_name . to_sym . gt => right ) . selector ) . inc ( right_field_name , - diff ) self . skip_before_destroy = true end
1025	def on_session_missing user . authenticate user . fan_of user . update ( :status => user . status ) reset_keepalive end
483	def ft_sugget ( attribute : , prefix : ) key = "#{@model}:#{attribute}" REDI_SEARCH . call ( 'FT.SUGGET' , key , prefix ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
739	def process_media ( part ) file = temp_file ( part ) if part . part_type? =~ / \/ / || part . part_type? == 'application/smil' type , content = transform_text_part ( part ) else if part . part_type? == 'application/octet-stream' type = type_from_filename ( filename? ( part ) ) else type = part . part_type? end content = part . body . decoded end return type , nil if content . nil? || content . empty? log ( "#{self.class} writing file #{file}" , :info ) File . open ( file , 'wb' ) { | f | f . write ( content ) } return type , file end
420	def handle_exceptions ( response ) begin yield rescue => error message = "Exception: #{error}" message << "\n#{error.backtrace.join("\n")}" if ( error . respond_to? ( :backtrace ) ) Server . logger . error ( message ) return if response . isCommitted response . reset response . setStatus ( 500 ) end end
1364	def select ( fields ) if ( fields == [ ] ) || ( fields . nil? ) fields = [ :_id ] end clone . tap { | q | q . options [ :fields ] = fields } end
862	def befriend new_friend run_callbacks :befriend do friendships . create friend_id : new_friend . id , friend_type : new_friend . class . name end end
357	def dependency_attributes_for ( inventory_collections ) attributes = Set . new inventory_collections . each do | inventory_collection | attributes += filtered_dependency_attributes . select { | _key , value | value . include? ( inventory_collection ) } . keys end attributes end
1197	def collect ( opts ) raise Jinx :: ValidationError . new ( "#{self} is already collected" ) if received? specimen_event_parameters . merge! ( extract_event_parameters ( opts ) ) end
416	def report_class ( jacoco_class ) counter = coverage_counter ( jacoco_class ) coverage = ( counter . covered . fdiv ( counter . covered + counter . missed ) * 100 ) . floor required_coverage = minimum_class_coverage_map [ jacoco_class . name ] required_coverage = minimum_class_coverage_percentage if required_coverage . nil? status = coverage_status ( coverage , required_coverage ) { covered : coverage , status : status , required_coverage_percentage : required_coverage } end
618	def to_rtf rtf = ( @text . nil? ? '' : @text . gsub ( "{" , "\\{" ) . gsub ( "}" , "\\}" ) . gsub ( "\\" , "\\\\" ) ) f = lambda { | n | n < 128 ? n . chr : "\\u#{n}\\'3f" } if RUBY_VERSION > "1.9.0" return rtf . encode ( "UTF-16LE" , :undef => :replace ) . each_codepoint . map ( & f ) . join ( '' ) else return rtf . unpack ( 'U*' ) . map ( & f ) . join ( '' ) end end
123	def age list = txns list . empty? ? 0 : ( Time . now - list . min_by ( & :date ) . date ) / ( 60 * 60 ) end
721	def progress ( message , & block ) spinner = %w[ / \\ | ] . cycle print "\e[90m#{message}... \e[0m" result = observing_thread ( block , 0.5 , 0.1 ) do print "\r\e[90m#{message}... #{spinner.next} \e[0m" end puts "\r\e[90m#{message}... OK\e[0m" result rescue StandardError puts "\r\e[90m#{message}...\e[0m \e[31mFAILED\e[0m" raise end
1094	def controlled_value ( value ) return if value . blank? ControlledValues . instance . find ( @attribute , value ) or raise ControlledValueError . new ( "#{@attribute} value '#{value}' is not a recognized controlled value." ) end
313	def reply ( txt , source , params = { } ) debug txt params = { :in_reply_to_status_id => source . id } . merge ( params ) tweet txt , params , source end
1023	def trigger ( command , * args ) command = command . to_sym if command if Event . command? ( command ) event = Event . new ( self , command , args ) handlers = @event_handlers [ event . name ] || [ ] handlers . each do | handler | success = handler . run ( event ) handlers . delete ( handler ) if success && handler . once end end true end
1124	def update_laptop ( name ) assert_valid_values ( name , * %w( mac pc linux chrome iphone cake intel android ) ) api ( 'user.modify' , :laptop => name ) self . attributes = { 'laptop' => name } true end
967	def set_auto_date_field ( field_name ) unless self . class . protect_remote_timestamps? method = "#{field_name}=" self . send ( method , Time . now ) if self . respond_to? ( method ) end end
1344	def mapped_key ( map , key ) load_keymap ( map . to_s ) @maps [ map . to_s ] [ handle_composite ( key ) ] end
284	def to_absolute ( link ) link = link . to_s new_url = begin url . merge ( link ) rescue Exception return end if ( ! new_url . opaque ) && ( path = new_url . path ) if ( new_url . scheme == 'ftp' && ! path . start_with? ( '/' ) ) path . insert ( 0 , '/' ) end new_url . path = URI . expand_path ( path ) end return new_url end
268	def get_page ( url ) url = URI ( url ) prepare_request ( url ) do | session , path , headers | new_page = Page . new ( url , session . get ( path , headers ) ) @cookies . from_page ( new_page ) yield new_page if block_given? return new_page end end
98	def determine_choice ( field_data , field_choices ) result = nil key_name = field_data . keys . first unless key_name . nil? choice = find_named_entry ( field_choices , key_name ) result = choice [ :type ] unless choice . nil? end return result end
338	def extract ( destination , options = { } ) raise IOError , 'non-readable archive' unless readable? raise IOError , 'closed archive' if closed? options [ :directories ] = true unless options . has_key? ( :directories ) options [ :symlinks ] = false unless options . has_key? ( :symlinks ) options [ :overwrite ] = :all unless options [ :overwrite ] == :older || options [ :overwrite ] == :never options [ :create ] = true unless options . has_key? ( :create ) options [ :flatten ] = false unless options . has_key? ( :flatten ) options [ :directories ] = false if options [ :flatten ] directories = [ ] each do | entry | file_path = entry . zip_path file_path = File . basename ( file_path ) if options [ :flatten ] file_path = File . join ( destination , file_path ) file_exists = File . exist? ( file_path ) file_mtime = File . mtime ( file_path ) if file_exists begin if ( ! file_exists && ! options [ :create ] ) || ( file_exists && ( options [ :overwrite ] == :never || options [ :overwrite ] == :older && entry . mtime <= file_mtime ) ) || ( ! options [ :exclude ] . nil? && options [ :exclude ] [ entry ] ) then next end if options [ :password ] . kind_of? ( String ) then entry . password = options [ :password ] elsif ! options [ :password ] . nil? then entry . password = options [ :password ] [ entry ] end if entry . directory? then directories << entry elsif entry . file? || ( entry . symlink? && options [ :symlinks ] ) then entry . extract ( options . merge ( :file_path => file_path ) ) end rescue StandardError => error unless options [ :on_error ] . nil? then case options [ :on_error ] [ entry , error ] when :retry retry when :skip else raise end else raise end end end if options [ :directories ] then directories . sort { | a , b | b . zip_path <=> a . zip_path } . each do | entry | begin entry . extract ( options . merge ( :file_path => File . join ( destination , entry . zip_path ) ) ) rescue StandardError => error unless options [ :on_error ] . nil? then case options [ :on_error ] [ entry , error ] when :retry retry when :skip else raise end else raise end end end end nil end
296	def supernet ( new_prefix ) raise ArgumentError , "New prefix must be smaller than existing prefix" if new_prefix >= @prefix . to_i return self . class . new ( "0.0.0.0/0" ) if new_prefix < 1 return self . class . new ( @address + "/#{new_prefix}" ) . network end
1118	def buddies data = api ( 'user.get_buddies' ) data [ 'buddies' ] . map { | id | User . new ( client , :_id => id ) } end
142	def merge_cells start_row , start_col , end_row , end_col @merged_cells . push [ start_row , end_row , start_col , end_col ] end
666	def open ( vendor_id , product_id , serial_number = nil , options = { } ) dev = get_device ( vendor_id , product_id , serial_number , options ) dev . open if dev end
350	def assign_attributes ( attributes ) attributes . each do | k , v | next if %i( resource_timestamps resource_timestamps_max resource_timestamp ) . include? ( k ) next if %i( resource_counters resource_counters_max resource_counter ) . include? ( k ) if data [ :resource_timestamp ] && attributes [ :resource_timestamp ] assign_only_newest ( :resource_timestamp , :resource_timestamps , attributes , data , k , v ) elsif data [ :resource_counter ] && attributes [ :resource_counter ] assign_only_newest ( :resource_counter , :resource_counters , attributes , data , k , v ) else public_send ( "#{k}=" , v ) end end if attributes [ :resource_timestamp ] assign_full_row_version_attr ( :resource_timestamp , attributes , data ) elsif attributes [ :resource_counter ] assign_full_row_version_attr ( :resource_counter , attributes , data ) end self end
3	def stringify_headers headers headers . inject ( { } ) do | result , ( key , value ) | if key . is_a? Symbol key = key . to_s . split ( / / ) . map ( & :capitalize ) . join ( '-' ) end if 'CONTENT-TYPE' == key . upcase result [ key ] = maybe_convert_extension ( value . to_s ) elsif 'ACCEPT' == key . upcase if value . is_a? Array target_values = value else target_values = value . to_s . split ',' end result [ key ] = target_values . map { | ext | maybe_convert_extension ( ext . to_s . strip ) } . join ( ', ' ) else result [ key ] = value . to_s end result end end
124	def max negative = txns . select { | t | t . amount . negative? } negative . empty? ? 0 : negative . max_by ( & :id ) . id end
1267	def do_move_options ( type ) options = OpenStruct . new opt_parser = OptionParser . new do | opts | if type == 'publish' opts . on ( '-d' , '--keep-draft' , "Keep draft post" ) do | d | options . keep_draft = d end else opts . on ( '-p' , '--keep-post' , "Do not delete post" ) do | p | options . keep_post = p end end opts . on ( '-t' , '--keep-timestamp' , "Keep existing timestamp" ) do | t | options . keep_timestamp = t end end opt_parser . parse! @params options end
303	def consumer_secret ( s ) bot . deprecated "Setting consumer_secret outside of your config file is deprecated!" , Kernel . caller . first bot . config [ :consumer_secret ] = s end
444	def ls ( mask = '' , raise = true ) ls_items = [ ] mask = '"' + mask + '"' if mask . include? ' ' output = exec 'ls ' + mask output . lines . each do | line | ls_item = LsItem . from_line ( line ) ls_items << ls_item if ls_item end ls_items rescue Client :: RuntimeError => e raise e if raise [ ] end
1323	def extract_search_text ( * attributes ) Array ( attributes ) . map { | meth | Nokogiri :: HTML ( self . send ( meth ) ) . xpath ( "//text()" ) . map { | node | text = node . text ; text . try ( :strip! ) ; text } . join ( " " ) } . reject ( & :blank? ) . join ( "\n" ) end
886	def deduplicate ( objects ) losers_to_winners = build_losers_to_winners_map ( objects ) losers_to_winners . each_key do | key | objects . delete ( key ) end objects . each do | id , object | object . foreign_keys . each do | property | value = object [ property ] if value && losers_to_winners . key? ( value ) object [ property ] = losers_to_winners [ value ] end end end objects end
801	def usb_open ( vendor , product ) raise ArgumentError . new ( 'vendor should be Fixnum' ) unless vendor . kind_of? ( Fixnum ) raise ArgumentError . new ( 'product should be Fixnum' ) unless product . kind_of? ( Fixnum ) check_result ( Ftdi . ftdi_usb_open ( ctx , vendor , product ) ) end
664	def enumerate ( vendor_id = 0 , product_id = 0 , options = { } ) raise HIDAPI :: HidApiError , 'not initialized' unless @context if vendor_id . is_a? ( Hash ) || ( vendor_id . is_a? ( String ) && options . empty? ) options = vendor_id vendor_id = 0 product_id = 0 end if product_id . is_a? ( Hash ) || ( product_id . is_a? ( String ) && options . empty? ) options = product_id product_id = 0 end if options . is_a? ( String ) || options . is_a? ( Symbol ) options = { as : options } end unless options . nil? || options . is_a? ( Hash ) raise ArgumentError , 'options hash is invalid' end klass = ( options || { } ) . delete ( :as ) || 'HIDAPI::Device' klass = Object . const_get ( klass ) unless klass == :no_mapping filters = { bClass : HID_CLASS } unless vendor_id . nil? || vendor_id . to_i == 0 filters [ :idVendor ] = vendor_id . to_i end unless product_id . nil? || product_id . to_i == 0 filters [ :idProduct ] = product_id . to_i end list = @context . devices ( filters ) if klass != :no_mapping list . to_a . map { | dev | klass . new ( dev ) } else list . to_a end end
424	def find ( id ) build ( resource_gateway . json_show ( id ) ) rescue RestClient :: ResourceNotFound raise NoSuchModelError , "Can't find any #{endpoint} with id \"#{id}\"" end
780	def create_user ( options = { } ) user = User . new ( options ) user . validate_for_create! body = user_hash ( user . to_hash ) response = oauth_access_token . post ( '/v1/users' , body : body ) User . new ( response . parsed ) end
573	def add_venue ( options = { } ) response = connection . post do | req | req . url "venues/add" , options end return_error_or_body ( response , response . body . response . venue ) end
1100	def add_user ( user ) raise 'InvalidUser' unless user . respond_to? ( :dn ) direct_members = @raw_ldap_data [ Cratus . config . group_member_attribute ] return true if direct_members . include? ( user . dn ) direct_members << user . dn Cratus :: LDAP . replace_attribute ( dn , Cratus . config . group_member_attribute , direct_members . uniq ) end
623	def list ( kind = :bullets ) node = ListNode . new ( self ) yield node . list ( kind ) self . store ( node ) end
864	def unfriend friend run_callbacks :unfriend do friendships . where ( friend_type : friend . class . name ) . where ( friend_id : friend . id ) . first . destroy end end
653	def header ( type = HeaderNode :: UNIVERSAL ) index = 0 if type == HeaderNode :: LEFT_PAGE index = 1 elsif type == HeaderNode :: RIGHT_PAGE index = 2 elsif type == HeaderNode :: FIRST_PAGE index = 3 end @headers [ index ] end
1183	def add_dependency ( key , dependencies = [ ] ) raise SelfDependencyError , "An object's dependencies cannot contain itself" if dependencies . include? key node = node_for_key_or_new key dependencies . each do | dependency | node . addEdge ( node_for_key_or_new ( dependency ) ) end resolve_dependencies end
310	def on_safelist? ( s ) search = from_user ( s ) . downcase safelist . any? { | b | search . include? ( b . downcase ) } end
1090	def process ( object , options = { } ) filtered = super ( object , options ) return nil if filtered . nil? values = filtered . split ( ';' ) values . each_with_index do | value , index | if types [ index ] == 'n' if value =~ / \. / number_value = value . to_f else number_value = value . to_i end values [ index ] = number_value elsif types [ index ] == 'd' if value . strip . empty? date = Date . strptime ( '9999-9-9' , '%Y-%m-%d' ) else begin date = Date . strptime ( value , date_format ) rescue puts "Error #{value}, #{index}" end end values [ index ] = date end end values end
190	def dispatch_update_type! ( update ) type = update . keys . first upd = update [ type ] case type when :append_to_item_field append_to_item_field! ( upd ) when :set_item_field set_item_field! ( upd ) when :delete_item_field delete_item_field! ( upd ) else raise EwsBadArgumentError , "Bad Update type. #{type}" end end
533	def guess_min_peek_range ( tubes ) min = 0 tubes . each do | tube | response = tube . peek ( 'ready' ) if response if min == 0 min = response . id . to_i else min = [ min , response . id . to_i ] . min end end end jitter_min = ( min - ( GUESS_PEEK_RANGE * 0.25 ) ) . to_i [ 1 , jitter_min ] . max end
569	def trending_venues ( ll , options = { } ) options [ :ll ] = ll response = connection . get do | req | req . url "venues/trending" , options end return_error_or_body ( response , response . body . response ) end
840	def to_a [ required , short , long , desc , default , filter , action , cast , valid , validate ] . compact end
819	def matches ( regexp , word ) if regexp . respond_to? ( :match? ) regexp . match? ( word ) else regexp . match ( word ) end end
1157	def attributes ( & block ) raise ArgumentError , "You should provide block" unless block_given? attributes = Morf :: AttributesParser . parse ( & block ) self . class_variable_set ( :@@attributes , attributes ) end
1321	def run logger . info ( "#{self.class.to_s} is starting." ) count_options = self . class . legacy_find_options . dup count_options . delete ( :order ) count_options . delete ( :group ) count_options . delete ( :limit ) count_options . delete ( :offset ) @num_of_records = self . class . legacy_model . count ( count_options ) if self . class . legacy_find_options [ :limit ] && ( @num_of_records > self . class . legacy_find_options [ :limit ] ) run_in_batches @num_of_records else run_normal end logger . info ( "#{self.class.to_s} migrated all #{@num_of_records} records successfully." ) end
1076	def snag assert_current_song sh = digest ( rand ) api ( 'snag.add' , :djid => room . current_dj . id , :songid => id , :roomid => room . id , :section => room . section , :site => 'queue' , :location => 'board' , :in_queue => 'false' , :blocked => 'false' , :vh => digest ( [ client . user . id , room . current_dj . id , id , room . id , 'queue' , 'board' , 'false' , 'false' , sh ] * '/' ) , :sh => sh , :fh => digest ( rand ) ) true end
232	def contentful_user_agent header = { 'sdk' => sdk_info , 'app' => app_info , 'integration' => integration_info , 'platform' => platform_info , 'os' => os_info } result = [ ] header . each do | key , values | next unless values [ :name ] result << format_user_agent_header ( key , values ) end result . join ( ' ' ) end
768	def set_log ( stream = Pancake . configuration . log_stream , log_level = Pancake . configuration . log_level , delimiter = Pancake . configuration . log_delimiter , auto_flush = Pancake . configuration . log_auto_flush ) @buffer = [ ] @delimiter = delimiter @auto_flush = auto_flush if Levels [ log_level ] @level = Levels [ log_level ] else @level = log_level end @log = stream @log . sync = true @mutex = ( @@mutex [ @log ] ||= Mutex . new ) end
561	def add_checkin_reply ( checkin_id , options = { } ) response = connection . post do | req | req . url "checkins/#{checkin_id}/reply" , options end return_error_or_body ( response , response . body . response . reply ) end
1273	def get_server_name ( server , exact = true ) ret = nr_api . get ( url ( 'servers' ) , 'filter[name]' => server ) . body return ret [ 'servers' ] unless exact ret [ 'servers' ] . find { | x | x [ 'name' ] . casecmp ( server ) . zero? } rescue NoMethodError nil end
609	def login! ( passwd = nil ) self . password = passwd || self . password response = client . login ( username . to_s , password . to_s ) apply_attributes! response . result self . session_token . present? end
815	def to_g_marker_api3 ( marker_options = { } , options = { } ) options = { :escape => [ ] , :lat_lng_options => { } } . merge ( options ) opts = Geos :: Helper . camelize_keys ( marker_options ) opts [ :position ] = self . centroid . to_g_lat_lng ( options [ :lat_lng_options ] ) json = Geos :: Helper . escape_json ( opts , Geos :: GoogleMaps :: Api3Constants :: UNESCAPED_MARKER_OPTIONS - options [ :escape ] ) "new google.maps.Marker(#{json})" end
107	def prepare_wrapper ( version , service ) api_config . do_require ( version , service ) endpoint = api_config . endpoint ( version , service ) interface_class_name = api_config . interface_name ( version , service ) wrapper = class_for_path ( interface_class_name ) . new ( @config , endpoint ) auth_handler = get_auth_handler ( ) header_ns = api_config . config ( :header_ns ) + version . to_s soap_handler = soap_header_handler ( auth_handler , version , header_ns , wrapper . namespace ) wrapper . header_handler = soap_handler return wrapper end
1310	def wake_deadline ( start_time , timeout ) timeout = process_timeout ( timeout ) deadline = start_time + timeout if timeout end
1399	def fix_ownership return if Process . uid != 0 begin uid = Etc . getpwnam ( "bixby" ) . uid gid = Etc . getgrnam ( "bixby" ) . gid File . chown ( uid , gid , Bixby . path ( "var" ) , Bixby . path ( "etc" ) ) rescue ArgumentError end end
476	def ft_add record : fields = [ ] @fields . each { | field | fields . push ( field , record . send ( field ) ) } REDI_SEARCH . call ( 'FT.ADD' , @index_name , record . to_global_id . to_s , @score , 'REPLACE' , 'FIELDS' , fields ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
1004	def declare_queue ( channel , exchange , name , key , options = { } ) channel . queue ( name , options ) do | queue | unless default_exchange? ( exchange . name ) queue . bind ( exchange , { :routing_key => key } ) end log . debug ( "Queue #{queue.name.inspect} bound to #{exchange.name.inspect}" ) end end
1232	def process_count File . new ( infile ) . each_with_index do | line , index | result = col_filter . process ( row_filter . process ( line . chomp , row : index ) ) unless result . nil? or result . empty? key = unstring ( line ) . split ( ';' ) . values_at ( * key_columns ) key_value = key_values [ key ] || key_values [ key ] = { name : key , elements : Hash . new ( 0 ) , sum : 0 } result . chomp . split ( ';' ) . each do | column | heading << column if heading . index ( column ) . nil? key_value [ :elements ] [ column ] += 1 key_value [ :sum ] += 1 sums [ column ] += 1 end end end end
779	def options VALID_CONFIG_OPTIONS . inject ( { } ) do | option , key | option . merge! ( key => send ( key ) ) end end
630	def superscript style = CharacterStyle . new style . superscript = true if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
5	def [] ( suburl , & new_block ) case when block_given? then self . class . new ( concat_urls ( url , suburl ) , options , & new_block ) when block then self . class . new ( concat_urls ( url , suburl ) , options , & block ) else self . class . new ( concat_urls ( url , suburl ) , options ) end end
150	def fetch! ( reload = false ) if @resources && ( ! @fetchable || ! reload ) return @resources elsif association && association . options . parent && association . options . parent . new_record? return ( @resources = [ ] ) end @response = get_response ( @query || path ) handle_response ( @response . body ) @resources end
983	def change_column ( table_name , column_name , type , options = { } ) change_column_sql = "ALTER TABLE #{quote_table_name(table_name)} " << "ADD #{quote_column_name(column_name)} #{type_to_sql(type, options[:limit])}" add_column_options! ( change_column_sql , options ) execute ( change_column_sql ) end
808	def read_data chunksize = read_data_chunksize p = FFI :: MemoryPointer . new ( :char , chunksize ) bytes_read = Ftdi . ftdi_read_data ( ctx , p , chunksize ) check_result ( bytes_read ) r = p . read_bytes ( bytes_read ) r . force_encoding ( "ASCII-8BIT" ) if r . respond_to? ( :force_encoding ) r end
611	def first_or_create ( query_attrs = { } , resource_attrs = { } ) conditions ( query_attrs ) klass = Parse :: Model . find_class self . table if klass . blank? raise ArgumentError , "Parse model with class name #{self.table} is not registered." end hash_constraints = constraints ( true ) klass . first_or_create ( hash_constraints , resource_attrs ) end
878	def to_h ( persist : false ) { } . tap do | hash | ( persist ? properties - foreign_objects : properties ) . each do | property | value = self [ property ] if value == false || value . present? hash [ property ] = value end end end end
982	def primary_keys ( table ) if self . class . lowercase_schema_reflection @connection . primary_keys ( table ) . map do | key | key . downcase end else @connection . primary_keys ( table ) end end
1294	def analyze ( string , options = { } ) x = [ ] @fst . _analyze ( string ) do | a | if options [ :symbol_sequence ] x << a . map { | s | s . match ( / / ) ? $1 . to_sym : s } else x << a . join end end x end
820	def dump_points ( cur_path = [ ] ) points = [ self . exterior_ring . dump_points ] self . interior_rings . each do | ring | points . push ( ring . dump_points ) end cur_path . concat ( points ) end
978	def filter ( key , * options ) if options . present? && options . first . instance_of? ( Hash ) options = options . first . with_indifferent_access if options . key? ( :only ) return filter_only_values ( key , options [ :only ] ) elsif options . key? ( :except ) return filter_excluded_values ( key , options [ :except ] ) end else return fetch ( key , * options ) end end
1282	def draft ( opts ) opts = @helper . ensure_open_struct ( opts ) FileUtils . mkdir_p ( DRAFTS_FOLDER ) slug = if opts . slug . nil? || opts . slug . empty? opts . title else opts . slug end slug = @helper . get_slug_for ( slug ) head , ext = @helper . get_layout ( opts . layout ) head . sub! ( / \s / , "title: #{opts.title}" ) head . sub! ( / \s / , "date: #{@helper.get_date_stamp}" ) ext ||= @ext path = File . join ( DRAFTS_FOLDER , "#{slug}.#{ext}" ) f = File . open ( path , "w" ) f . write ( head ) f . close @helper . open_in_editor ( path ) path end
576	def venue_menus ( venue_id , options = { } ) response = connection . get do | req | req . url "venues/#{venue_id}/menu" , options end return_error_or_body ( response , response . body . response ) end
756	def update_video_orientation! photo_output . connectionWithMediaType ( AVMediaTypeVideo ) . tap do | connection | device_orientation = UIDevice . currentDevice . orientation video_orientation = orientation_mapping . fetch ( device_orientation , AVCaptureVideoOrientationPortrait ) connection . setVideoOrientation ( video_orientation ) if connection . videoOrientationSupported? end end
1329	def initialize_database @db = SQLite3 :: Database . new @database_path File . chmod 0600 , @database_path begin @db . execute 'drop table if exists host;' @db . execute <<-SQL SQL sync_host_table rescue File . unlink @database_path raise end end
422	def find ( file , paths ) if ( Pathname . new ( file ) . absolute? ) return unless ( timestamp = mtime ( file ) ) @logger . debug ( "Found #{file}" ) [ file , timestamp ] else paths . each do | path | fullpath = File . expand_path ( ( File . join ( path , file ) ) ) next unless ( timestamp = mtime ( fullpath ) ) @logger . debug ( "Found #{file} in #{fullpath}" ) return ( [ fullpath , timestamp ] ) end return ( nil ) end end
346	def build_feedback_edge_set ( edges , fixed_edges ) edges = edges . dup acyclic_edges = fixed_edges . dup feedback_edge_set = [ ] while edges . present? edge = edges . shift if detect_cycle ( edge , acyclic_edges ) feedback_edge_set << edge else acyclic_edges << edge end end feedback_edge_set end
1062	def champions ( optional = { } ) region = optional [ :region ] || @sightstone . region free_to_play = optional [ :free_to_play ] || false uri = "https://prod.api.pvp.net/api/lol/#{region}/v1.1/champion" response = _get_api_response ( uri , { 'freeToPlay' => free_to_play } ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) champions = [ ] data [ 'champions' ] . each do | champ | champions << Champion . new ( champ ) end if block_given? yield champions else return champions end } end
1163	def league_entries ( summoner , optional = { } ) region = optional [ :region ] || @sightstone . region id = if summoner . is_a? Summoner summoner . id else summoner end uri = "https://prod.api.pvp.net/api/lol/#{region}/v2.3/league/by-summoner/#{id}/entry" response = _get_api_response ( uri ) _parse_response ( response ) { | resp | data = JSON . parse ( resp ) entries = [ ] data . each do | entry | entries << LeagueItem . new ( entry ) end if block_given? yield entries else return entries end } end
936	def extract_device ( value ) device = value . to_s . split ( '|' ) [ 2 ] if value . to_s . include? '|' sauce_devices @sauce_devices [ device ] if not device . nil? end
971	def get_nokogiri ( path ) uri = URI . join ( 'https://stellar.mit.edu' , path ) raw_html = @mech . get_file uri Nokogiri . HTML raw_html , uri . to_s end
57	def to_h { :date => AdManagerApi :: AdManagerDate . new ( @api , @time . year , @time . month , @time . day ) . to_h , :hour => @time . hour , :minute => @time . min , :second => @time . sec , :time_zone_id => @timezone . identifier } end
1306	def INJECT ( adjuster1 , adjuster2 , * adjusters ) adjusters = [ adjuster1 , adjuster2 , * adjusters ] unless adjusters . all? { | f | adjustable? f } raise TypeError , 'wrong object for adjuster' end -> v { adjusters . reduce ( v ) { | ret , adjuster | adjuster . call ret } } end
212	def move_folder ( to_folder_id , * sources ) req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . MoveFolder { builder . nbuild . parent . default_namespace = @default_ns builder . to_folder_id! ( to_folder_id ) builder . folder_ids! ( sources . flatten ) } end end do_soap_request ( req ) end
1330	def execute_hook_action @rename = false name = @rec [ 'host' ] [ 'name' ] id = @rec [ 'host' ] [ 'id' ] case @action when 'create' sql = "insert into host (id, name) values (?, ?)" params = [ id , name ] when 'update' @old_name = @db . get_first_row ( 'select name from host where id = ?' , id ) @old_name = @old_name [ 0 ] unless @old_name . nil? if @old_name . nil? warn 'received an update for a non-existent host' else @rename = @old_name != name end debug "checking for a rename: old=#{@old_name} new=#{name} rename?=#{@rename}" sql = 'update host set name = ? where id = ?' params = [ name , id ] when 'destroy' sql = 'delete from host where id = ?' params = [ id ] else raise ArgumentError , "unsupported action: #{ARGV[0]}" end debug "updating database; id=#{id} name=#{name} sql=#{sql}" stm = @db . prepare sql stm . bind_params * params stm . execute end
750	def get_transfer ( type ) type = type [ 0 ] . upcase + type [ 1 .. - 1 ] try_require ( type ) Transfer . const_get ( type ) . new ( @options , @files ) end
1305	def WHEN ( condition , adjuster ) unless Validation . conditionable? condition raise TypeError , 'wrong object for condition' end unless Validation . adjustable? adjuster raise TypeError , 'wrong object for adjuster' end -> v { _valid? ( condition , v ) ? adjuster . call ( v ) : v } end
133	def clean ( max : 24 * 60 * 60 ) Futex . new ( file , log : @log ) . open do list = load list . reject! do | s | if s [ :time ] >= Time . now - max false else @log . debug ( "Copy ##{s[:name]}/#{s[:host]}:#{s[:port]} is too old, over #{Age.new(s[:time])}" ) true end end save ( list ) deleted = 0 files . each do | f | next unless list . find { | s | s [ :name ] == File . basename ( f , Copies :: EXT ) } . nil? file = File . join ( @dir , f ) size = File . size ( file ) File . delete ( file ) @log . debug ( "Copy at #{f} deleted: #{Size.new(size)}" ) deleted += 1 end list . select! do | s | cp = File . join ( @dir , "#{s[:name]}#{Copies::EXT}" ) wallet = Wallet . new ( cp ) begin wallet . refurbish raise "Invalid protocol #{wallet.protocol} in #{cp}" unless wallet . protocol == Zold :: PROTOCOL true rescue StandardError => e FileUtils . rm_rf ( cp ) @log . debug ( "Copy at #{cp} deleted: #{Backtrace.new(e)}" ) deleted += 1 false end end save ( list ) deleted end end
286	def get ( options = { } , & block ) response = http . get_uri ( options , & block ) handle_response ( response ) end
679	def get_vapp_by_name ( organization , vdcName , vAppName ) result = nil get_vdc_by_name ( organization , vdcName ) [ :vapps ] . each do | vapp | if vapp [ 0 ] . downcase == vAppName . downcase result = get_vapp ( vapp [ 1 ] ) end end result end
714	def get_vdc_id_by_name ( organization , vdcName ) result = nil organization [ :vdcs ] . each do | vdc | if vdc [ 0 ] . downcase == vdcName . downcase result = vdc [ 1 ] end end result end
593	def fetch! ( compiled_query ) response = client . find_objects ( @table , compiled_query . as_json , _opts ) if response . error? puts "[ParseQuery] #{response.error}" end response end
1181	def create_sum_row line = [ ] header . clear_header_cols . each do | col | line << @sum_row [ col ] || "" end line . flatten . join ( ';' ) end
677	def _output_paths ( file ) input_file_dir = File . dirname ( file ) file_name = _output_filename ( file ) file_name = "#{file_name}.html" if _append_html_ext_to_output_path? ( file_name ) input_file_dir = input_file_dir . gsub ( Regexp . new ( "#{options[:input]}(\/){0,1}" ) , '' ) if options [ :input ] if options [ :output ] Array ( options [ :output ] ) . map do | output_dir | File . join ( output_dir , input_file_dir , file_name ) end else if input_file_dir == '' [ file_name ] else [ File . join ( input_file_dir , file_name ) ] end end end
1152	def sh ( command , as : nil , quiet : false ) as ||= @user output = "" synchronize do log . debug "sh #{command}" , quiet : quiet result = nil ch = ssh ( as ) . open_channel do | ch | ch . request_pty do | ch , success | "failed to acquire pty" unless success ch . exec ( command ) do | _ , success | fail "failed to execute command" unless success ch . on_data do | _ , data | log . trace "received #{data.bytesize} bytes stdout" , quiet : quiet output << data end ch . on_extended_data do | _ , _ , data | log . trace "received #{data.bytesize} bytes stderr" , quiet : quiet output << data . colorize ( :red ) end ch . on_request ( "exit-status" ) do | _ , data | result = data . read_long log . trace "received exit-status #{result}" , quiet : quiet end end end end ch . wait fail FailedCommand , output if result != 0 output end end
601	def all_read! will_change! permissions . keys . each do | perm | permissions [ perm ] . read! true end end
1255	def cachier! ( var = nil ) if var && instance_variable_get ( "@#{var}" ) remove_instance_variable ( "@#{var}" ) else instance_variables . each { | x | remove_instance_variable ( x ) } end end
1042	def output o = if @output . nil? './lib/steamd' else @output end raise 'output must be a directory' unless File . directory? ( o ) File . expand_path ( o ) end
571	def venue_categories ( options = { } ) response = connection . get do | req | req . url "venues/categories" , options end return_error_or_body ( response , response . body . response . categories ) end
148	def _side_load ( name , klass , resources ) associations = klass . associated_with ( name ) associations . each do | association | association . side_load ( resources , @included [ name ] ) end resources . each do | resource | loaded_associations = resource . loaded_associations loaded_associations . each do | association | loaded = resource . send ( association [ :name ] ) next unless loaded _side_load ( name , association [ :class ] , to_array ( loaded ) ) end end end
1093	def get_content ( & func ) data = Array . new @feed . to_a . each do | single_post | begin if func . nil? data << clean_post_content ( single_post , & @message_parser ) else data << clean_post_content ( single_post , & func ) end rescue end end data end
417	def total_coverage ( report_path ) jacoco_report = Nokogiri :: XML ( File . open ( report_path ) ) report = jacoco_report . xpath ( 'report/counter' ) . select { | item | item [ 'type' ] == 'INSTRUCTION' } missed_instructions = report . first [ 'missed' ] . to_f covered_instructions = report . first [ 'covered' ] . to_f total_instructions = missed_instructions + covered_instructions covered_percentage = ( covered_instructions * 100 / total_instructions ) . round ( 2 ) coverage_status = coverage_status ( covered_percentage , minimum_project_coverage_percentage ) { covered : covered_percentage , status : coverage_status } end
695	def wait_task_completion ( taskid ) errormsg = nil task = { } loop do task = get_task ( taskid ) break if task [ :status ] != 'running' sleep 1 end if task [ :status ] == 'error' errormsg = task [ :response ] . css ( "Error" ) . first errormsg = "Error code #{errormsg['majorErrorCode']} - #{errormsg['message']}" end { :status => task [ :status ] , :errormsg => errormsg , :start_time => task [ :start_time ] , :end_time => task [ :end_time ] } end
1045	def enable if disabled? Cratus :: LDAP . replace_attribute ( dn , Cratus . config . user_account_control_attribute , [ '512' ] ) refresh else true end end
684	def clone_vapp ( vdc_id , source_vapp_id , name , deploy = "true" , poweron = "false" , linked = "false" , delete_source = "false" ) params = { "method" => :post , "command" => "/vdc/#{vdc_id}/action/cloneVApp" } builder = Nokogiri :: XML :: Builder . new do | xml | xml . CloneVAppParams ( "xmlns" => "http://www.vmware.com/vcloud/v1.5" , "name" => name , "deploy" => deploy , "linkedClone" => linked , "powerOn" => poweron ) { xml . Source "href" => "#{@api_url}/vApp/vapp-#{source_vapp_id}" xml . IsSourceDelete delete_source } end response , headers = send_request ( params , builder . to_xml , "application/vnd.vmware.vcloud.cloneVAppParams+xml" ) vapp_id = headers [ :location ] . gsub ( / \/ \/ \- / , "" ) task = response . css ( "VApp Task[operationName='vdcCopyVapp']" ) . first task_id = task [ "href" ] . gsub ( / \/ \/ / , "" ) { :vapp_id => vapp_id , :task_id => task_id } end
657	def to_s ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}Colour Table (#{@colours.size} colours)" @colours . each { | colour | text << "\n#{prefix} #{colour}" } text . string end
938	def extract_multiple_numbers ( str ) return [ ] if str == '' || str . nil? str . scan ( STDNUMPAT_MULTIPLE ) . flatten . map { | i | i . gsub ( / \- / , '' ) . upcase } end
547	def user_set_friend_pings ( user_id , value ) response = connection . post do | req | req . url "users/#{user_id}/setpings" , value end return_error_or_body ( response , response . body . response ) end
173	def folder_shape! ( folder_shape ) @nbuild . FolderShape { @nbuild . parent . default_namespace = @default_ns base_shape! ( folder_shape [ :base_shape ] ) if ( folder_shape [ :additional_properties ] ) additional_properties! ( folder_shape [ :additional_properties ] ) end } end
1079	def add_child_type ( type ) case type when CaTissue :: StorageType then add_storage_type ( type ) when CaTissue :: SpecimenArrayType then add_specimen_array_type ( type ) when String then add_specimen_class ( type ) else raise ArgumentError . new ( "Storage type child not supported - #{type}" ) end self end
1122	def blocks data = api ( 'block.list_all' ) data [ 'blocks' ] . map { | attrs | User . new ( client , attrs [ 'block' ] [ 'blocked' ] ) } end
1291	def gen_usage puts 'Usage:' puts ' poole [ACTION] [ARG]' puts '' puts 'Actions:' puts ' draft Create a new draft in _drafts with title SLUG' puts ' post Create a new timestamped post in _posts with title SLUG' puts ' publish Publish the draft with SLUG, timestamping appropriately' puts ' unpublish Move a post to _drafts, untimestamping appropriately' exit end
502	def active ( date = "" , page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" , include_tracking_preference = false ) paged_result_by_date ( "active" , date , page , page_size , order_field , order_direction , include_tracking_preference ) end
526	def flush ( async = true ) loop do @lock . synchronize do @queue . synchronize do @results_unprocessed += 1 end @queue << @buffer @buffer = [ ] end if not async LOGGER . info ( 'Starting synchronous flush' ) @queue . synchronize do @all_processed_condition . wait_while { @results_unprocessed > 0 } LOGGER . info ( 'Finished synchronous flush' ) end end break if @buffer . size < 1 end end
761	def attribute_lookup ( assoc ) group_data = @map [ assoc . group . to_sym ] return nil unless group_data attribute = group_data [ assoc . type . to_sym ] return attribute end
280	def each_meta_redirect return enum_for ( __method__ ) unless block_given? if ( html? && doc ) search ( '//meta[@http-equiv and @content]' ) . each do | node | if node . get_attribute ( 'http-equiv' ) =~ / /i content = node . get_attribute ( 'content' ) if ( redirect = content . match ( / \S / ) ) yield redirect [ 1 ] end end end end end
58	def method_missing ( name , * args , & block ) restricted_functions = [ :dst? , :getgm , :getlocal , :getutc , :gmt , :gmtime , :gmtoff , :isdst , :localtime , :utc ] if restricted_functions . include? name raise NoMethodError , 'undefined method %s for %s' % [ name , self ] end result = @time . send ( name , * args , & block ) if result . is_a? Time return self . class . new ( @api , result , @timezone . identifier ) else return result end end
1182	def _rewrap_array ( result ) if @wrap_results newcoll = @collection . class . new ( result ) self . class . new ( newcoll , @wrapfunc_in , @wrapfunc_out ) else @collection . class . new ( result . map ( & @wrapfunc_out ) ) end end
76	def get_report_response_with_awql ( report_query , format , cid , & block ) data = '__rdquery=%s&__fmt=%s' % [ CGI . escape ( report_query ) , CGI . escape ( format ) ] return make_adhoc_request ( data , cid , & block ) end
90	def get_extra_user_agents ( ) @extra_user_agents_lock . synchronize do user_agents = @extra_user_agents . collect do | k , v | v . nil? ? k : '%s/%s' % [ k , v ] end @extra_user_agents . clear return user_agents end end
427	def save! if persisted? update ( to_h ) else self . id = resource_gateway . create ( to_h ) end self rescue RestClient :: Exception => e raise_failed_request_error ( e ) end
1279	def channel if ( channel = Thread . current [ CHANNEL_KEY ] ) . try ( :open? ) channel else new_channel = connection . channel new_channel . confirm_select new_channel . prefetch ( Isimud . prefetch_count ) if Isimud . prefetch_count Thread . current [ CHANNEL_KEY ] = new_channel end end
641	def top_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ TOP ] = size . to_i else @borders [ TOP ] = nil end end
1056	def add_to_existing_container ( storable ) if storage_type . nil? then raise Jinx :: ValidationError . new ( "Cannot add #{storable.qp} to #{qp} with missing storage type" ) end scs = subcontainers . sort { | sc1 , sc2 | sc1 . position . coordinate <=> sc2 . position . coordinate } logger . debug { "Looking for a #{self} subcontainer from among #{scs.pp_s} to place #{storable.qp}..." } unless scs . empty? sc = scs . detect do | sc | if identifier and sc . identifier == identifier then raise Jinx :: ValidationError . new ( "#{self} has a circular containment reference to subcontainer #{sc}" ) end sc . add_to_existing_container ( storable ) if StorageContainer === sc end if sc then logger . debug { "#{self} subcontainer #{sc} stored #{storable.qp}." } self elsif can_hold_child? ( storable ) then logger . debug { "#{self} can hold #{storable.qp}." } add_local ( storable ) else logger . debug { "Neither #{self} of type #{storage_type.name} nor its subcontainers can hold #{storable.qp}." } nil end end
1355	def pick ( number , * cards ) ordered = cards . flatten . map do | card | i = card_preference . map { | preference | card . type == preference } . index ( true ) { card : card , index : i } end ordered . sort_by { | h | h [ :index ] || 99 } . first ( number ) . map { | h | h [ :card ] } end
889	def build_dependency_graph ( objects ) DependencyGraph . new . tap do | graph | objects . each do | id , object | graph [ id ] = [ ] object . foreign_keys . each do | property | value = object [ property ] if value graph [ id ] << value end end end end end
1055	def find_subcontainer ( name , type ) logger . debug { "Finding box with name #{name}..." } ctr = CaTissue :: StorageContainer . new ( :name => name ) if ctr . find then logger . debug { "Container found: #{ctr}." } else logger . debug { "Container not found: #{name}." } create_subcontainer ( name , type ) end box end
141	def update_row idx , * cells res = if row = @rows [ idx ] row [ 0 , cells . size ] = cells row else Row . new self , idx , cells end row_updated idx , res res end
624	def footnote ( text ) if ! text . nil? and text != '' mark = CommandNode . new ( self , '\fs16\up6\chftn' , nil , false ) note = CommandNode . new ( self , '\footnote {\fs16\up6\chftn}' , nil , false ) note . paragraph << text self . store ( mark ) self . store ( note ) end end
535	def managed_pages ( options = { } ) response = connection . get do | req | req . url "pages/managing" , options end return_error_or_body ( response , response . body . response . managing ) end
994	def consume_api @dados = RestClient :: Request . execute ( method : :get , url : 'https://finance.yahoo.com/webservice/v1/symbols/allcurrencies/quote' ) hash_local = Hash . new @hash_local = Hash . from_xml ( @dados ) end
1269	def nr_api @conn ||= Faraday :: Connection . new ( 'https://api.newrelic.com' , conn_opts ) do | client | client . use Faraday :: Response :: RaiseError client . use FaradayMiddleware :: EncodeJson client . use FaradayMiddleware :: ParseJson , content_type : / \b / client . response :logger if Config . environment . to_s . casecmp ( 'development' ) . zero? client . adapter Faraday . default_adapter end end
712	def get_organizations params = { 'method' => :get , 'command' => '/org' } response , headers = send_request ( params ) orgs = response . css ( 'OrgList Org' ) results = { } orgs . each do | org | results [ org [ 'name' ] ] = org [ 'href' ] . gsub ( / \/ \/ / , "" ) end results end
1032	def parse_and_create parsed_feed = parse_feed return false unless parsed_feed feed = create_feed ( parsed_feed ) create_articles ( feed , parsed_feed ) feed end
169	def experiment ( name ) id = name . to_s . downcase . gsub ( / \W / , "_" ) . to_sym Vanity . logger . warn ( "Deprecated: Please call experiment method with experiment identifier (a Ruby symbol)" ) unless id == name experiments [ id . to_sym ] or raise NoExperimentError , "No experiment #{id}" end
37	def initialize_url ( batch_job_url ) headers = DEFAULT_HEADERS headers [ 'Content-Length' ] = 0 headers [ 'x-goog-resumable' ] = 'start' response = AdsCommon :: Http . post_response ( batch_job_url , '' , @api . config , headers ) return response . headers [ 'Location' ] end
678	def _output_filename ( file ) sub_strings = File . basename ( file ) . split ( '.' ) base_name , extensions = sub_strings . first , sub_strings [ 1 .. - 1 ] if extensions . last == 'haml' extensions . pop if extensions . empty? [ base_name , options [ :default_ext ] ] . join ( '.' ) else [ base_name , extensions ] . flatten . join ( '.' ) end else [ base_name , extensions , options [ :default_ext ] ] . flatten . compact . join ( '.' ) end end
470	def submit ( request ) url = request . to_url ActiveSupport :: Notifications . instrument ( "amazon_flex_pay.api" , :action => request . action_name , :request => url ) do | payload | begin http = RestClient . get ( url ) payload [ :response ] = http . body payload [ :code ] = http . code response = request . class :: Response . from_xml ( http . body ) response . request = request response rescue RestClient :: BadRequest , RestClient :: Unauthorized , RestClient :: Forbidden => e payload [ :response ] = e . http_body payload [ :code ] = e . http_code er = AmazonFlexPay :: API :: BaseRequest :: ErrorResponse . from_xml ( e . response . body ) klass = AmazonFlexPay :: API . const_get ( er . errors . first . code ) raise klass . new ( er . errors . first . code , er . errors . first . message , er . request_id , request ) end end end
332	def reset! registered_keys . each { | key | ClassConstants . new ( key ) . deconstantize } @registered_keys = [ ] container . _container . clear end
1176	def create_table_data processed_header = false File . open ( infile ) . each_with_index do | line , index | line = line . chomp next if line . empty? line = unstring ( line ) . chomp header . process line , processed_header unless processed_header processed_header = true next end next if row_filter . process ( line , row : index ) . nil? @columns = line . split ( ';' ) create_row ( create_key , line ) end end
1022	def search_song ( query , options = { } ) assert_valid_keys ( options , :artist , :duration , :page ) options = { :page => 1 } . merge ( options ) raise ( APIError , 'User must be in a room to search for songs' ) unless room if artist = options [ :artist ] query = "title: #{query}" query << " artist: #{artist}" end query << " duration: #{options[:duration]}" if options [ :duration ] api ( 'file.search' , :query => query , :page => options [ :page ] ) conditions = { 'query' => query } EventMachine . add_timer ( @timeout ) do trigger ( :search_failed , conditions ) end if @timeout songs = wait do | & resume | on ( :search_completed , :once => true , :if => conditions ) { | songs | resume . call ( songs ) } on ( :search_failed , :once => true , :if => conditions ) { resume . call } end @event_handlers [ :search_completed ] . delete_if { | handler | handler . conditions == conditions } @event_handlers [ :search_failed ] . delete_if { | handler | handler . conditions == conditions } songs || raise ( APIError , 'Search failed to complete' ) end
1158	def resolve ( dep_hashes , repos ) logger . info 'resolving dependencies' session = MavenRepositorySystemSession . new local_repo = LocalRepository . new ( local_repository_path ) local_manager = @system . newLocalRepositoryManager ( local_repo ) session . setLocalRepositoryManager ( local_manager ) collect_req = CollectRequest . new dep_hashes . each do | hash | dep = Dependency . new new_artifact ( hash ) , 'compile' collect_req . addDependency dep logger . debug 'requested {}' , dep end repos . each do | uri | repo = RemoteRepository . new ( uri . object_id . to_s , 'default' , uri ) collect_req . addRepository repo logger . info 'added repository {}' , repo . getUrl enabled = [ ] enabled << 'releases' if repo . getPolicy ( false ) . isEnabled enabled << 'snapshots' if repo . getPolicy ( true ) . isEnabled logger . debug '{}' , enabled . join ( '+' ) end node = @system . collectDependencies ( session , collect_req ) . getRoot dependency_req = DependencyRequest . new ( node , nil ) @system . resolveDependencies ( session , dependency_req ) nlg = PreorderNodeListGenerator . new node . accept nlg if logger . isDebugEnabled total_size = 0 nlg . getArtifacts ( false ) . each do | artifact | file = artifact . file size = File . stat ( artifact . file . absolute_path ) . size total_size += size logger . debug ( "Using %0.2f %s" % [ size / MiB_PER_BYTE , artifact ] ) end logger . debug ( ' -----' ) logger . debug ( " %0.2f MiB total" % [ total_size / MiB_PER_BYTE ] ) else nlg . getArtifacts ( false ) . each do | artifact | logger . info 'Using {}' , artifact end end nlg . getFiles . map { | e | e . to_s } end
1208	def date_range ( col , start_date , end_date , args , block ) operation = " Date.strptime(\"#{start_date}\", \"#{date_format}\") " + "<= Date.strptime(\"[value]\", \"#{date_format}\") && " + " Date.strptime(\"[value]\", \"#{date_format}\") " + "<= Date.strptime(\"#{end_date}\", \"#{date_format}\")" pivot [ "#{start_date}-#{end_date}" ] = { col : col , operation : operation } end
139	def protect! password = '' @protected = true password = password . to_s if password . size == 0 @password_hash = 0 else @password_hash = Excel :: Password . password_hash password end end
298	def - ( oth ) if oth . is_a? Integer self . prefix - oth else ( self . prefix - oth . prefix ) . abs end end
1088	def pull_text_until_end texts = [ ] loop do res = pull break unless res . text? texts << res [ 0 ] end texts . join end
498	def update_custom_field ( custom_field_key , field_name , visible_in_preference_center ) custom_field_key = CGI . escape ( custom_field_key ) options = { :body => { :FieldName => field_name , :VisibleInPreferenceCenter => visible_in_preference_center } . to_json } response = put "customfields/#{custom_field_key}" , options response . parsed_response end
336	def each ( & b ) raise IOError , 'non-readable archive' unless readable? raise IOError , 'closed archive' if closed? unless @parse_complete then parse ( @archive ) @parse_complete = true end @entries . each ( & b ) end
1268	def resolve_links ( text ) html = Nokogiri :: HTML . fragment ( text ) html . css ( "a[href]" ) . each do | link | href = URI ( link [ "href" ] ) next unless href . relative? && markup_for_file ( nil , href . path ) == :markdown link . replace "{file:#{href} #{link.inner_html}}" end super ( html . to_s ) end
1034	def normalize_scope ( object , context ) return object if object . is_a? ( Symbol ) @scope_recognizers . each_pair do | name , recognizers | return name if recognizers . any? { | r | lambda ( & r ) . call ( context , object ) } end @scope_converters . each do | converter | scope = lambda ( & converter ) . call ( context , object ) return normalize_scope ( scope , converter ) unless scope . nil? end return :default end
805	def write_data_chunksize p = FFI :: MemoryPointer . new ( :uint , 1 ) check_result ( Ftdi . ftdi_write_data_get_chunksize ( ctx , p ) ) p . read_uint end
668	def open_path ( path , options = { } ) dev = get_device_by_path ( path , options ) dev . open if dev end
264	def [] ( url ) url = URI ( url ) key = [ url . scheme , url . host , url . port ] paths = @credentials [ key ] return nil unless paths ordered_paths = paths . keys . sort_by { | path_key | - path_key . length } path_dirs = URI . expand_path ( url . path ) . split ( '/' ) ordered_paths . each do | path | return paths [ path ] if path_dirs [ 0 , path . length ] == path end return nil end
1277	def create_queue ( queue_name , exchange_name , options = { } ) queue_options = options [ :queue_options ] || { durable : true } routing_keys = options [ :routing_keys ] || [ ] log "Isimud::BunnyClient: create_queue #{queue_name}: queue_options=#{queue_options.inspect}" queue = find_queue ( queue_name , queue_options ) bind_routing_keys ( queue , exchange_name , routing_keys ) if routing_keys . any? queue end
83	def report_definition_to_xml ( report_definition ) check_report_definition_hash ( report_definition ) add_report_definition_hash_order ( report_definition ) begin return Gyoku . xml ( { :report_definition => report_definition } ) rescue ArgumentError => e if e . message . include? ( "order!" ) unknown_fields = e . message . slice ( e . message . index ( '[' ) , e . message . length ) raise AdwordsApi :: Errors :: InvalidReportDefinitionError , "Unknown report definition field(s): %s" % unknown_fields end raise e end end
1132	def load data = api ( 'user.get_prefs' ) self . attributes = data [ 'result' ] . inject ( { } ) do | result , ( preference , value , * ) | result [ preference ] = value result end super end
1367	def follower_of? ( model ) 0 < self . followees . by_model ( model ) . limit ( 1 ) . count * model . followers . by_model ( self ) . limit ( 1 ) . count end
755	def save_to_photo_library ( jpeg_data , & block ) photo_library . performChanges ( -> { image = UIImage . imageWithData ( jpeg_data ) PHAssetChangeRequest . creationRequestForAssetFromImage ( image ) } , completionHandler : -> ( success , error ) { if error error_callback . call ( error ) else block . call ( nil ) end } ) end
836	def []= ( name , schema ) case name when Symbol , String , Regexp if @properties . has_key? ( name ) raise InvalidSchemaError , "property '#{name}' already defined" end @properties [ name ] = schema else raise InvalidSchemaError , "unsupported property name type #{name}:#{name.class}" end end
91	def extract_header_data ( response ) header_type = get_full_type_signature ( :SoapResponseHeader ) headers = response . header [ :response_header ] . dup process_attributes ( headers , false ) headers = normalize_fields ( headers , header_type [ :fields ] ) return headers end
145	def format idx case idx when Integer @formats [ idx ] || @default_format || Format . new when String @formats . find do | fmt | fmt . name == idx end end end
643	def bottom_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ BOTTOM ] = size . to_i else @borders [ BOTTOM ] = nil end end
466	def to_param params = to_hash . merge ( 'callerKey' => AmazonFlexPay . access_key , 'signatureVersion' => 2 , 'signatureMethod' => 'HmacSHA256' ) params [ 'signature' ] = AmazonFlexPay . sign ( AmazonFlexPay . pipeline_endpoint , params ) AmazonFlexPay :: Util . query_string ( params ) end
405	def refresh_tokens response = get ( path : 'tokens' ) [ "data" ] token_array = response || { } tokens = { } token_array . each do | t | tokens [ t . keys . first ] = t . values . first end @tokens = tokens return tokens end
1385	def jquids_includes ( options = { } ) Jquids . format = options [ :format ] if options . has_key? ( :format ) html_out = "" if options . has_key? ( :style ) html_out << stylesheet_link_tag ( jq_ui_stylesheet ( options [ :style ] ) ) + "\n" unless options [ :style ] == nil or options [ :style ] == :none or options [ :style ] == false else html_out << stylesheet_link_tag ( jq_ui_stylesheet ) + "\n" end jq_vrs = options . has_key? ( :jQuery ) ? options [ :jQuery ] : Jquids :: JQVersions . last ui_vrs = options . has_key? ( :jQueryUI ) ? options [ :jQueryUI ] : Jquids :: UIVersions . last trtp_vrs = options . has_key? ( :TRTimepicker ) ? options [ :TRTimepicker ] : :none unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil html_out << "<style type=\"text/css\">.ui-timepicker-div .ui-widget-header{margin-bottom:8px;}.ui-timepicker-div dl{text-align:left;}.ui-timepicker-div dl dt{height:25px;}.ui-timepicker-div dl dd{margin:-25px 0 10px 65px;}.ui-timepicker-div td{font-size:90%;}</style>\n" end html_out << javascript_include_tag ( jq_ui_javascripts ( jq_vrs , ui_vrs , trtp_vrs ) ) + "\n" options [ :datepicker_options ] ||= { } options [ :datepicker_options ] [ :showOtherMonths ] = true if options [ :datepicker_options ] [ :showOtherMonths ] . nil? options [ :datepicker_options ] [ :selectOtherMonths ] = true if options [ :datepicker_options ] [ :selectOtherMonths ] . nil? options [ :datepicker_options ] [ :changeMonth ] = true if options [ :datepicker_options ] [ :changeMonth ] . nil? options [ :datepicker_options ] [ :changeYear ] = true if options [ :datepicker_options ] [ :changeYear ] . nil? options [ :datepicker_options ] [ :dateFormat ] = Jquids . format [ :js_date ] Jquids . jquids_process_options ( options ) datepicker_options = if options [ :datepicker_options ] . respond_to? ( :to_json ) options . delete ( :datepicker_options ) . to_json else begin JSON . unparse ( options . delete ( :datepicker_options ) ) rescue "" end end html_out << '<script type="text/javascript">$.datepicker.setDefaults(' + datepicker_options + ');' unless trtp_vrs == :none or trtp_vrs == false or trtp_vrs == nil options [ :timepicker_options ] ||= { } options [ :timepicker_options ] [ :ampm ] = Jquids . format [ :ampm ] options [ :timepicker_options ] [ :timeFormat ] = Jquids . format [ :tr_js_time ] timepicker_options = if options [ :timepicker_options ] . respond_to? ( :to_json ) options . delete ( :timepicker_options ) . to_json else begin JSON . unparse ( options . delete ( :timepicker_options ) ) rescue "" end end html_out << '$.timepicker.setDefaults(' + timepicker_options + ');' end html_out << '$(document).ready(function(){$(".jquids_dp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).datepicker(JSON.parse(s)):$(this).datepicker()});$(".jquids_tp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).timepicker(JSON.parse(s)):$(this).timepicker()});$(".jquids_dtp").each(function(){var s=$(this).attr("data-jquipicker");$(this).attr("data-jquipicker")?$(this).datetimepicker(JSON.parse(s)):$(this).datetimepicker()})});</script>' if html_out . respond_to? ( :html_safe ) return html_out . html_safe else return html_out end end
1067	def import_annotation ( name , opts ) logger . debug { "Importing #{qp} annotation #{name}..." } class_eval ( "module #{name}; end" ) mod = const_get ( name ) mod . extend ( Annotation :: Importer ) mod . initialize_annotation ( self , opts ) { | pxy | create_proxy_attribute ( mod , pxy ) } mod end
777	def fetch ( title , year = "" , tomatoes = false , plot = "short" ) res = network . call ( { t : title , y : year , tomatoes : tomatoes , plot : plot } ) if res [ :data ] [ "Response" ] == "False" { status : 404 } else { status : res [ :code ] , movie : parse_movie ( res [ :data ] ) } end end
1009	def do_once ( action_name , opts = { } ) return if action_applied? ( action_name ) result = yield job_done = opts [ :job_done_when ] . blank? || opts [ :job_done_when ] . call ( result ) apply_action ( action_name ) if job_done end
1307	def PARSE ( parser ) if ! :: Integer . equal? ( parser ) and ! parser . respond_to? ( :parse ) raise TypeError , 'wrong object for parser' end -> v { if :: Integer . equal? parser :: Kernel . Integer v else parser . parse ( case v when String v when -> _ { v . respond_to? :to_str } v . to_str when -> _ { v . respond_to? :read } v . read else raise TypeError , 'wrong object for parsing source' end ) end } end
61	def execute_action ( action_name , args , & block ) registry = get_service_registry ( ) validator = ParametersValidator . new ( registry ) args = validator . validate_args ( action_name , args ) request_info , response = handle_soap_request ( action_name . to_sym , false , args , validator . extra_namespaces ) do_logging ( action_name , request_info , response ) handle_errors ( response ) extractor = ResultsExtractor . new ( registry ) result = extractor . extract_result ( response , action_name , & block ) run_user_block ( extractor , response , result , & block ) if block_given? return result end
917	def get_xy_tile ( xtile , ytile , zoom , style_id = nil , tile_size = nil ) style_id = self . default_style_id if style_id == nil tile_size = self . default_tile_size if tile_size == nil connect "/#{style_id}/#{tile_size}/#{zoom}/#{xtile}/#{ytile}.png" end
164	def version ( * versions , & block ) condition = lambda { | env | versions . include? ( env [ "HTTP_X_API_VERSION" ] ) } with_conditions ( condition , & block ) end
600	def delete ( id ) id = id . id if id . is_a? ( Parse :: Pointer ) if id . present? && permissions . has_key? ( id ) will_change! permissions . delete ( id ) end end
1259	def run bind_queues and return if test_env? start_shutdown_thread start_error_counter_thread client . on_exception do | e | count_error ( e ) end client . connect start_event_thread puts 'EventListener started. Hit Ctrl-C to exit' Thread . stop puts 'Main thread wakeup - exiting.' client . close end
696	def send_request ( params , payload = nil , content_type = nil ) req_params = setup_request ( params , payload , content_type ) handled_request ( req_params ) do request = RestClient :: Request . new ( req_params ) response = request . execute if ! [ 200 , 201 , 202 , 204 ] . include? ( response . code ) @logger . warn "Warning: unattended code #{response.code}" end parsed_response = Nokogiri :: XML ( response ) @logger . debug "Send request result: #{parsed_response}" [ parsed_response , response . headers ] end end
302	def exclude ( * args ) e = flatten_list_of_strings ( args ) if e . nil? || e . empty? bot . exclude = [ ] else bot . exclude += e end end
995	def treat_data @hash_inter = Hash . new @hash = Hash . new if validate_api_return @hash_inter = @hash_local [ 'list' ] [ 'resources' ] [ 'resource' ] @hash_inter . each do | cout | simbol_string = cout [ 'field' ] [ 0 ] . to_s simbol = simbol_string . split ( "/" ) @hash [ simbol [ 1 ] ] = cout [ 'field' ] [ 1 ] . to_f end else @data = false end end
495	def administrators response = get ( '/admins.json' ) response . map { | item | Hashie :: Mash . new ( item ) } end
1077	def add ( options = { } ) assert_valid_keys ( options , :playlist , :index ) options = { :playlist => playlist . id , :index => 0 } . merge ( options ) song = dup song . attributes = { :playlist => options [ :playlist ] } playlist , index = song . playlist , options [ :index ] api ( 'playlist.add' , :playlist_name => playlist . id , :song_dict => { :fileid => id } , :index => index ) playlist . songs . insert ( index , song ) if playlist . loaded? true end
730	def add_to_query ( ** terms ) if is_a? Rescuetime :: Collection self << terms self else Rescuetime :: Collection . new ( BASE_PARAMS , state , terms ) end end
760	def use ( middleware , * _args , & block ) stack ( middleware ) . use ( middleware , * _args , & block ) end
849	def subtitle = ( str ) composite = product . titles . first if composite . nil? composite = ONIX :: Title . new composite . title_type = 1 product . titles << composite end composite . subtitle = str end
356	def fixed_dependencies fixed_attrs = fixed_attributes filtered_dependency_attributes . each_with_object ( Set . new ) do | ( key , value ) , fixed_deps | fixed_deps . merge ( value ) if fixed_attrs . include? ( key ) end . reject ( & :saved? ) end
152	def side_load ( resources , side_loads ) key = "#{options.name}_id" plural_key = "#{Inflection.singular options.name.to_s}_ids" resources . each do | resource | if resource . key? ( plural_key ) side_load_from_child_ids ( resource , side_loads , plural_key ) elsif resource . key? ( key ) || options . singular side_load_from_child_or_parent_id ( resource , side_loads , key ) else side_load_from_parent_id ( resource , side_loads , key ) end end end
36	def find_value ( data , path ) return ( path . nil? or data . nil? ) ? nil : path . split ( '.' ) . inject ( data ) do | node , section | break if node . nil? key = section . to_sym ( node . is_a? ( Hash ) and node . include? ( key ) ) ? node [ key ] : nil end end
434	def link ( name , locator ) define_method ( "#{name}_text" ) do adapter . link ( locator ) . value end define_method ( "click_#{name}" ) do adapter . link ( locator ) . click end define_method ( "#{name}_view" ) do adapter . link ( locator ) . view end end
402	def search_enum ( args , page_size : 100 , additional_headers : { } ) Enumerator . new do | yielder | ( 0 .. Float :: INFINITY ) . step ( page_size ) . each do | index | search_params = args . merge ( start : index . to_i , count : page_size ) results = search ( search_params , additional_headers ) . to_h . fetch ( 'results' , [ ] ) results . each do | result | yielder << result end if results . count < page_size break end end end end
1326	def parse_config ( conffile = nil ) conffile ||= Dir . glob ( [ "/etc/foreman_hooks-host_rename/settings.yaml" , "#{confdir}/settings.yaml" ] ) [ 0 ] raise "Could not locate the configuration file" if conffile . nil? config = { hook_user : 'foreman' , database_path : '/var/tmp/foreman_hooks-host_rename.db' , log_path : '/var/tmp/foreman_hooks-host_rename.log' , log_level : 'warn' , rename_hook_command : '/bin/true' , } . merge ( symbolize ( YAML . load ( File . read ( conffile ) ) ) ) config . each do | k , v | instance_variable_set ( "@#{k}" , v ) end document = Kwalify :: Yaml . load_file ( conffile ) schema = Kwalify :: Yaml . load_file ( "#{confdir}/schema.yaml" ) validator = Kwalify :: Validator . new ( schema ) errors = validator . validate ( document ) if errors && ! errors . empty? puts "WARNING: The following errors were found in #{conffile}:" for e in errors puts "[#{e.path}] #{e.message}" end raise "Errors in the configuration file" end check_script @rename_hook_command end
1027	def reconnect_from ( * exceptions ) begin yield rescue * exceptions => ex if @reconnect logger . debug "Connection failed: #{ex.message}" EM :: Synchrony . sleep ( @reconnect_wait ) logger . debug 'Attempting to reconnect' retry else raise end end end
271	def prepare_request_headers ( url ) headers = @default_headers . dup unless @host_headers . empty? @host_headers . each do | name , header | if url . host . match ( name ) headers [ 'Host' ] = header break end end end headers [ 'Host' ] ||= @host_header if @host_header headers [ 'User-Agent' ] = @user_agent if @user_agent headers [ 'Referer' ] = @referer if @referer if ( authorization = @authorized . for_url ( url ) ) headers [ 'Authorization' ] = "Basic #{authorization}" end if ( header_cookies = @cookies . for_host ( url . host ) ) headers [ 'Cookie' ] = header_cookies end return headers end
521	def clicks ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "clicks" , date , page , page_size , order_field , order_direction ) end
101	def process_attributes ( data , keep_xsi_type = false ) if keep_xsi_type xsi_type = data . delete ( :" " ) data [ :xsi_type ] = xsi_type if xsi_type end data . reject! { | key , value | key . to_s . start_with? ( '@' ) } end
1164	def place ( top , left , angle ) api ( 'sticker.place' , :placement => [ :sticker_id => id , :top => top , :left => left , :angle => angle ] , :is_dj => client . user . dj? , :roomid => room . id , :section => room . section ) true end
740	def process_part ( part ) return if ignore_media? ( part . part_type? , part ) type , file = process_media ( part ) add_file ( type , file ) unless type . nil? || file . nil? end
1091	def log ( level , message , quiet : false , & block ) if ! quiet && ( LEVELS . index ( level ) >= LEVELS . index ( Logger . level ) ) synchronize do message = message . to_s . colorize ( COLORS [ level ] ) if level message . split ( "\n" ) . each do | line | STDERR . puts " " * Logger . indent + @prefix + line end end with_indent ( & block ) if block elsif block block . ( ) end end
590	def payload msg = { data : { alert : alert , badge : badge || "Increment" } } msg [ :data ] [ :sound ] = sound if sound . present? msg [ :data ] [ :title ] = title if title . present? msg [ :data ] . merge! @data if @data . is_a? ( Hash ) if @expiration_time . present? msg [ :expiration_time ] = @expiration_time . respond_to? ( :iso8601 ) ? @expiration_time . iso8601 ( 3 ) : @expiration_time end if @push_time . present? msg [ :push_time ] = @push_time . respond_to? ( :iso8601 ) ? @push_time . iso8601 ( 3 ) : @push_time end if @expiration_interval . is_a? ( Numeric ) msg [ :expiration_interval ] = @expiration_interval . to_i end if query . where . present? q = @query . dup if @channels . is_a? ( Array ) && @channels . empty? == false q . where :channels . in => @channels end msg [ :where ] = q . compile_where unless q . where . empty? elsif @channels . is_a? ( Array ) && @channels . empty? == false msg [ :channels ] = @channels end msg end
1256	def write_json ( file , object ) return unless file && object begin File . open ( file , 'w' ) { | f | f . write ( JSON . pretty_generate ( object ) ) } end end
835	def validate ( object ) sanitized_object = validate_type ( object ) validate_constraints ( sanitized_object ) unless sanitized_object . nil? && allow_nil? self . sanitized_object = sanitized_object true rescue ValidationError => e self . sanitized_object = nil raise e end
753	def captureOutput ( output , didFinishProcessingPhotoSampleBuffer : photo_sample_buffer , previewPhotoSampleBuffer : preview_photo_sample_buffer , resolvedSettings : resolved_settings , bracketSettings : bracket_settings , error : error ) if error error_callback . call ( error ) else jpeg_data = AVCapturePhotoOutput . jpegPhotoDataRepresentation ( forJPEGSampleBuffer : photo_sample_buffer , previewPhotoSampleBuffer : preview_photo_sample_buffer ) @capture_callback . call ( jpeg_data ) end end
479	def ft_del record : doc_id = record . to_global_id REDI_SEARCH . call ( 'FT.DEL' , @index_name , doc_id ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
584	def << ( * list ) if list . count > 0 notify_will_change! list . flatten . each { | e | collection . push ( e ) } end end
17	def batch_job_utils ( version = nil ) version = api_config . default_version if version . nil? if ! api_config . versions . include? ( version ) raise AdsCommon :: Errors :: Error , "Unknown version '%s'" % version end return AdwordsApi :: BatchJobUtils . new ( self , version ) end
640	def border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ TOP ] = @borders [ RIGHT ] = @borders [ BOTTOM ] = @borders [ LEFT ] = size . to_i else @borders = [ nil , nil , nil , nil ] end end
544	def user_mayorships ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/mayorships" , options end return_error_or_body ( response , response . body . response . mayorships ) end
246	def call ( save : true ) if save == false call_processor elsif destination handle_destination do call_processor ( destination : destination ) end else create_tempfile do | tempfile | call_processor ( destination : tempfile . path ) end end end
72	def download_report_as_file_with_awql ( report_query , format , path , cid = nil ) report_body = download_report_with_awql ( report_query , format , cid ) save_to_file ( report_body , path ) return nil end
447	def del ( path , raise = true ) path = '"' + path + '"' if path . include? ' ' exec 'del ' + path true rescue Client :: RuntimeError => e raise e if raise false end
1173	def add_position_to_specimen_template ( specimen , template ) pos = specimen . position pas = pos . class . nondomain_attributes ss = pos . snapshot vh = ss ? pas . to_compact_hash { | pas | ss [ pas ] } : pos . value_hash ( pas ) vh [ :specimen ] = template vh [ :storage_container ] = pos . storage_container . copy template . position = pos . class . new ( vh ) logger . debug { "Work around #{specimen} update anomaly by copying position #{template.position.qp} to update template #{template.qp} as #{template.position.qp} with values #{vh.qp}..." } end
376	def decode ( options = { } ) decode! ( options ) rescue TwoCaptcha :: Error => ex TwoCaptcha :: Captcha . new end
659	def to_s ( indent = 0 ) prefix = indent > 0 ? ' ' * indent : '' text = StringIO . new text << "#{prefix}Information" text << "\n#{prefix} Title: #{@title}" unless @title . nil? text << "\n#{prefix} Author: #{@author}" unless @author . nil? text << "\n#{prefix} Company: #{@company}" unless @company . nil? text << "\n#{prefix} Comments: #{@comments}" unless @comments . nil? text << "\n#{prefix} Created: #{@created}" unless @created . nil? text . string end
599	def delete ( uri , body = nil , headers = { } ) request :delete , uri , body : body , headers : headers end
743	def temp_file ( part ) file_name = filename? ( part ) File . expand_path ( File . join ( msg_tmp_dir ( ) , File . basename ( file_name ) ) ) end
558	def recent_checkins ( options = { } ) response = connection . get do | req | req . url "checkins/recent" , options end return_error_or_body ( response , response . body . response . recent ) end
361	def or ( value = nil , & block ) return Failure ( block . call ( @value ) ) if failure? && block_given? return Failure ( value ) if failure? return self end
935	def extract_platform ( value ) platform = value . to_s . split ( '|' ) [ 1 ] if value . to_s . include? '|' sauce_platforms @sauce_platforms [ platform ] if not platform . nil? end
1170	def decrement_derived_quantity ( child ) return unless specimen_type == child . specimen_type and child . initial_quantity if available_quantity . nil? then raise Jinx :: ValidationError . new ( "Derived specimen has an initial quantity #{child.initial_quantity} but the parent is missing an available quantity" ) elsif ( available_quantity - child . initial_quantity ) . abs < 0.00000001 then self . available_quantity = 0.0 elsif child . initial_quantity <= available_quantity then self . available_quantity -= child . initial_quantity else raise Jinx :: ValidationError . new ( "Derived specimen initial quantity #{child.initial_quantity} exceeds parent available quantity #{available_quantity}" ) end end
6	def cookies hash = { } cookie_jar . cookies ( @request . uri ) . each do | cookie | hash [ cookie . name ] = cookie . value end hash end
1101	def create_annotation_service ( mod , name ) @integrator = Annotation :: Integrator . new ( mod ) Annotation :: AnnotationService . new ( @database , name , @integrator ) end
489	def validate_token! ( access_token ) validator = Fridge . configuration . validator if validator . call ( access_token ) access_token else raise InvalidToken , 'Rejected by validator' end end
1285	def prepare_modes buf = [ 0 , 0 , 0 , 0 , 0 , 0 , '' ] . pack ( "IIIICCA*" ) $stdout . ioctl ( TCGETS , buf ) @old_modes = buf . unpack ( "IIIICCA*" ) new_modes = @old_modes . clone new_modes [ 3 ] &= ~ ECHO new_modes [ 3 ] &= ~ ICANON $stdout . ioctl ( TCSETS , new_modes . pack ( "IIIICCA*" ) ) print "\e[2J" print "\e[H" print "\e[?47h" print "\e[?1000h" self . cursor = false flush end
908	def execute_ssh ( commands ) commands = [ commands ] unless commands . is_a? Array result = "" Net :: SSH . start settings . remote_server , settings . remote_user do | ssh | commands . each do | command | was_error = false logger . info "ssh: #{command}" ssh . exec! command do | channel , stream , data | case stream when :stdout logger . info data result += "#{data}\n" unless data . empty? when :stderr logger . error data was_error = true end end throw "Exception during ssh, look in log file" if was_error end end result end
559	def add_checkin ( options = { } ) response = connection . post do | req | req . url "checkins/add" , options end return_error_or_body ( response , response . body . response . checkin ) end
1064	def init_col_filter ( columns , source ) if columns . nil? File . open ( source , 'r' ) . each do | line | line = unstring ( line ) next if line . empty? line += ' ' if line =~ / / size = line . split ( ';' ) . size columns = "0-#{size-1}" break end end ColumnFilter . new ( columns ) . filter . flatten end
724	def all requester = Rescuetime :: Requester host = HOST parse_response requester . get ( host , params ) end
1352	def validate_timeout ( timeout ) unless timeout == nil raise TypeError , "'timeout' must be nil or a Numeric" unless timeout . is_a? ( Numeric ) raise ArgumentError , "'timeout' must not be negative" if timeout . negative? end end
759	def stack ( name = nil , opts = { } ) if self :: StackMiddleware . _mwares [ name ] && mw = self :: StackMiddleware . _mwares [ name ] unless mw . stack == self mw = self :: StackMiddleware . _mwares [ name ] = self :: StackMiddleware . _mwares [ name ] . dup end mw else self :: StackMiddleware . new ( name , self , opts ) end end
1074	def skip assert_current_song api ( 'room.stop_song' , :songid => id , :djid => played_by . id , :roomid => room . id , :section => room . section ) true end
833	def add ( key , meta ) @collection [ key ] = meta if meta . required? @required_properties << key else @required_properties . delete ( key ) end meta end
867	def collect_directories ( glob_pattern , file_pattern = '' ) Pathname . glob ( glob_pattern ) . select { | f | f . basename . to_s . include? ( file_pattern ) } . map ( & :dirname ) . uniq . map ( & :realpath ) end
419	def servlet_to_rack ( request ) env = Hash . new env [ 'REQUEST_METHOD' ] = request . getMethod env [ 'QUERY_STRING' ] = request . getQueryString . to_s env [ 'SERVER_NAME' ] = request . getServerName env [ 'SERVER_PORT' ] = request . getServerPort . to_s env [ 'rack.version' ] = Rack :: VERSION env [ 'rack.url_scheme' ] = request . getScheme env [ 'HTTP_VERSION' ] = request . getProtocol env [ "SERVER_PROTOCOL" ] = request . getProtocol env [ 'REMOTE_ADDR' ] = request . getRemoteAddr env [ 'REMOTE_HOST' ] = request . getRemoteHost env [ 'REQUEST_PATH' ] = request . getRequestURI env [ 'PATH_INFO' ] = request . getRequestURI env [ 'SCRIPT_NAME' ] = "" env [ 'REQUEST_URI' ] = request . getRequestURL . to_s env [ 'REQUEST_URI' ] << "?#{env['QUERY_STRING']}" if env [ 'QUERY_STRING' ] env [ 'rack.multiprocess' ] = false env [ 'rack.multithread' ] = true env [ 'rack.run_once' ] = false env [ 'rack.input' ] = @server . rewindable ( request ) env [ 'rack.input' ] . set_encoding ( Encoding . find ( "ASCII-8BIT" ) ) if env [ 'rack.input' ] . respond_to? ( :set_encoding ) request . getHeaderNames . each do | header_name | header = header_name . to_s . upcase . tr ( '-' , '_' ) env [ "HTTP_#{header}" ] = request . getHeader ( header_name ) end env [ "CONTENT_TYPE" ] = env . delete ( "HTTP_CONTENT_TYPE" ) if env [ "HTTP_CONTENT_TYPE" ] env [ "CONTENT_LENGTH" ] = env . delete ( "HTTP_CONTENT_LENGTH" ) if env [ "HTTP_CONTENT_LENGTH" ] env [ 'rack.errors' ] ||= @server . logger env [ 'rack.logger' ] ||= @server . logger return ( env ) end
542	def user_photos ( options = { } ) response = connection . get do | req | req . url "users/self/photos" , options end return_error_or_body ( response , response . body . response . photos ) end
497	def create_custom_field ( field_name , data_type , options = [ ] , visible_in_preference_center = true ) options = { :body => { :FieldName => field_name , :DataType => data_type , :Options => options , :VisibleInPreferenceCenter => visible_in_preference_center } . to_json } response = post "customfields" , options response . parsed_response end
1341	def find ( ids , opts = { } ) ids . is_a? ( Array ) ? find_by_ids ( ids , opts ) : find_by_id ( ids , opts ) end
613	def add ( font ) if font . instance_of? ( Font ) @fonts . push ( font ) if @fonts . index ( font ) . nil? end self end
1151	def read ( filename , as : nil , quiet : false ) Base64 . decode64 sh ( "cat #{filename.shellescape} | base64" , as : as , quiet : quiet ) end
492	def subscribers ( date = "" , page = 1 , page_size = 1000 , order_field = "email" , order_direction = "asc" , include_tracking_preference = false ) options = { :query => { :date => date , :page => page , :pagesize => page_size , :orderfield => order_field , :orderdirection => order_direction , :includetrackingpreference => include_tracking_preference } } response = get "active" , options Hashie :: Mash . new ( response ) end
847	def title composite = product . titles . first if composite . nil? nil else composite . title_text || composite . title_without_prefix end end
491	def history options = { :query => { :email => @email_address } } response = cs_get "/subscribers/#{@list_id}/history.json" , options response . map { | item | Hashie :: Mash . new ( item ) } end
1133	def execute File . open ( out_file , 'w' ) do | o | File . new ( in_file , 'r' ) . each_with_index do | line , index | extraction = col_filter . process ( row_filter . process ( line . chomp , row : index ) ) o . puts extraction unless extraction . nil? end end end
455	def create_scanner ( start_row = nil , end_row = nil , * columns , & block ) columns = ( columns . length > 0 ) ? columns : column_families . keys sid = call :scannerOpenWithStop , start_row . to_s , end_row . to_s , columns Scanner . new @client , sid , & block end
741	def transform_text ( type , text ) return type , text if ! config [ 'transform' ] || ! ( transforms = config [ 'transform' ] [ type ] ) if RUBY_VERSION < "1.9" require 'iconv' ic = Iconv . new ( 'UTF-8' , 'ISO-8859-1' ) text = ic . iconv ( text ) text << ic . iconv ( nil ) ic . close end transforms . each do | transform | next unless transform . size == 2 p = transform . first r = transform . last text = text . gsub ( p , r ) rescue text end return type , text end
747	def type_from_filename ( filename ) ext = filename . split ( '.' ) . last ent = MMS2R :: EXT . detect { | k , v | v == ext } ent . nil? ? nil : ent . first end
822	def raw_exchange_rates req = Net :: HTTP :: Post . new ( @uri , 'Content-Type' => 'application/json' ) req . body = { lang : :en } . to_json response = Net :: HTTP . start ( @uri . hostname , @uri . port ) do | http | http . request ( req ) end fail ResponseError , response . code unless response . is_a? Net :: HTTPSuccess response = JSON . parse ( response . body ) unless response [ 'd' ] && response [ 'd' ] . size >= 6 fail ResponseError , "Unknown JSON #{response}" end response rescue JSON :: ParserError raise ResponseError , "Unknown JSON: #{response.body}" end
1048	def generate make_output_directory files . each do | file | File . write ( "#{@output}/#{File.basename(file, '.*')}.rb" , Steamd :: Generator :: Ruby . new ( file ) . run ) end end
381	def validate_response ( response ) if ( error = TwoCaptcha :: RESPONSE_ERRORS [ response ] ) fail ( error ) elsif response . to_s . empty? || response . match ( / \A \_ / ) fail ( TwoCaptcha :: Error , response ) end end
633	def foreground ( colour ) style = CharacterStyle . new style . foreground = colour root . colours << colour if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
105	def validate_service_request ( version , service ) unless api_config . has_version ( version ) raise AdsCommon :: Errors :: Error , "Version '%s' not recognized" % version . to_s end unless api_config . version_has_service ( version , service ) raise AdsCommon :: Errors :: Error , "Version '%s' does not contain service '%s'" % [ version . to_s , service . to_s ] end end
1081	def generate opts = CliOptions . new ( options ) gen = CodeGenerator . new ( opts . input , opts . output ) gen . generate end
691	def create_internal_network_node ( network_config ) builder = Nokogiri :: XML :: Builder . new do | xml | xml . Configuration { xml . IpScopes { xml . IpScope { xml . IsInherited ( network_config [ :is_inherited ] || "false" ) xml . Gateway network_config [ :gateway ] xml . Netmask network_config [ :netmask ] xml . Dns1 network_config [ :dns1 ] if network_config [ :dns1 ] xml . Dns2 network_config [ :dns2 ] if network_config [ :dns2 ] xml . DnsSuffix network_config [ :dns_suffix ] if network_config [ :dns_suffix ] xml . IsEnabled ( network_config [ :is_enabled ] || true ) xml . IpRanges { xml . IpRange { xml . StartAddress network_config [ :start_address ] xml . EndAddress network_config [ :end_address ] } } } } xml . FenceMode 'isolated' xml . RetainNetInfoAcrossDeployments ( network_config [ :retain_info ] || false ) } end builder . doc end
541	def user_todos ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/todos" , options end return_error_or_body ( response , response . body . response . todos ) end
870	def [] ( index ) if index . respond_to? ( :to_a ) index . to_a . map do | i | check_index ( i ) Color . from_i ( ws2811_led_get ( @channel , i ) ) end else check_index ( index ) Color . from_i ( ws2811_led_get ( @channel , index ) ) end end
411	def verify! if signature . missing? && assertion . signature . missing? raise Samlr :: SignatureError . new ( "Neither response nor assertion signed with a certificate" ) end signature . verify! unless signature . missing? assertion . verify! true end
854	def proprietry_discount_code_for_rrp price = price_get ( 2 ) return nil if price . nil? discount = price . discounts_coded . find { | disc | disc . discount_code_type == 2 } discount . andand . discount_code end
1155	def write_result sum_line = [ sum_row_title ] ( heading . size - 2 ) . times { sum_line << "" } sum_line << sums [ sum_col_title ] row = 0 ; File . open ( outfile , 'w' ) do | out | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 out . puts heading . join ( ';' ) key_values . each do | k , v | out . puts sum_line . join ( ';' ) if row == sum_row ; row += 1 out . puts [ k , v ] . join ( ';' ) end end end
130	def to_s @threads . map do | t | [ "#{t.name}: status=#{t.status}; alive=#{t.alive?}" , 'Vars: ' + t . thread_variables . map { | v | "#{v}=\"#{t.thread_variable_get(v)}\"" } . join ( '; ' ) , t . backtrace . nil? ? 'NO BACKTRACE' : " #{t.backtrace.join("\n ")}" ] . join ( "\n" ) end end
108	def create_default_logger ( ) logger = Logger . new ( STDOUT ) logger . level = get_log_level_for_string ( @config . read ( 'library.log_level' , 'INFO' ) ) return logger end
803	def usb_open_desc_index ( vendor , product , description , serial , index ) raise ArgumentError . new ( 'vendor should be Fixnum' ) unless vendor . kind_of? ( Fixnum ) raise ArgumentError . new ( 'product should be Fixnum' ) unless product . kind_of? ( Fixnum ) raise ArgumentError . new ( 'index should be Fixnum' ) unless index . kind_of? ( Fixnum ) raise ArgumentError . new ( 'index should be greater than or equal to zero' ) if index < 0 check_result ( Ftdi . ftdi_usb_open_desc_index ( ctx , vendor , product , description , serial , index ) ) end
480	def ft_info REDI_SEARCH . call ( 'FT.INFO' , @index_name ) rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
499	def update_custom_field_options ( custom_field_key , new_options , keep_existing_options ) custom_field_key = CGI . escape ( custom_field_key ) options = { :body => { :Options => new_options , :KeepExistingOptions => keep_existing_options } . to_json } put "customfields/#{custom_field_key}/options" , options end
99	def normalize_item ( item , field_def ) return case field_def [ :type ] when 'long' , 'int' then Integer ( item ) when 'double' , 'float' then Float ( item ) when 'boolean' then item . kind_of? ( String ) ? item . casecmp ( 'true' ) == 0 : item else item end end
1253	def download_to_file url , file url = URI . parse ( URI . encode ( url . strip ) ) File . new ( file , File :: CREAT ) Net :: HTTP . start ( url . host ) { | http | resp = http . get ( url . path ) open ( file , "wb" ) { | file | file . write ( resp . body ) } } end
1148	def ping ( ) log . debug "Pinging" Timeout . timeout ( 1 ) do TCPSocket . new ( address , 22 ) . close end true rescue Timeout :: Error , Errno :: ECONNREFUSED fail "Failed to ping #{self}" end
1263	def observer_queue @observer_queue ||= client . create_queue ( [ name , 'listener' , Socket . gethostname , Process . pid ] . join ( '.' ) , models_exchange , queue_options : { exclusive : true } , subscribe_options : { manual_ack : true } ) end
827	def write_attribute ( key_name , new_value ) meta = ensure_metadata_exists ( key_name ) @source . delete ( meta . source_key ) @writethrough [ key_name ] = @cache [ key_name ] = new_value end
788	def privacy ( id , privacy = false ) drop = Drop . find ( id ) drop . update ( :private => privacy ) end
262	def from_page ( page ) cookies = page . cookie_params unless cookies . empty? self [ page . url . host ] = cookies return true end return false end
1135	def get_doctype ( path ) doc_type = nil begin metadata = YAML . load_file ( path + 'template.yml' ) doc_type = metadata [ 'type' ] if doc_type . nil? say 'Type value not found. Check template.yml in the document directory' , :red say 'Make sure there is an entry `type: DOC_TYPE` in the file.' say " #{path}" raise_error ( 'DOC_TYPE not found in template.yml' ) end rescue Errno :: ENOENT say 'No template.yml found in the document directory. Did you forget to add it?' , :red say 'Did you run the command in the directory where the document is located?' say " #{path}" raise_error ( 'template.yml not found' ) end return doc_type end
1395	def find ( * args ) scope = args . slice! ( 0 ) options = args . slice! ( 0 ) || { } @resource_class . find ( scope , options ) end
1041	def input o = if @input . nil? Steamd . language_dir else @input end raise 'input must be a directory' unless File . directory? ( o ) File . expand_path ( o ) end
343	def register ( extention , handler = nil , & block ) handler ||= block raise 'Handler or block required.' unless handler @render_library [ extention . to_s ] = handler handler end
401	def batch_search ( searches , additional_headers = { } ) url_friendly_searches = searches . each_with_index . map do | search , index | { index => search } end searches_query = { search : url_friendly_searches } request_url = "#{base_url}/batch_search.json?#{Rack::Utils.build_nested_query(searches_query)}" get_json ( request_url , additional_headers ) end
300	def blocklist ( * args ) list = flatten_list_of_strings ( args ) if list . nil? || list . empty? bot . blocklist = [ ] else bot . blocklist += list end end
728	def order_by ( order , interval : nil ) order = order . to_s interval = interval ? interval . to_s : nil unless valid_order? order raise Errors :: InvalidQueryError , "#{order} is not a valid order" end unless valid_interval? interval raise Errors :: InvalidQueryError , "#{interval} is not a valid interval" end add_to_query perspective : ( order == 'time' ? 'interval' : order ) , resolution_time : interval end
534	def page_venues ( page_id , options = { } ) response = connection . get do | req | req . url "pages/#{page_id}/venues" , options end venues = return_error_or_body ( response , response . body . response . venues ) venues = Foursquare2 . filter ( venues , options [ :query ] ) if options . has_key? :query venues end
1319	def parse ( args ) @options = Options . new opt_parser = OptionParser . new do | parser | @options . define_options ( parser ) end opt_parser . parse! ( args ) @options end
415	def classes ( delimiter ) git = @dangerfile . git affected_files = git . modified_files + git . added_files affected_files . select { | file | files_extension . reduce ( false ) { | state , el | state || file . end_with? ( el ) } } . map { | file | file . split ( '.' ) . first . split ( delimiter ) [ 1 ] } end
1246	def default_user scg = specimen_collection_group || ( specimen . specimen_collection_group if specimen ) || return cp = scg . collection_protocol || return cp . coordinators . first || ( cp . sites . first . coordinator if cp . sites . size === 1 ) end
874	def set ( x , y , r , g , b ) check_coords ( x , y ) self [ x , y ] = Color . new ( r , g , b ) end
192	def dispatch_field_item! ( item , ns_prefix = nil ) item . values . first [ :xmlns_attribute ] = ns_prefix if ns_prefix build_xml! ( item ) end
620	def << ( text ) if ! last . nil? and last . respond_to? ( :text= ) last . append ( text ) else self . store ( TextNode . new ( self , text ) ) end end
1389	def gd ( date = self ) j_date = jd ( date ) g_date = HijriUmmAlqura . jd_to_gd ( j_date ) return g_date end
998	def js ( code ) XhrProxy . context = self @__page ||= Harmony :: Page . new ( XHR_MOCK_SCRIPT + rewrite_script_paths ( @response . body . to_s ) ) Harmony :: Page :: Window :: BASE_RUNTIME . wait @__page . execute_js ( code ) end
953	def contain ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string ) do | comparator , item | if options [ :case_sensitive ] item =~ Regexp . new ( comparator , Regexp :: MULTILINE ) else item =~ Regexp . new ( comparator , Regexp :: IGNORECASE | Regexp :: MULTILINE ) end end end
690	def create_fake_network_node ( vapp_networks , network_name ) parent_section = vapp_networks . css ( 'NetworkConfigSection' ) . first new_network = Nokogiri :: XML :: Node . new "NetworkConfig" , parent_section new_network [ 'networkName' ] = network_name placeholder = Nokogiri :: XML :: Node . new "PLACEHOLDER" , new_network new_network . add_child placeholder parent_section . add_child ( new_network ) vapp_networks end
1314	def select_tag_for_filter ( model , nvpairs , params ) return unless model && nvpairs && ! nvpairs . empty? options = { :query => params [ :query ] } _url = url_for ( eval ( "#{model}_url(options)" ) ) _html = %{<label for="show">Show:</label><br />} _html << %{<select name="show" id="show" onchange="window.location='#{_url}' + '?show=' + this.value">} nvpairs . each do | pair | _html << %{<option value="#{pair[:scope]}"} if params [ :show ] == pair [ :scope ] || ( ( params [ :show ] . nil? || params [ :show ] . empty? ) && pair [ :scope ] == "all" ) _html << %{ selected="selected"} end _html << %{>#{pair[:label]}} _html << %{</option>} end _html << %{</select>} end
1190	def add ( name , options = { } , & coercer ) name = name . to_sym value = Attribute . new ( name , options , & coercer ) clone_with do @attributes = attributes . merge ( name => value ) @transformer = nil end end
327	def on_blocklist? ( s ) search = if s . is_a? ( Twitter :: User ) s . name elsif s . respond_to? ( :user ) && ! s . is_a? ( Twitter :: NullObject ) from_user ( s ) else s end . downcase blocklist . any? { | b | search . include? ( b . downcase ) } end
452	def to_all_parts me = DeepClone . clone ( self ) me . disable_id_attribute @relations << DocumentRelation . new ( type : "partOf" , identifier : nil , url : nil , bibitem : me ) @title . each ( & :remove_part ) @abstract = [ ] @docidentifier . each ( & :remove_part ) @docidentifier . each ( & :all_parts ) @all_parts = true end
940	def update_self_and_descendants_depth if depth? scope_class . each_with_level ( self_and_descendants ) do | node , level | node . with ( :safe => true ) . set ( :depth , level ) unless node . depth == level end self . reload end self end
537	def user_requests ( options = { } ) response = connection . get do | req | req . url "users/requests" , options end return_error_or_body ( response , response . body . response . requests ) end
1339	def nethash interval = 500 , start = 0 , stop = false suffixe = stop ? "/#{stop}" : '' JSON . parse ( call_blockchain_api ( "nethash/#{interval}/#{start}#{suffixe}?format=json" ) ) end
1361	def wait continue = false trap "SIGINT" do puts "Continuing..." continue = true end puts "Waiting. Press ^C to continue test..." wait_until ( 3600 ) { continue } trap "SIGINT" , "DEFAULT" end
831	def response response = Net :: HTTP . get_response ( @uri ) if response . is_a? Net :: HTTPRedirection response = Net :: HTTP . get_response ( URI . parse ( response [ 'location' ] ) ) end fail ResponseError , response . code unless response . is_a? Net :: HTTPSuccess response end
474	def ft_search_count ( args ) ft_search ( args ) . first rescue Exception => e Rails . logger . error e if defined? Rails return e . message end
87	def credentials ( credentials_override = nil ) credentials = @credentials . dup ( ) credentials . merge! ( credentials_override ) unless credentials_override . nil? return credentials end
1270	def alert_add_entity ( entity_id , condition_id , entity_type = 'Server' ) nr_api . put do | req | req . url url ( 'alerts_entity_conditions' , entity_id ) req . params [ 'entity_type' ] = entity_type req . params [ 'condition_id' ] = condition_id end end
202	def items_since ( date_time , opts = { } ) opts = opts . clone unless date_time . kind_of? ( Date ) raise EwsBadArgumentError , "First argument must be a Date or DateTime" end restr = { :restriction => { :is_greater_than_or_equal_to => [ { :field_uRI => { :field_uRI => 'item:DateTimeReceived' } } , { :field_uRI_or_constant => { :constant => { :value => date_time . to_datetime } } } ] } } items ( opts . merge ( restr ) ) end
180	def mailbox! ( mbox ) nbuild [ NS_EWS_TYPES ] . Mailbox { name! ( mbox [ :name ] ) if mbox [ :name ] email_address! ( mbox [ :email_address ] ) if mbox [ :email_address ] address! ( mbox [ :address ] ) if mbox [ :address ] routing_type! ( mbox [ :routing_type ] ) if mbox [ :routing_type ] mailbox_type! ( mbox [ :mailbox_type ] ) if mbox [ :mailbox_type ] item_id! ( mbox [ :item_id ] ) if mbox [ :item_id ] } end
622	def paragraph ( style = nil ) node = ParagraphNode . new ( self , style ) yield node if block_given? self . store ( node ) end
918	def each_item return to_enum ( __method__ ) { count } unless block_given? return if empty? item = list_head loop do yield item item = item . next end end
977	def filtered return self if filters . empty? filtered_results = filters . each_with_object ( { } ) do | ( key , options ) , results | results [ key ] = filter ( key , * options ) end self . class . new ( filtered_results ) end
176	def folder_ids! ( fids , act_as = nil ) ns = @nbuild . parent . name . match ( / /i ) ? NS_EWS_TYPES : NS_EWS_MESSAGES @nbuild [ ns ] . FolderIds { fids . each do | fid | fid [ :act_as ] = act_as if act_as != nil dispatch_folder_id! ( fid ) end } end
386	def prettify ( xml ) result = '' formatter = REXML :: Formatters :: Pretty . new indent formatter . compact = compact doc = REXML :: Document . new xml formatter . write doc , result result end
278	def every_atom_doc every_page do | page | if ( block_given? && page . atom? ) if ( doc = page . doc ) yield doc end end end end
711	def get_network ( networkId ) response = get_base_network ( networkId ) name = response . css ( 'OrgVdcNetwork' ) . attribute ( 'name' ) . text description = response . css ( "Description" ) . first description = description . text unless description . nil? gateway = response . css ( 'Gateway' ) gateway = gateway . text unless gateway . nil? netmask = response . css ( 'Netmask' ) netmask = netmask . text unless netmask . nil? fence_mode = response . css ( 'FenceMode' ) fence_mode = fence_mode . text unless fence_mode . nil? start_address = response . css ( 'StartAddress' ) start_address = start_address . text unless start_address . nil? end_address = response . css ( 'EndAddress' ) end_address = end_address . text unless end_address . nil? { :id => networkId , :name => name , :description => description , :gateway => gateway , :netmask => netmask , :fence_mode => fence_mode , :start_address => start_address , :end_address => end_address } end
204	def search_by_subject ( match_str , exclude_str = nil ) items do | obj | match = { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => match_str } } } unless exclude_str . nil? excl = { :not => { :contains => { :containment_mode => 'Substring' , :containment_comparison => 'IgnoreCase' , :field_uRI => { :field_uRI => 'item:Subject' } , :constant => { :value => exclude_str } } } } match [ :and ] = [ { :contains => match . delete ( :contains ) } , excl ] end obj . restriction = match end end
270	def visit_page ( url ) url = sanitize_url ( url ) get_page ( url ) do | page | @history << page . url begin @every_page_blocks . each { | page_block | page_block . call ( page ) } yield page if block_given? rescue Actions :: Paused => action raise ( action ) rescue Actions :: SkipPage return nil rescue Actions :: Action end page . each_url do | next_url | begin @every_link_blocks . each do | link_block | link_block . call ( page . url , next_url ) end rescue Actions :: Paused => action raise ( action ) rescue Actions :: SkipLink next rescue Actions :: Action end if ( @max_depth . nil? || @max_depth > @levels [ url ] ) enqueue ( next_url , @levels [ url ] + 1 ) end end end end
30	def prefix_key_with_namespace ( key , ns_index = nil ) namespace = ( ns_index . nil? ) ? DEFAULT_NAMESPACE : ( "ns%d" % ns_index ) return prefix_key ( key , namespace ) end
161	def update_many! ( client , ids_or_attributes , attributes = { } ) association = attributes . delete ( :association ) || Association . new ( :class => self ) response = client . connection . put ( "#{association.generate_path}/update_many" ) do | req | if attributes == { } req . body = { resource_name => ids_or_attributes } else req . params = { :ids => ids_or_attributes . join ( ',' ) } req . body = { singular_resource_name => attributes } end yield req if block_given? end JobStatus . new_from_response ( client , response ) end
1312	def obfuscated_link_to ( path , image , label , args = { } ) _html = %{<form action="#{path}" method="get" class="obfuscated_link">} _html << %{ <fieldset><input alt="#{label}" src="#{image}" type="image" /></fieldset>} args . each { | k , v | _html << %{ <div><input id="#{k.to_s}" name="#{k}" type="hidden" value="#{v}" /></div>} } _html << %{</form>} _html end
323	def retweet ( id = @current_tweet ) return if require_login == false || id . nil? id = id_from_tweet ( id ) if debug_mode? debug "I'm in debug mode, otherwise I would retweet with tweet id: #{id}" return end client . retweet id end
616	def next_node peer = nil if ! parent . nil? and parent . respond_to? ( :children ) index = parent . children . index ( self ) peer = parent . children [ index + 1 ] end peer end
102	def service ( name , version = nil ) name = name . to_sym version = ( version . nil? ) ? api_config . default_version : version . to_sym validate_service_request ( version , name ) wrapper = if @wrappers . include? ( version ) && @wrappers [ version ] [ name ] @wrappers [ version ] [ name ] else @wrappers [ version ] ||= { } @wrappers [ version ] [ name ] = prepare_wrapper ( version , name ) end return wrapper end
46	def module_name ( version , service ) return [ api_name , version . to_s . upcase , service . to_s ] . join ( '::' ) end
1165	def find request_uris . map do | request | if request [ :body ] . nil? request [ :uri ] else html = Nokogiri :: HTML ( request [ :body ] ) potential_feed_uris = html . xpath ( XPATHS . detect { | path | ! html . xpath ( path ) . empty? } ) if potential_feed_uris . empty? Mako . errors . add_error "Could not find feed for #{request[:uri]}" next end uri_string = potential_feed_uris . first . value feed_uri = URI . parse ( uri_string ) feed_uri . absolutize! ( request [ :uri ] ) end end . compact end
826	def exists_locally? ( key_name ) return true if @cache . key? ( key_name ) || @writethrough . key? ( key_name ) meta = ensure_metadata_exists ( key_name ) @source . key? ( meta . source_key ) end
1144	def publish_to_socket ( params ) message = params . is_a? ( String ) ? params : params . to_json data = "~m~#{message.length}~m~#{message}" @socket . send ( data ) end
266	def run ( & block ) @running = true until ( @queue . empty? || paused? || limit_reached? ) begin visit_page ( dequeue , & block ) rescue Actions :: Paused return self rescue Actions :: Action end end @running = false @sessions . clear return self end
1061	def set api ( 'user.set_avatar' , :avatarid => id ) client . user . attributes = { 'avatarid' => id } client . user . avatar . attributes = { 'min' => minimum_points , 'acl' => acl } true end
330	def get_screen_name ( t = @access_token ) return unless @screen_name . nil? return if t . nil? oauth_response = t . get ( '/1.1/account/verify_credentials.json' ) @screen_name = JSON . parse ( oauth_response . body ) [ "screen_name" ] end
1301	def send_voice_confirmation! return false if _TC_voice_blocked return true if voice_confirmed? return false if _TC_phone_number . blank? format_phone_number confirmation_code = TwilioContactable . confirmation_code ( self , :voice ) response = TwilioContactable :: Gateway . initiate_voice_call ( self , _TC_formatted_phone_number ) if response . success? update_twilio_contactable_voice_confirmation confirmation_code end response end
315	def direct_messages ( opts = { } , & block ) return unless require_login debug "check for DMs since #{since_id_dm}" @current_tweet = nil client . direct_messages_received ( since_id : since_id_dm , count : 200 ) . each { | s | update_since_id_dm ( s ) debug s . text if has_safelist? && ! on_safelist? ( s . sender ) debug "skipping because user not on safelist" elsif block_given? && ! on_blocklist? ( s . sender ) && ! skip_me? ( s ) @current_tweet = s yield s end } @current_tweet = nil rescue Twitter :: Error :: Forbidden => e puts "sorry, looks like we're not allowed to check DMs for this account" end
606	def parse_result! ( h ) @result = { } return unless h . is_a? ( Hash ) @code = h [ CODE ] @error = h [ ERROR ] if h [ RESULTS ] . is_a? ( Array ) @result = h [ RESULTS ] @count = h [ COUNT ] || @result . count else @result = h @count = 1 end end
1222	def add_defaults_local super self . title ||= short_title self . short_title ||= title self . start_date ||= Java :: JavaUtil :: Date . new end
731	def valid_credentials? return false unless api_key? ! activities . all . nil? rescue Rescuetime :: Errors :: InvalidCredentialsError false end
1051	def create_file_header ( columns ) columns . each_with_index do | c , i | next if i == @current_key columns [ i ] = c . scan ( Regexp . new ( @current_source_header ) ) . flatten [ 0 ] end @file_header = @current_key ? [ @current_key . to_i ] : [ ] header_cols . each do | h | @file_header << columns . index ( h ) end @file_header . compact! end
1072	def enter if client . room != self client . room . leave if client . room client . connect ( url ) begin client . room = self data = api ( 'room.register' , :section => nil ) self . attributes = { 'section' => data [ 'section' ] } rescue Exception client . room = nil raise end end true end
170	def custom_template_path_valid? Vanity . playground . custom_templates_path && File . exist? ( Vanity . playground . custom_templates_path ) && ! Dir [ File . join ( Vanity . playground . custom_templates_path , '*' ) ] . empty? end
384	def configure_virtual_attributes ( attributes ) @virtual_attributes = if attributes == true VirtualAttributes . new ( true ) elsif attributes . is_a? ( Hash ) VirtualAttributes . new ( true , attributes ) else VirtualAttributes . new ( false ) end end
404	def process_request ( request ) request [ 'User-Agent' ] = @user_agent request [ 'Content-Type' ] = 'application/json' request [ 'X-BitPay-Plugin-Info' ] = 'Rubylib' + VERSION begin response = @https . request request rescue => error raise BitPay :: ConnectionError , "#{error.message}" end if response . kind_of? Net :: HTTPSuccess return JSON . parse ( response . body ) elsif JSON . parse ( response . body ) [ "error" ] raise ( BitPayError , "#{response.code}: #{JSON.parse(response.body)['error']}" ) else raise BitPayError , "#{response.code}: #{JSON.parse(response.body)}" end end
9	def _follow_redirection ( new_args , & block ) url = headers [ :location ] unless url raise exception_with_response end unless url . start_with? ( 'http' ) url = URI . parse ( request . url ) . merge ( url ) . to_s end new_args [ :url ] = url new_args [ :password ] = request . password new_args [ :user ] = request . user new_args [ :headers ] = request . headers new_args [ :max_redirects ] = request . max_redirects - 1 new_args [ :cookies ] = cookie_jar new_req = Request . new ( new_args ) new_req . redirection_history = history + [ self ] new_req . execute ( & block ) end
1370	def ever_follow follow = [ ] self . follow_history . each do | h | follow << h . split ( '_' ) [ 0 ] . constantize . find ( h . split ( '_' ) [ 1 ] ) end follow end
610	def logout return true if self . session_token . blank? client . logout session_token self . session_token = nil true rescue => e false end
608	def signup! ( passwd = nil ) self . password = passwd || password if username . blank? raise Parse :: Error :: UsernameMissingError , "Signup requires a username." end if password . blank? raise Parse :: Error :: PasswordMissingError , "Signup requires a password." end signup_attrs = attribute_updates signup_attrs . except! * Parse :: Properties :: BASE_FIELD_MAP . flatten response = client . create_user signup_attrs if response . success? apply_attributes! response . result return true end case response . code when Parse :: Response :: ERROR_USERNAME_MISSING raise Parse :: Error :: UsernameMissingError , response when Parse :: Response :: ERROR_PASSWORD_MISSING raise Parse :: Error :: PasswordMissingError , response when Parse :: Response :: ERROR_USERNAME_TAKEN raise Parse :: Error :: UsernameTakenError , response when Parse :: Response :: ERROR_EMAIL_TAKEN raise Parse :: Error :: EmailTakenError , response when Parse :: Response :: ERROR_EMAIL_INVALID raise Parse :: Error :: InvalidEmailAddress , response end raise Parse :: Client :: ResponseError , response end
290	def sign_batch ( tx_templates ) if @xpubs_by_signer . empty? successes = tx_templates . each_with_index . reduce ( { } ) do | memo , ( t , i ) | memo [ i ] = t memo end BatchResponse . new ( successes : successes ) end orig_index = ( 0 ... tx_templates . size ) . to_a errors = { } @xpubs_by_signer . each do | signer_conn , xpubs | next_tx_templates = [ ] next_orig_index = [ ] batch = signer_conn . batch_request ( '/sign-transaction' , transactions : tx_templates , xpubs : xpubs , ) { | item | Transaction :: Template . new ( item ) } batch . successes . each do | i , template | next_tx_templates << template next_orig_index << orig_index [ i ] end batch . errors . each do | i , err | errors [ orig_index [ i ] ] = err end tx_templates = next_tx_templates orig_index = next_orig_index break if tx_templates . empty? end successes = tx_templates . each_with_index . reduce ( { } ) do | memo , ( t , i ) | memo [ orig_index [ i ] ] = t memo end BatchResponse . new ( successes : successes , errors : errors , ) end
1065	def add_annotation ( name , opts = { } ) mod_sym = name . camelize . to_sym pkg = opts [ :package ] ||= name . underscore svc = opts [ :service ] ||= name . underscore grp = opts [ :group ] ||= pkg pxy_nm = opts [ :proxy_name ] || "#{self.name.demodulize}RecordEntry" self . annotation_proxy_class_name = pxy_nm @ann_spec_hash ||= { } @ann_spec_hash [ mod_sym ] = opts logger . info ( "Added #{qp} annotation #{name} with module #{mod_sym}, package #{pkg}, service #{svc} and group #{grp}." ) end
720	def evaluate name , receiver , args , call = nil , context = nil matcher = Support :: Matcher . new self , name , receiver , args matcher . match . new ( receiver , call , context ) . send name , * args end
324	def run! before_run HANDLER_CALLS . each { | c | if ( h = @handlers [ c ] ) send ( c , * ( h . opts ) ) do | obj | h . call ( obj ) end end } after_run end
877	def validate! if self . class . json_schema self . class . validator . instance_variable_set ( '@errors' , [ ] ) self . class . validator . instance_variable_set ( '@data' , stringify_keys ( to_h ( persist : true ) ) ) self . class . validator . validate true end end
1230	def coerce ( value ) return SpreadSheet . new ( [ value ] ) if value . is_a? ( Numeric ) return SpreadSheet . new ( value ) if value . is_a? ( Array ) end
254	def active? ( url ) url = URI ( url ) key = key_for ( url ) return @sessions . has_key? ( key ) end
159	def destroy! return false if destroyed? || new_record? @client . connection . delete ( url || path ) do | req | yield req if block_given? end @destroyed = true end
861	def website_set ( type , value ) site = website ( type ) if site . nil? site = ONIX :: Website . new site . website_role = type product . websites << site end site . website_link = value . to_s end
1180	def add_to_sum_row ( value , column ) return unless @sum_row_patterns @sum_row_patterns . each do | pattern | if pattern =~ / \( \d / header_column = evaluate ( pattern , "" ) else header_column = pattern end if header_column == column @sum_row [ header_column ] ||= 0 @sum_row [ header_column ] += value end end end
198	def copy ( new_folder ) new_folder = new_folder . id if new_folder . kind_of? ( GenericFolder ) copy_opts = { :to_folder_id => { :id => new_folder } , :item_ids => [ { :item_id => { :id => self . id } } ] } resp = @ews . copy_item ( copy_opts ) rmsg = resp . response_messages [ 0 ] if rmsg . success? obj = rmsg . items . first itype = obj . keys . first obj [ itype ] [ :elems ] [ 0 ] [ :item_id ] [ :attribs ] [ :id ] else raise EwsError , "Could not copy item. #{rmsg.response_code}: #{rmsg.message_text}" end end
907	def run validate_settings Lock . create ( self ) do schedule = find_schedule unless schedule logger . info "No backup needed - exiting" return end logger . info "Starting #{schedule} backup to #{settings.remote_server}" timestamp = Time . now . strftime ( 'backup_%Y-%m-%d-T%H-%M-%S' ) current_path = File . join ( settings . remote_path , 'current' ) progress_path = File . join ( settings . remote_path , 'incomplete' ) complete_path = File . join ( schedule_path ( schedule ) , timestamp ) login = "#{settings.remote_user}@#{settings.remote_server}" rsync_path = "#{login}:#{progress_path}" execute_ssh "mkdir --verbose --parents #{schedule_path schedule}" Rsync . execute ( logger , settings . local_path , rsync_path , { exclude_file : settings . exclude_file , link_dest : current_path , max_upload_speed : settings . max_upload_speed , max_download_speed : settings . max_download_speed } ) logger . info "Do the backup shuffle" execute_ssh [ "mv --verbose #{progress_path} #{complete_path}" , "rm --verbose --force #{current_path}" , "ln --verbose --symbolic #{complete_path} #{current_path}" , ] delete_old_backups schedule logger . info "#{schedule} backup done" end rescue Exception => exception logger . error exception . message logger . error exception . backtrace end
463	def multi_use_pipeline ( caller_reference , return_url , options = { } ) cbui MultiUse . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
621	def to_rtf text = StringIO . new text << '{' if wrap? text << @prefix if @prefix self . each do | entry | text << "\n" if split? text << entry . to_rtf end text << "\n" if split? text << @suffix if @suffix text << '}' if wrap? text . string end
1007	def parse_paths ( paths ) if paths paths . split ( File :: PATH_SEPARATOR ) . map do | path | Pathname . new ( path ) end else [ ] end end
1126	def << ( input ) if input . index ( / \s / ) . nil? word = normalize_word input self . word = word unless word == '' elsif input . scan ( SENTENCE_DELIMITER ) . length < 2 self . sentence = input . gsub ( SENTENCE_DELIMITER , '' ) else self . passage = input end end
513	def templates response = get 'templates' response . map { | item | Hashie :: Mash . new ( item ) } end
969	def submissions page = @client . get_nokogiri @url @submissions ||= page . css ( '.gradeTable tbody tr' ) . map { | tr | begin Stellar :: Homework :: Submission . new tr , self rescue ArgumentError nil end } . reject ( & :nil? ) end
344	def requested_method params [ '_method' . freeze ] = ( params [ '_method' . freeze ] || request . request_method . downcase ) . to_sym self . class . _pl_params2method ( params , request . env ) end
1117	def update ( attributes = { } ) assert_valid_keys ( attributes , :name , :status , :laptop_name , :twitter_id , :facebook_url , :website , :about , :top_artists , :hangout ) status = attributes . delete ( :status ) update_status ( status ) if status laptop_name = attributes . delete ( :laptop_name ) update_laptop ( laptop_name ) if laptop_name update_profile ( attributes ) if attributes . any? true end
275	def every_html_doc every_page do | page | if ( block_given? && page . html? ) if ( doc = page . doc ) yield doc end end end end
829	def verify_required! @key_metadata . required_properties . each do | key_name | next if @source . key? ( @key_metadata . get ( key_name ) . source_key ) raise RequiredAttribute , "#{@parent} requires `#{key_name}`" end end
445	def put ( from , to , overwrite = false , raise = true ) ls_items = ls to , false if ! overwrite && ! ls_items . empty? raise Client :: RuntimeError , "File [#{to}] already exist" end from = '"' + from + '"' if from . include? ' ' to = '"' + to + '"' if to . include? ' ' exec 'put ' + from + ' ' + to true rescue Client :: RuntimeError => e raise e if raise false end
976	def call ( env ) if rand ( 1 .. 100 ) <= @percent if @modify == :response response = @handler . call ( * @app . call ( env ) ) else modified_env = @handler . call ( env ) || env response = @app . call ( modified_env ) end else response = @app . call ( env ) end response end
265	def []= ( url , auth ) url = URI ( url ) path = URI . expand_path ( url . path ) key = [ url . scheme , url . host , url . port ] @credentials [ key ] ||= { } @credentials [ key ] [ path . split ( '/' ) ] = auth return auth end
702	def set_vm_ram ( vmid , memory_size ) params = { 'method' => :get , 'command' => "/vApp/vm-#{vmid}/virtualHardwareSection/memory" } get_response , headers = send_request ( params ) get_response . css ( "rasd|ElementName" ) . first . content = "#{memory_size} MB of memory" get_response . css ( "rasd|VirtualQuantity" ) . first . content = memory_size params [ 'method' ] = :put put_response , headers = send_request ( params , get_response . to_xml , "application/vnd.vmware.vcloud.rasdItem+xml" ) task_id = headers [ :location ] . gsub ( / \/ \/ / , "" ) task_id end
588	def save unless saved? || @contents . nil? || @name . nil? response = client . create_file ( @name , @contents , @mime_type ) unless response . error? result = response . result @name = result [ FIELD_NAME ] || File . basename ( result [ FIELD_URL ] ) @url = result [ FIELD_URL ] end end saved? end
505	def campaigns response = get 'campaigns' response . map { | item | Hashie :: Mash . new ( item ) } end
322	def load_config ( params = { } ) read_only_data = global_config . merge ( bot_config ) . merge ( params ) @config = Chatterbot :: ConfigManager . new ( config_file , read_only_data ) end
1295	def generate ( string ) x = [ ] @fst . _generate ( string ) { | a | x << a . join } x end
1293	def osx_notification ( message , subtitle , title ) TerminalNotifier . notify ( message , title : title , subtitle : subtitle ) end
293	def set_bearer_token ( token ) FHIR . logger . info 'Configuring the client to use Bearer Token authentication.' value = "Bearer #{token}" @security_headers = { 'Authorization' => value } @use_oauth2_auth = false @use_basic_auth = true @client = RestClient @client . proxy = proxy unless proxy . nil? @client end
1140	def log_time Mako . logger . info 'Generating...' start_time = Time . now . to_f yield generation_time = Time . now . to_f - start_time Mako . logger . info "done in #{generation_time} seconds" end
167	def method_missing ( method , * args , & block ) %w( url_for flash ) . include? ( method . to_s ) ? ProxyEmpty . new : super end
1250	def load_properties file = default_properties_file props = file && File . exists? ( file ) ? load_properties_file ( file ) : { } path = props [ :classpath ] || props [ :path ] || infer_classpath Java . expand_to_class_path ( path ) if path unless props . has_key? ( :host ) or props . has_key? ( :port ) then url = remote_service_url if url then host , port = url . split ( ':' ) props [ :host ] = host props [ :port ] = port end end unless props . has_key? ( :database ) then props . merge ( infer_database_properties ) end props end
880	def export_to_string ( options = { } ) hash = self . to_h image_layers = hash . delete ( :image_layers ) object_groups = hash . delete ( :object_groups ) hash [ :layers ] += image_layers hash [ :layers ] += object_groups hash [ :layers ] . sort_by! { | l | l [ :name ] } hash . delete ( :contents ) object_groups . each do | object_layer | object_layer [ "objects" ] . each do | object | object . delete ( "shape" ) object . delete ( "points" ) end end MultiJson . dump ( hash ) end
1388	def jd ( date = self ) index = ( 12 * ( date . year - 1 ) ) + date . month - 16260 mcjdn = date . day + HijriUmmAlqura :: UMMALQURA_DAT [ index - 1 ] - 1 mcjdn = mcjdn + 2400000 - 0.5 return mcjdn end
238	def reload ( client = nil ) return client . send ( Support . snakify ( self . class . name . split ( '::' ) . last ) , id ) unless client . nil? false end
921	def deregister ( * targets ) targets . each & Ducks . list . method ( :delete ) targets . each & decorators . method ( :delete ) end
1097	def render_opml ( list ) document = Nokogiri :: XML ( list . load_list ) feeds . each do | feed_url | node = "<outline xmlUrl='#{feed_url}' />\n" document . xpath ( "//outline[@text='Subscriptions']" ) . last . add_child node end formatted_no_decl = Nokogiri :: XML :: Node :: SaveOptions :: FORMAT + Nokogiri :: XML :: Node :: SaveOptions :: NO_DECLARATION document . to_xml ( encoding : 'utf-8' , save_with : formatted_no_decl ) end
362	def write_func_declaration type : , c_name : , args : [ ] , static : true write_func_prototype type , c_name , args , static : static @code << ";" new_line end
1290	def get_layout ( layout_path ) if layout_path . nil? contents = "---\n" contents << "title:\n" contents << "layout: post\n" contents << "date:\n" contents << "---\n" ext = nil else begin contents = File . open ( layout_path , "r" ) . read ( ) ext = layout_path . match ( / \. / ) [ 1 ] rescue Errno :: ENOENT bad_path ( layout_path ) end end return contents , ext end
1318	def open_file_dialog ( title , filepath , text = "" ) wait_and_focus_window ( title ) dialog = RFormSpec :: OpenFileDialog . new ( title , text ) dialog . enter_filepath ( filepath ) sleep 1 dialog . click_open end
1289	def ensure_jekyll_dir @orig_dir = Dir . pwd start_path = Pathname . new ( @orig_dir ) ok = File . exists? ( './_posts' ) new_path = nil if ! ok check_custom_src_dir! ok = File . exists? ( './_posts' ) new_path = Pathname . new ( Dir . pwd ) end if ok return ( new_path ? new_path . relative_path_from ( start_path ) : '.' ) else puts 'ERROR: Cannot locate _posts directory. Double check to make sure' puts ' that you are in a jekyll directory.' exit end end
1332	def read_hash ( name ) opts = self . class . persisted_attrs [ name ] if ! hashes [ name ] && opts [ :default ] opts [ :default ] else self . send ( "#{name}=" , hashes [ name ] . value ) if hashes [ name ] . is_a? ( Redis :: Future ) hashes [ name ] end end
454	def feed ( input ) head = @start . to_s input . each_char { | symbol | head = @transitions [ head ] [ symbol ] } accept = is_accept_state? head resp = { input : input , accept : accept , head : head } resp end
24	def handle_namespace_override ( args , key , ns ) add_extra_namespace ( ns ) new_key = prefix_key_with_namespace ( key . to_s . lower_camelcase , ns ) rename_hash_key ( args , key , new_key ) replace_array_item ( args [ :order! ] , key , new_key ) return new_key end
1296	def configure ( argv = ARGV ) cli = Options . new cli . parse_options ( argv ) json_config = Util . parse_json ( cli . config [ :config_file ] || Config . config_file ) config = [ json_config , cli . config ] . compact . reduce ( :merge ) config . each { | k , v | Config . send ( "#{k}=" , v ) } end
414	def report ( path , report_url = '' , delimiter = %r{ \/ \/ \/ \/ } ) setup classes = classes ( delimiter ) parser = Jacoco :: SAXParser . new ( classes ) Nokogiri :: XML :: SAX :: Parser . new ( parser ) . parse ( File . open ( path ) ) total_covered = total_coverage ( path ) report_markdown = "### JaCoCO Code Coverage #{total_covered[:covered]}% #{total_covered[:status]}\n" report_markdown << "| Class | Covered | Meta | Status |\n" report_markdown << "|:---|:---:|:---:|:---:|\n" class_coverage_above_minimum = markdown_class ( parser , report_markdown , report_url ) markdown ( report_markdown ) report_fails ( class_coverage_above_minimum , total_covered ) end
798	def respond_to? method , include_private = false true if bootstrap_admin_config . respond_to? method super method , include_private end
70	def should_log_payloads ( level , is_fault ) return level <= Logger :: INFO if is_fault return level <= Logger :: DEBUG end
735	def parse_result ( node , delegate ) if delegate method = delegate . is_a? ( Proc ) ? delegate : delegate . method ( delegate . respond_to? ( :call ) ? :call : :parse ) method . arity == 1 ? method [ node ] : method [ node , self ] else node end unless node . nil? end
734	def to_hash converter = lambda { | obj | obj . respond_to? ( :to_hash ) ? obj . to_hash : obj } self . class . rules . keys . inject ( { } ) do | hash , name | value = send ( name ) hash [ name . to_sym ] = Array === value ? value . map ( & converter ) : converter [ value ] hash end end
64	def exception_for_soap_fault ( response ) begin fault = response [ :fault ] if fault [ :detail ] and fault [ :detail ] [ :api_exception_fault ] exception_fault = fault [ :detail ] [ :api_exception_fault ] exception_name = ( exception_fault [ :application_exception_type ] || FALLBACK_API_ERROR_EXCEPTION ) exception_class = get_module ( ) . const_get ( exception_name ) return exception_class . new ( exception_fault ) elsif fault [ :faultstring ] fault_message = fault [ :faultstring ] return AdsCommon :: Errors :: ApiException . new ( "Unknown exception with error: %s" % fault_message ) else raise ArgumentError . new ( fault . to_s ) end rescue Exception => e return AdsCommon :: Errors :: ApiException . new ( "Failed to resolve exception (%s), SOAP fault: %s" % [ e . message , response . soap_fault ] ) end end
1107	def make_controlled_value ( value_hash ) cv = ControlledValue . new ( value_hash [ :value ] , value_hash [ :parent ] ) cv . identifier = value_hash [ :identifier ] cv . public_id = value_hash [ :public_id ] cv end
1049	def reset! self . api_key = DEFAULT_API_KEY self . api_secret = DEFAULT_API_SECRET self . adapter = DEFAULT_ADAPTER self . endpoint = DEFAULT_ENDPOINT self . user_agent = DEFAULT_USER_AGENT self . format = DEFAULT_FORMAT self . max = DEFAULT_MAX self . related_entities = DEFAULT_RELATED_ENTITIES self . show_metadata = DEFAULT_SHOW_METADATA self . enable_categorizer = DEFAULT_ENABLE_CATEGORIZER self . unique = DEFAULT_UNIQUE self end
250	def apply ( operations ) operations . inject ( self ) do | builder , ( name , argument ) | if argument == true || argument == nil builder . send ( name ) elsif argument . is_a? ( Array ) builder . send ( name , * argument ) else builder . send ( name , argument ) end end end
846	def each ( & block ) @reader . each do | node | if @reader . node_type == 1 && @reader . name == "Product" str = @reader . outer_xml if str . nil? yield @product_klass . new else yield @product_klass . from_xml ( str ) end end end end
661	def process_request ( data , client ) validated = @validated . include? ( client ) parser = @validating [ client . object_id ] if validated parser . process data else result = parser . signal ( data ) case result when :validated @validated . each do | old | old . write "\x02update\x03" end @validated << client if @validated . length > 1 client . write "\x02wait\x03" else client . write "\x02ready\x03" end @logger . verbose { "Client <0x#{client.object_id.to_s(16)}> connection was validated" } when :close_connection client . close @logger . warn "Client <0x#{client.object_id.to_s(16)}> connection was closed due to bad credentials" end end end
390	def redis_mock ( replies = { } ) begin pid = fork do trap ( "TERM" ) { exit } RedisMock . start do | command , * args | ( replies [ command . to_sym ] || lambda { | * _ | "+OK" } ) . call ( * args ) end end sleep 1 yield ensure if pid Process . kill ( "TERM" , pid ) Process . wait ( pid ) end end end
999	def calc_pointsize ( width , height , text , min_pointsize ) current_pointsize = min_pointsize metrics = nil loop { self . pointsize = current_pointsize last_metrics = metrics metrics = get_multiline_type_metrics ( text ) if metrics . width + stroke_padding > width or metrics . height + stroke_padding > height if current_pointsize > min_pointsize current_pointsize -= 1 metrics = last_metrics end break else current_pointsize += 1 end } [ current_pointsize , metrics ] end
1309	def connection @options [ :path ] = API_REST + @options [ :path ] @options [ :headers ] = HEADERS . merge ( { 'X-Megam-Date' => Time . now . strftime ( "%Y-%m-%d %H:%M" ) } ) . merge ( @options [ :headers ] ) text . info ( "HTTP Request Data:" ) text . msg ( "> HTTP #{@options[:scheme]}://#{@options[:host]}" ) @options . each do | key , value | text . msg ( "> #{key}: #{value}" ) end text . info ( "End HTTP Request Data." ) http = Net :: HTTP . new ( @options [ :host ] , @options [ :port ] ) http end
388	def acquire df = EM :: DefaultDeferrable . new @redis . lock_acquire ( [ @key ] , [ @token , @timeout ] ) . callback { | success | if ( success ) EM :: Hiredis . logger . debug "#{to_s} acquired" EM . cancel_timer ( @expire_timer ) if @expire_timer @expire_timer = EM . add_timer ( @timeout - 1 ) { EM :: Hiredis . logger . debug "#{to_s} Expires in 1s" @onexpire . call if @onexpire } df . succeed else EM :: Hiredis . logger . debug "#{to_s} failed to acquire" df . fail ( "Lock is not available" ) end } . errback { | e | EM :: Hiredis . logger . error "#{to_s} Error acquiring lock #{e}" df . fail ( e ) } df end
863	def befriend! new_friend run_callbacks :befriend do friendships . create! friend_id : new_friend . id , friend_type : new_friend . class . name end end
1219	def create_lookup_table File . open ( source ) . each_with_index do | line | next if line . chomp . empty? values = unstring ( line ) . chomp . split ( ';' ) next if values . empty? @joiners . each do | joiner | key = values [ joiner . join [ 0 ] ] joiner . lookup [ :rows ] [ key ] = [ ] joiner . cols . each do | i | joiner . lookup [ :rows ] [ key ] << values [ i ] end end end end
243	def process_xml ( xml ) doc = REXML :: Document . new xml if root = REXML :: XPath . first ( doc , 'xmlns:cartridge_basiclti_link' ) @title = get_node_text ( root , 'blti:title' ) @description = get_node_text ( root , 'blti:description' ) @launch_url = get_node_text ( root , 'blti:launch_url' ) @secure_launch_url = get_node_text ( root , 'blti:secure_launch_url' ) @icon = get_node_text ( root , 'blti:icon' ) @secure_icon = get_node_text ( root , 'blti:secure_icon' ) @cartridge_bundle = get_node_att ( root , 'xmlns:cartridge_bundle' , 'identifierref' ) @cartridge_icon = get_node_att ( root , 'xmlns:cartridge_icon' , 'identifierref' ) if vendor = REXML :: XPath . first ( root , 'blti:vendor' ) @vendor_code = get_node_text ( vendor , 'lticp:code' ) @vendor_description = get_node_text ( vendor , 'lticp:description' ) @vendor_name = get_node_text ( vendor , 'lticp:name' ) @vendor_url = get_node_text ( vendor , 'lticp:url' ) @vendor_contact_email = get_node_text ( vendor , '//lticp:contact/lticp:email' ) @vendor_contact_name = get_node_text ( vendor , '//lticp:contact/lticp:name' ) end if custom = REXML :: XPath . first ( root , 'blti:custom' , LTI_NAMESPACES ) set_properties ( @custom_params , custom ) end REXML :: XPath . each ( root , 'blti:extensions' , LTI_NAMESPACES ) do | vendor_ext_node | platform = vendor_ext_node . attributes [ 'platform' ] properties = { } set_properties ( properties , vendor_ext_node ) REXML :: XPath . each ( vendor_ext_node , 'lticm:options' , LTI_NAMESPACES ) do | options_node | opt_name = options_node . attributes [ 'name' ] options = { } set_properties ( options , options_node ) properties [ opt_name ] = options end self . set_ext_params ( platform , properties ) end end end
1172	def update_user_address ( user , address ) logger . debug { "Work around caTissue prohibition of #{user} address #{address} update by creating a new address record for a dummy user..." } address . identifier = nil perform ( :create , address ) { create_object ( address ) } logger . debug { "Worked around caTissue address update bug by swizzling the #{user} address #{address} identifier." } perform ( :update , user ) { update_object ( user ) } user end
309	def home_timeline ( * args , & block ) return unless require_login debug "check for home_timeline tweets since #{since_id_home_timeline}" opts = { :since_id => since_id_home_timeline , :count => 200 } results = client . home_timeline ( opts ) @current_tweet = nil results . each { | s | update_since_id_home_timeline ( s ) if block_given? && valid_tweet? ( s ) @current_tweet = s yield s end } @current_tweet = nil end
525	def update ( new_email_address , name ) options = { :query => { :email => @email_address } , :body => { :EmailAddress => new_email_address , :Name => name } . to_json } put '/admins.json' , options @email_address = new_email_address end
1335	def write_hash ( name , val ) raise "RedisAssist: tried to store a #{val.class.name} as Hash" unless val . is_a? ( Hash ) hashes [ name ] = val end
837	def []= ( key , value ) case value when String string ( key , equal_to : value . to_s ) else any ( key , equal_to : value . to_s ) end end
531	def images inline_attachments = mail . attachments . select ( & :inline? ) inline_attachments . collect do | attachment | { name : attachment . cid , type : attachment . mime_type , content : Base64 . encode64 ( attachment . body . decoded ) } end end
530	def attachments regular_attachments = mail . attachments . reject ( & :inline? ) regular_attachments . collect do | attachment | { name : attachment . filename , type : attachment . mime_type , content : Base64 . encode64 ( attachment . body . decoded ) } end end
462	def edit_token_pipeline ( caller_reference , return_url , options = { } ) cbui EditToken . new ( options . merge ( :caller_reference => caller_reference , :return_url => return_url ) ) end
824	def validate_ipv6_addr ( value ) ipaddr = IPAddr . new ( value ) unless ipaddr . ipv6? raise ValidationError , "IP address '#{value}' is not IPv6" end ipaddr rescue ArgumentError => e raise ValidationError , "invalid IPv6 address '#{value}' - #{e.message}" end
675	def delta ( other_audit ) return self . change_log if other_audit . nil? { } . tap do | d | ( self . change_log . keys - other_audit . change_log . keys ) . each do | k | d [ k ] = [ nil , self . change_log [ k ] ] end ( other_audit . change_log . keys - self . change_log . keys ) . each do | k | d [ k ] = [ other_audit . change_log [ k ] , nil ] end self . change_log . keys . each do | k | if self . change_log [ k ] != other_audit . change_log [ k ] d [ k ] = [ other_audit . change_log [ k ] , self . change_log [ k ] ] end end end end
698	def get_catalog ( catalogId ) params = { 'method' => :get , 'command' => "/catalog/#{catalogId}" } response , headers = send_request ( params ) description = response . css ( "Description" ) . first description = description . text unless description . nil? items = { } response . css ( "CatalogItem[type='application/vnd.vmware.vcloud.catalogItem+xml']" ) . each do | item | items [ item [ 'name' ] ] = item [ 'href' ] . gsub ( / \/ \/ / , "" ) end { :id => catalogId , :description => description , :items => items } end
65	def run_user_block ( extractor , response , body , & block ) header = extractor . extract_header_data ( response ) case block . arity when 1 then yield ( header ) when 2 then yield ( header , body ) else raise AdsCommon :: Errors :: ApiException , "Wrong number of block parameters: %d" % block . arity end return nil end
1209	def number ( col , comparator , number , args , block ) comparator = '==' if comparator == '=' operation = "[value] #{comparator} #{number}" pivot [ "#{comparator}#{number}" ] = { col : col , operation : operation } end
931	def browser_caps ( browser , browser_options ) target = ( browser . to_sym if ENV [ 'BROWSER' ] . nil? or ENV [ 'browser' ] . empty? ) || ( ENV [ 'BROWSER' ] . to_sym ) browser , version , platform , device = extract_values_from ( target ) options = { } options . merge! browser_options caps = capabilities ( browser , version , platform , device ) options [ :url ] = url if url if options . include? :url browser = :remote options [ :desired_capabilities ] = caps end options [ :http_client ] = http_client if persistent_http or options . delete ( :persistent_http ) return browser , options end
1179	def prepare_sum_row ( pattern ) return if pattern . nil? || pattern . empty? @sum_row_pos , sum_row_pattern = pattern . split ( / /i ) @sum_row_pos . upcase! @sum_row = Hash . new @sum_row_patterns = split_by_comma_regex ( sum_row_pattern ) end
26	def validate_array_arg ( arg , parent , key , arg_type ) result = arg . map do | item | validate_arg ( item , parent , key , arg_type ) end return result end
818	def convert_to_price ( price_str ) raise SolidusImportProducts :: Exception :: InvalidPrice unless price_str punt = price_str . index ( '.' ) coma = price_str . index ( ',' ) if ! coma . nil? && ! punt . nil? price_str . gsub! ( punt < coma ? '.' : ',' , '' ) end price_str . tr ( ',' , '.' ) . to_f end
1298	def remove_nonreporting_servers ( keeptime = nil ) list_nonreporting_servers . each do | server | next if keeptime && Time . parse ( server [ :last_reported_at ] ) >= Time . now - ChronicDuration . parse ( keeptime ) Notifier . msg ( server [ :name ] , 'Removing Stale, Non-Reporting Server' ) Client . delete_server ( server [ :id ] ) end end
184	def time_zone_definition! ( zone ) attributes = { 'Id' => zone [ :id ] } attributes [ 'Name' ] = zone [ :name ] if zone [ :name ] nbuild [ NS_EWS_TYPES ] . TimeZoneDefinition ( attributes ) end
146	def worksheet idx case idx when Integer @worksheets [ idx ] when String @worksheets . find do | sheet | sheet . name == idx end end end
1184	def resolve_dependency ( node ) node . seen = true @seen_this_pass << node node . edges . each do | edge | unless @resolved . include? edge unless @seen_this_pass . include? edge unless edge . seen? resolve_dependency edge end else raise CircularDependencyError , "Circular reference detected: #{node.key.to_s} - #{edge.key.to_s}" end end end @resolved << node end
947	def arrayorize ( value ) case value when nil then return [ ] when String then value . to_s . split when Symbol then value . to_s . split else value end end
1196	def write buffer = create_zip ( @entries , @ignore_entries ) puts "\nwrite file #{@output_file}" File . open ( @output_file , "wb" ) { | f | f . write buffer . string } end
181	def get_server_time_zones! ( get_time_zone_options ) nbuild [ NS_EWS_MESSAGES ] . GetServerTimeZones ( 'ReturnFullTimeZoneData' => get_time_zone_options [ :full ] ) do if get_time_zone_options [ :ids ] && get_time_zone_options [ :ids ] . any? nbuild [ NS_EWS_MESSAGES ] . Ids do get_time_zone_options [ :ids ] . each do | id | nbuild [ NS_EWS_TYPES ] . Id id end end end end end
540	def user_tips ( user_id , options = { } ) response = connection . get do | req | req . url "users/#{user_id}/tips" , options end tips = return_error_or_body ( response , response . body . response . tips ) tips = Foursquare2 . filter ( tips , options [ :query ] ) if options . has_key? :query tips end
1104	def find ( public_id_or_alias , value , recursive = false ) pid = ControlledValue . standard_public_id ( public_id_or_alias ) value_cv_hash = @pid_value_cv_hash [ pid ] cv = value_cv_hash [ value ] if recursive then fetch_descendants ( cv , value_cv_hash ) end cv end
308	def favorite ( id = @current_tweet ) return if require_login == false id = id_from_tweet ( id ) if debug_mode? debug "I'm in debug mode, otherwise I would favorite tweet id: #{id}" return end client . favorite id end
96	def normalize_hash_field ( field , field_def ) process_attributes ( field , true ) field_type = field_def [ :type ] field_def = get_full_type_signature ( field_type ) xsi_type_override = determine_xsi_type_override ( field , field_def ) unless xsi_type_override . nil? field_def = get_full_type_signature ( xsi_type_override ) return ( field_def . nil? ) ? field : normalize_fields ( field , field_def [ :fields ] ) end result = field choice_type_override = determine_choice_type_override ( field , field_def ) unless choice_type_override . nil? field_key = field . keys . first field_data = field [ field_key ] field_def = get_full_type_signature ( choice_type_override ) if ! field_def . nil? and field_data . kind_of? ( Hash ) field_data = normalize_fields ( field_data , field_def [ :fields ] ) end result = { field_key => field_data } else unless field_def . nil? result = normalize_fields ( field , field_def [ :fields ] ) end end if check_key_value_struct ( result ) result = convert_key_value_to_hash ( result ) end return result end
500	def custom_fields response = get "customfields" response . map { | item | Hashie :: Mash . new ( item ) } end
553	def event ( event_id , options = { } ) response = connection . get do | req | req . url "events/#{event_id}" , options end return_error_or_body ( response , response . body . response . event ) end
946	def file? ( method ) @files ||= { } @files [ method ] ||= begin file = @object . send ( method ) if @object && @object . respond_to? ( method ) file && :: Formula . file . any? { | method | file . respond_to? ( method ) } end end
615	def previous_node peer = nil if ! parent . nil? and parent . respond_to? ( :children ) index = parent . children . index ( self ) peer = index > 0 ? parent . children [ index - 1 ] : nil end peer end
136	def mark_as_unread ( user ) if previous_post . nil? read_state = postable . user_read_states . find_by ( user_id : user . id ) read_state . destroy if read_state else postable . user_read_states . touch! ( user . id , previous_post , overwrite_newer : true ) end end
273	def visit? ( url ) ! visited? ( url ) && visit_scheme? ( url . scheme ) && visit_host? ( url . host ) && visit_port? ( url . port ) && visit_link? ( url . to_s ) && visit_url? ( url ) && visit_ext? ( url . path ) && robot_allowed? ( url . to_s ) end
911	def option_parser params = [ "-#{@short}" , "--#{@long}" , nil , @options [ :type ] ] if ! @description . nil? and ! @description . empty? params [ 2 ] = @description end if ! [ TrueClass , FalseClass ] . include? ( @options [ :type ] ) params [ 1 ] += " #{@options[:key]}" end return params end
441	def refunds response = Charge . get ( URI . parse ( PinPayment . api_url ) . tap { | uri | uri . path = "/1/charges/#{token}/refunds" } ) response . map { | x | Refund . new ( x . delete ( 'token' ) , x ) } end
1066	def load_local_annotations return Array :: EMPTY_ARRAY if @ann_spec_hash . nil? initialize_annotation_holder @ann_spec_hash . map { | name , opts | import_annotation ( name , opts ) } end
1252	def download_files if ! File . exists? ( STATUS_FILE_PATH ) or File . mtime ( STATUS_FILE_PATH ) < Time . now - STATUS_DOWNLOAD_INTERVAL download_to_file STATUS_URL , STATUS_FILE_PATH end if ! File . exists? ( DATA_FILE_PATH ) or File . mtime ( DATA_FILE_PATH ) < Time . now - DATA_DOWNLOAD_INTERVAL download_to_file random_data_url , DATA_FILE_PATH end end
285	def post ( options = { } , & block ) response = http . post_uri ( options . merge ( :body => serialize ) , & block ) handle_response ( response ) end
1167	def make_default_consent_tier_statuses return if registration . nil? or registration . consent_tier_responses . empty? ctses = consent_tier_statuses . map { | cts | cts . consent_tier } registration . consent_tier_responses . each do | ctr | ct = ctr . consent_tier next if ctses . include? ( ct ) cts = CaTissue :: ConsentTierStatus . new ( :consent_tier => ct ) cts . add_defaults consent_tier_statuses << cts logger . debug { "Made default #{qp} #{cts.qp} for consent tier #{ct.qp}." } end end
1392	def raise ( exception = nil ) exception = case when exception == nil then StandardError . new when exception . is_a? ( Exception ) then exception when Exception >= exception then exception . new else Kernel . raise ( TypeError , "'exception' must be nil or an instance of or descendant of Exception" ) end @mutex . synchronize do Kernel . raise ( Complete ) if @complete @complete = true @exception = exception @waiter . resume_all_indefinitely end nil end
67	def format_headers ( headers ) return headers . map do | k , v | v = REDACTED_STR if k == 'Authorization' [ k , v ] . join ( ': ' ) end . join ( ', ' ) end
1115	def ping ( on : hosts , quiet : false ) log . info "ping" , quiet : quiet do hash_map ( hosts ) do | host | host . ping end end end
235	def do_build_resource ( response ) logger . debug ( response : response ) if logger configuration [ :resource_builder ] . new ( response . object , configuration . merge ( endpoint : response . request . endpoint ) , ( response . request . query || { } ) . fetch ( :locale , nil ) == '*' , 0 ) . run end
959	def lte ( query_string , options = { :case_sensitive => false } ) do_comparison ( query_string , options ) do | comparator , item | comparator >= item end end
255	def [] ( url ) url = URI ( url ) key = key_for ( url ) unless @sessions [ key ] session = Net :: HTTP :: Proxy ( @proxy . host , @proxy . port , @proxy . user , @proxy . password ) . new ( url . host , url . port ) session . open_timeout = @open_timeout if @open_timeout session . read_timeout = @read_timeout if @read_timeout session . continue_timeout = @continue_timeout if @continue_timeout session . keep_alive_timeout = @keep_alive_timeout if @keep_alive_timeout if url . scheme == 'https' session . use_ssl = true session . verify_mode = OpenSSL :: SSL :: VERIFY_NONE session . ssl_timeout = @ssl_timeout session . start end @sessions [ key ] = session end return @sessions [ key ] end
1014	def populate galena = CaTissue :: Institution . new ( :name => 'Galena University' ) addr = CaTissue :: Address . new ( :city => 'Galena' , :state => 'Illinois' , :country => 'United States' , :zipCode => '37544' , :street => '411 Basin St' , :phoneNumber => '311-555-5555' ) dept = CaTissue :: Department . new ( :name => 'Pathology' ) crg = CaTissue :: CancerResearchGroup . new ( :name => 'Don Thomas Cancer Center' ) coord = CaTissue :: User . new ( :email_address => 'corey.nator@galena.edu' , :last_name => 'Nator' , :first_name => 'Corey' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @hospital = CaTissue :: Site . new ( :site_type => CaTissue :: Site :: SiteType :: COLLECTION , :name => 'Galena Hospital' , :address => addr . copy , :coordinator => coord ) @tissue_bank = CaTissue :: Site . new ( :site_type => CaTissue :: Site :: SiteType :: REPOSITORY , :name => 'Galena Tissue Bank' , :address => addr . copy , :coordinator => coord ) pi = CaTissue :: User . new ( :email_address => 'vesta.gator@galena.edu' , :last_name => 'Gator' , :first_name => 'Vesta' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @surgeon = CaTissue :: User . new ( :email_address => 'serge.on@galena.edu' , :first_name => 'Serge' , :last_name => 'On' , :address => addr . copy , :institution => galena , :department => dept , :cancer_research_group => crg ) @protocol = CaTissue :: CollectionProtocol . new ( :title => 'Galena Migration' , :principal_investigator => pi , :sites => [ @tissue_bank ] ) cpe = CaTissue :: CollectionProtocolEvent . new ( :collection_protocol => @protocol , :event_point => 1.0 ) CaTissue :: TissueSpecimenRequirement . new ( :collection_event => cpe , :specimen_type => 'Fixed Tissue' ) @freezer_type = CaTissue :: StorageType . new ( :name => 'Galena Freezer' , :columns => 10 , :rows => 1 , :column_label => 'Rack' ) rack_type = CaTissue :: StorageType . new ( :name => 'Galena Rack' , :columns => 10 , :rows => 10 ) @box_type = CaTissue :: StorageType . new ( :name => 'Galena Box' , :columns => 10 , :rows => 10 ) @freezer_type << rack_type rack_type << @box_type @box_type << 'Tissue' @box = @box_type . new_container ( :name => 'Galena Box 1' ) end
68	def format_fault ( message ) if message . length > MAX_FAULT_LOG_LENGTH message = message [ 0 , MAX_FAULT_LOG_LENGTH ] end return message . gsub ( "\n" , ' ' ) end
813	def to_bbox ( long_or_short_names = :long ) case long_or_short_names when :long { :north => self . north , :east => self . east , :south => self . south , :west => self . west } when :short { :n => self . north , :e => self . east , :s => self . south , :w => self . west } else raise ArgumentError . new ( "Expected either :long or :short for long_or_short_names argument" ) end end
905	def after return to_enum ( __callee__ ) unless block_given? return if chain_tail? item = self . next loop do yield item item = item . next end end
644	def left_border_width = ( width ) size = width . nil? ? 0 : width if size > 0 @borders [ LEFT ] = size . to_i else @borders [ LEFT ] = nil end end
574	def mark_venue_todo ( venue_id , options = { } ) response = connection . post do | req | req . url "venues/#{venue_id}/marktodo" , options end return_error_or_body ( response , response . body . response ) end
1131	def copy_container_type_capacity return unless container_type and container_type . capacity self . capacity = cpc = container_type . capacity . copy ( :rows , :columns ) logger . debug { "Initialized #{qp} capacity from #{container_type.qp} capacity #{cpc}." } update_full_flag cpc end
1147	def add_defaults_local super self . capacity ||= Capacity . new . add_defaults self . row_label ||= capacity . rows && capacity . rows > 0 ? 'Row' : 'Unused' self . column_label ||= capacity . columns && capacity . columns > 0 ? 'Column' : 'Unused' end
403	def advanced_search ( args ) raise ArgumentError . new ( "Args cannot be blank" ) if args . nil? || args . empty? request_path = "#{base_url}/advanced_search?#{Rack::Utils.build_nested_query(args)}" get_json ( request_path ) end
223	def build_soap! ( & block ) opts = { :server_version => server_version , :impersonation_type => impersonation_type , :impersonation_mail => impersonation_address } opts [ :time_zone_context ] = @time_zone_context if @time_zone_context EwsBuilder . new . build! ( opts , & block ) end
205	def sync_items! ( sync_state = nil , sync_amount = 256 , sync_all = false , opts = { } ) item_shape = opts . has_key? ( :item_shape ) ? opts . delete ( :item_shape ) : { :base_shape => :default } sync_state ||= @sync_state resp = ews . sync_folder_items item_shape : item_shape , sync_folder_id : self . folder_id , max_changes_returned : sync_amount , sync_state : sync_state rmsg = resp . response_messages [ 0 ] if rmsg . success? @synced = rmsg . includes_last_item_in_range? @sync_state = rmsg . sync_state rhash = { } rmsg . changes . each do | c | ctype = c . keys . first rhash [ ctype ] = [ ] unless rhash . has_key? ( ctype ) if ctype == :delete || ctype == :read_flag_change rhash [ ctype ] << c [ ctype ] [ :elems ] [ 0 ] [ :item_id ] [ :attribs ] else type = c [ ctype ] [ :elems ] [ 0 ] . keys . first item = class_by_name ( type ) . new ( ews , c [ ctype ] [ :elems ] [ 0 ] [ type ] ) rhash [ ctype ] << item end end rhash else raise EwsError , "Could not synchronize: #{rmsg.code}: #{rmsg.message_text}" end end
1215	def execute File . new ( infile ) . each_with_index do | line , index | row = row_filter . process ( line , row : index ) next if row . nil? or row . chomp . empty? collection . each do | category , elements | values = elements [ :filter ] . process ( row ) values . chomp . split ( ';' ) . each do | value | elements [ :entries ] << value . chomp if elements [ :entries ] . index ( value . chomp ) . nil? end end end File . open ( outfile , 'w' ) do | out | collection . each do | category , elements | out . puts "[#{category}]" elements [ :entries ] . sort . each { | c | out . puts c } end end end
973	def bind raise ModelNotSetError . new ( "You must set the model before binding it." ) unless @model fields do | field | view_obj = self . view . viewWithTag ( field . tag ) @model . send ( "#{field.name}=" . to_sym , view_obj . text ) if view_obj . respond_to? ( :text ) end end
1260	def register_observer_class ( observer_class ) @observer_mutex . synchronize do return if @observed_models . include? ( observer_class ) @observed_models << observer_class log "EventListener: registering observer class #{observer_class}" observer_queue . bind ( models_exchange , routing_key : "#{Isimud.model_watcher_schema}.#{observer_class.base_class.name}.*" ) end end
217	def convert_id ( opts ) opts = opts . clone [ :id , :format , :destination_format , :mailbox ] . each do | k | validate_param ( opts , k , true ) end req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . ConvertId { | x | builder . nbuild . parent . default_namespace = @default_ns x . parent [ 'DestinationFormat' ] = opts [ :destination_format ] . to_s . camel_case x . SourceIds { | x | x [ NS_EWS_TYPES ] . AlternateId { | x | x . parent [ 'Format' ] = opts [ :format ] . to_s . camel_case x . parent [ 'Id' ] = opts [ :id ] x . parent [ 'Mailbox' ] = opts [ :mailbox ] } } } end end do_soap_request ( req , response_class : EwsResponse ) end
1227	def rows_from_params ( opts ) col_count = opts [ :cols ] row_count = opts [ :rows ] size = row_count * col_count if row_count && col_count rows = [ ] if values = opts [ :values ] if size values += [ NotAvailable ] * ( size - values . size ) elsif col_count values += [ NotAvailable ] * ( ( col_count - values . size ) % col_count ) elsif row_count values += [ NotAvailable ] * ( ( row_count - values . size ) % row_count ) col_count = values . size / row_count else col_count = Math . sqrt ( values . size ) . ceil values += [ NotAvailable ] * ( ( col_count - values . size ) % col_count ) end values . each_slice ( col_count ) { | row | rows << row } elsif opts [ :file ] File . foreach ( opts [ :file ] ) do | line | next if line . chomp . empty? values = line . split ( SEMICOLON ) rescue str2utf8 ( line ) . split ( SEMICOLON ) rows << values . collect { | v | v . strip . empty? ? NotAvailable : str2num ( v . chomp , opts [ :ds ] ) } end end rows end
1006	def home path = if ( env [ 'HOME' ] || env [ 'USERPROFILE' ] ) env [ 'HOME' ] || env [ 'USERPROFILE' ] elsif ( env [ 'HOMEDRIVE' ] && env [ 'HOMEPATH' ] ) "#{env['HOMEDRIVE']}#{env['HOMEPATH']}" else begin File . expand_path ( '~' ) rescue if File :: ALT_SEPARATOR 'C:/' else '/' end end end return Pathname . new ( path ) end
694	def get_task ( taskid ) params = { 'method' => :get , 'command' => "/task/#{taskid}" } response , headers = send_request ( params ) task = response . css ( 'Task' ) . first status = task [ 'status' ] start_time = task [ 'startTime' ] end_time = task [ 'endTime' ] { :status => status , :start_time => start_time , :end_time => end_time , :response => response } end
632	def font ( font , size = nil ) style = CharacterStyle . new style . font = font style . font_size = size root . fonts << font if block_given? apply ( style ) { | node | yield node } else apply ( style ) end end
423	def mtime ( file ) begin return unless file stat = File . stat ( file ) stat . file? ? stat . mtime . to_i : nil rescue Errno :: ENOENT , Errno :: ENOTDIR , Errno :: ESRCH nil end end
1324	def set_query_attributes! attr_names = self . class . search_query_attributes . map ( & :to_s ) self . query = attr_names . inject ( { } ) { | memo , attr | memo [ attr ] = self . send ( attr ) memo } end
1	def to_s super + ":\n" + format_observation ( result . control ) + "\n" + result . candidates . map { | candidate | format_observation ( candidate ) } . join ( "\n" ) + "\n" end
1204	def range ( start_value , end_value , args , block ) filter << ( start_value . to_i .. end_value . to_i ) . to_a end
354	def filtered_dependency_attributes filtered_attributes = dependency_attributes if attributes_blacklist . present? filtered_attributes = filtered_attributes . reject { | key , _value | attributes_blacklist . include? ( key ) } end if attributes_whitelist . present? filtered_attributes = filtered_attributes . select { | key , _value | attributes_whitelist . include? ( key ) } end filtered_attributes end
195	def sync_folder_items ( opts ) opts = opts . clone req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . SyncFolderItems { builder . nbuild . parent . default_namespace = @default_ns builder . item_shape! ( opts [ :item_shape ] ) builder . sync_folder_id! ( opts [ :sync_folder_id ] ) if opts [ :sync_folder_id ] builder . sync_state! ( opts [ :sync_state ] ) if opts [ :sync_state ] builder . ignore! ( opts [ :ignore ] ) if opts [ :ignore ] builder . max_changes_returned! ( opts [ :max_changes_returned ] ) builder . sync_scope! ( opts [ :sync_scope ] ) if opts [ :sync_scope ] } end end do_soap_request ( req , response_class : EwsResponse ) end
656	def add ( colour ) if colour . instance_of? ( Colour ) @colours . push ( colour ) if @colours . index ( colour ) . nil? end self end
229	def incoming_references ( client = nil , query = { } ) return false unless client query = is_a? ( Contentful :: Entry ) ? query . merge ( links_to_entry : id ) : query . merge ( links_to_asset : id ) client . entries ( query ) end
1201	def create_filter ( values ) values . scan ( / \/ \/ /i ) . flatten . each do | value | send ( value ) end unless values . nil? end
16	def report_utils ( version = nil ) version = api_config . default_version if version . nil? if ! api_config . versions . include? ( version ) raise AdsCommon :: Errors :: Error , "Unknown version '%s'" % version end return AdwordsApi :: ReportUtils . new ( self , version ) end
18	def run_with_temporary_flag ( flag_name , flag_value , block ) previous = @credential_handler . instance_variable_get ( flag_name ) @credential_handler . instance_variable_set ( flag_name , flag_value ) begin return block . call ensure @credential_handler . instance_variable_set ( flag_name , previous ) end end
371	def __expose! singleton = singleton_class singleton . private_instance_methods . each do | sym | singleton . send ( :public , sym ) end __module_info [ :private_constants ] . each do | sym | const_set ( sym , singleton . const_get ( sym ) ) end self end
450	def exec ( cmd ) @write1 . puts cmd text = @read2 . read @read2 . close @read2 , @write2 = IO . pipe raise Client :: RuntimeError , text if text . start_with? 'NT_STATUS_' text end
242	def set_ext_params ( ext_key , ext_params ) raise ArgumentError unless ext_params . is_a? ( Hash ) @extensions [ ext_key ] = ext_params end
1029	def tree ( root_depth : 1 , sitemap : false , nav_class : 'tree' ) return if m . parent_at_depth ( root_depth ) . nil? @sitemap = sitemap h . content_tag :nav , class : nav_class do h . concat render_tree_master_ul ( m . parent_at_depth ( root_depth ) ) end end
1345	def processor_count @processor_count ||= begin os_name = RbConfig :: CONFIG [ "target_os" ] if os_name =~ / / require 'win32ole' result = WIN32OLE . connect ( "winmgmts://" ) . ExecQuery ( "select NumberOfLogicalProcessors from Win32_Processor" ) result . to_enum . collect ( & :NumberOfLogicalProcessors ) . reduce ( :+ ) elsif File . readable? ( "/proc/cpuinfo" ) IO . read ( "/proc/cpuinfo" ) . scan ( / / ) . size elsif File . executable? ( "/usr/bin/hwprefs" ) IO . popen ( "/usr/bin/hwprefs thread_count" ) . read . to_i elsif File . executable? ( "/usr/sbin/psrinfo" ) IO . popen ( "/usr/sbin/psrinfo" ) . read . scan ( / / ) . size elsif File . executable? ( "/usr/sbin/ioscan" ) IO . popen ( "/usr/sbin/ioscan -kC processor" ) do | out | out . read . scan ( / / ) . size end elsif File . executable? ( "/usr/sbin/pmcycles" ) IO . popen ( "/usr/sbin/pmcycles -m" ) . read . count ( "\n" ) elsif File . executable? ( "/usr/sbin/lsdev" ) IO . popen ( "/usr/sbin/lsdev -Cc processor -S 1" ) . read . count ( "\n" ) elsif File . executable? ( "/usr/sbin/sysconf" ) and os_name =~ / /i IO . popen ( "/usr/sbin/sysconf NPROC_ONLN" ) . read . to_i elsif File . executable? ( "/usr/sbin/sysctl" ) IO . popen ( "/usr/sbin/sysctl -n hw.ncpu" ) . read . to_i elsif File . executable? ( "/sbin/sysctl" ) IO . popen ( "/sbin/sysctl -n hw.ncpu" ) . read . to_i else $stderr . puts "Unknown platform: " + RbConfig :: CONFIG [ "target_os" ] $stderr . puts "Assuming 1 processor." 1 end end end
1217	def log out . sync = true @log ||= Logger . new ( out ) @log . formatter = proc do | severity , datetime , progname , msg | if verbose string = "#{severity} [#{datetime.strftime('%Y-%m-%d %H:%M:%S.%2N')}]: " else string = "[#{datetime.strftime('%H:%M:%S')}]: " end string += "#{msg}\n" string end @log end
432	def radio ( name , locator ) define_method ( "#{name}" ) do adapter . radio ( locator ) . set end define_method ( "#{name}?" ) do adapter . radio ( locator ) . set? end define_method ( "#{name}_view" ) do adapter . radio ( locator ) . view end end
508	def lists response = get 'lists' response . map { | item | Hashie :: Mash . new ( item ) } end
431	def combo_box ( name , locator ) define_method ( "#{name}" ) do adapter . combo ( locator ) . value end define_method ( "clear_#{name}" ) do | item | adapter . combo ( locator ) . clear item end define_method ( "#{name}_selections" ) do adapter . combo ( locator ) . values end define_method ( "#{name}=" ) do | item | adapter . combo ( locator ) . set item end alias_method "select_#{name}" , "#{name}=" define_method ( "#{name}_options" ) do adapter . combo ( locator ) . options end define_method ( "#{name}_view" ) do adapter . combo ( locator ) . view end end
339	def find_central_directory ( io ) eocd_offset = - 22 loop do io . seek ( eocd_offset , IO :: SEEK_END ) if IOExtensions . read_exactly ( io , 4 ) == EOCD_SIGNATURE then io . seek ( 16 , IO :: SEEK_CUR ) if IOExtensions . read_exactly ( io , 2 ) . unpack ( 'v' ) [ 0 ] == ( eocd_offset + 22 ) . abs then break end end eocd_offset -= 1 end io . seek ( eocd_offset + 16 , IO :: SEEK_END ) return IOExtensions . read_exactly ( io , 4 ) . unpack ( 'V' ) [ 0 ] rescue Errno :: EINVAL raise Zip :: UnzipError , 'unable to locate end-of-central-directory record' end
1302	def validate ( value , format , raise_error = false ) unless FORMATS . key? ( format ) raise FormatError , "Invalid data format: #{format}" end result = value =~ FORMATS [ format ] ? true : false if raise_error && ! result raise ValidationError , "Invalid value \"#{value}\" for #{format}" end result end
596	def get ( uri , query = nil , headers = { } ) request :get , uri , query : query , headers : headers end
778	def find ( id , tomatoes = false , plot = "short" ) res = network . call ( { i : id , tomatoes : tomatoes , plot : plot } ) if res [ :data ] [ "Response" ] == "False" { status : 404 } else { status : res [ :code ] , movie : parse_movie ( res [ :data ] ) } end end
848	def title = ( str ) composite = product . titles . first if composite . nil? composite = ONIX :: Title . new composite . title_type = 1 product . titles << composite end composite . title_text = str end
1020	def user_by_name ( name ) data = api ( 'user.get_id' , :name => name ) user = self . user ( data [ 'userid' ] ) user . attributes = { 'name' => name } user end
895	def print_artifacts artifacts = build . artifacts return if artifacts . empty? content = "### Jenkins artifacts:\n\n" content << "<img width='40' align='right' src='#{JENKINS_ICON}'></img>\n" artifacts . each do | artifact | content << "* #{artifact_link(artifact)}\n" end markdown content end
737	def subject unless @subject subject = mail . subject . strip rescue "" ignores = config [ 'ignore' ] [ 'text/plain' ] if ignores && ignores . detect { | s | s == subject } @subject = "" else @subject = transform_text ( 'text/plain' , subject ) . last end end @subject end
577	def venues_timeseries ( options = { } ) options [ :venueId ] = options [ :venueId ] . join ( ',' ) response = connection . get do | req | req . url "venues/timeseries" , options end return_error_or_body ( response , response . body . response ) end
496	def set_primary_contact ( email ) options = { :query => { :email => email } } response = put ( "/primarycontact.json" , options ) Hashie :: Mash . new ( response ) end
312	def tweet ( txt , params = { } , original = nil ) return if require_login == false txt = replace_variables ( txt , original ) if debug_mode? debug "I'm in debug mode, otherwise I would tweet: #{txt}" else debug txt if params . has_key? ( :media ) file = params . delete ( :media ) if ! file . is_a? ( File ) file = File . new ( file ) end client . update_with_media txt , file , params else client . update txt , params end end rescue Twitter :: Error :: Forbidden => e debug e false end
989	def activate ( network ) request = Net :: HTTP :: Post . new ( URI . join ( @base_uri . to_s , "/cloudlets/api/v2/policies/#{@policy_id}/versions/#{@version_id}/activations" ) . to_s , { 'Content-Type' => 'application/json' } ) request . body = { "network" : network } . to_json response = @http_host . request ( request ) response . body end
604	def no_write! will_change! permissions . keys . each do | perm | permissions [ perm ] . write! false end end
1143	def publish ( params ) params [ :msgid ] = message_id = next_message_id params = @default_params . merge ( params ) logger . debug "Message sent: #{params.inspect}" if HTTP_APIS . include? ( params [ :api ] ) publish_to_http ( params ) else publish_to_socket ( params ) end EventMachine . add_timer ( @timeout ) do dispatch ( 'msgid' => message_id , 'command' => 'response_received' , 'error' => 'timed out' ) end if @timeout message_id end
20	def validate_choice_argument ( item , parent , key , item_type ) result = false if item_type . kind_of? ( Hash ) && item_type . include? ( :choices ) if item . kind_of? ( Array ) parent [ key ] = [ ] item . each do | sub_item | unless validate_choice_argument ( sub_item , parent , key , item_type ) validate_arg ( sub_item , parent , key , item_type ) end end return true end new_root = { } choice_items = arrayize ( item ) choice_items . each do | choice_item | choice_type = choice_item . delete ( :xsi_type ) choice_item_type = find_choice_by_xsi_type ( choice_type , item_type [ :choices ] ) if choice_type . nil? || choice_item_type . nil? raise AdsCommon :: Errors :: TypeMismatchError . new ( 'choice subtype' , choice_type , choice_item . to_s ( ) ) end choice_item [ :xsi_type ] = choice_type choice_key = choice_item_type [ :original_name ] new_root [ choice_key ] = choice_item type_signature = get_full_type_signature ( choice_type ) validate_arg ( choice_item , new_root , choice_key , type_signature ) end if parent [ key ] . kind_of? ( Array ) parent [ key ] << new_root else parent [ key ] = new_root end result = true end return result end
299	def bot return @bot unless @bot . nil? @bot_command = nil params = { } opts = OptionParser . new opts . banner = "Usage: #{File.basename($0)} [options]" opts . separator "" opts . separator "Specific options:" opts . on ( '-c' , '--config [ARG]' , "Specify a config file to use" ) { | c | ENV [ "chatterbot_config" ] = c } opts . on ( '-t' , '--test' , "Run the bot without actually sending any tweets" ) { params [ :debug_mode ] = true } opts . on ( '-v' , '--verbose' , "verbose output to stdout" ) { params [ :verbose ] = true } opts . on ( '--dry-run' , "Run the bot in test mode, and also don't update the database" ) { params [ :debug_mode ] = true ; params [ :no_update ] = true } opts . on ( '-r' , '--reset' , "Reset your bot to ignore old tweets" ) { @bot_command = :reset_since_id_counters } opts . on ( '--profile [ARG]' , "get/set your bot's profile text" ) { | p | @bot_command = :profile_text @bot_command_args = [ p ] } opts . on ( '--website [ARG]' , "get/set your bot's profile URL" ) { | u | @bot_command = :profile_website @bot_command_args = [ u ] } opts . on_tail ( "-h" , "--help" , "Show this message" ) do puts opts exit end opts . parse! ( ARGV ) @bot = Chatterbot :: Bot . new ( params ) if @bot_command != nil @bot . skip_run = true result = @bot . send ( @bot_command , * @bot_command_args ) puts result end @bot end
1156	def init_sum_scheme ( sum_scheme ) row_scheme , col_scheme = sum_scheme . split ( ',' ) unless sum_scheme . nil? unless row_scheme . nil? @sum_row_title , @sum_row = row_scheme . split ( ':' ) unless row_scheme . empty? end @sum_row . nil? ? @sum_row = 0 : @sum_row = @sum_row . to_i @sum_row_title = 'Total' if @sum_row_title . nil? col_scheme . nil? ? @sum_col_title = 'Total' : @sum_col_title = col_scheme @sum_col = 0 end
580	def add_photo ( options = { } ) response = connection . post ( 'photos/add' , options ) return_error_or_body ( response , response . body . response . photo ) end
126	def exec ( cmd , nohup_log ) start = Time . now Open3 . popen2e ( { 'MALLOC_ARENA_MAX' => '2' } , cmd ) do | stdin , stdout , thr | nohup_log . print ( "Started process ##{thr.pid} from process ##{Process.pid}: #{cmd}\n" ) stdin . close until stdout . eof? begin line = stdout . gets rescue IOError => e line = Backtrace . new ( e ) . to_s end nohup_log . print ( line ) end nohup_log . print ( "Nothing else left to read from ##{thr.pid}\n" ) code = thr . value . to_i nohup_log . print ( "Exit code of process ##{thr.pid} is #{code}, was alive for #{Age.new(start)}: #{cmd}\n" ) code end end
1300	def send_sms_confirmation! return false if _TC_sms_blocked return true if sms_confirmed? return false if _TC_phone_number . blank? format_phone_number confirmation_code = TwilioContactable . confirmation_code ( self , :sms ) message = ( self . class . respond_to? ( :confirmation_message ) ? self . class : TwilioContactable ) . confirmation_message ( confirmation_code ) if message . to_s . size > 160 raise ArgumentError , "SMS Confirmation Message is too long. Limit it to 160 characters of unescaped text." end response = TwilioContactable :: Gateway . deliver_sms ( message , _TC_formatted_phone_number ) if response . success? update_twilio_contactable_sms_confirmation confirmation_code end response end
585	def format_value ( key , val , data_type = nil ) data_type ||= self . fields [ key ] val = format_operation ( key , val , data_type ) case data_type when :object val = val . with_indifferent_access if val . is_a? ( Hash ) when :array val = val . to_a if val . is_a? ( Parse :: CollectionProxy ) val = [ val ] unless val . is_a? ( Array ) val . compact! val = Parse :: CollectionProxy . new val , delegate : self , key : key when :geopoint val = Parse :: GeoPoint . new ( val ) unless val . blank? when :file val = Parse :: File . new ( val ) unless val . blank? when :bytes val = Parse :: Bytes . new ( val ) unless val . blank? when :integer if val . nil? || val . respond_to? ( :to_i ) == false val = nil else val = val . to_i end when :boolean if val . nil? val = nil else val = val ? true : false end when :string val = val . to_s unless val . blank? when :float val = val . to_f unless val . blank? when :acl val = ACL . typecast ( val , self ) when :date if val . respond_to? ( :parse_date ) && val . is_a? ( Parse :: Date ) == false val = val . parse_date elsif val . is_a? ( Hash ) val = Parse :: Date . parse ( val [ "iso" ] || val [ :iso ] ) elsif val . is_a? ( String ) val = Parse :: Date . parse val end when :timezone val = Parse :: TimeZone . new ( val ) if val . present? else if data_type . respond_to? ( :typecast ) val = data_type . typecast ( val ) else warn "Property :#{key}: :#{data_type} has no valid data type" val = val end end val end
856	def add_subject ( str , type = "12" ) subject = :: ONIX :: Subject . new subject . subject_scheme_id = type . to_i subject . subject_code = str product . subjects << subject end
1200	def pivot_each_column ( values = [ ] ) pivot . each do | column , parameters | value = values [ parameters [ :col ] . to_i ] value = value . strip . gsub ( / / , "" ) unless value . nil? match = false begin match = eval ( parameters [ :operation ] . gsub ( '[value]' , value ) ) rescue Exception => e end yield column , match end end
429	def text ( name , locator ) define_method ( "#{name}" ) do adapter . text ( locator ) . value end define_method ( "#{name}=" ) do | text | adapter . text ( locator ) . set text end define_method ( "clear_#{name}" ) do adapter . text ( locator ) . clear end define_method ( "enter_#{name}" ) do | text | adapter . text ( locator ) . enter text end define_method ( "#{name}_view" ) do adapter . text ( locator ) . view end end
214	def empty_folder ( opts ) validate_version ( VERSION_2010_SP1 ) ef_opts = { } [ :delete_type , :delete_sub_folders ] . each do | k | ef_opts [ camel_case ( k ) ] = validate_param ( opts , k , true ) end fids = validate_param opts , :folder_ids , true req = build_soap! do | type , builder | if ( type == :header ) else builder . nbuild . EmptyFolder ( ef_opts ) { | x | builder . nbuild . parent . default_namespace = @default_ns builder . folder_ids! ( fids ) } end end do_soap_request ( req ) end
43	def version_has_service ( version , service ) return service_config . include? ( version ) && service_config [ version ] . include? ( service ) end
811	def to_g_polyline_api2 ( polyline_options = { } , options = { } ) klass = if options [ :short_class ] 'GPolyline' else 'google.maps.Polyline' end poly_opts = if polyline_options [ :polyline_options ] Geos :: Helper . camelize_keys ( polyline_options [ :polyline_options ] ) end args = [ ( polyline_options [ :color ] ? "'#{Geos::Helper.escape_javascript(polyline_options[:color])}'" : 'null' ) , ( polyline_options [ :weight ] || 'null' ) , ( polyline_options [ :opacity ] || 'null' ) , ( poly_opts ? poly_opts . to_json : 'null' ) ] . join ( ', ' ) "new #{klass}([#{self.to_g_lat_lng(options).join(', ')}], #{args})" end
1121	def stickers_purchased data = api ( 'sticker.get_purchased_stickers' ) data [ 'stickers' ] . map { | sticker_id | Sticker . new ( client , :_id => sticker_id ) } end
114	def exists? ( id , body ) DirItems . new ( @dir ) . fetch . each do | f | next unless f . start_with? ( "#{id}-" ) return true if safe_read ( File . join ( @dir , f ) ) == body end false end
1171	def update_changed_dependent ( owner , property , dependent , autogenerated ) if CollectibleEventParameters === dependent then logger . debug { "Work around a caTissue bug by resaving the collected #{owner} #{dependent} directly rather than via a cascade..." } update_from_template ( dependent ) elsif CaTissue :: User === owner and property . attribute == :address then update_user_address ( owner , dependent ) elsif CaTissue :: Specimen === owner and CaTissue :: Specimen === dependent then logger . debug { "Work around caTissue bug to update #{dependent} separately after the parent #{owner} update..." } prepare_specimen_for_update ( dependent ) update_from_template ( dependent ) logger . debug { "Updated the #{owner} child #{dependent}." } elsif CaTissue :: ConsentTierStatus === dependent then update_from_template ( owner ) else super end end
1365	def set_pagination_info ( page_no , page_size , record_count ) @current_page = page_no @per_page = page_size @total_count = record_count @total_pages = ( record_count / page_size . to_f ) . ceil extend PaginationMethods self end
178	def folder_id! ( fid , change_key = nil ) attribs = { 'Id' => fid } attribs [ 'ChangeKey' ] = change_key if change_key @nbuild [ NS_EWS_TYPES ] . FolderId ( attribs ) end
901	def option ( opt ) opt = opt . to_sym options . each do | op | if op . short === opt or op . long === opt return op . value end end end
74	def get_stream_helper_with_awql ( report_query , format , cid = nil ) return AdwordsApi :: ReportStream . set_up_with_awql ( self , report_query , format , cid ) end
377	def upload ( options = { } ) args = { } args [ :body ] = options [ :raw64 ] if options [ :raw64 ] args [ :method ] = options [ :method ] || 'base64' args . merge! ( options ) response = request ( 'in' , :multipart , args ) unless response . match ( / \A \| / ) fail ( TwoCaptcha :: Error , 'Unexpected API Response' ) end TwoCaptcha :: Captcha . new ( id : response . split ( '|' , 2 ) [ 1 ] , api_response : response ) end
174	def item_shape! ( item_shape ) @nbuild [ NS_EWS_MESSAGES ] . ItemShape { @nbuild . parent . default_namespace = @default_ns base_shape! ( item_shape [ :base_shape ] ) mime_content! ( item_shape [ :include_mime_content ] ) if item_shape . has_key? ( :include_mime_content ) body_type! ( item_shape [ :body_type ] ) if item_shape [ :body_type ] if ( item_shape [ :additional_properties ] ) additional_properties! ( item_shape [ :additional_properties ] ) end } end
990	def update ( options = { } , existing_rules = [ ] ) request = Net :: HTTP :: Put . new ( URI . join ( @base_uri . to_s , "cloudlets/api/v2/policies/#{@policy_id}/versions/#{@version_id}?omitRules=false&matchRuleFormat=1.0" ) . to_s , { 'Content-Type' => 'application/json' } ) rules = generate_path_rules ( options ) + generate_cookie_rules ( options ) + existing_rules if rules . empty? puts "No rules to apply, please check syntax" return end request . body = { matchRules : rules } . to_json response = @http_host . request ( request ) response . body end
859	def price_set ( type , num ) p = price_get ( type ) if p . nil? supply = find_or_create_supply_detail p = ONIX :: Price . new p . price_type_code = type supply . prices << p end p . price_amount = num end
524	def bounces ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "bounces" , date , page , page_size , order_field , order_direction ) end
389	def unlock EM . cancel_timer ( @expire_timer ) if @expire_timer df = EM :: DefaultDeferrable . new @redis . lock_release ( [ @key ] , [ @token ] ) . callback { | keys_removed | if keys_removed > 0 EM :: Hiredis . logger . debug "#{to_s} released" df . succeed else EM :: Hiredis . logger . debug "#{to_s} could not release, not held" df . fail ( "Cannot release a lock we do not hold" ) end } . errback { | e | EM :: Hiredis . logger . error "#{to_s} Error releasing lock #{e}" df . fail ( e ) } df end
33	def time_to_xml_hash ( time ) return { :hour => time . hour , :minute => time . min , :second => time . sec , :date => { :year => time . year , :month => time . month , :day => time . day } } end
992	def convert ( valueToConvert , firstUnit , secondUnit ) finalValue = valueToConvert . round ( 10 ) firstUnitResultant = getInDictionary ( firstUnit ) if firstUnitResultant . nil? raise NotImplementedError . new ( "#{firstUnit} isn't recognized by InoxConverter" ) end finalValue *= firstUnitResultant . round ( 10 ) secondUnitResultant = getInDictionary ( secondUnit ) if secondUnitResultant . nil? raise NotImplementedError . new ( "#{secondUnit} isn't recognized by InoxConverter" ) end finalValue /= secondUnitResultant . round ( 10 ) return finalValue . round ( 10 ) end
274	def accept? ( data ) unless @accept . empty? @accept . any? { | rule | test_data ( data , rule ) } else ! @reject . any? { | rule | test_data ( data , rule ) } end end
965	def validate_length ( field , value , setting ) if value . is_a? ( String ) || value . nil? result = value . nil? || ( value . length < setting . first || value . length > setting . last ) add_message ( field , "incorrect value supplied for #{field.to_s} -- should be between #{setting.first} and #{setting.last} characters long." ) if result return ! result end return false end
891	def resolve_foreign_objects ( object , map ) object . foreign_objects . each do | property | value = object [ property ] if value . present? foreign_object = ForeignObject . new ( value ) resolve_foreign_keys ( foreign_object , map ) document = connection . find ( foreign_object . to_h ) if document object [ "#{property}_id" ] = document [ '_id' ] else raise Errors :: MissingDatabaseIdError , "couldn't resolve foreign object: #{property} #{value}" end end end end
1393	def to_hash index_hash = Hash . new index_hash [ "json_claz" ] = self . class . name index_hash [ "creationDate" ] = creationDate index_hash [ "admin" ] = admin index_hash [ "type" ] = type index_hash [ "password" ] = password index_hash [ "name" ] = name index_hahs [ "mail" ] = mail index_hash [ "displayName" ] = displayName index_hash [ "lastModified" ] = lastModified index_hash [ "active" ] = active index_hash [ "some_msg" ] = some_msg index_hash end
353	def uniq_keys_candidates ( keys ) uniq_key_candidates = unique_indexes . each_with_object ( [ ] ) { | i , obj | obj << i if ( keys - i . columns . map ( & :to_sym ) ) . empty? } if unique_indexes . blank? || uniq_key_candidates . blank? raise "#{self} and its table #{model_class.table_name} must have a unique index defined " "covering columns #{keys} to be able to use saver_strategy :concurrent_safe_batch." end uniq_key_candidates end
520	def opens ( date = "" , page = 1 , page_size = 1000 , order_field = "date" , order_direction = "asc" ) paged_result_by_date ( "opens" , date , page , page_size , order_field , order_direction ) end
1068	def create current_count = UniqueKey . where ( list_key_params ) . count if params [ :max ] == 'Infinity' || current_count < params [ :max ] . to_i unique_key = list_key_params . merge ( position : current_count + 1 ) viewable = UniqueKey . create_localized_viewable! ( unique_key ) if unique_key [ :viewable_type ] != 'Viewable::Block' path = rails_admin . edit_path ( model_name : unique_key [ :viewable_type ] . to_s . underscore . gsub ( '/' , '~' ) , id : viewable . id ) redirect_to path else redirect_to :back end else redirect_to :back end end
281	def each_redirect ( & block ) return enum_for ( __method__ ) unless block if ( locations = @response . get_fields ( 'Location' ) ) locations . each ( & block ) else each_meta_redirect ( & block ) end end
758	def full_feature ( value = true ) return unless value @config . formulize @config . event = ( @config . event + [ :call , :return ] ) . uniq @config . import_return_to_call = true @config . show_additional_attrs = [ :path , :lineno ] if value == 10 @config . include_instance_var = true @config . include_local_var = true end end
1287	def daemon ENV [ 'TZ' ] = 'UTC' if OS . windows? && ! ENV [ 'TZ' ] scheduler = Rufus :: Scheduler . new Notifier . msg ( 'Daemonizing Process' ) alerts_interval = Config . alert_management_interval scheduler . every alerts_interval , overlap : false do Manager . manage_alerts end if Config . cleanup cleanup_interval = Config . cleanup_interval cleanup_age = Config . cleanup_age scheduler . every cleanup_interval , overlap : false do Manager . remove_nonreporting_servers ( cleanup_age ) end end scheduler . join end
933	def extract_browser ( value ) browser = value . to_s . split ( / \d / ) [ 0 ] browser = browser . to_s . split ( '|' ) [ 0 ] if browser . to_s . include? '|' browser end
421	def find_files_for_reload paths = [ './' , * $LOAD_PATH ] . uniq [ $0 , * $LOADED_FEATURES ] . uniq . map do | file | next if file =~ / \. / yield ( find ( file , paths ) ) end end
1011	def weekdays_field ( attribute , options = { } ) db_field = options [ :db_field ] || attribute . to_s + '_bit_array' self . composed_of ( attribute , :class_name => "::Timely::WeekDays" , :mapping => [ [ db_field , 'weekdays_int' ] ] , :converter => Proc . new { | field | :: Timely :: WeekDays . new ( field ) } ) end
31	def get_full_type_signature ( type_name ) result = ( type_name . nil? ) ? nil : @registry . get_type_signature ( type_name ) result [ :fields ] = implode_parent ( result ) if result and result [ :base ] return result end
1331	def read_list ( name ) opts = self . class . persisted_attrs [ name ] if ! lists [ name ] && opts [ :default ] opts [ :default ] else send ( "#{name}=" , lists [ name ] . value ) if lists [ name ] . is_a? ( Redis :: Future ) lists [ name ] end end
1378	def find_closest_term_color ( pixel_values ) color = "" lil_dist = 195075 @@palette . each do | col_name , col_values | dist = find_distance ( col_values , pixel_values ) if dist < lil_dist lil_dist = dist color = col_name end end color end
236	def resolve ( client , query = { } ) id_and_query = [ ( id unless link_type == 'Space' ) ] . compact + [ query ] client . public_send ( Contentful :: Support . snakify ( link_type ) . to_sym , * id_and_query ) end
637	def column_shading_colour ( index , colour ) self . each do | row | cell = row [ index ] cell . shading_colour = colour if cell != nil end end
501	def segments response = get "segments" response . map { | item | Hashie :: Mash . new ( item ) } end
589	def where ( constraints = nil ) return query . compile_where unless constraints . is_a? ( Hash ) query . where constraints query end
