7688	function OpenXML_Rels_ReplaceTarget ( $ RelsPath , $ OldTarget , $ NewTarget ) { $ idx = $ this -> FileGetIdx ( $ RelsPath ) ; if ( $ idx === false ) $ this -> RaiseError ( "Cannot edit target in '$RelsPath' because the file is not found." ) ; $ txt = $ this -> TbsStoreGet ( $ idx , 'Replace target in rels file' ) ; $ att = 'Target="' . $ OldTarget . '"' ; $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ txt , $ att , 0 ) ; if ( $ loc ) { if ( $ NewTarget === false ) { $ loc -> Delete ( ) ; } else { $ loc -> ReplaceAtt ( 'Target' , $ NewTarget ) ; } $ this -> TbsStorePut ( $ idx , $ txt ) ; return true ; } else { return false ; } }
1832	public function onRegister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( ! $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> registerAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
10902	public function loadRelation ( string $ name ) { if ( ! isset ( $ this -> relationObjects [ $ name ] ) || empty ( $ this -> relationObjects [ $ name ] ) ) { $ relation = $ this -> getRelations ( ) [ $ name ] ; if ( ! $ relation || ! $ relation [ 'entity' ] || ! $ this -> get ( $ relation [ 'key' ] ?? 'id' ) ) { return null ; } $ entity = $ this -> entity ( $ relation [ 'entity' ] ) ; $ type = $ relation [ 'type' ] ?? 'has_one' ; $ key = $ relation [ 'key' ] ?? ( 'has_one' === $ type ? $ this -> __getEntityName ( ) . '_id' : 'id' ) ; $ foreignKey = $ relation [ 'foreign_key' ] ?? ( 'has_one' === $ type ? 'id' : $ this -> __getEntityName ( ) . '_id' ) ; $ assoc = $ relation [ 'assoc' ] ?? false ; $ this -> relationObjects [ $ name ] = ( 'has_one' === $ type ) ? $ entity -> load ( $ this -> get ( $ key ) , $ foreignKey ) : $ entity -> loadAll ( [ $ foreignKey => $ this -> get ( $ key ) ] , $ assoc ) ; } return $ this -> relationObjects [ $ name ] ?? null ; }
4742	public function isReviewOptInValidationRequired ( ) { return ( bool ) \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( self :: REVIEW_OPTIN_PARAM ) ; }
2438	public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { if ( \ in_array ( $ k , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ k , $ v ) ; } else { $ this -> sessionBag -> set ( $ k , $ v ) ; } } }
11927	public function actionRunOne ( ) { $ this -> out ( "Run Interface " . $ this -> dataInterface -> object -> name , Console :: UNDERLINE , Console :: FG_GREEN ) ; $ this -> hr ( ) ; $ this -> dataInterface -> run ( null , new ConsoleAction ( ) ) ; }
8269	public function read ( ) { $ this -> open ( ) ; $ data = file_get_contents ( $ this -> filePath ) ; if ( $ data === false ) { throw new \ RuntimeException ( "Could not read from file " . $ this -> filePath ) ; } return $ data ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
4040	protected function generateOption ( $ val , $ index ) { $ checked = '' ; if ( is_array ( $ this -> varValue ) && in_array ( $ val [ 'value' ] , $ this -> varValue ) ) { $ checked = ' checked="checked"' ; } return sprintf ( '<span class="%1$s opt_%2$s">' . '<input type="checkbox" name="%8$s[]" id="opt_%3$s" class="checkbox" value="%4$s"%5$s%6$s ' . '<label id="lbl_%3$s" for="opt_%3$s">%7$s</label></span>' , $ this -> getClassForOption ( $ index ) , $ index , $ this -> strName . '_' . $ index , $ val [ 'value' ] , $ checked , $ this -> getAttributes ( ) . $ this -> strTagEnding , $ val [ 'label' ] , $ this -> strName ) ; }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
1700	public function unzip ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ strName = $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name' ] ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'general_purpose_bit_flag' ] & 0x0001 ) { throw new \ Exception ( "File $strName is encrypted" ) ; } if ( @ fseek ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'offset_of_local_header' ] ) !== 0 ) { throw new \ Exception ( "Cannot reposition pointer" ) ; } $ strSignature = @ fread ( $ this -> resFile , 4 ) ; if ( $ strSignature != self :: FILE_SIGNATURE ) { throw new \ Exception ( "$strName is not a compressed file" ) ; } fseek ( $ this -> resFile , 24 , SEEK_CUR ) ; $ arrEFL = unpack ( 'v' , @ fread ( $ this -> resFile , 2 ) ) ; fseek ( $ this -> resFile , ( $ this -> arrFiles [ $ this -> intIndex ] [ 'file_name_length' ] + $ arrEFL [ 1 ] ) , SEEK_CUR ) ; if ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] < 1 ) { return '' ; } $ strBuffer = @ fread ( $ this -> resFile , $ this -> arrFiles [ $ this -> intIndex ] [ 'compressed_size' ] ) ; switch ( $ this -> arrFiles [ $ this -> intIndex ] [ 'compression_method' ] ) { case 0 : break ; case 8 : $ strBuffer = gzinflate ( $ strBuffer ) ; break ; case 12 : if ( ! \ extension_loaded ( 'bz2' ) ) { throw new \ Exception ( 'PHP extension "bz2" required to decompress BZIP2 files' ) ; } $ strBuffer = bzdecompress ( $ strBuffer ) ; break ; default : throw new \ Exception ( 'Unknown compression method' ) ; break ; } if ( $ strBuffer === false ) { throw new \ Exception ( 'Could not decompress data' ) ; } if ( \ strlen ( $ strBuffer ) != $ this -> arrFiles [ $ this -> intIndex ] [ 'uncompressed_size' ] ) { throw new \ Exception ( 'Size of the uncompressed file does not match header value' ) ; } return $ strBuffer ; }
12349	public function getTaxonomy ( $ system_id ) { foreach ( $ this -> getTaxonomies ( ) as $ taxonomy ) { if ( $ taxonomy -> system_id === $ system_id ) { return $ taxonomy ; } } return false ; }
5259	public static function all ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ collection = collect ( ) ; static :: map ( $ query , function ( ElasticsearchModel $ document ) use ( $ collection ) { $ collection -> put ( $ document -> getId ( ) , $ document ) ; } ) ; return $ collection ; }
3005	static public function ping ( \ Base $ f3 , $ params ) { $ hash = $ params [ 'hash' ] ; if ( $ f3 -> exists ( 'mailer.on.ping' , $ ping_handler ) ) $ f3 -> call ( $ ping_handler , array ( $ hash ) ) ; $ img = new \ Image ( ) ; $ img -> load ( base64_decode ( 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMA' . 'AAAl21bKAAAABGdBTUEAALGPC/xhBQAAAANQTFRFAAAAp3o92gAAAAF0U' . 'k5TAEDm2GYAAAAKSURBVAjXY2AAAAACAAHiIbwzAAAAAElFTkSuQmCC' ) ) ; $ img -> render ( ) ; }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
7995	public function getVpsList ( ) { $ request = $ this -> get ( 'vps' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
1529	public function route ( ) : RouteRegistration { $ route = new RouteRegistration ( $ this -> router , $ this , $ this -> defaults ) ; $ route -> controller ( $ this -> options [ 'controller' ] ?? '' ) ; return $ route ; }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
2046	private function getTempDir ( ) : string { $ container = $ this -> getContainer ( ) ; $ tmpDir = sys_get_temp_dir ( ) . '/' . md5 ( $ container -> getParameter ( 'kernel.project_dir' ) ) ; if ( ! is_dir ( $ tmpDir ) ) { $ container -> get ( 'filesystem' ) -> mkdir ( $ tmpDir ) ; } return $ tmpDir ; }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
2667	public function getSingleDictionary ( $ version , $ dictionaryName ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary/' . $ dictionaryName ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
12608	public function getChild ( $ type ) { if ( isset ( $ this -> _children [ $ type ] ) ) { return $ this -> _children [ $ type ] ; } return false ; }
3917	protected function sortByRandom ( ) { $ arrFiles = $ this -> foundFiles ; $ arrSource = $ this -> outputBuffer ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ keys = array_keys ( $ arrFiles ) ; $ files = array ( ) ; shuffle ( $ keys ) ; foreach ( $ keys as $ key ) { $ files [ $ key ] = $ arrFiles [ $ key ] ; } return $ this -> remapSorting ( $ files , $ arrSource ) ; }
3781	private function determineFilterValue ( $ filterValues , $ valueName ) { if ( ! isset ( $ filterValues [ $ valueName ] ) && $ this -> get ( 'defaultid' ) ) { return $ this -> get ( 'defaultid' ) ; } return $ filterValues [ $ valueName ] ; }
9340	public function load ( $ directory ) { $ configurations = glob ( $ directory . '/*.php' ) ; foreach ( $ configurations as $ configuration ) { $ items = require $ configuration ; $ name = basename ( $ configuration , '.php' ) ; $ this -> data = array_merge ( $ this -> data , array ( $ name => $ items ) ) ; } return $ this -> data ; }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
12598	public function isCacheable ( $ namespace ) { if ( ! $ this -> cacheOptions -> isEnabled ( ) ) { return false ; } $ namespaces = $ this -> cacheOptions -> getNamespaces ( ) ; if ( empty ( $ namespaces ) ) { return true ; } return in_array ( $ namespace , $ namespaces ) ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
230	public function getLastInsertID ( $ sequenceName = '' ) { if ( $ this -> db -> isActive ) { return $ this -> db -> pdo -> lastInsertId ( $ sequenceName === '' ? null : $ this -> quoteTableName ( $ sequenceName ) ) ; } throw new InvalidCallException ( 'DB Connection is not active.' ) ; }
12074	public function childIndex ( FilterRequest $ filters , $ id , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> getChilds ( $ id , $ relation , $ filters ) ; if ( ! $ resource || count ( $ resource ) < 1 ) { } return $ this -> success ( $ resource ) ; }
11661	public static function readFromFile ( $ file ) { $ real_file = File :: asFile ( $ file ) ; if ( $ real_file -> exists ( ) ) return self :: readFromString ( $ file -> getContent ( ) ) ; else return array ( ) ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
1751	public static function getReferer ( $ blnEncodeAmpersands = false , $ strTable = null ) { $ objSession = static :: getContainer ( ) -> get ( 'session' ) ; $ ref = Input :: get ( 'ref' ) ; $ key = Input :: get ( 'popup' ) ? 'popupReferer' : 'referer' ; $ session = $ objSession -> get ( $ key ) ; if ( $ ref && isset ( $ session [ $ ref ] ) ) { $ session = $ session [ $ ref ] ; } elseif ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' && \ is_array ( $ session ) ) { $ session = end ( $ session ) ; } if ( $ strTable != '' && isset ( $ session [ $ strTable ] ) && Input :: get ( 'act' ) != 'select' ) { $ session [ 'current' ] = $ session [ $ strTable ] ; } $ cleanUrl = function ( $ url , $ params = array ( 'rt' , 'ref' ) ) { if ( $ url == '' || strpos ( $ url , '?' ) === false ) { return $ url ; } list ( $ path , $ query ) = explode ( '?' , $ url , 2 ) ; $ queryObj = new Query ( $ query ) ; $ queryObj = $ queryObj -> withoutPairs ( $ params ) ; return $ path . $ queryObj -> getUriComponent ( ) ; } ; $ strUrl = ( $ cleanUrl ( $ session [ 'current' ] ) != $ cleanUrl ( Environment :: get ( 'request' ) ) ) ? $ session [ 'current' ] : $ session [ 'last' ] ; $ return = $ cleanUrl ( $ strUrl , array ( 'tg' , 'ptg' ) ) ; if ( $ return == '' && \ defined ( 'TL_MODE' ) && TL_MODE == 'FE' ) { $ return = Environment :: get ( 'httpReferer' ) ; } if ( $ return == '' ) { $ return = ( \ defined ( 'TL_MODE' ) && TL_MODE == 'BE' ) ? 'contao/main.php' : Environment :: get ( 'url' ) ; } return preg_replace ( '/&(amp;)?/i' , ( $ blnEncodeAmpersands ? '&amp;' : '&' ) , $ return ) ; }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
1403	private function parse ( ) { if ( ! $ this -> response ) { return [ ] ; } $ body = json_decode ( ( string ) $ this -> response -> getBody ( ) , true ) ; return isset ( $ body [ 'errors' ] ) ? $ body [ 'errors' ] : [ ] ; }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
7335	private function addMappings ( ClassMetadata $ metadata , array $ mappings ) { foreach ( $ mappings as $ mapping ) { if ( ! $ metadata -> hasField ( $ mapping [ 'fieldName' ] ) ) { $ metadata -> mapField ( $ mapping ) ; } } }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
7507	function getTokenString ( $ start_offset = 0 , $ end_offset = 0 ) { $ token_start = ( ( is_int ( $ this -> token_start ) ) ? $ this -> token_start : $ this -> pos ) + $ start_offset ; $ len = $ this -> pos - $ token_start + 1 + $ end_offset ; return ( ( $ len > 0 ) ? substr ( $ this -> doc , $ token_start , $ len ) : '' ) ; }
3670	private function determineFragments ( Request $ request ) : ? array { if ( null === $ requestUri = $ this -> strippedUri ( $ request ) ) { return null ; } $ fragments = null ; if ( Config :: get ( 'folderUrl' ) && false !== strpos ( $ requestUri , '/' ) ) { $ fragments = $ this -> getFolderUrlFragments ( $ requestUri , $ request -> getHost ( ) , $ request -> attributes -> get ( '_locale' ) ) ; } if ( null === $ fragments ) { if ( '/' === $ requestUri ) { return null ; } $ fragments = explode ( '/' , $ requestUri ) ; } if ( Config :: get ( 'useAutoItem' ) && 0 === ( \ count ( $ fragments ) % 2 ) ) { array_insert ( $ fragments , 1 , [ 'auto_item' ] ) ; } $ fragments = $ this -> getPageIdFromUrlHook ( $ fragments ) ; if ( null === $ fragments || ( '' === $ fragments [ 0 ] && \ count ( $ fragments ) > 1 ) ) { return null ; } return $ fragments ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
7454	protected function getFirstTerm ( WP_Post $ post ) { $ taxonomies = $ this -> getTaxonomies ( $ post -> post_type ) ; foreach ( $ taxonomies as $ taxonomy ) { $ post_terms = \ get_the_terms ( $ post , $ taxonomy ) ; if ( ! $ post_terms || \ is_wp_error ( $ post_terms ) ) { continue ; } return $ post_terms [ 0 ] ; } }
5974	public function filters ( ) { if ( ! $ this -> filters instanceof FiltersController ) { $ this -> filters = new FiltersController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> filters -> setLogger ( $ this -> logger ) ; } return $ this -> filters ; }
1404	public function add ( $ record , array $ relationship , EncodingParametersInterface $ parameters ) { $ related = $ this -> findRelated ( $ record , $ relationship ) ; $ relation = $ this -> getRelation ( $ record , $ this -> key ) ; $ existing = $ relation -> getQuery ( ) -> whereKey ( $ related -> modelKeys ( ) ) -> get ( ) ; $ relation -> saveMany ( $ related -> diff ( $ existing ) ) ; $ record -> refresh ( ) ; return $ record ; }
8691	public static function symlinkJQueryFileUpload ( Event $ event ) { $ IO = $ event -> getIO ( ) ; $ composer = $ event -> getComposer ( ) ; $ cmanager = new ComposerPathFinder ( $ composer ) ; $ ds = DIRECTORY_SEPARATOR ; $ options = [ 'targetSuffix' => self :: getTargetSuffix ( 'jquery-file-upload' ) , 'sourcePrefix' => "..{$ds}..{$ds}..{$ds}" , ] ; list ( $ symlinkTarget , $ symlinkName ) = $ cmanager -> getSymlinkFromComposer ( 'sidus/file-upload-bundle' , 'blueimp/jquery-file-upload' , $ options ) ; $ IO -> write ( 'Checking Symlink' , false ) ; if ( false === self :: checkSymlink ( $ symlinkTarget , $ symlinkName , true ) ) { $ IO -> write ( 'Creating Symlink: ' . $ symlinkName , false ) ; self :: createSymlink ( $ symlinkTarget , $ symlinkName ) ; } $ IO -> write ( '<info>OK</info>' ) ; }
9531	private function respondDefault ( & $ i , & $ results , $ parameter ) { $ defaultResult = $ this -> parameterCluster -> default -> call ( $ this , $ parameter ) ; if ( $ defaultResult === - 1 ) { $ this -> valid = false ; } $ results [ $ parameter ] = $ defaultResult ; $ i ++ ; }
642	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3515	public function getLocale ( ) { if ( ! $ this -> cookiesLoaded ) { $ key = $ this -> cookiePrefix . 'lang_locale' ; $ queuedCookieLocale = \ Cookie :: queued ( $ key , null ) ; $ locale = getSupportedLocale ( $ queuedCookieLocale != null ? $ queuedCookieLocale -> getValue ( ) : \ Cookie :: get ( $ key , '' ) ) ; parent :: setLocale ( $ locale ) ; $ this -> getShowUnpublished ( ) ; $ this -> cookiesLoaded = true ; } return parent :: getLocale ( ) ; }
3068	protected function initServiceContext ( ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> getRunnerService ( ) -> check ( $ serviceContext ) ; return $ serviceContext -> init ( ) ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
288	protected function negotiateLanguage ( $ request ) { if ( ! empty ( $ this -> languageParam ) && ( $ language = $ request -> get ( $ this -> languageParam ) ) !== null ) { if ( is_array ( $ language ) ) { return reset ( $ this -> languages ) ; } if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } return reset ( $ this -> languages ) ; } foreach ( $ request -> getAcceptableLanguages ( ) as $ language ) { if ( isset ( $ this -> languages [ $ language ] ) ) { return $ this -> languages [ $ language ] ; } foreach ( $ this -> languages as $ key => $ supported ) { if ( is_int ( $ key ) && $ this -> isLanguageSupported ( $ language , $ supported ) ) { return $ supported ; } } } return reset ( $ this -> languages ) ; }
9879	private function writeBookViews ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ objWriter -> startElement ( 'bookViews' ) ; $ objWriter -> startElement ( 'workbookView' ) ; $ objWriter -> writeAttribute ( 'activeTab' , $ spreadsheet -> getActiveSheetIndex ( ) ) ; $ objWriter -> writeAttribute ( 'autoFilterDateGrouping' , '1' ) ; $ objWriter -> writeAttribute ( 'firstSheet' , '0' ) ; $ objWriter -> writeAttribute ( 'minimized' , '0' ) ; $ objWriter -> writeAttribute ( 'showHorizontalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'showSheetTabs' , '1' ) ; $ objWriter -> writeAttribute ( 'showVerticalScroll' , '1' ) ; $ objWriter -> writeAttribute ( 'tabRatio' , '600' ) ; $ objWriter -> writeAttribute ( 'visibility' , 'visible' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10914	public function execute ( ) { try { $ this -> output_buffer_level = ob_get_level ( ) ; ob_start ( ) ; $ response = $ this -> doExecute ( ) ; if ( ( is_object ( $ response ) && ! ( $ response instanceof Response ) ) || ( is_string ( $ response ) && class_exists ( $ response ) ) ) { $ response = $ this -> reflect ( $ response ) ; } if ( $ response instanceof Response ) throw $ response ; throw new HTTPError ( 500 , "App did not produce any response" ) ; } catch ( Response $ response ) { self :: $ logger -> debug ( "Response type {0} returned from controller: {1}" , [ get_class ( $ response ) , $ this -> app ] ) ; throw $ response ; } catch ( Throwable $ e ) { self :: $ logger -> debug ( "While executing controller: {0}" , [ $ this -> app ] ) ; self :: $ logger -> notice ( "Unexpected exception of type {0} thrown while processing request: {1}" , [ get_class ( $ e ) , $ e ] ) ; throw $ e ; } finally { $ this -> logScriptOutput ( ) ; } }
8728	public function changeFolder ( HTTPRequest $ request ) { $ token = $ this -> getForm ( ) -> getSecurityToken ( ) ; if ( ! $ token -> checkRequest ( $ request ) ) { return $ this -> httpError ( 400 ) ; } $ folderID = $ request -> postVar ( 'FolderID' ) ; if ( $ folderID ) { $ this -> FolderSelector ( ) -> setLastFolderID ( $ folderID ) ; } }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
9440	protected function value ( $ name ) { $ object = isset ( $ this -> instances [ $ name ] ) ? $ this -> get ( $ name ) : null ; $ exists = ! $ object && $ this -> extra -> has ( $ name ) === true ; return $ exists === true ? $ this -> extra -> get ( $ name ) : $ object ; }
12852	protected static function symbol ( $ symbol ) { if ( $ symbol instanceof Symbol ) return [ $ symbol -> symbol , $ symbol -> package ] ; throw new \ UnexpectedValueException ( sprintf ( "Unexpected value of type '%s'." , is_object ( $ symbol ) ? get_class ( $ symbol ) : gettype ( $ symbol ) ) ) ; }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
9975	private static function fillBuiltInFormatCodes ( ) { if ( self :: $ builtInFormats === null ) { self :: $ builtInFormats = [ ] ; self :: $ builtInFormats [ 0 ] = self :: FORMAT_GENERAL ; self :: $ builtInFormats [ 1 ] = '0' ; self :: $ builtInFormats [ 2 ] = '0.00' ; self :: $ builtInFormats [ 3 ] = '#,##0' ; self :: $ builtInFormats [ 4 ] = '#,##0.00' ; self :: $ builtInFormats [ 9 ] = '0%' ; self :: $ builtInFormats [ 10 ] = '0.00%' ; self :: $ builtInFormats [ 11 ] = '0.00E+00' ; self :: $ builtInFormats [ 12 ] = '# ?/?' ; self :: $ builtInFormats [ 13 ] = '# ??/??' ; self :: $ builtInFormats [ 14 ] = 'm/d/yyyy' ; self :: $ builtInFormats [ 15 ] = 'd-mmm-yy' ; self :: $ builtInFormats [ 16 ] = 'd-mmm' ; self :: $ builtInFormats [ 17 ] = 'mmm-yy' ; self :: $ builtInFormats [ 18 ] = 'h:mm AM/PM' ; self :: $ builtInFormats [ 19 ] = 'h:mm:ss AM/PM' ; self :: $ builtInFormats [ 20 ] = 'h:mm' ; self :: $ builtInFormats [ 21 ] = 'h:mm:ss' ; self :: $ builtInFormats [ 22 ] = 'm/d/yyyy h:mm' ; self :: $ builtInFormats [ 37 ] = '#,##0_);(#,##0)' ; self :: $ builtInFormats [ 38 ] = '#,##0_);[Red](#,##0)' ; self :: $ builtInFormats [ 39 ] = '#,##0.00_);(#,##0.00)' ; self :: $ builtInFormats [ 40 ] = '#,##0.00_);[Red](#,##0.00)' ; self :: $ builtInFormats [ 44 ] = '_("$"* #,##0.00_);_("$"* \(#,##0.00\);_("$"* "-"??_);_(@_)' ; self :: $ builtInFormats [ 45 ] = 'mm:ss' ; self :: $ builtInFormats [ 46 ] = '[h]:mm:ss' ; self :: $ builtInFormats [ 47 ] = 'mm:ss.0' ; self :: $ builtInFormats [ 48 ] = '##0.0E+0' ; self :: $ builtInFormats [ 49 ] = '@' ; self :: $ builtInFormats [ 27 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 30 ] = 'm/d/yy' ; self :: $ builtInFormats [ 36 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 50 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 57 ] = '[$-404]e/m/d' ; self :: $ builtInFormats [ 59 ] = 't0' ; self :: $ builtInFormats [ 60 ] = 't0.00' ; self :: $ builtInFormats [ 61 ] = 't#,##0' ; self :: $ builtInFormats [ 62 ] = 't#,##0.00' ; self :: $ builtInFormats [ 67 ] = 't0%' ; self :: $ builtInFormats [ 68 ] = 't0.00%' ; self :: $ builtInFormats [ 69 ] = 't# ?/?' ; self :: $ builtInFormats [ 70 ] = 't# ??/??' ; self :: $ flippedBuiltInFormats = array_flip ( self :: $ builtInFormats ) ; } }
7863	protected function drawCenteredChar ( $ character ) { $ spaces = str_repeat ( ' ' , $ this -> geometry -> getHalfWidth ( ) ) ; $ this -> drawRow ( $ spaces . $ character ) ; }
6446	public function completeLogin ( $ extrainputs = array ( ) ) { $ linkedin = $ this -> getClient ( ) ; $ this -> token = $ linkedin -> getAccessToken ( $ extrainputs [ 'code' ] ) ; return $ this -> getUserProfile ( ) ; }
9417	public function fwhm ( ) { $ float_fwhm = 2 * sqrt ( 2 * log ( 2 ) ) * $ this -> float_sigma ; if ( $ this -> int_precision ) { return round ( $ float_fwhm , $ this -> int_precision ) ; } return $ float_fwhm ; }
2837	public function getInfoAsArray ( ) { return array ( 'design_area' => $ this -> getArea ( ) , 'package_name' => $ this -> getPackageName ( ) , 'layout_theme' => $ this -> getThemeLayout ( ) , 'template_theme' => $ this -> getThemeTemplate ( ) , 'locale' => $ this -> getThemeLocale ( ) , 'skin' => $ this -> getThemeSkin ( ) ) ; }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
4072	private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; }
7730	public function api ( $ url , $ body = null , $ type = self :: TYPE_POST ) { $ body [ 'access_token' ] = $ this -> accessToken ; $ this -> setBody ( $ body ) ; $ headers = [ 'Content-Type: application/json' , ] ; if ( $ type == self :: TYPE_GET ) { $ url .= '?' . http_build_query ( $ body ) ; } $ curl = curl_init ( $ this -> url . $ url ) ; if ( $ type == self :: TYPE_POST ) { curl_setopt ( $ curl , CURLOPT_POST , 1 ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , http_build_query ( $ body ) ) ; } curl_setopt ( $ curl , CURLOPT_HTTPHEADER , $ headers ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; $ response = curl_exec ( $ curl ) ; curl_close ( $ curl ) ; return json_decode ( $ response , true ) ; }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
436	public function afterAction ( $ action , $ result ) { $ event = new ActionEvent ( $ action ) ; $ event -> result = $ result ; $ this -> trigger ( self :: EVENT_AFTER_ACTION , $ event ) ; return $ event -> result ; }
5307	protected function getPathFromPolygon ( SimpleXMLElement $ polygon ) { $ points = $ this -> getValuesFromList ( $ polygon [ 'points' ] ) ; $ path = 'M' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; while ( count ( $ points ) ) { $ path .= 'L' . array_shift ( $ points ) . ' ' . array_shift ( $ points ) ; } return $ path . 'Z' ; }
11012	protected function importSchemaFile ( string $ schemaFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { if ( $ this -> db -> getSchemaManager ( ) -> tablesExist ( [ $ controlTableName ] ) ) { $ this -> output -> writeln ( '<comment>Schema already exists in the database, skipping schema import for file <info>' . $ schemaFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ schemaFile ) ; }
12969	public function transformFromFront ( array $ array ) { $ transformation = $ this -> getTransformation ( ) ; $ fillables = $ this -> getFillable ( ) ; $ transformed = [ ] ; foreach ( $ fillables as $ name ) { if ( ! key_exists ( $ name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ name ] ; } foreach ( $ transformation as $ name => $ new_name ) { if ( ! key_exists ( $ new_name , $ array ) ) { continue ; } $ transformed [ $ name ] = $ array [ $ new_name ] ; } return $ transformed ; }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
11810	protected function loadForeignObject ( ) { if ( $ this -> _isLoadingForeignObject ) { throw new RecursionException ( 'Ran into recursion while loading foreign object' ) ; } $ this -> _isLoadingForeignObject = true ; if ( isset ( $ this -> deferredModel ) && ( $ attributes = $ this -> deferredModel -> attributes ) ) { $ this -> foreignObject = $ this -> dataSource -> createModel ( $ this -> deferredModel -> id , $ this -> deferredModel -> attributes ) ; } $ this -> _isLoadingForeignObject = false ; }
7147	public function get_user_settings ( $ default = array ( ) , $ user_id = NULL ) { if ( ! $ user_id ) return $ default ; $ default_opt_in = apply_filters ( 'iac_default_opt_in' , FALSE ) ; $ default = $ default_opt_in ? '1' : '0' ; $ settings = array ( 'inform_about_posts' => get_user_meta ( $ user_id , 'post_subscription' , TRUE ) , 'inform_about_comments' => get_user_meta ( $ user_id , 'comment_subscription' , TRUE ) ) ; foreach ( $ settings as $ k => $ v ) { if ( '' === $ v ) $ settings [ $ k ] = $ default ; } return $ settings ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
2500	private function getIndexFieldType ( ContentType $ contentType , FieldDefinition $ fieldDefinition , FieldType $ fieldType ) { if ( ! $ fieldType instanceof FieldType \ TextField ) { return $ fieldType ; } $ fieldType = clone $ fieldType ; $ fieldType -> boost = $ this -> boostFactorProvider -> getContentFieldBoostFactor ( $ contentType , $ fieldDefinition ) ; return $ fieldType ; }
4434	public function call ( string $ command , ... $ arguments ) { $ arguments = func_get_args ( ) ; array_shift ( $ arguments ) ; return $ this -> __call ( $ command , $ arguments ) ; }
3070	protected function saveItemState ( ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemState' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemIdentifier = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ state = $ this -> getRequestParameter ( 'itemState' ) ? json_decode ( $ this -> getRequestParameter ( 'itemState' ) , true ) : new \ stdClass ( ) ; return $ this -> getRunnerService ( ) -> setItemState ( $ serviceContext , $ itemIdentifier , $ state ) ; } return false ; }
3615	public function setEcoTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = array ( ) ; if ( $ temp_low === FALSE ) { $ data [ 'away_temperature_low_enabled' ] = FALSE ; } elseif ( $ temp_low != NULL ) { $ data [ 'away_temperature_low_enabled' ] = TRUE ; $ data [ 'away_temperature_low' ] = $ temp_low ; } if ( $ temp_high === FALSE ) { $ data [ 'away_temperature_high_enabled' ] = FALSE ; } elseif ( $ temp_high != NULL ) { $ data [ 'away_temperature_high_enabled' ] = TRUE ; $ data [ 'away_temperature_high' ] = $ temp_high ; } $ data = json_encode ( $ data ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7151	public function equals ( SubjectIdentity $ identity ) { return $ this -> provider === $ identity -> getProvider ( ) && $ this -> identifier === $ identity -> getIdentifier ( ) ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
12215	protected function compileConfiguration ( Traversable $ source , string $ target , CompilerContext $ context ) { $ compiler = new StandardCompiler ( ) ; $ compiler -> setSource ( $ source ) ; $ compiler -> setTarget ( $ target ) ; $ compiler -> compile ( ) ; }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6168	protected function writeAssertionFailure ( $ assertionFailure ) { $ this -> writeNewLine ( ) ; foreach ( explode ( "\n" , $ assertionFailure ) as $ line ) { $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
6750	public function getTransformer ( ) { if ( ! property_exists ( $ this , 'transformer' ) || ! $ this -> transformer ) { if ( ! $ this -> _defaultTransformer ) { $ this -> createQualifiedTransformerClass ( ) ; } return $ this -> _defaultTransformer ; } return $ this -> transformer ; }
6675	public function add_meta_boxes ( $ post_type , $ post ) { App :: setCurrentID ( 'EFG' ) ; $ is_active = $ this -> get_rating_state ( $ post -> ID ) ; if ( App :: main ( ) -> is_publish_post ( $ post ) && $ is_active ) { $ this -> add_styles ( ) ; $ this -> add_scripts ( ) ; add_meta_box ( 'info_movie-rating-movie' , __ ( 'Extensions For Grifus - Custom rating' , 'extensions-for-grifus-rating' ) , [ $ this , 'render_meta_boxes' ] , $ post_type , 'normal' , 'high' ) ; } }
12615	public function addAttribute ( AttributeInterface $ attribute ) { if ( isset ( $ this -> attributes [ $ attribute -> getName ( ) ] ) ) trigger_error ( "Attribute " . $ attribute -> getName ( ) . " already exists" , E_USER_NOTICE ) ; $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; }
9659	public static function createReader ( $ readerType ) { if ( ! isset ( self :: $ readers [ $ readerType ] ) ) { throw new Reader \ Exception ( "No reader found for type $readerType" ) ; } $ className = self :: $ readers [ $ readerType ] ; $ reader = new $ className ( ) ; return $ reader ; }
284	private function getFixturesConfig ( $ fixtures ) { $ config = [ ] ; foreach ( $ fixtures as $ fixture ) { $ isNamespaced = ( strpos ( $ fixture , '\\' ) !== false ) ; $ fixture = str_replace ( '/' , '\\' , $ fixture ) ; $ fullClassName = $ isNamespaced ? $ fixture : $ this -> namespace . '\\' . $ fixture ; if ( class_exists ( $ fullClassName ) ) { $ config [ ] = $ fullClassName ; } elseif ( class_exists ( $ fullClassName . 'Fixture' ) ) { $ config [ ] = $ fullClassName . 'Fixture' ; } } return $ config ; }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
10509	public function attach ( \ SplObserver $ observer , $ eventName = Null , $ function = Null , $ order = Null ) { $ newEventAttach = new \ stdClass ( ) ; $ newEventAttach -> observer = $ observer ; $ newEventAttach -> function = $ function ; $ newEventAttach -> eventName = $ eventName ; $ newEventAttach -> order = $ order ; $ this -> _observers -> attach ( $ newEventAttach ) ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
4858	public function getList ( $ namespace , $ callback ) { $ session = new Container ( $ namespace ) ; $ params = $ session -> params ? : array ( ) ; if ( ! $ session -> list ) { $ session -> list = is_array ( $ callback ) ? call_user_func ( $ callback , $ session -> params ) : $ callback -> getPaginationList ( $ session -> params ) ; } return $ session -> list ; }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
10074	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ UPDATE = new SynchronizationMode ( 1 ) ; self :: $ IGNORE = new SynchronizationMode ( 2 ) ; self :: $ initialized = true ; } }
3643	public function except ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> except ( ( array ) $ keys ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
9661	public static function createReaderForFile ( $ filename ) { File :: assertFile ( $ filename ) ; $ guessedReader = self :: getReaderTypeFromExtension ( $ filename ) ; if ( $ guessedReader !== null ) { $ reader = self :: createReader ( $ guessedReader ) ; if ( isset ( $ reader ) && $ reader -> canRead ( $ filename ) ) { return $ reader ; } } foreach ( self :: $ readers as $ type => $ class ) { if ( $ type !== $ guessedReader ) { $ reader = self :: createReader ( $ type ) ; if ( $ reader -> canRead ( $ filename ) ) { return $ reader ; } } } throw new Reader \ Exception ( 'Unable to identify a reader for this file' ) ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
1687	public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
5438	public function match ( $ subject , & $ match ) { if ( count ( $ this -> patterns ) === 0 ) { return false ; } if ( ! preg_match ( $ this -> getCompoundedRegex ( ) , $ subject , $ matches ) ) { $ match = '' ; return false ; } $ match = $ matches [ 0 ] ; for ( $ i = 1 ; $ i < count ( $ matches ) ; $ i ++ ) { if ( $ matches [ $ i ] ) { return $ this -> labels [ $ i - 1 ] ; } } return true ; }
4472	public function retry ( $ group , $ message , $ delay = 0 ) { return $ this -> client -> retry ( $ this -> jid , $ this -> queue , $ this -> worker , $ delay , $ group , $ message ) ; }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
4615	public function buildCluster ( array $ hosts = [ 'localhost' ] ) { $ nodes = [ ] ; foreach ( $ hosts as $ host ) { $ nodes [ ] = $ this -> atHost ( $ host ) -> build ( ) ; } return $ nodes ; }
11318	public function getBaseData ( ) { $ data = new FluidXml ( false ) ; $ message = $ data -> addChild ( 'Message' , [ 'version' => $ this -> getApiVersion ( ) ] , true ) ; $ header = $ message -> addChild ( 'Header' , true ) ; $ header -> addChild ( 'Time' , $ this -> getTime ( ) ) ; $ itentity = $ header -> addChild ( 'Identity' , true ) ; $ itentity -> addChild ( 'UserID' , $ this -> getUserId ( ) ) ; $ body = $ message -> addChild ( 'Body' , [ 'type' => 'GetInvoice' , 'live' => $ this -> getLive ( ) ] , true ) ; $ order = $ body -> addChild ( 'Order' , [ 'paymentMethod' => $ this -> getPaymentMethod ( ) ] , true ) ; $ order -> addChild ( 'MerchantID' , $ this -> getMerchantId ( ) ) ; $ order -> addChild ( 'SiteAddress' , $ this -> getSiteAddress ( ) ) ; $ order -> addChild ( 'PostbackURL' , $ this -> getNotifyUrl ( ) ) ; $ order -> addChild ( 'SuccessURL' , $ this -> getReturnUrl ( ) ) ; $ order -> addChild ( 'FailureURL' , $ this -> getCancelUrl ( ) ) ; return $ message ; }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
10351	public function channel ( string $ channel_id ) : EventChannelInterface { if ( isset ( $ this -> channel_adapters [ $ channel_id ] ) ) { return $ this -> channel_adapters [ $ channel_id ] ; } $ adapter = new Stk2kEventChannelAdapter ( $ this -> eventstream -> channel ( $ channel_id , function ( ) { return new SimpleEventSource ( ) ; } , function ( ) { return new WildCardEventEmitter ( ) ; } ) ) ; $ this -> channel_adapters [ $ channel_id ] = $ adapter ; return $ adapter ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
3926	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( is_array ( $ event -> getValue ( ) ) ) { $ values = [ ] ; foreach ( $ event -> getValue ( ) as $ value ) { $ values [ ] = substr ( $ value , 6 ) ; } $ event -> setValue ( $ values ) ; } else { $ event -> setValue ( substr ( $ event -> getValue ( ) , 6 ) ) ; } }
9318	public function rotate ( $ angle , $ background = 'FFFFFF' ) { $ angle = intval ( $ angle ) ; if ( ! is_int ( $ angle ) || ( $ angle < 0 ) || ( $ angle > 360 ) ) { throw new ezcBaseValueException ( 'height' , $ height , 'angle < 0 or angle > 360' ) ; } $ angle = 360 - $ angle ; $ background = "#{$background}" ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-background' , $ background ) ; $ this -> addFilterOption ( $ this -> getActiveReference ( ) , '-rotate' , $ angle ) ; }
11599	public function run ( ) : void { if ( ! $ this -> isAppRootSet ( ) ) { throw new Exception ( "The application root wasn't defined." ) ; } if ( ! $ this -> isConfigFileSet ( ) ) { throw new Exception ( "The main config file wasn't defined." ) ; } $ configPath = $ this -> getAppRoot ( ) . $ this -> getConfigFile ( ) ; if ( ! is_readable ( $ configPath ) ) { throw new Exception ( "It's unable to load " . $ configPath . 'as main config file.' ) ; } $ config = require_once $ configPath ; if ( ! is_array ( $ config ) ) { throw new Exception ( 'The main config must be an array.' ) ; } $ this -> configSet = $ config ; }
4877	public static function factory ( ContainerInterface $ container ) { $ config = $ container -> get ( 'ApplicationConfig' ) ; $ options = new ListenerOptions ( $ config [ 'module_listener_options' ] ) ; return new static ( $ options ) ; }
11050	function protect_spaces ( $ data ) { $ data = str_replace ( "\n" , "\1n\1" , $ data ) ; $ data = str_replace ( "\r" , "\1r\1" , $ data ) ; $ data = str_replace ( "\t" , "\1t\1" , $ data ) ; return str_replace ( " " , "\1s\1" , $ data ) ; }
11616	public function invite ( $ account , $ wechatId ) { $ params = [ 'kf_account' => $ account , 'invite_wx' => $ wechatId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_INVITE_BIND , $ params ] ) ; }
7949	public function updateDomainProperties ( $ domain , $ properties ) { self :: getClient ( ) -> updateDomainProperties ( $ this -> sn , $ domain , $ properties ) ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
6345	public static function filterBy ( Iterator $ unfiltered , string $ className ) : Iterator { return self :: filter ( $ unfiltered , Predicates :: instance ( $ className ) ) ; }
4113	public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } $ info [ 'cache-status' ] = self :: TYPE_NOTCACHED ; $ cacheLifeTime = $ block -> getCacheLifetime ( ) ; if ( ! is_null ( $ cacheLifeTime ) ) { $ info [ 'cache-lifetime' ] = ( intval ( $ cacheLifeTime ) == 0 ) ? 'forever' : intval ( $ cacheLifeTime ) . ' sec' ; $ info [ 'cache-key' ] = $ block -> getCacheKey ( ) ; $ info [ 'cache-key-info' ] = is_array ( $ block -> getCacheKeyInfo ( ) ) ? implode ( ', ' , $ block -> getCacheKeyInfo ( ) ) : $ block -> getCacheKeyInfo ( ) ; $ info [ 'tags' ] = implode ( ',' , $ block -> getCacheTags ( ) ) ; $ info [ 'cache-status' ] = self :: TYPE_CACHED ; } elseif ( $ this -> isWithinCachedBlock ( $ block ) ) { $ info [ 'cache-status' ] = self :: TYPE_IMPLICITLYCACHED ; } $ info [ 'methods' ] = $ this -> getClassMethods ( get_class ( $ block ) ) ; return $ info ; }
4793	function order ( $ columns ) { $ this -> rows = null ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { if ( $ this -> union ) { $ this -> unionOrder [ ] = $ columns ; } else { $ this -> order [ ] = $ columns ; } } } elseif ( $ this -> union ) { $ this -> unionOrder = array ( ) ; } else { $ this -> order = array ( ) ; } return $ this ; }
5160	public function getAttachmentByField ( string $ field ) : array { if ( isset ( $ this -> attachment [ $ field ] ) ) { return $ this -> attachment [ $ field ] ; } return [ ] ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
8053	public function deleteCalendarEvent ( $ id ) { $ cache = $ this -> cache ; $ this -> calendarEvent -> destroy ( $ id ) ; $ allEvents = $ this -> getAllEvents ( ) ; unset ( $ allEvents [ $ id ] ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
11861	public function getCompanionId ( ) { if ( $ this -> isForeign && isset ( $ this -> foreignPrimaryKey ) ) { return $ this -> foreignPrimaryKey ; } elseif ( ! $ this -> isForeign && isset ( $ this -> localPrimaryKey ) ) { return $ this -> localPrimaryKey ; } if ( isset ( $ this -> companionObject ) ) { return $ this -> companionObject -> primaryKey ; } return ; }
6131	protected function getSuffixIconServer ( ) { $ html = "" ; if ( $ this -> currObj [ "virtualserver_icon_id" ] ) { if ( ! $ this -> currObj -> iconIsLocal ( "virtualserver_icon_id" ) && $ this -> ftclient ) { if ( ! isset ( $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ) ) { $ download = $ this -> currObj -> transferInitDownload ( rand ( 0x0000 , 0xFFFF ) , 0 , $ this -> currObj -> iconGetName ( "virtualserver_icon_id" ) ) ; if ( $ this -> ftclient == "data:image" ) { $ download = TeamSpeak3 :: factory ( "filetransfer://" . $ download [ "host" ] . ":" . $ download [ "port" ] ) -> download ( $ download [ "ftkey" ] , $ download [ "size" ] ) ; } $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] = $ download ; } else { $ download = $ this -> cacheIcon [ $ this -> currObj [ "virtualserver_icon_id" ] ] ; } if ( $ this -> ftclient == "data:image" ) { $ html .= $ this -> getImage ( "data:" . Convert :: imageMimeType ( $ download ) . ";base64," . base64_encode ( $ download ) , "Server Icon" , null , false ) ; } else { $ html .= $ this -> getImage ( $ this -> ftclient . "?ftdata=" . base64_encode ( serialize ( $ download ) ) , "Server Icon" , null , false ) ; } } elseif ( in_array ( $ this -> currObj [ "virtualserver_icon_id" ] , $ this -> cachedIcons ) ) { $ html .= $ this -> getImage ( "group_icon_" . $ this -> currObj [ "virtualserver_icon_id" ] . ".png" , "Server Icon" ) ; } } return $ html ; }
11282	public function _populate ( $ record = null , $ db = false , $ loadMap = false ) { $ this -> model_hydrating = true ; if ( $ db ) { $ this -> model_db = $ db ; } if ( $ record ) { $ this -> _populateAttributes ( $ record ) ; $ this -> _populateNonModelData ( $ record ) ; } if ( $ this -> model_loadMapsEnabled ) { $ this -> _populateLoadMap ( $ record , $ loadMap ) ; } $ this -> onLoad ( ) ; if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && $ func = $ loadMap -> getOnLoadFunction ( ) ) { $ args = $ loadMap -> getOnLoadArgs ( ) ; array_unshift ( $ args , $ this ) ; call_user_func_array ( $ func , $ args ) ; } $ this -> model_hydrating = false ; return $ this ; }
3982	private function extractUserRights ( TokenInterface $ token ) { $ beUser = $ token -> getUser ( ) ; if ( ! ( $ beUser instanceof BackendUser ) ) { return [ ] ; } $ allowedModules = $ beUser -> modules ; switch ( true ) { case \ is_string ( $ allowedModules ) : $ allowedModules = unserialize ( $ allowedModules , [ 'allowed_classes' => false ] ) ; break ; case null === $ allowedModules : $ allowedModules = [ ] ; break ; default : } return array_flip ( $ allowedModules ) ; }
10210	public function createAction ( ) { $ request = $ this -> getRequest ( ) ; $ prg = $ this -> prg ( $ request -> getRequestUri ( ) , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } elseif ( $ prg === false ) { return $ this -> viewModel ; } if ( $ this -> contactForm -> setData ( $ prg ) -> isValid ( ) ) { $ contact = $ this -> contactForm -> getData ( ) ; $ this -> commandService -> persist ( $ contact ) ; $ this -> viewModel -> setVariable ( 'contact' , $ contact ) ; } return $ this -> viewModel ; }
6795	protected function convertValueIds ( $ valueResult , & $ counter = null ) { $ result = [ ] ; $ aliases = [ ] ; $ idColumn = $ this -> getIdColumn ( ) ; $ aliasColumn = $ this -> getAliasColumn ( ) ; while ( $ row = $ valueResult -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ valueId = $ row -> $ idColumn ; $ aliases [ $ valueId ] = $ row -> $ aliasColumn ; $ result [ ] = $ valueId ; } if ( ( $ counter !== null ) && ! empty ( $ result ) ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'value_id' , 'COUNT(value_id) as mm_count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'value_id IN (:values)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'values' , $ result , Connection :: PARAM_STR_ARRAY ) -> execute ( ) -> fetch ( \ PDO :: FETCH_OBJ ) ; $ amount = $ statement -> mm_count ; $ valueId = $ statement -> value_id ; $ alias = $ aliases [ $ valueId ] ; $ counter [ $ valueId ] = $ amount ; $ counter [ $ alias ] = $ amount ; } return $ result ; }
2428	protected function hasToWait ( ) { $ return = true ; $ time = strtotime ( date ( 'Y-m-d H:i' ) ) ; $ this -> Database -> lockTables ( array ( 'tl_cron' => 'WRITE' ) ) ; $ objCron = $ this -> Database -> prepare ( "SELECT * FROM tl_cron WHERE name='lastrun'" ) -> limit ( 1 ) -> execute ( ) ; if ( $ objCron -> numRows < 1 ) { $ this -> Database -> query ( "INSERT INTO tl_cron (name, value) VALUES ('lastrun', $time)" ) ; $ return = false ; } elseif ( $ objCron -> value <= ( $ time - $ this -> getCronTimeout ( ) ) ) { $ this -> Database -> query ( "UPDATE tl_cron SET value=$time WHERE name='lastrun'" ) ; $ return = false ; } $ this -> Database -> unlockTables ( ) ; return $ return ; }
5932	public function setEndDate ( $ endDate ) { if ( $ endDate instanceof DateTime ) { $ this -> endDate = $ endDate ; } else { try { $ this -> endDate = new DateTime ( $ endDate ) ; } catch ( \ Exception $ e ) { $ this -> endDate = null ; } } return $ this ; }
1824	public function originalRow ( ) { $ row = $ this -> row ( ) ; if ( ! $ this -> isModified ( ) ) { return $ row ; } $ originalRow = array ( ) ; foreach ( $ row as $ k => $ v ) { $ originalRow [ $ k ] = $ this -> arrModified [ $ k ] ?? $ v ; } return $ originalRow ; }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
3711	protected function generateElement ( $ table , $ content , $ replace , $ elementId ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE id=? AND type="metamodels_frontendclearall"' , $ table ) ; $ statement = $ this -> connection -> prepare ( $ sql ) ; $ statement -> bindValue ( 1 , $ elementId ) ; $ statement -> execute ( ) ; $ objDbResult = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; if ( $ objDbResult === false ) { return str_replace ( $ replace , '' , $ content ) ; } if ( $ table == 'tl_module' ) { $ objElement = new ModuleFilterClearAll ( $ objDbResult ) ; } elseif ( $ table == 'tl_content' ) { $ objElement = new ContentElementFilterClearAll ( $ objDbResult ) ; } else { return str_replace ( $ replace , '' , $ content ) ; } return str_replace ( $ replace , $ objElement -> generateReal ( ) , $ content ) ; }
3928	private function getOptionsViaDcGeneral ( $ metaModel , $ environment , $ attribute ) { $ factory = DcGeneralFactory :: deriveEmptyFromEnvironment ( $ environment ) -> setContainerName ( $ metaModel -> getTableName ( ) ) ; $ dcGeneral = $ factory -> createDcGeneral ( ) ; $ subEnv = $ dcGeneral -> getEnvironment ( ) ; $ optEv = new GetPropertyOptionsEvent ( $ subEnv , $ subEnv -> getDataProvider ( ) -> getEmptyModel ( ) ) ; $ optEv -> setPropertyName ( $ attribute -> getColName ( ) ) ; $ subEnv -> getEventDispatcher ( ) -> dispatch ( GetPropertyOptionsEvent :: NAME , $ optEv ) ; $ options = $ optEv -> getOptions ( ) ; return $ options ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
477	public function renameTable ( $ table , $ newName ) { $ time = $ this -> beginCommand ( "rename table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameTable ( $ table , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6015	public function retrieveSite ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/sites/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
3013	public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; }
12669	public function addNamespace ( $ namespaceOptions , $ namespace = null ) { if ( ! $ namespaceOptions instanceof NamespaceOptionsInterface ) { if ( is_array ( $ namespaceOptions ) ) { $ namespaceOptions = new NamespaceOptions ( $ namespaceOptions ) ; if ( $ namespace !== null ) { $ namespaceOptions -> setName ( $ namespace ) ; } } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\NamespaceOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ namespaceOptions ) ? get_class ( $ namespaceOptions ) : gettype ( $ namespaceOptions ) ) ) ; } } else { if ( ! $ namespaceOptions -> getName ( ) && $ namespace ) { $ namespaceOptions -> setName ( $ namespace ) ; } } if ( $ namespace === null ) { $ namespace = $ namespaceOptions -> getName ( ) ; } $ this -> namespaces [ $ namespace ] = $ namespaceOptions ; }
2630	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ comment = $ this -> getRequest ( ) -> getParam ( 'comment_value' ) ; $ negated = 0 ; if ( $ value [ 0 ] == '!' ) { $ negated = 1 ; $ value = ltrim ( $ value , '!' ) ; } $ ipParts = explode ( '/' , $ value ) ; $ subnet = false ; if ( ! empty ( $ ipParts [ 1 ] ) ) { if ( is_numeric ( $ ipParts [ 1 ] ) && ( int ) $ ipParts [ 1 ] < 129 ) { $ subnet = $ ipParts [ 1 ] ; } else { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP subnet format.' ] ) ; } } if ( ! filter_var ( $ ipParts [ 0 ] , FILTER_VALIDATE_IP ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Invalid IP address format.' ] ) ; } $ createAclItem = $ this -> api -> upsertAclItem ( $ aclId , $ ipParts [ 0 ] , $ negated , $ comment , $ subnet ) ; if ( ! $ createAclItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Acl entry.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'id' => $ createAclItem -> id , 'comment' => $ createAclItem -> comment , 'created_at' => $ createAclItem -> created_at ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
5129	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-8' , 'UTF-16BE' ) ; } return preg_replace_callback ( '/(?:[\xD8-\xDB]...)|(?:..)/s' , function ( $ m ) { if ( isset ( $ m [ 0 ] [ 3 ] ) ) { list ( , $ higher , $ lower ) = unpack ( 'n*' , $ m [ 0 ] ) ; $ code = ( ( $ higher & 0x03FF ) << 10 ) + ( $ lower & 0x03FF ) + 0x10000 ; return pack ( 'c*' , $ code >> 18 | 0xF0 , $ code >> 12 & 0x3F | 0x80 , $ code >> 6 & 0x3F | 0x80 , $ code & 0x3F | 0x80 ) ; } list ( , $ code ) = unpack ( 'n' , $ m [ 0 ] ) ; if ( $ code < 0x80 ) { return chr ( $ code ) ; } elseif ( $ code < 0x0800 ) { return chr ( $ code >> 6 | 0xC0 ) . chr ( $ code & 0x3F | 0x80 ) ; } else { return chr ( $ code >> 12 | 0xE0 ) . chr ( $ code >> 6 & 0x3F | 0x80 ) . chr ( $ code & 0x3F | 0x80 ) ; } return '?' ; } , $ str ) ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
7650	public function unlink ( $ path ) { $ this -> getStorageClient ( $ path ) -> deleteBlob ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; clearstatcache ( true , $ path ) ; return true ; }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
12564	public function sendVoice ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VOICE , $ message , $ to ) ; }
6114	public function version ( $ ident = null ) { if ( $ this -> version === null ) { $ this -> version = $ this -> request ( "version" ) -> toList ( ) ; } return ( $ ident && array_key_exists ( $ ident , $ this -> version ) ) ? $ this -> version [ $ ident ] : $ this -> version ; }
7215	protected function fixDefault ( TaxGroupInterface $ taxGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ taxGroup , [ 'default' ] ) ) { return ; } if ( $ taxGroup -> isDefault ( ) ) { try { $ previousTaxGroup = $ this -> taxGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( null === $ previousTaxGroup || $ previousTaxGroup === $ taxGroup ) { return ; } $ previousTaxGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousTaxGroup , false ) ; } }
3655	private function getLabelText ( $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc.' . $ type , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc.' . $ type ) { $ label = $ this -> translator -> trans ( 'tl_metamodel_dcasetting_condition.typedesc._default_' , [ ] , 'contao_tl_metamodel_dcasetting_condition' ) ; if ( $ label === 'tl_metamodel_dcasetting_condition.typedesc._default_' ) { return $ type ; } } return $ label ; }
909	private function getHeaderAsComment ( ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ comment = ( self :: HEADER_COMMENT === $ this -> configuration [ 'comment_type' ] ? '/*' : '/**' ) . $ lineEnding ; $ lines = explode ( "\n" , str_replace ( "\r" , '' , $ this -> configuration [ 'header' ] ) ) ; foreach ( $ lines as $ line ) { $ comment .= rtrim ( ' * ' . $ line ) . $ lineEnding ; } return $ comment . ' */' ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
4770	public function renderWidget ( string $ widgetGroup = '' , array $ widgetId = [ ] ) { $ widgets = $ this -> widgetBuilder -> build ( $ this -> widgets -> getWidgets ( ) , $ widgetGroup , $ widgetId ) ; return $ this -> engine -> render ( $ widgets ) ; }
2157	public function generate ( ) { if ( $ this -> youtube == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://youtu.be/' . $ this -> youtube . '" target="_blank" rel="noreferrer noopener">youtu.be/' . $ this -> youtube . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
7351	public function isPaid ( ) { return 0 <= Money :: compare ( $ this -> paidTotal , $ this -> grandTotal , $ this -> getCurrency ( ) -> getCode ( ) ) ; }
11099	public static function maxCount ( ) { $ array = \ func_get_args ( ) ; if ( ! \ is_array ( $ array ) ) { return 0 ; } $ maxCnt = 0 ; foreach ( $ array as $ item ) { if ( ! \ is_array ( $ item ) ) { continue ; } $ cnt = \ count ( $ item ) ; $ maxCnt = $ cnt > $ maxCnt ? $ cnt : $ maxCnt ; } return $ maxCnt ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
12005	public function archive ( $ sourceDir , array $ options , $ username , $ block ) { $ this -> resolveOptions ( $ options ) ; $ block = json_decode ( $ block , true ) ; $ block [ "history" ] = array ( ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ historyDirName = sprintf ( '%s/archive/%s' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ historyFileName = $ historyDirName . '/history.json' ; if ( ! is_dir ( $ historyDirName ) ) { mkdir ( $ historyDirName ) ; } $ history = array ( ) ; if ( file_exists ( $ historyFileName ) ) { $ history = json_decode ( file_get_contents ( $ historyFileName ) , true ) ; } $ history = array_merge ( $ history , array ( $ block [ "history_name" ] => $ block ) ) ; FilesystemTools :: writeFile ( $ historyFileName , json_encode ( $ history ) ) ; }
2861	public function getRange ( $ logFile ) { if ( ! array_key_exists ( $ logFile , $ this -> ranges ) ) { throw new Exception ( 'Invalid log file' ) ; } return $ this -> ranges [ $ logFile ] ; }
12001	static protected function doctrine2Query ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ generate ) { $ result = $ entityManager -> createQueryBuilder ( ) -> select ( "entity.$field" ) -> from ( $ entityName , 'entity' ) -> where ( "entity.$field = :$field" ) -> setParameter ( "$field" , $ generate ) -> getQuery ( ) -> getResult ( ) ; return ! empty ( $ result ) ; }
260	public function renderFile ( $ viewFile , $ params = [ ] , $ context = null ) { $ viewFile = $ requestedFile = Yii :: getAlias ( $ viewFile ) ; if ( $ this -> theme !== null ) { $ viewFile = $ this -> theme -> applyTo ( $ viewFile ) ; } if ( is_file ( $ viewFile ) ) { $ viewFile = FileHelper :: localize ( $ viewFile ) ; } else { throw new ViewNotFoundException ( "The view file does not exist: $viewFile" ) ; } $ oldContext = $ this -> context ; if ( $ context !== null ) { $ this -> context = $ context ; } $ output = '' ; $ this -> _viewFiles [ ] = [ 'resolved' => $ viewFile , 'requested' => $ requestedFile ] ; if ( $ this -> beforeRender ( $ viewFile , $ params ) ) { Yii :: debug ( "Rendering view file: $viewFile" , __METHOD__ ) ; $ ext = pathinfo ( $ viewFile , PATHINFO_EXTENSION ) ; if ( isset ( $ this -> renderers [ $ ext ] ) ) { if ( is_array ( $ this -> renderers [ $ ext ] ) || is_string ( $ this -> renderers [ $ ext ] ) ) { $ this -> renderers [ $ ext ] = Yii :: createObject ( $ this -> renderers [ $ ext ] ) ; } $ renderer = $ this -> renderers [ $ ext ] ; $ output = $ renderer -> render ( $ this , $ viewFile , $ params ) ; } else { $ output = $ this -> renderPhpFile ( $ viewFile , $ params ) ; } $ this -> afterRender ( $ viewFile , $ params , $ output ) ; } array_pop ( $ this -> _viewFiles ) ; $ this -> context = $ oldContext ; return $ output ; }
7608	public function renderListItems ( array $ aDropdownOptions ) { if ( ! isset ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( __METHOD__ . ' expects "items" option' ) ; } if ( ! is_array ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( '"items" option expects an array, "' . gettype ( $ aDropdownOptions [ 'items' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] = array ( 'class' => 'dropdown-menu' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'list_attributes' ] ) ) { throw new \ LogicException ( '"list_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'list_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] = 'dropdown-menu' ; } elseif ( ! preg_match ( '/(\s|^)dropdown-menu(\s|$)/' , $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] .= ' dropdown-menu' ; } } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] = 'menu' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'aria-labelledby' ] = $ aDropdownOptions [ 'name' ] ; } $ sItems = '' ; foreach ( $ aDropdownOptions [ 'items' ] as $ sKey => $ aItemOptions ) { if ( ! is_array ( $ aItemOptions ) ) { if ( ! is_scalar ( $ aItemOptions ) ) { throw new \ LogicException ( 'item option expects an array or a scalar value, "' . gettype ( $ aItemOptions ) . '" given' ) ; } $ aItemOptions = $ aItemOptions === self :: TYPE_ITEM_DIVIDER ? array ( 'type' => self :: TYPE_ITEM_DIVIDER ) : array ( 'label' => $ aItemOptions , 'type' => self :: TYPE_ITEM_LINK , 'item_attributes' => array ( 'href' => is_string ( $ sKey ) ? $ sKey : null ) ) ; } else { if ( ! isset ( $ aItemOptions [ 'label' ] ) ) { $ aItemOptions [ 'label' ] = is_string ( $ sKey ) ? $ sKey : null ; } if ( ! isset ( $ aItemOptions [ 'type' ] ) ) { $ aItemOptions [ 'type' ] = self :: TYPE_ITEM_LINK ; } } $ sItems .= $ this -> renderItem ( $ aItemOptions ) . "\n" ; } return sprintf ( static :: $ dropdownListFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'list_attributes' ] ) , $ sItems ) ; }
5277	public function where ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( ! in_array ( $ type , array ( 'and' , 'or' , 'where' ) ) ) { throw new \ Exception ( 'Invalid where type "' . $ type . '"' ) ; } $ sub_type = is_null ( $ param1 ) ? $ type : $ param1 ; if ( empty ( $ this -> statements [ 'wheres' ] ) ) { $ type = 'where' ; } if ( is_array ( $ column ) ) { $ subquery = array ( ) ; foreach ( $ column as $ value ) { if ( ! isset ( $ value [ 2 ] ) ) { $ value [ 2 ] = $ value [ 1 ] ; $ value [ 1 ] = '=' ; } $ subquery [ ] = $ this -> generateWhere ( $ value [ 0 ] , $ value [ 1 ] , $ value [ 2 ] , empty ( $ subquery ) ? '' : $ sub_type ) ; } $ this -> statements [ 'wheres' ] [ ] = $ type . ' ( ' . trim ( join ( ' ' , $ subquery ) ) . ' )' ; return $ this ; } $ this -> statements [ 'wheres' ] [ ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , $ type ) ; return $ this ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
2312	public function getCacheName ( ) { $ importantPart = $ this -> getImportantPart ( ) ; $ strCacheKey = substr ( md5 ( '-w' . $ this -> getTargetWidth ( ) . '-h' . $ this -> getTargetHeight ( ) . '-o' . $ this -> getOriginalPath ( ) . '-m' . $ this -> getResizeMode ( ) . '-z' . $ this -> getZoomLevel ( ) . '-x' . $ importantPart [ 'x' ] . '-y' . $ importantPart [ 'y' ] . '-i' . $ importantPart [ 'width' ] . '-e' . $ importantPart [ 'height' ] . '-t' . $ this -> fileObj -> mtime ) , 0 , 8 ) ; return StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.image.target_dir' ) ) . '/' . substr ( $ strCacheKey , - 1 ) . '/' . $ this -> fileObj -> filename . '-' . $ strCacheKey . '.' . $ this -> fileObj -> extension ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
9471	public function paginate ( $ numTotal , $ page , $ limit = 10 ) { $ this -> setTotalItemCount ( $ numTotal ) ; $ this -> setCurrentPageNumber ( $ page ) ; $ this -> setItemNumberPerPage ( $ limit ) ; }
8469	public function emergency ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'emergency' , $ scope , $ message , $ context , $ config ) ; }
4480	public function setData ( $ data ) : void { if ( is_array ( $ data ) == false && is_string ( $ data ) == false && $ data instanceof JobData == false ) { throw new InvalidArgumentException ( sprintf ( "Job's data must be either an array, or a JobData instance, or a JSON string, %s given." , gettype ( $ data ) ) ) ; } if ( is_array ( $ data ) == true ) { $ data = new JobData ( $ data ) ; } elseif ( is_string ( $ data ) == true ) { $ data = new JobData ( json_decode ( $ data , true ) ) ; } $ this -> data = $ data ; }
6278	protected function find ( $ key ) { $ keyLen = strlen ( $ key ) ; $ u = Util :: hash ( $ key ) ; $ upos = ( $ u << 3 ) & 2047 ; $ hashSlots = $ this -> readInt31 ( $ upos + 4 ) ; if ( ! $ hashSlots ) { return false ; } $ hashPos = $ this -> readInt31 ( $ upos ) ; $ keyHash = $ u ; $ u = Util :: unsignedShiftRight ( $ u , 8 ) ; $ u = Util :: unsignedMod ( $ u , $ hashSlots ) ; $ u <<= 3 ; $ keyPos = $ hashPos + $ u ; for ( $ i = 0 ; $ i < $ hashSlots ; $ i ++ ) { $ hash = $ this -> readInt32 ( $ keyPos ) ; $ pos = $ this -> readInt31 ( $ keyPos + 4 ) ; if ( ! $ pos ) { return false ; } $ keyPos += 8 ; if ( $ keyPos == $ hashPos + ( $ hashSlots << 3 ) ) { $ keyPos = $ hashPos ; } if ( $ hash === $ keyHash ) { if ( $ keyLen === $ this -> readInt31 ( $ pos ) ) { $ dataLen = $ this -> readInt31 ( $ pos + 4 ) ; $ dataPos = $ pos + 8 + $ keyLen ; $ foundKey = $ this -> read ( $ pos + 8 , $ keyLen ) ; if ( $ foundKey === $ key ) { $ this -> dataLen = $ dataLen ; $ this -> dataPos = $ dataPos ; return true ; } } } } return false ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
1004	public function parseRequestParams ( $ method , array $ bodyParams , array $ queryParams ) { if ( $ method === 'GET' ) { $ result = OperationParams :: create ( $ queryParams , true ) ; } elseif ( $ method === 'POST' ) { if ( isset ( $ bodyParams [ 0 ] ) ) { $ result = [ ] ; foreach ( $ bodyParams as $ index => $ entry ) { $ op = OperationParams :: create ( $ entry ) ; $ result [ ] = $ op ; } } else { $ result = OperationParams :: create ( $ bodyParams ) ; } } else { throw new RequestError ( 'HTTP Method "' . $ method . '" is not supported' ) ; } return $ result ; }
7363	protected function updatePaymentTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ paid = $ this -> paymentCalculator -> calculatePaidTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ paid , $ sale -> getPaidTotal ( ) , $ currency ) ) { $ sale -> setPaidTotal ( $ paid ) ; $ changed = true ; } $ pending = $ this -> paymentCalculator -> calculateOfflinePendingTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ pending , $ sale -> getPendingTotal ( ) , $ currency ) ) { $ sale -> setPendingTotal ( $ pending ) ; $ changed = true ; } $ acceptedOutstanding = $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ acceptedOutstanding , $ sale -> getOutstandingAccepted ( ) , $ currency ) ) { $ sale -> setOutstandingAccepted ( $ acceptedOutstanding ) ; $ changed = true ; } $ expiredOutstanding = $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ expiredOutstanding , $ sale -> getOutstandingExpired ( ) , $ currency ) ) { $ sale -> setOutstandingExpired ( $ expiredOutstanding ) ; $ changed = true ; } if ( $ changed && $ this -> outstandingReleaser -> releaseFund ( $ sale ) ) { $ sale -> setOutstandingAccepted ( $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ) ; $ sale -> setOutstandingExpired ( $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ) ; } return $ changed ; }
1889	protected function getPathNodes ( ) { if ( ! $ this -> varValue ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } foreach ( $ this -> varValue as $ id ) { $ arrPids = $ this -> Database -> getParentRecords ( $ id , 'tl_page' ) ; array_shift ( $ arrPids ) ; $ this -> arrNodes = array_merge ( $ this -> arrNodes , $ arrPids ) ; } }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
3220	function restoreFile ( $ path , $ rev ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argStringNonEmpty ( "rev" , $ rev ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/restore" , $ path ) , array ( "rev" => $ rev ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
5986	public function getTokens ( ) { $ tokens = [ 'accessToken' => null , 'refreshToken' => null ] ; if ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) { $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2accesstoken' ) ) { $ tokens [ 'accessToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2accesstoken' ) ) ; } if ( $ this -> cache instanceof Cache && empty ( $ tokens [ 'accessToken' ] ) && $ this -> cache -> contains ( 'oauth2refreshtoken' ) ) { $ tokens [ 'refreshToken' ] = unserialize ( $ this -> cache -> fetch ( 'oauth2refreshtoken' ) ) ; } if ( empty ( $ tokens [ 'accessToken' ] ) ) { $ response = $ this -> getClient ( ) -> get ( '/' ) ; $ tokens [ 'accessToken' ] = $ this -> oauth2Middleware -> getAccessToken ( ) ; $ tokens [ 'refreshToken' ] = $ this -> oauth2Middleware -> getRefreshToken ( ) ; } return $ tokens ; }
2431	public function checkCategory ( $ varValue ) { if ( \ strlen ( $ varValue ) || Contao \ Input :: post ( 'FORM_SUBMIT' ) == 'tl_style' ) { return $ varValue ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ key = 'tl_style_' . CURRENT_ID ; $ filter = $ objSessionBag -> get ( 'filter' ) ; if ( \ strlen ( $ filter [ $ key ] [ 'category' ] ) ) { return $ filter [ $ key ] [ 'category' ] ; } return '' ; }
474	public function update ( $ table , $ columns , $ condition = '' , $ params = [ ] ) { $ time = $ this -> beginCommand ( "update $table" ) ; $ this -> db -> createCommand ( ) -> update ( $ table , $ columns , $ condition , $ params ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
11522	public function get ( $ name ) { return isset ( $ this -> _items [ $ name ] ) ? $ this -> _items [ $ name ] : null ; }
5958	public function clientGetById ( $ clid ) { if ( ! array_key_exists ( ( string ) $ clid , $ this -> clientList ( ) ) ) { throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; } return $ this -> clientList [ intval ( ( string ) $ clid ) ] ; }
3878	public function addChild ( $ child ) { if ( ! \ is_array ( $ child ) ) { throw new \ RuntimeException ( 'Error Processing sub filter: ' . var_export ( $ child , true ) , 1 ) ; } switch ( strtoupper ( $ child [ 'operation' ] ) ) { case '=' : case '>' : case '<' : return $ this -> getFilterForComparingOperator ( $ child ) ; case 'IN' : return $ this -> getFilterForInList ( $ child ) ; case 'LIKE' : return $ this -> getFilterForLike ( $ child ) ; default : } throw new \ RuntimeException ( 'Error processing filter array ' . var_export ( $ child , true ) , 1 ) ; }
4716	public function on ( $ event , callable $ callback , $ priority = 10 ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { $ this -> callbacks [ $ event ] = [ true , [ ] ] ; } $ this -> callbacks [ $ event ] [ 0 ] = false ; $ this -> callbacks [ $ event ] [ 1 ] [ ] = array ( $ priority , $ callback ) ; return $ this ; }
11668	public static function getRemoteClient ( array $ params ) { return new m62Sftp ( [ 'host' => $ params [ 'sftp_host' ] , 'username' => $ params [ 'sftp_username' ] , 'password' => $ params [ 'sftp_password' ] , 'port' => $ params [ 'sftp_port' ] , 'privateKey' => ( isset ( $ params [ 'sftp_private_key' ] ) ? $ params [ 'sftp_private_key' ] : '' ) , 'timeout' => ( ! empty ( $ params [ 'sftp_timeout' ] ) ? $ params [ 'sftp_timeout' ] : '30' ) , 'root' => $ params [ 'sftp_root' ] ] ) ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
6594	public function getMethodDocumentation ( \ ReflectionMethod $ method ) { $ comment = $ this -> getMethodComment ( $ method ) ; $ summary = $ this -> getSummary ( $ comment ) ; $ parameters = $ this -> getParameters ( $ comment ) ; $ returnType = $ this -> getReturnType ( $ comment ) ; $ documentation = [ ] ; if ( $ summary ) { $ documentation [ 'summary' ] = $ summary ; $ description = $ this -> getDescription ( $ comment ) ; if ( $ description ) { $ documentation [ 'description' ] = $ description ; } } $ documentation [ 'parameters' ] = $ parameters ; $ documentation [ 'returnType' ] = $ returnType ; return $ documentation ; }
523	protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } }
119	protected function getPassword ( ) { if ( $ this -> credentials === null ) { throw new \ LogicException ( "No svn auth detected." ) ; } return isset ( $ this -> credentials [ 'password' ] ) ? $ this -> credentials [ 'password' ] : '' ; }
9957	public function protectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 , $ password , $ alreadyHashed = false ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> protectCells ( $ cellRange , $ password , $ alreadyHashed ) ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
10299	private function writeDataLabels ( XMLWriter $ objWriter , Layout $ chartLayout = null ) { $ objWriter -> startElement ( 'c:dLbls' ) ; $ objWriter -> startElement ( 'c:showLegendKey' ) ; $ showLegendKey = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowLegendKey ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLegendKey ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showVal' ) ; $ showVal = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowVal ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showVal ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showCatName' ) ; $ showCatName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowCatName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showCatName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showSerName' ) ; $ showSerName = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowSerName ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showSerName ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showPercent' ) ; $ showPercent = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowPercent ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showPercent ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showBubbleSize' ) ; $ showBubbleSize = ( empty ( $ chartLayout ) ) ? 0 : $ chartLayout -> getShowBubbleSize ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showBubbleSize ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showLeaderLines' ) ; $ showLeaderLines = ( empty ( $ chartLayout ) ) ? 1 : $ chartLayout -> getShowLeaderLines ( ) ; $ objWriter -> writeAttribute ( 'val' , ( ( empty ( $ showLeaderLines ) ) ? 0 : 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
707	public function bigPrimaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGPK , $ length ) ; }
12264	public function addSource ( $ sourcePath , $ useStrict = true ) { if ( is_link ( $ sourcePath ) ) { return $ this -> addSource ( realpath ( $ sourcePath ) , $ useStrict ) ; } if ( is_dir ( $ sourcePath ) ) { $ this -> sourceDirs [ ] = $ sourcePath ; } elseif ( true === $ useStrict ) { throw new \ Exception ( sprintf ( 'Path {%s} is not a readable directory' , $ sourcePath ) ) ; } return $ this ; }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
2341	protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
7160	public function buildSaleView ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> initialize ( $ sale , $ options ) ; $ this -> amountCalculator -> calculateSale ( $ sale ) ; $ grossResult = $ sale -> getGrossResult ( ) ; $ this -> view -> setGross ( new TotalView ( $ this -> formatter -> currency ( $ grossResult -> getGross ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getDiscount ( $ this -> view -> isAti ( ) ) ) , $ this -> formatter -> currency ( $ grossResult -> getBase ( $ this -> view -> isAti ( ) ) ) ) ) ; $ finalResult = $ sale -> getFinalResult ( ) ; $ this -> view -> setFinal ( new TotalView ( $ this -> formatter -> currency ( $ finalResult -> getBase ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTax ( ) ) , $ this -> formatter -> currency ( $ finalResult -> getTotal ( ) ) ) ) ; if ( $ this -> options [ 'private' ] && null !== $ margin = $ this -> marginCalculator -> calculateSale ( $ sale ) ) { $ prefix = $ margin -> isAverage ( ) ? '~' : '' ; $ this -> view -> setMargin ( new MarginView ( $ prefix . $ this -> formatter -> currency ( $ margin -> getAmount ( ) ) , $ prefix . $ this -> formatter -> percent ( $ margin -> getPercent ( ) ) ) ) ; $ this -> view -> vars [ 'show_margin' ] = true ; } $ this -> buildSaleItemsLinesViews ( $ sale ) ; $ this -> buildSaleDiscountsLinesViews ( $ sale ) ; $ this -> buildShipmentLine ( $ sale ) ; $ this -> buildSaleTaxesViews ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> buildSaleView ( $ sale , $ this -> view , $ this -> options ) ; } $ columnsCount = 6 ; if ( $ this -> view -> vars [ 'show_availability' ] ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_discounts' ] = 0 < count ( $ grossResult -> getDiscountAdjustments ( ) ) ) { $ columnsCount += 3 ; } if ( $ this -> view -> vars [ 'show_taxes' ] = 1 < count ( $ finalResult -> getTaxAdjustments ( ) ) ) { $ columnsCount ++ ; } if ( $ this -> view -> vars [ 'show_margin' ] ) { $ columnsCount ++ ; } if ( $ this -> options [ 'editable' ] ) { $ columnsCount ++ ; } $ this -> view -> vars [ 'columns_count' ] = $ columnsCount ; return $ this -> view ; }
9129	public function setInterceptor ( StreamInterceptor $ interceptor ) { $ this -> interceptor = $ interceptor ; stream_filter_append ( $ this -> stdout , $ interceptor -> getFilterName ( ) ) ; }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
2696	public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
4991	public function getEntity ( $ key = '*' ) { return isset ( $ this -> entities [ $ key ] ) ? $ this -> entities [ $ key ] : null ; }
5641	public function paintCaseStart ( $ test_name ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = 1 ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
2082	public function generateXmlFiles ( ) { $ this -> generateSitemap ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Regenerated the XML files' , __METHOD__ , TL_CRON ) ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
3447	public function toArray ( ) { $ array = $ this -> fields ; foreach ( $ this -> appends as $ accessor ) { if ( isset ( $ this [ $ accessor ] ) ) { $ array [ $ accessor ] = $ this [ $ accessor ] ; } } foreach ( $ this -> related as $ key => $ value ) { if ( is_object ( $ value ) && method_exists ( $ value , 'toArray' ) ) { $ array [ $ key ] = $ value -> toArray ( ) ; } elseif ( is_null ( $ value ) || $ value === false ) { $ array [ $ key ] = $ value ; } } if ( count ( $ this -> getVisible ( ) ) > 0 ) { $ array = array_intersect_key ( $ array , array_flip ( $ this -> getVisible ( ) ) ) ; } if ( count ( $ this -> getHidden ( ) ) > 0 ) { $ array = array_diff_key ( $ array , array_flip ( $ this -> getHidden ( ) ) ) ; } return $ array ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
6847	public static function adjust ( $ hour , $ ampm ) { $ hour = ( int ) $ hour ; $ ampm = strtolower ( $ ampm ) ; switch ( $ ampm ) { case 'am' : if ( $ hour == 12 ) { $ hour = 0 ; } break ; case 'pm' : if ( $ hour < 12 ) { $ hour += 12 ; } break ; } return sprintf ( '%02d' , $ hour ) ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
800	private function findStart ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ $ index ] -> equalsAny ( [ '$' , [ T_VARIABLE ] ] ) ) { if ( $ tokens [ $ index ] -> equals ( ']' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_INDEX_SQUARE_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_PROP_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_PROP_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_DYNAMIC_VAR_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_DYNAMIC_VAR_BRACE , $ index ) ; } elseif ( $ tokens [ $ index ] -> isGivenKind ( CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_INDEX_CURLY_BRACE , $ index ) ; } else { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } } while ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> equals ( '$' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } if ( $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_OBJECT_OPERATOR ) ) { return $ this -> findStart ( $ tokens , $ tokens -> getPrevMeaningfulToken ( $ index ) ) ; } return $ index ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
1311	public function checkSignature ( Request $ request , Consumer $ consumer , Token $ token , $ signature ) { $ built = $ this -> buildSignature ( $ request , $ consumer , $ token ) ; if ( strlen ( $ built ) == 0 || strlen ( $ signature ) == 0 ) { return false ; } if ( strlen ( $ built ) != strlen ( $ signature ) ) { return false ; } $ result = 0 ; for ( $ i = 0 ; $ i < strlen ( $ signature ) ; $ i ++ ) { $ result |= ord ( $ built { $ i } ) ^ ord ( $ signature { $ i } ) ; } return $ result == 0 ; }
11330	public function getMultiline ( ) { if ( is_null ( $ this -> _multiline ) ) { $ this -> _multiline = MultilineDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _multiline ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
3881	private function getPageDetails ( $ pageId ) { if ( empty ( $ pageId ) ) { return array ( ) ; } $ event = new GetPageDetailsEvent ( $ pageId ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; return $ event -> getPageDetails ( ) ; }
12320	public static function getBundleLocationName ( string $ sName ) : string { $ oConfig = self :: get ( $ sName , null , true ) ; if ( isset ( $ oConfig -> redirect ) ) { return $ oConfig -> redirect ; } else { return PORTAL ; } }
2852	public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
5400	protected function truncateHost ( $ host ) { $ tlds = SimpleUrl :: getAllTopLevelDomains ( ) ; if ( preg_match ( '/[a-z\-]+\.(' . $ tlds . ')$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } elseif ( preg_match ( '/[a-z\-]+\.[a-z\-]+\.[a-z\-]+$/i' , $ host , $ matches ) ) { return $ matches [ 0 ] ; } return false ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
6536	protected function retrieve ( ) { if ( false === $ this -> retrieved ) { $ this -> updatedDatas = $ this -> getArray ( ) ; $ this -> retrieved = true ; } }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
1214	public static function isObject ( $ value ) { if ( is_array ( $ value ) ) { return ! $ value || array_keys ( $ value ) [ 0 ] !== 0 ; } return $ value instanceof \ Countable && $ value instanceof \ ArrayAccess ? count ( $ value ) == 0 || ! $ value -> offsetExists ( 0 ) : $ value instanceof \ stdClass || $ value instanceof JmesPathableObjectInterface ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
1954	public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
1103	protected function fireMoveEvent ( $ event , $ halt = true ) { if ( ! isset ( static :: $ dispatcher ) ) return true ; $ event = "eloquent.{$event}: " . get_class ( $ this -> node ) ; $ method = $ halt ? 'until' : 'fire' ; return static :: $ dispatcher -> $ method ( $ event , $ this -> node ) ; }
12954	public static function priceStringToInt ( string $ str , string $ propertyPath = '' ) : int { $ str = trim ( $ str ) ; if ( ! preg_match ( '/(\.|,)[0-9]{2}$/' , $ str ) ) { throw new \ InvalidArgumentException ( ( $ propertyPath ? $ propertyPath . ' (value: "' . $ str . '")' : $ str ) . ' does not match the currency string format' ) ; } $ str = preg_replace ( '/[^0-9]+/' , '' , $ str ) ; return intval ( $ str ) ; }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
4384	protected function dumpArray ( $ array ) { $ isNested = $ this -> valDepth > 0 ; $ this -> valDepth ++ ; $ array = parent :: dumpArray ( $ array ) ; $ str = \ trim ( \ print_r ( $ array , true ) ) ; $ str = \ preg_replace ( '#^Array\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '#^array\s*\(\s+\)#' , 'array()' , $ str ) ; if ( $ isNested ) { $ str = \ str_replace ( "\n" , "\n " , $ str ) ; } return $ str ; }
11162	protected function getKey ( array $ config ) { if ( ! isset ( $ config [ 'key' ] ) || ! is_string ( $ config [ 'key' ] ) ) { throw new \ DomainException ( 'key must reference a string' , self :: ERR_INVALID_KEY ) ; } return $ config [ 'key' ] ; }
9382	public function getTag ( $ classNames , $ color = null ) { return ArrayData :: create ( [ 'ClassNames' => $ classNames , 'Color' => $ color ] ) -> renderWith ( sprintf ( '%s\Tag' , self :: class ) ) ; }
3317	public function pushValue ( $ value ) { $ value = $ this -> _preprocessValue ( $ value ) ; $ this -> value [ ] = $ value ; $ this -> callTrigger ( ) ; }
9360	protected function middleware ( FinalCallback $ callback , ServerRequestInterface $ request ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( interface_exists ( Application :: MIDDLEWARE ) === true ) { $ middleware = new Dispatcher ( $ this -> middlewares , $ response ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
8472	public function error ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'error' , $ scope , $ message , $ context , $ config ) ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
11419	protected function getValues ( $ fields , $ preCalculatedResult = false ) { if ( $ preCalculatedResult ) { return $ preCalculatedResult ; } $ app = App :: getInstance ( ) ; $ sql = $ this -> constructSelectSQL ( $ fields ) ; $ item = $ this -> getCache ( $ fields [ $ this -> pk ] ) ; $ results = $ item -> get ( \ Stash \ Invalidation :: PRECOMPUTE , 300 ) ; if ( $ item -> isMiss ( ) ) { $ results = $ this -> runGetRow ( $ sql ) ; if ( $ app [ 'db' ] -> last_error ) { throw new SQLException ( $ app [ 'db' ] -> last_error , $ app [ 'db' ] -> captured_errors ) ; } if ( is_null ( $ results ) ) { throw new ModelNotFoundException ( 'No model in database' , $ this -> dbtable , $ this -> constructorId ) ; } $ app [ 'cache' ] -> save ( $ item -> set ( $ results ) ) ; } return $ results ; }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
10822	public static function block ( $ messages , $ style ) { if ( is_string ( $ messages ) ) { $ messages = [ $ messages ] ; } if ( count ( $ messages ) > 0 ) { self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; foreach ( $ messages as $ message ) { $ message = ' ' . $ message ; while ( strlen ( $ message ) < self :: $ lineLength ) { $ message .= ' ' ; } self :: writeln ( $ message , $ style ) ; } self :: writeln ( str_repeat ( ' ' , self :: $ lineLength ) , $ style ) ; } }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
1452	protected function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createDeleteValidator ( $ data , $ rules , $ messages , $ customAttributes ) ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
11372	protected function onClassFound ( ScannedPhpClass $ subject ) { $ class = $ subject -> getClass ( ) ; $ main = $ this -> reader -> getClassAnnotation ( $ class , Di \ DiServiceAnnotation :: class ) ; if ( $ main instanceof Di \ DiServiceAnnotation ) { $ definition = $ this -> provideServiceDefinitionFor ( new ServiceDefinitionProvider \ Frame ( $ class , $ main , DiOptionsCollection :: from ( $ this -> reader , $ class ) , null ) ) ; $ this -> addServiceDefinition ( $ definition ) ; } }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
10024	public static function flattenArrayIndexed ( $ array ) { if ( ! is_array ( $ array ) ) { return ( array ) $ array ; } $ arrayValues = [ ] ; foreach ( $ array as $ k1 => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ k2 => $ val ) { if ( is_array ( $ val ) ) { foreach ( $ val as $ k3 => $ v ) { $ arrayValues [ $ k1 . '.' . $ k2 . '.' . $ k3 ] = $ v ; } } else { $ arrayValues [ $ k1 . '.' . $ k2 ] = $ val ; } } } else { $ arrayValues [ $ k1 ] = $ value ; } } return $ arrayValues ; }
2220	public static function findPublishedDefaultByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.source='default'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
5343	public function build ( SoapClientBuilderInterface $ builder ) { $ builder -> createWsdl ( $ this -> endpoint ) ; $ builder -> createSoapClient ( ) ; $ builder -> setLogin ( $ this -> login ) ; $ builder -> setMode ( $ this -> mode ) ; $ builder -> setClientVersion ( self :: CLIENT_VERSION ) ; return $ builder -> getSoapClient ( ) ; }
3054	public function persistSeenCatItemIds ( $ seenCatItemId ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ items = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> getCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' ) ; if ( ! $ items ) { $ items = [ ] ; } else { $ items = json_decode ( $ items ) ; } if ( ! in_array ( $ seenCatItemId , $ items ) ) { $ items [ ] = $ seenCatItemId ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-seen-item-ids' , json_encode ( $ items ) ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
10251	public function getFirstName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } return FirstName :: where ( 'gender' , $ gender ) -> where ( 'rank' , '<=' , 250 ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
2342	protected function getUserId ( ) { if ( $ this -> intUserId !== null ) { return $ this -> intUserId ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> id ; }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
9919	private function findColumns ( Model $ model ) { $ tableName = $ this -> getTableName ( $ model ) ; if ( ! $ this -> databaseRepository -> hasTable ( $ tableName ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Table %s for %s does not exist!' , $ tableName , $ model -> getName ( ) ) ) ; } $ columns = $ this -> databaseRepository -> getColumnListing ( $ tableName ) ; foreach ( $ columns as $ columnName ) { $ columnType = $ this -> databaseRepository -> getColumnType ( $ tableName , $ columnName ) ; $ model -> addColumn ( new Column ( $ columnName , $ columnType ) ) ; } }
11347	public function renderField ( $ name ) { $ html = '' ; $ field = $ this -> getField ( $ name ) ; $ html .= $ this -> formatter -> renderField ( $ field ) ; return $ html ; }
10234	public function main ( ) { $ config = $ this -> app [ 'config' ] [ 'auja' ] ? : $ this -> app [ 'config' ] [ 'auja-laravel::config' ] ; $ authenticationForm = $ this -> app [ 'auja' ] -> authenticationForm ( $ config [ 'title' ] , $ this -> app [ 'url' ] -> route ( 'auja.support.login' , [ ] , false ) ) ; $ username = ( $ this -> app [ 'auth' ] -> user ( ) == null ) ? null : $ this -> app [ 'auth' ] -> user ( ) -> name ; $ main = $ this -> app [ 'auja' ] -> main ( $ config [ 'title' ] , $ this -> app [ 'auth' ] -> check ( ) , $ username , $ this -> app [ 'url' ] -> route ( 'auja.support.logout' , [ ] , false ) , $ authenticationForm ) ; $ main -> setColor ( Main :: COLOR_MAIN , $ config [ 'color' ] [ 'main' ] ) ; $ main -> setColor ( Main :: COLOR_ALERT , $ config [ 'color' ] [ 'alert' ] ) ; $ main -> setColor ( Main :: COLOR_SECONDARY , $ config [ 'color' ] [ 'secondary' ] ) ; return new JsonResponse ( $ main ) ; }
4925	public function getTypes ( $ region = null ) { if ( null === $ region ) { $ ret = [ ] ; foreach ( $ this -> matrix as $ types ) { $ ret = array_merge ( $ ret , $ types ) ; } return array_values ( array_unique ( $ ret ) ) ; } return $ this -> matrix [ $ region ] ; }
2301	public static function convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) { $ arrSections = array_flip ( array_values ( array_unique ( $ arrSections ) ) ) ; foreach ( array_keys ( $ arrSections ) as $ k ) { $ arrSections [ $ k ] = $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ k ] ; } asort ( $ arrSections ) ; return $ arrSections ; }
11510	public static function parse ( $ program ) { $ i = 0 ; $ len = strlen ( $ program ) ; $ forms = [ ] ; while ( $ i < $ len ) { if ( strpos ( self :: WHITESPACES , $ program [ $ i ] ) === false ) { try { $ form = self :: parseExpression ( substr ( $ program , $ i ) , $ offset ) ; if ( ! is_null ( $ form ) ) $ forms [ ] = $ form ; } catch ( ParseException $ e ) { throw new ParseException ( $ program , $ e -> offset + $ i ) ; } $ i += $ offset ; } else ++ $ i ; } return $ forms ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
10066	public function actionGenerate ( ) { $ input = $ this -> parseArguments ( func_get_args ( ) ) ; $ container = new Container ( ) ; $ container -> set ( GeneratorInterface :: class , array_merge ( [ 'class' => $ this -> generator_fqn ] , $ input [ 'generator' ] ) ) ; $ container -> set ( DbProviderInterface :: class , array_merge ( [ 'class' => $ this -> dbprovider_fqn ] , $ input [ 'dbprovider' ] ) ) ; $ this -> generator_obj = $ container -> get ( GeneratorInterface :: class ) ; if ( ! $ this -> force && ! $ this -> confirmGeneration ( ) ) { return ; } $ this -> dbprovider_obj = $ container -> get ( DbProviderInterface :: class ) ; Console :: startProgress ( 0 , $ this -> count ) ; foreach ( $ this -> dbprovider_obj -> export ( $ this -> count ) as $ count ) { Console :: updateProgress ( $ this -> count - $ count , $ this -> count ) ; } Console :: endProgress ( true ) ; }
12081	public function deleteChild ( $ idParent , FilterRequest $ filters , $ idChild , $ relation ) { $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> deleteChild ( $ idParent , $ relation , $ idChild ) ; if ( $ resource == null ) { } return $ this -> success ( ) ; }
3752	public function resetFallback ( $ strField ) { @ trigger_error ( __CLASS__ . '::' . __METHOD__ . ' is deprecated - handle resetting manually' , E_USER_DEPRECATED ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ attribute = $ metaModel -> getAttribute ( $ strField ) ; $ ids = $ metaModel -> getIdsFromFilter ( null ) ; if ( $ attribute instanceof IComplex ) { $ attribute -> unsetDataFor ( $ ids ) ; } if ( $ attribute instanceof ITranslated ) { $ attribute -> unsetValueFor ( $ ids , $ this -> getCurrentLanguage ( ) ) ; } if ( $ attribute instanceof IAttribute ) { $ data = array ( ) ; foreach ( $ ids as $ id ) { $ data [ $ id ] = null ; } $ attribute -> setDataFor ( $ data ) ; } throw new \ RuntimeException ( 'Unknown attribute or type ' . $ strField ) ; }
1042	private function printBlockString ( $ value , $ isDescription ) { $ escaped = str_replace ( '"""' , '\\"""' , $ value ) ; return ( $ value [ 0 ] === ' ' || $ value [ 0 ] === "\t" ) && strpos ( $ value , "\n" ) === false ? ( '"""' . preg_replace ( '/"$/' , "\"\n" , $ escaped ) . '"""' ) : ( '"""' . "\n" . ( $ isDescription ? $ escaped : $ this -> indent ( $ escaped ) ) . "\n" . '"""' ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
8239	public function setAuthenticated ( $ v ) { if ( ! $ v ) { $ this -> authenticator = null ; } $ this -> authenticated = $ v ; return $ this ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
8506	public function getBillOfLading ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetBillOfLadingRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetBillOfLadingRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetBillOfLading' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetBillOfLadingResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
240	private function saveTableMetadataToCache ( $ cache , $ name ) { if ( $ cache === null ) { return ; } $ metadata = $ this -> _tableMetadata [ $ name ] ; $ metadata [ 'cacheVersion' ] = static :: SCHEMA_CACHE_VERSION ; $ cache -> set ( $ this -> getCacheKey ( $ name ) , $ metadata , $ this -> db -> schemaCacheDuration , new TagDependency ( [ 'tags' => $ this -> getCacheTag ( ) ] ) ) ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
7071	protected function updateMessage ( TicketMessageInterface $ message ) { $ message -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ message , true ) ; }
11258	private function invoker ( ContainerInterface $ container ) { $ resolvers = new ResolverChain ( [ new ParameterNameContainerResolver ( $ container ) , new DefaultValueResolver ( ) , ] ) ; $ invoker = new Invoker ( $ resolvers , $ container ) ; return $ invoker ; }
8345	public static function prefix ( string $ namespace , $ subdomain = null , string $ uri = null ) { self :: $ namespace = $ namespace ; self :: $ subdomain = is_array ( $ subdomain ) ? $ subdomain : [ $ subdomain ] ; self :: $ uri = $ uri ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
8020	public function set ( string $ content ) { $ parsed = $ this -> parseContent ( $ content ) ; $ this -> id = $ parsed -> id ; $ this -> infoUri = $ parsed -> infoUri ; $ this -> partialCancelUri = $ parsed -> partialCancelUri ?? null ; $ this -> nextUri = $ parsed -> nextUri ?? null ; $ this -> columns = [ ] ; if ( isset ( $ parsed -> columns ) ) { $ this -> columnTransfer ( $ parsed -> columns ) ; } $ this -> data = $ parsed -> data ?? [ ] ; $ this -> stats = isset ( $ parsed -> stats ) ? $ this -> statsTransfer ( $ parsed -> stats ) : null ; $ this -> error = isset ( $ parsed -> error ) ? $ this -> errorTransfer ( $ parsed -> error ) : null ; }
9448	public function getPackPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) ; } return $ paths [ $ me ] ; }
10954	protected function ifNoneMatch ( Request $ request , Response $ response , string $ etag ) : Response { $ ifNoneMatch = $ request -> getHeaderLine ( 'If-None-Match' ) ; if ( $ ifNoneMatch && $ etag === $ ifNoneMatch ) { return $ response -> withStatus ( 304 , "Not Modified" ) ; } return $ response ; }
6991	static public function getLocaleWithSuffix ( $ separator = '_' , $ lowercased = false ) : ? string { $ locale = preg_split ( '%[-_]%' , strtolower ( app ( ) -> getLocale ( ) ) ) ; if ( count ( $ locale ) === 2 ) { return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ locale [ 1 ] : strtoupper ( $ locale [ 1 ] ) ) ; } else { $ localeSuffix = isset ( static :: $ localeSuffixMap [ $ locale [ 0 ] ] ) ? static :: $ localeSuffixMap [ $ locale [ 0 ] ] : $ locale [ 0 ] ; return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ localeSuffix : strtoupper ( $ localeSuffix ) ) ; } }
8904	public function delete_many ( $ primary_values , $ time = 'NOW()' ) { $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) ; return $ this -> _delete ( $ primary_values , $ time ) ; }
4230	public static function getParsed ( $ what ) { $ hash = null ; if ( \ is_object ( $ what ) ) { $ hash = self :: getHash ( $ what ) ; if ( isset ( self :: $ cache [ $ hash ] ) ) { return self :: $ cache [ $ hash ] ; } } $ comment = self :: getCommentContent ( $ what ) ; if ( \ is_array ( $ comment ) ) { return $ comment ; } $ return = array ( 'summary' => null , 'description' => null , ) ; if ( \ preg_match ( '/^@/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ pos = $ matches [ 0 ] [ 1 ] ; $ strTags = \ substr ( $ comment , $ pos ) ; $ return = \ array_merge ( $ return , self :: parseTags ( $ strTags ) ) ; $ comment = $ pos > 0 ? \ substr ( $ comment , 0 , $ pos - 1 ) : '' ; } $ comment = \ preg_replace ( '/^\\\@/m' , '@' , $ comment ) ; $ comment = \ str_replace ( '{@*}' , '*/' , $ comment ) ; $ split = \ preg_split ( '/(\.[\r\n]+|[\r\n]{2})/' , $ comment , 2 , PREG_SPLIT_DELIM_CAPTURE ) ; $ split = \ array_replace ( array ( '' , '' , '' ) , $ split ) ; $ return = \ array_merge ( $ return , \ array_filter ( array ( 'summary' => \ trim ( $ split [ 0 ] . $ split [ 1 ] ) , 'desc' => \ trim ( $ split [ 2 ] ) , ) ) ) ; if ( $ hash ) { self :: $ cache [ $ hash ] = $ return ; } return $ return ; }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
6909	public function removeCopy ( Recipient $ copy ) { if ( $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> removeElement ( $ copy ) ; } return $ this ; }
3813	protected function transformGroupSort ( $ rows ) { foreach ( $ rows as $ row ) { $ this -> groupSort [ ] = new InputScreenGroupingAndSorting ( $ row , $ this ) ; } }
2392	public function getAllowedCalendars ( ) { if ( $ this -> User -> isAdmin ) { $ objCalendar = Contao \ CalendarModel :: findAll ( ) ; } else { $ objCalendar = Contao \ CalendarModel :: findMultipleByIds ( $ this -> User -> calendars ) ; } $ return = array ( ) ; if ( $ objCalendar !== null ) { while ( $ objCalendar -> next ( ) ) { $ return [ $ objCalendar -> id ] = $ objCalendar -> title ; } } return $ return ; }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
4850	public function prepare ( $ value ) { $ importer = $ this -> getVariably ( ) -> get ( 'importer' ) ; $ table = $ importer -> getCurrentTable ( ) ; if ( ! isset ( $ this -> counter [ $ table ] ) ) { $ db = $ importer -> getDb ( ) ; $ counter = $ db -> fetchOne ( 'SELECT MAX(DISTINCT counter) AS counter FROM ' . $ table ) ; $ this -> counter [ $ table ] = $ counter [ 'counter' ] + 1 ; } return $ this -> counter [ $ table ] ; }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
7768	public function validate ( array $ data , $ rules = [ ] ) { $ this -> clearErrors ( ) ; $ this -> clearFieldAliases ( ) ; $ data = $ this -> extractFieldAliases ( $ data ) ; if ( empty ( $ rules ) ) { $ rules = $ this -> extractRules ( $ data ) ; $ data = $ this -> extractInput ( $ data ) ; } $ this -> input = $ data ; foreach ( $ this -> before as $ before ) { call_user_func_array ( $ before , [ $ this ] ) ; } foreach ( $ data as $ field => $ value ) { $ fieldRules = explode ( '|' , $ rules [ $ field ] ) ; foreach ( $ fieldRules as $ rule ) { $ continue = $ this -> validateAgainstRule ( $ field , $ value , $ this -> getRuleName ( $ rule ) , $ this -> getRuleArgs ( $ rule ) ) ; if ( ! $ continue ) { break ; } } } return $ this ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
1281	protected function buildFile ( array $ data ) : FileInterface { if ( isset ( $ data [ 'uploadFrom' ] ) ) { return new LocalUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , new Link ( $ data [ 'uploadFrom' ] [ 'sys' ] [ 'id' ] , $ data [ 'uploadFrom' ] [ 'sys' ] [ 'linkType' ] ) ) ; } if ( isset ( $ data [ 'upload' ] ) ) { return new RemoteUploadFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'upload' ] ) ; } if ( isset ( $ data [ 'details' ] [ 'image' ] ) ) { return new ImageFile ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] , $ data [ 'details' ] [ 'image' ] [ 'width' ] , $ data [ 'details' ] [ 'image' ] [ 'height' ] ) ; } return new File ( $ data [ 'fileName' ] , $ data [ 'contentType' ] , $ data [ 'url' ] , $ data [ 'details' ] [ 'size' ] ) ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
11728	private function _fetch ( $ attrName , $ default = NULL ) { return $ this -> hasAttribute ( $ attrName ) ? $ this -> getAttribute ( $ attrName ) -> getValue ( ) : $ default ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
7994	public function getDedicatedServerList ( ) { $ request = $ this -> get ( 'dedicated/server' ) ; $ response = $ request -> send ( ) ; return $ response -> getBody ( true ) ; }
3095	protected function resolve ( $ data ) { if ( ! isset ( $ data [ 'action' ] ) || ! isset ( $ data [ 'timestamp' ] ) || ! isset ( $ data [ 'parameters' ] ) || ! is_array ( $ data [ 'parameters' ] ) ) { throw new \ common_exception_InconsistentData ( 'Action parameters have to contain "action", "timestamp" and "parameters" fields.' ) ; } $ availableActions = $ this -> getAvailableActions ( ) ; $ actionName = $ data [ 'action' ] ; $ actionClass = null ; if ( isset ( $ availableActions [ $ actionName ] ) ) { $ actionClass = $ availableActions [ $ actionName ] ; } if ( is_null ( $ actionClass ) || ! is_a ( $ actionClass , TestRunnerAction :: class , true ) ) { throw new \ ResolverException ( 'Action name "' . $ actionName . '" could not be resolved.' ) ; } return $ this -> getServiceManager ( ) -> propagate ( new $ actionClass ( $ actionName , $ data [ 'timestamp' ] , $ data [ 'parameters' ] ) ) ; }
12716	protected function getConcreteFromInterface ( $ interface ) { if ( ! $ this -> isAbstractExists ( $ interface ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: runtime ( sprintf ( "%s has no concrete implementation in the class binding stack." , $ interface ) ) ; } try { return $ this -> getResolvedSingleton ( $ interface ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> bindings [ $ interface ] [ 'concrete' ] ; $ object = $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ this -> build ( $ concrete ) ; if ( $ this -> isShared ( $ interface ) ) { $ this -> markAsResolved ( $ interface , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ interface , $ object ) ; } return $ object ; }
211	protected function hashPluginOptions ( $ view ) { $ encOptions = empty ( $ this -> clientOptions ) ? '{}' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ this -> _hashVar = self :: PLUGIN_NAME . '_' . hash ( 'crc32' , $ encOptions ) ; $ this -> options [ 'data-plugin-' . self :: PLUGIN_NAME ] = $ this -> _hashVar ; $ view -> registerJs ( "var {$this->_hashVar} = {$encOptions};" , View :: POS_HEAD ) ; }
9567	public function config ( $ configurator ) { if ( $ this -> booted ) { $ this -> invokeConfigurator ( $ configurator ) ; } else { $ this -> configurators -> push ( $ configurator ) ; } }
2235	public function onGeneratePage ( PageModel $ pageModel , LayoutModel $ layoutModel ) : void { $ calendarfeeds = StringUtil :: deserialize ( $ layoutModel -> calendarfeeds ) ; if ( empty ( $ calendarfeeds ) || ! \ is_array ( $ calendarfeeds ) ) { return ; } $ this -> framework -> initialize ( ) ; $ adapter = $ this -> framework -> getAdapter ( CalendarFeedModel :: class ) ; if ( ! ( $ feeds = $ adapter -> findByIds ( $ calendarfeeds ) ) instanceof Collection ) { return ; } $ template = $ this -> framework -> getAdapter ( Template :: class ) ; $ environment = $ this -> framework -> getAdapter ( Environment :: class ) ; foreach ( $ feeds as $ feed ) { $ GLOBALS [ 'TL_HEAD' ] [ ] = $ template -> generateFeedTag ( sprintf ( '%sshare/%s.xml' , ( $ feed -> feedBase ? : $ environment -> get ( 'base' ) ) , $ feed -> alias ) , $ feed -> format , $ feed -> title ) ; } }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
3127	protected function isEndPoint ( TimePoint $ point ) { return $ point -> match ( null , TimePoint :: TARGET_ALL , TimePoint :: TYPE_END ) ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
8687	public static function replaceRecursive ( $ iterable1 , $ iterable2 ) { Assert :: allIsIterable ( [ $ iterable1 , $ iterable2 ] ) ; if ( $ iterable1 instanceof Traversable ) { $ iterable1 = iterator_to_array ( $ iterable1 ) ; } if ( $ iterable2 instanceof Traversable ) { $ iterable2 = iterator_to_array ( $ iterable2 ) ; } $ merged = $ iterable1 ; foreach ( $ iterable2 as $ key => $ value ) { if ( $ value instanceof Traversable ) { $ value = iterator_to_array ( $ value ) ; } if ( is_array ( $ value ) && static :: isAssociative ( $ value ) && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = static :: replaceRecursive ( $ merged [ $ key ] , $ value ) ; } elseif ( $ value === null && isset ( $ merged [ $ key ] ) && \ is_iterable ( $ merged [ $ key ] ) ) { if ( $ merged [ $ key ] instanceof Traversable ) { $ merged [ $ key ] = iterator_to_array ( $ merged [ $ key ] ) ; } continue ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
6785	public function buildFormDataString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ formOptions = [ ] ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { $ formOptions [ $ key ] = $ options [ $ key ] ; } } return http_build_query ( $ formOptions ) ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
3525	public function lookup ( $ username ) { try { $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_PERSONA_API . 'public/account/lookup?q=' . urlencode ( $ username ) , $ this -> access_token ) ; return new self ( $ this -> access_token , $ data -> id ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) throw new UserNotFoundException ( 'User ' . $ username . ' was not found.' ) ; throw $ e ; } }
11842	private function getBind ( ) { [ $ dsBegin , $ treeType ] = $ this -> extractInput ( ) ; $ calcId = $ this -> getCalcId ( $ dsBegin , $ treeType ) ; $ bind = [ QGrid :: BND_CALC_ID => $ calcId ] ; return $ bind ; }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
12827	protected function removeBlockFromSlotFile ( array $ options , $ targetDir = null ) { $ targetDir = $ this -> workDirectory ( $ targetDir ) ; $ slot = $ this -> getSlotDefinition ( $ targetDir ) ; $ blockName = $ options [ "blockname" ] ; $ tmp = array_flip ( $ slot [ "blocks" ] ) ; unset ( $ tmp [ $ blockName ] ) ; $ slot [ "blocks" ] = array_keys ( $ tmp ) ; $ this -> saveSlotDefinition ( $ targetDir , $ slot ) ; return $ blockName ; }
7242	public function validate ( $ request ) { if ( ! empty ( $ request [ 'send_by_bcc' ] ) && '1' === $ request [ 'send_by_bcc' ] ) $ request [ 'send_by_bcc' ] = '1' ; else $ request [ 'send_by_bcc' ] = '0' ; if ( ! empty ( $ request [ 'send_attachments' ] ) && '1' === $ request [ 'send_attachments' ] ) $ request [ 'send_attachments' ] = '1' ; else $ request [ 'send_attachments' ] = '0' ; return $ request ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
8405	public static function run ( ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } foreach ( self :: $ namespaces as $ name => $ path ) { if ( is_readable ( $ path . DIRECTORY_SEPARATOR . 'init.php' ) === true ) { require $ path . DIRECTORY_SEPARATOR . 'init.php' ; } elseif ( stripos ( $ path , 'vendor' ) === false || stripos ( $ path , 'vendor' ) == strlen ( $ path ) - strlen ( 'vendor' ) ) { Logger :: get ( ) -> error ( 'namespace "' . $ name . '" doesn\'t have an init.php' ) ; } } if ( defined ( 'STRAY_IS_CLI' ) === true && constant ( 'STRAY_IS_CLI' ) === true ) { Console :: run ( ) ; } elseif ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { if ( count ( self :: $ applications ) == 0 ) { throw new BadUse ( 'no application has been registered' ) ; } Http :: run ( ) ; } else { throw new BadUse ( 'unknown mode, not CLI_IS_CLI nor STRAY_IS_HTTP' ) ; } }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
189	public function setTransactionIsolationLevel ( $ level ) { switch ( $ level ) { case Transaction :: SERIALIZABLE : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = False;' ) -> execute ( ) ; break ; case Transaction :: READ_UNCOMMITTED : $ this -> db -> createCommand ( 'PRAGMA read_uncommitted = True;' ) -> execute ( ) ; break ; default : throw new NotSupportedException ( get_class ( $ this ) . ' only supports transaction isolation levels READ UNCOMMITTED and SERIALIZABLE.' ) ; } }
946	public function handle ( Request $ request , Closure $ next ) { $ query = $ request -> query -> all ( ) ; $ signature = $ query [ 'signature' ] ; unset ( $ query [ 'signature' ] ) ; $ signatureLocal = ShopifyApp :: createHmac ( [ 'data' => $ query , 'buildQuery' => true ] ) ; if ( $ signature !== $ signatureLocal || ! isset ( $ query [ 'shop' ] ) ) { return Response :: make ( 'Invalid proxy signature.' , 401 ) ; } Session :: put ( 'shopify_domain' , ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ) ; return $ next ( $ request ) ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
106	public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
3628	protected static function getCURLCerts ( ) { $ url = 'https://curl.haxx.se/ca/cacert.pem' ; $ certs = @ file_get_contents ( $ url ) ; if ( ! $ certs ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , TRUE ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 2 ) ; $ response = curl_exec ( $ ch ) ; $ info = curl_getinfo ( $ ch ) ; curl_close ( $ ch ) ; if ( $ info [ 'http_code' ] == 200 ) { $ certs = $ response ; } } return $ certs ; }
3181	public function getMaximumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ maxTime = $ timeLimits -> getMaxTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ maxTime ) ; } return false ; }
8680	public function sortKeys ( $ order = SORT_ASC , $ flags = SORT_REGULAR ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( $ order === SORT_ASC ) { ksort ( $ items , $ flags ) ; } else { krsort ( $ items , $ flags ) ; } return $ this -> createFrom ( $ items ) ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
5777	public function null_eq ( string $ name , $ arg ) { if ( $ arg === null ) { $ this -> sql .= "$name is null" ; } else { $ this -> args [ ] = $ arg ; $ argNum = count ( $ this -> args ) ; $ this -> sql .= "$name = \$$argNum" ; } return $ this ; }
7554	protected function match_filters ( $ conditions , $ custom_filters = array ( ) ) { foreach ( $ conditions as $ c ) { $ c [ 'filter' ] = strtolower ( $ c [ 'filter' ] ) ; if ( isset ( $ this -> filter_map [ $ c [ 'filter' ] ] ) ) { if ( ! $ this -> { $ this -> filter_map [ $ c [ 'filter' ] ] } ( $ c [ 'params' ] ) ) { return false ; } } elseif ( isset ( $ custom_filters [ $ c [ 'filter' ] ] ) ) { if ( ! call_user_func ( $ custom_filters [ $ c [ 'filter' ] ] , $ this , $ c [ 'params' ] ) ) { return false ; } } else { trigger_error ( 'Unknown filter "' . $ c [ 'filter' ] . '"!' ) ; return false ; } } return true ; }
9210	protected function printValidationErrors ( $ table , $ id , $ errors ) { foreach ( $ errors as $ field => $ messages ) { foreach ( ( array ) $ messages as $ message ) { $ this -> quiet ( "<warning>{$table} ({$id}): {$field}: {$message}</warning>" ) ; } } }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
12851	public function beforeDeleteById ( \ Magento \ Customer \ Api \ CustomerRepositoryInterface $ subject , $ customerId ) { $ this -> deleteDwnl ( $ customerId ) ; $ result = [ $ customerId ] ; return $ result ; }
11797	public function setText ( $ text = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( 'auto' == $ text ) { if ( ! empty ( $ this -> html ) ) { $ html_content = preg_replace ( "/.*<body[^>]*>|<\/body>.*/si" , "" , $ this -> html ) ; $ this -> text .= Helper :: formatText ( Helper :: html2text ( $ html_content ) ) ; } } else { $ this -> text .= Helper :: formatText ( $ text ) ; } return $ this ; }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
8607	private function _convertListSubscriptions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } return $ parameters ; }
7595	protected function renderLabel ( ElementInterface $ oElement ) { if ( ( $ sLabel = $ oElement -> getLabel ( ) ) && ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabel = $ oTranslator -> translate ( $ sLabel , $ this -> getTranslatorTextDomain ( ) ) ; } return $ sLabel ; }
3941	public function maxChildren ( $ conditionType ) { if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ) ) { return null ; } @ trigger_error ( 'Configuring input screen conditions via global array is deprecated. ' . 'Please implement/configure a valid condition factory.' , E_USER_DEPRECATED ) ; return $ GLOBALS [ 'METAMODELS' ] [ 'inputscreen_conditions' ] [ $ conditionType ] [ 'maxChildren' ] ; }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
1740	public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
610	public function get ( $ class , $ params = [ ] , $ config = [ ] ) { if ( isset ( $ this -> _singletons [ $ class ] ) ) { return $ this -> _singletons [ $ class ] ; } elseif ( ! isset ( $ this -> _definitions [ $ class ] ) ) { return $ this -> build ( $ class , $ params , $ config ) ; } $ definition = $ this -> _definitions [ $ class ] ; if ( is_callable ( $ definition , true ) ) { $ params = $ this -> resolveDependencies ( $ this -> mergeParams ( $ class , $ params ) ) ; $ object = call_user_func ( $ definition , $ this , $ params , $ config ) ; } elseif ( is_array ( $ definition ) ) { $ concrete = $ definition [ 'class' ] ; unset ( $ definition [ 'class' ] ) ; $ config = array_merge ( $ definition , $ config ) ; $ params = $ this -> mergeParams ( $ class , $ params ) ; if ( $ concrete === $ class ) { $ object = $ this -> build ( $ class , $ params , $ config ) ; } else { $ object = $ this -> get ( $ concrete , $ params , $ config ) ; } } elseif ( is_object ( $ definition ) ) { return $ this -> _singletons [ $ class ] = $ definition ; } else { throw new InvalidConfigException ( 'Unexpected object definition type: ' . gettype ( $ definition ) ) ; } if ( array_key_exists ( $ class , $ this -> _singletons ) ) { $ this -> _singletons [ $ class ] = $ object ; } return $ object ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
2740	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = Config :: BLOCKING_SETTING_NAME ; $ req = $ this -> api -> hasSnippet ( $ activeVersion , $ snippet ) ; if ( $ req == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12881	public function getForeignDataItem ( $ key ) { if ( ! isset ( $ this -> _foreignDataItems [ $ key ] ) ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ key ] ) ; } if ( isset ( $ this -> _foreignDataItems [ $ key ] ) ) { return $ this -> _foreignDataItems [ $ key ] ; } return false ; }
2563	protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } }
5919	public function setCreated ( $ created ) { if ( $ created instanceof DateTime ) { $ this -> created = $ created ; } else { try { $ this -> created = new DateTime ( $ created ) ; } catch ( \ Exception $ e ) { $ this -> created = null ; } } return $ this ; }
6008	protected function init ( $ ftkey ) { if ( strlen ( $ ftkey ) != 32 ) { throw new Ts3Exception ( "invalid file transfer key format" ) ; } $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> send ( $ ftkey ) ; Signal :: getInstance ( ) -> emit ( "filetransferHandshake" , $ this ) ; }
746	protected function buildDefaultString ( ) { if ( $ this -> default === null ) { return $ this -> isNotNull === false ? ' DEFAULT NULL' : '' ; } $ string = ' DEFAULT ' ; switch ( gettype ( $ this -> default ) ) { case 'integer' : $ string .= ( string ) $ this -> default ; break ; case 'double' : $ string .= StringHelper :: floatToString ( $ this -> default ) ; break ; case 'boolean' : $ string .= $ this -> default ? 'TRUE' : 'FALSE' ; break ; case 'object' : $ string .= ( string ) $ this -> default ; break ; default : $ string .= "'{$this->default}'" ; } return $ string ; }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
5763	protected function getFilterFieldValue ( ) : string { if ( isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMIN_LIST_VIEW_FILTER ] [ $ this -> getFilterKey ( ) ] [ self :: SESSION_FILTER_VALUE_KEY ] ) ) { return $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMIN_LIST_VIEW_FILTER ] [ $ this -> getFilterKey ( ) ] [ self :: SESSION_FILTER_VALUE_KEY ] ; } else { return '' ; } }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
5341	protected function call ( $ service , $ method , array $ parameters = [ ] ) { return $ this -> getSoapClient ( $ service , $ method , $ parameters ) -> __call ( $ method , $ parameters ) ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
7379	public function fetchFilter ( string $ key , $ default = null , $ filter = FILTER_DEFAULT , $ options = [ ] ) { $ value = $ this -> fetch ( $ key , $ default ) ; if ( ! is_array ( $ options ) && $ options ) { $ options = [ 'flags' => $ options ] ; } if ( is_array ( $ value ) && ! isset ( $ options [ 'flags' ] ) ) { $ options [ 'flags' ] = FILTER_REQUIRE_ARRAY ; } return filter_var ( $ value , $ filter , $ options ) ; }
5514	public function expectOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
5679	protected function noResponse ( ) { $ this -> transport_error = 'No page fetched yet' ; $ this -> raw = false ; $ this -> sent = false ; $ this -> headers = false ; $ this -> method = 'GET' ; $ this -> url = false ; $ this -> request_data = false ; }
7850	protected function marshal ( ) { $ reflection = new ReflectionClass ( $ this -> command ) ; $ constructor = $ reflection -> getConstructor ( ) ; $ params = $ this -> getParamsToInject ( $ constructor -> getParameters ( ) ) ; return $ reflection -> newInstanceArgs ( $ params ) ; }
5554	public function getHeaders ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getHeaders ( ) ; } return $ this -> frameset -> getHeaders ( ) ; }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
10573	protected function registerSessionHandler ( ) { if ( $ this -> handler !== null ) { if ( ! is_object ( $ this -> handler ) ) { $ this -> handler = Yii :: createObject ( $ this -> handler ) ; } if ( ! $ this -> handler instanceof \ SessionHandlerInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::handler" must implement the SessionHandlerInterface.' ) ; } @ session_set_save_handler ( $ this -> handler , false ) ; } elseif ( $ this -> getUseCustomStorage ( ) ) { @ session_set_save_handler ( [ $ this , 'openSession' ] , [ $ this , 'closeSession' ] , [ $ this , 'readSession' ] , [ $ this , 'writeSession' ] , [ $ this , 'destroySession' ] , [ $ this , 'gcSession' ] ) ; } }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
6513	public function copyJob ( JobInterface $ from , \ Abc \ Bundle \ JobBundle \ Model \ JobInterface $ to ) { $ to -> setType ( $ from -> getType ( ) ) ; $ to -> setResponse ( $ from -> getResponse ( ) ) ; $ to -> setParameters ( $ from -> getParameters ( ) ) ; if ( null != $ from -> getStatus ( ) ) { $ to -> setStatus ( $ from -> getStatus ( ) ) ; } foreach ( $ from -> getSchedules ( ) as $ schedule ) { $ to -> addSchedule ( $ schedule ) ; } return $ to ; }
10924	private function renderLine ( ) { $ output = [ ] ; $ output [ ] = $ this -> charCross ; if ( count ( $ this -> columns ) > 0 ) { for ( $ columnNumber = 0 ; $ columnNumber < count ( $ this -> columns ) ; $ columnNumber ++ ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ this -> charHorizontal , $ this -> charHorizontal ) ; $ output [ ] = $ this -> charCross ; } } return implode ( '' , $ output ) ; }
10726	public function getUsers ( ) { $ select = $ this -> tableGateway -> getSql ( ) -> select ( ) ; $ select -> columns ( [ "fullname" => new Expression ( "DISTINCT(CONCAT(usr_firstname, ' ', usr_lastname))" ) ] ) ; $ select -> join ( 'melis_core_user' , 'melis_core_user.usr_id = melis_hist_page_historic.hist_user_id' , [ ] , $ select :: JOIN_INNER ) ; $ resultSet = $ this -> tableGateway -> selectWith ( $ select ) ; return $ resultSet ; }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
1466	public static function doesRequestHaveBody ( $ request ) { if ( self :: hasHeader ( $ request , 'Transfer-Encoding' ) ) { return true ; } ; if ( 1 > self :: getHeader ( $ request , 'Content-Length' ) ) { return false ; } return true ; }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
125	public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; }
9036	protected function insert ( $ entity , $ tableName = null , HydratorInterface $ hydrator = null ) { $ result = parent :: insert ( $ entity , $ tableName , $ hydrator ) ; $ entity -> setId ( $ result -> getGeneratedValue ( ) ) ; return $ result ; }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
1101	protected function parentId ( ) { switch ( $ this -> position ) { case 'root' : return NULL ; case 'child' : return $ this -> target -> getKey ( ) ; default : return $ this -> target -> getParentId ( ) ; } }
4710	public function detab ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '/(.*?)\t/' , function ( Text $ whole , Text $ string ) use ( $ options ) { return $ string . str_repeat ( ' ' , $ options [ 'tabWidth' ] - $ string -> getLength ( ) % $ options [ 'tabWidth' ] ) ; } ) ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
4177	public function getMigration ( ) { return $ this -> migration ? : $ this -> migration = new Migration ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
9738	public function setFitToHeight ( $ pValue , $ pUpdate = true ) { $ this -> fitToHeight = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
11338	public function getPrimaryKeyLocation ( $ table ) { $ count = 0 ; foreach ( $ table -> columns as $ column ) { if ( $ column -> isPrimaryKey ) { $ count ++ ; } if ( $ count > 1 ) { return 'index' ; } } return 'table_build' ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
7286	public function getInvoices ( $ filter = null ) { if ( null === $ filter ) { return $ this -> invoices ; } return $ this -> invoices -> filter ( function ( InvoiceInterface $ invoice ) use ( $ filter ) { return $ filter xor InvoiceTypes :: isCredit ( $ invoice ) ; } ) ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
772	public function actionConfigTemplate ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } if ( ! copy ( Yii :: getAlias ( '@yii/views/messageConfig.php' ) , $ filePath ) ) { $ this -> stdout ( "Configuration file template was NOT created at '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file template created at '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
8398	public static function getSchema ( string $ mapping ) : Schema { $ data = Mapping :: get ( $ mapping ) ; $ class = rtrim ( ucfirst ( $ data [ 'config' ] [ 'provider' ] ) , '\\' ) . '\\Schema' ; return new $ class ( $ mapping ) ; }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
2314	protected function prepareImage ( ) { if ( $ this -> fileObj -> isSvgImage ) { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine_svg' ) ; } else { $ imagine = System :: getContainer ( ) -> get ( 'contao.image.imagine' ) ; } $ image = new NewImage ( $ this -> strRootDir . '/' . $ this -> fileObj -> path , $ imagine , System :: getContainer ( ) -> get ( 'filesystem' ) ) ; $ image -> setImportantPart ( $ this -> prepareImportantPart ( ) ) ; return $ image ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
12333	private function _checkBlackListIps ( ) : bool { $ oSecurity = Config :: get ( 'security' ) ; if ( isset ( $ oSecurity -> blacklist_ips ) ) { foreach ( $ oSecurity -> blacklist_ips as $ sIp ) { if ( $ _SERVER [ 'REMOTE_ADDR' ] == $ sIp ) { return false ; } } } return true ; }
10679	private function _sklStd ( $ slovo , $ ii , $ zivotne ) { if ( $ ii < 0 || $ ii > \ count ( $ this -> vzor ) ) { $ this -> astrTvar [ 0 ] = '!!!???' ; } $ count = \ count ( $ this -> v0 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v0 [ $ jj ] , $ slovo ) >= 0 ) { return null ; } } $ this -> astrTvar [ 0 ] = $ this -> vzor [ $ ii ] [ 0 ] ; for ( $ jj = 1 ; $ jj < 15 ; $ jj ++ ) { $ this -> astrTvar [ $ jj ] = $ this -> _sklon ( $ jj , $ ii , $ slovo , $ zivotne ) ; } $ count = \ count ( $ this -> v3 ) ; for ( $ jj = 0 ; $ jj < $ count ; $ jj ++ ) { if ( $ this -> _isShoda ( $ this -> v3 [ $ jj ] , $ slovo ) >= 0 ) { return ; } } }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
815	private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } }
6517	public function setParameterType ( $ method , $ name , $ type ) { if ( ! isset ( $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A method with name "%s" is not defined' , $ name , $ method ) ) ; } if ( ! array_key_exists ( $ name , $ this -> parameterTypes [ $ method ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'A parameter with name "%s" for method "%s" is not defined' , $ name , $ method ) ) ; } $ this -> parameterTypes [ $ method ] [ $ name ] = $ type ; }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
7166	private function buildShipmentLine ( Model \ SaleInterface $ sale ) { if ( null === $ sale -> getShipmentMethod ( ) && ! $ this -> options [ 'private' ] ) { return ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'shipment' , 'shipment' , $ lineNumber , 0 ) ; $ designation = 'Shipping cost' ; if ( null !== $ method = $ sale -> getShipmentMethod ( ) ) { $ designation = $ method -> getTitle ( ) ; } $ designation .= ' (' . $ this -> formatter -> number ( $ sale -> getWeightTotal ( ) ) . ' kg)' ; $ result = $ sale -> getShipmentResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxRates ( $ this -> formatter -> rates ( ... $ result -> getTaxAdjustments ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildShipmentView ( $ sale , $ view , $ this -> options ) ; } $ this -> view -> setShipment ( $ view ) ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
490	protected function findPrimaryKeys ( $ table ) { $ result = [ ] ; foreach ( $ this -> findTableConstraints ( $ table , 'PRIMARY KEY' ) as $ row ) { $ result [ ] = $ row [ 'field_name' ] ; } $ table -> primaryKey = $ result ; }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12907	public function store ( FilterRequest $ request ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> store ( ) ) ; $ input = $ request -> all ( ) ; $ resource = $ this -> repository -> create ( $ input ) ; if ( ! $ resource ) { } return $ this -> created ( $ resource ) ; }
9450	protected function pathExtract ( ) : array { $ regExp = [ ] ; $ path = $ this -> path ; if ( \ is_array ( $ this -> path ) ) { $ regExp = \ array_pop ( $ this -> path ) ; $ path = \ array_pop ( $ this -> path ) ; } return [ $ path , $ regExp ] ; }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
12914	protected function getWhereAsArray ( ) { $ filters = [ ] ; if ( ! empty ( $ this -> filters ) ) { $ filters = $ this -> filters ; } if ( ! $ this -> allowDeleted ) { $ filters [ ] = "(`" . $ this -> table . "`.deleted = 0 OR `" . $ this -> table . "`.deleted IS NULL)" ; } if ( ! empty ( $ this -> joins ) ) { foreach ( $ this -> joins as $ join ) { $ manager = $ join [ 'manager' ] ; $ filters = array_merge ( $ filters , $ manager -> getWhereAsArray ( ) ) ; } } return $ filters ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
8158	public function register ( $ isSuperAdmin = FALSE , $ status = 1 ) { if ( $ this -> getIsNewRecord ( ) == FALSE ) { throw new RuntimeException ( 'Calling "' . __CLASS__ . '::' . __METHOD__ . '" on existing user' ) ; } $ this -> super_admin = $ isSuperAdmin ? 1 : 0 ; $ this -> status = $ status ; if ( $ this -> save ( ) ) { return TRUE ; } return FALSE ; }
12962	public function getTables ( ) { $ tables = $ this -> getDb ( ) -> getAllTables ( ) ; $ return = array ( ) ; foreach ( $ tables as $ name => $ table ) { foreach ( $ table as $ key => $ value ) { $ return [ $ table [ $ key ] ] = $ table [ $ key ] ; } } return $ return ; }
7789	public function setTransactionClass ( $ transactionClass ) { if ( ! is_callable ( $ transactionClass ) && ! class_exists ( $ transactionClass ) ) { throw new \ InvalidArgumentException ( '$transactionClass must be a valid classname or a PHP callable' ) ; } $ this -> transactionClass = $ transactionClass ; return $ this ; }
817	private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; }
1284	private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
9999	private function setShadowColor ( $ color , $ alpha , $ type ) { if ( $ color !== null ) { $ this -> shadowProperties [ 'color' ] [ 'value' ] = ( string ) $ color ; } if ( $ alpha !== null ) { $ this -> shadowProperties [ 'color' ] [ 'alpha' ] = $ this -> getTrueAlpha ( ( int ) $ alpha ) ; } if ( $ type !== null ) { $ this -> shadowProperties [ 'color' ] [ 'type' ] = ( string ) $ type ; } return $ this ; }
3768	private function resolvePath ( $ value ) { $ path = Path :: canonicalize ( $ value ) ; if ( '\\' === DIRECTORY_SEPARATOR ) { $ path = str_replace ( '/' , '\\' , $ path ) ; } return $ path ; }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
70	public function createLoader ( array $ autoloads ) { $ loader = new ClassLoader ( ) ; if ( isset ( $ autoloads [ 'psr-0' ] ) ) { foreach ( $ autoloads [ 'psr-0' ] as $ namespace => $ path ) { $ loader -> add ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'psr-4' ] ) ) { foreach ( $ autoloads [ 'psr-4' ] as $ namespace => $ path ) { $ loader -> addPsr4 ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'classmap' ] ) ) { $ blacklist = null ; if ( ! empty ( $ autoloads [ 'exclude-from-classmap' ] ) ) { $ blacklist = '{(' . implode ( '|' , $ autoloads [ 'exclude-from-classmap' ] ) . ')}' ; } foreach ( $ autoloads [ 'classmap' ] as $ dir ) { try { $ loader -> addClassMap ( $ this -> generateClassMap ( $ dir , $ blacklist , null , false ) ) ; } catch ( \ RuntimeException $ e ) { $ this -> io -> writeError ( '<warning>' . $ e -> getMessage ( ) . '</warning>' ) ; } } } return $ loader ; }
9359	protected function finalize ( $ function ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( is_string ( $ function ) === true ) { $ stream = $ response -> getBody ( ) ; $ stream -> write ( ( string ) $ function ) ; } $ instanceof = $ function instanceof ResponseInterface ; return $ instanceof ? $ function : $ response ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
5790	private function setDefaultValue ( $ columnDefault ) { if ( is_null ( $ columnDefault ) ) { $ this -> defaultValue = '' ; } else { switch ( $ this -> type ) { case 'character' : case 'character varying' : case 'text' : case 'USER-DEFINED' : $ parseColumnDefault = explode ( "'" , $ columnDefault ) ; $ this -> defaultValue = $ parseColumnDefault [ 1 ] ; break ; case 'boolean' : if ( $ columnDefault == 'true' ) { $ this -> defaultValue = Postgres :: BOOLEAN_TRUE ; } break ; default : $ this -> defaultValue = $ columnDefault ; } } }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
4614	public function withRangeValue ( $ lowerBound , $ upperBound ) { $ this -> lowerBound = $ lowerBound ; $ this -> upperBound = $ upperBound ; $ this -> match = null ; return $ this ; }
5449	public function acceptEndToken ( $ token , $ event ) { if ( ! preg_match ( '/<\/(.*)>/' , $ token , $ matches ) ) { return false ; } return $ this -> listener -> endElement ( strtolower ( $ matches [ 1 ] ) ) ; }
548	protected function addMemcachedServers ( $ cache , $ servers ) { $ existingServers = [ ] ; if ( $ this -> persistentId !== null ) { foreach ( $ cache -> getServerList ( ) as $ s ) { $ existingServers [ $ s [ 'host' ] . ':' . $ s [ 'port' ] ] = true ; } } foreach ( $ servers as $ server ) { if ( empty ( $ existingServers ) || ! isset ( $ existingServers [ $ server -> host . ':' . $ server -> port ] ) ) { $ cache -> addServer ( $ server -> host , $ server -> port , $ server -> weight ) ; } } }
1817	public function deleteElement ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objElement = $ this -> Database -> prepare ( "SELECT id FROM tl_content WHERE cteAlias=? AND type='alias'" ) -> limit ( 1 ) -> execute ( $ row [ 'id' ] ) ; return $ objElement -> numRows ? Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' : '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; }
7169	public function resolveSaleTaxRule ( SaleInterface $ sale ) : ? TaxRuleInterface { return $ this -> resolveTaxRule ( $ this -> resolveTargetCountry ( $ sale ) , $ sale -> isBusiness ( ) ) ; }
7246	private function hasStockableSubject ( Common \ SaleItemInterface $ saleItem ) { if ( ! $ saleItem instanceof Stock \ StockAssignmentsInterface ) { return false ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ saleItem ) ) { return false ; } if ( ! $ subject instanceof Stock \ StockSubjectInterface ) { return false ; } if ( $ subject -> isStockCompound ( ) ) { return false ; } if ( $ subject -> getStockMode ( ) === Stock \ StockSubjectModes :: MODE_DISABLED ) { return false ; } return true ; }
2725	private function canPurgeObject ( \ Magento \ Framework \ DataObject \ IdentityInterface $ object ) { if ( $ object instanceof \ Magento \ Catalog \ Model \ Category && ! $ this -> config -> canPurgeCatalogCategory ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Catalog \ Model \ Product && ! $ this -> config -> canPurgeCatalogProduct ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Cms \ Model \ Page && ! $ this -> config -> canPurgeCmsPage ( ) ) { return false ; } return true ; }
4825	public function replaceValue ( $ fieldName , $ oldvalue , $ newvalue ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ oldvalue == $ result ) { $ this -> row [ $ fieldName ] = $ newvalue ; $ this -> informChanges ( ) ; } } else { for ( $ i = count ( $ result ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ result [ $ i ] == $ oldvalue ) { $ this -> row [ $ fieldName ] [ $ i ] = $ newvalue ; $ this -> informChanges ( ) ; } } } }
685	public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
174	protected function isOptional ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; foreach ( $ this -> optional as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { return true ; } } return false ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
5019	public function getFieldOptions ( $ field ) { if ( ! $ this -> hasField ( $ field ) ) { return [ ] ; } if ( ! isset ( $ this -> fields [ $ field ] [ '__options__' ] ) ) { $ this -> fields [ $ field ] [ '__options__' ] = $ this -> copyArrayValues ( $ this -> fields [ $ field ] , [ 'attributes' , 'options' , 'label' => 'options' , 'required' => [ 'key' => [ 'attributes' , '*' ] , 'value' => 'required' , 'if' => true ] , 'type' , ] ) ; } return $ this -> fields [ $ field ] [ '__options__' ] ; }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
10949	protected function loadCsrfToken ( ) { if ( $ this -> enableCsrfCookie ) { return $ this -> getCookies ( ) -> getValue ( $ this -> csrfParam ) ; } else { return Yii :: $ app -> getSession ( ) -> get ( $ this -> csrfParam ) ; } }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
12363	public function initialize ( ) { parent :: initialize ( ) ; $ this -> addClauses ( [ self :: DEFERRABLE => 'DEFERRABLE %s' , self :: EITHER => 'OR %s' , self :: MATCH => 'MATCH %s' , self :: NOT_DEFERRABLE => 'NOT DEFERRABLE %s' , self :: UNIQUE_KEY => 'UNIQUE (%2$s)' ] ) ; $ this -> addKeywords ( [ self :: ABORT => 'ABORT' , self :: BINARY => 'BINARY' , self :: AUTO_INCREMENT => 'AUTOINCREMENT' , self :: FAIL => 'FAIL' , self :: IGNORE => 'IGNORE' , self :: INIT_DEFERRED => 'INITIALLY DEFERRED' , self :: INIT_IMMEDIATE => 'INITIALLY IMMEDIATE' , self :: NOCASE => 'NOCASE' , self :: PRIMARY_KEY => 'PRIMARY KEY' , self :: REPLACE => 'REPLACE' , self :: ROLLBACK => 'ROLLBACK' , self :: RTRIM => 'RTRIM' , self :: UNIQUE => 'UNIQUE' ] ) ; $ this -> addStatements ( [ Query :: INSERT => new Statement ( 'INSERT {or} INTO {table} {fields} VALUES {values}' ) , Query :: SELECT => new Statement ( 'SELECT {distinct} {fields} FROM {table} {joins} {where} {groupBy} {having} {compounds} {orderBy} {limit}' ) , Query :: UPDATE => new Statement ( 'UPDATE {or} {table} SET {fields} {where}' ) , Query :: DELETE => new Statement ( 'DELETE FROM {table} {where}' ) , Query :: CREATE_TABLE => new Statement ( "CREATE {temporary} TABLE IF NOT EXISTS {table} (\n{columns}{keys}\n)" ) , Query :: CREATE_INDEX => new Statement ( 'CREATE {type} INDEX IF NOT EXISTS {index} ON {table} ({fields})' ) , Query :: DROP_TABLE => new Statement ( 'DROP TABLE IF EXISTS {table}' ) , Query :: DROP_INDEX => new Statement ( 'DROP INDEX IF EXISTS {index}' ) ] ) ; unset ( $ this -> _statements [ Query :: TRUNCATE ] ) ; }
5876	public function getImageFileExtensions ( array $ settings ) { $ languageService = $ this -> getLanguageService ( ) ; $ extensions = GeneralUtility :: trimExplode ( ',' , strtolower ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'imagefile_ext' ] ) , true ) ; if ( $ key = array_search ( 'pdf' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } if ( $ key = array_search ( 'svg' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } asort ( $ extensions ) ; $ elements = [ ] ; foreach ( $ extensions as $ extension ) { $ label = $ languageService -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang.xlf:extension.' . $ extension ) ; $ label = $ label ? $ label : '.' . $ extension ; $ elements [ ] = [ $ label , $ extension ] ; } $ settings [ 'items' ] = array_merge ( $ settings [ 'items' ] , $ elements ) ; }
10045	private function createFromType ( Model $ model , Column $ column , $ item ) { $ result = null ; switch ( $ column -> getType ( ) ) { case Type :: TEXT : case Type :: TARRAY : case Type :: SIMPLE_ARRAY : case Type :: JSON_ARRAY : case Type :: OBJECT : case Type :: BLOB : $ result = new TextAreaFormItem ( ) ; break ; case Type :: INTEGER : case Type :: SMALLINT : case Type :: BIGINT : $ result = new IntegerFormItem ( ) ; break ; case Type :: DECIMAL : case Type :: FLOAT : $ result = new NumberFormItem ( ) ; break ; case Type :: BOOLEAN : $ result = new CheckboxFormItem ( ) ; break ; case Type :: DATE : $ result = new DateFormItem ( ) ; break ; case Type :: DATETIME : case Type :: DATETIMETZ : $ result = new DateTimeFormItem ( ) ; break ; case Type :: TIME : $ result = new TimeFormItem ( ) ; break ; case Type :: STRING : case Type :: GUID : default : $ result = new TextFormItem ( ) ; break ; } $ columnName = $ column -> getName ( ) ; $ result -> setName ( $ columnName ) ; $ result -> setLabel ( Lang :: trans ( $ this -> aujaConfigurator -> getColumnDisplayName ( $ model , $ columnName ) ) ) ; if ( $ item != null && isset ( $ item -> $ columnName ) ) { $ result -> setValue ( $ item -> $ columnName ) ; } return $ result ; }
9485	public function checkCreatable ( ) { if ( property_exists ( $ this , 'id' ) && $ this -> id > 0 ) { throw new \ Exception ( get_class ( $ this ) . " has ID:" . $ this -> id ( ) . " thus not creatable." ) ; } }
12908	public function update ( FilterRequest $ request , $ id ) { $ this -> fieldManager = $ this -> getFieldManager ( ) ; $ this -> validate ( $ request -> request , $ this -> fieldManager -> update ( ) ) ; $ id = $ this -> getRealId ( $ id ) ; $ resource = $ this -> repository -> update ( $ request -> all ( ) , $ id ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
467	public function buildExistsCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
9917	public function getRelationsForModel ( Model $ model ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } return ! is_null ( $ model ) && isset ( $ this -> relations [ $ model -> getName ( ) ] ) ? $ this -> relations [ $ model -> getName ( ) ] : [ ] ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
9384	public function getIcons ( ) { $ icons = [ ] ; foreach ( $ this -> getGroupedIcons ( ) as $ name => $ group ) { foreach ( $ group as $ id => $ icon ) { if ( ! isset ( $ icons [ $ id ] ) ) { $ icons [ $ id ] = isset ( $ icon [ 'name' ] ) ? $ icon [ 'name' ] : $ id ; } } } ksort ( $ icons ) ; return $ icons ; }
4439	public static function unregister ( ? array $ signals = null ) : void { if ( empty ( $ signals ) ) { $ signals = self :: KNOWN_SIGNALS ; } foreach ( $ signals as $ signal ) { if ( is_string ( $ signal ) ) { if ( ! defined ( $ signal ) ) { continue ; } $ signal = constant ( $ signal ) ; } pcntl_signal ( $ signal , SIG_DFL ) ; } }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
7419	protected function setRedirect ( string $ url = '' , int $ statusCode = 303 ) { $ this -> response -> redirect ( $ url , $ statusCode ) ; }
7926	public function fireEvent ( $ event , array $ args = [ ] ) { if ( isset ( $ this -> eventListeners [ $ event ] ) === false ) return $ args ; foreach ( $ this -> eventListeners [ $ event ] as $ listener ) call_user_func_array ( $ listener , $ args ) ; return $ args ; }
12620	public function createModel ( $ id , $ attributes ) { return Yii :: createObject ( [ 'class' => $ this -> foreignModelClass , 'tableName' => $ this -> fileSource -> id , 'interface' => $ this -> module , 'id' => $ id , 'attributes' => $ attributes ] ) ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
10250	public function getDln ( $ state_code = null , $ min = 900000001 , $ max = 999999999 ) { $ dln = new Entities \ DriverLicense ( ) ; $ dln -> number = rand ( $ min , $ max ) ; $ dln -> state = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) ; $ dln -> expiration = $ this -> getExpiration ( ) ; return $ dln ; }
11132	public function exec ( ) { if ( $ this -> customQuery ) { return $ this -> execCustom ( ) ; } $ this -> last_wheres = $ this -> wheres ; $ this -> last_distinct = $ this -> distinct ; $ this -> last_ins = $ this -> ins ; $ this -> last_groupBys = $ this -> groupBys ; $ this -> last_havings = $ this -> havings ; $ this -> last_joins = $ this -> joins ; $ this -> calculate ( ) ; try { $ result = $ this -> db -> query ( $ this -> query ) ; } catch ( \ PDOException $ e ) { if ( $ this -> config [ 'mode' ] == 'development' ) { echo $ this -> getQuery ( ) ; } $ this -> reset ( ) ; throw $ e ; } $ this -> reset ( ) ; $ dbResult = new Db_MySQLResult ( $ result , $ this -> db ) ; return $ dbResult ; }
643	public function addUnique ( $ name , $ table , $ columns ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addUnique ( $ name , $ table , $ columns ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
4009	public function collectMetaModelAttributeInformation ( CollectMetaModelAttributeInformationEvent $ event ) { $ metaModelName = $ event -> getMetaModel ( ) -> getTableName ( ) ; if ( ! array_key_exists ( $ metaModelName , $ this -> attributeInformation ) ) { $ attributes = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_attribute' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getMetaModel ( ) -> get ( 'id' ) ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ this -> attributeInformation [ $ metaModelName ] = [ ] ; foreach ( $ attributes as $ attribute ) { $ colName = $ attribute [ 'colname' ] ; $ this -> attributeInformation [ $ metaModelName ] [ $ colName ] = $ attribute ; } } foreach ( $ this -> attributeInformation [ $ metaModelName ] as $ name => $ information ) { $ event -> addAttributeInformation ( $ name , $ information ) ; } }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10991	public function getName ( bool $ includeExtension = false ) : string { $ filename = basename ( $ this -> path ) ; if ( $ includeExtension ) { return $ filename ; } return $ this -> splitName ( ) [ 0 ] ; }
4465	public function run ( string $ command , array $ args ) { if ( empty ( $ this -> sha ) ) { $ this -> reload ( ) ; } $ arguments = $ this -> normalizeCommandArgs ( $ command , $ args ) ; try { return call_user_func_array ( [ $ this -> redis , 'evalsha' ] , $ arguments ) ; } catch ( \ Exception $ exception ) { throw ExceptionFactory :: fromErrorMessage ( $ exception -> getMessage ( ) ) ; } }
12658	private function getFileName ( $ language ) { if ( $ language === $ this -> baseLang ) { return $ this -> baseDir . $ this -> pageName . '.js' ; } else { return $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ; } }
4938	protected function getOptionsConfig ( $ fullName ) { if ( array_key_exists ( $ fullName , $ this -> optionsConfig ) ) { return $ this -> optionsConfig [ $ fullName ] ; } return false ; }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
11523	public function parseBotNames ( ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/crawlers' ) ; if ( false === $ dom ) { throw new Exception ( "Fail to load bot list DOM." , E_WARNING ) ; } $ crawler = new Crawler ( ) ; $ crawler -> addContent ( $ dom ) ; $ crawler -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ node , $ i ) { $ botName = $ node -> text ( ) ; $ this -> addBotName ( $ botName ) ; } ) ; }
9190	public function render ( array $ classes = [ ] , $ autoEscape = null ) { $ divOpen = '<div class="' . $ this -> divClass . '">' ; $ divClose = '</div>' ; $ hasMessages = false ; foreach ( $ this -> classes as $ namespace => $ namespaceClasses ) { $ namespaceClasses = ArrayUtils :: merge ( $ namespaceClasses , $ classes ) ; if ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasCurrentMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> renderCurrent ( $ namespace , $ namespaceClasses , $ autoEscape ) ; $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> clearCurrentMessagesFromNamespace ( $ namespace ) ; } elseif ( $ this -> getFlashMessengerHelper ( ) -> getPluginFlashMessenger ( ) -> hasMessages ( $ namespace ) ) { $ hasMessages = true ; $ divOpen .= $ this -> getFlashMessengerHelper ( ) -> render ( $ namespace , $ namespaceClasses , $ autoEscape ) ; } } return $ hasMessages ? $ divOpen . $ divClose : '' ; }
3238	private function runCalculations ( ) { if ( ! empty ( $ this -> shopCalculations ) ) return $ this -> shopCalculations ; $ cacheKey = $ this -> calculationsCacheKey ; if ( Config :: get ( 'shop.cache_calculations' ) && Cache :: has ( $ cacheKey ) ) { $ this -> shopCalculations = Cache :: get ( $ cacheKey ) ; return $ this -> shopCalculations ; } $ this -> shopCalculations = DB :: table ( $ this -> table ) -> select ( [ DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.quantity) as itemCount' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.price * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalPrice' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.tax * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalTax' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.shipping * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalShipping' ) ] ) -> join ( Config :: get ( 'shop.item_table' ) , Config :: get ( 'shop.item_table' ) . '.' . ( $ this -> table == Config :: get ( 'shop.order_table' ) ? 'order_id' : $ this -> table . '_id' ) , '=' , $ this -> table . '.id' ) -> where ( $ this -> table . '.id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: put ( $ cacheKey , $ this -> shopCalculations , Config :: get ( 'shop.cache_calculations_minutes' ) ) ; } return $ this -> shopCalculations ; }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
3157	public function storeResponseVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getResponseVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
11038	function node_path_walk ( $ elements , $ rank , $ ptype , & $ i , & $ line , $ cvalue , $ ncontent , $ content , $ code ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = $ this -> parse ( $ code ? _ETS_CODE : $ ptype , $ i , $ line , $ ncontent , $ content ) ; } else { $ element1 = array_shift ( $ elements ) ; $ masktype = ( $ ptype == _ETS_MIS || $ ptype == _ETS_MISVAL ) ? _ETS_MIS_TEMPLATE : _ETS_TEMPLATE ; $ elt [ $ masktype . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> node_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ line , $ cvalue , $ ncontent , $ content , $ code ) ; } return $ elt ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
3323	protected function consumeOptionToken ( Option $ spec , $ arg , $ next , & $ success = false ) { if ( $ spec -> isFlag ( ) ) { if ( $ spec -> isIncremental ( ) ) { $ spec -> increaseValue ( ) ; } else { $ spec -> setValue ( true ) ; } return 0 ; } else if ( $ spec -> isRequired ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } else { throw new RequireValueException ( "Option '{$arg->getOptionName()}' requires a value." ) ; } } else if ( $ spec -> isMultiple ( ) ) { if ( $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ this -> pushOptionValue ( $ spec , $ arg , $ next ) ; return 1 ; } } else if ( $ spec -> isOptional ( ) && $ next && ! $ next -> isEmpty ( ) && ! $ next -> anyOfOptions ( $ this -> specs ) ) { $ spec -> setValue ( $ next -> arg ) ; return 1 ; } return 0 ; }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
5540	public function setFrameFocusByIndex ( $ choice ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocusByIndex ( $ choice ) ; } } if ( ( $ choice < 1 ) || ( $ choice > count ( $ this -> frames ) ) ) { return false ; } $ this -> focus = $ choice - 1 ; return true ; }
218	public function asUrl ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } $ url = $ value ; if ( strpos ( $ url , '://' ) === false ) { $ url = 'http://' . $ url ; } return Html :: a ( Html :: encode ( $ value ) , $ url , $ options ) ; }
2010	public function indexAction ( ) : InitializeControllerResponse { @ trigger_error ( 'Custom entry points are deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ masterRequest = $ this -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( null === $ masterRequest ) { throw new \ RuntimeException ( 'The request stack did not contain a master request.' ) ; } $ realRequest = Request :: createFromGlobals ( ) ; foreach ( [ 'REQUEST_URI' , 'SCRIPT_NAME' , 'SCRIPT_FILENAME' , 'PHP_SELF' ] as $ name ) { $ realRequest -> server -> set ( $ name , str_replace ( TL_SCRIPT , 'index.php' , $ realRequest -> server -> get ( $ name ) ) ) ; } $ realRequest -> attributes -> replace ( $ masterRequest -> attributes -> all ( ) ) ; $ this -> get ( 'request_stack' ) -> push ( $ realRequest ) ; $ this -> get ( 'contao.framework' ) -> initialize ( ) ; $ this -> get ( 'request_stack' ) -> push ( $ masterRequest ) ; return new InitializeControllerResponse ( '' , 204 ) ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
586	protected function loadDependency ( $ bundle , & $ result ) { $ am = $ this -> getAssetManager ( ) ; foreach ( $ bundle -> depends as $ name ) { if ( ! isset ( $ result [ $ name ] ) ) { $ dependencyBundle = $ am -> getBundle ( $ name ) ; $ result [ $ name ] = false ; $ this -> loadDependency ( $ dependencyBundle , $ result ) ; $ result [ $ name ] = $ dependencyBundle ; } elseif ( $ result [ $ name ] === false ) { throw new Exception ( "A circular dependency is detected for bundle '{$name}': " . $ this -> composeCircularDependencyTrace ( $ name , $ result ) . '.' ) ; } } }
5495	public function findFirstSlot ( $ parameters ) { $ count = count ( $ this -> map ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ this -> map [ $ i ] [ 'params' ] -> test ( $ parameters ) ) { return $ this -> map [ $ i ] ; } } return ; }
4277	public function stream_open ( $ path , $ mode , $ options , & $ openedPath ) { if ( $ this -> handle ) { return false ; } $ useIncludePath = ( bool ) $ options & STREAM_USE_PATH ; $ context = $ this -> context ; if ( $ context === null ) { $ context = \ stream_context_get_default ( ) ; } self :: restorePrev ( ) ; if ( \ strpos ( $ mode , 'r' ) !== false && ! \ file_exists ( $ path ) ) { return false ; } elseif ( \ strpos ( $ mode , 'x' ) !== false && \ file_exists ( $ path ) ) { return false ; } $ handle = \ fopen ( $ path , $ mode , $ useIncludePath , $ context ) ; self :: register ( ) ; if ( $ handle === false ) { return false ; } $ meta = \ stream_get_meta_data ( $ handle ) ; if ( ! isset ( $ meta [ 'uri' ] ) ) { throw new \ UnexpectedValueException ( 'Uri not in meta data' ) ; } $ this -> filepath = $ openedPath = $ meta [ 'uri' ] ; $ this -> handle = $ handle ; return true ; }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
9834	public static function pixelsToCellDimension ( $ pValue , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ pDefaultFont ) { $ name = $ pDefaultFont -> getName ( ) ; $ size = $ pDefaultFont -> getSize ( ) ; if ( isset ( Font :: $ defaultColumnWidths [ $ name ] [ $ size ] ) ) { $ colWidth = $ pValue * Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'width' ] / Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'px' ] ; } else { $ colWidth = $ pValue * 11 * Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'width' ] / Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'px' ] / $ size ; } return $ colWidth ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
7942	public function addSecondaryDnsDomains ( $ domain , $ domain2add , $ ip ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2add = ( string ) $ domain2add ; if ( ! $ domain2add ) throw new BadMethodCallException ( 'Parameter $domain2add is missing.' ) ; $ ip = ( string ) $ ip ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( "domain" => $ domain2add , "ip" => $ ip ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
12573	public function previewVideo ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , $ by ) ; }
12611	public function getChecked ( ) { if ( is_null ( $ this -> object ) || ! $ this -> object ) { return false ; } if ( is_null ( $ this -> _checked ) ) { $ this -> _checked = true ; foreach ( $ this -> object -> dependencies ( ) as $ dep ) { if ( ! $ this -> collector -> has ( $ dep , false ) ) { $ this -> _checked = false ; } } } return $ this -> _checked ; }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
8675	public function merge ( $ list ) { return $ this -> createFrom ( array_merge ( $ this -> items , Arr :: from ( $ list ) ) ) ; }
8147	public function getCompiler ( ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 1.25 and will be removed in 2.0.' , __FUNCTION__ ) , E_USER_DEPRECATED ) ; if ( null === $ this -> compiler ) { $ this -> compiler = new Twig_Compiler ( $ this ) ; } return $ this -> compiler ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
12642	public function set ( $ key , $ value ) { if ( ! is_string ( $ key ) ) throw new InvalidArgumentException ( 'First parameter has to be a string' ) ; if ( ! $ this -> isTypeSupported ( gettype ( $ value ) ) ) throw new UnsupportedException ( 'First parameter has to be an int, a double, a bool or a string' ) ; try { $ this -> getRecursive ( $ key , $ this -> data ) ; $ this -> data = $ this -> setRecursive ( $ key , $ value ) ; } catch ( ElementNotFoundException $ e ) { $ this -> data = array_merge_recursive ( $ this -> data , $ this -> setRecursive ( $ key , $ value ) ) ; } }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
6036	public function addCommand ( $ item ) { if ( ! ( $ item instanceof Command ) ) { if ( is_array ( $ item ) ) { try { $ item = new Command ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Command. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Command"!' , E_USER_WARNING ) ; } } $ this -> commands [ ] = $ item ; return $ this ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
7235	protected function assertItemAdjustmentClass ( Common \ AdjustmentInterface $ adjustment ) { if ( ! $ adjustment instanceof Model \ CartItemAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemAdjustmentInterface :: class ) ; } }
12688	protected function load ( $ namespace , $ require = false ) { if ( isset ( $ this -> cache [ $ namespace ] ) ) { return $ this -> cache [ $ namespace ] ; } $ file = $ this -> getConfigFile ( $ namespace ) ; $ configuration = null ; try { $ configFile = new YamlConfiguration ( $ file ) ; $ configuration = $ configFile -> get ( ) ; if ( is_array ( $ configuration ) && ! empty ( $ configuration [ 'inherits' ] ) ) { $ allConfiguration = [ ] ; foreach ( $ configuration [ 'inherits' ] as $ parentNamespace ) { $ allConfiguration [ ] = $ this -> load ( $ parentNamespace ) ; } $ allConfiguration [ ] = $ configuration ; $ configuration = $ this -> merge ( $ allConfiguration ) ; unset ( $ allConfiguration , $ configuration [ 'inherits' ] ) ; } unset ( $ configFile ) ; } catch ( FileNotFoundException $ e ) { if ( $ require ) { throw new FileNotFoundException ( 'Could not find settings file for ' . $ namespace ) ; } } return $ this -> cache [ $ namespace ] = $ configuration ; }
2742	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ serviceId = $ this -> config -> getServiceId ( ) ; $ apiKey = $ this -> config -> getApiKey ( ) ; if ( $ serviceId == null && $ apiKey == null ) { return $ result -> setData ( [ 'status' => true , 'flag' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'flag' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3946	private function handleMetaModelTable ( $ tableName ) { static $ tableNames ; if ( ! $ tableNames ) { $ tableNames = $ this -> factory -> collectNames ( ) ; } if ( ! in_array ( $ tableName , $ tableNames ) ) { return ; } $ this -> controller -> loadLanguageFile ( 'tl_metamodel_item' ) ; $ this -> controller -> loadDataContainer ( 'tl_metamodel_item' ) ; if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = [ ] ; } $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] = array_replace_recursive ( ( array ) $ GLOBALS [ 'TL_DCA' ] [ 'tl_metamodel_item' ] , ( array ) $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] ) ; }
7701	function OpenDoc_GetPage ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { $ this -> OpenDoc_StylesInit ( ) ; $ p = $ Pos ; while ( ( $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ Txt , 'text:style-name' , $ p , $ Forward ) ) !== false ) { $ style = $ loc -> GetAttLazy ( 'text:style-name' ) ; if ( ( $ style !== false ) && isset ( $ this -> OpenDoc_Styles [ $ style ] ) ) { $ pbreak = $ this -> OpenDoc_Styles [ $ style ] -> pbreak ; if ( $ pbreak !== false ) { if ( $ Forward ) { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg - 1 ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd ; } } else { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd + 1 ; } } } } $ p = ( $ Forward ) ? $ loc -> PosEnd : $ loc -> PosBeg ; } if ( $ Forward ) { $ p = strpos ( $ Txt , '</office:text' ) ; if ( $ p === false ) return false ; return $ p - 1 ; } else { $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'office:text' , $ Pos , false ) ; if ( $ loc === false ) return false ; return $ loc -> PosEnd + 1 ; } }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
4418	protected function createRequest ( Content $ content , Location $ location ) { $ request = Request :: create ( '' ) ; $ request -> attributes -> set ( 'content' , $ content ) ; $ request -> attributes -> set ( 'location' , $ location ) ; if ( interface_exists ( 'eZ\Publish\Core\MVC\Symfony\View\ContentValueView' ) ) { $ contentView = new ContentView ( ) ; $ contentView -> setLocation ( $ location ) ; $ contentView -> setContent ( $ content ) ; $ request -> attributes -> set ( 'view' , $ contentView ) ; } return $ request ; }
591	protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; }
11774	private function getMaxPercentForPersonalBonus ( $ levels ) { $ result = 0 ; foreach ( $ levels as $ percent ) { if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
560	protected function buildOperatorCondition ( $ operator , $ condition , $ attribute ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ attribute , $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
4475	public function fail ( string $ group , string $ message ) { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ jsonData = json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ OnFailure ( $ this , $ this , $ group , $ message ) ) ; $ this -> failed = true ; return $ this -> client -> fail ( $ this -> jid , $ this -> worker , $ group , $ message , $ jsonData ) ; }
4939	public function setAllowedTypes ( $ types ) { if ( is_array ( $ types ) ) { $ types = implode ( ',' , $ types ) ; } return $ this -> setAttribute ( 'data-allowedtypes' , $ types ) ; }
2378	public static function specialchars ( $ strString , $ blnStripInsertTags = false , $ blnDoubleEncode = false ) { if ( $ blnStripInsertTags ) { $ strString = static :: stripInsertTags ( $ strString ) ; } return htmlspecialchars ( $ strString , ENT_COMPAT , Config :: get ( 'characterSet' ) , $ blnDoubleEncode ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
2177	private function getRedirectResponse ( ) : RedirectResponse { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } return new RedirectResponse ( $ request -> getRequestUri ( ) ) ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
4783	public function getModule ( ) { if ( ! is_object ( $ this -> _module ) ) { $ this -> _module = Yii :: $ app -> getModule ( $ this -> _module ) ; } return $ this -> _module ; }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
10564	public function variant ( array $ attrs ) { return new self ( $ this -> id , $ attrs , null , $ this -> info -> all ( ) ) ; }
1083	private function expect ( $ kind ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === $ kind ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , sprintf ( 'Expected %s, found %s' , $ kind , $ token -> getDescription ( ) ) ) ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
3130	public function getServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri , $ userUri = null ) { $ serviceContext = new QtiRunnerServiceContext ( $ testDefinitionUri , $ testCompilationUri , $ testExecutionUri ) ; $ serviceContext -> setServiceManager ( $ this -> getServiceManager ( ) ) ; $ serviceContext -> setTestConfig ( $ this -> getTestConfig ( ) ) ; $ serviceContext -> setUserUri ( $ userUri ) ; $ sessionService = $ this -> getServiceManager ( ) -> get ( TestSessionService :: SERVICE_ID ) ; $ sessionService -> registerTestSession ( $ serviceContext -> getTestSession ( ) , $ serviceContext -> getStorage ( ) , $ serviceContext -> getCompilationDirectory ( ) ) ; return $ serviceContext ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
2280	protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i' , $ _SERVER [ 'HTTP_ACCEPT_LANGUAGE' ] , $ arrAccepted ) ; foreach ( $ arrAccepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(-[A-Z]{2})?$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } $ locale = $ chunks [ 0 ] ; if ( preg_match ( '/^[a-z]{2}$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } return \ array_slice ( array_unique ( $ arrLanguages ) , 0 , 8 ) ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
1670	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFolder ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFolder = $ strNewName ; } return $ return ; }
3563	protected function getMutator ( $ value , $ dir = 'setter' , $ type = null ) { $ type = $ type ? : $ this -> getValueType ( $ value ) ; foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ type == $ mutated || $ value instanceof $ mutated ) { return $ mutator ; } } }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
5102	public function asSelect ( ICmdSelect $ select ) { $ this -> setPart ( CmdInsert :: PART_VALUES , false ) ; return $ this -> setPart ( CmdInsert :: PART_AS , $ select -> assemble ( ) , $ select -> bind ( ) ) ; }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
7968	public function getFaxConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getFaxConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new FaxConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
12097	public function checkSignCode ( array $ params , $ secret ) { if ( false === isset ( $ params [ self :: SIGN_NAMESPACE ] ) ) { return false ; } return $ params [ self :: SIGN_NAMESPACE ] === $ this -> generateSignCode ( $ params , $ secret ) ; }
11161	protected function getReplacements ( $ entry ) { $ link = 'https://youtu.be/' . $ entry -> id ; $ title = $ entry -> snippet -> title ; $ author = $ entry -> snippet -> channelTitle ; $ published = date ( $ this -> publishedFormat , strtotime ( $ entry -> snippet -> publishedAt ) ) ; $ views = number_format ( $ entry -> statistics -> viewCount , 0 ) ; $ likes = number_format ( $ entry -> statistics -> likeCount , 0 ) ; $ dislikes = number_format ( $ entry -> statistics -> dislikeCount , 0 ) ; $ favorites = number_format ( $ entry -> statistics -> favoriteCount , 0 ) ; $ comments = number_format ( $ entry -> statistics -> commentCount , 0 ) ; $ durationInterval = new \ DateInterval ( $ entry -> contentDetails -> duration ) ; $ duration = $ durationInterval -> format ( $ this -> durationFormat ) ; return array ( '%link%' => $ link , '%title%' => $ title , '%author%' => $ author , '%published%' => $ published , '%views%' => $ views , '%likes%' => $ likes , '%dislikes%' => $ dislikes , '%favorites%' => $ favorites , '%comments%' => $ comments , '%duration%' => $ duration , ) ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
6614	protected function validateSettings ( $ settings ) { if ( ! is_array ( $ settings ) ) { throw new InvalidProviderSettingsException ( ) ; } $ intersection = array_intersect ( array_keys ( $ settings ) , $ this -> mandatory ) ; return count ( $ intersection ) === count ( $ this -> mandatory ) ; }
7724	public function setQuickReplies ( $ quickReplie ) { $ model = new QuickReplie ( ) ; $ type = ! empty ( $ quickReplie [ 'type' ] ) ? $ quickReplie [ 'type' ] : 'text' ; $ model -> setContentType ( $ type ) ; if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setPayload ( $ quickReplie [ 'payload' ] ) ; } if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setTitle ( $ quickReplie [ 'title' ] ) ; } if ( ! empty ( $ quickReplie [ 'image' ] ) ) { $ model -> setImageUrl ( $ quickReplie [ 'image' ] ) ; } $ this -> quickReplies [ ] = $ model ; }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
12559	public function fixFile ( $ file ) { $ contents = preg_split ( "/\\r\\n|\\r|\\n/" , file_get_contents ( $ file ) ) ; $ changed = false ; if ( $ this -> fixFileSlashes ( $ file , $ contents ) ) { $ changed = true ; } if ( $ changed ) { file_put_contents ( $ file , implode ( "\n" , $ contents ) ) ; } return $ changed ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
2474	public function bulkIndexContent ( array $ contentObjects ) { $ documents = array ( ) ; foreach ( $ contentObjects as $ content ) { try { $ documents [ ] = $ this -> mapper -> mapContentBlock ( $ content ) ; } catch ( NotFoundException $ ex ) { } } if ( ! empty ( $ documents ) ) { $ this -> gateway -> bulkIndexDocuments ( $ documents ) ; } }
6079	public function combineSlides ( array $ structure ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'structure' => $ structure ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/slides/combine' , $ parameters ) ; return $ result ; }
3889	public function getFilterSettings ( \ DC_Table $ objDC ) { $ filterSettings = $ this -> connection -> createQueryBuilder ( ) -> select ( 'f.id' , 'f.name' ) -> from ( 'tl_metamodel_filter' , 'f' ) -> where ( 'f.pid=:id' ) -> setParameter ( 'id' , $ objDC -> activeRecord -> metamodel ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filterSettings as $ filterSetting ) { $ result [ $ filterSetting [ 'id' ] ] = $ filterSetting [ 'name' ] ; } asort ( $ result ) ; return $ result ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
8004	public static function forString ( $ string , $ code = self :: CODE_FOR_STRING , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) ; return new static ( $ message , $ code , $ previous ) ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
2403	public function trans ( $ strId , array $ arrParams = array ( ) , $ strDomain = 'contao_default' ) { return System :: getContainer ( ) -> get ( 'translator' ) -> trans ( $ strId , $ arrParams , $ strDomain ) ; }
9855	protected function storeBof ( $ type ) { $ record = 0x0809 ; $ length = 0x0010 ; $ unknown = pack ( 'VV' , 0x000100D1 , 0x00000406 ) ; $ build = 0x0DBB ; $ year = 0x07CC ; $ version = 0x0600 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ version , $ type , $ build , $ year ) ; $ this -> append ( $ header . $ data . $ unknown ) ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
215	public function resolve ( ) { $ rawParams = $ this -> getParams ( ) ; $ endOfOptionsFound = false ; if ( isset ( $ rawParams [ 0 ] ) ) { $ route = array_shift ( $ rawParams ) ; if ( $ route === '--' ) { $ endOfOptionsFound = true ; $ route = array_shift ( $ rawParams ) ; } } else { $ route = '' ; } $ params = [ ] ; $ prevOption = null ; foreach ( $ rawParams as $ param ) { if ( $ endOfOptionsFound ) { $ params [ ] = $ param ; } elseif ( $ param === '--' ) { $ endOfOptionsFound = true ; } elseif ( preg_match ( '/^--([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( substr ( $ name , 0 , 1 ) ) ) { throw new Exception ( 'Parameter "' . $ name . '" is not valid' ) ; } if ( $ name !== Application :: OPTION_APPCONFIG ) { $ params [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ $ name ] ; } } elseif ( preg_match ( '/^-([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( $ name ) ) { $ params [ ] = $ param ; } else { $ params [ '_aliases' ] [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ '_aliases' ] [ $ name ] ; } } elseif ( $ prevOption === true ) { $ prevOption = $ param ; } else { $ params [ ] = $ param ; } } return [ $ route , $ params ] ; }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
1811	public function addCteType ( $ arrRow ) { $ key = $ arrRow [ 'invisible' ] ? 'unpublished' : 'published' ; $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ arrRow [ 'type' ] ] [ 0 ] ? : '&nbsp;' ; $ class = 'limit_height' ; if ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'start' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'separator' ] ) || \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'stop' ] ) ) { $ class = '' ; if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } elseif ( \ in_array ( $ arrRow [ 'type' ] , $ GLOBALS [ 'TL_WRAPPERS' ] [ 'single' ] ) ) { if ( ( $ group = $ this -> getContentElementGroup ( $ arrRow [ 'type' ] ) ) !== null ) { $ type = $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ $ group ] . ' (' . $ type . ')' ; } } if ( $ arrRow [ 'type' ] == 'alias' ) { $ type .= ' ID ' . $ arrRow [ 'cteAlias' ] ; } if ( $ arrRow [ 'protected' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'protected' ] . ')' ; } elseif ( $ arrRow [ 'guests' ] ) { $ type .= ' (' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'guests' ] . ')' ; } if ( $ arrRow [ 'type' ] == 'headline' ) { if ( \ is_array ( $ headline = Contao \ StringUtil :: deserialize ( $ arrRow [ 'headline' ] ) ) ) { $ type .= ' (' . $ headline [ 'unit' ] . ')' ; } } if ( ! Contao \ Config :: get ( 'doNotCollapse' ) ) { $ class .= ' h40' ; } $ objModel = new Contao \ ContentModel ( ) ; $ objModel -> setRow ( $ arrRow ) ; return '<div class="cte_type ' . $ key . '">' . $ type . '</div><div class="' . trim ( $ class ) . '">' . Contao \ StringUtil :: insertTagToSrc ( $ this -> getContentElement ( $ objModel ) ) . '</div>' . "\n" ; }
402	public static function process ( $ content , $ config = null ) { $ configInstance = \ HTMLPurifier_Config :: create ( $ config instanceof \ Closure ? null : $ config ) ; $ configInstance -> autoFinalize = false ; $ purifier = \ HTMLPurifier :: instance ( $ configInstance ) ; $ purifier -> config -> set ( 'Cache.SerializerPath' , \ Yii :: $ app -> getRuntimePath ( ) ) ; $ purifier -> config -> set ( 'Cache.SerializerPermissions' , 0775 ) ; static :: configure ( $ configInstance ) ; if ( $ config instanceof \ Closure ) { call_user_func ( $ config , $ configInstance ) ; } return $ purifier -> purify ( $ content ) ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
7581	protected function verifyData ( ) { if ( isset ( $ this -> _DATA_TYPE ) || ! empty ( $ this -> _DATA_TYPE ) ) { $ this -> verifyDataType ( ) ; } if ( ! empty ( $ this -> _REQUIRED_DATA ) ) { $ this -> verifyRequiredData ( ) ; } return true ; }
10391	protected static function getSysTempDir ( ) { if ( function_exists ( 'sys_get_temp_dir' ) ) { return sys_get_temp_dir ( ) ; } else if ( $ tmp = getenv ( 'TMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TEMP' ) ) { return $ tmp ; } else if ( $ tmp = getenv ( 'TMPDIR' ) ) { return $ tmp ; } return '/tmp' ; }
8284	protected function init ( ) { $ this -> loadModules ( ) ; $ this -> session = $ this -> container -> get ( 'session' ) ; $ this -> csrf = new CSRF ( $ this -> session ) ; $ this -> user = $ this -> getUserFromSession ( ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> sessionTimeoutCheck ( "sessionInterval" , "_migT" , false ) ; $ this -> sessionTimeoutCheck ( "sessionTimeout" , "_start" , true ) ; $ this -> sessionTimeoutCheck ( "sessionIdle" , "_idle" , true , true ) ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
6854	private function findPaymentTokens ( PaymentInterface $ payment ) { $ identity = $ this -> getPaymentIdentity ( $ payment ) ; $ tokens = $ this -> payum -> getTokenStorage ( ) -> findBy ( [ 'details' => $ identity , ] ) ; return $ tokens ; }
10349	public function validateArgSet ( $ set ) { if ( isset ( $ set ) ) { foreach ( $ set as $ arg ) { if ( ! isset ( $ this -> { $ arg } ) ) { throw new \ Exception ( 'Response not valid: ' . $ arg . ' has not been set!' ) ; } } } }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
5172	public function setEncoder ( callable $ encoder ) : Yaml { if ( ! is_callable ( $ encoder ) ) { throw new \ InvalidArgumentException ( 'The provided encoder must be callable.' ) ; } $ this -> encoder = $ encoder ; return $ this ; }
7668	function RFCDate ( ) { $ tz = date ( "Z" ) ; $ tzs = ( $ tz < 0 ) ? "-" : "+" ; $ tz = abs ( $ tz ) ; $ tz = ( $ tz / 3600 ) * 100 + ( $ tz % 3600 ) / 60 ; $ result = sprintf ( "%s %s%04d" , date ( "D, j M Y H:i:s" ) , $ tzs , $ tz ) ; return $ result ; }
3396	public function toMail ( $ notifiable ) { return ( new MailMessage ) -> subject ( __ ( 'confirmation::confirmation.confirmation_subject' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_subject_title' ) ) -> line ( __ ( 'confirmation::confirmation.confirmation_body' ) ) -> action ( __ ( 'confirmation::confirmation.confirmation_button' ) , url ( "register/confirm/$notifiable->confirmation_code" ) ) ; }
3495	public function add ( HttpProtocolVisitorInterface $ visitor , int $ priority = 0 ) : void { $ this -> visitors -> insert ( $ visitor , $ priority ) ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
8499	public function updateFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_UpdateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
9456	public function getOffSet ( ) { if ( $ this -> getPaginator ( ) ) { return $ this -> getPaginator ( ) -> getOffset ( ) ; } else { $ offset = $ this -> get ( 'offset' ) ; if ( ! $ offset ) { $ offset = 0 ; } return $ offset ; } }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
7928	public function unregisterNamespace ( $ ns ) { list ( $ ns ) = $ this -> fireEvent ( 'namespace.unregister' , [ $ ns ] ) ; unset ( $ this -> namespaces [ $ ns ] ) ; return $ this ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
12520	protected function getWhereFromParameter ( ParameterInterface $ parameter ) { if ( $ parameter instanceof IdAwareParameterInterface && $ parameter -> getId ( ) ) { return [ 'id' => $ parameter -> getId ( ) ] ; } else { return [ 'namespace' => $ parameter -> getNamespace ( ) , 'name' => $ parameter -> getName ( ) ] ; } }
5526	protected function createCodeForSubclass ( $ methods ) { $ code = "" ; if ( ! empty ( $ this -> namespace ) ) { $ code .= 'namespace ' . $ this -> namespace . ";\n" ; } $ code .= 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " public \$mock;\n" ; $ code .= $ this -> addMethodList ( array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new \\' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ this -> reflection -> getMethods ( ) ) ; $ code .= $ this -> createCodeForNewMethod ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
11079	public static function getMonthName ( $ month ) { if ( $ month < 1 || $ month > 12 ) { return '' ; } $ monthNames = [ 1 => self :: poorManTranslate ( 'fts-shared' , 'January' ) , 2 => self :: poorManTranslate ( 'fts-shared' , 'February' ) , 3 => self :: poorManTranslate ( 'fts-shared' , 'March' ) , 4 => self :: poorManTranslate ( 'fts-shared' , 'April' ) , 5 => self :: poorManTranslate ( 'fts-shared' , 'May' ) , 6 => self :: poorManTranslate ( 'fts-shared' , 'June' ) , 7 => self :: poorManTranslate ( 'fts-shared' , 'July' ) , 8 => self :: poorManTranslate ( 'fts-shared' , 'August' ) , 9 => self :: poorManTranslate ( 'fts-shared' , 'September' ) , 10 => self :: poorManTranslate ( 'fts-shared' , 'October' ) , 11 => self :: poorManTranslate ( 'fts-shared' , 'November' ) , 12 => self :: poorManTranslate ( 'fts-shared' , 'December' ) , ] ; return $ monthNames [ $ month ] ; }
11581	public function bootstrap ( $ rootDir , $ siteName ) { $ this -> app [ "red_kite_cms.root_dir" ] = $ rootDir ; $ this -> siteName = $ siteName ; $ this -> checkPermissions ( $ rootDir ) ; $ this -> initCmsRequiredServices ( ) ; $ this -> registerProviders ( ) ; $ this -> registerServices ( ) ; $ this -> registerListeners ( ) ; $ this -> register ( $ this -> app ) ; $ this -> boot ( ) ; $ this -> addWebsiteRoutes ( ) ; $ this -> app [ "dispatcher" ] -> dispatch ( CmsEvents :: CMS_BOOTED , new CmsBootedEvent ( $ this -> app [ "red_kite_cms.configuration_handler" ] ) ) ; }
10256	public function getState ( $ state_code = null ) { if ( ! empty ( $ state_code ) ) { $ res = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ res = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ State = new Entities \ State ; $ State -> code = $ res -> state_code ; $ State -> name = $ res -> state ; return $ State ; }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
3649	public static function get ( ? string $ key = null ) { self :: init ( ) ; if ( $ key === null ) { return self :: $ utmCookie ; } else { if ( mb_strpos ( $ key , 'utm_' ) !== 0 ) { $ key = 'utm_' . $ key ; } if ( false === array_key_exists ( $ key , self :: $ utmCookie ) ) { throw new UnexpectedValueException ( sprintf ( 'Argument $key has unexpecte value "%s". Utm value with key "%s" does not exists.' , $ key , $ key ) ) ; } else { return self :: $ utmCookie [ $ key ] ; } } }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
3154	public function getTraceVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_TraceVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setTrace ( $ variableValue ) ; return $ metaVariable ; }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
12812	private static function isForeignKey ( string $ table , string $ column ) : bool { return array_key_exists ( $ column , self :: getForeignKeys ( $ table ) ) ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
8381	public function execute ( ) { if ( $ this -> statement == null ) { $ this -> statement = Database :: get ( $ this -> database ) -> { ( $ this -> isCritical === true ? 'getMasterLink' : 'getLink' ) } ( ) -> prepare ( $ this -> toSql ( ) ) ; } foreach ( $ this -> parameters as $ name => $ value ) { $ type = \ PDO :: PARAM_STR ; if ( is_int ( $ value ) === true ) { $ type = \ PDO :: PARAM_INT ; } elseif ( is_bool ( $ value ) === true ) { $ type = \ PDO :: PARAM_BOOL ; } elseif ( is_null ( $ value ) === true ) { $ type = \ PDO :: PARAM_NULL ; } $ this -> statement -> bindValue ( $ name , $ value , $ type ) ; } $ result = $ this -> statement -> execute ( ) ; $ this -> errorInfo = $ this -> statement -> errorInfo ( ) ; if ( $ this -> getErrorState ( ) != '00000' ) { Logger :: get ( ) -> error ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; if ( constant ( 'STRAY_ENV' ) === 'development' ) { throw new AppException ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; } } return $ result ; }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
6702	protected function precedence ( $ a , $ b ) { if ( count ( $ a ) > count ( $ b ) ) { $ l = - 1 ; $ r = 1 ; $ x = $ a ; $ y = $ b ; } else { $ l = 1 ; $ r = - 1 ; $ x = $ b ; $ y = $ a ; } foreach ( array_keys ( $ x ) as $ i ) { if ( false === isset ( $ y [ $ i ] ) ) { return $ l ; } if ( $ x [ $ i ] === $ y [ $ i ] ) { continue ; } $ xi = is_integer ( $ x [ $ i ] ) ; $ yi = is_integer ( $ y [ $ i ] ) ; if ( $ xi && $ yi ) { return ( $ x [ $ i ] > $ y [ $ i ] ) ? $ l : $ r ; } elseif ( ( false === $ xi ) && ( false === $ yi ) ) { return ( max ( $ x [ $ i ] , $ y [ $ i ] ) == $ x [ $ i ] ) ? $ l : $ r ; } else { return $ xi ? $ r : $ l ; } } return 0 ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
1828	public function save ( ) { if ( \ count ( \ func_get_args ( ) ) ) { throw new \ InvalidArgumentException ( 'The $blnForceInsert argument has been removed (see system/docs/UPGRADE.md)' ) ; } if ( $ this -> blnPreventSaving ) { throw new \ RuntimeException ( 'The model instance has been detached and cannot be saved' ) ; } $ objDatabase = Database :: getInstance ( ) ; $ arrFields = $ objDatabase -> getFieldNames ( static :: $ strTable ) ; if ( Registry :: getInstance ( ) -> isRegistered ( $ this ) ) { $ arrSet = array ( ) ; $ arrRow = $ this -> row ( ) ; foreach ( $ this -> arrModified as $ k => $ v ) { if ( \ in_array ( $ k , $ arrFields ) ) { $ arrSet [ $ k ] = $ arrRow [ $ k ] ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } if ( $ intPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } $ objDatabase -> prepare ( "UPDATE " . static :: $ strTable . " %s WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> set ( $ arrSet ) -> execute ( $ intPk ) ; $ this -> postSave ( self :: UPDATE ) ; $ this -> arrModified = array ( ) ; } else { $ arrSet = $ this -> row ( ) ; foreach ( $ arrSet as $ k => $ v ) { if ( ! \ in_array ( $ k , $ arrFields ) ) { unset ( $ arrSet [ $ k ] ) ; } } $ arrSet = $ this -> preSave ( $ arrSet ) ; if ( empty ( $ arrSet ) ) { return $ this ; } $ stmt = $ objDatabase -> prepare ( "INSERT INTO " . static :: $ strTable . " %s" ) -> set ( $ arrSet ) -> execute ( ) ; if ( static :: $ strPk == 'id' ) { $ this -> id = $ stmt -> insertId ; } $ this -> postSave ( self :: INSERT ) ; $ this -> arrModified = array ( ) ; Registry :: getInstance ( ) -> register ( $ this ) ; } return $ this ; }
3927	public function setValueOptionsMultiple ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } if ( $ event -> getModel ( ) -> getProperty ( 'type' ) !== 'conditionpropertycontainanyof' ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ attribute = $ metaModel -> getAttributeById ( $ event -> getModel ( ) -> getProperty ( 'attr_id' ) ) ; if ( ! ( $ attribute && ( $ attribute -> get ( 'type' ) == 'tags' ) ) ) { return ; } $ event -> getWidget ( ) -> multiple = true ; }
12635	protected function getSignkey ( $ api ) { return $ this -> sandboxEnabled && $ api !== self :: API_SANDBOX_SIGN_KEY ? $ this -> getSandboxSignKey ( ) : $ this -> merchant -> key ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
306	public function getSizeLimit ( ) { $ limit = $ this -> sizeToBytes ( ini_get ( 'upload_max_filesize' ) ) ; $ postLimit = $ this -> sizeToBytes ( ini_get ( 'post_max_size' ) ) ; if ( $ postLimit > 0 && $ postLimit < $ limit ) { Yii :: warning ( 'PHP.ini\'s \'post_max_size\' is less than \'upload_max_filesize\'.' , __METHOD__ ) ; $ limit = $ postLimit ; } if ( $ this -> maxSize !== null && $ limit > 0 && $ this -> maxSize < $ limit ) { $ limit = $ this -> maxSize ; } if ( isset ( $ _POST [ 'MAX_FILE_SIZE' ] ) && $ _POST [ 'MAX_FILE_SIZE' ] > 0 && $ _POST [ 'MAX_FILE_SIZE' ] < $ limit ) { $ limit = ( int ) $ _POST [ 'MAX_FILE_SIZE' ] ; } return $ limit ; }
9623	public function getConnectionConfig ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } $ config = $ this -> config -> get ( "database.connections.$connection" ) ; if ( ! $ config ) { if ( ! is_string ( $ connection ) ) { $ connection = gettype ( $ connection ) ; } throw new \ InvalidArgumentException ( "No config found for connection: $connection" ) ; } return $ config ; }
1623	public function buildCondition ( $ condition , & $ columns ) { static $ builders = [ 'not' => 'buildNotCondition' , 'and' => 'buildAndCondition' , 'or' => 'buildAndCondition' , 'between' => 'buildBetweenCondition' , 'not between' => 'buildBetweenCondition' , 'in' => 'buildInCondition' , 'not in' => 'buildInCondition' , 'like' => 'buildLikeCondition' , 'not like' => 'buildLikeCondition' , 'or like' => 'buildLikeCondition' , 'or not like' => 'buildLikeCondition' , '>' => 'buildCompareCondition' , '>=' => 'buildCompareCondition' , '<' => 'buildCompareCondition' , '<=' => 'buildCompareCondition' , ] ; if ( ! is_array ( $ condition ) ) { throw new NotSupportedException ( 'Where condition must be an array in redis ActiveRecord.' ) ; } if ( isset ( $ condition [ 0 ] ) ) { $ operator = strtolower ( $ condition [ 0 ] ) ; if ( isset ( $ builders [ $ operator ] ) ) { $ method = $ builders [ $ operator ] ; array_shift ( $ condition ) ; return $ this -> $ method ( $ operator , $ condition , $ columns ) ; } else { throw new Exception ( 'Found unknown operator in query: ' . $ operator ) ; } } else { return $ this -> buildHashCondition ( $ condition , $ columns ) ; } }
12943	public function authenticate ( AdapterInterface $ adapter = null ) { $ event = clone $ this -> getEvent ( ) ; $ event -> setName ( AuthenticationEvent :: EVENT_AUTH ) ; if ( ! $ adapter ) { $ adapter = $ this -> getAdapter ( ) ; } if ( $ adapter ) { $ event -> setAdapter ( $ adapter ) ; } $ this -> getEventManager ( ) -> trigger ( $ event ) ; return $ event -> getResult ( ) ; }
8676	public function flip ( ) { if ( ! $ this -> items ) { return $ this -> createFrom ( [ ] ) ; } try { return $ this -> createFrom ( Thrower :: call ( 'array_flip' , $ this -> items ) ) ; } catch ( ErrorException $ e ) { throw new LogicException ( 'Only string and integer values can be flipped' ) ; } }
7416	public function getMaxFileSize ( ) : int { $ iniMax = strtolower ( ini_get ( 'upload_max_filesize' ) ) ; if ( '' === $ iniMax ) { return PHP_INT_MAX ; } $ max = ltrim ( $ iniMax , '+' ) ; if ( 0 === strpos ( $ max , '0x' ) ) { $ max = intval ( $ max , 16 ) ; } elseif ( 0 === strpos ( $ max , '0' ) ) { $ max = intval ( $ max , 8 ) ; } else { $ max = ( int ) $ max ; } switch ( substr ( $ iniMax , - 1 ) ) { case 't' : $ max *= 1024 ; case 'g' : $ max *= 1024 ; case 'm' : $ max *= 1024 ; case 'k' : $ max *= 1024 ; } return $ max ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
9455	public function getQueries ( ) { $ array = [ ] ; foreach ( $ this -> getKeywords ( ) as $ keyword ) { $ value = $ keyword -> getData ( ) ; if ( $ this -> getCountableAttributes ( ) ) { $ value [ 'countableAttributes' ] = $ this -> getCountableAttributes ( ) ; } $ array [ ] = $ value ; } return $ array ; }
1155	public function getMessage ( $ attribute , $ rule ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'getMessage' , [ $ attribute , $ rule ] ) ; }
10361	public static function writeLogs ( string $ message ) : bool { return ( bool ) file_put_contents ( rtrim ( LOGS_PATH , '/' ) . '/' . gmdate ( 'Y_m_d' ) . '.log' , '[' . gmdate ( 'd-M-Y H:i:s' ) . '] ' . $ message . PHP_EOL , FILE_APPEND ) ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
4470	public function complete ( ? string $ nextq = null , int $ delay = 0 , array $ depends = [ ] ) : string { if ( $ this -> completed || $ this -> failed ) { throw new JobAlreadyFinishedException ( ) ; } $ params = [ $ this -> jid , $ this -> worker , $ this -> queue , json_encode ( $ this -> data , JSON_UNESCAPED_SLASHES ) ? : '{}' ] ; if ( $ nextq ) { $ next = [ 'next' , $ nextq , 'delay' , $ delay , 'depends' , json_encode ( $ depends , JSON_UNESCAPED_SLASHES ) ] ; $ params = array_merge ( $ params , $ next ) ; } $ this -> completed = true ; return call_user_func_array ( [ $ this -> client , 'complete' ] , $ params ) ; }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
2326	public static function createFromDbResult ( Result $ objResult , $ strTable ) { $ arrModels = array ( ) ; $ strClass = Model :: getClassFromTable ( $ strTable ) ; while ( $ objResult -> next ( ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( $ strTable , $ objResult -> { $ strClass :: getPk ( ) } ) ; if ( $ objModel !== null ) { $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; $ arrModels [ ] = $ objModel ; } else { $ arrModels [ ] = new $ strClass ( $ objResult ) ; } } return new static ( $ arrModels , $ strTable ) ; }
8179	public function login ( ) { return $ this -> validate ( ) ? Yii :: $ app -> user -> login ( $ this -> getUser ( ) , $ this -> rememberMe ? UserModule :: $ rememberMeDuration : 0 ) : FALSE ; }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
11430	private function runRoute ( array $ routeInfo ) : Response { list ( $ _ , $ callback , $ vars ) = $ routeInfo ; $ vars = array_filter ( $ vars , function ( $ var ) { return strpos ( $ var , '_' ) !== 0 ; } , ARRAY_FILTER_USE_KEY ) ; if ( ! class_exists ( $ callback [ 0 ] ) ) { throw new ControllerNotFoundException ( 'Trying to instantiate a non existent controller (`' . $ callback [ 0 ] . '`)' ) ; } $ controller = new $ callback [ 0 ] ( $ this -> response , $ this -> session ) ; if ( ! method_exists ( $ controller , $ callback [ 1 ] ) ) { throw new ActionNotFoundException ( 'Trying to call a non existent action (`' . $ callback [ 0 ] . '::' . $ callback [ 1 ] . '`)' ) ; } return $ this -> injector -> execute ( [ $ controller , $ callback [ 1 ] ] , array_map ( 'urldecode' , $ vars ) ) ; }
9944	public function getCellByColumnAndRow ( $ columnIndex , $ row , $ createIfNotExists = true ) { $ columnLetter = Coordinate :: stringFromColumnIndex ( $ columnIndex ) ; $ coordinate = $ columnLetter . $ row ; if ( $ this -> cellCollection -> has ( $ coordinate ) ) { return $ this -> cellCollection -> get ( $ coordinate ) ; } return $ createIfNotExists ? $ this -> createNewCell ( $ coordinate ) : null ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
8947	public function uploadTrace ( $ file , $ description , $ tags , $ public , $ visibility , $ username , $ password ) { $ parameters = array ( 'file' => $ file , 'description' => $ description , 'tags' => $ tags , 'public' => $ public , 'visibility' => $ visibility , ) ; $ base = 'gpx/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'multipart/form-data' ; $ header = array_merge ( $ header , $ parameters ) ; $ header = array_merge ( $ header , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; return $ this -> sendRequest ( $ path , 'POST' , $ header , array ( ) ) ; }
3256	public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; }
3660	private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; }
1820	public function extractVimeoId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> vimeo != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%vimeo\.com/(?:channels/(?:\w+/)?|groups/(?:[^/]+)/videos/|album/(?:\d+)/video/)?(\d+)(?:$|/|\?)%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
6521	public function boot ( ) { $ this -> app -> when ( SmsGatewayChannel :: class ) -> needs ( SmsGatewayClient :: class ) -> give ( function ( ) { $ config = $ this -> app [ 'config' ] [ 'services.smsgateway' ] ; return new SmsGatewayClient ( new HttpClient , $ config [ 'email' ] , $ config [ 'password' ] , $ config [ 'device' ] ) ; } ) ; }
8084	public function clearErrors ( $ channelName = '' ) { $ channel = $ this -> namespaceChannel ( $ channelName ) ; $ this -> console [ 'errors' ] [ $ channel ] = array ( ) ; $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
492	public function findFor ( $ name , $ model ) { if ( method_exists ( $ model , 'get' . $ name ) ) { $ method = new \ ReflectionMethod ( $ model , 'get' . $ name ) ; $ realName = lcfirst ( substr ( $ method -> getName ( ) , 3 ) ) ; if ( $ realName !== $ name ) { throw new InvalidArgumentException ( 'Relation names are case sensitive. ' . get_class ( $ model ) . " has a relation named \"$realName\" instead of \"$name\"." ) ; } } return $ this -> multiple ? $ this -> all ( ) : $ this -> one ( ) ; }
7866	protected function drawBorderTop ( $ isCore = false ) { $ crossroads = $ isCore ? static :: CROSSROADS_UP : static :: CROSSROADS ; $ this -> drawBorder ( static :: BORDER_NW , $ crossroads , static :: BORDER_NE ) ; $ this -> geometry -> increaseNesting ( ) ; }
10362	public static function exception ( $ exception ) { try { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; $ error [ 'code' ] = $ exception -> getCode ( ) ; $ error [ 'message' ] = $ exception -> getMessage ( ) ; $ error [ 'file' ] = $ exception -> getFile ( ) ; $ error [ 'line' ] = $ exception -> getLine ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'type' ] = 'ErrorException: ' ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( ErrorHandler :: $ levels ) ) ? ErrorHandler :: $ levels [ $ error [ 'code' ] ] : 'Unknown Error' ; } else { $ error [ 'type' ] = get_class ( $ exception ) ; } ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; @ header ( 'Content-Type: text/html; charset=UTF-8' ) ; if ( DEVELOPMENT ) { $ error [ 'backtrace' ] = $ exception -> getTrace ( ) ; if ( $ exception instanceof \ ErrorException ) { $ error [ 'backtrace' ] = array_slice ( $ error [ 'backtrace' ] , 1 ) ; } $ error [ 'backtrace' ] = self :: formatBacktrace ( $ error [ 'backtrace' ] ) ; $ error [ 'highlighted' ] = self :: highlightCode ( $ error [ 'file' ] , $ error [ 'line' ] ) ; @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/exception.php' ; } else { @ header ( 'HTTP/1.1 500 Internal Server Error' ) ; include 'views/production.php' ; } } catch ( Exception $ e ) { while ( ob_get_level ( ) > 0 ) ob_end_clean ( ) ; echo $ e -> getMessage ( ) . ' in ' . $ e -> getFile ( ) . ' (line ' . $ e -> getLine ( ) . ').' ; } exit ( 1 ) ; }
6539	public function transform ( $ iterator ) { if ( null === $ iterator ) { return array ( ) ; } if ( is_array ( $ iterator ) ) { return $ iterator ; } if ( ! $ iterator instanceof Iterator ) { throw new TransformationFailedException ( 'Expected a Yucca\Component\Iterator\Iterator object.' ) ; } return $ iterator -> getArray ( ) ; }
2079	public function purgeInternalCache ( ) { $ container = System :: getContainer ( ) ; $ clearer = $ container -> get ( 'contao.cache.clear_internal' ) ; $ clearer -> clear ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Purged the internal cache' , __METHOD__ , TL_CRON ) ; }
5230	public static function forValue ( $ value ) { $ enumClass = new \ ReflectionClass ( get_called_class ( ) ) ; foreach ( $ enumClass -> getStaticProperties ( ) as $ instance ) { if ( $ instance -> value ( ) === $ value ) { return $ instance ; } } throw new \ InvalidArgumentException ( 'Enum ' . $ enumClass -> getName ( ) . ' for value ' . $ value . ' does not exist.' ) ; }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
2499	private function getAlwaysAvailableFilter ( array $ languageCodes ) { $ conditions = array ( new CustomField ( self :: FIELD_IS_ALWAYS_AVAILABLE , Operator :: EQ , true ) , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ languageCodes ) ) , ) ; if ( $ this -> hasMainLanguagesEndpoint ) { $ conditions [ ] = new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ; } return new LogicalAnd ( $ conditions ) ; }
5816	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ types = unserialize ( $ this -> TagTypes ) ; $ changed = $ this -> getChangedFields ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { if ( isset ( $ types [ $ type ] ) ) { $ newTypes = array ( ) ; if ( isset ( $ changed [ 'TagTypes' ] ) ) { $ before = unserialize ( $ changed [ 'TagTypes' ] [ 'before' ] ) ; $ after = unserialize ( $ changed [ 'TagTypes' ] [ 'after' ] ) ; $ newTypes = is_array ( $ before ) ? array_diff ( $ after , $ before ) : $ after ; } if ( ( isset ( $ changed [ 'ID' ] ) || isset ( $ newTypes [ $ type ] ) ) && ! ( $ type :: get ( ) -> filter ( $ field , $ this -> Title ) -> first ( ) ) ) { $ tag = $ type :: create ( ) ; $ tag -> $ field = $ this -> Title ; $ tag -> FusionTagID = $ this -> ID ; $ tag -> write ( ) ; } else if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) && ( $ existing = $ type :: get ( ) -> filter ( $ field , $ changed [ 'Title' ] [ 'before' ] ) ) ) { foreach ( $ existing as $ tag ) { $ tag -> $ field = $ changed [ 'Title' ] [ 'after' ] ; $ tag -> write ( ) ; } } } } if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) ) { $ this -> service -> updateTagging ( $ this -> ID ) ; } }
7609	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ handler ) : ResponseInterface { $ requestHandler = $ request -> getAttribute ( $ this -> handlerAttribute ) ; if ( empty ( $ requestHandler ) ) { if ( $ this -> continueOnEmpty ) { return $ handler -> handle ( $ request ) ; } throw new RuntimeException ( 'Empty request handler' ) ; } if ( is_string ( $ requestHandler ) ) { $ requestHandler = $ this -> container -> get ( $ requestHandler ) ; } if ( is_array ( $ requestHandler ) && count ( $ requestHandler ) === 2 && is_string ( $ requestHandler [ 0 ] ) ) { $ requestHandler [ 0 ] = $ this -> container -> get ( $ requestHandler [ 0 ] ) ; } if ( $ requestHandler instanceof MiddlewareInterface ) { return $ requestHandler -> process ( $ request , $ handler ) ; } if ( $ requestHandler instanceof RequestHandlerInterface ) { return $ requestHandler -> handle ( $ request ) ; } if ( is_callable ( $ requestHandler ) ) { return ( new CallableHandler ( $ requestHandler ) ) -> process ( $ request , $ handler ) ; } throw new RuntimeException ( sprintf ( 'Invalid request handler: %s' , gettype ( $ requestHandler ) ) ) ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
3828	protected function addUrlParameter ( $ url , $ name , $ value ) { @ trigger_error ( sprintf ( '"%1$s" has been deprecated in favor of the "FilterUrlBuilder"' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ value = str_replace ( '%' , '%%' , urlencode ( $ value ) ) ; if ( empty ( $ value ) ) { return $ url ; } if ( $ name !== 'auto_item' ) { $ url .= '/' . $ name . '/' . $ value ; } else { $ url = '/' . $ value . $ url ; } return $ url ; }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
10197	public function writeStringTable ( array $ pStringTable ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'sst' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'uniqueCount' , count ( $ pStringTable ) ) ; foreach ( $ pStringTable as $ textElement ) { $ objWriter -> startElement ( 'si' ) ; if ( ! $ textElement instanceof RichText ) { $ textToWrite = StringHelper :: controlCharacterPHP2OOXML ( $ textElement ) ; $ objWriter -> startElement ( 't' ) ; if ( $ textToWrite !== trim ( $ textToWrite ) ) { $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; } $ objWriter -> writeRawData ( $ textToWrite ) ; $ objWriter -> endElement ( ) ; } elseif ( $ textElement instanceof RichText ) { $ this -> writeRichText ( $ objWriter , $ textElement ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
6186	public function renderInclude ( $ name , $ path = null ) { $ twigConfig = Config :: load ( 'twig' ) ; $ pathFile = pathFile ( $ name ) ; $ folder = $ pathFile [ 0 ] ; $ name = $ pathFile [ 1 ] ; $ path = $ twigConfig -> get ( 'setTemplateDir' ) . DIRECTORY_SEPARATOR . $ folder . $ name . $ twigConfig -> get ( 'fileExtension' , '.twig' ) ; try { if ( ! is_file ( $ path ) ) { throw new ViewException ( 'Can not open template ' . $ name . ' in: ' . $ path ) ; } $ renderInclude = $ this -> twig -> render ( $ name , $ this -> assign ) ; } catch ( ViewException $ e ) { echo $ e -> getMessage ( ) . '<br /> File: ' . $ e -> getFile ( ) . '<br /> Code line: ' . $ e -> getLine ( ) . '<br /> Trace: ' . $ e -> getTraceAsString ( ) ; exit ( ) ; } return $ renderInclude ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
9716	private function writeCountry ( ) { $ record = 0x008C ; $ length = 4 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> countryCode , $ this -> countryCode ) ; return $ this -> writeData ( $ header . $ data ) ; }
10693	protected function fixTable ( $ table , $ tableAlias = '' ) { if ( empty ( $ table ) ) { $ table = [ ] ; } else { if ( ! is_array ( $ table ) ) { $ table = empty ( $ tableAlias ) ? [ $ table ] : [ $ table => $ tableAlias ] ; } } return $ table ; }
10259	public function getPhone ( $ state_code = null , $ zip = null , $ include_toll_free = false ) { if ( ! empty ( $ zip ) ) { $ areacodes = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } else { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ areacodes = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } $ code_list = explode ( ',' , $ areacodes ) ; if ( $ include_toll_free === true ) { $ code_list [ ] = 800 ; $ code_list [ ] = 888 ; $ code_list [ ] = 877 ; $ code_list [ ] = 866 ; $ code_list [ ] = 855 ; } $ areacode = $ this -> fromArray ( $ code_list ) ; $ prefix = rand ( 100 , 999 ) ; $ number = rand ( 1 , 9999 ) ; return $ areacode . '-' . $ prefix . '-' . str_pad ( $ number , 4 , '0' , STR_PAD_LEFT ) ; }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
4010	public function getMaxPaginationLinks ( ) { if ( null === $ this -> maxPaginationLinks ) { $ this -> setMaxPaginationLinks ( \ Config :: get ( 'maxPaginationLinks' ) ) ; } return $ this -> maxPaginationLinks ; }
1295	public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
9470	protected function loadingGroups ( ) : void { foreach ( $ this -> groups as $ group ) { $ this -> addPattern ( $ group -> toArray ( ) ) ; } }
4553	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; foreach ( $ this -> removed as $ property ) { if ( ! array_key_exists ( $ property , $ data ) ) { throw new OutOfRangeException ( 'Property does not exist.' ) ; } unset ( $ data [ $ property ] ) ; } $ event -> setData ( $ data ) ; }
9195	public function setThemesPath ( $ path ) { if ( ! is_dir ( $ path ) ) { throw new \ Exception ( sprintf ( 'Path "%s" not found.' , $ path ) ) ; } $ this -> themesPath = rtrim ( $ path , DS ) ; return $ this ; }
1606	public function findRedirectByPath ( $ path ) { $ redirects = $ this -> findAllRedirects ( true ) ; foreach ( $ redirects as $ redirect ) { $ to = false ; if ( trim ( $ redirect [ 'uri' ] , '/' ) == $ path ) $ to = $ redirect [ 'to' ] ; elseif ( $ uri = $ this -> _isRedirectRegex ( $ redirect [ 'uri' ] ) ) if ( preg_match ( $ uri , $ path ) ) $ to = preg_replace ( $ uri , $ redirect [ 'to' ] , $ path ) ; if ( $ to ) { return [ 'to' => strpos ( $ to , '://' ) !== false ? $ to : UrlHelper :: siteUrl ( $ to ) , 'type' => $ redirect [ 'type' ] , ] ; } } return false ; }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
9091	protected function normalizeOptions ( array $ options = [ ] ) { $ options = parent :: normalizeOptions ( $ options ) ; if ( isset ( $ options [ 'subLiClassLevel0' ] ) && $ options [ 'subLiClassLevel0' ] !== null ) { $ options [ 'subLiClassLevel0' ] = ( string ) $ options [ 'subLiClassLevel0' ] ; } else { $ options [ 'subLiClassLevel0' ] = $ this -> getSubLiClassLevel0 ( ) ; } return $ options ; }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
2152	public function synchronize ( $ varValue , $ objUser , $ objModule = null ) { if ( $ objUser === null ) { return $ varValue ; } $ blnIsFrontend = true ; if ( $ objUser instanceof DataContainer ) { $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objUser -> id ) ; if ( $ objUser -> numRows < 1 ) { return $ varValue ; } $ blnIsFrontend = false ; } if ( $ varValue == $ objUser -> newsletter || $ objUser -> email == '' ) { return $ varValue ; } $ time = time ( ) ; $ varValue = StringUtil :: deserialize ( $ varValue , true ) ; if ( $ blnIsFrontend && $ objModule instanceof Module ) { $ arrChannel = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; } else { $ arrChannel = $ this -> Database -> query ( "SELECT id FROM tl_newsletter_channel" ) -> fetchEach ( 'id' ) ; } $ arrDelete = array_values ( array_diff ( $ arrChannel , $ varValue ) ) ; if ( ! empty ( $ arrDelete ) && \ is_array ( $ arrDelete ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrDelete ) ) . ") AND email=?" ) -> execute ( $ objUser -> email ) ; } foreach ( $ varValue as $ intId ) { $ intId = ( int ) $ intId ; if ( $ intId < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intId , $ objUser -> email ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, active=?, addedOn=?" ) -> execute ( $ intId , $ objUser -> email , ( $ objUser -> disable ? '' : 1 ) , ( $ blnIsFrontend ? $ time : '' ) ) ; } } return serialize ( $ varValue ) ; }
3582	protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; }
999	public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; }
7026	public function checkRememberMeCookie ( ) { if ( ! $ this -> loggedIn ( ) && $ this -> Cookie -> read ( 'User.id' ) ) { return $ this -> Cookie -> read ( 'User.id' ) ; } return false ; }
12133	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ options = $ serviceLocator -> get ( 'HtSettingsModule\Options\ModuleOptions' ) ; $ settingsService = new SettingsService ( $ options , $ serviceLocator -> get ( 'HtSettingsModule_SettingsMapper' ) , $ serviceLocator -> get ( 'HtSettingsModule\Service\NamespaceHydratorProvider' ) ) ; if ( $ options -> getCacheOptions ( ) -> isEnabled ( ) ) { $ settingsService -> setCacheManager ( $ serviceLocator -> get ( 'HtSettingsModule\Service\CacheManager' ) ) ; } return $ settingsService ; }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
7986	public function getModels ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/models' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4196	private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { $ obj = $ abs -> getSubject ( ) ; if ( $ obj instanceof \ Traversable && ! $ abs [ 'traverseValues' ] ) { $ traversed = true ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ obj as $ k => $ v ) { $ abs [ 'traverseValues' ] [ $ k ] = $ this -> abstracter -> needsAbstraction ( $ v ) ? $ this -> abstracter -> getAbstraction ( $ v , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) : $ v ; } } } if ( ! $ traversed ) { $ this -> addConstants ( $ abs ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ abs [ 'extends' ] [ ] = $ reflector -> getName ( ) ; } $ this -> addProperties ( $ abs ) ; $ this -> addMethods ( $ abs ) ; } }
10253	public function getFullName ( $ gender = null ) { if ( empty ( $ gender ) ) { $ gender = $ this -> getGender ( ) ; } $ person_name = new Entities \ FullName ; $ person_name -> first = $ this -> getFirstName ( $ gender ) ; $ person_name -> middle = $ this -> getMiddleName ( $ gender ) ; $ person_name -> last = $ this -> getLastName ( ) ; $ person_name -> gender = $ gender ; return $ person_name ; }
728	public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } if ( isset ( self :: $ _events [ $ name ] [ $ class ] ) ) { $ removed = false ; foreach ( self :: $ _events [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _events [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _events [ $ name ] [ $ class ] = array_values ( self :: $ _events [ $ name ] [ $ class ] ) ; return $ removed ; } } $ removed = false ; if ( isset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { foreach ( self :: $ _eventWildcards [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _eventWildcards [ $ name ] [ $ class ] = array_values ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] ) ; } } } } return $ removed ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
9169	public function setTimestampCreated ( $ postTime ) { if ( $ postTime instanceof DateTime ) { $ this -> timestampCreated = $ postTime ; } else { $ this -> timestampCreated = new DateTime ( $ postTime ) ; } return $ this ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
2828	public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; }
10635	public function update ( \ SplSubject $ eventManager ) { $ this -> isUpdate = true ; if ( $ eventManager -> event -> function !== NULL ) { $ this -> { $ eventManager -> event -> function } ( $ eventManager ) ; } }
11770	public function switchTo ( NodeConnectionInterface $ connection ) { if ( $ connection && $ connection === $ this -> current ) { return ; } if ( $ connection !== $ this -> master && ! in_array ( $ connection , $ this -> slaves , true ) ) { throw new \ InvalidArgumentException ( 'Invalid connection or connection not found.' ) ; } $ connection -> connect ( ) ; if ( $ this -> current ) { $ this -> current -> disconnect ( ) ; } $ this -> current = $ connection ; }
5088	public function queryMap ( $ key = 0 , $ value = 1 ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) || is_string ( $ value ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) || ! key_exists ( $ value , $ row ) ) throw new MySqlException ( "Key '$key' or Value '$value' columns not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; $ map [ $ row [ $ key ] ] = $ row [ $ value ] ; } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
8775	public function admin ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ADMIN_FOLDER . '/' . $ data : $ this -> url . '/' . ADMIN_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
1913	protected function generateCaptcha ( ) { if ( $ this -> arrCaptcha ) { return ; } $ int1 = random_int ( 1 , 9 ) ; $ int2 = random_int ( 1 , 9 ) ; $ this -> arrCaptcha = array ( 'int1' => $ int1 , 'int2' => $ int2 , 'sum' => $ int1 + $ int2 , 'key' => $ this -> strCaptchaKey , 'hashes' => $ this -> generateHashes ( $ int1 + $ int2 ) ) ; }
4832	public function payout ( ) { if ( ! $ this -> payout_id ) { throw new GoCardless_ClientException ( "Cannot fetch payout for a bill that has not been paid out" ) ; } return GoCardless_Payout :: find_with_client ( $ this -> client , $ this -> payout_id ) ; }
2963	public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; }
6522	public function isCompatibleForMerge ( Field $ other ) { if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> className !== $ other -> className ) { return false ; } if ( ! array_intersect ( $ this -> anyOfClassNames , $ other -> anyOfClassNames ) ) { return false ; } return true ; }
10378	protected static function get_routes_to_folder ( $ type ) { $ url = isset ( self :: $ unify [ "{$type}s" ] ) ? self :: $ unify [ "{$type}s" ] : self :: $ unify ; return [ 'url' => $ url , 'path' => self :: get_path_from_url ( $ url ) , ] ; }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
3970	protected function attributeIdToName ( IMetaModel $ metaModel , $ attributeId ) { if ( null === $ attribute = $ metaModel -> getAttributeById ( $ attributeId ) ) { throw new \ RuntimeException ( sprintf ( 'Could not retrieve attribute %s from MetaModel %s.' , $ attributeId , $ metaModel -> getTableName ( ) ) ) ; } return $ attribute -> getColName ( ) ; }
6293	private function scanThemes ( ) { $ themeDirectories = glob ( $ this -> basePath . '/*' , GLOB_ONLYDIR ) ; $ themes = [ ] ; foreach ( $ themeDirectories as $ themePath ) { $ json = $ themePath . '/theme.json' ; if ( file_exists ( $ json ) ) { $ contents = file_get_contents ( $ json ) ; if ( ! $ contents === false ) { $ th = $ this -> parseThemeInfo ( json_decode ( $ contents , true ) ) ; $ themes [ $ th -> getDirectory ( ) ] = $ th ; } } } $ this -> themes = $ themes ; if ( count ( $ themes ) && ! $ this -> activeTheme ) { $ this -> set ( array_keys ( $ themes ) [ 0 ] ) ; } }
6239	public static function getExtensionFor ( string $ mimetype ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( false !== $ match = array_search ( $ mimetype , $ extensions , true ) ) { return $ match ; } return null ; }
6827	public static function isValid ( $ action , $ throw = false ) { if ( in_array ( $ action , static :: getActions ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown gateway action '$action'." ) ; } return false ; }
10803	public function deletePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = $ responseData [ 0 ] [ 'idPage' ] ; $ response = array ( 'idPage' => $ idPage ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_start' , $ this , $ response ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => 'Delete' , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => 'tr_melispagehistoric_action_text_Delete' ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_end' , $ this , $ responseData ) ; }
1512	public function read ( StoreInterface $ store , FetchResource $ request ) { $ result = $ this -> doRead ( $ store , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ result ) ; }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
12217	private function register ( ) { ini_set ( 'display_errors' , false ) ; if ( $ this -> displayErrors ) { ini_set ( 'display_errors' , true ) ; } register_shutdown_function ( [ $ this , 'shutdownHandler' ] ) ; set_error_handler ( [ $ this , 'errorHandler' ] ) ; set_exception_handler ( [ $ this , 'exceptionHandler' ] ) ; }
2105	protected function generateFaqLink ( $ objFaq ) { $ objCategory = $ objFaq -> getRelated ( 'pid' ) ; $ jumpTo = ( int ) $ objCategory -> jumpTo ; if ( $ jumpTo < 1 ) { throw new \ Exception ( "FAQ categories without redirect page cannot be used in an FAQ list" ) ; } if ( ! isset ( $ this -> arrTargets [ $ jumpTo ] ) ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( Environment :: get ( 'request' ) , true ) ; if ( $ jumpTo > 0 && ( $ objTarget = PageModel :: findByPk ( $ jumpTo ) ) !== null ) { $ this -> arrTargets [ $ jumpTo ] = ampersand ( $ objTarget -> getFrontendUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ) ; } } return sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ this -> arrTargets [ $ jumpTo ] ) , ( $ objFaq -> alias ? : $ objFaq -> id ) ) ; }
4949	public function createQueryBuilder ( $ findDrafts = false ) { $ qb = parent :: createQueryBuilder ( ) ; if ( null !== $ findDrafts ) { $ qb -> field ( 'isDraft' ) -> equals ( $ findDrafts ) ; } return $ qb ; }
3916	protected function sortByIdList ( $ sortIds ) { $ fileMap = $ this -> foundFiles ; if ( ! $ fileMap ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ fileKeys = array_flip ( array_keys ( $ this -> uuidMap ) ) ; $ sorted = array ( ) ; foreach ( $ sortIds as $ sortStringId ) { $ key = $ fileKeys [ $ sortStringId ] ; $ sorted [ $ key ] = $ fileMap [ $ key ] ; unset ( $ fileMap [ $ key ] ) ; } $ sorted += $ fileMap ; return $ this -> remapSorting ( $ sorted , $ this -> outputBuffer ) ; }
10736	public function compare ( $ x ) : int { if ( ! is_numeric ( $ x ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, x, to be a number" ) ; } if ( $ x < $ this -> lower || ( ! $ this -> isLowerInclusive && $ x == $ this -> lower ) ) { return - 1 ; } elseif ( $ x > $ this -> upper || ( ! $ this -> isUpperInclusive && $ x == $ this -> upper ) ) { return 1 ; } else { return 0 ; } }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
4379	protected function dumpArray ( $ array ) { if ( empty ( $ array ) ) { $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">()</span>' ; } else { $ displayKeys = $ this -> debug -> getCfg ( 'output.displayListKeys' ) || ! $ this -> debug -> utilities -> isList ( $ array ) ; $ html = '<span class="t_keyword">array</span>' . '<span class="t_punct">(</span>' . "\n" ; if ( $ displayKeys ) { $ html .= '<span class="array-inner">' . "\n" ; foreach ( $ array as $ key => $ val ) { $ html .= "\t" . '<span class="key-value">' . '<span class="t_key' . ( \ is_int ( $ key ) ? ' t_int' : '' ) . '">' . $ this -> dump ( $ key , true , false ) . '</span> ' . '<span class="t_operator">=&gt;</span> ' . $ this -> dump ( $ val ) . '</span>' . "\n" ; } $ html .= '</span>' ; } else { $ html .= '<ul class="array-inner list-unstyled">' . "\n" ; foreach ( $ array as $ val ) { $ html .= $ this -> dump ( $ val , true , 'li' ) ; } $ html .= '</ul>' ; } $ html .= '<span class="t_punct">)</span>' ; } return $ html ; }
7971	public function getIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( $ id !== 0 && ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; $ id = intval ( $ id ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
12715	protected function circularDependencyResolver ( $ class ) { if ( ! is_string ( $ class ) && ! class_exists ( $ class ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be a string of valid class name." , __METHOD__ ) ) ; } $ reflector = Internal \ ReflectionClassFactory :: create ( $ class ) ; if ( ! $ this -> hasConstructor ( $ reflector ) ) { return $ this -> resolveInstanceWithoutConstructor ( $ reflector ) ; } else { $ param = $ this -> getMethodParameters ( $ reflector , '__construct' ) ; if ( empty ( $ param ) ) { return $ reflector -> newInstance ( ) ; } else { foreach ( $ param as $ key => $ value ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ param [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ param [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } } return $ reflector -> newInstanceArgs ( $ param ) ; } } }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
2475	public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; }
2925	public function normaliseValue ( $ value , $ quote = '' ) { if ( strlen ( $ quote ) == 0 ) { return trim ( $ value ) ; } $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; return $ value ; }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
540	protected function addPaginationHeaders ( $ pagination ) { $ links = [ ] ; foreach ( $ pagination -> getLinks ( true ) as $ rel => $ url ) { $ links [ ] = "<$url>; rel=$rel" ; } $ this -> response -> getHeaders ( ) -> set ( $ this -> totalCountHeader , $ pagination -> totalCount ) -> set ( $ this -> pageCountHeader , $ pagination -> getPageCount ( ) ) -> set ( $ this -> currentPageHeader , $ pagination -> getPage ( ) + 1 ) -> set ( $ this -> perPageHeader , $ pagination -> pageSize ) -> set ( 'Link' , implode ( ', ' , $ links ) ) ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
8484	public static function getHostname ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Name FROM Win32_ComputerSystem" ) as $ cs ) { return $ cs -> Name ; } return "Unknown" ; }
6834	private function getFindNewBySupplierQuery ( ) { if ( null !== $ this -> findNewBySupplierQuery ) { return $ this -> findNewBySupplierQuery ; } $ qb = $ this -> createQueryBuilder ( ) ; $ as = $ this -> getAlias ( ) ; return $ this -> findNewBySupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.supplier' , ':supplier' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.state' , ':state' ) ) -> getQuery ( ) -> setParameter ( 'state' , Model \ SupplierOrderStates :: STATE_NEW ) ; }
8791	public function meta ( $ name , $ content , array $ attributes = [ ] ) { $ defaults = compact ( 'name' , 'content' ) ; $ attributes = array_merge ( $ defaults , $ attributes ) ; return $ this -> toHtmlString ( '<meta' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
10427	private function initShops ( ContainerBuilder $ container , array $ config ) { $ activeShop = ! empty ( $ config [ 'active_shop' ] ) ? $ config [ 'active_shop' ] : null ; if ( $ activeShop !== null && ! isset ( $ config [ 'shops' ] [ $ activeShop ] ) ) { throw new LogicException ( "Parameter 'ongr_connections.active_shop' must be set to one" . "of the values defined in 'ongr_connections.shops'." ) ; } $ container -> setParameter ( 'ongr_connections.active_shop' , $ activeShop ) ; $ container -> setParameter ( 'ongr_connections.shops' , $ config [ 'shops' ] ) ; $ container -> setDefinition ( 'ongr_connections.shop_service' , new Definition ( 'ONGR\ConnectionsBundle\Service\ShopService' , [ $ activeShop , $ config [ 'shops' ] , ] ) ) ; }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
9601	public function add ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ sum = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ sum [ $ i ] = $ component + $ bComponents [ $ i ] ; } return new static ( $ sum ) ; }
6859	protected static function solsticeDecember ( $ year , $ vsop = true ) { $ month = 12 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
11406	public function actionCreate ( ) { $ model = new Item ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'index' ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
8998	public function exists ( ) : bool { if ( ! file_exists ( $ this -> path ) ) { return false ; } if ( ! is_dir ( $ this -> path ) ) { throw new DirectoryException ( "Entry {path} exists, but it is not a directory!" , array ( 'path' => $ this -> path ) ) ; } return true ; }
11594	public function postAction ( ) { $ request = $ this -> environment -> getRequestHelper ( ) ; $ id = $ request -> getIdentifierParam ( 'name' ) ; try { $ this -> pageList -> getPage ( $ id ) ; } catch ( InvalidParameterException $ e ) { $ page = $ this -> pageList -> addPageFromRequest ( $ id , $ request ) ; $ this -> environment -> sendJSONResult ( $ page -> getJSON ( ) ) ; return ; } throw new InvalidParameterException ( "Page already exists" ) ; }
4155	protected function buildRequestHeader ( ) { $ bearerToken = $ this -> bearerToken ; if ( $ this -> bearerToken === null ) { $ bearerToken = $ this -> getBearerToken ( ) ; } return array ( 'Authorization: Bearer ' . rawurlencode ( $ bearerToken ) , 'Expect:' ) ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
7520	function parse_cdata ( ) { if ( $ this -> next_pos ( ']]>' , false ) === self :: TOK_UNKNOWN ) { $ this -> status [ 'cdata' ] = $ this -> getTokenString ( 9 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos + 2 ; return true ; } else { $ this -> addError ( 'Invalid cdata tag' ) ; return false ; } }
12469	protected function replaceNamespace ( $ path ) { $ search = [ 'namespace ' . $ this -> currentRoot . ';' , $ this -> currentRoot . '\\' ] ; $ replace = [ 'namespace ' . $ this -> argument ( 'name' ) . ';' , $ this -> argument ( 'name' ) . '\\' ] ; $ this -> replaceIn ( $ path , $ search , $ replace ) ; }
2239	private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } try { $ connection = DriverManager :: getConnection ( $ params ) ; $ connection -> connect ( ) ; $ connection -> close ( ) ; } catch ( DriverException $ e ) { $ extensionConfigs [ ] = [ 'dbal' => [ 'connections' => [ 'default' => [ 'server_version' => '5.5' , ] , ] , ] , ] ; } return $ extensionConfigs ; }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
4952	protected function checkRatingValue ( $ rating , $ throwException = true ) { if ( ! is_int ( $ rating ) || static :: RATING_EXCELLENT < $ rating || static :: RATING_NONE > $ rating ) { if ( $ throwException ) { throw new \ InvalidArgumentException ( sprintf ( '%s is not a valid rating value.' , $ rating ) ) ; } return false ; } return true ; }
5256	public function setParent ( ElasticsearchModel $ parent ) { $ this -> _parent = $ parent ; $ this -> setParentId ( $ parent -> getId ( ) ) ; }
11725	public function assign ( string $ key , $ value , bool $ global = false ) { if ( $ global === false ) { $ this -> vars [ $ key ] = $ value ; } else { View :: $ global_vars [ $ key ] = $ value ; } return $ this ; }
3822	public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
1638	protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; }
10244	public function getImplementedFunctionNames ( ) { $ returnValue = [ ] ; foreach ( self :: $ phpSpreadsheetFunctions as $ functionName => $ function ) { if ( $ this -> isImplemented ( $ functionName ) ) { $ returnValue [ ] = $ functionName ; } } return $ returnValue ; }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
7170	protected function resolveTargetCountry ( $ target ) : CountryInterface { if ( null === $ target ) { return $ this -> countryProvider -> getCountry ( ) ; } if ( $ target instanceof CountryInterface ) { return $ target ; } if ( $ target instanceof SaleInterface ) { $ country = $ this -> resolveSaleTargetCountry ( $ target ) ; } elseif ( $ target instanceof CustomerInterface ) { $ country = $ this -> resolveCustomerTargetCountry ( $ target ) ; } elseif ( is_string ( $ target ) && 2 == strlen ( $ target ) ) { $ country = $ this -> getCountryByCode ( $ target ) ; } else { throw new InvalidArgumentException ( "Unexpected taxation target." ) ; } return $ country ? : $ this -> countryProvider -> getCountry ( ) ; }
11257	private function all ( ? string $ name ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( is_null ( $ name ) ) { $ array [ ] = [ $ file , $ this -> filesystem -> read ( $ file [ 'path' ] ) ] ; } else { if ( $ file [ 'filename' ] === ( $ name ? : Seed :: DEFAULT_SEED ) ) { $ array [ ] = [ $ file , $ this -> filesystem -> read ( $ file [ 'path' ] ) ] ; break ; } } } return $ array ; }
4352	public function onConfig ( Event $ event ) { $ file = $ this -> debug -> getCfg ( 'file' ) ; $ this -> setFile ( $ file ) ; }
1780	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'calendar' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } $ this -> cal_calendar = $ this -> sortOutProtected ( StringUtil :: deserialize ( $ this -> cal_calendar , true ) ) ; if ( empty ( $ this -> cal_calendar ) || ! \ is_array ( $ this -> cal_calendar ) ) { return '' ; } $ this -> strUrl = preg_replace ( '/\?.*$/' , '' , Environment :: get ( 'request' ) ) ; $ this -> strLink = $ this -> strUrl ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> strLink = $ objTarget -> getFrontendUrl ( ) ; } return parent :: generate ( ) ; }
9695	private function applyInlineStyle ( & $ sheet , $ row , $ column , $ attributeArray ) { if ( ! isset ( $ attributeArray [ 'style' ] ) ) { return ; } $ supported_styles = [ 'background-color' , 'color' ] ; $ styles = explode ( ';' , $ attributeArray [ 'style' ] ) ; foreach ( $ styles as $ st ) { $ value = explode ( ':' , $ st ) ; if ( empty ( trim ( $ value [ 0 ] ) ) || ! in_array ( trim ( $ value [ 0 ] ) , $ supported_styles ) ) { continue ; } if ( substr ( trim ( $ value [ 1 ] ) , 0 , 1 ) == '#' ) { $ style_color = substr ( trim ( $ value [ 1 ] ) , 1 ) ; } if ( empty ( $ style_color ) ) { continue ; } switch ( trim ( $ value [ 0 ] ) ) { case 'background-color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'fill' => [ 'fillType' => Fill :: FILL_SOLID , 'color' => [ 'rgb' => "{$style_color}" ] ] ] ) ; break ; case 'color' : $ sheet -> getStyle ( $ column . $ row ) -> applyFromArray ( [ 'font' => [ 'color' => [ 'rgb' => "$style_color}" ] ] ] ) ; break ; } } }
2048	private function createStatement ( ) : void { if ( null !== $ this -> statement ) { return ; } if ( null === $ this -> container || ! $ this -> container -> has ( $ this -> dbalServiceName ) ) { throw new \ RuntimeException ( 'The container has not been injected or the database service is missing' ) ; } $ connection = $ this -> container -> get ( $ this -> dbalServiceName ) ; $ this -> statement = $ connection -> prepare ( ' INSERT INTO tl_log (tstamp, source, action, username, text, func, browser) VALUES (:tstamp, :source, :action, :username, :text, :func, :browser) ' ) ; }
5270	private function translateUpdate ( ) { $ build = array ( "update {$this->table} set" ) ; $ values = array ( ) ; foreach ( $ this -> statements [ 'values' ] as $ key => $ value ) { $ values [ ] = $ key . ' = ' . $ this -> esc_value ( $ value ) ; } if ( ! empty ( $ values ) ) { $ build [ ] = join ( ', ' , $ values ) ; } if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
210	protected function getValidXmlElementName ( $ name ) { if ( empty ( $ name ) || is_int ( $ name ) || ! $ this -> isValidXmlName ( $ name ) ) { return $ this -> itemTag ; } return $ name ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
7538	function getRoot ( ) { $ r = $ this -> parent ; $ n = ( $ r === null ) ? null : $ r -> parent ; while ( $ n !== null ) { $ r = $ n ; $ n = $ r -> parent ; } return $ r ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
7572	public function post ( Array $ postVars , Array $ headers , $ url = null ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'POST' , $ url , array ( 'multipart' => $ postVars , 'headers' => $ headers ) ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
1998	public function getLocale ( ) : string { foreach ( $ this -> getAcceptedLocales ( ) as $ locale ) { if ( file_exists ( $ this -> translationsDir . '/messages.' . $ locale . '.xlf' ) ) { return $ locale ; } } return 'en' ; }
5626	public function addRequestParameter ( $ key , $ value ) { $ this -> raw = false ; $ this -> request -> add ( $ key , $ value ) ; }
2624	private function sendReqToGA ( $ body = '' , $ method = \ Zend_Http_Client :: POST , $ uri = self :: GA_API_ENDPOINT ) { $ reqGAData = ( array ) $ this -> getGAReqData ( ) ; if ( $ body != '' && is_array ( $ body ) && ! empty ( $ body ) ) { $ body = array_merge ( $ reqGAData , $ body ) ; } try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 10 ) ; $ client -> write ( $ method , $ uri , '1.1' , null , http_build_query ( $ body ) ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; $ client -> close ( ) ; if ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( 'Return status ' . $ responseCode ) ) ; } return true ; } catch ( \ Exception $ e ) { return false ; } }
6291	private function loadTheme ( $ theme ) { if ( ! isset ( $ theme ) ) { return ; } $ th = $ this -> findThemeByDirectory ( $ theme ) ; if ( isset ( $ th ) ) { $ viewFinder = $ this -> view -> getFinder ( ) ; $ viewFinder -> prependPath ( $ th -> getPath ( ) ) ; if ( ! is_null ( $ th -> getParent ( ) ) ) { $ this -> loadTheme ( $ th -> getParent ( ) ) ; } $ this -> activeTheme = $ theme ; } }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
6934	protected function getOperator ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return $ this -> cartOperator ; } elseif ( $ sale instanceof QuoteInterface ) { return $ this -> quoteOperator ; } elseif ( $ sale instanceof OrderInterface ) { return $ this -> orderOperator ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
202	private function queryValueExists ( $ query , $ value ) { if ( is_array ( $ value ) ) { return $ query -> count ( "DISTINCT [[$this->targetAttribute]]" ) == count ( $ value ) ; } return $ query -> exists ( ) ; }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
4085	public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; }
5384	public function setValue ( $ value ) { if ( $ value === false ) { return parent :: setValue ( $ value ) ; } if ( $ value != $ this -> getAttribute ( 'value' ) ) { return false ; } return parent :: setValue ( $ value ) ; }
5179	private function addNew ( string $ key , $ value ) : self { $ this -> props [ $ key ] = $ value ; return $ this ; }
8632	public function setReportRequestInfoList ( $ reportRequestInfo ) { if ( ! $ this -> _isNumericArray ( $ reportRequestInfo ) ) { $ reportRequestInfo = array ( $ reportRequestInfo ) ; } $ this -> fields [ 'ReportRequestInfo' ] [ 'FieldValue' ] = $ reportRequestInfo ; return $ this ; }
9782	private function parseIf ( ) { $ if_open = $ this -> pop ( 'IF_OPEN' ) ; $ output = 'if(' . $ if_open [ 1 ] . ') {' . "\n" ; $ this -> currLine ++ ; $ seeking = true ; while ( $ seeking ) { list ( $ type , $ value ) = $ this -> peek ( ) ; switch ( $ type ) { case 'IF_CLOSE' : $ this -> pop ( ) ; $ output .= "}\n" ; $ seeking = false ; $ this -> currLine ++ ; break ; case 'ELSE' : $ this -> pop ( ) ; $ output .= "} else {\n" ; $ this -> currLine ++ ; break ; case 'ELSE_IF' : $ token = $ this -> pop ( ) ; $ output .= '} elseif(' . $ token [ 1 ] . ") {\n" ; $ this -> currLine ++ ; break ; default : $ output .= $ this -> parseExpression ( ) ; break ; } } return $ output ; }
8847	public function getArchivedBlogPosts ( $ year , $ month = null , $ day = null ) { $ query = $ this -> getBlogPosts ( ) -> dataQuery ( ) ; $ stage = $ query -> getQueryParam ( "Versioned.stage" ) ; if ( $ stage ) $ stage = '_' . Convert :: raw2sql ( $ stage ) ; $ query -> innerJoin ( "BlogPost" , "`SiteTree" . $ stage . "`.`ID` = `BlogPost" . $ stage . "`.`ID`" ) ; $ query -> where ( "YEAR(PublishDate) = '" . Convert :: raw2sql ( $ year ) . "'" ) ; if ( $ month ) { $ query -> where ( "MONTH(PublishDate) = '" . Convert :: raw2sql ( $ month ) . "'" ) ; if ( $ day ) { $ query -> where ( "DAY(PublishDate) = '" . Convert :: raw2sql ( $ day ) . "'" ) ; } } return $ this -> getBlogPosts ( ) -> setDataQuery ( $ query ) ; }
2304	public function createPageList ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( $ this -> User -> isAdmin ) { return $ this -> doCreatePageList ( ) ; } $ return = '' ; $ processed = array ( ) ; foreach ( $ this -> eliminateNestedPages ( $ this -> User -> pagemounts ) as $ page ) { $ objPage = PageModel :: findWithDetails ( $ page ) ; if ( $ objPage -> type == 'root' ) { $ title = $ objPage -> title ; $ start = $ objPage -> id ; } else { $ title = $ objPage -> rootTitle ; $ start = $ objPage -> rootId ; } if ( \ in_array ( $ start , $ processed ) ) { continue ; } if ( $ objPage -> domain && $ objPage -> domain != Environment :: get ( 'host' ) ) { continue ; } $ processed [ ] = $ start ; $ return .= '<optgroup label="' . $ title . '">' . $ this -> doCreatePageList ( $ start ) . '</optgroup>' ; } return $ return ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
12601	public static function write ( $ filename , $ buffer ) { $ fs = new Filesystem ( ) ; try { $ fs -> dumpFile ( $ filename , $ buffer ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( $ e -> getMessage ( ) ) ; } return true ; }
11930	public function getActiveCustomFields ( ) { if ( $ this -> activeCustomFields === null ) { $ this -> activeCustomFields = array ( ) ; foreach ( $ this -> customFields as $ cf ) { if ( $ cf -> isActive ( ) ) { array_push ( $ this -> activeCustomFields , $ cf ) ; } } } return $ this -> activeCustomFields ; }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
4769	public function run ( ) { if ( ! $ this -> is_debug ( ) || ! $ this -> is_debug_display ( ) ) { return ; } $ run = $ this [ 'run' ] ; $ run -> register ( ) ; ob_start ( ) ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
9141	public function getParam ( $ name , $ typeOf = 'string' ) { $ result = $ this -> hasParam ( $ name ) ? $ this -> params [ $ name ] : null ; switch ( $ typeOf ) { case 'bool' : case 'boolean' : $ result = function_exists ( 'boolval' ) ? boolval ( $ result ) : ( bool ) $ result ; break ; case 'double' : case 'float' : $ result = doubleval ( $ result ) ; break ; case 'int' : $ result = intval ( $ result ) ; break ; case 'string' : default : $ result = htmlentities ( strval ( $ result ) ) ; break ; } return $ result ; }
3117	public function getCatValue ( $ testSessionId , $ assessmentSectionId , $ key ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; return $ extendedState -> getCatValue ( $ assessmentSectionId , $ key ) ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
11652	protected function _initRestRoute ( ) { $ front = Zend_Controller_Front :: getInstance ( ) ; $ front -> setResponse ( new Benri_Controller_Response_Http ( ) ) ; $ front -> setRequest ( new Benri_Controller_Request_Http ( ) ) ; $ front -> getRouter ( ) -> addRoute ( 'benri-app' , new Zend_Rest_Route ( $ front ) ) ; }
2700	private function upgrade1010 ( $ newConfigPaths ) { $ oldData = $ this -> scopeConfig -> getValue ( $ newConfigPaths [ 'geoip_country_mapping' ] ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = [ ] ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ newConfigPaths [ 'geoip_country_mapping' ] , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; }
5712	public function addnew ( HTTPRequest $ r ) { return Controller :: curr ( ) -> redirect ( Controller :: join_links ( $ this -> owner -> gridField -> Link ( "item" ) , "new" ) ) ; }
9599	protected function redirect ( $ name , array $ params = array ( ) , $ statusCode = 302 ) { return new RedirectResponse ( $ this -> url ( $ name , $ params ) , $ statusCode ) ; }
10807	public function select ( ) { $ cols = func_get_args ( ) ; return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( false ) -> col ( $ cols ) ; }
11392	public static function getInstance ( ) : Debug { if ( ! ( self :: $ _oInstance instanceof self ) ) { self :: $ _oInstance = new self ( ) ; } return self :: $ _oInstance ; }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
4294	public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; } elseif ( $ val === self :: RECURSION ) { $ type = 'recursion' ; } } elseif ( \ is_array ( $ val ) ) { if ( \ in_array ( self :: ABSTRACTION , $ val , true ) ) { $ type = $ val [ 'type' ] ; $ typeMore = 'abstraction' ; } elseif ( AbstractArray :: isCallable ( $ val ) ) { $ type = 'callable' ; $ typeMore = 'raw' ; } else { $ type = 'array' ; $ typeMore = 'raw' ; } } elseif ( \ is_bool ( $ val ) ) { $ type = 'bool' ; $ typeMore = \ json_encode ( $ val ) ; } elseif ( \ is_float ( $ val ) ) { $ type = 'float' ; } elseif ( \ is_int ( $ val ) ) { $ type = 'int' ; } elseif ( \ is_null ( $ val ) ) { $ type = 'null' ; } elseif ( \ is_object ( $ val ) ) { $ type = 'object' ; $ typeMore = 'raw' ; } elseif ( \ is_resource ( $ val ) || \ strpos ( \ print_r ( $ val , true ) , 'Resource' ) === 0 ) { $ type = 'resource' ; $ typeMore = 'raw' ; } return $ type ; }
5590	public function setIdentity ( $ host , $ realm , $ username , $ password ) { $ this -> authenticator -> setIdentityForRealm ( $ host , $ realm , $ username , $ password ) ; }
8712	public function whereTranslated ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( func_num_args ( ) == 2 ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } elseif ( $ this -> invalidOperatorAndValue ( $ operator , $ value ) ) { throw new InvalidArgumentException ( 'Illegal operator and value combination.' ) ; } if ( ! in_array ( strtolower ( $ operator ) , $ this -> operators , true ) ) { list ( $ value , $ operator ) = [ $ operator , '=' ] ; } $ fallbackColumn = $ this -> qualifyTranslationColumn ( $ column , true ) ; $ column = $ this -> qualifyTranslationColumn ( $ column ) ; if ( ! $ this -> model -> shouldFallback ( ) || $ column instanceof Closure ) { return $ this -> where ( $ column , $ operator , $ value , $ boolean ) ; } $ condition = $ this -> compileIfNull ( $ column , $ fallbackColumn ) ; return $ this -> whereRaw ( "$condition $operator ?" , [ $ value ] , $ boolean ) ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
5305	protected function getPathPart ( SimpleXMLElement $ xmlElement , $ onlyFilled ) { $ path = '' ; if ( $ xmlElement === null ) { $ xmlElement = $ this -> xmlDocument ; } foreach ( $ xmlElement -> children ( ) as $ child ) { $ childName = $ child -> getName ( ) ; if ( ! empty ( $ child [ 'transform' ] ) ) { throw new \ Exception ( 'Transforms are currently not supported!' ) ; } if ( $ childName === 'g' ) { $ path .= ' ' . $ this -> getPathPart ( $ child , $ onlyFilled ) ; } else { if ( $ onlyFilled && ( string ) $ child [ 'fill' ] === 'none' ) { continue ; } if ( $ childName === 'polygon' ) { $ path .= ' ' . $ this -> getPathFromPolygon ( $ child ) ; } elseif ( $ childName === 'rect' ) { $ path .= ' ' . $ this -> getPathFromRect ( $ child ) ; } elseif ( $ childName === 'circle' ) { $ path .= ' ' . $ this -> getPathFromCircle ( $ child ) ; } elseif ( $ childName === 'ellipse' ) { $ path .= ' ' . $ this -> getPathFromEllipse ( $ child ) ; } elseif ( $ childName === 'path' ) { $ pathPart = trim ( $ child [ 'd' ] ) ; if ( substr ( $ pathPart , 0 , 1 ) === 'm' ) { $ pathPart = 'M' . substr ( $ pathPart , 1 ) ; } $ path .= ' ' . $ pathPart ; } } } return trim ( $ path ) ; }
12649	public function build ( ) { $ assetManager = new AssetManager ( ) ; $ filterManager = new FilterManager ( ) ; foreach ( $ this -> filters as $ filterName => $ filter ) { $ filterManager -> set ( $ filterName , $ filter ) ; } $ assetsFactory = new AssetFactory ( $ this -> configurationHandler -> webDir ( ) ) ; $ assetsFactory -> setAssetManager ( $ assetManager ) ; $ assetsFactory -> setFilterManager ( $ filterManager ) ; return $ assetsFactory ; }
7709	function GetInnerSrc ( ) { return ( $ this -> pET_PosBeg === false ) ? false : substr ( $ this -> Txt , $ this -> pST_PosEnd + 1 , $ this -> pET_PosBeg - $ this -> pST_PosEnd - 1 ) ; }
2446	public function checkPermission ( ) { switch ( Contao \ Input :: get ( 'act' ) ) { case 'select' : case 'show' : break ; case 'edit' : case 'delete' : case 'toggle' : $ objComment = $ this -> Database -> prepare ( "SELECT id, parent, source FROM tl_comments WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objComment -> numRows < 1 ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid comment ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' comment ID ' . Contao \ Input :: get ( 'id' ) . ' (parent element: ' . $ objComment -> source . ' ID ' . $ objComment -> parent . ').' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; if ( empty ( $ session [ 'CURRENT' ] [ 'IDS' ] ) || ! \ is_array ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ) { break ; } $ objComment = $ this -> Database -> execute ( "SELECT id, parent, source FROM tl_comments WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) . ")" ) ; while ( $ objComment -> next ( ) ) { if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) && ( $ key = array_search ( $ objComment -> id , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) !== false ) { unset ( $ session [ 'CURRENT' ] [ 'IDS' ] [ $ key ] ) ; } } $ session [ 'CURRENT' ] [ 'IDS' ] = array_values ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ; $ objSession -> replace ( $ session ) ; break ; default : if ( \ strlen ( Contao \ Input :: get ( 'act' ) ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid command "' . Contao \ Input :: get ( 'act' ) . '.' ) ; } break ; } }
11175	public static function verify ( $ real , $ hash ) { $ hash = base64_decode ( $ hash ) ; return crypt ( $ real , $ hash ) == $ hash ; }
6685	public function sendFailResponse ( $ data , $ httpStatusCode = 500 ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( $ httpStatusCode , $ this -> httpStatuses -> getReasonPhrase ( $ httpStatusCode ) ) ; return [ 'status' => 'fail' , 'data' => $ data ] ; }
12484	protected function getDefaultOptionIds ( ) { $ optionIds = [ ] ; $ defaultDefinition = $ this -> getDefaultInputDefinition ( ) ; foreach ( $ defaultDefinition -> getOptions ( ) as $ option ) { $ optionIds [ ] = $ option -> getName ( ) ; } ; return $ optionIds ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
6330	private function registerEffect ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( Effect :: class , $ interfaces , true ) ) { $ this -> effectsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . Effect :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
9434	public function rho ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ float_min < 0 || $ float_max < 0 ) { throw new \ InvalidArgumentException ( 'Rho value must be a positive number!' ) ; } if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set rho value, because algebraic form is in use.' ) ; } $ this -> rho = new \ stdClass ( ) ; $ this -> rho -> min = $ float_min ; $ this -> rho -> max = $ float_max ; return $ this ; }
6981	static public function factory ( $ type = 'html' , array $ params = null ) { if ( ! isset ( $ type ) || ! strcasecmp ( $ type , 'html' ) ) return ( new Html \ Renderer ( $ params ) ) ; throw new \ Exception ( "Unknown Skriv rendering type '$type'." ) ; }
6890	protected function removeAssignment ( StockAssignmentInterface $ assignment ) { $ this -> unitUpdater -> updateSold ( $ assignment -> getStockUnit ( ) , - $ assignment -> getSoldQuantity ( ) , true ) ; $ assignment -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> persistenceHelper -> remove ( $ assignment ) ; }
1989	public static function addToUrl ( $ strRequest , $ blnIgnoreParams = false , $ arrUnset = array ( ) ) { $ arrGet = $ blnIgnoreParams ? array ( ) : $ _GET ; foreach ( array_keys ( $ arrGet ) as $ key ) { $ arrGet [ $ key ] = Input :: get ( $ key , true , true ) ; } $ arrFragments = preg_split ( '/&(amp;)?/i' , $ strRequest ) ; foreach ( $ arrFragments as $ strFragment ) { list ( $ key , $ value ) = explode ( '=' , $ strFragment ) ; if ( $ value == '' ) { unset ( $ arrGet [ $ key ] ) ; } else { $ arrGet [ $ key ] = $ value ; } } if ( Config :: get ( 'addLanguageToUrl' ) ) { unset ( $ arrGet [ 'language' ] ) ; } $ strParams = '' ; $ strConnector = '/' ; $ strSeparator = '/' ; foreach ( $ arrGet as $ k => $ v ) { if ( Config :: get ( 'useAutoItem' ) && ( $ k == 'auto_item' || \ in_array ( $ k , $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) ) { $ strParams = $ strConnector . urlencode ( $ v ) . $ strParams ; } else { $ strParams .= $ strConnector . urlencode ( $ k ) . $ strSeparator . urlencode ( $ v ) ; } } global $ objPage ; $ pageId = $ objPage -> alias ? : $ objPage -> id ; if ( empty ( $ pageId ) ) { $ pageId = static :: getPageIdFromUrl ( ) ; } $ arrParams = array ( ) ; $ arrParams [ 'alias' ] = $ pageId . $ strParams ; if ( Config :: get ( 'addLanguageToUrl' ) ) { $ arrParams [ '_locale' ] = $ objPage -> rootLanguage ; } $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_frontend' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return $ strUrl ; }
7930	public function setCollection ( array $ collection ) { list ( $ collection ) = $ this -> fireEvent ( 'collection.set' , [ $ collection ] ) ; $ this -> collection = [ ] ; foreach ( $ collection as $ asset ) { $ this -> appendToCollection ( $ asset ) ; } return $ this ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
12524	public function deserializeJSON ( $ jsonString ) { $ data = json_decode ( $ jsonString ) ; $ this -> setContent ( $ data -> content ) ; $ this -> setContext ( $ data -> context ) ; }
6161	public function addPropertyRequest ( $ item ) { if ( ! ( $ item instanceof PropertyRequest ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyRequest ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyRequest. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyRequest"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
9653	public function addLoader ( $ extensions , $ loaderClass ) { foreach ( ( array ) $ extensions as $ extension ) { $ this -> extensions [ ] = $ extension ; if ( is_string ( $ loaderClass ) ) { $ this -> loaderClasses [ $ extension ] = $ loaderClass ; } elseif ( $ loaderClass instanceof LoaderInterface ) { $ this -> loaders [ $ extension ] = $ loaderClass ; } } }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
11832	public function getCache ( ) { if ( ! $ this -> cache ) { $ services = $ this -> getServices ( ) ; $ cache = $ services -> get ( 'Cache' ) ; $ this -> setCache ( $ cache ) ; } return $ this -> cache ; }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
10236	private function writeDefaultContentType ( XMLWriter $ objWriter , $ pPartname , $ pContentType ) { if ( $ pPartname != '' && $ pContentType != '' ) { $ objWriter -> startElement ( 'Default' ) ; $ objWriter -> writeAttribute ( 'Extension' , $ pPartname ) ; $ objWriter -> writeAttribute ( 'ContentType' , $ pContentType ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
7706	function _ApplyDiffFromStart ( $ Diff ) { $ this -> pST_PosEnd += $ Diff ; $ this -> pST_Src = false ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; }
8734	public function increment ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> increment ( $ column , $ amount , $ extra ) ; }
144	public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
10859	protected function cacheMarkers ( string $ marker ) : void { $ this -> marked [ $ marker ] = [ ] ; foreach ( $ this -> definitions as $ definition ) { foreach ( ( array ) $ definition -> markers as $ m ) { if ( $ m instanceof $ marker ) { $ this -> marked [ $ marker ] [ ] = [ $ definition , $ m ] ; } } } }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1016	public static function isBuiltInType ( Type $ type ) { return in_array ( $ type -> name , array_keys ( self :: getAllBuiltInTypes ( ) ) , true ) ; }
2766	public function isAhead ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is ahead.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ localSha = $ this -> run ( 'rev-parse' , [ '@' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha && $ localSha !== $ remoteSha ; }
9538	private function getRealName ( $ param ) { $ parameterClosure = $ this -> getParameterClosure ( $ param ) ; if ( $ parameterClosure -> parent != null ) { return $ parameterClosure -> parent -> parameterName ; } else { return $ parameterClosure -> parameterName ; } }
2038	private function applyLegacyLogic ( $ strUrl , $ strParams ) { if ( strpos ( $ strParams , '%' ) !== false ) { @ trigger_error ( 'Using sprintf placeholders in URLs has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ arrMatches = array ( ) ; preg_match_all ( '/%([sducoxXbgGeEfF])/' , $ strParams , $ arrMatches ) ; foreach ( array_unique ( $ arrMatches [ 1 ] ) as $ v ) { $ strUrl = str_replace ( '%25' . $ v , '%' . $ v , $ strUrl ) ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] ) ) { @ trigger_error ( 'Using the "generateFrontendUrl" hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateFrontendUrl' ] as $ callback ) { $ strUrl = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this -> row ( ) , $ strParams , $ strUrl ) ; } return $ strUrl ; } return $ strUrl ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
6512	public function updateJob ( EntityJobInterface $ job , Status $ status , $ processingTime = 0 , $ response = null ) { $ job -> setStatus ( $ status ) ; $ job -> setProcessingTime ( $ job -> getProcessingTime ( ) + ( $ processingTime === null ? 0 : $ processingTime ) ) ; $ job -> setResponse ( $ response ) ; if ( Status :: isTerminated ( $ status ) ) { $ job -> setTerminatedAt ( new \ DateTime ( ) ) ; } if ( $ job -> hasSchedules ( ) && Status :: isTerminated ( $ status ) ) { foreach ( $ job -> getSchedules ( ) as $ schedule ) { if ( method_exists ( $ schedule , 'setIsActive' ) ) { $ schedule -> setIsActive ( false ) ; } } } }
2841	public function renderArray ( $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ block -> setTemplate ( 'sheep_debug/view/panel/_array.phtml' ) ; $ block -> setData ( 'array' , $ data ) ; $ block -> setData ( 'no_data_label' , $ noDataLabel ) ; $ block -> setData ( 'header' , $ header ) ; return $ block -> toHtml ( ) ; }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
304	private function resetDependentRelations ( $ attribute ) { foreach ( $ this -> _relationsDependencies [ $ attribute ] as $ relation ) { unset ( $ this -> _related [ $ relation ] ) ; } unset ( $ this -> _relationsDependencies [ $ attribute ] ) ; }
34	protected function jobToText ( $ job ) { $ packageName = $ job [ 'packageName' ] ; $ constraint = $ job [ 'constraint' ] ; switch ( $ job [ 'cmd' ] ) { case 'install' : $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; if ( ! $ packages ) { return 'No package found to satisfy install request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) ; } return 'Installation request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . ' -> satisfiable by ' . $ this -> getPackageList ( $ packages ) . '.' ; case 'update' : return 'Update request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '.' ; case 'remove' : return 'Removal request for ' . $ packageName . $ this -> constraintToText ( $ constraint ) . '' ; } if ( isset ( $ constraint ) ) { $ packages = $ this -> pool -> whatProvides ( $ packageName , $ constraint ) ; } else { $ packages = array ( ) ; } return 'Job(cmd=' . $ job [ 'cmd' ] . ', target=' . $ packageName . ', packages=[' . $ this -> getPackageList ( $ packages ) . '])' ; }
6871	private function initializeMethod ( ShipmentInterface $ shipment ) { if ( null !== $ shipment -> getMethod ( ) ) { return ; } $ sale = $ shipment -> getSale ( ) ; if ( null === $ method = $ sale -> getShipmentMethod ( ) ) { return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_SHIPMENT ) ) { $ shipment -> setMethod ( $ method ) ; return ; } if ( $ shipment -> isReturn ( ) && $ gateway -> supports ( GatewayInterface :: CAPABILITY_RETURN ) ) { $ shipment -> setMethod ( $ method ) ; return ; } }
11446	public function getSpooler ( ) { if ( empty ( $ this -> spooler ) ) { $ spool_class = $ this -> getDefault ( 'spooler' ) ; if ( class_exists ( $ spool_class ) ) { $ this -> setSpooler ( new $ spool_class ) ; } else { throw new \ Exception ( sprintf ( 'Default spool class "%s" not found!' , $ spool_class ) ) ; } } return $ this -> spooler ; }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
7434	private function getDirContents ( $ dir , & $ results = [ ] ) { $ files = scandir ( $ dir ) ; foreach ( $ files as $ value ) { $ path = realpath ( $ dir . DIRECTORY_SEPARATOR . $ value ) ; if ( ! is_dir ( $ path ) ) { $ results [ ] = $ path ; continue ; } if ( $ value != '.' && $ value != '..' ) { $ this -> getDirContents ( $ path , $ results ) ; $ results [ ] = $ path ; } } return $ results ; }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
11929	public function setDataInterface ( $ value ) { if ( ( $ interfaceItem = Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getOne ( $ value ) ) && ( $ interface = $ interfaceItem -> object ) ) { $ this -> _interface = $ interfaceItem ; } else { throw new Exception ( "Invalid interface!" ) ; } }
7558	public function query ( $ query = '*' ) { $ select = $ this -> select ( $ query ) ; $ result = new \ pQuery ( ( array ) $ select ) ; return $ result ; }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
2098	public static function formatToJs ( $ strFormat ) { $ chunks = str_split ( $ strFormat ) ; foreach ( $ chunks as $ k => $ v ) { switch ( $ v ) { case 'D' : $ chunks [ $ k ] = 'a' ; break ; case 'j' : $ chunks [ $ k ] = 'e' ; break ; case 'l' : $ chunks [ $ k ] = 'A' ; break ; case 'S' : $ chunks [ $ k ] = 'o' ; break ; case 'F' : $ chunks [ $ k ] = 'B' ; break ; case 'M' : $ chunks [ $ k ] = 'b' ; break ; case 'a' : $ chunks [ $ k ] = 'p' ; break ; case 'A' : $ chunks [ $ k ] = 'p' ; break ; case 'g' : $ chunks [ $ k ] = 'l' ; break ; case 'G' : $ chunks [ $ k ] = 'k' ; break ; case 'h' : $ chunks [ $ k ] = 'I' ; break ; case 'i' : $ chunks [ $ k ] = 'M' ; break ; case 's' : $ chunks [ $ k ] = 'S' ; break ; case 'U' : $ chunks [ $ k ] = 's' ; break ; } } return preg_replace ( '/([a-zA-Z])/' , '%$1' , implode ( '' , $ chunks ) ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
5221	public function sourcePathes ( ) { $ vendorPathes = [ ] ; foreach ( array_merge ( $ this -> loadPsr0Pathes ( ) , $ this -> loadPsr4Pathes ( ) ) as $ pathes ) { if ( is_array ( $ pathes ) ) { $ vendorPathes = array_merge ( $ vendorPathes , $ pathes ) ; } else { $ vendorPathes [ ] = $ pathes ; } } return $ vendorPathes ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1061	public static function findValuesAddedToEnums ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ valuesAddedToEnums = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof EnumType ) || ! ( $ newType instanceof EnumType ) ) { continue ; } $ valuesInOldEnum = [ ] ; foreach ( $ oldType -> getValues ( ) as $ value ) { $ valuesInOldEnum [ $ value -> name ] = true ; } foreach ( $ newType -> getValues ( ) as $ value ) { if ( isset ( $ valuesInOldEnum [ $ value -> name ] ) ) { continue ; } $ valuesAddedToEnums [ ] = [ 'type' => self :: DANGEROUS_CHANGE_VALUE_ADDED_TO_ENUM , 'description' => sprintf ( '%s was added to enum type %s.' , $ value -> name , $ typeName ) , ] ; } } return $ valuesAddedToEnums ; }
10064	public function all ( ) { $ meta = $ this -> metaModel :: get ( [ 'key' , 'value' , 'type' ] ) ; $ data = [ ] ; foreach ( $ meta as $ m ) { $ data [ $ m -> key ] = $ m -> value ; } return $ data ; }
3001	public function setHTML ( $ message ) { $ f3 = \ Base :: instance ( ) ; $ tmpl = new \ Template ( ) ; if ( $ f3 -> exists ( 'mailer.jumplinks' , $ jumplink ) && $ jumplink ) $ tmpl -> extend ( 'a' , function ( $ node ) use ( $ f3 , $ tmpl ) { if ( isset ( $ node [ '@attrib' ] ) ) { $ attr = $ node [ '@attrib' ] ; unset ( $ node [ '@attrib' ] ) ; } else $ attr = array ( ) ; if ( isset ( $ attr [ 'href' ] ) ) { if ( ! $ f3 -> exists ( 'mailer.jump_route' , $ ping_route ) ) $ ping_route = '/mailer-jump' ; $ attr [ 'href' ] = $ f3 -> get ( 'SCHEME' ) . '://' . $ f3 -> get ( 'HOST' ) . $ f3 -> get ( 'BASE' ) . $ ping_route . '?target=' . urlencode ( $ attr [ 'href' ] ) ; } $ params = '' ; foreach ( $ attr as $ key => $ value ) $ params .= ' ' . $ key . '="' . $ value . '"' ; return '<a' . $ params . '>' . $ tmpl -> build ( $ node ) . '</a>' ; } ) ; $ message = $ tmpl -> build ( $ tmpl -> parse ( $ message ) ) ; $ this -> setContent ( $ message , 'text/html' ) ; }
10782	public function andHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
4950	public function createDraft ( array $ data = null , $ persist = false ) { $ data [ 'isDraft' ] = true ; return $ this -> create ( $ data , $ persist ) ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
9764	function equal ( $ value ) : self { if ( $ this -> hasFlag ( 'file' ) ) { if ( $ this -> hasFlag ( 'negate' ) ) assertFileNotEquals ( $ value , $ this -> target , $ this -> message ) ; else assertFileEquals ( $ value , $ this -> target , $ this -> message ) ; return $ this ; } $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , equalTo ( $ value ) ) ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
7882	public function getIndex ( ) { $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; if ( Session :: has ( 'success' ) || Session :: has ( 'error' ) ) { Session :: reflash ( ) ; } return Redirect :: to ( 'logviewer/' . $ today . '/all' ) ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
4268	public function dir_opendir ( $ path , $ options = 0 ) { if ( $ this -> handle ) { return false ; } array ( $ options ) ; self :: restorePrev ( ) ; $ this -> handle = \ opendir ( $ path ) ; self :: register ( ) ; return $ this -> handle !== false ; }
2042	public static function validateSymlink ( string $ target , string $ link , string $ rootDir ) : void { if ( '' === $ target ) { throw new \ InvalidArgumentException ( 'The symlink target must not be empty.' ) ; } if ( '' === $ link ) { throw new \ InvalidArgumentException ( 'The symlink path must not be empty.' ) ; } if ( false !== strpos ( $ link , '../' ) ) { throw new \ InvalidArgumentException ( 'The symlink path must not be relative.' ) ; } $ fs = new Filesystem ( ) ; if ( $ fs -> exists ( $ rootDir . '/' . $ link ) && ! is_link ( $ rootDir . '/' . $ link ) ) { throw new \ LogicException ( sprintf ( 'The path "%s" exists and is not a symlink.' , $ link ) ) ; } }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
10833	public function on ( $ column1 , $ op , $ column2 ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::on()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "ON" , $ table , $ type , $ column1 , $ op , $ column2 ) ; return $ this ; }
11115	public function reset ( ) : void { $ migrations = array_reverse ( $ this -> repository -> getRan ( ) ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
5097	private function appendByField ( $ values ) { $ fixed = array ( ) ; foreach ( $ this -> fields as $ field ) { $ fixed [ ] = $ values [ $ field ] ; } return $ this -> appendByPosition ( $ fixed ) ; }
3383	public function authenticate ( ) { $ user = $ this -> findUser ( ) ; if ( $ user === false ) { return new AuthenticationResult ( AuthenticationResult :: FAILURE_IDENTITY_NOT_FOUND , array ( ) , array ( 'User not found.' ) ) ; } $ validationResult = $ this -> passwordValidator -> isValid ( $ this -> credential , $ user [ $ this -> credentialColumn ] , $ user [ $ this -> identityColumn ] ) ; if ( $ validationResult -> isValid ( ) ) { unset ( $ user [ $ this -> getCredentialColumn ( ) ] ) ; return new AuthenticationResult ( AuthenticationResult :: SUCCESS , $ user , array ( ) ) ; } return new AuthenticationResult ( AuthenticationResult :: FAILURE_CREDENTIAL_INVALID , array ( ) , array ( 'Invalid username or password provided' ) ) ; }
2104	public function getTemplates ( ) : array { $ finder = Finder :: create ( ) -> files ( ) -> name ( '*.sql' ) -> in ( $ this -> rootDir . '/templates' ) ; $ templates = [ ] ; foreach ( $ finder as $ file ) { $ templates [ ] = $ file -> getRelativePathname ( ) ; } return $ templates ; }
6455	public function textual ( ) { $ this -> restrictElements ( [ 'textarea' => [ ] , 'input' => [ ] , ] ) ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , $ this -> value , $ this -> tag , ] ) ; $ this -> assert ( trim ( $ this -> expected ) === $ this -> value ) ; }
9921	private function findManyToManyRelations ( array $ models ) { for ( $ i = 0 ; $ i < sizeof ( $ models ) ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < sizeof ( $ models ) ; $ j ++ ) { $ model1 = $ models [ $ i ] ; $ model2 = $ models [ $ j ] ; if ( strcasecmp ( $ model1 -> getName ( ) , $ model2 -> getName ( ) ) < 0 ) { $ tableName = strtolower ( $ model1 -> getName ( ) ) . '_' . strtolower ( $ model2 -> getName ( ) ) ; } else { $ tableName = strtolower ( $ model2 -> getName ( ) ) . '_' . strtolower ( $ model1 -> getName ( ) ) ; } if ( $ this -> databaseRepository -> hasTable ( $ tableName ) ) { $ this -> defineManyToManyRelation ( $ model1 , $ model2 ) ; } } } }
9043	protected function logImpl ( $ level , $ message , array $ context = array ( ) ) { if ( ! $ this -> levelHasReached ( $ level ) ) { return ; } if ( $ this -> isRotationNeeded ( ) ) { unlink ( $ this -> file ) ; } $ ms = $ this -> getMessage ( $ level , $ message , $ context ) ; $ fos = new FileOutputStream ( $ this -> file , true ) ; $ fos -> write ( $ ms ) ; $ fos -> flush ( ) ; $ fos -> close ( ) ; }
2070	public function deletePage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ root = func_get_arg ( 7 ) ; return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_DELETE_PAGE , $ row ) && ( $ this -> User -> isAdmin || ! \ in_array ( $ row [ 'id' ] , $ root ) ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
7388	public function fetch ( string $ key , $ default = null ) { if ( isset ( $ _SERVER [ $ key ] ) ) { return $ _SERVER [ $ key ] ; } else { $ key = 'HTTP_' . $ key ; return $ _SERVER [ $ key ] ?? $ default ; } }
11383	protected function build ( $ stage ) { if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } if ( $ this -> container -> has ( $ stage ) ) { $ stage = $ this -> container -> get ( $ stage ) ; if ( $ stage instanceof RequestHandlerInterface ) { return new RequestHandler ( $ stage ) ; } if ( $ stage instanceof MiddlewareInterface ) { return $ stage ; } throw new \ RuntimeException ( "Stage is not a valid " . MiddlewareInterface :: class ) ; } if ( method_exists ( $ this -> container , 'newInstance' ) ) { return $ this -> container -> newInstance ( $ stage ) ; } throw new \ RuntimeException ( "Unable to resolve $stage" ) ; }
3331	public function fromResource ( $ fp ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; while ( ! feof ( $ fp ) ) { fwrite ( $ temp , fread ( $ fp , 8192 ) ) ; } fclose ( $ temp ) ; fclose ( $ fp ) ; return $ this -> fromPath ( $ tmpfile ) ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
8790	public function linkAsset ( $ url , $ title = null , $ attributes = [ ] , $ secure = null ) { $ url = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> link ( $ url , $ title ? : $ url , $ attributes , $ secure ) ; }
2843	public function getBlockTreeHtml ( ) { $ content = '' ; $ rootNodes = $ this -> getBlocksAsTree ( ) ; foreach ( $ rootNodes as $ rootNode ) { $ content .= $ this -> renderTreeNode ( $ rootNode ) ; } return $ content ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
5822	public function renderFlashAlerts ( array $ options = array ( ) ) { $ options = $ this -> resolveOptions ( $ options ) ; return $ this -> templating -> render ( $ options [ 'template' ] , $ options ) ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
5234	public function withEntry ( $ key , $ value ) { $ this -> bindings [ $ key ] = $ this -> getValueCreator ( $ value ) ; return $ this ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
7924	public function extract ( $ zipFile , $ targetPath ) { $ zipArchive = $ this -> openZipFile ( $ zipFile ) ; $ targetPath = $ this -> fixPath ( $ targetPath ) ; $ filenames = $ this -> extractFilenames ( $ zipArchive ) ; if ( $ zipArchive -> extractTo ( $ targetPath , $ filenames ) === false ) { throw new \ Exception ( $ this -> getError ( $ zipArchive -> status ) ) ; } $ zipArchive -> close ( ) ; return $ filenames ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
8172	private function getSourceExcerpt ( $ source = '' , $ line = 1 , $ plus = 1 , $ format = false ) { $ excerpt = [ ] ; $ twig = Escape :: html ( $ source ) ; $ lines = preg_split ( "/(\r\n|\n|\r)/" , $ twig ) ; $ start = max ( 1 , $ line - $ plus ) ; $ limit = min ( count ( $ lines ) , $ line + $ plus ) ; for ( $ i = $ start - 1 ; $ i < $ limit ; $ i ++ ) { if ( $ format ) { $ attr = 'data-line="' . ( $ i + 1 ) . '"' ; if ( $ i === $ line - 1 ) $ excerpt [ ] = "<mark $attr>$lines[$i]</mark>" ; else $ excerpt [ ] = "<span $attr>$lines[$i]</span>" ; } else { $ excerpt [ ] = $ lines [ $ i ] ; } } return implode ( "\n" , $ excerpt ) ; }
3233	static function useExternalPaths ( ) { if ( ! self :: $ useExternalFile and self :: $ paths !== null ) { throw new \ Exception ( "You called \"useExternalFile\" too late. The SDK already used the root " . "certificate file (probably to make an API call)." ) ; } self :: $ useExternalFile = true ; }
9949	public function getStyleByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 = null , $ row2 = null ) { if ( $ columnIndex2 !== null && $ row2 !== null ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> getStyle ( $ cellRange ) ; } return $ this -> getStyle ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 ) ; }
11682	public function init ( ) { $ request = $ this -> getRequest ( ) ; if ( $ request -> isGet ( ) ) { $ action = $ this -> getParam ( 'id' ) ? 'get' : 'index' ; } else { $ action = $ this -> getParam ( 'x-method' , $ request -> getMethod ( ) ) ; } $ request -> setActionName ( $ action ) -> setDispatched ( false ) -> setParam ( 'action' , $ action ) ; }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
7796	protected function accountNumber ( $ text ) { $ format = $ this -> format == self :: FORMAT_CLASSIC ? '/^[0-9.]+/' : '/^[0-9A-Z]+/' ; if ( $ account = $ this -> getLine ( '25' , $ text ) ) { if ( preg_match ( $ format , $ account , $ match ) ) { return str_replace ( '.' , '' , $ match [ 0 ] ) ; } } return null ; }
2039	private function createConfig ( $ size ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new PictureConfiguration ( ) ; $ attributes = [ ] ; if ( ! isset ( $ size [ 2 ] ) || ! is_numeric ( $ size [ 2 ] ) ) { $ resizeConfig = new ResizeConfiguration ( ) ; if ( ! empty ( $ size [ 0 ] ) ) { $ resizeConfig -> setWidth ( ( int ) $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ resizeConfig -> setHeight ( ( int ) $ size [ 1 ] ) ; } if ( ! empty ( $ size [ 2 ] ) ) { $ resizeConfig -> setMode ( $ size [ 2 ] ) ; } $ configItem = new PictureConfigurationItem ( ) ; $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( $ this -> defaultDensities ) { $ configItem -> setDensities ( $ this -> defaultDensities ) ; } $ config -> setSize ( $ configItem ) ; return [ $ config , $ attributes ] ; } $ imageSizeModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSizes = $ imageSizeModel -> findByPk ( $ size [ 2 ] ) ; $ config -> setSize ( $ this -> createConfigItem ( $ imageSizes ) ) ; if ( $ imageSizes && $ imageSizes -> cssClass ) { $ attributes [ 'class' ] = $ imageSizes -> cssClass ; } $ imageSizeItemModel = $ this -> framework -> getAdapter ( ImageSizeItemModel :: class ) ; $ imageSizeItems = $ imageSizeItemModel -> findVisibleByPid ( $ size [ 2 ] , [ 'order' => 'sorting ASC' ] ) ; if ( null !== $ imageSizeItems ) { $ configItems = [ ] ; foreach ( $ imageSizeItems as $ imageSizeItem ) { $ configItems [ ] = $ this -> createConfigItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ configItems ) ; } return [ $ config , $ attributes ] ; }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
11831	public static function create ( $ command , $ app ) { static $ cache = [ ] ; $ cacheKey = $ command ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ command = $ cache [ $ cacheKey ] [ 'command' ] ; } else { if ( false === strpos ( $ command , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ command ) ; } else { $ class = explode ( '.' , $ command ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ command = substr ( $ command , strrpos ( $ command , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'command' => $ command ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow command ' . $ cacheKey ) ; } return new $ class ( $ app ) ; }
5709	public function getButtonName ( ) { $ raw = $ this -> buttonName ? : $ this -> getButtonText ( ) ; return preg_replace ( '/[^a-z0-9-_]/' , '' , strtolower ( $ this -> getButtonText ( ) ) ) ; }
12245	public function sortChildren ( ) { $ nodes = $ this -> removeNodes ( '*' ) ; $ args = func_get_args ( ) ; array_unshift ( $ args , null ) ; $ args [ 0 ] = & $ nodes ; call_user_func_array ( array ( get_class ( $ this ) , 'sort' ) , $ args ) ; foreach ( $ nodes as $ node ) { $ this -> appendChild ( $ node ) ; } return $ this ; }
9745	public function setCity ( $ city ) { if ( ! ( $ city instanceof City ) ) { $ city = new City ( $ city ) ; } if ( $ city -> isEmpty ( ) ) { $ this -> invalidArguments ( '10003' ) ; } return $ this -> setParameter ( 'city' , $ city ) ; }
11572	public function process ( $ structureName , $ origin ) { $ def = $ this -> structures [ $ structureName ] ; $ data = array_merge ( $ def -> getEmptyValues ( ) , $ this -> source -> fetchData ( $ structureName , $ origin ) ) ; $ accessor = new PropertyAccess ( ) ; foreach ( $ def -> getChildren ( ) as $ childDef ) { $ data = array_merge ( $ data , $ this -> modifyPlaceholders ( $ this -> process ( $ childDef [ 'name' ] , $ accessor -> get ( $ data , $ childDef [ 'name' ] ) ) , $ childDef [ 'prefix' ] , $ childDef [ 'suffix' ] ) ) ; unset ( $ data [ $ childDef [ 'name' ] ] ) ; } return $ data ; }
6949	private function getByCountryAndCustomerQuery ( ) { if ( null === $ this -> byCountryAndCustomerQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndCustomerQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.customer' , ':customer' ) ) -> getQuery ( ) -> setParameter ( 'customer' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndCustomerQuery ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
6416	public static function skip ( IteratorAggregate $ iterable , int $ numberToSkip ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ numberToSkip ) { $ iterator = Iterators :: from ( $ iterable -> getIterator ( ) ) ; Iterators :: advance ( $ iterator , $ numberToSkip ) ; return $ iterator ; } ) ; }
9295	public function buildCustomFields ( $ form_fields = [ ] , $ config_name = 'custom_form' ) { $ fields = collect ( $ form_fields ) -> map ( function ( $ field , $ name ) use ( $ config_name ) { return $ this -> render ( isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' , [ $ name , $ field [ 'label' ] , [ 'data-table' => $ config_name ] ] ) ; } ) ; return $ fields ; }
6897	public function bind ( $ key , & $ value ) { $ this -> open ( ) ; $ this -> _data [ $ key ] = & $ value ; return $ this ; }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
4068	public function configure ( MetaModelsServiceContainer $ serviceContainer ) { $ serviceContainer -> setEventDispatcher ( function ( ) { return $ this -> container -> get ( 'event_dispatcher' ) ; } ) -> setDatabase ( function ( ) { return $ this -> container -> get ( 'cca.legacy_dic.contao_database_connection' ) ; } ) -> setAttributeFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.attribute_factory' ) ; } ) -> setFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.factory' ) ; } ) -> setFilterFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.filter_setting_factory' ) ; } ) -> setRenderSettingFactory ( function ( ) { return $ this -> container -> get ( 'metamodels.render_setting_factory' ) ; } ) -> setCache ( function ( ) { return $ this -> container -> get ( 'metamodels.cache' ) ; } ) ; return $ serviceContainer ; }
6559	public function get_number_type ( $ phone_number = '' , $ region = NULL ) { $ inputParams = array ( 'phone_number' => $ phone_number , 'region' => $ region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; if ( empty ( $ phone_number ) ) { $ this -> debug -> warning ( __FUNCTION__ , 'Phone Number input is Empty!' ) ; return NULL ; } $ phone_number = trim ( $ phone_number ) ; try { $ phoneNumberUtil = PhoneNumberUtil :: getInstance ( ) ; $ use_region = NULL !== $ region ? strtoupper ( $ region ) : self :: DEFAULT_REGION ; $ phoneNumberObject = $ phoneNumberUtil -> parse ( trim ( $ phone_number ) , $ use_region ) ; $ result = $ phoneNumberUtil -> getNumberType ( $ phoneNumberObject ) ; $ this -> debug -> debug ( __FUNCTION__ , 'Use REGION: ' . $ use_region ) ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result: ' . $ result ) ; return $ result ; } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } }
7731	public function supportsNormalization ( $ data , $ format = null ) { return is_object ( $ data ) && ( $ data instanceof \ DateTime ) && ( self :: FORMAT === $ format ) ; }
11262	public static function main ( $ argv , ContainerInterface $ container = null ) { $ output = self :: cyanLine ( $ argv ) ; $ app = new Application ( '' ) ; $ app -> add ( new MigrateMakeCommand ( ) ) ; $ app -> add ( new MigrateUpCommand ( $ container ) ) ; $ app -> add ( new MigrateDownCommand ( ) ) ; $ app -> add ( new MigrateResetCommand ( ) ) ; $ app -> add ( new MigrateStatusCommand ( ) ) ; $ app -> add ( new MigrateRefreshCommand ( ) ) ; $ app -> add ( new MigrateFreshCommand ( $ container ) ) ; $ app -> add ( new MigrateDropCommand ( ) ) ; $ app -> add ( new SeedRunCommand ( $ container ) ) ; $ app -> add ( new SeedMakeCommand ( ) ) ; $ app -> add ( new BinMakeCommand ( ) ) ; $ app -> run ( null , $ output ) ; }
5173	public static function createArticle ( String $ title , string $ body , string $ source , string $ uniqueId , int $ typeId , int $ categoryId , string $ reporter , string $ lead , string $ tags , string $ publishedAt , int $ identifier ) : Article { return new Article ( $ title , $ body , $ source , $ uniqueId , $ typeId , $ categoryId , $ reporter , $ lead , $ tags , $ publishedAt , $ identifier ) ; }
2426	protected static function isFileSyncExclude ( $ strPath ) { if ( Config :: get ( 'uploadPath' ) == 'templates' ) { return true ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; while ( $ strPath != '.' && ! is_dir ( $ rootDir . '/' . $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } if ( $ strPath == '.' ) { return true ; } $ uploadPath = System :: getContainer ( ) -> getParameter ( 'contao.upload_path' ) ; if ( strncmp ( $ strPath . '/' , $ uploadPath . '/' , \ strlen ( $ uploadPath ) + 1 ) !== 0 ) { return true ; } return ( new Folder ( $ strPath ) ) -> isUnsynchronized ( ) ; }
12526	static public function cleanup ( $ opts = array ( ) ) { if ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ) { exec ( 'tasklist /FO CSV' , $ runningProcesses , $ return_var ) ; $ runningProcesses = array_map ( function ( $ line ) { $ cols = explode ( ',' , $ line ) ; return trim ( $ cols [ 1 ] , '"' ) ; } , $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; sort ( $ runningProcesses ) ; unset ( $ runningProcesses [ 0 ] ) ; } else { exec ( 'ps -e -o pid' , $ runningProcesses , $ return_var ) ; } if ( $ return_var != 0 ) { pake_echo_error ( "Could not get list of processes to remove stale lock files" ) ; return ; } $ lockDir = self :: lockDir ( $ opts ) ; foreach ( glob ( $ lockDir . "/*_W.lock" ) as $ writeLock ) { $ pid = file_get_contents ( $ writeLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ writeLock ) ; } } foreach ( glob ( $ lockDir . "/*_R/*.lock" ) as $ readLock ) { $ pid = file_get_contents ( $ readLock ) ; if ( ! in_array ( $ pid , $ runningProcesses ) ) { pake_unlink ( $ readLock ) ; } } }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
7092	protected function add ( $ url , $ method , Callable $ action ) { $ url = $ this -> base !== "" && $ url === "/" ? $ this -> base : $ this -> base . $ url ; $ route = new Route ( $ url , $ method , $ action ) ; $ this -> routes [ ] = $ route ; return $ route ; }
12061	public function getPermissionMap ( $ forRequestPath , $ forRoutePath = "" ) { if ( isset ( $ this -> loaded [ $ forRequestPath ] ) ) { return $ this -> loaded [ $ forRequestPath ] ; } $ database = $ this -> database ; $ permissionsSQLd = NULL ; if ( ! empty ( $ forRoutePath ) && ( $ forRoutePath <> $ forRequestPath ) ) : $ permissionsSQLd = "OR {$database->quote($forRoutePath)} REGEXP p.permission_area_uri" ; endif ; $ premissionsSQLc = "SELECT p.*, a.lft, a.rgt, a.authority_name,a.authority_parent_id FROM ?authority_permissions AS p LEFT JOIN ?authority AS a ON p.authority_id=a.authority_id WHERE {$database->quote($forRequestPath)} REGEXP p.permission_area_uri {$permissionsSQLd} ORDER BY a.lft ASC" ; $ permissionsSQL = $ database -> prepare ( $ premissionsSQLc ) ; $ permissions = $ permissionsSQL -> execute ( ) -> fetchAll ( ) ; $ this -> loaded [ $ forRoutePath ] = $ permissions ; return $ this -> loaded [ $ forRoutePath ] ; }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
9866	private function writeProtectedRanges ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getProtectedCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'protectedRanges' ) ; foreach ( $ pSheet -> getProtectedCells ( ) as $ protectedCell => $ passwordHash ) { $ objWriter -> startElement ( 'protectedRange' ) ; $ objWriter -> writeAttribute ( 'name' , 'p' . md5 ( $ protectedCell ) ) ; $ objWriter -> writeAttribute ( 'sqref' , $ protectedCell ) ; if ( ! empty ( $ passwordHash ) ) { $ objWriter -> writeAttribute ( 'password' , $ passwordHash ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
2893	public function canCaptureBlock ( $ block ) { $ blockClass = get_class ( $ block ) ; if ( ! $ this -> canCaptureCoreBlocks ( ) && strpos ( $ blockClass , 'Mage_' ) === 0 ) { return false ; } if ( strpos ( $ blockClass , 'Sheep_Debug_Block' ) > 0 ) { return false ; } return true ; }
1349	public function any ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , null ) ; } return $ this ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
10775	public function loginRequired ( $ checkAjax = true ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ this -> enableSession && ( ! $ checkAjax || ! $ request -> getIsAjax ( ) ) ) { $ this -> setReturnUrl ( $ request -> getUrl ( ) ) ; } if ( $ this -> loginUrl !== null ) { $ loginUrl = ( array ) $ this -> loginUrl ; if ( $ loginUrl [ 0 ] !== Yii :: $ app -> requestedRoute ) { return Yii :: $ app -> getResponse ( ) -> redirect ( $ this -> loginUrl ) ; } } throw new ForbiddenHttpException ( Yii :: t ( 'yii' , 'Login Required' ) ) ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
2418	protected function addFolderToArchive ( ZipWriter $ objArchive , $ strFolder , \ DOMDocument $ xml , \ DOMElement $ table , array $ arrOrder = array ( ) ) { $ strFolder = preg_replace ( '@^' . preg_quote ( Config :: get ( 'uploadPath' ) , '@' ) . '/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strTarget = 'files' ; $ strFolder = Config :: get ( 'uploadPath' ) ; } else { $ strTarget = 'files/' . $ strFolder ; $ strFolder = Config :: get ( 'uploadPath' ) . '/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ this -> addFolderToArchive ( $ objArchive , $ strFolder . '/' . $ strFile , $ xml , $ table , $ arrOrder ) ; } else { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile , $ strTarget . '/' . $ strFile ) ; $ arrRow = array ( ) ; $ objFile = new File ( $ strFolder . '/' . $ strFile ) ; $ objModel = FilesModel :: findByPath ( $ strFolder . '/' . $ strFile ) ; if ( $ objModel !== null ) { $ arrRow = $ objModel -> row ( ) ; foreach ( array ( 'id' , 'pid' , 'tstamp' , 'uuid' , 'type' , 'extension' , 'found' , 'name' ) as $ key ) { unset ( $ arrRow [ $ key ] ) ; } } $ arrRow [ 'path' ] = $ strTarget . '/' . $ strFile ; $ arrRow [ 'hash' ] = $ objFile -> hash ; $ this -> addDataRow ( $ xml , $ table , $ arrRow , $ arrOrder ) ; } } }
609	public function convert ( $ asset , $ basePath ) { $ pos = strrpos ( $ asset , '.' ) ; if ( $ pos !== false ) { $ ext = substr ( $ asset , $ pos + 1 ) ; if ( isset ( $ this -> commands [ $ ext ] ) ) { list ( $ ext , $ command ) = $ this -> commands [ $ ext ] ; $ result = substr ( $ asset , 0 , $ pos + 1 ) . $ ext ; if ( $ this -> forceConvert || @ filemtime ( "$basePath/$result" ) < @ filemtime ( "$basePath/$asset" ) ) { $ this -> runCommand ( $ command , $ basePath , $ asset , $ result ) ; } return $ result ; } } return $ asset ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
5373	public function getValue ( $ key ) { $ values = array ( ) ; foreach ( $ this -> request as $ pair ) { if ( $ pair -> isKey ( $ key ) ) { $ values [ ] = $ pair -> getValue ( ) ; } } if ( count ( $ values ) == 0 ) { return false ; } elseif ( count ( $ values ) == 1 ) { return $ values [ 0 ] ; } else { return $ values ; } }
5776	public function add ( string $ sql ) { $ args = func_get_args ( ) ; array_shift ( $ args ) ; $ this -> sql .= $ sql ; $ this -> args = array_merge ( $ this -> args , $ args ) ; return $ this ; }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
7832	protected function getSpacesByCore ( $ up = false ) { $ free = $ this -> getTotalWidth ( ) - $ this -> getBordersLength ( ) - $ this -> getCoreLength ( ) ; return $ free < 1 ? '' : str_repeat ( ' ' , $ this -> roundHalf ( $ free , $ up ) ) ; }
7039	public function getShippedAt ( $ latest = false ) { if ( 0 == $ this -> shipments -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'return' , false ) ) -> andWhere ( Criteria :: expr ( ) -> in ( 'state' , [ ShipmentStates :: STATE_READY , ShipmentStates :: STATE_SHIPPED ] ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ shipments = $ this -> shipments ; $ shipments = $ shipments -> matching ( $ criteria ) ; if ( false !== $ shipment = $ shipments -> first ( ) ) { return $ shipment -> getCreatedAt ( ) ; } return null ; }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
4174	public function build ( ) { $ providers = $ this -> getProviders ( ) -> search ( ) ; $ facades = $ this -> getFacades ( ) -> search ( ) ; if ( ! ConfigFile :: instance ( $ providers , $ facades ) -> make ( ) ) { throw new ErrorException ( 'Unable to register providers and facades. Please report this incident at Qafeen/Manager' ) ; } $ this -> getResources ( ) -> publish ( $ providers [ 0 ] ) ; return $ this ; }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
10537	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( '*' , $ this -> cors [ 'Origin' ] ) || in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && Yii :: $ app -> getRequest ( ) -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } return $ responseHeaders ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
280	private function confirmLoad ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be loaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be loaded: \n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } $ this -> stdout ( "\nBe aware that:\n" , Console :: BOLD ) ; $ this -> stdout ( "Applying leads to purging of certain data in the database!\n" , Console :: FG_RED ) ; return $ this -> confirm ( "\nLoad above fixtures?" ) ; }
10111	private function writeSheetProtection ( ) { $ record = 0x0867 ; $ options = ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) << 1 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatCells ( ) << 2 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatColumns ( ) << 3 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatRows ( ) << 4 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertColumns ( ) << 5 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertRows ( ) << 6 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertHyperlinks ( ) << 7 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteColumns ( ) << 8 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteRows ( ) << 9 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectLockedCells ( ) << 10 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSort ( ) << 11 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getAutoFilter ( ) << 12 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getPivotTables ( ) << 13 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectUnlockedCells ( ) << 14 ; $ recordData = pack ( 'vVVCVVvv' , 0x0867 , 0x0000 , 0x0000 , 0x00 , 0x01000200 , 0xFFFFFFFF , $ options , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
10113	private function writeSetup ( ) { $ record = 0x00A1 ; $ length = 0x0022 ; $ iPaperSize = $ this -> phpSheet -> getPageSetup ( ) -> getPaperSize ( ) ; $ iScale = $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) ? $ this -> phpSheet -> getPageSetup ( ) -> getScale ( ) : 100 ; $ iPageStart = 0x01 ; $ iFitWidth = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToWidth ( ) ; $ iFitHeight = ( int ) $ this -> phpSheet -> getPageSetup ( ) -> getFitToHeight ( ) ; $ grbit = 0x00 ; $ iRes = 0x0258 ; $ iVRes = 0x0258 ; $ numHdr = $ this -> phpSheet -> getPageMargins ( ) -> getHeader ( ) ; $ numFtr = $ this -> phpSheet -> getPageMargins ( ) -> getFooter ( ) ; $ iCopies = 0x01 ; $ fLeftToRight = 0x0 ; $ fLandscape = ( $ this -> phpSheet -> getPageSetup ( ) -> getOrientation ( ) == PageSetup :: ORIENTATION_LANDSCAPE ) ? 0x0 : 0x1 ; $ fNoPls = 0x0 ; $ fNoColor = 0x0 ; $ fDraft = 0x0 ; $ fNotes = 0x0 ; $ fNoOrient = 0x0 ; $ fUsePage = 0x0 ; $ grbit = $ fLeftToRight ; $ grbit |= $ fLandscape << 1 ; $ grbit |= $ fNoPls << 2 ; $ grbit |= $ fNoColor << 3 ; $ grbit |= $ fDraft << 4 ; $ grbit |= $ fNotes << 5 ; $ grbit |= $ fNoOrient << 6 ; $ grbit |= $ fUsePage << 7 ; $ numHdr = pack ( 'd' , $ numHdr ) ; $ numFtr = pack ( 'd' , $ numFtr ) ; if ( self :: getByteOrder ( ) ) { $ numHdr = strrev ( $ numHdr ) ; $ numFtr = strrev ( $ numFtr ) ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data1 = pack ( 'vvvvvvvv' , $ iPaperSize , $ iScale , $ iPageStart , $ iFitWidth , $ iFitHeight , $ grbit , $ iRes , $ iVRes ) ; $ data2 = $ numHdr . $ numFtr ; $ data3 = pack ( 'v' , $ iCopies ) ; $ this -> append ( $ header . $ data1 . $ data2 . $ data3 ) ; }
6977	protected function createAndRegisterGateway ( $ platformName , $ name , array $ config ) { $ platform = $ this -> registry -> getPlatform ( $ platformName ) ; $ gateway = $ platform -> createGateway ( $ name , $ config ) ; if ( $ gateway instanceof Shipment \ AddressResolverAwareInterface ) { $ gateway -> setAddressResolver ( $ this -> registry -> getAddressResolver ( ) ) ; } if ( $ gateway instanceof Shipment \ WeightCalculatorAwareInterface ) { $ gateway -> setWeightCalculator ( $ this -> registry -> getWeightCalculator ( ) ) ; } if ( $ gateway instanceof PersisterAwareInterface ) { $ gateway -> setPersister ( $ this -> registry -> getPersister ( ) ) ; } $ this -> gateways [ $ name ] = $ gateway ; }
9802	public static function getLibXmlLoaderOptions ( ) { if ( self :: $ libXmlLoaderOptions === null && defined ( 'LIBXML_DTDLOAD' ) ) { self :: setLibXmlLoaderOptions ( LIBXML_DTDLOAD | LIBXML_DTDATTR ) ; } elseif ( self :: $ libXmlLoaderOptions === null ) { self :: $ libXmlLoaderOptions = true ; } return self :: $ libXmlLoaderOptions ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
9387	public function restful ( $ route , $ class , $ middlewares = array ( ) ) { $ middlewares = ( is_string ( $ middlewares ) ) ? array ( $ middlewares ) : $ middlewares ; $ this -> add ( 'GET' , '/' . $ route , $ class . '@index' , $ middlewares ) ; $ this -> add ( 'POST' , '/' . $ route , $ class . '@store' , $ middlewares ) ; $ this -> add ( 'DELETE' , '/' . $ route . '/:id' , $ class . '@delete' , $ middlewares ) ; $ this -> add ( 'GET' , '/' . $ route . '/:id' , $ class . '@show' , $ middlewares ) ; $ this -> add ( 'PATCH' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; $ this -> add ( 'PUT' , '/' . $ route . '/:id' , $ class . '@update' , $ middlewares ) ; return $ this ; }
8333	private function getSelectSql ( ) { if ( self :: LOCK_TRANSACTIONAL === $ this -> lockMode ) { $ this -> beginTransaction ( ) ; switch ( $ this -> driver ) { case 'mysql' : case 'oci' : case 'pgsql' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id FOR UPDATE" ; case 'sqlsrv' : return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WITH (UPDLOCK, ROWLOCK) WHERE $this->idCol = :id" ; case 'sqlite' : break ; default : throw new \ DomainException ( sprintf ( 'Transactional locks are currently not implemented for PDO driver "%s".' , $ this -> driver ) ) ; } } return "SELECT $this->dataCol, $this->lifetimeCol, $this->timeCol FROM $this->table WHERE $this->idCol = :id" ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
4349	private function normalizeArray ( $ cfg ) { $ return = array ( 'debug' => array ( ) , ) ; $ configKeys = $ this -> getConfigKeys ( ) ; foreach ( $ cfg as $ k => $ v ) { $ translated = false ; foreach ( $ configKeys as $ objName => $ objKeys ) { if ( $ k == $ objName && \ is_array ( $ v ) ) { $ return [ $ objName ] = isset ( $ return [ $ objName ] ) ? \ array_merge ( $ return [ $ objName ] , $ v ) : $ v ; $ translated = true ; break ; } elseif ( \ is_array ( $ v ) && isset ( $ configKeys [ $ k ] ) ) { continue ; } elseif ( \ in_array ( $ k , $ objKeys ) ) { $ return [ $ objName ] [ $ k ] = $ v ; $ translated = true ; break ; } } if ( ! $ translated ) { $ return [ 'debug' ] [ $ k ] = $ v ; } } if ( ! $ return [ 'debug' ] ) { unset ( $ return [ 'debug' ] ) ; } return $ return ; }
5045	public function paginator ( $ paginatorName , $ defaultParams = [ ] , $ as = 'paginator' ) { if ( is_string ( $ defaultParams ) ) { $ as = $ defaultParams ; $ defaultParams = [ ] ; } $ this -> stack [ 'paginator' ] = [ 'as' => $ as , $ paginatorName , $ defaultParams ] ; return $ this ; }
12454	public function create ( $ entity , $ action ) { $ type = ucfirst ( $ entity ) ; $ actionName = ucfirst ( $ action ) ; $ class = sprintf ( 'RedKiteCms\Action\%s\%s%sAction' , $ type , $ actionName , $ type ) ; if ( ! class_exists ( $ class ) ) { return null ; } $ reflectionClass = new \ ReflectionClass ( $ class ) ; return $ reflectionClass -> newInstance ( $ this -> app ) ; }
2525	public function getConsumerId ( $ generate = false ) { if ( is_null ( $ this -> consumerId ) && $ generate ) { $ this -> consumerId = $ this -> generateGuid ( ) ; } return $ this -> consumerId ; }
11332	public function setAttributes ( $ value ) { $ this -> _attributes = $ value ; if ( $ this -> model ) { $ this -> _model -> attributes = $ value ; } }
1410	public function resourceTypeNotRecognised ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'resource_type_not_recognised' , 'code' ) , $ this -> trans ( 'resource_type_not_recognised' , 'title' ) , $ this -> trans ( 'resource_type_not_recognised' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'type' ) ) ; }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
11880	protected function getRunner ( ) { if ( null === $ this -> runner ) { $ this -> runner = new ConsoleApplication ( $ this -> name , $ this -> version , $ this -> description , $ this -> alias ) ; } return $ this -> runner ; }
11805	public function get ( $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( ! $ columnsPassed ) { return $ query -> get ( $ this -> getQueryColumns ( ) ) ; } if ( ! $ columns ) { return $ query -> get ( ) ; } return $ query -> get ( $ columns ) ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
5116	public function submitAttachment ( string $ idArticle , Model $ attachment , string $ field ) : array { return json_decode ( $ this -> post ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) , $ this -> normalizePayload ( $ attachment -> getCollection ( ) ) ) , true ) ; }
332	public function madd ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiAdd ( $ items , $ duration , $ dependency ) ; }
4050	private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; }
7096	public function get ( string $ name ) : Block { if ( isset ( $ this -> _blocks [ $ name ] ) ) return $ this -> _blocks [ $ name ] ; $ this -> _blocks [ $ name ] = new $ this -> block_class ( $ name ) ; return $ this -> _blocks [ $ name ] ; }
6033	public function getMetadata ( $ section = null , $ key = null ) { if ( null === $ section ) { return $ this -> metadata ; } foreach ( $ this -> metadata as $ md ) { if ( $ section != $ md -> getSection ( ) ) { continue ; } if ( null === $ key ) { return $ md ; } foreach ( $ md -> getData ( ) as $ k => $ data ) { if ( $ key == $ k ) { return $ data ; } } throw new NotFoundException ( 'No metadata with section "' . $ section . '" and key "' . $ key . '" exists.' ) ; } throw new NotFoundException ( 'No metadata with section "' . $ section . '" exists.' ) ; }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
2412	protected function addTableTlTheme ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_theme' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_theme' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_theme' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ this -> addDataRow ( $ xml , $ table , $ objTheme -> row ( ) , $ arrOrder ) ; }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6669	public function set_movie_params ( ) { $ post_id = get_the_ID ( ) ; $ is_active = $ this -> get_rating_state ( $ post_id ) ; $ options = $ this -> model -> get_theme_options ( ) ; $ params = [ 'postID' => $ post_id , 'dark' => $ options [ 'enable-dark' ] , 'imdb_button' => __ ( 'TOTAL' , 'extensions-for-grifus-rating' ) , 'is_active' => $ is_active , ] ; return $ params ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
11026	protected function country ( ) { $ this -> parts [ '{country}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCountryPropertyName ( ) , [ 'options' => [ 'class' => 'form-group' ] ] ) -> dropDownList ( ArrayHelper :: map ( Country :: find ( ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , [ 'id' => $ this -> fieldIds [ 'country' ] , 'prompt' => Yii :: t ( 'jlorente/location' , 'Select country' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCountryPropertyName ( ) ) ] ) ; }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
11997	static public function generateDoctrine2 ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrine2Query ( $ entityManager , $ entityName , $ field , $ generate ) ) ; return $ generate ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
8657	private function convertCancelFeedSubmissions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CancelFeedSubmissions' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10643	public function getParent ( ) { if ( $ this -> path === "/" || ( $ path = dirname ( $ this -> path ) ) === "." ) { return null ; } return new DirEntity ( $ path ) ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
8318	public function minLength ( $ n ) { $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ n ) { if ( mb_strlen ( $ str ) < $ n ) { return sprintf ( "Minimum password length is %d characters." , $ n ) ; } else { return true ; } } ) ; return $ this ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
5127	public function readQTime ( ) { $ msec = $ this -> readUInt ( ) ; $ time = strtotime ( 'midnight' ) + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
10059	public function commit ( ) { foreach ( $ this -> deferred as $ item ) { $ this -> save ( $ item ) ; } $ this -> deferred = [ ] ; return true ; }
3706	public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; }
7195	public function onPrepare ( ResourceEventInterface $ event ) { $ order = $ this -> getSaleFromEvent ( $ event ) ; if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { throw new IllegalOperationException ( "Order is not ready for shipment preparation" ) ; } }
7417	protected function setView ( string $ name = '' , array $ data = [ ] ) { if ( ! empty ( $ data ) ) { $ this -> data = array_replace ( $ this -> data , $ data ) ; } $ content = ( new Native ( $ this -> packageRoot , $ this -> request -> language ( ) , ! Wrap :: isEnabled ( ) ) ) -> getContent ( $ name , $ this -> data ) ; $ this -> response -> setContent ( $ content ) ; }
2899	public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; }
6255	public function searchPickupPoints ( $ postcode = null , $ street_address = null , $ country = null , $ service_provider = null , $ limit = 5 ) { if ( ( $ postcode == null && $ street_address == null ) || ( trim ( $ postcode ) == '' && trim ( $ street_address ) == '' ) ) { return '[]' ; } $ post_params = array ( 'postcode' => ( string ) $ postcode , 'address' => ( string ) $ street_address , 'country' => ( string ) $ country , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
4994	public function getActiveFormPrevious ( ) { $ key = null ; $ actualKey = $ this -> getActiveFormActual ( ) ; if ( isset ( $ actualKey ) ) { $ forms = array_keys ( $ this -> forms ) ; $ formsFlip = array_flip ( $ forms ) ; $ index = $ formsFlip [ $ actualKey ] ; if ( 0 < $ index ) { $ key = $ forms [ $ index - 1 ] ; } } return $ key ; }
5808	public function onAfterDelete ( ) { parent :: onAfterDelete ( ) ; $ fusion = FusionTag :: get ( ) -> byID ( $ this -> owner -> FusionTagID ) ; $ types = unserialize ( $ fusion -> TagTypes ) ; unset ( $ types [ $ this -> owner -> ClassName ] ) ; $ fusion -> TagTypes = ! empty ( $ types ) ? serialize ( $ types ) : null ; $ fusion -> write ( ) ; }
1619	public function buildAll ( $ query ) { $ modelClass = $ query -> modelClass ; $ key = $ this -> quoteValue ( $ modelClass :: keyPrefix ( ) . ':a:' ) ; return $ this -> build ( $ query , "n=n+1 pks[n]=redis.call('HGETALL',$key .. pk)" , 'pks' ) ; }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
3823	public function setPageValue ( string $ name , $ value ) : self { if ( empty ( $ value ) ) { unset ( $ this -> page [ $ name ] ) ; return $ this ; } $ this -> page [ $ name ] = $ value ; return $ this ; }
5785	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( mb_strlen ( $ this -> columns ) > 0 ) { $ this -> columns .= ", " ; } $ this -> columns .= $ name ; if ( mb_strlen ( $ this -> values ) > 0 ) { $ this -> values .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> values .= "$" . $ argNum ; }
3567	public function toArray ( ) { return function ( $ next , $ attributes ) { unset ( $ attributes [ 'meta_attributes' ] , $ attributes [ 'metaAttributes' ] ) ; $ attributes = array_merge ( $ attributes , $ this -> getMetaAttributesArray ( ) ) ; return $ next ( $ attributes ) ; } ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
7031	private function findMatchingShipmentItem ( InvoiceLineInterface $ line , ShipmentInterface $ shipment ) { $ saleItem = $ line -> getSaleItem ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ saleItem === $ shipmentItem -> getSaleItem ( ) ) { return $ shipmentItem ; } } return null ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
12437	public function addFormField ( IFormField $ field , $ isExtra = false ) { $ fieldId = $ field -> getId ( ) ; if ( empty ( $ fieldId ) ) { throw new \ LogicException ( 'The access path of a form field must not be empty' ) ; } $ field -> setParent ( $ this ) ; $ this -> children [ $ fieldId ] = $ field ; if ( $ isExtra === false ) { $ mappingContext = new MappingContext ( $ this , $ field , $ this -> accessorChain ) ; $ this -> mappingContexts [ $ fieldId ] = $ mappingContext ; } return $ field ; }
5796	private function setSlimMiddleware ( \ Slim \ App $ slim , $ slimContainer ) { $ slim -> add ( new CsrfMiddleware ( $ slimContainer ) ) ; if ( isset ( $ this -> config [ 'trackAll' ] ) && $ this -> config [ 'trackAll' ] ) { $ slim -> add ( new TrackerMiddleware ( $ slimContainer ) ) ; } $ slim -> add ( $ slimContainer -> csrf ) ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
1266	private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; }
2440	public function urlEncode ( ) : string { $ data = json_encode ( $ this ) ; if ( \ function_exists ( 'gzencode' ) && false !== ( $ encoded = @ gzencode ( $ data ) ) ) { $ data = $ encoded ; } return strtr ( base64_encode ( $ data ) , '+/=' , '-_,' ) ; }
8899	public function update_many ( $ primary_values , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } return FALSE ; }
12768	public function get ( string $ key = '' ) { if ( empty ( $ key ) ) { return $ this -> store ; } else { return $ this -> store [ $ key ] ?? null ; } }
5523	public function generateSubclass ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_class = "" ; if ( ! empty ( $ this -> namespace ) ) { $ mock_class .= $ this -> namespace . '\\' ; } $ mock_class .= $ this -> mock_class ; $ mock_reflection = new SimpleReflection ( $ mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } if ( $ this -> reflection -> isInterface ( ) || $ this -> reflection -> hasFinal ( ) ) { $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } else { $ code = $ this -> createCodeForSubclass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; } }
6076	public function uploadPreview ( $ fileData , $ id ) { $ parameters = [ 'query' => [ ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => 'preview-file' , ] , ] , 'headers' => null , ] ; $ this -> post ( 'v1/media.json/' . $ id . '/uploadpreview' , $ parameters ) ; }
507	public function getMessageSource ( $ category ) { if ( isset ( $ this -> translations [ $ category ] ) ) { $ source = $ this -> translations [ $ category ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = Yii :: createObject ( $ source ) ; } foreach ( $ this -> translations as $ pattern => $ source ) { if ( strpos ( $ pattern , '*' ) > 0 && strpos ( $ category , rtrim ( $ pattern , '*' ) ) === 0 ) { if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ $ pattern ] = Yii :: createObject ( $ source ) ; } } if ( isset ( $ this -> translations [ '*' ] ) ) { $ source = $ this -> translations [ '*' ] ; if ( $ source instanceof MessageSource ) { return $ source ; } return $ this -> translations [ $ category ] = $ this -> translations [ '*' ] = Yii :: createObject ( $ source ) ; } throw new InvalidConfigException ( "Unable to locate message source for category '$category'." ) ; }
9160	private function adjustHeaders ( $ requestType ) { if ( ! array_key_exists ( 'Accept' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept' , 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' ) ; } if ( ! array_key_exists ( 'Accept-Language' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept-Language' , 'en-US;q=0.7,en;q=0.3' ) ; } if ( ! array_key_exists ( 'User-Agent' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'User-Agent' , 'phpGenerics 1.0' ) ; } if ( ! array_key_exists ( 'Connection' , $ this -> headers ) || strlen ( $ this -> headers [ 'Connection' ] ) == 0 ) { $ this -> adjustConnectionHeader ( $ requestType ) ; } if ( ! array_key_exists ( 'Accept-Encoding' , $ this -> headers ) ) { if ( function_exists ( 'gzinflate' ) ) { $ encoding = 'gzip, deflate' ; } else { $ encoding = 'identity' ; } $ this -> setHeader ( 'Accept-Encoding' , $ encoding ) ; } }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
5075	public function writeLog ( $ sLine ) { if ( ! is_string ( $ sLine ) ) { $ sLine = print_r ( $ sLine , true ) ; } $ sLine = ' [' . $ this -> sModuleName . '->' . $ this -> sMethod . '] ' . $ sLine ; $ this -> oLogger -> line ( $ sLine ) ; }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
6391	public function readScormScoesTrack ( $ userid , $ scormid , $ scoid , $ attempt ) { $ trackingValues = [ ] ; $ scormTracking = $ this -> readStoreRecords ( 'scorm_scoes_track' , [ 'userid' => $ userid , 'scormid' => $ scormid , 'scoid' => $ scoid , 'attempt' => $ attempt ] ) ; foreach ( $ scormTracking as $ st ) { if ( $ st -> element == 'cmi.core.score.min' ) { $ trackingValues [ 'scoremin' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.score.max' ) { $ trackingValues [ 'scoremax' ] = $ st -> value ; } else if ( $ st -> element == 'cmi.core.lesson_status' ) { $ trackingValues [ 'status' ] = $ st -> value ; } } return $ trackingValues ; }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
8388	public function addInnerJoin ( $ table , $ on ) { $ this -> innerJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
5258	public static function map ( $ query = [ ] , callable $ callback = null , $ limit = - 1 ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ query [ 'from' ] = Arr :: get ( $ query , 'from' , 0 ) ; $ query [ 'size' ] = Arr :: get ( $ query , 'size' , 50 ) ; $ i = 0 ; $ models = static :: search ( $ query ) ; $ total = $ models -> getTotal ( ) ; while ( $ models ) { foreach ( $ models as $ model ) { if ( $ callback ) { $ callback ( $ model ) ; } $ i ++ ; } $ query [ 'from' ] += $ query [ 'size' ] ; if ( $ i >= $ total || ( $ limit > 0 && $ i >= $ limit ) ) { break ; } $ models = static :: search ( $ query ) ; } return $ total ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
9096	public function update ( ) { hypePrototyper ( ) -> prototype -> saveStickyValues ( $ this -> action ) ; foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) == 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } foreach ( $ this -> fields as $ field ) { if ( $ field -> getDataType ( ) !== 'attribute' ) { $ this -> entity = $ field -> handle ( $ this -> entity ) ; } } if ( ! $ this -> entity -> save ( ) ) { return false ; } hypePrototyper ( ) -> prototype -> clearStickyValues ( $ this -> action ) ; return $ this -> entity ; }
10017	public function addNamedRange ( NamedRange $ namedRange ) { if ( $ namedRange -> getScope ( ) == null ) { $ this -> namedRanges [ $ namedRange -> getName ( ) ] = $ namedRange ; } else { $ this -> namedRanges [ $ namedRange -> getScope ( ) -> getTitle ( ) . '!' . $ namedRange -> getName ( ) ] = $ namedRange ; } return true ; }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
593	public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
3938	private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; }
11758	public function reply ( $ msgId , $ index , $ commentId , $ content ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , 'content' => $ content , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REPLY_COMMENT , $ params ] ) ; }
8134	public function renderBlock ( $ name , $ context = array ( ) ) { $ context = $ this -> env -> mergeGlobals ( $ context ) ; $ level = ob_get_level ( ) ; ob_start ( ) ; try { $ this -> template -> displayBlock ( $ name , $ context ) ; } catch ( Exception $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } catch ( Throwable $ e ) { while ( ob_get_level ( ) > $ level ) { ob_end_clean ( ) ; } throw $ e ; } return ob_get_clean ( ) ; }
7680	function TbsSheetSlide_DeleteDisplay ( $ id_or_name , $ ok , $ delete ) { if ( is_null ( $ ok ) ) $ ok = true ; $ ext = $ this -> ExtEquiv ; $ ok = ( boolean ) $ ok ; if ( ! is_array ( $ id_or_name ) ) $ id_or_name = array ( $ id_or_name ) ; foreach ( $ id_or_name as $ item => $ action ) { if ( ! is_bool ( $ action ) ) { $ item = $ action ; $ action = $ ok ; } $ item_ref = ( is_string ( $ item ) ) ? 'n:' . htmlspecialchars ( $ item ) : 'i:' . $ item ; if ( $ delete ) { if ( $ ok ) { $ this -> OtbsSheetSlidesDelete [ $ item_ref ] = $ item ; } else { unset ( $ this -> OtbsSheetSlidesVisible [ $ item_ref ] ) ; } } else { $ this -> OtbsSheetSlidesVisible [ $ item_ref ] = $ ok ; } } }
3751	public function isUniqueValue ( $ strField , $ varNew , $ intId = null ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strField ) ; if ( $ attribute ) { $ matchingIds = $ this -> prepareFilter ( $ this -> getEmptyConfig ( ) -> setFilter ( array ( array ( 'operation' => '=' , 'property' => $ attribute -> getColName ( ) , 'value' => $ varNew ) ) ) ) -> getMatchingIds ( ) ; return ( count ( $ matchingIds ) == 0 ) || ( $ matchingIds == array ( $ intId ) ) ; } return false ; }
8928	public function add ( $ name , GeneratorInterface $ class ) { if ( array_key_exists ( $ name , $ this -> generators ) ) { throw new \ InvalidArgumentException ( 'Generator already exists.' ) ; } $ this -> generators [ $ name ] = $ class ; }
6616	public function getEndpointResult ( $ method , $ endpointName , Request $ request ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ reflectionMethod = $ this -> reflection -> getMethod ( $ methodName ) ; return $ reflectionMethod -> invokeArgs ( $ this -> controller , $ this -> mapRequestToArguments ( $ reflectionMethod , $ request ) ) ; }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
3454	public static function fromAggregateRoot ( $ eventSourcedAggregateRoot ) : AggregateType { if ( ! \ is_object ( $ eventSourcedAggregateRoot ) ) { throw new Exception \ AggregateTypeException ( \ sprintf ( 'Aggregate root must be an object but type of %s given' , \ gettype ( $ eventSourcedAggregateRoot ) ) ) ; } if ( $ eventSourcedAggregateRoot instanceof AggregateTypeProvider ) { return $ eventSourcedAggregateRoot -> aggregateType ( ) ; } $ self = new static ( ) ; $ self -> aggregateType = \ get_class ( $ eventSourcedAggregateRoot ) ; return $ self ; }
10512	private function orderObserversForPriority ( $ a , $ b ) { if ( $ a -> order > $ b -> order ) { return + 1 ; } elseif ( $ a -> order == $ b -> order ) { return 0 ; } return - 1 ; }
4596	public function getList ( ) : array { $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
8878	private function safeSendSignal ( $ process , string $ signal , int $ mappedSignal ) : void { if ( true !== proc_terminate ( $ process , $ mappedSignal ) ) { throw new CommandExecutionException ( 'Call to proc_terminate with signal "' . $ signal . '" failed for unknown reason.' ) ; } }
12112	public function getForeignDataModel ( $ key ) { $ config = $ this -> settings [ 'foreignPullParams' ] ; if ( ! isset ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ ] ; } if ( ! empty ( $ config [ 'where' ] ) ) { $ config [ 'where' ] = [ 'and' , $ config [ 'where' ] , [ $ this -> foreignModel -> primaryKey ( ) => $ key ] ] ; } else { $ config [ 'where' ] [ $ this -> foreignModel -> primaryKey ( ) ] = $ key ; } return $ this -> foreignModel -> findOne ( $ config ) ; }
6105	public function getHost ( ) { if ( $ this -> host === null ) { $ this -> host = new Host ( $ this ) ; } return $ this -> host ; }
11448	public function actionOne ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ table = Enter :: display ( 'Enter table name for export' ) ; $ tables = $ fixtures -> export ( [ $ table ] ) ; Output :: items ( $ tables , 'Exported tables' ) ; } elseif ( $ option == 'i' ) { $ table = Enter :: display ( 'Enter table name for import' ) ; $ tables = $ fixtures -> import ( [ $ table ] ) ; Output :: items ( $ tables , 'Imported tables' ) ; } }
6038	protected function initTransport ( $ options , $ transport = "TCP" ) { if ( ! is_array ( $ options ) ) { throw new Ts3Exception ( "transport parameters must provided in an array" ) ; } if ( $ transport == "TCP" ) $ this -> transport = new TCP ( $ options ) ; else $ this -> transport = new UDP ( $ options ) ; }
7991	public function setSshKey ( $ pp , $ pca , $ key ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ key ) throw new BadMethodCallException ( 'Missing parameter $key (Public key for this pca).' ) ; $ payload = array ( 'sshkey' => $ key ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
1778	public static function optionChecked ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' checked' : '' ; }
1746	public function addEnclosure ( $ strFile , $ strUrl = null , $ strMedia = 'enclosure' ) { if ( $ strFile == '' || ! file_exists ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFile ) ) { return ; } if ( $ strUrl === null ) { $ strUrl = Environment :: get ( 'base' ) ; } $ objFile = new File ( $ strFile ) ; $ this -> arrData [ 'enclosure' ] [ ] = array ( 'media' => $ strMedia , 'url' => $ strUrl . System :: urlEncode ( $ strFile ) , 'length' => $ objFile -> size , 'type' => $ objFile -> mime ) ; }
10839	protected function deleteRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( file_exists ( $ CacheFile ) ) { return unlink ( $ CacheFile ) ; } return true ; }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
757	protected function renderImageByGD ( $ code ) { $ image = imagecreatetruecolor ( $ this -> width , $ this -> height ) ; $ backColor = imagecolorallocate ( $ image , ( int ) ( $ this -> backColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> backColor % 0x10000 / 0x100 ) , $ this -> backColor % 0x100 ) ; imagefilledrectangle ( $ image , 0 , 0 , $ this -> width - 1 , $ this -> height - 1 , $ backColor ) ; imagecolordeallocate ( $ image , $ backColor ) ; if ( $ this -> transparent ) { imagecolortransparent ( $ image , $ backColor ) ; } $ foreColor = imagecolorallocate ( $ image , ( int ) ( $ this -> foreColor % 0x1000000 / 0x10000 ) , ( int ) ( $ this -> foreColor % 0x10000 / 0x100 ) , $ this -> foreColor % 0x100 ) ; $ length = strlen ( $ code ) ; $ box = imagettfbbox ( 30 , 0 , $ this -> fontFile , $ code ) ; $ w = $ box [ 4 ] - $ box [ 0 ] + $ this -> offset * ( $ length - 1 ) ; $ h = $ box [ 1 ] - $ box [ 5 ] ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ fontSize = ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ; $ angle = mt_rand ( - 10 , 10 ) ; $ letter = $ code [ $ i ] ; $ box = imagettftext ( $ image , $ fontSize , $ angle , $ x , $ y , $ foreColor , $ this -> fontFile , $ letter ) ; $ x = $ box [ 2 ] + $ this -> offset ; } imagecolordeallocate ( $ image , $ foreColor ) ; ob_start ( ) ; imagepng ( $ image ) ; imagedestroy ( $ image ) ; return ob_get_clean ( ) ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
3842	private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } }
8311	public function applyDefaults ( $ config , array $ defaults , $ depth = 1 ) { if ( ! is_int ( $ depth ) || $ depth < 0 ) { throw new \ InvalidArgumentException ( "Depth must be non-negative integer." ) ; } if ( ! is_array ( $ config ) ) { return $ defaults ; } if ( $ depth === 0 ) { $ config += $ defaults ; return $ config ; } foreach ( $ defaults as $ key => $ defaultValue ) { if ( ! isset ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ defaultValue ; continue ; } if ( is_array ( $ defaultValue ) ) { if ( is_array ( $ config [ $ key ] ) ) { $ config [ $ key ] = $ this -> applyDefaults ( $ config [ $ key ] , $ defaultValue , $ depth - 1 ) ; } else { throw new ConfigurationException ( "Configuration key " . $ key . " expects an array, a scalar value found." ) ; } } else { if ( is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( "Configuration key " . $ key . " expects scalar, an array found." ) ; } } } return $ config ; }
6869	protected function buildInvoiceList ( IM \ InvoiceSubjectInterface $ subject ) { $ invoices = $ subject -> getInvoices ( true ) -> toArray ( ) ; usort ( $ invoices , function ( IM \ InvoiceInterface $ a , IM \ InvoiceInterface $ b ) { return $ a -> getCreatedAt ( ) -> getTimestamp ( ) - $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( IM \ InvoiceInterface $ invoice ) { return [ 'invoice' => $ invoice , 'total' => $ invoice -> getGrandTotal ( ) , ] ; } , $ invoices ) ; }
10501	public function autoComplete ( $ data ) { static $ counter = 0 ; $ this -> inputOptions [ 'class' ] .= ' typeahead typeahead-' . ( ++ $ counter ) ; foreach ( $ data as & $ item ) { $ item = [ 'word' => $ item ] ; } $ this -> form -> getView ( ) -> registerJs ( "yii.gii.autocomplete($counter, " . Json :: htmlEncode ( $ data ) . ");" ) ; return $ this ; }
8129	public function actionIndex ( ) { $ profile = Profile :: findOne ( [ 'uid' => Yii :: $ app -> user -> id ] ) ; if ( $ profile == NULL ) throw new NotFoundHttpException ; return $ this -> render ( 'index' , [ 'profile' => $ profile ] ) ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
5548	public function getUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getUrl ( ) ; $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) ; } else { $ url = $ this -> frameset -> getUrl ( ) ; } return $ url ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
12281	public function getCode ( ) { $ data = [ 'component_appid' => $ this -> getAppId ( ) , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: CREATE_PRE_AUTH_CODE , $ data ] ) ; if ( empty ( $ result [ 'pre_auth_code' ] ) ) { throw new InvalidArgumentException ( 'Invalid response.' ) ; } return $ result [ 'pre_auth_code' ] ; }
4326	public static function getInterface ( ) { $ return = 'http' ; $ isCliOrCron = \ count ( \ array_filter ( array ( \ defined ( 'STDIN' ) , isset ( $ _SERVER [ 'argv' ] ) , ! \ array_key_exists ( 'REQUEST_METHOD' , $ _SERVER ) , ) ) ) > 0 ; if ( $ isCliOrCron ) { $ return = isset ( $ _SERVER [ 'TERM' ] ) || \ array_key_exists ( 'PATH' , $ _SERVER ) ? 'cli' : 'cron' ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] ) && $ _SERVER [ 'HTTP_X_REQUESTED_WITH' ] == 'XMLHttpRequest' ) { $ return = 'ajax' ; } return $ return ; }
5827	public function buildUrl ( $ url , array $ query ) { if ( ! empty ( $ query ) ) { $ queryString = http_build_query ( $ query ) ; $ url .= '?' . $ queryString ; } return $ url ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
2360	public static function findPublishedById ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ; } return static :: findOneBy ( $ arrColumns , $ intId , $ arrOptions ) ; }
7605	public function setTranslator ( TranslatorInterface $ oTranslator = null , $ sTextDomain = null ) { $ this -> translator = $ oTranslator ; if ( null !== $ sTextDomain ) { $ this -> setTranslatorTextDomain ( $ sTextDomain ) ; } return $ this ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
12228	public function removeSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'removeSelf() cannot be used to remove the root node' ) ; } $ node = $ tmp -> parentNode -> removeChild ( $ tmp ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
11869	public function clearOld ( int $ maxLife ) : void { $ limit = microtime ( true ) - $ maxLife / 1000000 ; foreach ( self :: $ files as & $ file ) { if ( $ file [ 'time' ] <= $ limit ) { $ file = null ; } } self :: $ files = array_filter ( self :: $ files ) ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
6458	public function writeJson ( IHttpResponseMessage $ response , array $ content ) : void { $ json = json_encode ( $ content ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new InvalidArgumentException ( 'Failed to JSON encode content: ' . json_last_error_msg ( ) ) ; } $ response -> getHeaders ( ) -> add ( 'Content-Type' , 'application/json' ) ; $ response -> setBody ( new StringBody ( $ json ) ) ; }
12170	public function createTables ( Database $ database ) { $ this -> database = $ database ; $ this -> database -> startTransaction ( ) ; $ this -> createAuthorityTable ( ) ; $ this -> createAuthorityPermissionsTable ( ) ; $ this -> createMenutable ( ) ; $ this -> createMenuGroupTable ( ) ; $ this -> createOptionsTable ( ) ; $ this -> createSessionTable ( ) ; $ this -> createTaxonomyTable ( ) ; $ this -> createObjectsTable ( ) ; $ this -> createGroupsTable ( ) ; $ this -> createObjectsAuthorityTable ( ) ; $ this -> createObjectsGroupTable ( ) ; $ this -> createObjectsEdgesTable ( ) ; $ this -> createPropertiesTable ( ) ; $ this -> createPropertyDatatypeTable ( ) ; $ this -> createPropertyValuesTable ( ) ; $ this -> createIndices ( ) ; $ this -> insertPropertyDatatypes ( ) ; $ this -> createObjectsRatingTable ( ) ; $ this -> createPropertyValuesProxyTable ( "attachment" ) ; $ this -> createPropertyValuesProxyTable ( "media" ) ; $ this -> createPropertyValuesProxyTable ( "user" ) ; $ this -> createPropertyValuesProxyTable ( "page" ) ; if ( ! $ this -> database -> commitTransaction ( ) ) { return false ; } return true ; }
4750	public function filterPlans ( array $ plans , array $ filters ) : array { foreach ( $ filters as $ key => $ filter ) { if ( array_key_exists ( $ key , current ( $ plans ) ) ) { $ plans = array_filter ( $ plans , function ( $ element ) use ( $ key , $ filter ) { return $ element [ $ key ] == $ filter ; } ) ; } } return $ plans ; }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
5544	public function getRaw ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRaw ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= $ this -> frames [ $ i ] -> getRaw ( ) ; } return $ raw ; }
9351	public function add ( $ matrix ) { if ( ! ( $ matrix instanceof Matrix ) ) { throw new \ InvalidArgumentException ( 'Given argument must be an instance of \Malenki\Math\Matrix' ) ; } if ( ! $ this -> sameSize ( $ matrix ) ) { throw new \ RuntimeException ( 'Cannot adding given matrix: it has wrong size.' ) ; } $ out = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; foreach ( $ this -> arr as $ k => $ v ) { $ arrOther = $ matrix -> getRow ( $ k ) ; $ arrNew = array ( ) ; foreach ( $ v as $ kk => $ vv ) { if ( $ arrOther [ $ kk ] instanceof Complex ) { $ arrNew [ ] = $ arrOther [ $ kk ] -> add ( $ vv ) ; } elseif ( $ vv instanceof Complex ) { $ arrNew [ ] = $ vv -> add ( $ arrOther [ $ kk ] ) ; } else { $ arrNew [ ] = $ arrOther [ $ kk ] + $ vv ; } } $ out -> addRow ( $ arrNew ) ; } return $ out ; }
8781	public function save ( $ content = null , $ time = 30 ) { $ fileName = md5 ( $ this -> prefix . http ( ) -> server ( 'REQUEST_URI' ) ) . $ this -> extension ; $ this -> file = cache_path ( 'html' . DIRECTORY_SEPARATOR . $ fileName ) ; $ this -> start ( $ time ) ; return $ this -> finish ( $ content ) ; }
1476	public function createQueryValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ data , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) { return $ this -> invalidQueryParameter ( $ key , $ detail , $ failed ) ; } ) ; }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
11695	protected function bustCacheBalls ( string $ asset_contents ) { $ asset_ext = $ this -> destination -> getExtension ( ) ; $ asset_name = $ this -> destination -> getBasename ( '.' . $ asset_ext ) ; $ asset_name_quoted = preg_quote ( $ asset_name , '/' ) ; $ search_for = '/' . $ asset_name_quoted . '\..*?\.' . $ asset_ext . '|' . $ asset_name_quoted . '\..*?\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.' . $ asset_ext . '/' ; $ replace_with = $ asset_name . '.' . md5 ( $ asset_contents ) . '.' . $ asset_ext ; foreach ( $ this -> template as $ templateFile ) { $ this -> printTaskInfo ( 'Updating template file - <info>' . $ templateFile . '</info>' ) ; $ this -> collectionBuilder ( ) -> taskReplaceInFile ( $ templateFile ) -> regex ( $ search_for ) -> to ( $ replace_with ) -> run ( ) ; } $ asset_base_dir = $ this -> destination -> getPath ( ) ; $ this -> destination = new SplFileInfo ( $ asset_base_dir . '/' . $ replace_with ) ; $ files_to_delete = new Finder ( ) ; $ files_to_delete -> files ( ) ; $ files_to_delete -> name ( $ asset_name . '.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext . '.gz' ) ; $ files_to_delete -> in ( $ asset_base_dir ) ; $ files_to_delete -> depth ( '== 0' ) ; foreach ( $ files_to_delete as $ file_to_delete ) { unlink ( $ file_to_delete -> getPathname ( ) ) ; } }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
7508	function setWhitespace ( $ ws ) { if ( is_array ( $ ws ) ) { $ this -> whitespace = array_fill_keys ( array_values ( $ ws ) , true ) ; $ this -> buildCharMap ( ) ; } else { $ this -> setWhiteSpace ( str_split ( $ ws ) ) ; } }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
5976	public function media ( ) { if ( ! $ this -> media instanceof MediaController ) { $ this -> media = new MediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> media -> setLogger ( $ this -> logger ) ; } return $ this -> media ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
10560	public function init ( array $ config = [ ] ) { foreach ( $ config as $ key => $ value ) { switch ( $ key ) { case 'default_controller' : $ this -> defaultController = $ value ; break ; case 'default_action' : $ this -> defaultAction = $ value ; break ; case 'namespaces' : $ this -> namespaces = $ value ; break ; default : break ; } } }
10002	public function apply ( Tag $ tag , Renderer $ renderer ) { foreach ( $ this -> stack as $ item ) { $ result = $ item [ 'decorator' ] ( $ tag , $ renderer ) ; if ( $ result instanceof Tag ) { $ tag = $ result ; } else { trigger_error ( sprintf ( '%s does not return an instance of Sirius\\Html\\Tag' , get_class ( $ item [ 'decorator' ] ) ) , E_USER_WARNING ) ; } } return $ tag ; }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
24	public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ progress ) ; }
8679	public function sort ( $ order = SORT_ASC , $ flags = SORT_REGULAR , $ preserveKeys = false ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( ! $ preserveKeys ) { if ( $ order === SORT_ASC ) { sort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { rsort ( $ items , $ flags ) ; } } else { if ( $ order === SORT_ASC ) { asort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { arsort ( $ items , $ flags ) ; } } return $ this -> createFrom ( $ items ) ; }
9966	public function fromArray ( array $ source , $ nullValue = null , $ startCell = 'A1' , $ strictNullComparison = false ) { if ( ! is_array ( end ( $ source ) ) ) { $ source = [ $ source ] ; } list ( $ startColumn , $ startRow ) = Coordinate :: coordinateFromString ( $ startCell ) ; foreach ( $ source as $ rowData ) { $ currentColumn = $ startColumn ; foreach ( $ rowData as $ cellValue ) { if ( $ strictNullComparison ) { if ( $ cellValue !== $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } else { if ( $ cellValue != $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } ++ $ currentColumn ; } ++ $ startRow ; } return $ this ; }
12638	public static function select ( string $ table , array $ columns = [ ] , string $ orderBy = "" ) : array { $ pdo = self :: connect ( ) ; $ sql = "SELECT " . ( $ columns === [ ] ? "*" : "\"" . implode ( "\", \"" , $ columns ) . "\"" ) . " FROM \"$table\"" . ( $ orderBy !== "" ? " ORDER BY $orderBy" : "" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; return $ results ; }
4343	protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
1024	private function getOperationRootType ( Schema $ schema , OperationDefinitionNode $ operation ) { switch ( $ operation -> operation ) { case 'query' : $ queryType = $ schema -> getQueryType ( ) ; if ( ! $ queryType ) { throw new Error ( 'Schema does not define the required query root type.' , [ $ operation ] ) ; } return $ queryType ; case 'mutation' : $ mutationType = $ schema -> getMutationType ( ) ; if ( ! $ mutationType ) { throw new Error ( 'Schema is not configured for mutations.' , [ $ operation ] ) ; } return $ mutationType ; case 'subscription' : $ subscriptionType = $ schema -> getSubscriptionType ( ) ; if ( ! $ subscriptionType ) { throw new Error ( 'Schema is not configured for subscriptions.' , [ $ operation ] ) ; } return $ subscriptionType ; default : throw new Error ( 'Can only execute queries, mutations and subscriptions.' , [ $ operation ] ) ; } }
12665	public function install ( ) : ApplicationInterface { try { $ resolved_modules = ( new ModuleDependencyResolver ( $ this -> required_modules ) ) -> resolve ( ) ; $ this -> installModules ( $ resolved_modules ) ; return $ this ; } catch ( \ Throwable $ e ) { throw new ApplicationInstallationException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
9973	public function setFormatCode ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: FORMAT_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> formatCode = $ pValue ; $ this -> builtInFormatCode = self :: builtInFormatCodeIndex ( $ pValue ) ; } return $ this ; }
12165	private function createAuthorityPermissionsTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority_permissions`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority_permissions` ( `authority_permission_key` bigint(20) NOT NULL AUTO_INCREMENT, `authority_id` bigint(20) NOT NULL, `permission_area_uri` varchar(255) NOT NULL, `permission` varchar(45) NOT NULL DEFAULT '1', `permission_type` varchar(45) NOT NULL, `permission_title` varchar(45) NOT NULL, PRIMARY KEY (`authority_permission_key`), UNIQUE KEY `UNIQUE` (`permission_area_uri`,`permission_type`,`authority_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority_permissions` (`authority_permission_key`, `authority_id`, `permission_area_uri`, `permission`, `permission_type`, `permission_title`) VALUES (1, 4, '^/admin(/[a-z0-9-]*)*', 'allow', 'special', 'Console'), (2, 1, '^/admin/setup/install(/[a-z0-9-]*)*', 'allow', 'execute', 'Installer'), (3, 4, '^/page(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (4, 2, '^/member(/[a-z0-9-]*)*', 'allow', 'execute', 'Member Pages'), (5, 1, '^/member/sign([a-z0-9-]*)*', 'allow', 'execute', 'Authentication'), (6, 2, '^/message(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (7, 1, '^/search(/[a-z0-9-]*)*', 'allow', 'execute', 'Search'), (8, 4, '^/listing(/[a-z0-9-]*)*', 'allow', 'special', 'Directory'), (9, 2, '^/notification(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (10, 1, '^/post(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (11, 1, '^/event(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (12, 1, '^/stream(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (13, 1, '^/group(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (14, 1, '^/file(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (16, 2, '^/post(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (15, 1, '^/page(/[a-z0-9-]*)*', 'allow', 'view', 'Content');" ) ; }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
115	public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { $ this -> config -> prohibitUrlByConfig ( $ url , $ this -> io ) ; return $ this -> executeWithAuthRetry ( $ command , $ cwd , $ url , $ path , $ verbose ) ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
12048	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( $ element instanceof CkEditor ) { $ plugin = $ renderer -> plugin ( 'form_ckeditor' ) ; return $ plugin ( $ element ) ; } return parent :: render ( $ element ) ; }
6207	public function set ( $ key , $ value ) { if ( $ this -> exists ( $ key ) ) { $ this -> dataStore [ $ key ] = $ value ; } }
11078	public static function formatPhoneNumber ( $ phoneNumber , $ formatType = Tools :: PHONE_NUMBER_FORMAT_NUMBER ) { $ formatType = ( int ) $ formatType ; if ( $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL && $ formatType !== self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_NUMBER && $ formatType !== self :: PHONE_NUMBER_FORMAT_NICE && $ formatType !== self :: PHONE_NUMBER_FORMAT_SMSTOOLS ) { return false ; } if ( ! Validate :: isPhoneNumber ( $ phoneNumber ) ) { return false ; } $ phoneNumber = self :: removeSpace ( $ phoneNumber ) ; $ phoneLen = \ strlen ( $ phoneNumber ) ; if ( $ phoneLen > 9 && 0 !== strpos ( $ phoneNumber , '+' ) ) { $ phoneNumber = '+' . $ phoneNumber ; $ phoneLen ++ ; } if ( $ phoneLen !== 9 && ! ( $ phoneLen >= 11 && $ phoneLen <= 13 && 0 === strpos ( $ phoneNumber , '+' ) ) ) { return false ; } $ international = ( $ phoneLen !== 9 ) ; switch ( $ formatType ) { case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$1 $2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_INTERNATIONAL : $ formattedPhone = $ international ? $ phoneNumber : '+420' . $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_NICE : $ formattedPhone = preg_replace ( '/^(\+\d{1,3})(\d{3})(\d{3})(\d{3})$/' , '$2 $3 $4' , $ international ? $ phoneNumber : '+420' . $ phoneNumber ) ; break ; case self :: PHONE_NUMBER_FORMAT_NUMBER : $ formattedPhone = $ international ? substr ( $ phoneNumber , - 9 ) : $ phoneNumber ; break ; case self :: PHONE_NUMBER_FORMAT_SMSTOOLS : $ formattedPhone = $ international ? trim ( $ phoneNumber , '+' ) : '420' . $ phoneNumber ; break ; default : $ formattedPhone = false ; } return $ formattedPhone ; }
3832	protected function validateWidget ( $ widget , $ value ) { if ( null === $ value ) { return ; } $ widget -> setInputCallback ( function ( ) use ( $ value ) { return $ value ; } ) ; $ widget -> validate ( ) ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
11	private function mockLocalRepositories ( RepositoryManager $ rm ) { $ packages = array ( ) ; foreach ( $ rm -> getLocalRepository ( ) -> getPackages ( ) as $ package ) { $ packages [ ( string ) $ package ] = clone $ package ; } foreach ( $ packages as $ key => $ package ) { if ( $ package instanceof AliasPackage ) { $ alias = ( string ) $ package -> getAliasOf ( ) ; $ packages [ $ key ] = new AliasPackage ( $ packages [ $ alias ] , $ package -> getVersion ( ) , $ package -> getPrettyVersion ( ) ) ; } } $ rm -> setLocalRepository ( new InstalledArrayRepository ( $ packages ) ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
10072	function fromXML ( $ xmlElement ) { $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> author = $ xmlElement -> author ; $ this -> state = $ xmlElement -> state ; $ this -> type = $ xmlElement -> type ; $ this -> contactFilterName = $ xmlElement -> contact_filter_name ; $ this -> contactFilterId = $ xmlElement -> contact_filter_id ; $ this -> evaluated = $ xmlElement -> evaluated ; $ this -> created = $ xmlElement -> created ; $ this -> updated = $ xmlElement -> updated ; $ this -> countActiveContacts = $ xmlElement -> count_active_contacts ; $ this -> countContacts = $ xmlElement -> count_contacts ; }
2669	public function checkAuthDictionaryPopulation ( $ version ) { $ dictionary = $ this -> getAuthDictionary ( $ version ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } $ authItems = $ this -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { throw new LocalizedException ( __ ( 'You must add users in order to enable Basic Authentication.' ) ) ; } }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
5013	public function attach ( EventManagerInterface $ events , $ priority = 1 ) : void { $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_BOOTSTRAP , [ $ this , 'logBootstrap' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_FINISH , [ $ this , 'logFinish' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobStart' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_JOB , [ $ this , 'logJobEnd' ] , - 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_IDLE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; $ this -> listeners [ ] = $ events -> attach ( AbstractWorkerEvent :: EVENT_PROCESS_STATE , [ $ this , 'injectLoggerInEvent' ] , 1000 ) ; }
5208	public function p ( ) { $ args = func_get_args ( ) ; $ node = $ args [ 0 ] ; if ( null === $ node ) { return ; } $ this -> logger -> trace ( 'p' . $ node -> getType ( ) , $ node , $ this -> getMetadata ( ) -> getFullQualifiedNameClass ( ) ) ; $ class = $ this -> getClass ( 'p' . $ node -> getType ( ) ) ; return call_user_func_array ( array ( $ class , "convert" ) , $ args ) ; }
2154	public function getNewsletters ( $ objModule ) { $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter === null ) { return array ( ) ; } $ arrNewsletters = array ( ) ; if ( $ objModule === null || TL_MODE == 'BE' ) { while ( $ objNewsletter -> next ( ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } else { $ newsletters = StringUtil :: deserialize ( $ objModule -> newsletters , true ) ; if ( empty ( $ newsletters ) || ! \ is_array ( $ newsletters ) ) { return array ( ) ; } while ( $ objNewsletter -> next ( ) ) { if ( \ in_array ( $ objNewsletter -> id , $ newsletters ) ) { $ arrNewsletters [ $ objNewsletter -> id ] = $ objNewsletter -> title ; } } } natsort ( $ arrNewsletters ) ; return $ arrNewsletters ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
3680	private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } if ( count ( $ parented ) == $ lastCount ) { break ; } $ lastCount = count ( $ parented ) ; } }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
6258	public function authorizeByControllerAndAction ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; extract ( $ this -> getControllerNameAndAction ( $ request ) ) ; $ actionMap = $ this -> getActionMap ( ) ; if ( isset ( $ actionMap [ $ name ] [ '*' ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ '*' ] ) ) { return true ; } } if ( isset ( $ actionMap [ $ name ] [ $ action ] ) ) { if ( $ this -> _isAllowedRole ( $ user [ $ roleField ] , $ actionMap [ $ name ] [ $ action ] ) ) { return true ; } } if ( $ this -> config ( 'undefinedActionsAreAllowed' ) === true ) { return true ; } return false ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
7548	function childCount ( $ ignore_text_comments = false ) { if ( ! $ ignore_text_comments ) { return count ( $ this -> children ) ; } else { $ count = 0 ; foreach ( array_keys ( $ this -> children ) as $ k ) { if ( ! $ this -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ count ; } } return $ count ; } }
10462	public function getTableName ( $ shopId = null ) { $ tableName = parent :: getTableName ( ) ; if ( $ shopId === null ) { $ shopId = $ this -> getActiveShopId ( ) ; } if ( ! $ this -> isShopValid ( $ shopId ) ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." ) ; } $ tableName .= '_' . $ shopId ; try { SqlValidator :: validateTableName ( $ tableName ) ; } catch ( InvalidArgumentException $ e ) { throw new InvalidArgumentException ( "Shop id \"{$shopId}\" is invalid." , 0 , $ e ) ; } return $ tableName ; }
2888	public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; if ( $ block -> getNameInLayout ( ) == 'debug_panels' ) { $ this -> updateProfiling ( ) ; } if ( ! $ this -> canCaptureBlock ( $ block ) ) { return ; } $ blockName = Mage :: helper ( 'sheep_debug' ) -> getBlockName ( $ block ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; try { $ blockInfo = $ requestInfo -> getBlock ( $ blockName ) ; } catch ( Exception $ e ) { $ blockInfo = $ requestInfo -> addBlock ( $ block ) ; } $ blockInfo -> startRendering ( $ block ) ; }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
5778	public function set ( string $ sql , array $ args ) { $ this -> sql = $ sql ; $ this -> args = $ args ; }
2080	public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } $ this -> log ( 'Purged the unactivated member registrations' , __METHOD__ , TL_CRON ) ; }
4026	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> scopeMatcher -> currentScopeIsBackend ( ) ) { return ; } $ model = $ event -> getModel ( ) ; if ( ( $ model -> getProviderName ( ) !== 'tl_metamodel_filtersetting' ) || ! in_array ( $ event -> getModel ( ) -> getProperty ( 'type' ) , $ this -> getTypes ( ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ event -> setLabel ( $ this -> getLabelPattern ( $ environment , $ model ) ) -> setArgs ( $ this -> getLabelParameters ( $ environment , $ model ) ) ; }
4861	public function pushLazy ( $ service , $ payload = null , array $ options = [ ] ) { $ manager = $ this -> getJobPluginManager ( ) ; $ serviceOptions = [ ] ; if ( is_array ( $ service ) ) { $ serviceOptions = $ service [ 'options' ] ?? $ service [ 1 ] ?? [ ] ; $ service = $ service [ 'name' ] ?? $ service [ 0 ] ?? null ; } if ( ! $ manager -> has ( $ service ) && ! class_exists ( $ service ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Service name "%s" is not a known job service or existent class' , $ service ) ) ; } $ lazyOptions = [ 'name' => $ service , 'options' => $ serviceOptions , 'content' => $ payload , ] ; $ job = $ this -> getJobPluginManager ( ) -> build ( 'lazy' , $ lazyOptions ) ; $ this -> push ( $ job , $ options ) ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
11502	public function showAction ( Comment $ comment ) { $ deleteForm = $ this -> createDeleteForm ( $ comment ) ; return array ( 'entity' => $ comment , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
11261	public function add ( MethodInterface $ method ) { if ( $ this -> isUnique ( $ method ) ) { $ this -> collection [ ] = $ method ; } else { throw new ExtDirectException ( "Remotable methodname {$method->getAnnotatedName()} already exists, but have to be unique" ) ; } }
7452	protected function renderRTL ( ) : string { $ trail = '' ; if ( $ this -> after ) { $ trail .= '<span class="after">' . $ this -> after . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , \ array_reverse ( $ this -> links ) ) ; if ( $ this -> before ) { $ trail .= ' <span class="before">' . $ this -> before . '</span>' ; } return $ trail ; }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
3319	public function isa ( $ type , $ option = null ) { if ( $ type === 'bool' ) { $ type = 'boolean' ; } $ this -> isa = $ type ; $ this -> isaOption = $ option ; return $ this ; }
5694	public function index ( HTTPRequest $ r ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/betterbuttons_nested_form.css' ) ; return $ this -> customise ( array ( 'Form' => $ this -> Form ( ) ) ) -> renderWith ( BetterButtonNestedForm :: class ) ; }
5059	public function generateFromURI ( $ string ) { $ badge = Badge :: fromURI ( $ string ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
1230	public function resolve ( array $ configuration ) { foreach ( $ this -> definitions as $ key => $ def ) { if ( ! isset ( $ configuration [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ configuration [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ configuration ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ configuration ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ configuration [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } return $ configuration ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
4353	public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } }
11816	protected function step3 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/database" ) ; $ this -> view -> setData ( "step" , "3" ) ; $ this -> view -> setData ( "randomstring" , getRandomString ( '5' ) . "_" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Database Settings" ) ) ; return ; }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
9823	public function writeWorkbookRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles' , 'styles.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme' , 'theme/theme1.xml' ) ; $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings' , 'sharedStrings.xml' ) ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ this -> writeRelationship ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet' , 'worksheets/sheet' . ( $ i + 1 ) . '.xml' ) ; } if ( $ spreadsheet -> hasMacros ( ) ) { $ this -> writeRelationShip ( $ objWriter , ( $ i + 1 + 3 ) , 'http://schemas.microsoft.com/office/2006/relationships/vbaProject' , 'vbaProject.bin' ) ; ++ $ i ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
11843	private function getCalcId ( $ dsBegin , $ treeType ) { $ codeRegular = $ codeForecast = '' ; if ( $ treeType == OptionTreeType :: VAL_PLAIN ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_PV_WRITE_OFF ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN ; } elseif ( $ treeType == OptionTreeType :: VAL_COMPRESS ) { $ codeRegular = Cfg :: CODE_TYPE_CALC_COMPRESS_PHASE1 ; $ codeForecast = Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ; } $ query = $ this -> qGetId -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QGetId :: BND_DS_BEGIN => $ dsBegin , QGetId :: BND_TYPE_CODE_REGULAR => $ codeRegular , QGetId :: BND_TYPE_CODE_FORECAST => $ codeForecast ] ; $ result = $ conn -> fetchOne ( $ query , $ bind ) ; return $ result ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
12762	public function set ( $ name , $ value , $ expire = 0 , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ expire === - 1 ) { $ expire = time ( ) + 3600 * 24 * 365 ; } else { $ expire *= 60 ; } $ value = base64_encode ( $ value ) ; if ( $ path != null ) { if ( $ domain != null ) { if ( $ secure ) { if ( $ httpOnly ) { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } } else { setcookie ( $ name , $ value , $ expire ) ; } }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
4284	public function url_stat ( $ path , $ flags ) { self :: restorePrev ( ) ; if ( ! \ file_exists ( $ path ) ) { $ info = false ; } elseif ( $ flags & STREAM_URL_STAT_LINK ) { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ lstat ( $ path ) : \ lstat ( $ path ) ; } else { $ info = $ flags & STREAM_URL_STAT_QUIET ? @ \ stat ( $ path ) : \ stat ( $ path ) ; } self :: register ( ) ; return $ info ; }
3859	public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
1890	public function grantsAccess ( ) : bool { $ content = array_filter ( file ( ( string ) $ this -> file ) ) ; foreach ( $ content as $ line ) { if ( $ this -> hasRequireGranted ( $ line ) ) { return true ; } } return false ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
2961	public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } elseif ( $ this -> _os === "windows" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } return false ; }
1825	public function setRow ( array $ arrData ) { foreach ( $ arrData as $ k => $ v ) { if ( strpos ( $ k , '__' ) !== false ) { unset ( $ arrData [ $ k ] ) ; } } $ this -> arrData = $ arrData ; return $ this ; }
8989	public function getTemplate ( $ data_type , $ type ) { $ options = ( array ) $ this -> config -> getType ( $ data_type , $ type ) ; return new UI \ Template ( $ data_type , $ type , $ options ) ; }
1847	protected function parseArticles ( $ objArticles , $ blnAddArchive = false ) { $ limit = $ objArticles -> count ( ) ; if ( $ limit < 1 ) { return array ( ) ; } $ count = 0 ; $ arrArticles = array ( ) ; while ( $ objArticles -> next ( ) ) { $ objArticle = $ objArticles -> current ( ) ; $ arrArticles [ ] = $ this -> parseArticle ( $ objArticle , $ blnAddArchive , ( ( ++ $ count == 1 ) ? ' first' : '' ) . ( ( $ count == $ limit ) ? ' last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' odd' : ' even' ) , $ count ) ; } return $ arrArticles ; }
10196	public function createStringTable ( Worksheet $ pSheet , $ pExistingTable = null ) { $ aStringTable = [ ] ; $ cellCollection = null ; $ aFlippedStringTable = null ; if ( ( $ pExistingTable !== null ) && is_array ( $ pExistingTable ) ) { $ aStringTable = $ pExistingTable ; } $ aFlippedStringTable = $ this -> flipStringTable ( $ aStringTable ) ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cellValue = $ cell -> getValue ( ) ; if ( ! is_object ( $ cellValue ) && ( $ cellValue !== null ) && $ cellValue !== '' && ! isset ( $ aFlippedStringTable [ $ cellValue ] ) && ( $ cell -> getDataType ( ) == DataType :: TYPE_STRING || $ cell -> getDataType ( ) == DataType :: TYPE_STRING2 || $ cell -> getDataType ( ) == DataType :: TYPE_NULL ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue ] = true ; } elseif ( $ cellValue instanceof RichText && ( $ cellValue !== null ) && ! isset ( $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] ) ) { $ aStringTable [ ] = $ cellValue ; $ aFlippedStringTable [ $ cellValue -> getHashCode ( ) ] = true ; } } return $ aStringTable ; }
12911	public function getCountSQL ( ) { $ statement = [ ] ; if ( $ this -> distinct ) { $ distinct = 'DISTINCT ' ; } else { $ distinct = '' ; } $ statement [ ] = "(SELECT $distinct`" . $ this -> table . "`.*" ; $ statement [ ] = $ this -> getFrom ( ) ; $ statement [ ] = $ this -> getJoin ( ) ; $ statement [ ] = $ this -> getWhere ( ) ; $ statement [ ] = $ this -> getOrder ( ) ; $ statement [ ] = ")" ; foreach ( $ this -> unions as $ union ) { $ statement [ ] = "UNION " . $ distinct ; $ statement [ ] = $ union -> getCountSQL ( ) ; } $ statement = array_filter ( $ statement ) ; $ sql = implode ( "\n" , $ statement ) ; return $ sql ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
2093	protected function validator ( $ varInput ) { $ this -> blnSubmitInput = false ; if ( ! \ strlen ( $ varInput ) && ( \ strlen ( $ this -> varValue ) || ! $ this -> mandatory ) ) { return '' ; } $ intLength = $ this -> minlength ? : Config :: get ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ varInput ) < $ intLength ) { $ this -> addError ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordLength' ] , $ intLength ) ) ; } if ( $ varInput != $ this -> getPost ( $ this -> strName . '_confirm' ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'passwordMatch' ] ) ; } $ varInput = parent :: validator ( $ varInput ) ; if ( ! $ this -> hasErrors ( ) ) { $ this -> blnSubmitInput = true ; return password_hash ( $ varInput , PASSWORD_DEFAULT ) ; } return '' ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
3487	private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
10649	private function buildUniqueRules ( ) { $ rulescopes = $ this -> rules ; foreach ( $ rulescopes as $ scope => & $ rules ) { foreach ( $ rules as $ field => & $ ruleset ) { $ ruleset = ( is_string ( $ ruleset ) ) ? explode ( '|' , $ ruleset ) : $ ruleset ; foreach ( $ ruleset as & $ rule ) { if ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) == false ) { $ params = explode ( ',' , $ rule ) ; $ uniqueRules = array ( ) ; $ table = explode ( ':' , $ params [ 0 ] ) ; if ( count ( $ table ) == 1 ) $ uniqueRules [ 1 ] = $ this -> table ; else $ uniqueRules [ 1 ] = $ table [ 1 ] ; if ( count ( $ params ) == 1 ) $ uniqueRules [ 2 ] = $ field ; else $ uniqueRules [ 2 ] = $ params [ 1 ] ; $ uniqueRules [ 3 ] = $ this -> getKey ( ) ; $ uniqueRules [ 4 ] = $ this -> getKeyName ( ) ; $ rule = 'unique:' . implode ( ',' , $ uniqueRules ) ; } elseif ( str_contains ( $ rule , 'unique' ) && str_contains ( $ rule , '{id}' ) ) { $ rule = str_replace ( '{id}' , $ this -> getKey ( ) , $ rule ) ; } } } } $ this -> rules = $ rulescopes ; }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
1714	public static function getInstance ( ) { if ( static :: $ objInstance !== null ) { return static :: $ objInstance ; } $ objToken = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( $ objToken !== null && is_a ( $ objToken -> getUser ( ) , static :: class ) ) { return $ objToken -> getUser ( ) ; } $ strUser = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) -> getBackendUsername ( ) ; if ( $ strUser !== null ) { static :: $ objInstance = static :: loadUserByUsername ( $ strUser ) ; return static :: $ objInstance ; } return parent :: getInstance ( ) ; }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
10962	private function isInvalidLogDate ( $ file ) { $ pattern = '/laravel-(\d){4}-(\d){2}-(\d){2}.log/' ; if ( ( bool ) preg_match ( $ pattern , $ file , $ matches ) === false ) { return true ; } return false ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
9143	public function getParam ( $ name , $ defaultValue = null ) { $ params = reset ( $ this -> params ) ; if ( is_array ( $ params ) && isset ( $ params [ $ name ] ) ) { $ value = $ params [ $ name ] ; if ( is_string ( $ value ) && stripos ( $ value , $ delimiter = $ this -> getParamDelimiter ( ) ) ) { $ value = explode ( $ delimiter , $ value ) ; } return $ value ; } if ( $ defaultValue != null ) { return $ defaultValue ; } throw new \ Exception ( sprintf ( 'Requested param %s not available' , $ name ) ) ; }
8060	private function createWorker ( $ i ) { $ sockets = array ( ) ; if ( socket_create_pair ( AF_UNIX , SOCK_STREAM , 0 , $ sockets ) === FALSE ) { throw new \ RuntimeException ( 'socket_create_pair failed.' ) ; return ; } $ processId = pcntl_fork ( ) ; if ( $ processId < 0 ) { throw new \ RuntimeException ( 'pcntl_fork failed.' ) ; return ; } elseif ( $ processId === 0 ) { $ this -> workerProcesses = new ProcessDetailsCollection ( ) ; $ this -> workerPoolSize = 0 ; socket_close ( $ sockets [ 1 ] ) ; $ this -> runWorkerProcess ( $ this -> worker , new SimpleSocket ( $ sockets [ 0 ] ) , $ i ) ; } else { socket_close ( $ sockets [ 0 ] ) ; $ this -> workerProcesses -> addFree ( new ProcessDetails ( $ processId , new SimpleSocket ( $ sockets [ 1 ] ) ) ) ; } }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
2750	public function getVclSnippets ( $ path = '/vcl_snippets' , $ specificFile = null ) { $ snippetsData = [ ] ; $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) . $ path ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; if ( ! $ specificFile ) { $ files = $ directoryRead -> read ( ) ; if ( is_array ( $ files ) ) { foreach ( $ files as $ file ) { if ( substr ( $ file , strpos ( $ file , "." ) + 1 ) !== 'vcl' ) { continue ; } $ snippetFilePath = $ moduleEtcPath . '/' . $ file ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ file ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } } } else { $ snippetFilePath = $ moduleEtcPath . '/' . $ specificFile ; $ snippetFilePath = $ directoryRead -> getRelativePath ( $ snippetFilePath ) ; $ type = explode ( '.' , $ specificFile ) [ 0 ] ; $ snippetsData [ $ type ] = $ directoryRead -> readFile ( $ snippetFilePath ) ; } return $ snippetsData ; }
2227	public function editHeader ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> User -> canEditFieldsOf ( 'tl_faq_category' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
2787	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( PHP_SAPI !== 'phpdbg' && ! defined ( 'HHVM_VERSION' ) && ! extension_loaded ( 'xdebug' ) ) { $ output -> writeln ( '<error>You need to install and enable xdebug, or use phpdbg, ' . 'in order to allow for code coverage generation.</error>' ) ; return 1 ; } Performance :: upMemProfiler ( ) ; $ this -> validate ( $ input ) ; $ container = $ this -> container = new Container ( $ input -> getOptions ( ) ) ; $ this -> doConfiguration ( $ input ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ this -> removeOldLogFiles ( ) ; } else { $ output -> writeln ( '<error>No log file is specified. Detailed results ' . 'will not be available.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ output -> writeln ( '<error>Incremental Analysis is an experimental feature and will very likely</error>' ) ; $ output -> writeln ( '<error>yield inaccurate results at this time.</error>' ) ; $ output -> write ( PHP_EOL ) ; } if ( $ this -> textLogFile ) { $ renderer = new Text ( $ output , true ) ; } else { $ renderer = new Text ( $ output ) ; } $ testSuiteRunner = new UnitTestRunner ( $ container -> getAdapter ( ) , $ container -> getAdapter ( ) -> getProcess ( $ container , true ) , $ container -> getTempDirectory ( ) . '/coverage.humbug.txt' ) ; $ testSuiteRunner -> addObserver ( new LoggingObserver ( $ renderer , $ output , new ProgressBarObserver ( $ input , $ output ) ) ) ; $ result = $ testSuiteRunner -> run ( $ container ) ; if ( ! $ result -> isSuccess ( ) ) { return 1 ; } $ output -> write ( PHP_EOL ) ; $ renderer -> renderStaticAnalysisStart ( ) ; $ output -> write ( PHP_EOL ) ; $ incrementalCache = null ; if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache = new IncrementalCache ( $ container ) ; } $ mutationTestingRunner = $ this -> builder -> build ( $ container , $ renderer , $ input , $ output ) ; $ mutationTestingRunner -> run ( $ result -> getCoverage ( ) , $ this -> mutableIterator , $ incrementalCache ) ; if ( $ this -> isLoggingEnabled ( ) ) { $ output -> write ( PHP_EOL ) ; } if ( $ input -> getOption ( 'incremental' ) ) { $ incrementalCache -> write ( ) ; } }
1592	protected function validateResource ( ) : bool { $ identifier = $ this -> validateTypeAndId ( ) ; $ attributes = $ this -> validateAttributes ( ) ; $ relationships = $ this -> validateRelationships ( ) ; if ( $ attributes && $ relationships ) { return $ this -> validateAllFields ( ) && $ identifier ; } return $ identifier && $ attributes && $ relationships ; }
6378	protected function readStoreRecord ( $ type , array $ query ) { $ model = $ this -> store -> get_record ( $ type , $ query ) ; if ( $ model === false ) { throw new Exception ( 'Record not found.' ) ; } return $ model ; }
8841	public function generateURLSegment ( $ increment = null ) { $ filter = new URLSegmentFilter ( ) ; $ this -> owner -> URLSegment = $ filter -> filter ( $ this -> owner -> Title ) ; if ( is_int ( $ increment ) ) $ this -> owner -> URLSegment .= '-' . $ increment ; $ duplicate = DataList :: create ( $ this -> owner -> ClassName ) -> filter ( array ( "URLSegment" => $ this -> owner -> URLSegment , "BlogID" => $ this -> owner -> BlogID ) ) ; if ( $ this -> owner -> ID ) $ duplicate = $ duplicate -> exclude ( "ID" , $ this -> owner -> ID ) ; if ( $ duplicate -> count ( ) > 0 ) { $ increment = is_int ( $ increment ) ? $ increment + 1 : 0 ; $ this -> owner -> generateURLSegment ( ( int ) $ increment ) ; } return $ this -> owner -> URLSegment ; }
4945	public function revoke ( $ resource , $ permission = null , $ build = true ) { if ( self :: PERMISSION_NONE == $ permission || ! $ this -> isAssigned ( $ resource ) ) { return $ this ; } if ( self :: PERMISSION_CHANGE == $ permission ) { return $ this -> grant ( $ resource , self :: PERMISSION_VIEW , $ build ) ; } return $ this -> grant ( $ resource , self :: PERMISSION_NONE , $ build ) ; }
10081	protected function registerManager ( ) { $ this -> app -> singleton ( 'auja' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new Auja ( $ app , $ app [ 'auja.configurator' ] , $ config [ 'models' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Auja' , 'auja' ) ; }
11697	public function __ ( $ key , array $ parameters = [ ] , $ locale = null , $ default = null , $ parseBBCode = true ) { return $ this -> translate ( $ key , $ parameters , $ locale , $ default , $ parseBBCode ) ; }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
11181	public function getActions ( ) { $ result = $ this -> get ( Keys :: EXT_ACTION ) ; if ( is_string ( $ result ) ) { return unserialize ( $ result ) ; } return array ( ) ; }
5362	public function createContext ( Registry $ registry , $ name ) { $ schemas = array_values ( $ registry -> getSchemas ( ) ) ; foreach ( $ schemas as $ schema ) { $ openApiSpec = $ this -> schemaParser -> parseSchema ( $ schema -> getOrigin ( ) ) ; $ this -> chainGuesser -> guessClass ( $ openApiSpec , $ schema -> getRootName ( ) , $ schema -> getOrigin ( ) . '#' , $ registry ) ; $ schema -> setParsed ( $ openApiSpec ) ; } foreach ( $ registry -> getSchemas ( ) as $ schema ) { foreach ( $ schema -> getClasses ( ) as $ class ) { $ properties = $ this -> chainGuesser -> guessProperties ( $ class -> getObject ( ) , $ schema -> getRootName ( ) , $ class -> getReference ( ) , $ registry ) ; foreach ( $ properties as $ property ) { $ property -> setType ( $ this -> chainGuesser -> guessType ( $ property -> getObject ( ) , $ property -> getName ( ) , $ property -> getReference ( ) , $ registry ) ) ; } $ class -> setProperties ( $ properties ) ; } } return new Context ( $ registry ) ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
7790	public function setOpeningBalanceClass ( $ openingBalanceClass ) { if ( ! is_callable ( $ openingBalanceClass ) && ! class_exists ( $ openingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$openingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> openingBalanceClass = $ openingBalanceClass ; return $ this ; }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
9264	protected function createController ( $ controller ) { $ parts = explode ( ':' , $ controller ) ; if ( count ( $ parts ) === 2 ) { $ service = $ this -> container -> get ( $ parts [ 0 ] ) ; return array ( $ service , $ parts [ 1 ] ) ; } $ controller = parent :: createController ( $ controller ) ; if ( $ controller [ 0 ] instanceof ContainerAwareInterface ) { $ controller [ 0 ] -> setContainer ( $ this -> container ) ; } return $ controller ; }
8977	public function setParameter ( $ name , $ value ) { if ( ! isset ( $ ref ) ) { $ ref = new \ ReflectionClass ( $ this -> config ) ; } $ function = sprintf ( 'set%s' , ucfirst ( $ name ) ) ; if ( ! $ ref -> hasMethod ( $ function ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The function "%s" does not exists on configuration' , $ name ) ) ; } $ this -> config -> $ function ( $ value ) ; return $ this ; }
11636	public function getDeviceByPageId ( $ pageId , $ begin , $ count ) { $ params = [ 'type' => 2 , 'page_id' => intval ( $ pageId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
12319	public function redirect ( string $ shortURLKey ) { $ record = HCShortURL :: where ( 'short_url_key' , $ shortURLKey ) -> first ( ) ; if ( ! $ record ) abort ( 404 ) ; $ record -> increment ( 'clicks' ) ; return redirect ( $ record -> url ) ; }
7065	public function getAuthActions ( ) { if ( ! $ this -> _AuthActions ) { if ( Configure :: load ( 'auth_actions' ) === false ) { trigger_error ( 'AuthActions: Could not load config/auth_actions.php' , E_USER_WARNING ) ; } $ actionConfig = Configure :: read ( 'auth_actions' ) ; $ publicActionsConfig = Configure :: read ( 'public_actions' ) ; $ options = Configure :: read ( 'auth_settings' ) ; if ( ! is_array ( $ options ) ) { $ options = [ ] ; } if ( ! is_array ( $ publicActionsConfig ) ) { $ publicActionsConfig = [ ] ; } $ this -> _AuthActions = new AuthActions ( $ actionConfig , $ publicActionsConfig , $ options ) ; } return $ this -> _AuthActions ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
11902	public function cache ( ContentfulAsset $ asset ) { if ( ! isset ( $ asset -> file ) ) { $ this -> log ( 'Asset %s has no file.' , $ asset ) ; return ; } foreach ( $ asset -> file as $ locale => $ file ) { if ( ! $ file ) { $ this -> log ( 'Asset %s contains unpublished file for %s.' , $ asset , $ locale ) ; continue ; } $ localFile = $ this -> getLocalFile ( $ asset , $ locale ) ; if ( $ localFile -> isFile ( ) ) { continue ; } $ this -> log ( 'Caching "%s" file for asset "%s" as "%s" ...' , $ locale , $ asset -> getId ( ) , $ localFile -> getPathname ( ) ) ; $ dir = new \ SplFileInfo ( $ localFile -> getPath ( ) ) ; if ( ! $ dir -> isWritable ( ) ) { throw new RuntimeException ( sprintf ( 'Target directory "%s" is not writeable!' , $ localFile -> getPath ( ) ) ) ; } copy ( str_replace ( '//' , 'https://' , $ file [ 'url' ] ) , $ localFile -> getPathname ( ) ) ; $ size = filesize ( $ localFile -> getPathname ( ) ) ; $ this -> log ( '%d bytes saved.' , $ size ) ; } }
6879	public function finish ( ) { parent :: finish ( ) ; if ( $ this -> isRowActionsEnabled ( ) && ! $ this -> hasValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME ) ) { $ this -> addValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME , null ) ; } if ( $ this -> isNestedViewEnabled ( ) && ! $ this -> hasValueViewer ( $ this -> getColumnNameForNestedView ( ) ) ) { $ this -> addValueViewer ( $ this -> getColumnNameForNestedView ( ) , DataGridColumn :: create ( ) -> setIsVisible ( false ) ) ; } if ( $ this -> isRowsReorderingEnabled ( ) ) { $ reorderingColumns = $ this -> getRowsPositioningColumns ( ) ; $ allowedColumnTypes = [ Column :: TYPE_INT , Column :: TYPE_FLOAT , Column :: TYPE_UNIX_TIMESTAMP ] ; foreach ( $ reorderingColumns as $ columnName ) { if ( ! $ this -> hasValueViewer ( $ columnName ) ) { throw new NotFoundException ( "Column '$columnName' provided for reordering was not found within declared data grid columns" ) ; } $ valueViewer = $ this -> getValueViewer ( $ columnName ) ; if ( ! $ valueViewer -> isLinkedToDbColumn ( ) && $ valueViewer -> getTableColumn ( ) -> isItExistsInDb ( ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering must be linked to a column that exists in database" ) ; } $ colType = $ valueViewer -> getTableColumn ( ) -> getType ( ) ; if ( ! in_array ( $ colType , $ allowedColumnTypes , true ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering should be of a numeric type (int, float, unix ts)." . "'{$colType}' type is not acceptable'" ) ; } $ valueViewer -> setIsSortable ( true ) ; } } }
8859	private function _hardCopy ( string $ originDir , string $ targetDir ) : string { $ this -> filesystem -> mkdir ( $ targetDir , 0777 ) ; $ this -> filesystem -> mirror ( $ originDir , $ targetDir , Finder :: create ( ) -> ignoreDotFiles ( false ) -> in ( $ originDir ) ) ; return AssetsInstallCommand :: METHOD_COPY ; }
6883	static public function getTypes ( ) { return [ static :: MANUAL , static :: CART_REMIND , static :: ORDER_ACCEPTED , static :: QUOTE_REMIND , static :: PAYMENT_CAPTURED , static :: PAYMENT_EXPIRED , static :: SHIPMENT_SHIPPED , static :: SHIPMENT_PARTIAL , static :: RETURN_PENDING , static :: RETURN_RECEIVED , ] ; }
1796	private function addIndexRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/' , $ defaults ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_index' , $ route ) ; }
11187	public static function get ( array $ arr , $ k , $ default = null ) { if ( isset ( $ arr [ $ k ] ) ) return $ arr [ $ k ] ; $ nested = explode ( '.' , $ k ) ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) ) { $ arr = $ arr [ $ part ] ; continue ; } else { $ arr = $ default ; break ; } } return $ arr ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
7143	private function sortAssignments ( array $ assignments , $ direction = SORT_DESC ) { usort ( $ assignments , function ( StockAssignmentInterface $ a , StockAssignmentInterface $ b ) use ( $ direction ) { $ aDate = $ a -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; $ bDate = $ b -> getSaleItem ( ) -> getSale ( ) -> getCreatedAt ( ) ; if ( $ aDate == $ bDate ) { return 0 ; } if ( $ direction === SORT_ASC ) { return $ aDate < $ bDate ? - 1 : 1 ; } return $ aDate > $ bDate ? - 1 : 1 ; } ) ; return $ assignments ; }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
2771	public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; }
3222	function createShareableLink ( $ path ) { Path :: checkArg ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/shares" , $ path ) , array ( "short_url" => "false" , ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; return self :: getField ( $ j , "url" ) ; }
878	public function useRuleSet ( RuleSetInterface $ ruleSet ) { $ fixers = [ ] ; $ fixersByName = [ ] ; $ fixerConflicts = [ ] ; $ fixerNames = array_keys ( $ ruleSet -> getRules ( ) ) ; foreach ( $ fixerNames as $ name ) { if ( ! \ array_key_exists ( $ name , $ this -> fixersByName ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Rule "%s" does not exist.' , $ name ) ) ; } $ fixer = $ this -> fixersByName [ $ name ] ; $ config = $ ruleSet -> getRuleConfiguration ( $ name ) ; if ( null !== $ config ) { if ( $ fixer instanceof ConfigurableFixerInterface ) { if ( ! \ is_array ( $ config ) || ! \ count ( $ config ) ) { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Configuration must be an array and may not be empty.' ) ; } $ fixer -> configure ( $ config ) ; } else { throw new InvalidFixerConfigurationException ( $ fixer -> getName ( ) , 'Is not configurable.' ) ; } } $ fixers [ ] = $ fixer ; $ fixersByName [ $ name ] = $ fixer ; $ conflicts = array_intersect ( $ this -> getFixersConflicts ( $ fixer ) , $ fixerNames ) ; if ( \ count ( $ conflicts ) > 0 ) { $ fixerConflicts [ $ name ] = $ conflicts ; } } if ( \ count ( $ fixerConflicts ) > 0 ) { throw new \ UnexpectedValueException ( $ this -> generateConflictMessage ( $ fixerConflicts ) ) ; } $ this -> fixers = $ fixers ; $ this -> fixersByName = $ fixersByName ; return $ this ; }
1334	protected function fillRelated ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ relationships = $ resource -> getRelationships ( ) ; $ changed = false ; foreach ( $ relationships as $ field => $ value ) { if ( $ this -> isNotFillable ( $ field , $ record ) ) { continue ; } if ( ! $ this -> isRelation ( $ field ) ) { continue ; } $ relation = $ this -> getRelated ( $ field ) ; if ( $ this -> requiresPrimaryRecordPersistence ( $ relation ) ) { $ relation -> update ( $ record , $ value , $ parameters ) ; $ changed = true ; } } if ( $ changed ) { $ record -> refresh ( ) ; } }
10895	public function addCollection ( UriCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
140	public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } }
3804	private function buildCondition ( $ condition , $ metaModel ) { if ( null === $ condition ) { return null ; } return $ this -> conditionFactory -> createCondition ( $ condition , $ metaModel ) ; }
4462	private function readErrorFromSocket ( $ socket ) : ? string { $ error = '' ; while ( ! empty ( $ res = socket_read ( $ socket , 8192 ) ) ) { $ error .= $ res ; } $ error = unserialize ( $ error ) ; if ( is_array ( $ error ) ) { $ handler = new ErrorFormatter ( ) ; return sprintf ( '%s: %s in %s on line %d' , $ handler -> constant ( $ error [ 'type' ] ) ? : 'Unknown' , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
9713	private function writeExternalsheetBiff8 ( ) { $ totalReferences = count ( $ this -> parser -> references ) ; $ record = 0x0017 ; $ length = 2 + 6 * $ totalReferences ; $ supbook_index = 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ totalReferences ) ; for ( $ i = 0 ; $ i < $ totalReferences ; ++ $ i ) { $ data .= $ this -> parser -> references [ $ i ] ; } return $ this -> writeData ( $ header . $ data ) ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
7739	public function deserialize ( $ data , $ entity ) { if ( ! $ this -> container -> has ( 'hydra.serializer' ) ) { throw new \ LogicException ( 'The HydraBundle is not registered in your application.' ) ; } $ serializer = $ this -> container -> get ( 'hydra.serializer' ) ; if ( is_object ( $ entity ) ) { return $ serializer -> deserializeIntoEntity ( $ data , $ entity ) ; } return $ serializer -> deserialize ( $ data , $ entity , self :: FORMAT ) ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
9138	public static function formatCamelCaseWithAcronyms ( array $ parts ) { $ camelCase = array_map ( function ( $ p ) { return static :: ucfirstAndLowerNonAcronym ( $ p ) ; } , $ parts ) ; if ( static :: isAcronym ( $ camelCase [ 0 ] ) ) { return implode ( '' , $ camelCase ) ; } return lcfirst ( implode ( '' , $ camelCase ) ) ; }
1823	public function listImageSize ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'name' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . ( int ) $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
2292	public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; }
1879	public function protect ( ) { @ trigger_error ( 'Using DC_Folder::protect() has been deprecated and will no longer work in Contao 5.0. Use Contao\Folder::protect() and Contao\Folder::unprotect() instead.' , E_USER_DEPRECATED ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ this -> intId ) ) { throw new InternalServerErrorException ( 'Resource "' . $ this -> intId . '" is not a directory.' ) ; } if ( file_exists ( $ this -> strRootDir . '/' . $ this -> intId . '/.public' ) ) { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> protect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'Folder "' . $ this -> intId . '" has been protected' , __METHOD__ , TL_FILES ) ; } else { $ objFolder = new Folder ( $ this -> intId ) ; $ objFolder -> unprotect ( ) ; $ this -> import ( Automator :: class , 'Automator' ) ; $ this -> Automator -> generateSymlinks ( ) ; $ this -> log ( 'The protection from folder "' . $ this -> intId . '" has been removed' , __METHOD__ , TL_FILES ) ; } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
807	public function generate ( $ input ) { $ tokens = [ ] ; $ parts = explode ( '\\' , $ input ) ; foreach ( $ parts as $ index => $ part ) { $ tokens [ ] = new Token ( [ T_STRING , $ part ] ) ; if ( $ index !== \ count ( $ parts ) - 1 ) { $ tokens [ ] = new Token ( [ T_NS_SEPARATOR , '\\' ] ) ; } } return $ tokens ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
7035	protected function createMigrationTable ( ) { $ migrations = new Table ( "migrations" , true ) ; $ migrations -> string ( "host" ) -> notNullable ( ) -> primaryComposite ( ) ; $ migrations -> timestamp ( "created_at" ) -> notNullable ( ) -> primaryComposite ( true ) ; $ migrations -> blob ( "tables" ) ; try { return $ migrations -> create ( $ this -> dbName ) ; } catch ( PDOException $ e ) { error_log ( $ e -> getMessage ( ) ) ; return false ; } }
12180	public function getTaxonomyPackage ( ) { if ( empty ( $ this -> taxonomy ) ) { return false ; } $ taxonomySettings = $ this -> taxonomy ; if ( ! is_array ( $ taxonomySettings ) ) { $ taxonomySettings = [ 'id' => $ taxonomySettings ] ; } $ taxonomy = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ taxonomySettings [ 'id' ] ) ; if ( empty ( $ taxonomy ) || empty ( $ taxonomy -> object ) ) { return false ; } return $ taxonomy -> package ( $ taxonomySettings ) ; }
7230	public function getMarginPercent ( ) { if ( 0 < $ this -> margin && 0 < $ this -> revenue ) { return round ( $ this -> margin * 100 / $ this -> revenue , 1 ) ; } return 0 ; }
718	public function timestamp ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIMESTAMP , $ precision ) ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
349	public static function cssStyleToArray ( $ style ) { $ result = [ ] ; foreach ( explode ( ';' , $ style ) as $ property ) { $ property = explode ( ':' , $ property ) ; if ( count ( $ property ) > 1 ) { $ result [ trim ( $ property [ 0 ] ) ] = trim ( $ property [ 1 ] ) ; } } return $ result ; }
7415	public function errorMessage ( ) : string { static $ errors = array ( UPLOAD_ERR_INI_SIZE => 'The file "%s" exceeds your upload_max_filesize ini directive (limit is %d KiB).' , UPLOAD_ERR_FORM_SIZE => 'The file "%s" exceeds the upload limit defined in your form.' , UPLOAD_ERR_PARTIAL => 'The file "%s" was only partially uploaded.' , UPLOAD_ERR_NO_FILE => 'No file was uploaded.' , UPLOAD_ERR_CANT_WRITE => 'The file "%s" could not be written on disk.' , UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.' , UPLOAD_ERR_EXTENSION => 'File upload was stopped by a PHP extension.' , ) ; $ errorCode = $ this -> error ; $ maxFileSize = $ errorCode === UPLOAD_ERR_INI_SIZE ? $ this -> getMaxFileSize ( ) / 1024 : 0 ; $ message = isset ( $ errors [ $ errorCode ] ) ? $ errors [ $ errorCode ] : 'The file "%s" was not uploaded due to an unknown error.' ; return sprintf ( $ message , $ this -> name , $ maxFileSize ) ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
4758	protected function transformCacheAnnotation ( Cache $ cache ) { return array ( 'expires' => $ cache -> getExpires ( ) , 'maxage' => $ cache -> getMaxAge ( ) , 'smaxage' => $ cache -> getSMaxAge ( ) , 'public' => $ this -> transformBoolean ( $ cache -> isPublic ( ) ) , 'vary' => $ cache -> getVary ( ) , 'lastModified' => $ cache -> getLastModified ( ) , 'etag' => $ cache -> getETag ( ) , ) ; }
11621	public function view ( ) : \ TheCMSThread \ Core \ Main \ View { static $ view ; if ( $ view === null ) { $ view = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\View" ) ; } $ view -> __construct ( $ this -> auth ( ) ) ; return $ view ; }
1340	public function exists ( ResourceIdentifierInterface $ identifier ) { $ record = $ this -> lookup ( $ identifier ) ; return is_object ( $ record ) ? true : $ record ; }
8772	protected function markAsRegistered ( ServiceProvider $ provider ) { $ this -> serviceProviders [ ] = $ provider ; $ this -> loadedProviders [ get_class ( $ provider ) ] = true ; }
6714	public function getRequestChain ( ) { if ( is_null ( $ this -> requestChain ) ) { $ this -> requestChain = $ this -> getRequestChainFromUri ( $ this -> requestedUri ) ; } return $ this -> requestChain ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
7743	public function setValue ( $ entity , $ value ) { if ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( ! is_array ( $ value ) && ! ( $ value instanceof \ Traversable ) ) { if ( ( null !== $ this -> adderRemover ) && ( null !== $ this -> getter ) ) { $ itemsToAdd = is_object ( $ value ) ? iterator_to_array ( $ value ) : $ value ; $ itemToRemove = array ( ) ; $ previousValue = $ this -> getValue ( $ entity ) ; if ( is_array ( $ previousValue ) || $ previousValue instanceof \ Traversable ) { foreach ( $ previousValue as $ previousItem ) { foreach ( $ value as $ key => $ item ) { if ( $ item === $ previousItem ) { unset ( $ itemsToAdd [ $ key ] ) ; continue 2 ; } } $ itemToRemove [ ] = $ previousItem ; } } foreach ( $ itemToRemove as $ item ) { call_user_func ( array ( $ entity , 'remove' . $ this -> adderRemover ) , $ item ) ; } foreach ( $ itemsToAdd as $ item ) { call_user_func ( array ( $ entity , 'add' . $ this -> adderRemover ) , $ item ) ; } return ; } } if ( null === $ this -> setter ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as no setter has been found." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> setterType ) { return $ entity -> { $ this -> setter } ( $ value ) ; } else { return $ entity -> { $ this -> setter } = $ value ; } }
11543	public function changePassword ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangePasswordForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ password = $ user -> getPassword ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
5489	public static function parseArguments ( $ argv , $ mutliValueMode = false ) { $ args = array ( ) ; $ args [ 'extraArguments' ] = array ( ) ; array_shift ( $ argv ) ; foreach ( $ argv as $ arg ) { if ( preg_match ( '#^--([^=]+)=(.*)#' , $ arg , $ reg ) ) { $ args [ $ reg [ 1 ] ] = $ reg [ 2 ] ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ reg [ 2 ] ) ; } } elseif ( preg_match ( '#^[-]{1,2}([^[:blank:]]+)#' , $ arg , $ reg ) ) { $ nonnull = '' ; $ args [ $ reg [ 1 ] ] = $ nonnull ; if ( $ mutliValueMode ) { self :: addItemAsArray ( $ args , $ reg [ 1 ] , $ nonnull ) ; } } else { $ args [ 'extraArguments' ] [ ] = $ arg ; } } return $ args ; }
9219	protected function requestPageNumber ( $ pageNumber , $ forceRefresh = false ) { if ( ! isset ( $ this -> data [ $ this -> pageNumberToKey ( $ pageNumber ) ] ) || ( $ forceRefresh && isset ( $ this -> api ) ) ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { $ params = $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getParams ( ) ; $ params [ CanvasPageLink :: PARAM_PAGE_NUMBER ] = $ pageNumber ; $ page = $ this -> api -> get ( $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getEndpoint ( ) , $ params ) ; $ this -> data = array_replace ( $ this -> data , $ page -> data ) ; $ pagination = $ this -> parsePageLinks ( ) ; $ this -> paginationPerPage [ $ pagination [ CanvasPageLink :: CURRENT ] -> getPageNumber ( ) ] = $ pagination ; return true ; } } return false ; }
5966	public function permReset ( ) { $ token = $ this -> request ( "permreset" ) -> toList ( ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ this , $ token [ "token" ] ) ; return $ token [ "token" ] ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
12896	public function isClosingAfterOpening ( ) { $ diff = $ this -> getOpeningDate ( ) -> diff ( $ this -> getClosingDate ( ) ) ; if ( $ diff -> invert === 0 ) { return true ; } else { return false ; } }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
5959	public function clientGetByUid ( $ uid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_unique_identifier" ] == $ uid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
1992	public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; $ strLanguage = str_replace ( '-' , '_' , $ strLanguage ) ; if ( ! \ is_array ( $ arrData ) || ! isset ( $ arrData [ $ strLanguage ] ) ) { return array ( ) ; } return $ arrData [ $ strLanguage ] ; }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
6399	public function createEvents ( array $ events ) { $ results = [ ] ; foreach ( $ events as $ index => $ opts ) { $ route = isset ( $ opts [ 'eventname' ] ) ? $ opts [ 'eventname' ] : '' ; if ( isset ( static :: $ routes [ $ route ] ) && ( $ opts [ 'userid' ] > 0 || $ opts [ 'relateduserid' ] > 0 ) ) { try { $ event = '\LogExpander\Events\\' . static :: $ routes [ $ route ] ; array_push ( $ results , ( new $ event ( $ this -> repo ) ) -> read ( $ opts ) ) ; } catch ( \ Exception $ e ) { } } } return $ results ; }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
11620	public function auth ( ) : \ TheCMSThread \ Core \ Main \ Auth { static $ auth ; if ( $ auth === null ) { $ auth = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Auth" ) ; } $ auth -> __construct ( ) ; return $ auth ; }
10406	public function remove ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair !== null ) { $ this -> repository -> remove ( $ pair -> getId ( ) ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> refresh ( ) ; } }
1002	public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
5223	protected function getValueCreator ( $ value ) { if ( is_string ( $ value ) && class_exists ( $ value ) ) { return function ( $ injector ) use ( $ value ) { return $ injector -> getInstance ( $ value ) ; } ; } return function ( ) use ( $ value ) { return $ value ; } ; }
9604	public function scalarTripleProduct ( self $ b , self $ c ) { return $ this -> dotProduct ( $ b -> crossProduct ( $ c ) ) ; }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
7110	protected function getTicketFromEvent ( ResourceEventInterface $ event ) { $ ticket = $ event -> getResource ( ) ; if ( ! $ ticket instanceof TicketInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketInterface :: class ) ; } return $ ticket ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
12488	public static function write ( $ output ) { if ( self :: $ enabled ) { $ d = new \ DateTime ( ) ; $ f = new File ( self :: $ logFilePath , true ) ; $ f -> write ( $ d -> format ( 'd/m/Y H:i:s' ) . ' - ' . $ output . "\n" , true ) ; } }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
12053	public function set ( $ name , AbstractModule $ module ) { $ this -> container [ ( string ) $ name ] = $ module ; return $ this ; }
698	public function actionRun ( $ command ) { $ command = implode ( ' ' , \ func_get_args ( ) ) ; $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ dirs = $ this -> listSubDirs ( "$base/extensions" ) ; $ dirs = array_merge ( $ dirs , $ this -> listSubDirs ( "$base/apps" ) ) ; asort ( $ dirs ) ; $ oldcwd = getcwd ( ) ; foreach ( $ dirs as $ dir ) { $ displayDir = substr ( $ dir , \ strlen ( $ base ) ) ; $ this -> stdout ( "Running '$command' in $displayDir...\n" , Console :: BOLD ) ; chdir ( $ dir ) ; passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } chdir ( $ oldcwd ) ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
2801	protected static function generateNonLazyBeanCode ( string $ padding , string $ beanId , string $ beanType , Bean $ beanMetadata , string $ methodParams , ForceLazyInitProperty $ forceLazyInitProperty , SessionBeansProperty $ sessionBeansProperty , BeanPostProcessorsProperty $ postProcessorsProperty , WrapBeanAsLazy $ wrapBeanAsLazy ) : string { $ content = $ padding . '$backupForceLazyInit = $this->' . $ forceLazyInitProperty -> getName ( ) . ';' . PHP_EOL ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . 'if($this->' . $ sessionBeansProperty -> getName ( ) . '->has("' . $ beanId . '")) {' . PHP_EOL ; if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . ' $sessionInstance = clone $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } else { $ content .= $ padding . ' $sessionInstance = $this->' . $ sessionBeansProperty -> getName ( ) . '->get("' . $ beanId . '");' . PHP_EOL ; } $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $sessionInstance) : $sessionInstance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSingleton ( ) ) { $ content .= $ padding . 'static $instance = null;' . PHP_EOL ; $ content .= $ padding . 'if ($instance !== null) {' . PHP_EOL ; $ content .= $ padding . ' return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; $ content .= $ padding . '}' . PHP_EOL ; } if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = true;' . PHP_EOL ; } $ content .= self :: generateBeanCreationCode ( $ padding , $ beanId , $ methodParams , $ postProcessorsProperty ) ; if ( $ beanMetadata -> isSession ( ) ) { $ content .= $ padding . '$this->' . $ forceLazyInitProperty -> getName ( ) . ' = $backupForceLazyInit;' . PHP_EOL ; $ content .= $ padding . '$this->' . $ sessionBeansProperty -> getName ( ) . '->add("' . $ beanId . '", $instance);' . PHP_EOL ; } $ content .= $ padding . 'return ($backupForceLazyInit) ? $this->' . $ wrapBeanAsLazy -> getName ( ) . '("' . $ beanId . '", "' . $ beanType . '", $instance) : $instance;' . PHP_EOL ; return $ content ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
11893	private function createEditForm ( CustomField $ entity , $ type ) { $ form = $ this -> createForm ( 'custom_field_choice' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfield_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , 'type' => $ type , 'group_widget' => 'hidden' ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
4034	public function getLabel ( $ table ) : string { if ( strpos ( $ table , 'tl_' ) !== 0 ) { return $ table ; } $ shortTable = str_replace ( 'tl_' , '' , $ table ) ; $ label = $ this -> translator -> trans ( 'BRD.' . $ shortTable , [ ] , 'contao_default' ) ; if ( $ label === $ shortTable ) { $ shortTable = str_replace ( 'tl_metamodel_' , '' , $ table ) ; return ucfirst ( $ shortTable ) . ' %s' ; } return StringUtil :: specialchars ( $ label ) ; }
11428	public function toSelect ( array & $ optgroups = [ ] , $ level = 1 , $ root = true ) { $ options = [ ] ; foreach ( $ this -> items as $ item ) { $ options [ ] = $ item -> toSelect ( ) ; } if ( $ root === true ) { $ text = $ this -> text ; } else { $ text = '|' . str_repeat ( '-' , $ level ) . ' ' . $ this -> text ; } $ optgroups [ ] = [ 'text' => $ text , 'options' => $ options , ] ; foreach ( $ this -> groups as $ group ) { $ group -> toSelect ( $ optgroups , $ level + 1 , false ) ; } }
2149	public function createNewUser ( $ intUser , $ arrData ) { $ arrNewsletters = StringUtil :: deserialize ( $ arrData [ 'newsletter' ] , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } $ time = time ( ) ; foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; if ( $ objRecipient -> count < 1 ) { $ this -> Database -> prepare ( "INSERT INTO tl_newsletter_recipients SET pid=?, tstamp=$time, email=?, addedOn=$time" ) -> execute ( $ intNewsletter , $ arrData [ 'email' ] ) ; } } }
484	public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
7937	public function createBackupFTPAccess ( $ domain , $ ipBlock ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; $ payload = array ( 'ftp' => ( 1 == 1 ) , 'ipBlock' => $ ipBlock , 'nfs' => ( 1 == 0 ) , 'cifs' => ( 1 == 0 ) ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/features/backupFTP/access' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2318	public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/assets/contao/images/' . $ filename . '.svg' ) ) { return 'assets/contao/images/' . $ filename . '.svg' ; } return 'assets/contao/images/' . $ src ; } else { $ theme = Backend :: getTheme ( ) ; if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'system/themes/' . $ theme . '/icons/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ) ) { return 'system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ; } return 'system/themes/' . $ theme . '/images/' . $ src ; } }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
12532	public function update ( array $ deviceIdentifier , $ comment ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'comment' => $ comment , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_UPDATE , $ params ] ) ; }
12267	public function renderCmsBlock ( BaseBlock $ block , $ username , array $ options = array ( ) ) { $ blockTemplate = $ this -> fetchTemplateBlock ( $ block ) ; if ( $ blockTemplate == "" ) { return "" ; } $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( ) ; $ options = array_merge ( array ( 'block' => $ block , 'permalinks' => $ permalinks , ) , $ options ) ; return $ this -> templating -> render ( $ blockTemplate , $ options ) ; }
12639	protected function rethrowExceptions ( callable $ callable ) { try { return $ callable ( ) ; } catch ( ImplementationNotFoundException $ ex ) { throw new ImplementationNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( TypeMismatchException $ ex ) { throw new TypeMismatchException ( $ ex -> getMessage ( ) ) ; } catch ( UnresolveableArgumentException $ ex ) { throw new UnresolveableArgumentException ( $ ex -> getMessage ( ) ) ; } catch ( ValueNotFoundException $ ex ) { throw new ValueNotFoundException ( $ ex -> getMessage ( ) ) ; } catch ( InvalidCallableFormatException $ ex ) { throw new InvalidCallableFormatException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionIdentifierException $ ex ) { throw new MissingDefinitionIdentifierException ( $ ex -> getMessage ( ) ) ; } catch ( MissingDefinitionValueException $ ex ) { throw new MissingDefinitionValueException ( $ ex -> getMessage ( ) ) ; } catch ( ClassNotFoundException $ ex ) { throw new ClassNotFoundException ( $ ex -> getMessage ( ) ) ; } }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
8567	private function _convertGetShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentId ( ) ) { $ parameters [ 'ShipmentId' ] = $ request -> getShipmentId ( ) ; } return $ parameters ; }
1348	public function allow ( string $ resourceType , array $ fields = null ) : self { $ this -> all = false ; $ this -> allowed [ $ resourceType ] = $ fields ; return $ this ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
10905	public function getList ( $ asStrings = false ) { $ list = scandir ( $ this -> path ) ; if ( $ asStrings === true ) { return array_diff ( $ list , [ "." , ".." ] ) ; } $ ret = [ ] ; foreach ( $ list as $ name ) { if ( $ name === "." || $ name === ".." ) { continue ; } $ path = $ this -> path . DIRECTORY_SEPARATOR . $ name ; $ ret [ ] = ( is_dir ( $ path ) ) ? new static ( $ path ) : new FileEntity ( $ path ) ; } return $ ret ; }
2103	public function hasOldDatabase ( ) : bool { if ( ! $ this -> hasTable ( 'tl_layout' ) ) { return false ; } $ sql = $ this -> connection -> getDatabasePlatform ( ) -> getListTableColumnsSQL ( 'tl_layout' , $ this -> connection -> getDatabase ( ) ) ; $ columns = $ this -> connection -> fetchAll ( $ sql ) ; foreach ( $ columns as $ column ) { if ( 'sections' === $ column [ 'Field' ] ) { return ! \ in_array ( $ column [ 'Type' ] , [ 'varchar(1022)' , 'blob' ] , true ) ; } } return false ; }
7765	private function documentClassProperties ( \ ML \ HydraBundle \ Mapping \ ClassMetadata $ class ) { $ result = array ( ) ; $ propertyDomain = $ this -> getTypeReferenceIri ( $ class -> getName ( ) ) ; foreach ( $ class -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( '@' , $ property -> getExposeAs ( ) , 1 ) ) { continue ; } $ result [ ] = array ( 'property' => ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : array ( '@id' => 'vocab:' . $ property -> getIri ( ) , '@type' => ( $ property -> getRoute ( ) ) ? 'hydra:Link' : 'rdf:Property' , 'label' => $ property -> getTitle ( ) , 'description' => $ property -> getDescription ( ) , 'domain' => $ propertyDomain , 'range' => $ this -> getTypeReferenceIri ( $ property -> getType ( ) ) , 'supportedOperation' => $ this -> documentOperations ( $ property -> getOperations ( ) ) ) , 'hydra:title' => $ property -> getTitle ( ) , 'hydra:description' => $ property -> getDescription ( ) , 'required' => $ property -> getRequired ( ) , 'readonly' => $ property -> isReadOnly ( ) , 'writeonly' => $ property -> isWriteOnly ( ) ) ; } return $ result ; }
4611	public function get ( $ iSize = 150 , $ sECLevel = 'L' , $ iMargin = 1 ) { return self :: API_URL . $ iSize . 'x' . $ iSize . '&cht=qr&chld=' . $ sECLevel . '|' . $ iMargin . '&chl=' . $ this -> sData ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
5126	public static function init ( array $ directories , EnvironmentInterface $ environment = null , bool $ handleErrors = true ) : ? self { if ( $ handleErrors ) { ExceptionHandler :: register ( ) ; } $ core = new static ( new Container ( ) , $ directories ) ; $ core -> container -> bindSingleton ( EnvironmentInterface :: class , $ environment ?? new Environment ( ) ) ; try { ContainerScope :: runScope ( $ core -> container , function ( ) use ( $ core ) { $ core -> bootload ( ) ; $ core -> bootstrap ( ) ; } ) ; } catch ( \ Throwable $ e ) { ExceptionHandler :: handleException ( $ e ) ; return null ; } return $ core ; }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
11503	private function createDeleteForm ( Comment $ comment ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_comment_delete' , array ( 'id' => $ comment -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
9821	public function shiftColumn ( $ fromColumn , $ toColumn ) { $ fromColumn = strtoupper ( $ fromColumn ) ; $ toColumn = strtoupper ( $ toColumn ) ; if ( ( $ fromColumn !== null ) && ( isset ( $ this -> columns [ $ fromColumn ] ) ) && ( $ toColumn !== null ) ) { $ this -> columns [ $ fromColumn ] -> setParent ( ) ; $ this -> columns [ $ fromColumn ] -> setColumnIndex ( $ toColumn ) ; $ this -> columns [ $ toColumn ] = $ this -> columns [ $ fromColumn ] ; $ this -> columns [ $ toColumn ] -> setParent ( $ this ) ; unset ( $ this -> columns [ $ fromColumn ] ) ; ksort ( $ this -> columns ) ; } return $ this ; }
12033	function addDispatchAsyncMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatchAsync' ) ; $ body = 'return $this->api->executeAsync($request, $this, $callable);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response asynchronously. Allows you to modify the request before it is sent.' ) ; $ requestParameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ requestParameter ) ; $ tag = createParamTag ( $ requestParameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ callableParameter = new ParameterGenerator ( 'callable' , 'callable' ) ; $ methodGenerator -> setParameter ( $ callableParameter ) ; $ callableTag = createParamTag ( $ callableParameter , 'The callable that processes the response' ) ; $ docBlock -> setTag ( $ callableTag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3876	private function getMetaModelsPages ( $ config , $ rootPage = null , $ language = null ) { $ metaModelsIdentifier = $ config [ 'pid' ] ; $ filterIdentifier = $ config [ 'filter' ] ; $ presetParams = StringUtil :: deserialize ( $ config [ 'filterparams' ] , true ) ; $ renderSettingId = $ config [ 'rendersetting' ] ; $ metaModels = $ this -> getMetaModel ( $ metaModelsIdentifier , false ) ; $ availableLanguages = $ this -> getLanguage ( $ language , $ metaModels ) ; $ currentLanguage = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ availableLanguages as $ newLanguage ) { $ GLOBALS [ 'TL_LANGUAGE' ] = $ newLanguage ; $ view = $ this -> getView ( $ metaModelsIdentifier , $ renderSettingId ) ; $ jumpTos = $ view -> get ( 'jumpTo' ) ; $ processed = $ this -> setFilterParameters ( $ filterIdentifier , $ presetParams , array ( ) ) ; $ filter = $ metaModels -> getEmptyFilter ( ) ; $ filterSetting = $ this -> getFilterSettings ( $ filterIdentifier ) ; $ filterSetting -> addRules ( $ filter , $ processed ) ; $ newEntries = $ this -> getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage ) ; $ this -> removeEmptyDetailPages ( $ jumpTos ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; $ this -> foundPages = array_merge ( $ this -> foundPages , $ newEntries ) ; } $ GLOBALS [ 'TL_LANGUAGE' ] = $ currentLanguage ; }
10195	public static function getPrettyQueryLog ( $ connection = "" ) { $ return_queries = [ ] ; $ queries = Capsule :: connection ( $ connection ) -> getQueryLog ( ) ; foreach ( $ queries as $ query ) { $ query_pattern = str_replace ( '?' , "'%s'" , $ query [ 'query' ] ) ; $ return_queries [ ] = vsprintf ( $ query_pattern , $ query [ 'bindings' ] ) ; } return $ return_queries ; }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
7046	protected function buildCustomerData ( Common \ SaleInterface $ sale ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { return [ 'number' => $ customer -> getNumber ( ) , 'company' => $ customer -> getCompany ( ) , 'full_name' => trim ( $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ) , 'email' => $ customer -> getEmail ( ) , 'phone' => $ this -> formatPhoneNumber ( $ customer -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ customer -> getMobile ( ) ) , ] ; } else { return [ 'number' => null , 'company' => $ sale -> getCompany ( ) , 'full_name' => trim ( $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ) , 'email' => $ sale -> getEmail ( ) , 'phone' => null , 'mobile' => null , ] ; } }
9272	protected function dataToMultipart ( array $ data = [ ] ) { $ multipart = [ ] ; foreach ( $ data as $ name => $ contents ) { array_push ( $ multipart , [ 'name' => $ name , 'contents' => $ contents ] ) ; } return $ multipart ; }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
5290	protected static function requestCurl ( $ url , $ params ) { $ ch = curl_init ( ) ; $ options = array ( CURLOPT_URL => $ url , CURLOPT_HTTPHEADER => self :: getHeaders ( ) , CURLOPT_POSTFIELDS => json_encode ( $ params ) , CURLOPT_CONNECTTIMEOUT => self :: $ connectTimeout , CURLOPT_TIMEOUT => self :: $ requestTimeout , CURLOPT_USERAGENT => self :: getUserAgent ( ) , CURLOPT_RETURNTRANSFER => true ) ; curl_setopt_array ( $ ch , $ options ) ; $ result = curl_exec ( $ ch ) ; if ( $ result === false ) { $ e = new Error ( curl_error ( $ ch ) ) ; curl_close ( $ ch ) ; throw $ e ; } curl_close ( $ ch ) ; return $ result ; }
6813	private function getNumberFormatter ( ) { if ( $ this -> numberFormatter ) { return $ this -> numberFormatter ; } return $ this -> numberFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: DECIMAL ) ; }
1120	public function getRoot ( ) { if ( $ this -> exists ) { return $ this -> ancestorsAndSelf ( ) -> whereNull ( $ this -> getParentColumnName ( ) ) -> first ( ) ; } else { $ parentId = $ this -> getParentId ( ) ; if ( ! is_null ( $ parentId ) && $ currentParent = static :: find ( $ parentId ) ) { return $ currentParent -> getRoot ( ) ; } else { return $ this ; } } }
12025	private function generateExecuteFragment ( ) { $ body = '' ; if ( $ this -> operationDefinition -> getNeedsSigning ( ) ) { $ body .= '$request = $this->api->signRequest($request);' . PHP_EOL ; } $ body .= '$response = $this->api->execute($request, $this);' . PHP_EOL ; $ body .= '$this->response = $response;' . PHP_EOL ; return $ body ; }
6319	public function execute ( ) { $ this -> preExecute ( ) ; $ result = $ this -> connection -> execute ( $ this -> getSql ( ) ) ; $ this -> postExecute ( ) ; return $ result ; }
11845	private function getRandomAddress ( ) { return ( new Address ( ) ) -> setStreetAddress1 ( $ this -> faker -> streetAddress ) -> setStreetAddress2 ( rand ( 0 , 9 ) > 5 ? $ this -> faker -> streetAddress : '' ) -> setPostcode ( $ this -> getReference ( LoadPostalCodes :: $ refs [ array_rand ( LoadPostalCodes :: $ refs ) ] ) ) -> setValidFrom ( $ this -> faker -> dateTimeBetween ( '-5 years' ) ) ; }
6624	public function process ( Request $ request ) : Response { $ router = $ request -> attributes -> get ( 'router' ) ; $ next = next ( $ this -> middlewareStack ) ; if ( $ next instanceof Middleware ) { $ router -> log ( "Router: Calling Middleware: %s" , get_class ( $ next ) ) ; $ response = $ next -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , get_class ( $ next ) ) ; return $ response ; } elseif ( is_string ( $ next ) ) { $ router -> log ( "Router: Calling Middleware: %s" , $ next ) ; $ response = $ router -> getMiddleware ( $ next ) -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , $ next ) ; return $ response ; } else { $ params = $ request -> attributes -> get ( 'controller' ) ; $ router -> log ( "Router: Calling Controller: %s@%s" , $ params -> className , $ params -> method ) ; $ return = ( new $ params -> className ( $ params -> container ) ) -> { $ params -> method } ( $ request , ... array_values ( $ params -> args ) ) ; $ router -> log ( "Router: Controller Left" ) ; if ( $ return instanceof Response ) { return $ return ; } if ( is_array ( $ return ) or is_object ( $ return ) ) { return new JsonResponse ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'application/json' ) ) ; } return new Response ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'text/html' ) ) ; } }
1447	protected function dataForDelete ( $ record ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return ResourceObject :: create ( [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'attributes' => $ schema -> getAttributes ( $ record ) , 'relationships' => collect ( $ this -> existingRelationships ( $ record ) ) -> all ( ) , ] ) -> all ( ) ; }
12038	public function drop ( $ key ) { if ( $ this -> has ( $ key ) ) { unset ( $ _SESSION [ $ this -> root ] [ $ key ] ) ; return true ; } return false ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
8461	public static function getCurrentPage ( ) { $ protocol = self :: getProtocol ( ) ; $ host = self :: getDomain ( ) ; $ port = ':' . self :: getPort ( ) ; $ port = ( ( $ port == ':80' ) || ( $ port == ':443' ) ) ? '' : $ port ; $ uri = self :: getUri ( ) ; return $ protocol . '://' . $ host . $ port . $ uri ; }
5837	public function transform ( $ orig , $ transformation = null , $ overrides = array ( ) ) { return $ this -> transformer -> transform ( $ orig , $ transformation , $ overrides ) ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
812	private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
11128	protected function getClassName ( $ fileName ) { $ namePiece = @ explode ( $ this -> config [ 'modelsPrefix' ] , $ fileName ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 1 ] : $ fileName ; $ namePiece = @ explode ( $ this -> config [ 'modelsPostfix' ] , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; $ namePiece = explode ( '.php' , $ name ) ; $ name = isset ( $ namePiece [ 1 ] ) ? $ namePiece [ 0 ] : $ name ; return $ name ; }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
8663	private function convertGetReportRequestList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportRequestList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetReportProcessingStatusList ( ) ) { $ reportProcessingStatusList = $ request -> getReportProcessingStatusList ( ) ; foreach ( $ reportProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'ReportProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetRequestedFromDate ( ) ) { $ parameters [ 'RequestedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedFromDate ( ) ) ; } if ( $ request -> isSetRequestedToDate ( ) ) { $ parameters [ 'RequestedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getRequestedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
636	public function dropTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropTable ( $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
4054	private function fetchGroupSort ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ information ) use ( $ inputScreenId , $ metaModel ) { $ information [ 'isdefault' ] = ( bool ) $ information [ 'isdefault' ] ; $ information [ 'ismanualsort' ] = ( bool ) $ information [ 'ismanualsort' ] ; $ information [ 'rendergrouplen' ] = ( int ) $ information [ 'rendergrouplen' ] ; if ( $ information [ 'ismanualsort' ] ) { $ information [ 'rendergrouptype' ] = 'none' ; } if ( ! empty ( $ information [ 'rendersortattr' ] ) ) { if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ information [ 'rendersortattr' ] ) ) ) { @ trigger_error ( sprintf ( 'Unknown attribute "%1$s" in group sorting "%2$s.%3$s"' , $ information [ 'rendersortattr' ] , $ inputScreenId , $ information [ 'id' ] ) , E_USER_WARNING ) ; return $ information ; } $ information [ 'col_name' ] = $ attribute -> getColName ( ) ; } return $ information ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dca_sortgroup' ) -> where ( 'pid=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
5452	public function startElement ( $ name , $ attributes ) { $ factory = new SimpleTagBuilder ( ) ; $ tag = $ factory -> createTag ( $ name , $ attributes ) ; if ( ! $ tag ) { return true ; } if ( $ tag -> getTagName ( ) === 'label' ) { $ this -> acceptLabelStart ( $ tag ) ; $ this -> openTag ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'form' ) { $ this -> acceptFormStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frameset' ) { $ this -> acceptFramesetStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frame' ) { $ this -> acceptFrame ( $ tag ) ; return true ; } if ( $ tag -> isPrivateContent ( ) && ! isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag = $ tag ; } if ( $ tag -> expectEndTag ( ) ) { $ this -> openTag ( $ tag ) ; return true ; } $ this -> acceptTag ( $ tag ) ; return true ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
5304	public function getPath ( $ scale = 1 , $ roundPrecision = null , $ flip = 'none' , $ onlyFilled = true , $ xOffset = 0 , $ yOffset = 0 ) { $ path = $ this -> getPathPart ( $ this -> xmlDocument , $ onlyFilled ) ; if ( $ scale !== 1 || $ roundPrecision !== null || $ flip !== 'none' || $ xOffset !== 0 || $ yOffset !== 0 ) { $ path = $ this -> transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset / $ scale , $ yOffset / $ scale ) ; } return trim ( $ path ) ; }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
11319	function query ( $ sql , $ params = array ( ) ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ sql = $ this -> printf ( $ sql , $ params ) ; if ( $ this -> debug ) { echo $ sql . "<br><br>" ; } try { $ data = $ db -> query ( $ sql ) ; if ( $ this -> debug ) { echo '<pre>' ; var_dump ( $ data ) ; echo "</pre><br><br>" ; } $ this -> error = false ; return $ data ; } catch ( Exception $ e ) { $ this -> error = true ; echo 'error' ; } }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
8606	public function listSubscriptions ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListSubscriptionsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListSubscriptionsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListSubscriptionsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7737	private function getAnnotation ( Reflector $ element , $ annotation ) { if ( $ element instanceof ReflectionClass ) { return $ this -> reader -> getClassAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionMethod ) { return $ this -> reader -> getMethodAnnotation ( $ element , $ annotation ) ; } elseif ( $ element instanceof ReflectionProperty ) { return $ this -> reader -> getPropertyAnnotation ( $ element , $ annotation ) ; } return null ; }
9094	public function handle ( ) { try { if ( $ this -> validate ( ) ) { $ result = $ this -> update ( ) ; } } catch ( \ hypeJunction \ Exceptions \ ActionValidationException $ ex ) { register_error ( elgg_echo ( 'prototyper:validate:error' ) ) ; forward ( REFERER ) ; } catch ( \ IOException $ ex ) { register_error ( elgg_echo ( 'prototyper:io:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } catch ( \ Exception $ ex ) { register_error ( elgg_echo ( 'prototyper:handle:error' , array ( $ ex -> getMessage ( ) ) ) ) ; forward ( REFERER ) ; } if ( $ result ) { system_message ( elgg_echo ( 'prototyper:action:success' ) ) ; forward ( $ this -> entity -> getURL ( ) ) ; } else { register_error ( elgg_echo ( 'prototyper:action:error' ) ) ; forward ( REFERER ) ; } }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
5331	public function getEmojiCodeList ( ) { return [ 0x203c , 0x2049 , 0x2122 , 0x2139 , range ( 0x2194 , 0x2199 ) , range ( 0x21a9 , 0x21aa ) , range ( 0x231a , 0x231b ) , 0x2328 , range ( 0x23ce , 0x23cf ) , range ( 0x23e9 , 0x23f3 ) , range ( 0x23f8 , 0x23fa ) , 0x24c2 , range ( 0x25aa , 0x25ab ) , 0x25b6 , 0x25c0 , range ( 0x25fb , 0x25fe ) , range ( 0x2600 , 0x2604 ) , 0x260e , 0x2611 , range ( 0x2614 , 0x2615 ) , 0x2618 , 0x261d , 0x2620 , range ( 0x2622 , 0x2623 ) , 0x2626 , 0x262a , range ( 0x262e , 0x262f ) , range ( 0x2638 , 0x263a ) , 0x2640 , 0x2642 , range ( 0x2648 , 0x2653 ) , 0x2660 , 0x2663 , range ( 0x2665 , 0x2666 ) , 0x2668 , 0x267b , 0x267f , range ( 0x2692 , 0x2697 ) , 0x2699 , range ( 0x269b , 0x269c ) , range ( 0x26a0 , 0x26a1 ) , range ( 0x26aa , 0x26ab ) , range ( 0x26b0 , 0x26b1 ) , range ( 0x26bd , 0x26be ) , range ( 0x26c4 , 0x26c5 ) , 0x26c8 , range ( 0x26ce , 0x26cf ) , 0x26d1 , range ( 0x26d3 , 0x26d4 ) , range ( 0x26e9 , 0x26ea ) , range ( 0x26f0 , 0x26f5 ) , range ( 0x26f7 , 0x26fa ) , 0x26fd , 0x2702 , 0x2705 , range ( 0x2708 , 0x270d ) , 0x270f , 0x2712 , 0x2714 , 0x2716 , 0x271d , 0x2721 , 0x2728 , range ( 0x2733 , 0x2734 ) , 0x2744 , 0x2747 , 0x274c , 0x274e , range ( 0x2753 , 0x2755 ) , 0x2757 , range ( 0x2763 , 0x2764 ) , range ( 0x2795 , 0x2797 ) , 0x27a1 , 0x27b0 , 0x27bf , range ( 0x2934 , 0x2935 ) , range ( 0x2b05 , 0x2b07 ) , range ( 0x2b1b , 0x2b1c ) , 0x2b50 , 0x2b55 , 0x3030 , 0x303d , 0x3297 , 0x3299 , 0x200d , 0x20e3 , 0xfe0f , range ( 0x1f000 , 0x1f9cf ) ] ; }
3031	public function resumeSession ( AssessmentTestSession $ session ) { $ deliveryExecutionState = $ this -> getSessionState ( $ session ) ; if ( $ deliveryExecutionState === DeliveryExecution :: STATE_PAUSED ) { $ this -> updateTimeReference ( $ session ) ; $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_ACTIVE ) ; } }
9849	public function createSignedResponse ( int $ status , string $ body , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( $ body ) ) ; }
452	public function update ( $ table , $ columns , $ condition , & $ params ) { list ( $ lines , $ params ) = $ this -> prepareUpdateSets ( $ table , $ columns , $ params ) ; $ sql = 'UPDATE ' . $ this -> db -> quoteTableName ( $ table ) . ' SET ' . implode ( ', ' , $ lines ) ; $ where = $ this -> buildWhere ( $ condition , $ params ) ; return $ where === '' ? $ sql : $ sql . ' ' . $ where ; }
5244	private function prefixNamespace ( string $ targetFile ) { $ pattern = sprintf ( '/%1$s\\s+(?!(%2$s)|(Composer(\\\\|;)))/' , 'namespace' , $ this -> namespacePrefix ) ; $ replacement = sprintf ( '%1$s %2$s' , 'namespace' , $ this -> namespacePrefix ) ; $ this -> replace ( $ pattern , $ replacement , $ targetFile ) ; }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
8892	public function consumeSlimContainer ( Set $ container ) { foreach ( $ container as $ key => $ value ) { if ( $ value instanceof \ Closure ) { $ refFunc = new \ ReflectionFunction ( $ value ) ; $ shared = in_array ( 'object' , $ refFunc -> getStaticVariables ( ) ) ; $ this -> registerFactory ( $ key , $ value , $ shared ) ; } elseif ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } } }
8949	function constructUrl ( Request $ appRequest , Nette \ Http \ Url $ refUrl ) { return $ this -> getRouter ( ) -> constructUrl ( $ appRequest , $ refUrl ) ; }
1645	public function getDistance ( Coordinate $ coordinate , DistanceInterface $ calculator ) : float { return $ calculator -> getDistance ( $ this , $ coordinate ) ; }
2485	public function bulkIndexDocuments ( array $ documents ) { $ documentMap = array ( ) ; $ mainTranslationsEndpoint = $ this -> endpointResolver -> getMainLanguagesEndpoint ( ) ; $ mainTranslationsDocuments = array ( ) ; foreach ( $ documents as $ translationDocuments ) { foreach ( $ translationDocuments as $ document ) { $ documentMap [ $ document -> languageCode ] [ ] = $ document ; if ( $ mainTranslationsEndpoint !== null && $ document -> isMainTranslation ) { $ mainTranslationsDocuments [ ] = $ this -> getMainTranslationDocument ( $ document ) ; } } } foreach ( $ documentMap as $ languageCode => $ translationDocuments ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getIndexingTarget ( $ languageCode ) ) , $ translationDocuments ) ; } if ( ! empty ( $ mainTranslationsDocuments ) ) { $ this -> doBulkIndexDocuments ( $ this -> endpointRegistry -> getEndpoint ( $ mainTranslationsEndpoint ) , $ mainTranslationsDocuments ) ; } }
582	public function setAssetManager ( $ assetManager ) { if ( is_scalar ( $ assetManager ) ) { throw new Exception ( '"' . get_class ( $ this ) . '::assetManager" should be either object or array - "' . gettype ( $ assetManager ) . '" given.' ) ; } $ this -> _assetManager = $ assetManager ; }
10275	public static function getTextWidthPixelsExact ( $ text , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { if ( ! function_exists ( 'imagettfbbox' ) ) { throw new PhpSpreadsheetException ( 'GD library needs to be enabled' ) ; } $ fontFile = self :: getTrueTypeFontFileFromFont ( $ font ) ; $ textBox = imagettfbbox ( $ font -> getSize ( ) , $ rotation , $ fontFile , $ text ) ; $ lowerLeftCornerX = $ textBox [ 0 ] ; $ lowerRightCornerX = $ textBox [ 2 ] ; $ upperRightCornerX = $ textBox [ 4 ] ; $ upperLeftCornerX = $ textBox [ 6 ] ; $ textWidth = max ( $ lowerRightCornerX - $ upperLeftCornerX , $ upperRightCornerX - $ lowerLeftCornerX ) ; return $ textWidth ; }
1656	public function add ( $ message ) { if ( is_string ( $ message ) ) { $ this -> messages [ ] = new SimpleResponse ( $ message ) ; } elseif ( $ message instanceof ResponseInterface ) { $ this -> messages [ ] = $ message ; } elseif ( $ message instanceof QuestionInterface ) { $ this -> messages [ ] = $ message ; } return $ this ; }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
3094	public function getAvailableActions ( ) { return is_array ( $ this -> getOption ( self :: ACTIONS_OPTION ) ) ? $ this -> getOption ( self :: ACTIONS_OPTION ) : [ ] ; }
5117	public function deleteArticle ( string $ idArticle ) : ? string { $ articleOnRest = $ this -> getArticle ( $ idArticle ) ; if ( ! empty ( $ articleOnRest ) ) { $ articleOnRest = json_decode ( $ articleOnRest , true ) ; if ( isset ( $ articleOnRest [ 'data' ] ) ) { foreach ( Article :: getDeleteableAttachment ( ) as $ field ) { if ( isset ( $ articleOnRest [ 'data' ] [ $ field ] ) ) { foreach ( $ articleOnRest [ 'data' ] [ $ field ] as $ attachment ) { if ( isset ( $ attachment [ $ field . '_order' ] ) ) { $ this -> deleteAttachment ( $ idArticle , $ field , $ attachment [ $ field . '_order' ] ) ; } } } } } return $ this -> delete ( $ this -> getArticleWithIdEndPoint ( $ idArticle ) ) ; } }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
10412	public function loadUrlsFromDocument ( $ type , SeoAwareInterface $ document ) { if ( $ this -> invalidateSeoUrls ) { $ urls = $ document -> getUrls ( ) ; if ( is_array ( $ urls ) || $ urls instanceof \ Traversable ) { foreach ( $ urls as $ url ) { $ this -> addUrl ( $ url -> getUrl ( ) ) ; } } } foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getDocumentUrls ( $ type , $ document , $ this -> router ) ) ; $ this -> addMultipleDocumentParameters ( $ collector -> getDocumentParameters ( $ type , $ document ) ) ; } }
2515	public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
6155	protected function convertValue ( $ value ) { switch ( $ this -> propertyType -> getDataTypeId ( ) ) { case PropertyType :: DATATYPE_BOOLEAN : return ( bool ) $ value ; break ; case PropertyType :: DATATYPE_DATETIME : if ( $ value instanceof \ DateTime ) { return $ value ; } try { return new \ DateTime ( $ value ) ; } catch ( \ Exception $ e ) { return null ; } break ; case PropertyType :: DATATYPE_FLOAT : return ( float ) $ value ; break ; case PropertyType :: DATATYPE_INTEGER : return ( int ) $ value ; break ; case PropertyType :: DATATYPE_STRING : return ( string ) $ value ; break ; default : return $ value ; break ; } }
11215	public static function __callstatic ( $ method , $ params ) { $ uri = $ params [ 0 ] ; $ callback = $ params [ 1 ] ; array_push ( self :: $ routes , $ uri ) ; array_push ( self :: $ methods , strtoupper ( $ method ) ) ; array_push ( self :: $ callbacks , $ callback ) ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
8153	public function removeExtension ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.12 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to remove extension "%s" as extensions have already been initialized.' , $ name ) ) ; } $ class = ltrim ( $ name , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } unset ( $ this -> extensions [ $ class ] ) ; } unset ( $ this -> extensions [ $ class ] ) ; $ this -> updateOptionsHash ( ) ; }
10845	protected function refreshProductBuyPrices ( ProductInterface $ product ) { $ buyPrice = $ product -> getBuyPrice ( ) ; $ grossAmount = $ buyPrice -> getGrossAmount ( ) ; $ taxRate = $ product -> getBuyPriceTax ( ) -> getValue ( ) ; $ netAmount = TaxHelper :: calculateNetPrice ( $ grossAmount , $ taxRate ) ; $ buyPrice -> setTaxRate ( $ taxRate ) ; $ buyPrice -> setTaxAmount ( $ grossAmount - $ netAmount ) ; $ buyPrice -> setNetAmount ( $ netAmount ) ; }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
726	public function getAttribute ( $ attribute ) { try { return parent :: getAttribute ( $ attribute ) ; } catch ( \ PDOException $ e ) { switch ( $ attribute ) { case self :: ATTR_SERVER_VERSION : return $ this -> query ( "SELECT CAST(SERVERPROPERTY('productversion') AS VARCHAR)" ) -> fetchColumn ( ) ; default : throw $ e ; } } }
9372	public function run ( ) { if ( static :: $ container -> has ( self :: ERROR_HANDLER ) ) { $ debugger = static :: $ container -> get ( self :: ERROR_HANDLER ) ; $ debugger -> display ( ) ; } $ request = static :: $ container -> get ( self :: SERVER_REQUEST ) ; echo ( string ) $ this -> emit ( $ request ) -> getBody ( ) ; }
2983	protected function makePathRelative ( $ absolutePath ) { $ projectRootDir = dirname ( $ this -> getContainer ( ) -> getParameter ( 'kernel.root_dir' ) ) ; return str_replace ( $ projectRootDir . '/' , '' , realpath ( $ absolutePath ) ? : $ absolutePath ) ; }
10392	protected static function parseXml ( $ xmlFile ) { $ reader = new \ XMLReader ( ) ; $ libXmlErrors = libxml_use_internal_errors ( true ) ; $ errors = array ( ) ; if ( ! $ reader -> open ( $ xmlFile ) ) { throw new XmlParserException ( $ xmlFile , array ( ) ) ; } $ current = $ root = new Document ( ) ; $ parents = array ( $ root ) ; while ( @ $ reader -> read ( ) ) { switch ( $ reader -> nodeType ) { case \ XMLReader :: ELEMENT : $ nodeName = $ reader -> name ; array_push ( $ parents , $ current ) ; $ current = $ current -> $ nodeName = new Node ( ) ; $ emptyElement = $ reader -> isEmptyElement ; if ( $ reader -> hasAttributes ) { while ( $ reader -> moveToNextAttribute ( ) ) { $ current [ $ reader -> name ] = $ reader -> value ; } } if ( ! $ emptyElement ) { break ; } case \ XMLReader :: END_ELEMENT : $ current = array_pop ( $ parents ) ; break ; case \ XMLReader :: TEXT : case \ XMLReader :: CDATA : $ current -> setContent ( ( string ) $ current . $ reader -> value ) ; break ; } } if ( count ( $ errors = libxml_get_errors ( ) ) ) { libxml_use_internal_errors ( $ libXmlErrors ) ; libxml_clear_errors ( ) ; throw new XmlParserException ( $ xmlFile , $ errors ) ; } libxml_use_internal_errors ( $ libXmlErrors ) ; return $ root -> skipRoot ( ) ; }
11951	private function getOauthParams ( $ nonce ) { $ params = [ 'oauth_nonce' => $ nonce , 'oauth_timestamp' => time ( ) , ] ; if ( isset ( $ this -> oauth_token ) ) { $ params [ 'oauth_token' ] = $ this -> oauth_token ; } $ params = $ this -> oauthConfig -> toArray ( $ params ) ; return $ params ; }
9320	protected function getEchoMethods ( ) { $ methods = [ 'compileRawEchos' => strlen ( stripcslashes ( $ this -> rawTags [ 0 ] ) ) , 'compileEscapedEchos' => strlen ( stripcslashes ( $ this -> escapedTags [ 0 ] ) ) , 'compileMarkdownEchos' => strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) , 'compileRegularEchos' => strlen ( stripcslashes ( $ this -> contentTags [ 0 ] ) ) , ] ; uksort ( $ methods , function ( $ method1 , $ method2 ) use ( $ methods ) { if ( $ methods [ $ method1 ] > $ methods [ $ method2 ] ) { return - 1 ; } if ( $ methods [ $ method1 ] < $ methods [ $ method2 ] ) { return 1 ; } if ( $ method1 === 'compileRawEchos' ) { return - 1 ; } if ( $ method2 === 'compileRawEchos' ) { return 1 ; } if ( $ method1 === 'compileEscapedEchos' ) { return - 1 ; } if ( $ method2 === 'compileEscapedEchos' ) { return 1 ; } if ( $ method1 === 'compileMarkdownEchos' ) { return - 1 ; } if ( $ method2 === 'compileMarkdownEchos' ) { return 1 ; } } ) ; return $ methods ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
5348	public function installOperatingSystem ( $ vpsName , $ operatingSystemName , $ hostname ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystem' , [ $ vpsName , $ operatingSystemName , $ hostname ] ) ; }
7274	protected function decodeValue ( $ val , $ column = "" ) { if ( $ column === static :: $ idColumn ) $ val = ( int ) $ val ; else if ( isset ( static :: $ casts [ $ column ] ) ) { switch ( static :: $ casts [ $ column ] ) { case "object" : $ val = from_json ( $ val , false ) ; break ; case "array" : $ val = from_json ( $ val , true ) ; break ; default : settype ( $ val , static :: $ casts [ $ column ] ) ; } } else if ( in_array ( $ column , static :: $ jsons ) && is_string ( $ val ) ) $ val = from_json ( $ val ) ; return $ val ; }
10916	private function logScriptOutput ( ) { $ output_buffers = array ( ) ; $ ob_cnt = 0 ; while ( ob_get_level ( ) > $ this -> output_buffer_level ) { $ output = trim ( ob_get_contents ( ) ) ; ++ $ ob_cnt ; ob_end_clean ( ) ; if ( ! empty ( $ output ) ) { $ lines = explode ( "\n" , $ output ) ; foreach ( $ lines as $ n => $ line ) self :: $ logger -> debug ( "Script output: {0}/{1}: {2}" , [ $ ob_cnt , $ n + 1 , $ line ] ) ; } } }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
9635	public function read ( $ path , $ blocking = false ) { $ size = filesize ( $ path ) ; if ( $ size === 0 ) { return '' ; } $ flockFlags = $ blocking ? LOCK_SH : LOCK_SH | LOCK_NB ; $ file = fopen ( $ path , 'r' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } $ contents = fread ( $ file , $ size ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; return $ contents ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
12380	public static function fromReflectionParam ( ReflectionParameter $ param , ReflectionFunctionAbstract $ func = null , Exception $ previous = null , $ afterMessage = null ) { $ message = static :: makeMessage ( $ param , $ func ) ; if ( $ previous ) { $ message .= ' - ' . $ previous -> getMessage ( ) ; } if ( $ afterMessage ) { $ message .= ' - ' . $ afterMessage ; } return new static ( $ message , 0 , $ previous ) ; }
11236	public function url ( $ url = null , $ append = '' ) { unset ( $ _POST ) ; unset ( $ _FILES ) ; header ( 'location: ' . $ this -> getRedirect ( $ url ) . $ append ) ; exit ; }
10875	public function getDecodeHash ( string $ hash ) : array { $ decode = base64_decode ( $ hash ) ; list ( $ part1 , $ part2 ) = explode ( self :: PART_SEPARATOR , $ decode ) ; $ p1 = explode ( self :: TIME_SEPARATOR , $ part1 ) ; list ( $ linkValidate , ) = $ p1 ; $ id = null ; $ verifyHash = null ; $ dateNow = new DateTime ( ) ; $ dateValidate = $ dateNow ; if ( $ linkValidate == self :: NO_TIME ) { $ linkValidate = $ dateNow -> getTimestamp ( ) ; } $ dateValidate -> setTimestamp ( ( int ) $ linkValidate ) ; if ( $ dateValidate >= $ dateNow ) { $ p2 = explode ( self :: ID_SEPARATOR , $ part2 ) ; $ verifyHash = implode ( '.' , array_slice ( $ p2 , 0 , - 1 ) ) ; $ id = $ p2 [ count ( $ p2 ) - 1 ] ; } else { throw new IdentityException ( 'Activate link is expired!' ) ; } return [ 'id' => $ id , 'verifyHash' => $ verifyHash , 'expired' => ( int ) $ linkValidate ] ; }
11666	public function addFunction ( $ functionName , $ callback ) { if ( is_string ( $ functionName ) && is_callable ( $ callback ) ) { $ functions = [ 'name' => $ functionName , 'callable' => $ callback , ] ; array_push ( $ this -> functionList , $ functions ) ; } }
4700	protected function handleInput ( InputInterface $ input ) { if ( $ file = $ input -> getArgument ( 'file' ) ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The input file "%s" not found' , $ file ) ) ; } return file_get_contents ( $ file ) ; } else { $ contents = '' ; if ( $ stdin = fopen ( 'php://stdin' , 'r' ) ) { if ( stream_set_blocking ( $ stdin , false ) ) { $ contents = stream_get_contents ( $ stdin ) ; } fclose ( $ stdin ) ; } if ( $ contents ) { return $ contents ; } } throw new \ InvalidArgumentException ( 'No input file' ) ; }
1329	public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } }
8613	public function setAdjustmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
10827	public static function words ( array $ words , $ style = '' , $ separator = ', ' ) { self :: write ( implode ( $ separator , $ words ) , $ style ) ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
3753	public function save ( ModelInterface $ objItem , $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } if ( $ objItem instanceof Model ) { $ backupLanguage = $ this -> setLanguage ( $ this -> getCurrentLanguage ( ) ) ; $ objItem -> getItem ( ) -> save ( $ timestamp ) ; $ this -> setLanguage ( $ backupLanguage ) ; return $ objItem ; } throw new \ RuntimeException ( 'ERROR: incompatible object passed to GeneralDataMetaModel::save()' ) ; }
3160	protected function storeVariable ( QtiRunnerServiceContext $ context , $ itemUri , \ taoResultServer_models_classes_Variable $ metaVariable , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariable ( $ testUri , $ itemUri , $ metaVariable , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariable ( $ testUri , $ metaVariable , $ sessionId ) ; } return true ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
6877	private function buildRevenueData ( array $ result , $ detailed = false ) { $ data = [ ] ; foreach ( $ result as $ r ) { $ data [ $ r [ 'date' ] ] = $ detailed ? json_decode ( $ r [ 'details' ] , true ) : $ r [ 'revenue' ] ; } return $ data ; }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
5933	public function setStartDate ( $ startDate ) { if ( $ startDate instanceof DateTime ) { $ this -> startDate = $ startDate ; } else { try { $ this -> startDate = new DateTime ( $ startDate ) ; } catch ( \ Exception $ e ) { $ this -> startDate = null ; } } return $ this ; }
5284	public function limit ( $ limit , $ offset = 0 ) { global $ wpdb ; $ limit = \ absint ( $ limit ) ; $ offset = \ absint ( $ offset ) ; $ this -> limit = $ wpdb -> prepare ( 'limit %d, %d' , $ offset , $ limit ) ; return $ this ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
2084	public function rotateLogs ( ) { @ trigger_error ( 'Using Automator::rotateLogs() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead, which rotates its log files automatically.' , E_USER_DEPRECATED ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrFiles = preg_grep ( '/\.log$/' , scan ( $ rootDir . '/system/logs' ) ) ; foreach ( $ arrFiles as $ strFile ) { $ objFile = new File ( 'system/logs/' . $ strFile . '.9' ) ; if ( $ objFile -> exists ( ) ) { $ objFile -> delete ( ) ; } for ( $ i = 8 ; $ i > 0 ; $ i -- ) { $ strGzName = 'system/logs/' . $ strFile . '.' . $ i ; if ( file_exists ( $ rootDir . '/' . $ strGzName ) ) { $ objFile = new File ( $ strGzName ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.' . ( $ i + 1 ) ) ; } } $ objFile = new File ( 'system/logs/' . $ strFile ) ; $ objFile -> renameTo ( 'system/logs/' . $ strFile . '.1' ) ; } }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
9932	public function addRule ( Column \ Rule $ pRule ) { $ pRule -> setParent ( $ this ) ; $ this -> ruleset [ ] = $ pRule ; return $ this ; }
7619	public function setPermissionSet ( $ value = array ( ) ) { foreach ( $ value as $ url ) { if ( strpos ( $ url , $ this -> accountName ) === false ) { throw new Exception ( 'The permission set can only contain URLs for the account name specified in the Credentials_SharedAccessSignature instance.' ) ; } } $ this -> permissionSet = $ value ; }
11003	public function URL ( $ path = '' , $ current_url = null ) { $ url = new URL ( $ this -> url ) ; $ path = ltrim ( $ path , '/' ) ; $ url -> set ( 'path' , $ url -> path . $ path ) ; if ( $ current_url instanceof URL ) { if ( $ url -> host === $ current_url -> host && $ url -> scheme === $ current_url -> scheme && $ url -> port === $ current_url -> port ) { $ url -> host = null ; $ url -> scheme = null ; } } return $ url ; }
3011	public function follow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/follow' , $ options , false ) ; }
9562	protected function matchesTypehint ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return true ; } if ( is_array ( $ handler ) ) { $ reflection = ( new ReflectionMethod ( $ handler [ 0 ] , $ handler [ 1 ] ) ) ; } else { $ reflection = ( new ReflectionFunction ( $ handler ) ) ; } $ params = $ reflection -> getParameters ( ) ; if ( empty ( $ params ) ) { return true ; } $ handlerHint = $ params [ 0 ] -> getClass ( ) ; if ( ! $ handlerHint ) { return true ; } return $ handlerHint -> isInstance ( $ exception ) ; }
4145	protected function validateCredentials ( $ credentials ) { $ credentials = array_filter ( $ credentials ) ; $ keys = array_keys ( $ credentials ) ; $ diff = array_diff ( $ this -> requiredCredentials , $ keys ) ; if ( ! empty ( $ diff ) ) { throw new MissingCredentialsException ( 'Missing Credentials: ' . implode ( $ diff , ', ' ) ) ; } unset ( $ credentials , $ keys , $ diff ) ; }
10025	function getContact ( $ contactId , $ checksum , $ standard_fields = array ( ) , $ custom_fields = array ( ) , $ ignoreChecksum = false ) { $ queryParameters = array ( 'id' => $ contactId , 'checksum' => $ checksum , 'standard_field' => $ standard_fields , 'ignore_checksum' => $ ignoreChecksum ? "true" : "false" ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/contact' , $ queryParameters ) ; }
11651	public function getProduct ( array $ productData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ productData ) ) { throw new ProductException ( "The field '$mandatoryField' is missing in the given product data" ) ; } } try { $ sku = new SKU ( $ productData [ self :: FIELD_SKU ] ) ; $ slug = new Slug ( $ productData [ self :: FIELD_SLUG ] ) ; $ content = $ this -> contentMapper -> getContent ( $ productData ) ; $ product = new Product ( $ sku , $ slug , $ content ) ; return $ product ; } catch ( \ Exception $ productException ) { throw new ProductException ( sprintf ( "Failed to create a product from the given data: %s" , $ productException -> getMessage ( ) ) , $ productException ) ; } }
1578	public static function create ( array $ data ) : self { if ( ! isset ( $ data [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a resource type.' ) ; } return new self ( $ data [ 'type' ] , $ data [ 'id' ] ?? null , $ data [ 'attributes' ] ?? [ ] , $ data [ 'relationships' ] ?? [ ] , $ data [ 'meta' ] ?? [ ] , $ data [ 'links' ] ?? [ ] ) ; }
3806	private function isAttributeNameOrTypeChanged ( ModelInterface $ new , ModelInterface $ old ) { return ( $ old -> getProperty ( 'type' ) !== $ new -> getProperty ( 'type' ) ) || ( $ old -> getProperty ( 'colname' ) !== $ new -> getProperty ( 'colname' ) ) ; }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
10760	protected function buildUpdateSet ( ) { $ result = [ ] ; $ data = $ this -> clause_data [ 0 ] ; foreach ( $ data as $ col => $ val ) { $ result [ ] = $ this -> quote ( $ col ) . ' = ' . $ this -> processValue ( $ val ) ; } return $ result ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
3943	public static function prepareLanguageAwareWidget ( EnvironmentInterface $ environment , PropertyInterface $ property , IMetaModel $ metaModel , $ languageLabel , $ valueLabel , $ isTextArea , $ arrValues ) { if ( ! $ metaModel -> isTranslated ( ) ) { $ extra = $ property -> getExtra ( ) ; $ extra [ 'tl_class' ] .= empty ( $ extra [ 'tl_class' ] ) ? 'w50' : ' w50' ; $ property -> setWidgetType ( 'text' ) -> setExtra ( $ extra ) ; return ; } $ fallback = $ metaModel -> getFallbackLanguage ( ) ; $ languages = self :: buildLanguageArray ( $ metaModel , $ environment -> getTranslator ( ) ) ; $ neededKeys = array_keys ( $ languages ) ; if ( array_diff_key ( array_keys ( $ arrValues ) , $ neededKeys ) ) { foreach ( $ neededKeys as $ langCode ) { $ arrValues [ $ langCode ] = '' ; } } $ rowClasses = array ( ) ; foreach ( array_keys ( $ arrValues ) as $ langCode ) { $ rowClasses [ ] = ( $ langCode == $ fallback ) ? 'fallback_language' : 'normal_language' ; } $ extra = $ property -> getExtra ( ) ; $ extra [ 'minCount' ] = $ extra [ 'maxCount' ] = count ( $ languages ) ; $ extra [ 'disableSorting' ] = true ; $ extra [ 'tl_class' ] = 'clr' ; $ extra [ 'columnFields' ] = array ( 'langcode' => array ( 'label' => $ languageLabel , 'exclude' => true , 'inputType' => 'justtextoption' , 'options' => $ languages , 'eval' => array ( 'rowClasses' => $ rowClasses , 'valign' => 'center' , 'style' => 'min-width:75px;display:block;' ) ) , 'value' => array ( 'label' => $ valueLabel , 'exclude' => true , 'inputType' => $ isTextArea ? 'textarea' : 'text' , 'eval' => array ( 'rowClasses' => $ rowClasses , 'style' => 'width:400px;' , 'rows' => 3 ) ) , ) ; $ property -> setWidgetType ( 'multiColumnWizard' ) -> setExtra ( $ extra ) ; }
6995	public static function parseApplePriceMatrix ( $ dom , $ currency , $ directory = null ) { if ( is_string ( $ dom ) ) { if ( file_exists ( $ dom ) && is_file ( $ dom ) ) { $ file = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; unset ( $ file ) ; } else { $ content = $ dom ; $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTML ( $ content ) ; unset ( $ content ) ; } } if ( ! $ dom instanceof \ DOMDocument ) { throw new \ InvalidArgumentException ( sprintf ( 'The first argument must be a DOMDocument instance or path to ApplePriceMatrix file, "%s" given.' , is_object ( $ dom ) ? get_class ( $ dom ) : gettype ( $ dom ) ) ) ; } $ currency = strtoupper ( $ currency ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ tierPrimary = static :: parseApplePriceMatrixTier ( $ xpath , 1 , $ currency ) ; $ tierAlternative = static :: parseApplePriceMatrixTier ( $ xpath , 2 , $ currency ) ; $ prices = $ tierPrimary + $ tierAlternative ; ksort ( $ prices ) ; if ( $ directory ) { if ( ! is_writable ( $ directory ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write prices map to directory "%s". Directory is not writable.' , $ directory ) ) ; } $ file = $ directory . '/' . $ currency . '.php' ; file_put_contents ( $ file , '<?php return ' . var_export ( $ prices , 1 ) . ';' ) ; } return $ prices ; }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
881	private function fixTypes ( Annotation $ annotation ) { $ types = $ annotation -> getTypes ( ) ; $ new = $ this -> normalizeTypes ( $ types ) ; if ( $ types !== $ new ) { $ annotation -> setTypes ( $ new ) ; } }
12870	public function unbind ( ) : bool { if ( $ this -> _bConnected ) { return $ this -> _bConnected = ldap_unbind ( $ this -> _rConnect ) ; } else { return true ; } }
2143	public function generate ( $ objRootPage = null ) { global $ objPage ; $ obj403 = $ this -> prepare ( $ objRootPage ) ; $ objPage = $ obj403 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 403 Forbidden' ) ; $ objHandler -> generate ( $ objPage ) ; }
2233	public function checkPermission ( ) { if ( $ this -> User -> isAdmin ) { return ; } $ objSteps = $ this -> Database -> prepare ( "SELECT id FROM tl_undo WHERE pid=?" ) -> execute ( $ this -> User -> id ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = $ objSteps -> numRows ? $ objSteps -> fetchEach ( 'id' ) : array ( 0 ) ; if ( Contao \ Input :: get ( 'act' ) && ! \ in_array ( Contao \ Input :: get ( 'id' ) , $ GLOBALS [ 'TL_DCA' ] [ 'tl_undo' ] [ 'list' ] [ 'sorting' ] [ 'root' ] ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' undo step ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
1809	public function getContentElementGroup ( $ element ) { foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { if ( $ kk == $ element ) { return $ k ; } } } return null ; }
6865	protected function updateCustomerBalance ( InvoiceInterface $ invoice ) { if ( ! InvoiceTypes :: isCredit ( $ invoice ) ) { return ; } $ sale = $ this -> getSaleFromInvoice ( $ invoice ) ; if ( null === $ customer = $ sale -> getCustomer ( ) ) { return ; } $ methodCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'paymentMethod' ) ; $ amountCs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , 'grandTotal' ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ invoice ) ) { $ method = empty ( $ methodCs ) ? $ invoice -> getPaymentMethod ( ) : $ methodCs [ 0 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } return ; } if ( empty ( $ methodCs ) && empty ( $ amountCs ) ) { return ; } if ( ! empty ( $ methodCs ) && null !== $ method = $ methodCs [ 0 ] ) { $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 0 ] ; if ( $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , - $ amount , true ) ; } } if ( empty ( $ methodCs ) ) { $ method = $ invoice -> getPaymentMethod ( ) ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] - $ amountCs [ 0 ] ; } else { $ method = $ methodCs [ 1 ] ; $ amount = empty ( $ amountCs ) ? $ invoice -> getGrandTotal ( ) : $ amountCs [ 1 ] ; } if ( $ method && $ method -> isCredit ( ) && 0 != Money :: compare ( $ amount , 0 , $ invoice -> getCurrency ( ) ) ) { $ this -> customerUpdater -> updateCreditBalance ( $ customer , $ amount , true ) ; } }
5066	public function init ( string $ url = null ) : void { $ this -> ch = curl_init ( $ url ) ; CurlObjectLookup :: add ( $ this ) ; }
7658	function SmtpClose ( ) { if ( $ this -> smtp != NULL ) { if ( $ this -> smtp -> Connected ( ) ) { $ this -> smtp -> Quit ( ) ; $ this -> smtp -> Close ( ) ; } } }
12807	public static function where ( string $ column , string $ operator , $ value ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ column = self :: getColumnName ( $ column ) ; if ( $ column === null ) throw new ModelMissingPropertyException ( "Could not find a property '$column' of class '$class'. " . "Are you missing a '@ColumnNameAnnotation' on a property?" ) ; $ sql = "SELECT * FROM \"$tableName\" WHERE \"$column\" $operator " . ( gettype ( $ value ) === "string" ? "'$value'" : "$value" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
5387	public function setValue ( $ values ) { $ values = $ this -> makeArray ( $ values ) ; if ( ! $ this -> valuesArePossible ( $ values ) ) { return false ; } $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ widgets [ $ i ] -> getAttribute ( 'value' ) , $ values ) ) { $ widgets [ $ i ] -> setValue ( $ possible ) ; } else { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
12252	public function addMissing ( $ objStructure , & $ objElement ) { foreach ( $ objStructure -> attributes ( ) as $ strName => $ objAttribute ) { if ( ! isset ( $ objElement -> attributes ( ) -> $ strName ) ) { $ objElement -> addAttribute ( $ strName , ( string ) $ objAttribute ) ; } } foreach ( $ objStructure -> children ( ) as $ strName => $ varNode ) { if ( count ( $ varNode ) > 0 ) { $ objNode = $ objElement -> addChild ( $ strName ) ; $ this -> addMissing ( $ varNode , $ objNode ) ; } else { $ objElement -> addChild ( $ strName , ( string ) $ varNode ) ; } } }
6146	public function setStatusCode ( int $ value = null ) { if ( is_null ( $ value ) ) { return $ this ; } $ this -> statusCode = $ value ; return $ this ; }
11547	public function addGroup ( Group $ group ) { $ group -> setService ( $ this ) ; $ this -> groups [ $ group -> getName ( ) ] = $ group ; }
3361	private function exists ( $ offset = null ) { return isset ( $ this -> container [ $ offset !== null ? $ offset : $ this -> position ] ) ; }
10367	public function register ( RegisterRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'register' ) ) -> dispatchFrom ( RegisterJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.register.redirect' ) ) -> withSuccess ( trans ( 'auth::register.success' ) ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
10393	private function isValidOperation ( $ operationType ) { $ operationType = strtoupper ( $ operationType ) ; return in_array ( $ operationType , [ ActionTypes :: CREATE , ActionTypes :: UPDATE , ActionTypes :: DELETE , ] ) ; }
9437	public function getMany ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } $ arr_out = array ( ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ arr_out [ ] = $ this -> get ( ) ; } return $ arr_out ; }
11160	public function resolve ( $ url , \ GuzzleHttp \ Message \ Response $ data , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ json = json_decode ( $ data -> getBody ( ) ) ; $ logger -> info ( 'resolve' , array ( 'url' => $ url , 'json' => $ json ) ) ; if ( isset ( $ json -> error ) ) { return $ logger -> warning ( 'Query response contained an error' , array ( 'url' => $ url , 'error' => $ json -> error , ) ) ; } $ entries = $ json -> items ; if ( ! is_array ( $ entries ) || ! $ entries ) { return $ logger -> warning ( 'Query returned no results' , array ( 'url' => $ url ) ) ; } $ entry = reset ( $ entries ) ; $ replacements = $ this -> getReplacements ( $ entry ) ; $ message = str_replace ( array_keys ( $ replacements ) , array_values ( $ replacements ) , $ this -> responseFormat ) ; $ queue -> ircPrivmsg ( $ event -> getSource ( ) , $ message ) ; }
4134	public static function encryptAndAppendTag ( $ K , $ IV , $ P = null , $ A = null , $ tag_length = 128 ) { return implode ( self :: encrypt ( $ K , $ IV , $ P , $ A , $ tag_length ) ) ; }
1754	public static function getLanguages ( $ blnInstalledOnly = false ) { $ return = array ( ) ; $ languages = array ( ) ; $ arrAux = array ( ) ; $ langsNative = array ( ) ; static :: loadLanguageFile ( 'languages' ) ; include __DIR__ . '/../../config/languages.php' ; foreach ( $ languages as $ strKey => $ strName ) { $ arrAux [ $ strKey ] = isset ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) ? Utf8 :: toAscii ( $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ) : $ strName ; } asort ( $ arrAux ) ; $ arrBackendLanguages = self :: getContainer ( ) -> getParameter ( 'contao.locales' ) ; foreach ( array_keys ( $ arrAux ) as $ strKey ) { if ( $ blnInstalledOnly && ! \ in_array ( $ strKey , $ arrBackendLanguages ) ) { continue ; } $ return [ $ strKey ] = $ GLOBALS [ 'TL_LANG' ] [ 'LNG' ] [ $ strKey ] ?? $ languages [ $ strKey ] ; if ( isset ( $ langsNative [ $ strKey ] ) && $ langsNative [ $ strKey ] != $ return [ $ strKey ] ) { $ return [ $ strKey ] .= ' - ' . $ langsNative [ $ strKey ] ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getLanguages' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ return , $ languages , $ langsNative , $ blnInstalledOnly ) ; } } return $ return ; }
839	public static function fromCode ( $ code ) { $ codeHash = self :: calculateCodeHash ( $ code ) ; if ( self :: hasCache ( $ codeHash ) ) { $ tokens = self :: getCache ( $ codeHash ) ; $ tokens -> generateCode ( ) ; if ( $ codeHash === $ tokens -> codeHash ) { $ tokens -> clearEmptyTokens ( ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; } } $ tokens = new self ( ) ; $ tokens -> setCode ( $ code ) ; $ tokens -> clearChanged ( ) ; return $ tokens ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
9705	private function calcSheetOffsets ( ) { $ boundsheet_length = 10 ; $ offset = $ this -> _datasize ; $ total_worksheets = count ( $ this -> spreadsheet -> getAllSheets ( ) ) ; foreach ( $ this -> spreadsheet -> getWorksheetIterator ( ) as $ sheet ) { $ offset += $ boundsheet_length + strlen ( StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheet -> getTitle ( ) ) ) ; } for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> worksheetOffsets [ $ i ] = $ offset ; $ offset += $ this -> worksheetSizes [ $ i ] ; } $ this -> biffSize = $ offset ; }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
397	public static function getTableSchema ( ) { $ tableSchema = static :: getDb ( ) -> getSchema ( ) -> getTableSchema ( static :: tableName ( ) ) ; if ( $ tableSchema === null ) { throw new InvalidConfigException ( 'The table does not exist: ' . static :: tableName ( ) ) ; } return $ tableSchema ; }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
12197	public static function toBlock ( Serializer $ serializer , $ json ) { if ( empty ( $ json ) ) { return null ; } $ contentArray = json_decode ( $ json , true ) ; if ( ! array_key_exists ( "type" , $ contentArray ) ) { return null ; } $ className = BlockFactory :: getBlockClass ( $ contentArray [ "type" ] ) ; if ( ! class_exists ( $ className ) ) { return null ; } return $ serializer -> deserialize ( $ json , $ className , 'json' ) ; }
10786	public function run ( $ query , array $ params = array ( ) ) { $ statement = $ this -> pdo -> prepare ( $ query ) ; $ statement -> execute ( $ params ) ; return $ statement ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
5448	public function acceptStartToken ( $ token , $ event ) { if ( $ event == LEXER_ENTER ) { $ this -> tag = strtolower ( substr ( $ token , 1 ) ) ; return true ; } if ( $ event == LEXER_EXIT ) { $ success = $ this -> listener -> startElement ( $ this -> tag , $ this -> attributes ) ; $ this -> tag = '' ; $ this -> attributes = array ( ) ; return $ success ; } if ( $ token !== '=' ) { $ this -> current_attribute = strtolower ( html_entity_decode ( $ token , ENT_QUOTES ) ) ; $ this -> attributes [ $ this -> current_attribute ] = '' ; } return true ; }
8541	public function compile ( ) { if ( ! count ( $ this -> msgid ) ) return "" ; $ str = "" ; if ( $ this -> comments ) $ str .= implode ( self :: NEWLINE , $ this -> comments ) . self :: NEWLINE ; if ( $ this -> msgctxt ) $ str .= 'msgctxt "' . $ this -> msgctxt . '"' . self :: NEWLINE ; $ included_blocks = [ 'msgid' ] ; if ( $ this -> msgstr_plural ) $ included_blocks [ ] = 'msgid_plural' ; else $ included_blocks [ ] = 'msgstr' ; foreach ( $ included_blocks as $ key ) { if ( is_array ( $ this -> $ key ) ) { $ str .= "$key " ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ this -> $ key ) ) . self :: NEWLINE ; } } if ( $ this -> msgid_plural && $ this -> msgstr_plural ) { foreach ( $ this -> msgstr_plural as $ plural_key => $ plural_message ) { $ str .= 'msgstr[' . $ plural_key . '] ' ; $ str .= implode ( self :: NEWLINE , array_map ( [ $ this , 'quoteWrap' ] , $ plural_message ) ) . self :: NEWLINE ; } } return trim ( $ str ) ; }
5516	public function errorOn ( $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error on' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
4089	protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; }
12296	public function filter ( FilterRequest $ filters ) { $ search = new Search ( $ this -> model , $ filters ) ; $ this -> builder = $ search -> getBuilder ( ) ; return $ this ; }
9784	public function parseHTML ( ) { $ token = $ this -> pop ( 'HTML' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
1455	protected function validateHasOne ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasOne ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasOneExpected ( $ key ) ) ; return false ; } $ identifier = $ relationship -> getData ( ) ; if ( ! $ identifier ) { return true ; } if ( ! $ this -> validateIdentifier ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateExists ( $ identifier , $ key ) ) { return false ; } if ( ! $ this -> validateAcceptable ( $ identifier , $ record , $ key , $ resource ) ) { return false ; } return true ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
1930	public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
522	protected function createMigration ( $ class ) { $ this -> includeMigrationFile ( $ class ) ; $ migration = Yii :: createObject ( $ class ) ; if ( $ migration instanceof BaseObject && $ migration -> canSetProperty ( 'compact' ) ) { $ migration -> compact = $ this -> compact ; } return $ migration ; }
12343	public function newAction ( Request $ request ) { $ post = new Post ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ user = $ this -> container -> get ( 'security.token_storage' ) -> getToken ( ) -> getUser ( ) ; $ post -> setActor ( $ user ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.created' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'category' => $ post , 'form' => $ form -> createView ( ) , ) ; }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
2194	protected function activateAcount ( ) { $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_member' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objMember = MemberModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objMember -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objMember -> disable = '' ; $ objMember -> save ( ) ; $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objMember , $ this ) ; } } $ this -> log ( 'User account ID ' . $ objMember -> id . ' (' . Idna :: decodeEmail ( $ objMember -> email ) . ') has been activated' , __METHOD__ , TL_ACCESS ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'reg_jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'accountActivated' ] ; }
11497	public static function all ( $ pageNumber = 0 , $ pageSize = 10 , $ order = null ) { return ( new static ( ) ) -> fetchAll ( null , $ order , $ pageSize , $ pageNumber ) ; }
864	private function registerFoundToken ( $ token ) { $ tokenKind = $ token instanceof Token ? ( $ token -> isArray ( ) ? $ token -> getId ( ) : $ token -> getContent ( ) ) : ( \ is_array ( $ token ) ? $ token [ 0 ] : $ token ) ; if ( ! isset ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { $ this -> foundTokenKinds [ $ tokenKind ] = 0 ; } ++ $ this -> foundTokenKinds [ $ tokenKind ] ; }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
11177	public function create ( ? string $ name = null ) { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> creator -> create ( $ this -> filesystem , $ name ) ; }
3944	public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; if ( is_dir ( TL_ROOT . '/' . $ folder ) ) { $ scanResult = scan ( TL_ROOT . '/' . $ folder ) ; } foreach ( $ scanResult as $ value ) { if ( ! is_file ( TL_ROOT . '/' . $ folder . '/' . $ value ) ) { $ result += self :: searchFiles ( $ folder . '/' . $ value , $ extension ) ; } else { if ( preg_match ( '/' . $ extension . '$/i' , $ value ) ) { $ result [ $ folder ] [ $ folder . '/' . $ value ] = $ value ; } } } return $ result ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
11136	protected function calculateINSERT ( ) { $ this -> query .= 'INSERT INTO ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; if ( ! empty ( $ this -> inserts ) ) { $ this -> query .= ' (' ; $ this -> queryStringFromArray ( 'inserts' , '' , ', ' ) ; $ this -> query .= ')' ; } $ this -> valueStringFromArray ( 'values' , ' VALUES ' , ', ' ) ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
11207	public function getIterator ( ) { if ( ! $ this -> content || $ this -> contentModified ) { $ this -> generateContent ( ) ; } return new \ ArrayIterator ( $ this -> content ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
6055	public function addMediaToFolder ( $ folderId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ folderId . '/media' , $ parameters ) ; return $ result ; }
915	public static function camelCaseToUnderscore ( $ string ) { return Preg :: replaceCallback ( '/(^|[a-z0-9])([A-Z])/' , static function ( array $ matches ) { return strtolower ( '' !== $ matches [ 1 ] ? $ matches [ 1 ] . '_' . $ matches [ 2 ] : $ matches [ 2 ] ) ; } , $ string ) ; }
3651	protected function callParseTemplateHook ( ) { if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseTemplate' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ objCallback -> $ strMethod ( $ this ) ; } } }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
514	public function actionDown ( $ limit = 1 ) { if ( $ limit === 'all' ) { $ limit = null ; } else { $ limit = ( int ) $ limit ; if ( $ limit < 1 ) { throw new Exception ( 'The step argument must be greater than 0.' ) ; } } $ migrations = $ this -> getMigrationHistory ( $ limit ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No migration has been done before.\n" , Console :: FG_YELLOW ) ; return ExitCode :: OK ; } $ migrations = array_keys ( $ migrations ) ; $ n = count ( $ migrations ) ; $ this -> stdout ( "Total $n " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be reverted:\n" , Console :: FG_YELLOW ) ; foreach ( $ migrations as $ migration ) { $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ reverted = 0 ; if ( $ this -> confirm ( 'Revert the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateDown ( $ migration ) ) { $ this -> stdout ( "\n$reverted from $n " . ( $ reverted === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ reverted ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated down successfully.\n" , Console :: FG_GREEN ) ; } }
733	public function toArray ( array $ fields = [ ] , array $ expand = [ ] , $ recursive = true ) { $ data = [ ] ; foreach ( $ this -> resolveFields ( $ fields , $ expand ) as $ field => $ definition ) { $ attribute = is_string ( $ definition ) ? $ this -> $ definition : $ definition ( $ this , $ field ) ; if ( $ recursive ) { $ nestedFields = $ this -> extractFieldsFor ( $ fields , $ field ) ; $ nestedExpand = $ this -> extractFieldsFor ( $ expand , $ field ) ; if ( $ attribute instanceof Arrayable ) { $ attribute = $ attribute -> toArray ( $ nestedFields , $ nestedExpand ) ; } elseif ( is_array ( $ attribute ) ) { $ attribute = array_map ( function ( $ item ) use ( $ nestedFields , $ nestedExpand ) { if ( $ item instanceof Arrayable ) { return $ item -> toArray ( $ nestedFields , $ nestedExpand ) ; } return $ item ; } , $ attribute ) ; } } $ data [ $ field ] = $ attribute ; } if ( $ this instanceof Linkable ) { $ data [ '_links' ] = Link :: serialize ( $ this -> getLinks ( ) ) ; } return $ recursive ? ArrayHelper :: toArray ( $ data ) : $ data ; }
9906	public static function map ( $ color , $ palette , $ version ) { if ( $ color <= 0x07 || $ color >= 0x40 ) { return Color \ BuiltIn :: lookup ( $ color ) ; } elseif ( isset ( $ palette , $ palette [ $ color - 8 ] ) ) { return $ palette [ $ color - 8 ] ; } if ( $ version == Xls :: XLS_BIFF8 ) { return Color \ BIFF8 :: lookup ( $ color ) ; } return Color \ BIFF5 :: lookup ( $ color ) ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
38	protected function initStyles ( OutputInterface $ output ) { $ this -> colors = array ( 'green' , 'yellow' , 'cyan' , 'magenta' , 'blue' , ) ; foreach ( $ this -> colors as $ color ) { $ style = new OutputFormatterStyle ( $ color ) ; $ output -> getFormatter ( ) -> setStyle ( $ color , $ style ) ; } }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
1581	public function withAttributes ( $ attributes ) : self { $ copy = clone $ this ; $ copy -> attributes = collect ( $ attributes ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
6372	public function append ( IteratorAggregate $ other ) : FluentIterable { return self :: from ( Iterables :: concat ( $ this , $ other ) ) ; }
4632	public function responseHeaderCallback ( $ ch , $ header ) { if ( strpos ( $ header , ':' ) ) { list ( $ key , $ value ) = explode ( ':' , $ header , 2 ) ; $ value = trim ( $ value ) ; if ( ! empty ( $ value ) ) { if ( ! isset ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = $ value ; } elseif ( is_array ( $ this -> responseHeaders [ $ key ] ) ) { $ this -> responseHeaders [ $ key ] = array_merge ( $ this -> responseHeaders [ $ key ] , [ $ value ] ) ; } else { $ this -> responseHeaders [ $ key ] = array_merge ( [ $ this -> responseHeaders [ $ key ] ] , [ $ value ] ) ; } } } return strlen ( $ header ) ; }
12458	private function createCommentForm ( CommentFront $ model , $ entity ) { $ form = $ this -> createForm ( 'BlogBundle\Form\CommentFrontType' , $ model , array ( 'action' => $ this -> generateUrl ( 'blog_blog_comment' , array ( 'post' => $ entity -> getId ( ) ) ) , 'method' => 'POST' , 'attr' => array ( 'id' => 'comment-form' , 'class' => 'comment-form' ) ) ) ; return $ form ; }
7414	public function read ( ) { $ data = '' ; $ fileObj = $ this -> openFile ( ) ; while ( ! $ fileObj -> eof ( ) ) { $ data .= $ fileObj -> fread ( 4096 ) ; } $ fileObj = null ; return $ data ; }
6906	public function addExtraRecipient ( Recipient $ recipient ) { if ( ! $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> add ( $ recipient ) ; } return $ this ; }
1881	protected function isValid ( $ strFile ) { $ strFolder = Input :: get ( 'pid' , true ) ; if ( Validator :: isInsecurePath ( $ strFile ) ) { throw new AccessDeniedException ( 'Invalid file name "' . $ strFile . '" (hacking attempt).' ) ; } elseif ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new AccessDeniedException ( 'Invalid folder name "' . $ strFolder . '" (hacking attempt).' ) ; } if ( ! empty ( $ this -> arrValidFileTypes ) && is_file ( $ this -> strRootDir . '/' . $ strFile ) ) { $ fileinfo = preg_replace ( '/.*\.(.*)$/u' , '$1' , $ strFile ) ; if ( ! \ in_array ( strtolower ( $ fileinfo ) , $ this -> arrValidFileTypes ) ) { throw new AccessDeniedException ( 'File "' . $ strFile . '" is not an allowed file type.' ) ; } } if ( ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFile ) ) { throw new AccessDeniedException ( 'File or folder "' . $ strFile . '" is not within the files directory.' ) ; } if ( $ strFolder && ! preg_match ( '/^' . preg_quote ( Config :: get ( 'uploadPath' ) , '/' ) . '/i' , $ strFolder ) ) { throw new AccessDeniedException ( 'Parent folder "' . $ strFolder . '" is not within the files directory.' ) ; } if ( Input :: get ( 'act' ) == 'edit' || Input :: get ( 'act' ) == 'paste' || Input :: get ( 'act' ) == 'delete' ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> isAdmin && \ in_array ( $ strFile , $ this -> User -> filemounts ) ) { throw new AccessDeniedException ( 'Attempt to edit, copy, move or delete the root folder "' . $ strFile . '".' ) ; } } return true ; }
6782	public function setFormParameters ( $ optionNames ) { foreach ( ( array ) $ optionNames as $ option ) { $ this -> formParameters [ $ option ] = true ; } return $ this ; }
1839	protected static function find ( array $ arrOptions ) { if ( static :: $ strTable == '' ) { return null ; } if ( $ arrOptions [ 'return' ] == 'Model' ) { $ arrColumn = ( array ) $ arrOptions [ 'column' ] ; if ( \ count ( $ arrColumn ) == 1 ) { $ arrColumn [ 0 ] = preg_replace ( '/^' . preg_quote ( static :: getTable ( ) , '/' ) . '\./' , '' , $ arrColumn [ 0 ] ) ; if ( $ arrColumn [ 0 ] == static :: $ strPk || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) { $ varKey = \ is_array ( $ arrOptions [ 'value' ] ) ? $ arrOptions [ 'value' ] [ 0 ] : $ arrOptions [ 'value' ] ; $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varKey , $ arrColumn [ 0 ] ) ; if ( $ objModel !== null ) { return $ objModel ; } } } } $ arrOptions [ 'table' ] = static :: $ strTable ; $ strQuery = static :: buildFindQuery ( $ arrOptions ) ; $ objStatement = Database :: getInstance ( ) -> prepare ( $ strQuery ) ; if ( ! isset ( $ arrOptions [ 'limit' ] ) ) { $ arrOptions [ 'limit' ] = 0 ; } if ( ! isset ( $ arrOptions [ 'offset' ] ) ) { $ arrOptions [ 'offset' ] = 0 ; } if ( $ arrOptions [ 'limit' ] > 0 || $ arrOptions [ 'offset' ] > 0 ) { $ objStatement -> limit ( $ arrOptions [ 'limit' ] , $ arrOptions [ 'offset' ] ) ; } $ objStatement = static :: preFind ( $ objStatement ) ; $ objResult = $ objStatement -> execute ( $ arrOptions [ 'value' ] ) ; if ( $ objResult -> numRows < 1 ) { return $ arrOptions [ 'return' ] == 'Array' ? array ( ) : null ; } $ objResult = static :: postFind ( $ objResult ) ; if ( $ arrOptions [ 'return' ] == 'Model' ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ objResult -> { static :: $ strPk } ) ; if ( $ objModel !== null ) { return $ objModel -> mergeRow ( $ objResult -> row ( ) ) ; } return static :: createModelFromDbResult ( $ objResult ) ; } elseif ( $ arrOptions [ 'return' ] == 'Array' ) { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) -> getModels ( ) ; } else { return static :: createCollectionFromDbResult ( $ objResult , static :: $ strTable ) ; } }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
12070	public function createProject ( $ composerJson ) { $ response = $ this -> getResponse ( 'post' , 'v2/projects' , array ( ) , array ( 'upload' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( new Project ( ) , $ response ) ; }
9004	protected function months_dropdown ( $ post_type ) { global $ wpdb , $ wp_locale ; $ tn = $ this -> table -> get_table_name ( $ wpdb ) ; $ months = $ wpdb -> get_results ( " SELECT DISTINCT YEAR( time ) AS year, MONTH( time ) AS month FROM $tn ORDER BY time DESC " ) ; $ month_count = count ( $ months ) ; if ( ! $ month_count || ( 1 == $ month_count && 0 == $ months [ 0 ] -> month ) ) { return ; } $ m = isset ( $ _GET [ 'm' ] ) ? ( int ) $ _GET [ 'm' ] : 0 ; ?> <label for="filter-by-date" class="screen-reader-text"> <?php _e ( 'Filter by date' ) ; ?> </label> <select name="m" id="filter-by-date"> <option <?php selected ( $ m , 0 ) ; ?> value="0"> <?php _e ( 'All dates' ) ; ?> </option> <?php foreach ( $ months as $ arc_row ) { if ( 0 == $ arc_row -> year ) { continue ; } $ month = zeroise ( $ arc_row -> month , 2 ) ; $ year = $ arc_row -> year ; printf ( "<option %s value='%s'>%s</option>\n" , selected ( $ m , $ year . $ month , false ) , esc_attr ( $ arc_row -> year . $ month ) , sprintf ( __ ( '%1$s %2$d' ) , $ wp_locale -> get_month ( $ month ) , $ year ) ) ; } ?> </select> <?php }
11281	public function getFloat ( $ min , $ max ) { if ( $ min > $ max ) { throw new InvalidArgumentException ( 'Min cannot be greater than max' ) ; } $ random01 = \ mt_rand ( ) / \ mt_getrandmax ( ) ; return ( $ max - $ min ) * $ random01 + $ min ; }
10015	public function setActiveSheetIndexByName ( $ pValue ) { if ( ( $ worksheet = $ this -> getSheetByName ( $ pValue ) ) instanceof Worksheet ) { $ this -> setActiveSheetIndex ( $ this -> getIndex ( $ worksheet ) ) ; return $ worksheet ; } throw new Exception ( 'Workbook does not contain sheet:' . $ pValue ) ; }
3841	private function parsePanelFilter ( PanelRowInterface $ row ) { foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'filter' ] ) ) { $ element = new DefaultFilterElementInformation ( ) ; $ element -> setPropertyName ( $ value [ 'col_name' ] ) ; if ( ! $ row -> hasElement ( $ element -> getName ( ) ) ) { $ row -> addElement ( $ element ) ; } } } }
9335	public function rad ( ) { if ( $ this -> original -> type == self :: TYPE_RAD ) { return $ this -> original -> value ; } return $ this -> float_rad ; }
7457	public function persist ( ObjectManager $ manager ) { foreach ( $ this -> entities as $ entity ) { $ manager -> persist ( $ entity ) ; } if ( $ this -> root ) { $ manager -> persist ( $ this -> root ) ; } }
12193	public function onKernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof AuthenticationCredentialsNotFoundException ) { return new RedirectResponse ( "/login" ) ; } $ message = $ exception -> getMessage ( ) ; if ( $ exception instanceof NotFoundHttpException || $ exception instanceof PageNotPublishedException ) { $ this -> render404page ( $ event , $ message ) ; return ; } if ( ! $ exception instanceof RedKiteCmsExceptionInterface ) { DataLogger :: log ( $ message , DataLogger :: CRITICAL ) ; if ( $ this -> debug ) { return $ event ; } $ this -> setUpResponse ( $ event , $ message ) ; return ; } $ message = Utils :: translateException ( $ message , $ exception ) ; $ this -> setUpResponse ( $ event , $ message ) ; DataLogger :: log ( $ message , DataLogger :: ERROR ) ; }
10771	public function registerMediaType ( $ mediaType ) { if ( $ this -> check ( $ mediaType ) ) { $ this -> mediaTypes [ ( new \ ReflectionClass ( $ mediaType ) ) -> getConstant ( 'NAME' ) ] = $ mediaType ; return $ this ; } else { throw new \ Exception ( 'registered MediaType must implement \MandarinMedien\MMMediaBundle\Model\MediaTypeInterface' ) ; } }
7153	public function add_rule ( $ access , $ role , $ action ) : void { $ roles = ( array ) $ role ; foreach ( $ roles as $ r ) { $ action = ( array ) $ action ; foreach ( $ action as $ a ) { $ this -> _rules [ $ r ] [ $ a ] = $ access ; } } }
451	protected function prepareInsertSelectSubQuery ( $ columns , $ schema , $ params = [ ] ) { if ( ! is_array ( $ columns -> select ) || empty ( $ columns -> select ) || in_array ( '*' , $ columns -> select ) ) { throw new InvalidArgumentException ( 'Expected select query object with enumerated (named) parameters' ) ; } list ( $ values , $ params ) = $ this -> build ( $ columns , $ params ) ; $ names = [ ] ; $ values = ' ' . $ values ; foreach ( $ columns -> select as $ title => $ field ) { if ( is_string ( $ title ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ title ) ; } elseif ( preg_match ( '/^(.*?)(?i:\s+as\s+|\s+)([\w\-_\.]+)$/' , $ field , $ matches ) ) { $ names [ ] = $ schema -> quoteColumnName ( $ matches [ 2 ] ) ; } else { $ names [ ] = $ schema -> quoteColumnName ( $ field ) ; } } return [ $ names , $ values , $ params ] ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
10885	protected function makeRequest ( $ data ) { $ url = 'https://www.errorstream.com/api/1.0/errors/create?' . http_build_query ( [ 'api_token' => $ this -> api_token , 'project_token' => $ this -> project_token ] ) ; try { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , json_encode ( $ data ) ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type:application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ; } catch ( \ Exception $ ex ) { return $ ex -> getMessage ( ) ; } }
10966	public static function getScheme ( ) { $ protocol = isset ( $ _SERVER [ 'REQUEST_SCHEME' ] ) ? strtolower ( $ _SERVER [ 'REQUEST_SCHEME' ] ) : 'http' ; if ( $ protocol == 'http' && self :: isSsl ( ) ) { $ protocol .= 's' ; } return $ protocol ; }
2450	public function invalidateSourceCacheTag ( Contao \ DataContainer $ dc , array $ tags ) { $ commentModel = Contao \ CommentsModel :: findByPk ( $ dc -> id ) ; if ( null !== $ commentModel ) { $ tags [ ] = sprintf ( 'contao.comments.%s.%s' , $ commentModel -> source , $ commentModel -> parent ) ; } return $ tags ; }
1671	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ this -> Files -> rcopy ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return true ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
5752	public function getObjects ( array $ whereColumnsInfo = null ) : array { $ roles = [ ] ; if ( null !== $ records = $ this -> select ( "*" , $ whereColumnsInfo ) ) { foreach ( $ records as $ record ) { $ roles [ ] = $ this -> buildRole ( ( int ) $ record [ 'id' ] , $ record [ 'role' ] , new \ DateTimeImmutable ( $ record [ 'created' ] ) ) ; } } return $ roles ; }
10319	function getBlocksCount ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null ) ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks/count' , $ params ) ; }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
536	protected function cleanDocComment ( $ doc ) { $ lines = explode ( "\n" , $ doc ) ; $ n = \ count ( $ lines ) ; for ( $ i = 0 ; $ i < $ n ; $ i ++ ) { $ lines [ $ i ] = rtrim ( $ lines [ $ i ] ) ; if ( trim ( $ lines [ $ i ] ) == '*' && trim ( $ lines [ $ i + 1 ] ) == '*' ) { unset ( $ lines [ $ i ] ) ; } } return implode ( "\n" , $ lines ) ; }
5864	public function getDirectoryPattern ( $ directory ) { $ pattern = '/^' . str_replace ( '/' , '\\/' , $ directory ) . '/' ; $ pattern = str_replace ( '\\/**\\/' , '\\/([^\/]+\\/)*' , $ pattern ) ; $ pattern = str_replace ( '\\/*\\/' , '\\/[^\/]+\\/' , $ pattern ) ; return $ pattern ; }
4787	function offsetSet ( $ key , $ value ) { $ this -> row [ $ key ] = $ value ; $ this -> modified [ $ key ] = $ value ; }
4042	public function getReadableValue ( RenderReadablePropertyValueEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ model = $ event -> getModel ( ) ; if ( ! ( $ model instanceof Model ) ) { return ; } $ nativeItem = $ model -> getItem ( ) ; $ metaModel = $ nativeItem -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; if ( ! $ renderSetting ) { return ; } $ result = $ nativeItem -> parseAttribute ( $ event -> getProperty ( ) -> getName ( ) , 'text' , $ renderSetting ) ; if ( ! isset ( $ result [ 'text' ] ) ) { $ event -> setRendered ( sprintf ( 'Unexpected behaviour, attribute %s text representation was not rendered.' , $ event -> getProperty ( ) -> getName ( ) ) ) ; return ; } $ event -> setRendered ( $ result [ 'text' ] ) ; }
6300	public function render ( $ mainName = 'default' , $ barName = false , array $ data = null ) { if ( $ data === null ) { $ data = [ 'title' => 'Navigation' , 'side' => 'dropdown' , 'inverse' => true ] ; } $ main = $ this -> getMain ( $ mainName ) ; if ( is_string ( $ barName ) ) { $ bar = $ this -> getBar ( $ barName ) ; if ( empty ( $ bar ) ) { $ bar = false ; } } else { $ bar = false ; } return $ this -> view -> make ( $ this -> name , array_merge ( $ data , [ 'main' => $ main , 'bar' => $ bar ] ) ) -> render ( ) ; }
6002	public function setVideotemplates ( array $ videotemplates ) { $ this -> videotemplates = [ ] ; foreach ( $ videotemplates as $ item ) { $ this -> addVideoTemplate ( $ item ) ; } return $ this ; }
2665	public function createDictionary ( $ version , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ params ) ; return $ result ; }
12798	public function getLines ( $ lazy = true , $ raw = false ) { if ( is_null ( $ this -> _lines ) ) { $ file = $ this -> filePointer ; if ( ! $ file ) { return false ; } rewind ( $ file ) ; $ this -> _lines = [ ] ; $ currentLineNumber = 0 ; while ( ( $ buffer = fgetcsv ( $ this -> filePointer , 0 , $ this -> delimeter ) ) !== false ) { $ currentLineNumber ++ ; if ( $ currentLineNumber <= $ this -> skipLines ) { continue ; } $ line = Yii :: createObject ( [ 'class' => SourceFileLine :: className ( ) , 'sourceFile' => $ this , 'lineNumber' => $ currentLineNumber - 1 , 'content' => $ buffer ] ) ; if ( $ this -> testIgnore ( $ line ) ) { continue ; } $ lineId = $ line -> id ; if ( ! isset ( $ lineId ) ) { continue ; } $ this -> _lines [ $ lineId ] = $ line ; if ( $ lazy ) { $ line -> clean ( ) ; } } } return $ this -> _lines ; }
1597	protected function validateRelationships ( ) : bool { if ( ! $ this -> dataHas ( 'relationships' ) ) { return true ; } $ relationships = $ this -> dataGet ( 'relationships' ) ; if ( ! is_object ( $ relationships ) ) { $ this -> memberNotObject ( '/data' , 'relationships' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ relationships ) { return property_exists ( $ relationships , $ field ) ; } ) ; $ valid = $ disallowed -> isEmpty ( ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'relationships' , $ disallowed ) ; foreach ( $ relationships as $ field => $ relation ) { if ( ! $ this -> validateRelationship ( $ relation , $ field ) ) { $ valid = false ; } } return $ valid ; }
2483	protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
5584	public function click ( $ label ) { $ raw = $ this -> clickSubmit ( $ label ) ; if ( ! $ raw ) { $ raw = $ this -> clickLink ( $ label ) ; } if ( ! $ raw ) { $ raw = $ this -> clickImage ( $ label ) ; } return $ raw ; }
3611	public function getNextScheduledEvent ( $ serial_number = NULL ) { $ schedule = $ this -> getDeviceSchedule ( $ serial_number ) ; $ next_event = FALSE ; $ time = date ( 'H' ) * 60 + date ( 'i' ) ; for ( $ i = 0 , $ day = date ( 'D' ) ; $ i ++ < 7 ; $ day = date ( 'D' , strtotime ( "+ $i days" ) ) ) { if ( isset ( $ schedule [ $ day ] ) ) { foreach ( $ schedule [ $ day ] as $ event ) { if ( $ event -> time > $ time ) { return $ event ; } } } $ time = 0 ; } return $ next_event ; }
10996	public function prepend ( string $ contents , int $ maxMemory = 8096 ) : bool { $ test = \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ; if ( $ this -> test ( $ test ) === false ) { $ this -> error = "failed to prepend file; {$this->error}" ; return false ; } $ len = strlen ( $ contents ) ; $ size = filesize ( $ this -> path ) ; $ endsize = $ len + $ size ; if ( $ endsize > $ maxMemory ) { return $ this -> prependFileInPlace ( $ contents , $ len , $ endsize ) ; } if ( ( $ tmp = $ this -> readFile ( 0 ) ) === false ) { return false ; } if ( $ this -> writeFile ( $ contents . $ tmp , 0 ) === false ) { return false ; } return true ; }
3459	public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; }
1054	private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
6253	protected function normalizeAclPresence ( $ data ) { if ( $ data instanceof AclPresenceInterface ) { $ data = [ $ data ] ; } elseif ( is_array ( $ data ) && ! Arr :: isAssoc ( $ data ) ) { $ presences = [ ] ; foreach ( $ data as $ nestedData ) { if ( is_string ( $ nestedData ) ) { $ presences [ ] = $ nestedData ; } else { $ presences [ ] = new AclPresence ( $ nestedData ) ; } } $ data = $ presences ; } else { $ data = [ new AclPresence ( $ data ) ] ; } return $ data ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
6912	public function addInvoice ( InvoiceInterface $ invoice ) { if ( ! $ this -> invoices -> contains ( $ invoice ) ) { $ this -> invoices -> add ( $ invoice ) ; } return $ this ; }
10913	public function setVariable ( string $ name , $ value , bool $ as_instance = true ) { $ this -> variables [ $ name ] = $ value ; if ( is_object ( $ value ) ) $ this -> instances [ get_class ( $ value ) ] = $ value ; return $ this ; }
2727	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> determineVersions ( $ service -> versions ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> request -> getParam ( 'acls' ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetName = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; $ snippetId = $ this -> api -> getSnippet ( $ currActiveVersion [ 'active_version' ] , $ snippetName ) -> id ; $ params = [ 'name' => $ snippetId , 'content' => $ value ] ; $ this -> api -> updateSnippet ( $ params ) ; } $ this -> cacheTypeList -> cleanType ( 'config' ) ; $ this -> systemConfig -> clean ( ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4075	protected function setTableMapping ( $ modelId , $ tableName ) { $ this -> information [ $ tableName ] [ self :: MODELID ] = $ modelId ; $ this -> tableMap [ $ modelId ] = $ tableName ; }
1325	public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } if ( $ json ) { $ parameters = $ defaults ; } else { $ parameters = array_merge ( $ defaults , $ parameters ) ; } return new Request ( $ httpMethod , $ httpUrl , $ parameters ) ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
4968	public function fromQuery ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getQuery ( $ param , $ default ) ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
8812	public function view ( $ view , array $ data = [ ] ) { if ( function_exists ( 'app' ) ) { $ this -> setContent ( app ( 'load' ) -> view ( $ view , $ data ) ) ; return $ this ; } return ; }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
3904	public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ( 'dca_id' !== $ event -> getSubPropertyName ( ) ) ) { return ; } $ screens = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ event -> getModel ( ) -> getProperty ( 'id' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ screens as $ screen ) { $ result [ $ screen [ 'id' ] ] = $ screen [ 'name' ] ; } $ event -> setOptions ( $ result ) ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
4643	public function start ( Job $ build ) { foreach ( $ build -> getServices ( ) as $ service ) { try { $ this -> docker -> getImageManager ( ) -> find ( sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { $ buildStream = $ this -> docker -> getImageManager ( ) -> create ( null , [ 'fromImage' => sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; } else { throw $ e ; } } $ serviceConfig = $ service -> getConfig ( ) ; $ containerConfig = new ContainerConfig ( ) ; $ containerConfig -> setImage ( sprintf ( '%s:%s' , $ service -> getRepository ( ) , $ service -> getTag ( ) ) ) ; $ containerConfig -> setLabels ( [ 'com.jolici.container=true' ] ) ; if ( isset ( $ serviceConfig [ 'Env' ] ) ) { $ containerConfig -> setEnv ( $ serviceConfig [ 'Env' ] ) ; } $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ containerConfig ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ service -> setContainer ( $ containerCreateResult -> getId ( ) ) ; } }
5356	public function parseSchema ( $ openApiSpec ) { $ openApiSpecContents = file_get_contents ( $ openApiSpec ) ; $ schemaClass = self :: OPEN_API_MODEL ; $ schema = null ; $ jsonException = null ; $ yamlException = null ; try { return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; } catch ( \ Exception $ exception ) { $ jsonException = $ exception ; } $ content = Yaml :: parse ( $ openApiSpecContents , Yaml :: PARSE_OBJECT | Yaml :: PARSE_OBJECT_FOR_MAP | Yaml :: PARSE_DATETIME | Yaml :: PARSE_EXCEPTION_ON_INVALID_TYPE ) ; $ openApiSpecContents = json_encode ( $ content ) ; return $ this -> serializer -> deserialize ( $ openApiSpecContents , $ schemaClass , self :: CONTENT_TYPE_JSON , [ 'document-origin' => $ openApiSpec ] ) ; }
9409	protected function transform ( $ middleware , $ wrappable = true ) { if ( is_a ( $ middleware , Application :: MIDDLEWARE ) === false ) { $ approach = ( boolean ) $ this -> approach ( $ middleware ) ; $ response = $ approach === self :: SINGLE_PASS ? $ this -> response : null ; $ wrapper = new CallableMiddlewareWrapper ( $ middleware , $ response ) ; $ middleware = $ wrappable === true ? $ wrapper : $ middleware ; } return $ middleware ; }
351	public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
6381	public function readQuestionAttempts ( $ id ) { $ questionAttempts = $ this -> readStoreRecords ( 'question_attempts' , [ 'questionusageid' => $ id ] ) ; foreach ( $ questionAttempts as $ questionIndex => $ questionAttempt ) { $ questionAttemptSteps = $ this -> readStoreRecords ( 'question_attempt_steps' , [ 'questionattemptid' => $ questionAttempt -> id ] ) ; foreach ( $ questionAttemptSteps as $ stepIndex => $ questionAttemptStep ) { $ questionAttemptStep -> data = $ this -> readStoreRecords ( 'question_attempt_step_data' , [ 'attemptstepid' => $ questionAttemptStep -> id ] ) ; } $ questionAttempt -> steps = $ questionAttemptSteps ; } return $ questionAttempts ; }
3612	public function setTargetTemperatureMode ( $ mode , $ temperature = NULL , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; if ( $ temperature !== NULL ) { if ( $ mode == TARGET_TEMP_MODE_RANGE ) { if ( ! is_array ( $ temperature ) || count ( $ temperature ) != 2 || ! is_numeric ( $ temperature [ 0 ] ) || ! is_numeric ( $ temperature [ 1 ] ) ) { echo "Error: when using TARGET_TEMP_MODE_RANGE, you need to set the target temperatures (second argument of setTargetTemperatureMode) using an array of two numeric values.\n" ; return FALSE ; } $ temp_low = $ this -> temperatureInCelsius ( $ temperature [ 0 ] , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temperature [ 1 ] , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } elseif ( $ mode != TARGET_TEMP_MODE_OFF ) { if ( ! is_numeric ( $ temperature ) ) { echo "Error: when using TARGET_TEMP_MODE_HEAT or TARGET_TEMP_MODE_COLD, you need to set the target temperature (second argument of setTargetTemperatureMode) using an numeric value.\n" ; return FALSE ; } $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; $ set_temp_result = $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; } } $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_type' => $ mode ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
3578	protected function metaSelect ( Builder $ query , ArgumentBag $ args ) { $ columns = $ args -> get ( 'columns' ) ; foreach ( $ columns as $ key => $ column ) { list ( $ column , $ alias ) = $ this -> extractColumnAlias ( $ column ) ; if ( $ this -> hasColumn ( $ column ) ) { $ select = "{$this->getTable()}.{$column}" ; if ( $ column !== $ alias ) { $ select .= " as {$alias}" ; } $ columns [ $ key ] = $ select ; } elseif ( is_string ( $ column ) && $ column != '*' && strpos ( $ column , '.' ) === false ) { $ table = $ this -> joinMeta ( $ query , $ column ) ; $ columns [ $ key ] = "{$table}.meta_value as {$alias}" ; } } $ args -> set ( 'columns' , $ columns ) ; }
2372	public static function toXhtml ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*)>/i' => '<$1$2 />' , '/ border="[^"]*"/' => '' ) ; $ arrStrReplace = array ( '/ />' => ' />' , '<b>' => '<strong>' , '</b>' => '</strong>' , '<i>' => '<em>' , '</i>' => '</em>' , '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' target="_blank"' => ' onclick="return !window.open(this.href)"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
7346	static public function calculateReceivedQuantity ( SupplierOrderItemInterface $ item ) { $ quantity = 0 ; foreach ( $ item -> getOrder ( ) -> getDeliveries ( ) as $ delivery ) { foreach ( $ delivery -> getItems ( ) as $ deliveryItem ) { if ( $ item === $ deliveryItem -> getOrderItem ( ) ) { $ quantity += $ deliveryItem -> getQuantity ( ) ; continue 2 ; } } } return $ quantity ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
12142	public static function provider ( ProviderInterface $ provider = null ) { if ( $ provider ) { static :: $ provider = $ provider ; } elseif ( ! static :: $ provider ) { static :: $ provider = new Provider \ Native ( static :: $ root ) ; } return static :: $ provider ; }
8793	protected function setKeyInEnvironmentFile ( $ key , $ input , $ output ) { $ currentKey = config ( 'app.key' ) ; $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( 'Application key will re-generate. Are you sure?: ' , false ) ; if ( strlen ( $ currentKey ) !== 0 && ( ! $ helper -> ask ( $ input , $ output , $ question ) ) ) { return false ; } $ this -> writeNewEnvironmentFileWith ( $ key ) ; return true ; }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
6247	public function dirs ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ directory ) { if ( $ directory -> isDir ( ) ) { yield $ directory ; } } }
6808	public function number ( float $ number ) : string { return $ this -> getNumberFormatter ( ) -> format ( $ number , NumberFormatter :: TYPE_DEFAULT ) ; }
9503	public function joinCommand ( array $ parts ) { $ command = 'php ' . implode ( ' ' , $ parts ) ; $ stripped = str_replace ( '--watch' , '' , $ command ) ; return trim ( $ stripped ) ; }
7162	private function buildSaleTaxesViews ( Model \ SaleInterface $ sale ) { if ( ! $ this -> options [ 'taxes_view' ] ) { return ; } $ amounts = $ this -> amountCalculator -> calculateSale ( $ sale ) ; foreach ( $ amounts -> getTaxAdjustments ( ) as $ tax ) { $ this -> view -> addTax ( new TaxView ( $ tax -> getName ( ) , $ this -> formatter -> currency ( $ tax -> getAmount ( ) ) ) ) ; } }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
8940	public function downloadChangeset ( $ id ) { $ base = 'changeset/' . $ id . '/download' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> create ; }
6497	public function iSwitchToWindow ( ) { $ windows = $ this -> getWindowNames ( ) ; if ( empty ( $ this -> mainWindow ) ) { $ this -> mainWindow [ 'name' ] = array_shift ( $ windows ) ; $ this -> mainWindow [ 'element' ] = $ this -> getWorkingElement ( ) ; $ window = reset ( $ windows ) ; } else { $ window = $ this -> mainWindow [ 'name' ] ; $ element = $ this -> mainWindow [ 'element' ] ; $ this -> mainWindow = [ ] ; } $ this -> getSession ( ) -> switchToWindow ( $ window ) ; $ this -> setWorkingElement ( isset ( $ element ) ? $ element : $ this -> getBodyElement ( ) ) ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
8788	public function style ( $ url , $ attributes = [ ] , $ secure = null ) { $ defaults = [ 'media' => 'all' , 'type' => 'text/css' , 'rel' => 'stylesheet' ] ; $ attributes = array_merge ( $ attributes , $ defaults ) ; $ attributes [ 'href' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<link' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
9743	public function setCountry ( $ country ) { if ( ! ( $ country instanceof Country ) ) { $ country = new Country ( $ country ) ; } if ( $ country -> isEmpty ( ) ) { $ this -> invalidArguments ( '10001' ) ; } return $ this -> setParameter ( 'country' , $ country ) ; }
1944	public function section ( $ key , $ template = null ) { if ( empty ( $ this -> sections [ $ key ] ) ) { return ; } $ this -> id = $ key ; $ this -> content = $ this -> sections [ $ key ] ; if ( $ template === null ) { $ template = 'block_section' ; foreach ( $ this -> positions as $ position ) { if ( isset ( $ position [ $ key ] [ 'template' ] ) ) { $ template = $ position [ $ key ] [ 'template' ] ; } } } include $ this -> getTemplate ( $ template ) ; }
8588	public function setASINPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASINPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
4806	protected function processMemberVar ( File $ phpcsFile , $ stackPtr ) { $ tokens = $ phpcsFile -> getTokens ( ) ; $ commentToken = [ T_COMMENT , T_DOC_COMMENT_CLOSE_TAG , ] ; $ commentEnd = $ phpcsFile -> findPrevious ( $ commentToken , $ stackPtr ) ; $ commentStart = $ tokens [ $ commentEnd ] [ 'comment_opener' ] ; if ( $ tokens [ $ commentEnd ] [ 'line' ] === $ tokens [ $ commentStart ] [ 'line' ] ) { $ phpcsFile -> addError ( 'Member variable comment should not be inline' , $ stackPtr , static :: ERROR_CODE ) ; } }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
8156	public function addPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ this -> paths [ $ namespace ] [ ] = rtrim ( $ path , '/\\' ) ; }
5466	public function setIdentityForRealm ( $ host , $ realm , $ username , $ password ) { if ( isset ( $ this -> realms [ $ host ] [ $ realm ] ) ) { $ this -> realms [ $ host ] [ $ realm ] -> setIdentity ( $ username , $ password ) ; } }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
8149	public function compileSource ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } try { return $ this -> compile ( $ this -> parse ( $ this -> tokenize ( $ source ) ) ) ; } catch ( Twig_Error $ e ) { $ e -> setSourceContext ( $ source ) ; throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Syntax ( sprintf ( 'An exception has been thrown during the compilation of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ source , $ e ) ; } }
12882	public function getUnmappedKeys ( ) { $ u = [ ] ; $ f = $ this -> unmappedForeignKeys ; $ l = $ this -> unmappedLocalKeys ; if ( ! empty ( $ f ) ) { $ u [ 'foreign' ] = $ f ; } if ( ! empty ( $ l ) ) { $ u [ 'local' ] = $ l ; } return $ u ; }
3027	private function makeRequest ( $ method , $ path , $ options , $ addApiKey ) { if ( $ addApiKey ) { $ options = array_merge ( array ( 'api_key' => $ this -> apiKey ) , $ options ? : array ( ) ) ; } return $ this -> requestHandler -> request ( $ method , $ path , $ options ) ; }
1628	public function useDailyFiles ( $ path , $ days = 0 , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useDailyFiles ( $ path , $ days , $ level ) ; } } }
1948	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
4429	protected function getChoiceQuestion ( $ questionName , $ defaultValue = null , array $ choices = array ( ) ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; return new ChoiceQuestion ( $ questionName , $ choices , $ defaultValue ) ; }
1732	public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } $ objParent = PageModel :: findPublishedById ( $ objArticle -> pid ) ; if ( $ objParent === null ) { return '' ; } $ this -> objArticle = $ objArticle ; $ this -> objParent = $ objParent ; return parent :: generate ( ) ; }
3264	protected static function checkStatusChange ( $ order , $ prevStatusCode ) { if ( ! empty ( $ prevStatusCode ) && $ order -> statusCode != $ prevStatusCode ) \ event ( new OrderStatusChanged ( $ order -> id , $ order -> statusCode , $ prevStatusCode ) ) ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
10630	public static function memory ( ) { $ memory = new \ StdClass ( ) ; $ memory -> real = new \ StdClass ( ) ; $ memory -> swap = new \ StdClass ( ) ; if ( false !== ( $ data = @ file ( '/proc/meminfo' ) ) ) { $ data = implode ( "" , $ data ) ; preg_match_all ( "/MemTotal\s{0,}\:+\s{0,}([\d\.]+).+?MemFree\s{0,}\:+\s{0,}([\d\.]+).+?Cached\s{0,}\:+\s{0,}([\d\.]+).+?SwapTotal\s{0,}\:+\s{0,}([\d\.]+).+?SwapFree\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ meminfo ) ; preg_match_all ( "/Buffers\s{0,}\:+\s{0,}([\d\.]+)/s" , $ data , $ buffers ) ; $ memory -> total = $ meminfo [ 1 ] [ 0 ] * 1024 ; $ memory -> free = $ meminfo [ 2 ] [ 0 ] * 1024 ; $ memory -> used = $ memory -> total - $ memory -> free ; $ memory -> cached = $ meminfo [ 3 ] [ 0 ] * 1024 ; $ memory -> buffers = $ buffers [ 1 ] [ 0 ] * 1024 ; $ memory -> real -> used = $ memory -> total - $ memory -> free - $ memory -> cached - $ memory -> buffers ; $ memory -> real -> free = $ memory -> total - $ memory -> real -> used ; $ memory -> swap -> free = $ meminfo [ 5 ] [ 0 ] * 1024 ; $ memory -> swap -> used = $ meminfo [ 4 ] [ 0 ] * 1024 - $ memory -> swap -> free ; } return $ memory ; }
1909	private function stripNamespace ( string $ fqcn ) : string { if ( false !== ( $ pos = strrpos ( $ fqcn , '\\' ) ) ) { return substr ( $ fqcn , $ pos + 1 ) ; } return $ fqcn ; }
11080	public static function getDayName ( $ day ) { if ( $ day < self :: DOW_MONDAY || $ day > self :: DOW_SUNDAY ) { return '' ; } $ dayNames = [ self :: DOW_MONDAY => self :: poorManTranslate ( 'fts-shared' , 'Monday' ) , self :: DOW_TUESDAY => self :: poorManTranslate ( 'fts-shared' , 'Tuesday' ) , self :: DOW_WEDNESDAY => self :: poorManTranslate ( 'fts-shared' , 'Wednesday' ) , self :: DOW_THURSDAY => self :: poorManTranslate ( 'fts-shared' , 'Thursday' ) , self :: DOW_FRIDAY => self :: poorManTranslate ( 'fts-shared' , 'Friday' ) , self :: DOW_SATURDAY => self :: poorManTranslate ( 'fts-shared' , 'Saturday' ) , self :: DOW_SUNDAY => self :: poorManTranslate ( 'fts-shared' , 'Sunday' ) , ] ; return $ dayNames [ $ day ] ; }
6506	public function serializeReturnValue ( $ type , $ value ) { $ jobType = $ this -> registry -> get ( $ type ) ; return $ this -> serializer -> serialize ( $ value , 'json' , $ this -> getResponseSerializationContext ( $ jobType ) ) ; }
2610	public function determineVersions ( array $ versions ) { $ activeVersion = null ; $ nextVersion = null ; if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { $ activeVersion = $ version -> number ; } } $ nextVersion = ( int ) end ( $ versions ) -> number + 1 ; } return [ 'active_version' => $ activeVersion , 'next_version' => $ nextVersion ] ; }
612	public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; }
10580	protected function _createDataStore ( $ data = null ) { if ( is_null ( $ data ) ) { $ data = [ ] ; } try { return new ArrayObject ( $ data ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid type of store data' ) , null , $ e , $ data ) ; } }
11019	private function _getRoute ( ) { $ action = str_replace ( 'Action' , '' , $ this -> action -> getName ( ) ) ; $ action = explode ( '\\' , $ action ) ; $ action = strtolower ( $ action [ 0 ] ) ; $ cls = str_replace ( 'Controller' , '' , get_class ( $ this ) ) ; $ cls = strtolower ( $ cls ) ; $ path = explode ( '\\' , $ cls ) ; $ path = $ path [ count ( $ path ) - 1 ] . '/' . $ action ; if ( $ this -> action -> hasParams ( ) ) { foreach ( $ this -> action -> getParams ( ) as $ param ) { $ path .= '/' . $ param ; } } return $ path ; }
12185	public function getNiceId ( $ queryRole ) { $ roleType = $ this -> roleType ( $ queryRole ) ; if ( empty ( $ roleType ) ) { return false ; } return implode ( ':' , [ $ this -> role ( $ queryRole ) , $ roleType -> systemId ] ) ; }
2676	public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; }
10357	protected static function highlightCode ( string $ file , int $ line , int $ padding = 6 ) : array { if ( ! is_readable ( $ file ) ) { return false ; } $ handle = fopen ( $ file , 'r' ) ; $ lines = array ( ) ; $ currentLine = 0 ; while ( ! feof ( $ handle ) ) { $ currentLine ++ ; $ temp = fgets ( $ handle ) ; if ( $ currentLine > $ line + $ padding ) { break ; } if ( $ currentLine >= ( $ line - $ padding ) && $ currentLine <= ( $ line + $ padding ) ) { $ lines [ ] = array ( 'number' => str_pad ( $ currentLine , 4 , ' ' , STR_PAD_LEFT ) , 'highlighted' => ( $ currentLine === $ line ) , 'code' => ErrorHandler :: highlightString ( $ temp ) , ) ; } } fclose ( $ handle ) ; return $ lines ; }
12696	static function getAvailableExtNames ( ) { $ files = pakeFinder :: type ( 'file' ) -> name ( 'options-*.yaml' ) -> not_name ( 'options-sample.yaml' ) -> not_name ( 'options-user.yaml' ) -> maxdepth ( 0 ) -> in ( self :: getOptionsDir ( ) ) ; foreach ( $ files as $ i => $ file ) { $ files [ $ i ] = substr ( basename ( $ file ) , 8 , - 5 ) ; } return $ files ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
4868	protected function parseOptionsToDateTime ( $ options ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ scheduled = isset ( $ options [ 'scheduled' ] ) ? Utils :: createDateTime ( $ options [ 'scheduled' ] ) : clone ( $ this -> now ) ; if ( isset ( $ options [ 'delay' ] ) ) { $ delay = Utils :: createDateInterval ( $ options [ 'delay' ] ) ; $ scheduled -> add ( $ delay ) ; } return $ scheduled ; }
9856	private function addContinue ( $ data ) { $ limit = $ this -> limit ; $ record = 0x003C ; $ tmp = substr ( $ data , 0 , 2 ) . pack ( 'v' , $ limit ) . substr ( $ data , 4 , $ limit ) ; $ header = pack ( 'vv' , $ record , $ limit ) ; $ data_length = strlen ( $ data ) ; for ( $ i = $ limit + 4 ; $ i < ( $ data_length - $ limit ) ; $ i += $ limit ) { $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i , $ limit ) ; } $ header = pack ( 'vv' , $ record , strlen ( $ data ) - $ i ) ; $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i ) ; return $ tmp ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8358	public static function niceUrl ( string $ url ) { $ nice = null ; if ( ( $ pos = stripos ( $ url , '.' ) ) !== false ) { list ( $ subDomain , $ url ) = explode ( '.' , $ url ) ; $ request = Http :: getRequest ( ) ; $ nice = $ request -> getRawRequest ( ) -> getScheme ( ) . '://' ; if ( $ subDomain != null ) { $ nice .= $ subDomain . '.' ; } $ nice .= self :: extractDomain ( $ request -> getRawRequest ( ) ) ; } return $ nice . '/' . ltrim ( ( string ) preg_replace ( '/\/+/' , '/' , $ url ) , '/' ) ; }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
3387	public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; if ( $ user && is_null ( $ user -> confirmed_at ) ) { session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed_reset_password' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } $ response = $ this -> broker ( ) -> sendResetLink ( $ request -> only ( 'email' ) ) ; return $ response == Password :: RESET_LINK_SENT ? $ this -> sendResetLinkResponse ( $ response ) : $ this -> sendResetLinkFailedResponse ( $ request , $ response ) ; }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
7181	protected function generateNumber ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getNumber ( ) ) ) { $ this -> numberGenerator -> generate ( $ payment ) ; return true ; } return false ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
12448	static function run_update_ezinfo ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'ezinfo.php' ) -> maxdepth ( 0 ) ; pake_replace_regexp ( $ files , $ destdir , array ( '/^([\s]{1,25}\x27Version\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '/^([\s]{1,25}\x27License\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' ) , 1 ) ; $ files = pakeFinder :: type ( 'file' ) -> maxdepth ( 0 ) -> name ( 'extension.xml' ) ; pake_replace_regexp ( $ files , $ destdir , array ( '#^([\s]{1,8}<version>)([^<]*)(</version>\r?\n?)#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^([\s]{1,8}<license>)([^<]*)(</license>\r?\n?)#m' => '${1}' . htmlspecialchars ( $ opts [ 'version' ] [ 'license' ] ) . '$3' , '#^([\s]{1,8}<copyright>)Copyright \(C\) 1999-[\d]{4} eZ Systems AS(</copyright>\r?\n?)#m' => '${1}' . 'Copyright (C) 1999-' . strftime ( '%Y' ) . ' eZ Systems AS' . '$2' ) , 1 ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
5106	public function _set ( $ exp , $ bind = false ) { return $ this -> appendPart ( CmdUpdate :: PART_SET , $ exp , $ bind ) ; }
3600	public function createHttpResponseFromException ( \ Exception $ exception ) { $ httpResponse = HttpResponse :: create ( ) ; $ json = [ ] ; $ json [ 'jsonrpc' ] = '2.0' ; $ json [ 'error' ] = [ ] ; if ( $ exception instanceof Exceptions \ ErrorException ) { $ json [ 'error' ] [ 'code' ] = $ exception -> getCode ( ) ; $ json [ 'error' ] [ 'message' ] = $ exception -> getMessage ( ) ; if ( $ exception -> getData ( ) ) { $ json [ 'error' ] [ 'data' ] = $ exception -> getData ( ) ; } $ json [ 'id' ] = $ exception -> getId ( ) ; } else { $ json [ 'error' ] [ 'code' ] = - 32603 ; $ json [ 'error' ] [ 'message' ] = 'Internal error' ; $ json [ 'id' ] = null ; } $ httpResponse -> headers -> set ( 'Content-Type' , 'application/json' ) ; $ httpResponse -> setContent ( \ json_encode ( $ json ) ) ; $ httpResponse -> setStatusCode ( $ this -> errorCode ) ; $ this -> dispatch ( Event \ HttpResponseEvent :: EVENT , new Event \ HttpResponseEvent ( $ httpResponse ) ) ; return $ httpResponse ; }
3656	public function boot ( ) { $ environment = System :: getContainer ( ) -> get ( 'contao.framework' ) -> getAdapter ( Environment :: class ) ; $ script = explode ( '?' , $ environment -> get ( 'relativeRequest' ) , 2 ) [ 0 ] ; if ( ( 'contao/login' === $ script ) || ( 'contao/install' === $ script ) ) { return ; } $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; if ( ! $ connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_metamodel' , 'tl_metamodel_dca' , 'tl_metamodel_dca_sortgroup' , 'tl_metamodel_dcasetting' , 'tl_metamodel_dcasetting_condition' , 'tl_metamodel_attribute' , 'tl_metamodel_filter' , 'tl_metamodel_filtersetting' , 'tl_metamodel_rendersettings' , 'tl_metamodel_rendersetting' , 'tl_metamodel_dca_combine' , ] ) ) { System :: getContainer ( ) -> get ( 'logger' ) -> error ( 'MetaModels startup interrupted. Not all MetaModels tables have been created.' ) ; return ; } $ event = new MetaModelsBootEvent ( ) ; $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT , $ event ) ; $ determinator = System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) ; switch ( true ) { case $ determinator -> currentScopeIsFrontend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_FRONTEND , $ event ) ; break ; case $ determinator -> currentScopeIsBackend ( ) : $ this -> tryDispatch ( MetaModelsEvents :: SUBSYSTEM_BOOT_BACKEND , $ event ) ; break ; default : } }
8028	public function registerFreeProcess ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not register free process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761296 ) ; } $ this -> freeProcessIds [ $ pid ] = $ pid ; return $ this ; }
352	public static function getInputId ( $ model , $ attribute ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ name = mb_strtolower ( static :: getInputName ( $ model , $ attribute ) , $ charset ) ; return str_replace ( [ '[]' , '][' , '[' , ']' , ' ' , '.' ] , [ '' , '-' , '-' , '' , '-' , '-' ] , $ name ) ; }
87	private function getDefaultNormalizer ( ) { $ default = $ this -> getDefault ( ) ; $ trueRegex = $ this -> trueAnswerRegex ; $ falseRegex = $ this -> falseAnswerRegex ; return function ( $ answer ) use ( $ default , $ trueRegex , $ falseRegex ) { if ( is_bool ( $ answer ) ) { return $ answer ; } if ( empty ( $ answer ) && ! empty ( $ default ) ) { return $ default ; } if ( preg_match ( $ trueRegex , $ answer ) ) { return true ; } if ( preg_match ( $ falseRegex , $ answer ) ) { return false ; } return null ; } ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
1508	public static function fromArray ( array $ url ) : self { return new self ( isset ( $ url [ 'host' ] ) ? $ url [ 'host' ] : '' , isset ( $ url [ 'namespace' ] ) ? $ url [ 'namespace' ] : '' , isset ( $ url [ 'name' ] ) ? $ url [ 'name' ] : '' ) ; }
3990	private function getInputScreens ( ) { $ combinations = $ this -> getCombinations ( ) ; if ( null === $ combinations ) { return [ ] ; } $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; if ( $ this -> cache -> contains ( $ cacheKey = 'screens_' . implode ( ',' , $ screenIds ) ) ) { return $ this -> cache -> fetch ( $ cacheKey ) ; } $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ this -> cache -> save ( $ cacheKey , $ screens ) ; return $ screens ; }
9243	private function __setCookieAndLocale ( $ locale ) { if ( PHP_SAPI !== 'cli' ) { $ time = $ this -> __getCookieExpireTime ( ) ; I18n :: locale ( $ locale ) ; setcookie ( $ this -> __getCookieName ( ) , $ locale , $ time , '/' , $ this -> config ( 'Cookie.domain' ) ) ; } }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
11470	public function store ( ResponseRequest $ request ) { try { $ request = $ request -> all ( ) ; $ slug = $ request [ 'slug' ] ; $ attributes [ 'comment' ] = $ request [ 'comment' ] ; $ attributes [ 'question_id' ] = $ request [ 'question_id' ] ; $ attributes [ 'user_id' ] = user_id ( ) ; $ attributes [ 'user_type' ] = user_type ( ) ; $ response = $ this -> repository -> create ( $ attributes ) ; return $ this -> response -> message ( trans ( 'messages.success.created' , [ 'Module' => trans ( 'forum::response.name' ) ] ) ) -> code ( 204 ) -> status ( 'success' ) -> url ( trans_url ( '/discussion/' . $ slug ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( trans_url ( '/question/' . $ slug ) ) -> redirect ( ) ; } }
5645	public function shouldInvoke ( $ test_case_name , $ method ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> shouldInvoke ( $ test_case_name , $ method ) ) { return false ; } } return true ; }
12000	static protected function doctrineQuery ( $ tableName , $ field , $ generate ) { return \ Doctrine_Query :: create ( ) -> select ( $ field ) -> from ( $ tableName ) -> where ( "$field = ?" , $ generate ) -> execute ( array ( ) , \ Doctrine_Core :: HYDRATE_SINGLE_SCALAR ) ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
3332	public function fromContent ( $ content , $ mime_type ) { $ tmpfile = tempnam ( sys_get_temp_dir ( ) , 'ucr' ) ; $ temp = fopen ( $ tmpfile , 'w' ) ; fwrite ( $ temp , $ content ) ; fclose ( $ temp ) ; return $ this -> fromPath ( $ tmpfile , $ mime_type ) ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
8313	protected function beginPasswordReset ( ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ this -> picoAuth -> addAllowed ( "password_reset" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwbeginreset.md' ) ; if ( count ( $ this -> session -> getFlash ( '_pwresetsent' ) ) ) { $ this -> picoAuth -> addOutput ( "resetSent" , true ) ; return ; } $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "reset_email" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ email = trim ( $ post -> get ( "reset_email" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( ! $ this -> limit -> action ( "passwordReset" , true , array ( "email" => $ email ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ userData = $ this -> storage -> getUserByEmail ( $ email ) ) { $ this -> sendResetMail ( $ userData ) ; } $ this -> session -> addFlash ( "_pwresetsent" , true ) ; $ this -> session -> addFlash ( "success" , "Reset link sent via email." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
11829	public function getByTag ( $ tag ) { $ taggings = $ this -> getTaggings ( ) ; if ( array_key_exists ( $ tag , $ taggings ) ) { return $ taggings [ $ tag ] ; } return array ( ) ; }
4281	public function stream_tell ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ position = \ ftell ( $ this -> handle ) ; self :: register ( ) ; return $ position ; }
12971	public function seek ( $ position ) { if ( ! array_key_exists ( $ position , $ this -> elements ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Position %s does not exist in collection' , $ position ) ) ; } reset ( $ this -> elements ) ; while ( key ( $ this -> elements ) !== $ position ) { next ( $ this -> elements ) ; } }
5383	public function isValue ( $ compare ) { $ compare = trim ( $ compare ) ; if ( trim ( $ this -> getValue ( ) ) == $ compare ) { return true ; } return trim ( strip_tags ( $ this -> getContent ( ) ) ) == $ compare ; }
8049	public function createCalendarEvent ( array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEvent = $ this -> calendarEvent -> create ( $ eventData ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents [ $ calendarEvent -> id ] = $ calendarEvent ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
6738	public function run_ajax ( ) { $ methods = [ 'add_movie_rating' ] ; foreach ( $ methods as $ method ) { add_action ( 'wp_ajax_' . $ method , [ $ this -> rating , $ method ] ) ; add_action ( 'wp_ajax_nopriv_' . $ method , [ $ this -> rating , $ method ] ) ; } }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
8290	protected function checkLogoutSubmission ( ) { $ post = $ this -> request -> request ; if ( $ post -> has ( "logout" ) ) { if ( ! $ this -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGOUT_CSRF_ACTION ) ) { $ this -> redirectToPage ( "logout" ) ; } $ this -> logout ( ) ; } }
5052	public function getContentType ( ) { if ( ! $ this -> contentType ) { $ this -> setContentType ( $ this -> getParam ( 'contentType' ) ? : static :: TYPE_JSON ) ; } return $ this -> contentType ; }
5263	public function fields ( $ fields = false ) { if ( $ fields === false ) { $ this -> query [ 'body' ] [ '_source' ] = false ; } elseif ( ( array ) $ fields == [ '*' ] ) { unset ( $ this -> query [ 'body' ] [ '_source' ] ) ; } else { $ this -> query [ 'body' ] [ '_source' ] = $ fields ; } return $ this ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
4837	public function confirm_resource ( $ params ) { $ endpoint = '/confirm' ; $ required_params = array ( 'resource_id' , 'resource_type' ) ; foreach ( $ required_params as $ key => $ value ) { if ( ! isset ( $ params [ $ value ] ) ) { throw new GoCardless_ArgumentsException ( "$value missing" ) ; } $ data [ $ value ] = $ params [ $ value ] ; } if ( isset ( $ params [ 'state' ] ) ) { $ data [ 'state' ] = $ params [ 'state' ] ; } if ( isset ( $ params [ 'resource_uri' ] ) ) { $ data [ 'resource_uri' ] = $ params [ 'resource_uri' ] ; } $ sig_validation_data = array ( 'data' => $ data , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ params [ 'signature' ] ) ; if ( $ this -> validate_signature ( $ sig_validation_data ) == false ) { throw new GoCardless_SignatureException ( ) ; } $ confirm_params = array ( 'resource_id' => $ params [ 'resource_id' ] , 'resource_type' => $ params [ 'resource_type' ] ) ; $ confirm_params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; if ( ! isset ( $ params [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ confirm_params [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ response = $ this -> request ( 'post' , $ endpoint , $ confirm_params ) ; if ( $ response [ 'success' ] == true ) { $ endpoint = '/' . $ params [ 'resource_type' ] . 's/' . $ params [ 'resource_id' ] ; $ class_name = 'GoCardless_' . GoCardless_Utils :: camelize ( $ params [ 'resource_type' ] ) ; return new $ class_name ( $ this , $ this -> request ( 'get' , $ endpoint ) ) ; } else { throw new GoCardless_ClientException ( 'Failed to fetch the confirmed resource.' ) ; } }
12687	public function init ( $ confPath , $ useCache = true ) { $ this -> confPath = $ confPath ; if ( $ useCache ) { $ cachedConfig = new PhpConfiguration ( ) ; $ this -> cache = $ cachedConfig -> get ( ) ; unset ( $ cachedConfig ) ; } }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
11935	public function primaryKey ( ) { $ pk = $ this -> meta -> schema -> primaryKey ; if ( is_array ( $ pk ) ) { $ ppk = [ ] ; foreach ( $ pk as $ key ) { $ ppk [ ] = $ key ; } return implode ( '.' , $ ppk ) ; } return $ pk ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
10075	public static function controlCharacterOOXML2PHP ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_keys ( self :: $ controlCharacters ) , array_values ( self :: $ controlCharacters ) , $ value ) ; }
9296	private function update ( $ documents , $ repository , $ commitSize ) { if ( count ( $ documents ) > $ commitSize && $ commitSize > 1 ) { $ esResponse = [ ] ; $ i = 1 ; foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; if ( $ i ++ % ( $ commitSize - 1 ) == 0 ) { $ esResponse [ ] = $ this -> crud -> commit ( $ repository ) ; } } } else { foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; } $ esResponse = $ this -> crud -> commit ( $ repository ) ; } return json_encode ( $ esResponse ) ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
9741	public function isPrintAreaSet ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea !== null ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; return isset ( $ printAreas [ $ index - 1 ] ) ; }
2247	public static function generateMargin ( $ arrValues , $ strType = 'margin' ) { if ( ! \ is_array ( $ arrValues ) ) { $ arrValues = array ( 'top' => '' , 'right' => '' , 'bottom' => '' , 'left' => '' , 'unit' => '' ) ; } $ top = $ arrValues [ 'top' ] ; $ right = $ arrValues [ 'right' ] ; $ bottom = $ arrValues [ 'bottom' ] ; $ left = $ arrValues [ 'left' ] ; if ( $ top != '' && $ right != '' && $ bottom != '' && $ left != '' ) { if ( $ top == $ right && $ top == $ bottom && $ top == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top == $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top != $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ';' ; } else { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } } $ return = array ( ) ; $ arrDir = compact ( 'top' , 'right' , 'bottom' , 'left' ) ; foreach ( $ arrDir as $ k => $ v ) { if ( $ v != '' ) { $ return [ ] = $ strType . '-' . $ k . ':' . $ v . $ arrValues [ 'unit' ] . ';' ; } } return implode ( $ return ) ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
7692	function MsExcel_ConvertToExplicit_Item ( & $ Txt , $ Tag , $ Att , $ CellRow ) { $ tag_pc = strlen ( $ Tag ) + 1 ; $ rpl = '<' . $ Tag . ' ' . $ Att . '="' ; $ rpl_len = strlen ( $ rpl ) ; $ rpl_nbr = 0 ; $ p = 0 ; $ empty_first_pos = false ; $ empty_nbr = 0 ; $ item_num = 0 ; $ rpl_nbr = 0 ; while ( ( $ p = clsTinyButStrong :: f_Xml_FindTagStart ( $ Txt , $ Tag , true , $ p , true , true ) ) !== false ) { $ item_num ++ ; if ( $ empty_first_pos === false ) $ empty_first_pos = $ p ; $ p = $ p + $ tag_pc ; if ( substr ( $ Txt , $ p , 1 ) == '/' ) { $ empty_nbr ++ ; } else { $ ref = ( $ CellRow === false ) ? $ item_num : $ this -> Misc_CellRef ( $ item_num , $ CellRow ) ; $ x = $ rpl . $ ref . '"' ; $ len = $ p - $ empty_first_pos ; $ Txt = substr_replace ( $ Txt , $ x , $ empty_first_pos , $ len ) ; $ rpl_nbr ++ ; if ( $ CellRow === false ) { $ loc = new clsTbsXmlLoc ( $ Txt , $ Tag , $ p ) ; $ loc -> FindEndTag ( ) ; $ src = $ loc -> GetSrc ( ) ; $ nbr = $ this -> MsExcel_ConvertToExplicit_Item ( $ src , 'c' , 'r' , $ item_num ) ; if ( $ nbr > 0 ) { $ loc -> ReplaceSrc ( $ src ) ; } $ p = $ loc -> PosEnd ; } else { $ p = $ empty_first_pos + $ tag_pc ; } $ empty_nbr = 0 ; $ empty_first_pos = false ; } } return $ rpl_nbr ; }
1988	public static function getRootPageFromUrl ( ) { $ host = Environment :: get ( 'host' ) ; $ logger = System :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ accept_language = Environment :: get ( 'httpAcceptLanguage' ) ; if ( ! empty ( $ _GET [ 'language' ] ) && Config :: get ( 'addLanguageToUrl' ) ) { $ strUri = Environment :: get ( 'url' ) . '/' . Input :: get ( 'language' ) . '/' ; $ strError = 'No root page found (host "' . $ host . '", language "' . Input :: get ( 'language' ) . '")' ; } else { if ( Config :: get ( 'addLanguageToUrl' ) && Config :: get ( 'doNotRedirectEmpty' ) ) { $ accept_language = '-' ; } $ strUri = Environment :: get ( 'url' ) . '/' ; $ strError = 'No root page found (host "' . Environment :: get ( 'host' ) . '", languages "' . implode ( ', ' , Environment :: get ( 'httpAcceptLanguage' ) ) . '")' ; } try { $ objRequest = Request :: create ( $ strUri ) ; $ objRequest -> headers -> set ( 'Accept-Language' , $ accept_language ) ; $ arrParameters = System :: getContainer ( ) -> get ( 'contao.routing.nested_matcher' ) -> matchRequest ( $ objRequest ) ; $ objRootPage = $ arrParameters [ 'pageModel' ] ?? null ; if ( ! $ objRootPage instanceof PageModel ) { throw new MissingMandatoryParametersException ( 'Every Contao route must have a "pageModel" parameter' ) ; } } catch ( RoutingExceptionInterface $ exception ) { $ logger -> log ( LogLevel :: ERROR , $ strError , array ( 'contao' => new ContaoContext ( __METHOD__ , 'ERROR' ) ) ) ; throw new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } if ( Environment :: get ( 'relativeRequest' ) == '' ) { if ( Config :: get ( 'addLanguageToUrl' ) && ! Config :: get ( 'doNotRedirectEmpty' ) ) { $ arrParams = array ( '_locale' => $ objRootPage -> language ) ; $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_index' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; static :: redirect ( $ strUrl , 301 ) ; } elseif ( $ objRootPage -> type !== 'root' && ! \ in_array ( $ objRootPage -> alias , array ( 'index' , '/' ) ) ) { static :: redirect ( $ objRootPage -> getAbsoluteUrl ( ) , 302 ) ; } } if ( $ objRootPage -> type != 'root' ) { return PageModel :: findByPk ( $ objRootPage -> rootId ) ; } return $ objRootPage ; }
5346	public function requestRemoteHands ( $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ) { return $ this -> call ( self :: SERVICE , 'requestRemoteHands' , [ $ colocationName , $ contactName , $ phoneNumber , $ expectedDuration , $ instructions ] ) ; }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
10958	private function processFiles ( ) { foreach ( $ this -> currentCommand -> getFilesToMove ( ) as $ fileToMove ) { if ( $ fileToMove instanceof \ SplFileInfo ) { $ this -> processSplFileInfo ( $ fileToMove ) ; } else { $ this -> processArray ( $ fileToMove ) ; } } }
10904	public function isEmpty ( ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { throw new \ RuntimeException ( "failed to determine if a directory is empty; " . $ this -> getError ( ) ) ; } return count ( scandir ( $ this -> path ) ) === 2 ; }
8574	public function setGetMyPriceForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3844	protected static function upgradeJumpTo ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_content' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_content' , true ) ) { TableManipulation :: createColumn ( 'tl_content' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_content' , true ) ) { $ objDB -> execute ( 'UPDATE tl_content SET metamodel_jumpTo=jumpTo;' ) ; } } if ( $ objDB -> tableExists ( 'tl_module' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_module' , true ) ) { TableManipulation :: createColumn ( 'tl_module' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_module' , true ) ) { $ objDB -> execute ( 'UPDATE tl_module SET metamodel_jumpTo=jumpTo;' ) ; } } }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
4030	protected function getLabelPattern ( EnvironmentInterface $ environment , ModelInterface $ model ) { $ translator = $ environment -> getTranslator ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ combined = 'typedesc.' . $ type ; if ( ( $ resultPattern = $ translator -> translate ( $ combined , 'tl_metamodel_filtersetting' ) ) == $ combined ) { $ resultPattern = $ translator -> translate ( 'typedesc._default_' , 'tl_metamodel_filtersetting' ) ; } return $ resultPattern ; }
4446	public function tagged ( string $ tag , int $ offset = 0 , int $ limit = 25 ) : array { $ response = json_decode ( $ this -> client -> call ( 'tag' , 'get' , $ tag , $ offset , $ limit ) , true ) ; if ( empty ( $ response [ 'jobs' ] ) ) { $ response [ 'jobs' ] = [ ] ; } return $ response [ 'jobs' ] ; }
65	public function normalizePath ( $ path ) { $ parts = array ( ) ; $ path = strtr ( $ path , '\\' , '/' ) ; $ prefix = '' ; $ absolute = false ; if ( preg_match ( '{^( [0-9a-z]{2,}+: (?: // (?: [a-z]: )? )? | [a-z]: )}ix' , $ path , $ match ) ) { $ prefix = $ match [ 1 ] ; $ path = substr ( $ path , strlen ( $ prefix ) ) ; } if ( substr ( $ path , 0 , 1 ) === '/' ) { $ absolute = true ; $ path = substr ( $ path , 1 ) ; } $ up = false ; foreach ( explode ( '/' , $ path ) as $ chunk ) { if ( '..' === $ chunk && ( $ absolute || $ up ) ) { array_pop ( $ parts ) ; $ up = ! ( empty ( $ parts ) || '..' === end ( $ parts ) ) ; } elseif ( '.' !== $ chunk && '' !== $ chunk ) { $ parts [ ] = $ chunk ; $ up = '..' !== $ chunk ; } } return $ prefix . ( $ absolute ? '/' : '' ) . implode ( '/' , $ parts ) ; }
7319	public function add ( Time $ t ) { $ td = $ t -> days ; $ jda = intval ( $ td ) ; $ dfa = $ this -> dayFrac + $ td - $ jda ; if ( $ dfa < 0 ) { $ dfa += 1 ; $ jda -= 1 ; } $ jda1 = intval ( $ dfa ) ; $ dfa = fmod ( $ dfa , 1 ) ; $ this -> jd = $ this -> jd + $ jda + $ jda1 ; $ this -> dayFrac = $ dfa ; return $ this ; }
1186	protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; }
2456	public function deleteAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notDeletable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not deletable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; $ ids = $ session [ 'CURRENT' ] [ 'IDS' ] ; if ( \ is_array ( $ ids ) && \ strlen ( $ ids [ 0 ] ) ) { foreach ( $ ids as $ id ) { $ this -> intId = $ id ; $ this -> delete ( true ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
5196	public function addSearchResult ( $ index , $ type , array $ documents ) { $ result = [ 'took' => 5 , 'timed_out' => false , '_shards' => [ 'total' => 5 , 'successful' => 5 , 'failed' => 0 ] , 'hits' => [ 'total' => count ( $ documents ) , 'max_score' => 1 , 'hits' => [ ] ] ] ; foreach ( $ documents as $ document ) { $ result [ 'hits' ] [ 'hits' ] [ ] = [ '_index' => $ index , '_type' => $ type , '_id' => $ document [ 'id' ] , '_score' => 1 , '_source' => $ document ] ; } return $ this -> addResult ( 'search' , $ result ) ; }
661	public function beginTransaction ( $ isolationLevel = null ) { $ this -> open ( ) ; if ( ( $ transaction = $ this -> getTransaction ( ) ) === null ) { $ transaction = $ this -> _transaction = new Transaction ( [ 'db' => $ this ] ) ; } $ transaction -> begin ( $ isolationLevel ) ; return $ transaction ; }
5836	public function handleRequest ( Request $ request ) : Promise { $ path = removeDotPathSegments ( $ request -> getUri ( ) -> getPath ( ) ) ; return new Coroutine ( ( $ fileInfo = $ this -> fetchCachedStat ( $ path , $ request ) ) ? $ this -> respondFromFileInfo ( $ fileInfo , $ request ) : $ this -> respondWithLookup ( $ this -> root . $ path , $ path , $ request ) ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
6942	protected function scheduleSubjectStockUnitChangeEvent ( StockUnitInterface $ stockUnit ) { $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSubjectStockUnitChangeEventName ( ) , new SubjectStockUnitEvent ( $ stockUnit ) ) ; }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
1776	protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionSelected ( 1 , 1 ) ; } return static :: optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
9048	private function renderFields ( $ rendered , $ fields ) { foreach ( $ fields as $ field ) { if ( ! isset ( $ field [ 'name' ] ) ) { throw new ControlException ( "Field must have at least a name!" ) ; } $ fieldType = isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' ; $ id = isset ( $ field [ 'id' ] ) ? $ field [ 'id' ] : $ field [ 'name' ] ; $ class = isset ( $ field [ 'class' ] ) ? $ field [ 'class' ] : $ field [ 'name' ] ; $ rendered .= sprintf ( '<input type="%s" id="%s" class="%s" name="%s"/>' , $ fieldType , $ id , $ class , $ field [ 'name' ] ) ; } return $ rendered ; }
6530	public static function findAllUsingMixin ( $ mixin ) : array { if ( $ mixin instanceof Mixin ) { $ key = $ mixin -> getId ( ) -> getCurieMajor ( ) ; } else { $ key = $ mixin ; } if ( ! isset ( self :: $ resolvedMixins [ $ key ] ) ) { $ schemas = [ ] ; foreach ( ( self :: $ mixins [ $ key ] ?? [ ] ) as $ id ) { $ schemas [ ] = self :: $ classes [ $ id ] :: schema ( ) ; } self :: $ resolvedMixins [ $ key ] = $ schemas ; } if ( empty ( self :: $ resolvedMixins [ $ key ] ) ) { throw new NoMessageForMixin ( $ mixin ) ; } return self :: $ resolvedMixins [ $ key ] ; }
11393	public static function activateError ( $ iLevel ) { if ( self :: $ _bFirstActivation === true ) { self :: _setFileNameInErrorFile ( ) ; self :: $ _bFirstActivation = false ; } self :: _initLogFile ( ) ; self :: $ _bActivateError = true ; error_reporting ( $ iLevel ) ; set_error_handler ( function ( $ iErrNo , $ sErrStr , $ sErrFile , $ iErrLine ) { $ aContext = array ( 'file' => $ sErrFile , 'line' => $ iErrLine ) ; $ sType = self :: getTranslateErrorCode ( $ iErrNo ) ; self :: getInstance ( ) -> $ sType ( $ sErrStr , $ aContext ) ; return true ; } , $ iLevel ) ; register_shutdown_function ( function ( ) { if ( null !== ( $ aLastError = error_get_last ( ) ) ) { $ aContext = array ( 'file' => $ aLastError [ 'file' ] , 'line' => $ aLastError [ 'line' ] ) ; $ sType = self :: getTranslateErrorCode ( $ aLastError [ 'type' ] ) ; self :: getInstance ( ) -> $ sType ( $ aLastError [ 'message' ] , $ aContext ) ; } } ) ; }
2511	protected function makeStatusForPotentiallyNonExistent ( $ errorCatNode ) { if ( $ errorCatNode instanceof \ DOMNode ) { $ status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ status = Result :: STATUS_ERROR ; } return $ status ; }
630	public function insert ( $ table , $ columns ) { $ params = [ ] ; $ sql = $ this -> db -> getQueryBuilder ( ) -> insert ( $ table , $ columns , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
3498	private function createChainVisitor ( ) : HttpProtocolChainVisitor { $ chainVisitors = new HttpProtocolChainVisitor ( ) ; $ visitors = clone $ this -> visitors ; $ priority = 0 ; foreach ( $ visitors as $ visitor ) { $ chainVisitors -> add ( $ visitor , ++ $ priority ) ; } return $ chainVisitors ; }
1952	public static function findBySourceParentAndEmail ( $ strSource , $ intParent , $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "$t.source=? AND $t.parent=? AND $t.email=?" ) , array ( $ strSource , $ intParent , $ strEmail ) , $ arrOptions ) ; }
7119	protected function getGetMinEdaBySubjectQuery ( ) { if ( null !== $ this -> getMinEdaBySubjectQuery ) { return $ this -> getMinEdaBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> isNotNull ( $ as . '.estimatedDateOfArrival' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> gte ( $ as . '.orderedStock' , 0 ) , $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) ) -> select ( 'MIN(' . $ as . '.estimatedDateOfArrival) as eda' ) ; return $ this -> getMinEdaBySubjectQuery = $ qb -> getQuery ( ) ; }
52	public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
9474	public function readOne ( ) { if ( $ this -> pos <= $ this -> max ) { $ value = $ this -> string [ $ this -> pos ] ; $ this -> pos += 1 ; } else { $ value = null ; } return $ value ; }
12477	private function getTransformation ( ) { $ transforms = [ ] ; foreach ( $ this -> fields as $ field => $ extra ) { if ( is_int ( $ field ) ) { $ transforms [ $ extra ] = $ extra ; continue ; } $ transform = ( key_exists ( 'transform' , $ extra ) ) ? $ extra [ 'transform' ] : $ field ; if ( $ transform === false ) { continue ; } $ transforms [ $ field ] = $ transform ; } return $ transforms ; }
2254	protected function eliminateNestedPaths ( $ arrPaths ) { $ arrPaths = array_filter ( $ arrPaths ) ; if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return array ( ) ; } $ nested = array ( ) ; foreach ( $ arrPaths as $ path ) { $ nested [ ] = preg_grep ( '/^' . preg_quote ( $ path , '/' ) . '\/.+/' , $ arrPaths ) ; } if ( ! empty ( $ nested ) ) { $ nested = array_merge ( ... $ nested ) ; } return array_values ( array_diff ( $ arrPaths , $ nested ) ) ; }
12299	public function getPivotFields ( $ obj , $ prop ) { $ reflection = new \ ReflectionClass ( $ obj ) ; $ property = $ reflection -> getProperty ( $ prop ) ; $ property -> setAccessible ( true ) ; $ value = $ property -> getValue ( $ obj ) ; $ property -> setAccessible ( false ) ; return array_diff ( $ value , [ 'deleted_at' , 'created_at' , 'updated_at' ] ) ; }
9127	private function checkConnection ( $ start ) : bool { if ( ! $ this -> ready ( ) ) { if ( time ( ) - $ start > $ this -> timeout ) { $ this -> disconnect ( ) ; throw new HttpException ( "Connection timed out!" ) ; } return false ; } return true ; }
10041	function toString ( ) { return "Rule [isCustomfield=" . ( $ this -> isCustomfield ) ? "true" : "false" . ", field=" . $ this -> field . ", operator=" . $ this -> operator . ", value=" . $ this -> value . " (type = " . $ this -> type . ")" ; }
8162	public function unblock ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
774	protected function extractMessages ( $ fileName , $ translator , $ ignoreCategories = [ ] ) { $ this -> stdout ( 'Extracting messages from ' ) ; $ this -> stdout ( $ fileName , Console :: FG_CYAN ) ; $ this -> stdout ( "...\n" ) ; $ subject = file_get_contents ( $ fileName ) ; $ messages = [ ] ; $ tokens = token_get_all ( $ subject ) ; foreach ( ( array ) $ translator as $ currentTranslator ) { $ translatorTokens = token_get_all ( '<?php ' . $ currentTranslator ) ; array_shift ( $ translatorTokens ) ; $ messages = array_merge_recursive ( $ messages , $ this -> extractMessagesFromTokens ( $ tokens , $ translatorTokens , $ ignoreCategories ) ) ; } $ this -> stdout ( "\n" ) ; return $ messages ; }
1174	protected function generateJavascriptValidations ( ) { $ jsValidations = [ ] ; foreach ( $ this -> validator -> getRules ( ) as $ attribute => $ rules ) { if ( ! $ this -> jsValidationEnabled ( $ attribute ) ) { continue ; } $ newRules = $ this -> jsConvertRules ( $ attribute , $ rules , $ this -> remote ) ; $ jsValidations = array_merge ( $ jsValidations , $ newRules ) ; } return $ jsValidations ; }
4112	public function searchFullPath ( $ filename ) { $ paths = explode ( PATH_SEPARATOR , get_include_path ( ) ) ; foreach ( $ paths as $ path ) { $ fullPath = $ path . DIRECTORY_SEPARATOR . $ filename ; if ( file_exists ( $ fullPath ) ) { return $ fullPath ; } } return false ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
11629	private function createOperation ( $ trans , $ dsBegin ) { $ datePerformed = $ this -> hlpDate -> getUtcNowForDb ( ) ; $ req = new \ Praxigento \ Accounting \ Api \ Service \ Operation \ Create \ Request ( ) ; $ req -> setOperationTypeCode ( Cfg :: CODE_TYPE_OPER_PV_WRITE_OFF ) ; $ req -> setDatePerformed ( $ datePerformed ) ; $ req -> setTransactions ( $ trans ) ; $ period = substr ( $ dsBegin , 0 , 6 ) ; $ note = "PV Write Off ($period)" ; $ req -> setOperationNote ( $ note ) ; $ resp = $ this -> servOperation -> exec ( $ req ) ; $ result = $ resp -> getOperationId ( ) ; return $ result ; }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
263	public function close ( ) { if ( $ this -> getIsActive ( ) ) { $ this -> fields = $ this -> composeFields ( ) ; YII_DEBUG ? session_write_close ( ) : @ session_write_close ( ) ; } }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
6088	public function createMoodboard ( Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
9549	public function setPdo ( PDO $ pdo ) { $ this -> pdo = $ pdo ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; return $ this ; }
1818	public function setSingleSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord ) { switch ( $ dc -> activeRecord -> type ) { case 'text' : case 'hyperlink' : case 'image' : case 'accordionSingle' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; break ; case 'download' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'allowedDownload' ) ; break ; } } return $ varValue ; }
998	public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; }
625	public function handleHhvmError ( $ code , $ message , $ file , $ line , $ context , $ backtrace ) { if ( $ this -> handleError ( $ code , $ message , $ file , $ line ) ) { return true ; } if ( E_ERROR & $ code ) { $ exception = new ErrorException ( $ message , $ code , $ code , $ file , $ line ) ; $ ref = new \ ReflectionProperty ( '\Exception' , 'trace' ) ; $ ref -> setAccessible ( true ) ; $ ref -> setValue ( $ exception , $ backtrace ) ; $ this -> _hhvmException = $ exception ; } return false ; }
7086	public function setOptionLabelColumnForDefaultOptionsLoader ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) && ! ( $ columnNameOrClosure instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string, DbExpr or a Closure' ) ; } $ this -> optionLabelColumnForDefaultOptionsLoader = $ columnNameOrClosure ; return $ this ; }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
10303	public function setUseDiskCaching ( $ pValue , $ pDirectory = null ) { $ this -> useDiskCaching = $ pValue ; if ( $ pDirectory !== null ) { if ( is_dir ( $ pDirectory ) ) { $ this -> diskCachingDirectory = $ pDirectory ; } else { throw new Exception ( "Directory does not exist: $pDirectory" ) ; } } return $ this ; }
11508	public function validate ( $ token ) { $ params = [ $ token , $ this -> request -> get ( 'timestamp' ) , $ this -> request -> get ( 'nonce' ) , ] ; if ( ! $ this -> debug && $ this -> request -> get ( 'signature' ) !== $ this -> signature ( $ params ) ) { throw new FaultException ( 'Invalid request signature.' , 400 ) ; } }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
794	public function activeAttributes ( ) { $ scenario = $ this -> getScenario ( ) ; $ scenarios = $ this -> scenarios ( ) ; if ( ! isset ( $ scenarios [ $ scenario ] ) ) { return [ ] ; } $ attributes = array_keys ( array_flip ( $ scenarios [ $ scenario ] ) ) ; foreach ( $ attributes as $ i => $ attribute ) { if ( $ attribute [ 0 ] === '!' ) { $ attributes [ $ i ] = substr ( $ attribute , 1 ) ; } } return $ attributes ; }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
11199	public function processDelete ( $ name , $ container = false ) { if ( ! $ container ) { $ container = $ this ; } if ( isset ( $ container -> singleton -> $ name ) ) { unset ( $ container -> singleton -> $ name ) ; return true ; } if ( isset ( $ container -> signature -> $ name ) ) { unset ( $ container -> signature -> $ name ) ; return true ; } elseif ( $ container -> parent ) { return $ container -> processDelete ( $ name , $ container -> parent ) ; } return false ; }
12167	private function createMenuGroupTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu_group`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu_group` ( `menu_group_id` int(11) NOT NULL AUTO_INCREMENT, `menu_group_title` varchar(45) NOT NULL, `menu_group_order` int(11) NOT NULL DEFAULT '0', `menu_group_uid` varchar(45) NOT NULL, `menu_group_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_group_id`), UNIQUE KEY `menu_group_id_UNIQUE` (`menu_group_id`), UNIQUE KEY `menu_group_uid_UNIQUE` (`menu_group_uid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu_group` (`menu_group_id`, `menu_group_title`, `menu_group_order`, `menu_group_uid`, `menu_group_iscore`) VALUES (1, 'Media Menu', 1, 'mediamenu', 1), (2, 'User Menu', 2, 'usermenu', 1), (3, 'Dashboard Menu', 3, 'dashboardmenu', 1), (4, 'Messages Menu', 4, 'messagesmenu', 1), (5, 'Profile Menu', 5, 'profilemenu', 1), (6, 'People Menu', 6, 'peoplemenu', 1);" ) ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
10005	public function setRibbonXMLData ( $ target , $ xmlData ) { if ( $ target !== null && $ xmlData !== null ) { $ this -> ribbonXMLData = [ 'target' => $ target , 'data' => $ xmlData ] ; } else { $ this -> ribbonXMLData = null ; } }
6112	public function dirCreate ( $ cpw = "" , $ dirname = "/" ) { return $ this -> getParent ( ) -> channelDirCreate ( $ this -> getId ( ) , $ cpw , $ dirname ) ; }
7002	public function action ( Callable $ action = null ) { if ( $ action ) $ this -> action = $ action ; return $ this -> action ; }
585	protected function loadBundles ( $ bundles ) { $ this -> stdout ( "Collecting source bundles information...\n" ) ; $ am = $ this -> getAssetManager ( ) ; $ result = [ ] ; foreach ( $ bundles as $ name ) { $ result [ $ name ] = $ am -> getBundle ( $ name ) ; } foreach ( $ result as $ bundle ) { $ this -> loadDependency ( $ bundle , $ result ) ; } return $ result ; }
12633	public function close ( $ tradeNo ) { $ params = [ 'out_trade_no' => $ tradeNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_CLOSE ) , $ params ) ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
5532	protected function createCodeForOverridenMethods ( $ methods ) { $ code = '' ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) . " {\n" ; $ code .= " return \$this->mock->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } return $ code ; }
1668	public function purge ( ) { $ this -> Files -> rrdir ( $ this -> strFolder , true ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ this -> strFolder . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } Dbafs :: updateFolderHashes ( $ this -> strFolder ) ; } }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
8620	public function parse ( ) { $ handle = fopen ( $ this -> source_file , 'r' ) ; $ currentBlock = null ; while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( preg_match ( "/^msgid (.*?)$/us" , $ line , $ match ) ) { $ currentBlock = $ match [ 1 ] == '""' ? new HeaderBlock ( ) : new Block ( ) ; rewind ( $ handle ) ; break ; } } while ( ! feof ( $ handle ) ) { $ line = fgets ( $ handle ) ; if ( trim ( $ line ) == '' ) { if ( $ currentBlock ) { $ this -> addBlock ( $ currentBlock ) ; $ currentBlock = new Block ( ) ; } } else { $ currentBlock -> process ( $ line ) ; } } fclose ( $ handle ) ; if ( $ currentBlock && $ currentBlock -> isInitialized ( ) ) { $ this -> addBlock ( $ currentBlock ) ; } }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
4738	public function onKernelException ( GetResponseForExceptionEvent $ event ) { if ( $ this -> isIgnored ( $ event -> getException ( ) ) ) { return ; } if ( $ this -> mailer ) { $ this -> mailer -> sendException ( $ event -> getRequest ( ) , $ event -> getException ( ) ) ; } if ( $ this -> statsd ) { $ this -> statsd -> increment ( "exception" ) ; } }
805	private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( ( $ tokens [ $ i ] -> isGivenKind ( T_CLASS ) && $ tokensAnalyzer -> isAnonymousClass ( $ i ) ) || ( $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) && $ tokensAnalyzer -> isLambda ( $ i ) ) ) { $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> isGivenKind ( [ T_YIELD , T_YIELD_FROM ] ) ) { return false ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( T_RETURN ) ) { continue ; } $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( ! $ tokens [ $ i ] -> equals ( ';' ) ) { return false ; } } return true ; }
9209	protected function findKey ( Table $ Table , Entity $ entity ) { if ( ! empty ( $ entity -> { $ Table -> primaryKey ( ) } ) ) { $ key = $ entity -> { $ Table -> primaryKey ( ) } ; } else { $ key = 'unknown' ; } return $ key ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
9052	public function getMenuItemsJson ( Collection $ menuItems , $ currentOwner ) { $ this -> alreadySetIds = [ ] ; $ this -> position = 0 ; $ this -> currentOwner = $ currentOwner ; return json_encode ( $ this -> recursiveMenuItemHandling ( $ menuItems ) ) ; }
12452	static function run_update_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = $ opts [ 'build' ] [ 'dir' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'package.xml' ) -> maxdepth ( 0 ) ; if ( count ( $ files ) == 1 ) { pake_replace_regexp ( $ files , $ destdir , array ( '#^( *\074name\076)(.*)(\074/name\076\r?\n?)$#m' => '${1}' . $ opts [ 'extension' ] [ 'name' ] . '_extension' . '$3' , '#^( *\074version\076)(.*)(\074/version\076\r?\n?)$#m' => '${1}' . $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'release' ] . '$3' , '#^( *\074named-version\076)(.*)(\074/named-version\076\r?\n?)$#m' => '${1}' . $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '$3' , '#^( *\074number\076)(.*)(\074/number\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . '$3' , '#^( *\074release\076)(.*)(\074/release\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^( *\074timestamp\076)(.*)(\074/timestamp\076\r?\n?)$#m' => '${1}' . time ( ) . '$3' , '#^( *\074host\076)(.*)(\074/host\076\r?\n?)$#m' => '${1}' . gethostname ( ) . '$3' , '#^( *\074licence\076)(.*)(\074/licence\076\r?\n?)$#m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' , ) ) ; pake_replace_tokens ( $ files , $ destdir , '{' , '}' , array ( '$name' => $ opts [ 'extension' ] [ 'name' ] , '$version' => $ opts [ 'version' ] [ 'alias' ] , '$ezp_version' => $ opts [ 'ezp' ] [ 'version' ] [ 'major' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'minor' ] . '.' . $ opts [ 'ezp' ] [ 'version' ] [ 'release' ] ) ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
12822	protected function resolveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'blockname' , ) ) ; parent :: resolveOptions ( $ options ) ; $ this -> optionsResolved = true ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
4533	public function getList ( $ task , Parameters $ parameters = null ) { $ resource = str_replace ( '{id}' , $ task , static :: VARIABLE_LIST ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' ] , 'query' => ( array ) $ parameters -> toObject ( true ) ] ; $ objects = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ object -> name = $ name ; $ model = static :: toModel ( $ object ) ; $ list [ $ name ] = $ model ; } return $ list ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
9974	public function setBuiltInFormatCode ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => self :: builtInFormatCode ( $ pValue ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> builtInFormatCode = $ pValue ; $ this -> formatCode = self :: builtInFormatCode ( $ pValue ) ; } return $ this ; }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
8636	public function setShipmentFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12473	private function lookForPreMinifiedAsset ( ) { $ min_path = ( string ) Str :: s ( $ this -> file -> getRealPath ( ) ) -> replace ( '.' . $ this -> file -> getExtension ( ) , '.min.' . $ this -> file -> getExtension ( ) ) ; if ( ! file_exists ( $ min_path ) ) return false ; return file_get_contents ( $ min_path ) ; }
10305	private function recursiveReplace ( $ path ) { $ patterns = [ '/*.md' , '/*.php' , '/*.phtml' , '/*.txt' , '/*.TXT' , ] ; $ from = array_keys ( $ this -> getMapping ( ) ) ; $ to = array_values ( $ this -> getMapping ( ) ) ; foreach ( $ patterns as $ pattern ) { foreach ( glob ( $ path . $ pattern ) as $ file ) { $ original = file_get_contents ( $ file ) ; $ converted = str_replace ( $ from , $ to , $ original ) ; if ( $ original !== $ converted ) { echo $ file . " converted\n" ; file_put_contents ( $ file , $ converted ) ; } } } foreach ( glob ( $ path . '/*' , GLOB_ONLYDIR ) as $ subpath ) { if ( strpos ( $ subpath , $ path . '/' ) === 0 ) { $ this -> recursiveReplace ( $ subpath ) ; } } }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
5730	public function getButtonHTML ( ) { $ html = '<div class="btn-group" role="group">' ; $ params = array ( 'q' => ( array ) $ this -> gridFieldRequest -> getRequest ( ) -> getVar ( 'q' ) ) ; $ searchVars = ( bool ) $ params ? '?' . http_build_query ( $ params ) : '' ; $ previousRecordID = $ this -> gridFieldRequest -> getPreviousRecordID ( ) ; $ cssClass = $ previousRecordID ? "cms-panel-link" : "disabled" ; $ prevLink = $ previousRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ previousRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUSRECORD' , 'Go to the previous record' ) : "" ; $ linkText = $ previousRecordID ? _t ( 'GridFieldBetterButtons.PREVIOUS' , 'Previous' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-prev %s' href='%s' title='%s'><img src='" . BETTER_BUTTONS_DIR . "/images/prev.png' alt='previous' /> %s</a>" , $ cssClass , $ prevLink , $ linkTitle , $ linkText ) ; $ nextRecordID = $ this -> gridFieldRequest -> getNextRecordID ( ) ; $ cssClass = $ nextRecordID ? "cms-panel-link" : "disabled" ; $ nextLink = $ nextRecordID ? Controller :: join_links ( $ this -> gridFieldRequest -> gridField -> Link ( ) , "item" , $ nextRecordID . $ searchVars ) : "javascript:void(0);" ; $ linkTitle = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXTRECORD' , 'Go to the next record' ) : "" ; $ linkText = $ nextRecordID ? _t ( 'GridFieldBetterButtons.NEXT' , 'Next' ) : "" ; $ html .= sprintf ( "<a class='ss-ui-button btn btn-default gridfield-better-buttons-prevnext gridfield-better-buttons-next %s' href='%s' title='%s'>%s <img src='" . BETTER_BUTTONS_DIR . "/images/next.png' alt='next' /></a>" , $ cssClass , $ nextLink , $ linkTitle , $ linkText ) ; $ html .= '</div>' ; return $ html ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
3089	protected function alterTimeoutCallValue ( array $ options ) { $ timeoutValue = null ; if ( $ this -> isInitialCall === true ) { if ( $ this -> hasOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_INITIAL_CALL_TIMEOUT ) ; } } else { if ( $ this -> hasOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ) { $ timeoutValue = $ this -> getOption ( self :: OPTION_NEXT_ITEM_CALL_TIMEOUT ) ; } } if ( ! is_null ( $ timeoutValue ) ) { $ options [ self :: OPTION_ENGINE_CLIENT ] [ 'options' ] [ 'http_client_options' ] [ 'timeout' ] = $ timeoutValue ; } return $ options ; }
6796	protected function getValues ( $ valueIds , $ language ) { $ queryBuilder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ where = $ this -> getWhereColumn ( ) ? '(' . $ this -> getWhereColumn ( ) . ')' : null ; $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'source.*' ) -> from ( $ this -> getTagSource ( ) , 'source' ) -> where ( $ queryBuilder -> expr ( ) -> in ( 'source.' . $ this -> getIdColumn ( ) , $ valueIds ) ) -> andWhere ( $ queryBuilder -> expr ( ) -> andX ( ) -> add ( 'source.' . $ this -> getTagLangColumn ( ) . '=:lang' ) -> add ( $ where ) ) -> setParameter ( 'lang' , $ language ) -> groupBy ( 'source.' . $ this -> getIdColumn ( ) ) ; if ( $ this -> getTagSortSourceTable ( ) ) { $ statement -> addSelect ( $ this -> getTagSortSourceTable ( ) . '.*' ) ; $ statement -> join ( 's' , $ this -> getTagSortSourceTable ( ) , 'sort' , $ queryBuilder -> expr ( ) -> eq ( 'source.' . $ this -> getIdColumn ( ) , 'sort.id' ) ) ; if ( $ this -> getTagSortSourceColumn ( ) ) { $ statement -> orderBy ( $ this -> getTagSortSourceColumn ( 'sort' ) ) ; } } $ statement -> addOrderBy ( 'source.' . $ this -> getSortingColumn ( ) ) ; return $ statement -> execute ( ) ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
5274	public function groupBy ( $ columns ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } $ this -> statements [ 'groups' ] = $ this -> statements [ 'groups' ] + $ columns ; return $ this ; }
4864	public function pop ( array $ options = [ ] ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ now = $ this -> dateTimeToUTCDateTime ( $ this -> now ) ; $ envelope = $ this -> mongoCollection -> findOneAndUpdate ( [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'scheduled' => [ '$lte' => $ now ] , ] , [ '$set' => [ 'status' => self :: STATUS_RUNNING , 'executed' => $ now , ] , ] , [ 'sort' => [ 'priority' => 1 , 'scheduled' => 1 ] , 'returnDocument' => \ MongoDB \ Operation \ FindOneAndUpdate :: RETURN_DOCUMENT_AFTER ] ) ; if ( ! $ envelope ) { return null ; } return $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; }
5471	private function getProperty ( $ name , $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ property = $ reflection -> getProperty ( $ name ) ; if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { return $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { return $ this -> getPrivatePropertyNoMatterWhat ( $ name , $ object ) ; } }
4819	public function getIterator ( IteratorFilter $ itf = null ) { if ( is_null ( $ itf ) ) { return new AnyIterator ( $ this -> collection ) ; } return new AnyIterator ( $ itf -> match ( $ this -> collection ) ) ; }
4852	public function getDriver ( $ configTask , $ source ) { $ driverFactory = $ this -> getDriverCreator ( ) ; $ driver = $ driverFactory -> create ( $ configTask ) ; $ driver -> source ( $ source ) ; if ( method_exists ( $ driver , 'getLogger' ) && $ driver instanceof LoggerAwareInterface ) { $ this -> logger = $ driver -> getLogger ( ) ; } return $ driver ; }
6312	public function getTables ( $ schemaName = null ) { $ getTablesCommand = $ this -> container -> get ( 'rentgen.get_tables' ) ; if ( null !== $ schemaName ) { $ getTablesCommand -> setSchemaName ( $ schemaName ) ; } return $ getTablesCommand -> execute ( ) ; }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
2481	protected function internalFind ( array $ parameters , array $ languageSettings = array ( ) ) { $ searchTargets = $ this -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ searchTargets ) ) { $ parameters [ 'shards' ] = $ searchTargets ; } return $ this -> search ( $ parameters ) ; }
2884	public function startProfiling ( ) { $ this -> canCapture = Mage :: helper ( 'sheep_debug' ) -> canCapture ( ) ; if ( ! $ this -> canCapture ) { return ; } $ requestInfo = $ this -> getRequestInfo ( ) ; $ requestInfo -> setIsStarted ( true ) ; $ this -> registerShutdown ( ) ; $ requestInfo -> setStoreId ( $ this -> getCurrentStore ( ) -> getId ( ) ) ; $ requestInfo -> setDate ( date ( 'Y-m-d H:i:s' ) ) ; $ requestInfo -> initController ( ) ; $ requestInfo -> initLogging ( ) ; if ( Mage :: helper ( 'sheep_debug' ) -> canEnableVarienProfiler ( ) ) { Varien_Profiler :: enable ( ) ; } $ stackTraceProfiler = Mage :: getModel ( 'sheep_debug/db_profiler' ) ; $ stackTraceProfiler -> setCaptureStacktraces ( Mage :: helper ( 'sheep_debug' ) -> canEnableSqlStacktrace ( ) ) ; $ stackTraceProfiler -> replaceProfiler ( ) ; }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
1804	protected function invalidateCacheTags ( self $ dc ) { if ( ! System :: getContainer ( ) -> has ( 'fos_http_cache.cache_manager' ) ) { return ; } $ ns = 'contao.db.' ; $ tags = array ( $ ns . $ dc -> table , $ ns . $ dc -> table . '.' . $ dc -> id ) ; if ( $ dc -> ptable && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { $ tags [ ] = $ ns . $ dc -> ptable ; $ tags [ ] = $ ns . $ dc -> ptable . '.' . $ dc -> activeRecord -> pid ; } if ( \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] ) ) { foreach ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'oninvalidate_cache_tags_callback' ] as $ callback ) { if ( \ is_array ( $ callback ) ) { $ this -> import ( $ callback [ 0 ] ) ; $ tags = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ dc , $ tags ) ; } elseif ( \ is_callable ( $ callback ) ) { $ tags = $ callback ( $ dc , $ tags ) ; } } } $ tags = array_filter ( array_unique ( $ tags ) ) ; $ cacheManager = System :: getContainer ( ) -> get ( 'fos_http_cache.cache_manager' ) ; $ cacheManager -> invalidateTags ( $ tags ) ; }
4240	public function onConfig ( Event $ event ) { $ cfg = $ event [ 'config' ] ; if ( ! isset ( $ cfg [ 'debug' ] ) ) { return ; } $ cfg = $ cfg [ 'debug' ] ; if ( isset ( $ cfg [ 'file' ] ) ) { $ this -> debug -> addPlugin ( $ this -> debug -> output -> file ) ; } if ( isset ( $ cfg [ 'onBootstrap' ] ) ) { if ( ! $ this -> debug -> parentInstance ) { $ this -> debug -> eventManager -> subscribe ( 'debug.bootstrap' , $ cfg [ 'onBootstrap' ] ) ; } else { \ call_user_func ( $ cfg [ 'onBootstrap' ] , new Event ( $ this -> debug ) ) ; } } if ( isset ( $ cfg [ 'onLog' ] ) ) { if ( isset ( $ this -> cfg [ 'onLog' ] ) ) { $ this -> debug -> eventManager -> unsubscribe ( 'debug.log' , $ this -> cfg [ 'onLog' ] ) ; } $ this -> debug -> eventManager -> subscribe ( 'debug.log' , $ cfg [ 'onLog' ] ) ; } if ( ! static :: $ profilingEnabled ) { $ cfg = $ this -> debug -> getCfg ( 'debug/*' ) ; if ( $ cfg [ 'enableProfiling' ] && $ cfg [ 'collect' ] ) { static :: $ profilingEnabled = true ; $ pathsExclude = array ( __DIR__ , ) ; FileStreamWrapper :: register ( $ pathsExclude ) ; } } }
925	public function getExceptionErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_EXCEPTION === $ error -> getType ( ) ; } ) ; }
9722	public function write ( Spreadsheet $ spreadsheet , $ filename , array $ writers = [ 'Xlsx' , 'Xls' ] ) { $ spreadsheet -> setActiveSheetIndex ( 0 ) ; foreach ( $ writers as $ writerType ) { $ path = $ this -> getFilename ( $ filename , mb_strtolower ( $ writerType ) ) ; $ writer = IOFactory :: createWriter ( $ spreadsheet , $ writerType ) ; if ( $ writer instanceof Pdf ) { $ tempDir = $ this -> getTemporaryFolder ( ) ; $ writer -> setTempDir ( $ tempDir ) ; } $ callStartTime = microtime ( true ) ; $ writer -> save ( $ path ) ; $ this -> logWrite ( $ writer , $ path , $ callStartTime ) ; } $ this -> logEndingNotes ( ) ; }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
3758	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
281	private function confirmUnload ( $ fixtures , $ except ) { $ this -> stdout ( "Fixtures namespace is: \n" , Console :: FG_YELLOW ) ; $ this -> stdout ( "\t" . $ this -> namespace . "\n\n" , Console :: FG_GREEN ) ; if ( count ( $ this -> globalFixtures ) ) { $ this -> stdout ( "Global fixtures will be used:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ this -> globalFixtures ) ; } if ( count ( $ fixtures ) ) { $ this -> stdout ( "\nFixtures below will be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ fixtures ) ; } if ( count ( $ except ) ) { $ this -> stdout ( "\nFixtures that will NOT be unloaded:\n\n" , Console :: FG_YELLOW ) ; $ this -> outputList ( $ except ) ; } return $ this -> confirm ( "\nUnload fixtures?" ) ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
5680	public function getText ( ) { if ( ! $ this -> text ) { $ this -> text = self :: normalise ( $ this -> raw ) ; } return $ this -> text ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
6474	private function rankAcceptCharsetHeaders ( array $ charsetHeaders ) : array { usort ( $ charsetHeaders , [ $ this , 'compareAcceptCharsetHeaders' ] ) ; $ rankedCharsetHeaders = array_filter ( $ charsetHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedCharsetHeaders ) ; }
6786	public function buildHeaders ( $ options ) { $ options = $ this -> resolve ( $ options ) ; $ headerOptions = [ ] ; foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { $ headerOptions [ $ key ] = $ options [ $ key ] ; } } return $ headerOptions ; }
1494	public static function fromArray ( iterable $ config , string $ urlPrefix = null ) : self { return new self ( ... collect ( $ config ) -> map ( function ( $ value , $ key ) use ( $ urlPrefix ) { return Encoding :: fromArray ( $ key , $ value , $ urlPrefix ) ; } ) -> values ( ) ) ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
9242	private function __next ( ServerRequestInterface $ request , ResponseInterface $ response , $ next ) { $ this -> __loadConfigFiles ( ) ; return $ next ( $ request , $ response ) ; }
4143	public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
12793	public function create ( $ params = array ( ) ) { $ serverConfig = array_merge ( $ this -> defaults , $ params ) ; try { $ response = $ this -> client -> request -> post ( $ this -> apiEndpoint . "/droplets" , [ 'json' => $ serverConfig ] ) ; if ( 202 != $ this -> client -> getStatus ( $ response ) ) { throw new Exception ( 'Unable to create server.' ) ; } } catch ( Exception $ e ) { echo 'Unable to create server because ' . $ e -> getMessage ( ) ; } return $ this -> client -> getBody ( $ response ) ; }
9258	protected function dumpContainer ( ConfigCache $ cache , ContainerBuilder $ container , $ class , $ baseClass ) { $ dumper = new PhpDumper ( $ container ) ; $ content = $ dumper -> dump ( array ( 'class' => $ class , 'base_class' => $ baseClass ) ) ; $ cache -> write ( $ content , $ container -> getResources ( ) ) ; }
9860	private static function getInt4d ( $ data , $ pos ) { if ( trim ( $ data ) == '' ) { throw new ReaderException ( 'Parameter data is empty.' ) ; } elseif ( $ pos < 0 ) { throw new ReaderException ( 'Parameter pos=' . $ pos . ' is invalid.' ) ; } $ len = strlen ( $ data ) ; if ( $ len < $ pos + 4 ) { $ data .= str_repeat ( "\0" , $ pos + 4 - $ len ) ; } $ _or_24 = ord ( $ data [ $ pos + 3 ] ) ; if ( $ _or_24 >= 128 ) { $ _ord_24 = - abs ( ( 256 - $ _or_24 ) << 24 ) ; } else { $ _ord_24 = ( $ _or_24 & 127 ) << 24 ; } return ord ( $ data [ $ pos ] ) | ( ord ( $ data [ $ pos + 1 ] ) << 8 ) | ( ord ( $ data [ $ pos + 2 ] ) << 16 ) | $ _ord_24 ; }
12491	public static function where ( $ field , $ operator , $ value , $ logical ) { if ( gettype ( $ field ) == "array" ) { throw new ClusterpointException ( "\"->where()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ operator === null ) { return "{$logical} {$field} " ; } elseif ( $ value === null ) { $ value = $ operator ; $ operator = '==' ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } if ( ! ( $ value instanceof Raw ) ) { if ( is_string ( $ value ) ) { $ value = '"' . Client :: escape ( $ value ) . '"' ; } else { $ value = json_encode ( $ value ) ; } } return "{$logical} {$field}{$operator}{$value} " ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
9283	private function needsCompilation ( $ lessPath , $ cssPath ) { $ isNewer = function ( $ subject , $ reference ) { return filemtime ( $ subject ) > filemtime ( $ reference ) ; } ; if ( $ this -> forceCompile || ! file_exists ( $ lessPath ) || ! file_exists ( $ cssPath ) || $ isNewer ( $ lessPath , $ cssPath ) ) { return true ; } return $ this -> checkImports ( $ lessPath , $ cssPath , $ isNewer ) ; }
9467	protected function initializer ( string $ key , array $ storage ) : void { $ this -> _name = $ key ; $ this -> attached ( $ storage ) ; }
1632	public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; }
4002	protected function getCountFor ( $ intMetaModelId , $ intFilterId ) { $ metaModel = $ this -> loadMetaModel ( $ intMetaModelId ) ; if ( $ metaModel == null ) { return false ; } $ objFilter = $ metaModel -> getEmptyFilter ( ) ; if ( $ intFilterId ) { $ collection = $ this -> getServiceContainer ( ) -> getFilterFactory ( ) -> createCollection ( $ intFilterId ) ; $ values = [ ] ; foreach ( $ collection -> getParameters ( ) as $ key ) { $ values [ $ key ] = Input :: get ( $ key ) ; } $ collection -> addRules ( $ objFilter , $ values ) ; } return $ metaModel -> getCount ( $ objFilter ) ; }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
12657	public function deleteTextContainer ( $ name ) { foreach ( $ this -> languages as $ lang ) { $ this -> getPageTexts ( $ lang ) ; unset ( $ this -> contents [ $ lang ] [ $ name ] ) ; $ this -> writeTextsToFile ( $ lang ) ; } }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
889	private function shouldClearToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; return ! $ token -> isComment ( ) && ! ( $ token -> isWhitespace ( ) && $ tokens [ $ index + 1 ] -> isComment ( ) ) ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
7318	public function toMJD ( $ scale = null ) { $ mjd = static :: MJD ; if ( $ scale ) { return bcsub ( bcadd ( $ this -> jd , $ this -> dayFrac , $ scale ) , $ mjd , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac - $ mjd ; } }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
9664	public static function registerReader ( $ readerType , $ readerClass ) { if ( ! is_a ( $ readerClass , Reader \ IReader :: class , true ) ) { throw new Reader \ Exception ( 'Registered readers must implement ' . Reader \ IReader :: class ) ; } self :: $ readers [ $ readerType ] = $ readerClass ; }
9781	private function setFlag ( string $ name , bool $ value = true ) : self { $ this -> flags [ $ name ] = $ value ; return $ this ; }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
1707	private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; }
338	protected function extractColumnSize ( $ column , $ dbType , $ precision , $ scale , $ length ) { $ column -> size = trim ( $ length ) === '' ? null : ( int ) $ length ; $ column -> precision = trim ( $ precision ) === '' ? null : ( int ) $ precision ; $ column -> scale = trim ( $ scale ) === '' ? null : ( int ) $ scale ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
5451	public function parse ( $ response ) { $ this -> tags = array ( ) ; $ this -> page = $ this -> createPage ( $ response ) ; $ parser = $ this -> createParser ( $ this ) ; $ parser -> parse ( $ response -> getContent ( ) ) ; $ this -> acceptPageEnd ( ) ; $ page = $ this -> page ; $ this -> free ( ) ; return $ page ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
12858	public function onPageSaved ( PageSavedEvent $ event ) { $ blocks = $ event -> getApprovedBlocks ( ) ; foreach ( $ blocks as $ blockk ) { foreach ( $ blockk as $ block ) { $ this -> pageProductionRenderer -> renderBlock ( json_encode ( $ block ) ) ; } } $ mediaFiles = array_unique ( $ this -> pageProductionRenderer -> getMediaFiles ( ) ) ; $ webDir = $ this -> configurationHandler -> webDir ( ) ; $ fs = new Filesystem ( ) ; foreach ( $ mediaFiles as $ mediaFile ) { $ targetMediaFile = str_replace ( '/backend/' , '/production/' , $ mediaFile ) ; $ fs -> copy ( $ webDir . $ mediaFile , $ webDir . $ targetMediaFile ) ; } }
8861	public function canView ( $ member = null ) { if ( ! parent :: canView ( $ member ) ) return false ; if ( $ this -> PublishDate ) { $ publishDate = $ this -> dbObject ( "PublishDate" ) ; if ( $ publishDate -> InFuture ( ) && ! Permission :: checkMember ( $ member , "VIEW_DRAFT_CONTENT" ) ) { return false ; } } return true ; }
6434	public function getLoginStartUrl ( $ redirecturl ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] , 'callback_uri' => $ redirecturl ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> temp_credentials = $ server -> getTemporaryCredentials ( ) ; return $ server -> getAuthorizationUrl ( $ this -> temp_credentials ) ; }
10769	public function run ( ) { $ viewName = $ this -> resolveViewName ( ) ; $ this -> controller -> actionParams [ $ this -> viewParam ] = Yii :: $ app -> request -> get ( $ this -> viewParam ) ; $ controllerLayout = null ; if ( $ this -> layout !== null ) { $ controllerLayout = $ this -> controller -> layout ; $ this -> controller -> layout = $ this -> layout ; } try { $ output = $ this -> render ( $ viewName ) ; if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } } catch ( InvalidParamException $ e ) { if ( $ controllerLayout ) { $ this -> controller -> layout = $ controllerLayout ; } if ( YII_DEBUG ) { throw new NotFoundHttpException ( $ e -> getMessage ( ) ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return $ output ; }
7103	public static function query ( array $ params = null , $ use_get = null ) { if ( $ use_get ) { if ( $ params === NULL ) { $ params = $ _GET ; } else { $ params = Arr :: merge ( $ _GET , $ params ) ; } } if ( empty ( $ params ) ) { return '' ; } $ query = http_build_query ( $ params , '' , '&' ) ; return ( $ query === '' ) ? '' : ( '?' . $ query ) ; }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
4440	public static function sigName ( int $ signal ) : string { $ signals = [ 'SIGHUP' , 'SIGINT' , 'SIGQUIT' , 'SIGILL' , 'SIGTRAP' , 'SIGABRT' , 'SIGIOT' , 'SIGBUS' , 'SIGFPE' , 'SIGKILL' , 'SIGUSR1' , 'SIGSEGV' , 'SIGUSR2' , 'SIGPIPE' , 'SIGALRM' , 'SIGTERM' , 'SIGSTKFLT' , 'SIGCLD' , 'SIGCHLD' , 'SIGCONT' , 'SIGSTOP' , 'SIGTSTP' , 'SIGTTIN' , 'SIGTTOU' , 'SIGURG' , 'SIGXCPU' , 'SIGXFSZ' , 'SIGVTALRM' , 'SIGPROF' , 'SIGWINCH' , 'SIGPOLL' , 'SIGIO' , 'SIGPWR' , 'SIGSYS' , 'SIGBABY' , ] ; foreach ( $ signals as $ name ) { if ( defined ( $ name ) && constant ( $ name ) === $ signal ) { return $ name ; } } return 'UNKNOWN' ; }
3479	public function withActionLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> actionLocalized = $ localized ; return $ cloned ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
1198	protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; }
12353	public function save ( ) { try { $ autenticacao = new Autenticacao ( ) ; $ autenticacao -> exchangeArray ( $ this -> form -> getData ( ) ) ; $ perfilDefault = $ this -> autenticacaoManager -> getPerfilManager ( ) -> obterPerfilByNome ( Acesso :: getDefaultRole ( ) ) ; $ autenticacao = $ this -> autenticacaoManager -> salvar ( $ autenticacao -> setPerfilId ( $ perfilDefault -> getId ( ) ) -> setPerfil ( $ perfilDefault ) ) ; $ this -> addNotificacao ( new Notificacao ( Notificacao :: TIPO_SUCESSO , self :: MESSAGE_INSERT_SUCCESS ) ) ; } catch ( \ Exception $ e ) { $ this -> addNotificacao ( new Notificacao ( Notificacao :: TIPO_ERRO , self :: MESSAGE_INTERNAL_ERROR ) ) ; } return true ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
6652	public function addExtraData ( array $ extraData = [ ] ) { foreach ( $ extraData as $ key => $ data ) { $ this -> extraData [ $ key ] = $ data ; } }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
6469	public function parseAcceptHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept' , $ i ) ; $ mediaType = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptMediaTypeHeaderValue ( $ mediaType , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
4665	public function createMessage ( ) { $ eventsManager = $ this -> getEventsManager ( ) ; if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:beforeCreateMessage' , $ this ) ; } $ message = $ this -> getDI ( ) -> get ( '\Baka\Mail\Message' , [ $ this ] ) ; if ( ( $ from = $ this -> getConfig ( 'from' ) ) ) { $ message -> from ( $ from [ 'email' ] , isset ( $ from [ 'name' ] ) ? $ from [ 'name' ] : null ) ; } if ( $ eventsManager ) { $ eventsManager -> fire ( 'mailer:afterCreateMessage' , $ this , $ message ) ; } return $ message ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
3565	public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
2996	public function set ( $ key , $ val ) { $ this -> smtp -> set ( $ key , $ this -> encode ( $ val ) ) ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
11822	public function render_admin_header ( ) { $ page = filter_input ( INPUT_GET , 'page' ) ; if ( $ this -> page != $ page ) { return ; } echo '<style type="text/css">' ; echo $ this -> twig -> render ( 'list_table.css.twig' , array ( ) ) ; echo '</style>' ; }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
2970	private function doSend ( MessageInterface $ message ) { $ content = $ this -> format ( $ message ) ; $ headers = $ this -> getHeaders ( ) ; $ files = $ this -> getFiles ( $ message ) ; if ( ! empty ( $ files ) ) { parse_str ( $ content , $ fields ) ; $ builder = new MultipartStreamBuilder ( ) ; foreach ( $ fields as $ name => $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ c ) { $ builder -> addResource ( $ name . '[]' , $ c ) ; } continue ; } $ builder -> addResource ( $ name , $ value ) ; } foreach ( $ files as $ key => $ items ) { foreach ( $ items as $ name => $ path ) { $ options = [ ] ; if ( ! is_numeric ( $ name ) ) { $ options [ 'filename' ] = $ name ; } $ value = fopen ( $ path , 'r' ) ; $ builder -> addResource ( $ key , $ value , $ options ) ; } } $ content = $ builder -> build ( ) ; $ headers [ 'Content-Type' ] = 'multipart/form-data; boundary="' . $ builder -> getBoundary ( ) . '"' ; } $ request = $ this -> getMessageFactory ( ) -> createRequest ( 'POST' , $ this -> getEndpoint ( ) , $ headers , $ content ) ; return $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; }
12893	public function create ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
11479	protected function send ( RequestInterface $ request ) : ResponseInterface { $ request = $ request -> withHeader ( "Authorization" , sprintf ( "Bearer %s" , $ this -> apiToken ) ) ; $ request = $ request -> withHeader ( "Content-Type" , "application/json" ) ; $ request = $ request -> withHeader ( "Accept" , "application/json" ) ; try { $ response = $ this -> client -> send ( $ request ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getCode ( ) === 401 ) { throw new ClientException ( "Authorization failed. Did you specify the right api token?" , $ request , null , $ e ) ; } throw new ClientException ( sprintf ( "Failed to execute request (code %d): %s" , $ e -> getCode ( ) , $ e -> getMessage ( ) ) , $ request , null , $ e ) ; } return $ response ; }
8293	protected function errorHandler ( \ Exception $ e , $ url = "" ) { $ this -> errorOccurred = true ; $ this -> requestFile = $ this -> pluginDir . '/content/error.md' ; if ( $ this -> config [ "debug" ] === true ) { $ this -> addOutput ( "_exception" , ( string ) $ e ) ; } $ this -> logger -> critical ( "Exception on url '{url}': {e}" , array ( "url" => $ url , "e" => $ e ) ) ; header ( $ _SERVER [ 'SERVER_PROTOCOL' ] . ' 500 Internal Server Error' , true , 500 ) ; $ this -> requestUrl = "500" ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
12386	public function parse ( ) { $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> sortByName ( ) -> in ( $ this -> pagesDir ) ; $ languages = $ this -> configurationHandler -> languages ( ) ; $ homepage = $ this -> configurationHandler -> homepage ( ) ; foreach ( $ pages as $ page ) { $ pageDir = ( string ) $ page ; $ pageName = basename ( $ pageDir ) ; $ pageDefinitionFile = $ pageDir . '/' . $ this -> pageFile ; if ( ! file_exists ( $ pageDefinitionFile ) ) { continue ; } $ seoDefinition = $ this -> fetchSeoDefinition ( $ this -> pagesDir . '/' . $ pageName , $ this -> seoFile , $ languages ) ; $ pageDefinition = json_decode ( file_get_contents ( $ pageDefinitionFile ) , true ) ; $ pageDefinition [ "seo" ] = $ seoDefinition ; $ pageDefinition [ "isHome" ] = $ homepage == $ pageName ; $ this -> pages [ $ pageName ] = $ pageDefinition ; } return $ this ; }
12107	public function getPage ( $ name ) { if ( ! isset ( $ this -> pages [ $ name ] ) ) { throw new InvalidParameterException ( "Page not found" ) ; } return $ this -> pages [ $ name ] ; }
12794	public function delete ( $ id ) { try { $ response = $ this -> client -> request -> delete ( $ this -> apiEndpoint . "/droplets/$id" ) ; $ status = $ this -> client -> getStatus ( $ response ) ; if ( 204 != $ status ) { throw new Exception ( 'Digital Ocean responded that it could not delete it.' ) ; } return $ status ; } catch ( Exception $ e ) { echo 'Unable to delete server because ' . $ e -> getMessage ( ) ; } }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
2025	public static function findPublishedByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
11407	public function actionTriggerEvents ( ) { Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; $ result = ( $ post = Yii :: $ app -> request -> post ( 'depdrop_parents' ) ) ? Item :: eventList ( $ post [ 0 ] ) : [ ] ; $ output = [ ] ; foreach ( $ result as $ id => $ name ) { $ output [ ] = compact ( 'id' , 'name' ) ; } echo Json :: encode ( [ 'output' => $ output , 'selected' => '' ] ) ; }
5333	public function setSignature ( $ parameters , $ privateKey , $ service , $ endpoint , $ timestamp , $ nonce ) { $ this -> __setCookie ( 'signature' , rawurlencode ( $ this -> sign ( $ privateKey , array_merge ( $ parameters , [ '__service' => $ service , '__hostname' => $ endpoint , '__timestamp' => $ timestamp , '__nonce' => $ nonce , ] ) ) ) ) ; }
6174	protected function delete ( $ path , $ file ) { return $ this -> driver -> delete ( $ this -> root . $ path , $ file ) ; }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
9908	public function setPosition ( $ position ) { if ( ! in_array ( $ position , self :: $ positionXLref ) ) { return false ; } $ this -> position = $ position ; return true ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
1850	private function preHandleFragment ( FragmentReference $ uri , FragmentConfig $ config ) : void { if ( ! isset ( $ uri -> attributes [ 'pageModel' ] ) && $ this -> hasGlobalPageObject ( ) ) { $ uri -> attributes [ 'pageModel' ] = $ GLOBALS [ 'objPage' ] -> id ; } if ( $ this -> preHandlers -> has ( $ uri -> controller ) ) { $ preHandler = $ this -> preHandlers -> get ( $ uri -> controller ) ; $ preHandler -> preHandleFragment ( $ uri , $ config ) ; } }
8196	public function collectDir ( $ dir , $ ext = '.twig' ) { $ iterator = new RegexIterator ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ dir ) , RecursiveIteratorIterator :: LEAVES_ONLY ) , '{' . preg_quote ( $ ext ) . '$}' ) ; return $ this -> collect ( new Twig_Util_TemplateDirIterator ( $ iterator ) ) ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
7993	public function getDiskUsage ( $ diskId , $ type ) { return json_decode ( self :: getClient ( ) -> getDiskUsage ( $ this -> getDomain ( ) , $ diskId , $ type ) ) ; }
362	protected function getClientOptions ( ) { $ filterUrl = isset ( $ this -> filterUrl ) ? $ this -> filterUrl : Yii :: $ app -> request -> url ; $ id = $ this -> filterRowOptions [ 'id' ] ; $ filterSelector = "#$id input, #$id select" ; if ( isset ( $ this -> filterSelector ) ) { $ filterSelector .= ', ' . $ this -> filterSelector ; } return [ 'filterUrl' => Url :: to ( $ filterUrl ) , 'filterSelector' => $ filterSelector , ] ; }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
9284	private function checkImports ( $ lessPath , $ cssPath , $ callback ) { static $ needsRecompile = false ; if ( $ needsRecompile ) return $ needsRecompile ; $ lessContent = file_get_contents ( $ lessPath ) ; preg_match_all ( '/(?<=@import)\s+"([^"]+)/im' , $ lessContent , $ imports ) ; foreach ( $ imports [ 1 ] as $ import ) { $ importPath = realpath ( dirname ( $ lessPath ) . DIRECTORY_SEPARATOR . $ import ) ; if ( file_exists ( $ importPath ) ) { if ( $ callback ( $ importPath , $ cssPath ) ) { $ needsRecompile = true ; break ; } else $ needsRecompile = $ this -> checkImports ( $ importPath , $ cssPath , $ callback ) ; } } return $ needsRecompile ; }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
3004	public function save ( $ filename ) { $ f3 = \ Base :: instance ( ) ; $ lines = explode ( "\n" , $ this -> smtp -> log ( ) ) ; $ start = false ; $ out = '' ; for ( $ i = 0 , $ max = count ( $ lines ) ; $ i < $ max ; $ i ++ ) { if ( ! $ start && preg_match ( '/^354.*?$/' , $ lines [ $ i ] , $ matches ) ) { $ start = true ; continue ; } elseif ( preg_match ( '/^250.*?$\s^QUIT/m' , $ lines [ $ i ] . ( $ i + 1 < $ max ? "\n" . $ lines [ $ i + 1 ] : '' ) , $ matches ) ) break ; if ( $ start ) $ out .= $ lines [ $ i ] . "\n" ; } if ( $ out ) { $ path = $ f3 -> get ( 'mailer.storage_path' ) ; if ( ! is_dir ( $ path ) ) mkdir ( $ path , 0777 , true ) ; $ f3 -> write ( $ path . $ filename , $ out ) ; } }
2919	public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; }
10538	public static function allowFrom ( string $ allowFromUrl ) : self { $ middleware = new self ( sprintf ( self :: VALUE_ALLOW_FROM , $ allowFromUrl ) ) ; if ( ! filter_var ( $ allowFromUrl , FILTER_VALIDATE_URL ) ) { throw new MiddlewareException ( $ middleware , sprintf ( "'%s' is not a valid URL" , $ allowFromUrl ) ) ; } return $ middleware ; }
8835	public function getEnvironment ( string $ operatingSystem ) : EnvironmentInterface { $ environmentList = [ new UnixEnvironment ( ) ] ; $ environment = null ; foreach ( $ environmentList as $ possibleEnvironment ) { if ( in_array ( $ operatingSystem , $ possibleEnvironment -> getSupportedList ( ) ) ) { $ environment = $ possibleEnvironment ; } } if ( is_null ( $ environment ) ) { throw new \ RuntimeException ( 'Unable to find Environment for OS "' . $ operatingSystem . '".' . 'Try explicitly providing an Environment when instantiating the builder.' ) ; } return $ environment ; }
5721	public function doSaveAndPrev ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getPreviousRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
11399	public function getCustomFieldByType ( $ type ) { if ( isset ( $ this -> servicesByType [ $ type ] ) ) { return $ this -> servicesByType [ $ type ] ; } else { throw new \ LogicException ( 'the custom field with type ' . $ type . ' ' . 'is not found' ) ; } }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
4940	public function setIsMultiple ( $ flag ) { $ this -> isMultiple = ( bool ) $ flag ; if ( $ flag ) { $ this -> setAttribute ( 'multiple' , true ) ; } else { $ this -> removeAttribute ( 'multiple' ) ; } return $ this ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
2936	public function getBackups ( ) { $ backups = array_diff ( scandir ( $ this -> backupPath ) , array ( '..' , '.' ) ) ; $ output = [ ] ; foreach ( $ backups as $ backup ) { $ filenamePrefix = preg_quote ( self :: BACKUP_FILENAME_PREFIX , '/' ) ; $ filenameSuffix = preg_quote ( self :: BACKUP_FILENAME_SUFFIX , '/' ) ; $ filenameRegex = '/^' . $ filenamePrefix . '(\d{4})_(\d{2})_(\d{2})_(\d{2})(\d{2})(\d{2})' . $ filenameSuffix . '$/' ; $ datetime = preg_replace ( $ filenameRegex , '$1-$2-$3 $4:$5:$6' , $ backup ) ; $ data = [ 'filename' => $ backup , 'filepath' => $ this -> backupPath . $ backup , 'created_at' => $ datetime , ] ; $ output [ ] = $ data ; } return $ output ; }
12200	public function getData ( $ object ) { if ( ! $ this -> validateObject ( $ object ) ) { throw new InvalidArgumentException ( "Given object isn't instance of {$this->localName}" ) ; } $ reflection = new ReflectionObject ( $ object ) ; $ data = [ ] ; foreach ( array_keys ( $ this -> properties ) as $ localProperty ) { $ property = $ reflection -> getProperty ( $ localProperty ) ; $ property -> setAccessible ( true ) ; $ data [ $ localProperty ] = $ property -> getValue ( $ object ) ; } return $ data ; }
5884	protected function _normalizeConfig ( $ orders ) { if ( empty ( $ orders ) ) { $ orders = [ [ ] ] ; } elseif ( isset ( $ orders [ 'order' ] ) || isset ( $ orders [ 'callback' ] ) ) { $ orders = [ $ orders ] ; } $ default = [ 'order' => $ this -> _table -> aliasField ( $ this -> _table -> getDisplayField ( ) ) , 'callback' => null , ] ; foreach ( $ orders as $ key => $ value ) { $ orders [ $ key ] = $ orders [ $ key ] + $ default ; } $ this -> _config = [ 'orders' => $ orders , ] ; }
10023	public static function flattenArray ( $ array ) { if ( ! is_array ( $ array ) ) { return ( array ) $ array ; } $ arrayValues = [ ] ; foreach ( $ array as $ value ) { if ( is_array ( $ value ) ) { foreach ( $ value as $ val ) { if ( is_array ( $ val ) ) { foreach ( $ val as $ v ) { $ arrayValues [ ] = $ v ; } } else { $ arrayValues [ ] = $ val ; } } } else { $ arrayValues [ ] = $ value ; } } return $ arrayValues ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
7343	protected function initializeStock ( ) { $ this -> stockMode = StockSubjectModes :: MODE_AUTO ; $ this -> stockState = StockSubjectStates :: STATE_OUT_OF_STOCK ; $ this -> stockFloor = 0 ; $ this -> inStock = 0 ; $ this -> availableStock = 0 ; $ this -> virtualStock = 0 ; $ this -> replenishmentTime = 2 ; $ this -> minimumOrderQuantity = 1 ; $ this -> quoteOnly = false ; $ this -> endOfLife = false ; }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
11200	public function checkIfSingleton ( $ name , $ item ) { if ( isset ( $ this -> signaturesToSingletons -> $ name ) and $ this -> signaturesToSingletons -> $ name ) { $ this -> $ name = $ item ; $ this -> signaturesToSingletons = false ; } }
12094	public function getMd5Url ( $ address , $ scheme = true , $ www = true ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getMd5Address ( $ scheme , $ www ) ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
11517	protected function GenerateIOSPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ IOSPinicon ) { $ metadata .= $ this -> owner -> MarkupComment ( 'iOS Pinned Icon' ) ; if ( $ config -> fetchPiniconTitle ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'apple-mobile-web-app-title' , $ config -> fetchPiniconTitle ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 57 , 57 ) -> getAbsoluteURL ( ) , 'image/png' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 60 , 60 ) -> getAbsoluteURL ( ) , 'image/png' , '60x60' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'image/png' , '72x72' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 76 , 76 ) -> getAbsoluteURL ( ) , 'image/png' , '76x76' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 114 , 114 ) -> getAbsoluteURL ( ) , 'image/png' , '114x114' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 120 , 120 ) -> getAbsoluteURL ( ) , 'image/png' , '120x120' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'image/png' , '144x144' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 152 , 152 ) -> getAbsoluteURL ( ) , 'image/png' , '152x152' ) ; $ metadata .= $ owner -> MarkupLink ( 'apple-touch-icon' , $ IOSPinicon -> Fill ( 180 , 180 ) -> getAbsoluteURL ( ) , 'image/png' , '180x180' ) ; }
10182	public function unsetWorksheetCells ( ) { if ( $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCell = null ; $ this -> currentCoordinate = null ; } $ this -> __destruct ( ) ; $ this -> index = [ ] ; $ this -> parent = null ; }
6162	public function start ( ) { if ( $ this -> isRunning ( ) ) { return ; } $ this -> data [ "realmem_start" ] = memory_get_usage ( true ) ; $ this -> data [ "emalloc_start" ] = memory_get_usage ( ) ; $ this -> started = microtime ( true ) ; $ this -> running = true ; }
7982	public function addDeleteTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaDeleteTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
5593	protected function fetch ( $ url , $ encoding ) { $ request = $ this -> createRequest ( $ url , $ encoding ) ; return $ request -> fetch ( $ this -> connection_timeout ) ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
3891	public function loadCallback ( string $ value = null ) { return null === $ value ? null : trim ( \ base64_encode ( $ value ) , '=' ) ; }
2637	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; $ this -> api -> upsertDictionaryItem ( $ dictionaryId , $ key , $ value ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6921	public function get ( TaxGroupInterface $ taxGroup , CountryInterface $ country , $ business = false ) { $ key = $ this -> buildKey ( $ taxGroup , $ country , $ business ) ; if ( isset ( $ this -> taxes [ $ key ] ) ) { return $ this -> taxes [ $ key ] ; } return null ; }
2860	public function getLimitOptionsSelect ( ) { $ filterHelper = Mage :: helper ( 'sheep_debug/filter' ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'limit' ) -> setId ( 'limit' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'limit' , $ filterHelper -> getLimitDefaultValue ( ) ) ) -> setOptions ( $ this -> getOptionArray ( $ filterHelper -> getLimitValues ( ) ) ) ; return $ select -> getHtml ( ) ; }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
11765	public function remove ( ExpressionContract $ e ) { unset ( $ this -> expressions [ $ this -> indexOf ( $ e ) ] ) ; $ this -> expressions = array_values ( $ this -> expressions ) ; return $ this ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
8666	public function setInvalidASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4086	public function handle ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'filterparams' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ objFilterSettings = $ this -> settingFactory -> createCollection ( $ model -> getProperty ( 'filter' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'subfields' ] = $ objFilterSettings -> getParameterDCA ( ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
8413	public function getLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } if ( $ this -> transactionLevel >= 1 ) { return $ this -> servers [ 'write' ] [ 'link' ] ; } return $ this -> servers [ 'read' ] [ 'link' ] ; }
9961	public function freezePane ( $ cell , $ topLeftCell = null ) { if ( is_string ( $ cell ) && Coordinate :: coordinateIsRange ( $ cell ) ) { throw new Exception ( 'Freeze pane can not be set on a range of cells.' ) ; } if ( $ cell !== null && $ topLeftCell === null ) { $ coordinate = Coordinate :: coordinateFromString ( $ cell ) ; $ topLeftCell = $ coordinate [ 0 ] . $ coordinate [ 1 ] ; } $ this -> freezePane = $ cell ; $ this -> topLeftCell = $ topLeftCell ; return $ this ; }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
11750	public function relation ( ) { if ( is_null ( $ this -> relation ) ) { $ this -> relation = new Relation ( $ this -> accessToken ) ; } return $ this -> relation ; }
97	private function selectRestVersion ( $ channelXml , $ supportedVersions ) { $ channelXml -> registerXPathNamespace ( 'ns' , self :: CHANNEL_NS ) ; foreach ( $ supportedVersions as $ version ) { $ xpathTest = "ns:servers/ns:*/ns:rest/ns:baseurl[@type='{$version}']" ; $ testResult = $ channelXml -> xpath ( $ xpathTest ) ; foreach ( $ testResult as $ result ) { $ result = ( string ) $ result ; if ( preg_match ( '{^https://}i' , $ result ) ) { return array ( 'version' => $ version , 'baseUrl' => $ result ) ; } } if ( count ( $ testResult ) > 0 ) { return array ( 'version' => $ version , 'baseUrl' => ( string ) $ testResult [ 0 ] ) ; } } return null ; }
2281	protected static function httpHost ( ) { if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } else { $ host = $ _SERVER [ 'SERVER_NAME' ] ; if ( $ _SERVER [ 'SERVER_PORT' ] != 80 ) { $ host .= ':' . $ _SERVER [ 'SERVER_PORT' ] ; } } return preg_replace ( '/[^A-Za-z0-9[\].:-]/' , '' , $ host ) ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
4203	private function addProperties ( Event $ abs ) { if ( $ abs [ 'debugMethod' ] === 'table' && $ abs [ 'traverseValues' ] ) { return ; } $ obj = $ abs -> getSubject ( ) ; $ reflectionObject = $ abs [ 'reflector' ] ; while ( $ reflectionObject ) { $ className = $ reflectionObject -> getName ( ) ; $ properties = $ reflectionObject -> getProperties ( ) ; $ isDebugObj = $ className == __NAMESPACE__ ; while ( $ properties ) { $ reflectionProperty = \ array_shift ( $ properties ) ; $ name = $ reflectionProperty -> getName ( ) ; if ( isset ( $ abs [ 'properties' ] [ $ name ] ) ) { $ abs [ 'properties' ] [ $ name ] [ 'overrides' ] = $ this -> propOverrides ( $ reflectionProperty , $ abs [ 'properties' ] [ $ name ] , $ className ) ; $ abs [ 'properties' ] [ $ name ] [ 'originallyDeclared' ] = $ className ; continue ; } if ( $ isDebugObj && $ name == 'data' ) { $ abs [ 'properties' ] [ 'data' ] = \ array_merge ( self :: $ basePropInfo , array ( 'value' => array ( 'NOT INSPECTED' ) , 'visibility' => 'protected' , ) ) ; continue ; } $ abs [ 'properties' ] [ $ name ] = $ this -> getPropInfo ( $ abs , $ reflectionProperty ) ; } $ reflectionObject = $ reflectionObject -> getParentClass ( ) ; } $ this -> addPropertiesPhpDoc ( $ abs ) ; $ this -> addPropertiesDebug ( $ abs ) ; $ properties = $ abs [ 'properties' ] ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ properties as $ name => $ info ) { if ( $ this -> abstracter -> needsAbstraction ( $ info [ 'value' ] ) ) { $ properties [ $ name ] [ 'value' ] = $ this -> abstracter -> getAbstraction ( $ info [ 'value' ] , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) ; } } $ abs [ 'properties' ] = $ properties ; return ; }
12328	public function enqueue_script ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue script, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ in_footer = $ options -> get_in_footer ( ) ; $ localization_name = $ options -> get_localization_name ( ) ; $ data = $ options -> get_data ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_register_script ( $ handle , $ source , $ dependencies , $ version , $ in_footer ) ; if ( ! empty ( $ localization_name ) && ! empty ( $ data ) ) { wp_localize_script ( $ handle , $ localization_name , $ data ) ; } wp_enqueue_script ( $ handle ) ; }
4424	protected function execute ( InputInterface $ input , OutputInterface $ output ) { if ( ! $ input -> isInteractive ( ) ) { $ output -> writeln ( '<error>This command only supports interactive execution</error>' ) ; return 1 ; } $ this -> writeSection ( 'Installation' ) ; $ legacySiteAccessGenerator = new LegacySiteAccessGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ legacySiteAccessGenerator -> generate ( $ this -> input , $ this -> output ) ; $ configurationGenerator = new ConfigurationGenerator ( $ this -> getContainer ( ) , $ this -> questionHelper ) ; $ configurationGenerator -> generate ( $ this -> input , $ this -> output ) ; $ errors = array ( ) ; $ runner = $ this -> getRunner ( $ errors ) ; $ runner ( $ this -> generateLegacyAutoloads ( ) ) ; $ this -> writeInstallerSummary ( $ errors ) ; return 0 ; }
9221	public function offsetExists ( $ offset ) { if ( ! isset ( $ this -> data [ $ offset ] ) ) { $ this -> requestAllPages ( ) ; } return isset ( $ this -> data [ $ offset ] ) ; }
6402	public static function register ( ) { set_error_handler ( function ( $ code , $ message , $ file , $ line , $ context ) { if ( error_reporting ( ) == 0 ) { return false ; } ErrorType :: forCode ( $ code ) -> throwException ( $ message , $ file , $ line , $ context ) ; } ) ; }
3921	private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; if ( $ information [ 'isGdImage' ] = $ file -> isGdImage ) { $ information [ 'src' ] = urldecode ( $ this -> resizeImage ( $ fileName ) ) ; if ( file_exists ( TL_ROOT . '/' . $ information [ 'src' ] ) ) { $ size = getimagesize ( TL_ROOT . '/' . $ information [ 'src' ] ) ; $ information [ 'lb' ] = 'lb' . $ this -> getLightboxId ( ) ; $ information [ 'w' ] = $ size [ 0 ] ; $ information [ 'h' ] = $ size [ 1 ] ; $ information [ 'wh' ] = $ size [ 3 ] ; } } if ( $ information [ 'isSvgImage' ] = $ file -> isSvgImage ) { $ information [ 'src' ] = $ fileName ; } if ( $ information [ 'isPicture' ] = ( int ) $ this -> resizeImages [ 2 ] ) { $ picture = Picture :: create ( $ file , $ this -> getResizeImages ( ) ) -> getTemplateData ( ) ; $ picture [ 'alt' ] = $ altText ; $ picture [ 'title' ] = $ title ; $ information [ 'picture' ] = $ picture ; } $ this -> modifiedTime [ ] = $ file -> mtime ; $ this -> outputBuffer [ ] = $ information ; }
8553	public function setDebtRecoveryEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11167	protected function generateApi ( ) { $ api = array ( ) ; $ api [ "url" ] = $ this -> getUrl ( ) ; $ api [ "type" ] = "remoting" ; $ actionsArray = array ( ) ; $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ class ) { $ methodArray = array ( ) ; foreach ( $ class -> getMethods ( ) as $ method ) { $ methodArray [ ] = array ( "name" => $ method -> getAnnotatedName ( ) , "len" => $ method -> getLen ( ) ) ; } $ actionsArray [ $ class -> getAnnotatedName ( ) ] = $ methodArray ; } $ api [ "actions" ] = $ actionsArray ; return $ api ; }
12014	public static function execute ( ConnectionInterface $ connection , $ forceSimpleUrl = false ) { $ url = $ connection -> host . '/' . $ connection -> accountId . '/' . $ connection -> db . '' . $ connection -> action . ( isset ( $ connection -> transactionId ) ? '?transaction_id=' . $ connection -> transactionId : '' ) ; if ( $ forceSimpleUrl ) { $ url = $ connection -> host . '/' . $ connection -> accountId ; } if ( $ connection -> debug === true ) { echo "URL: " . $ url . "\r\n" ; echo "USER:PWD: " . $ connection -> username . ":" . str_repeat ( 'X' , strlen ( $ connection -> password ) ) . "\r\n" ; echo "METHOD: " . $ connection -> method . "\r\n" ; echo "QUERY: " . ( isset ( $ connection -> query ) ? $ connection -> query : null ) . "\r\n" ; } $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_USERPWD , $ connection -> username . ":" . $ connection -> password ) ; curl_setopt ( $ curl , CURLOPT_CUSTOMREQUEST , $ connection -> method ) ; curl_setopt ( $ curl , CURLOPT_POSTFIELDS , isset ( $ connection -> query ) ? $ connection -> query : null ) ; curl_setopt ( $ curl , CURLOPT_HTTPHEADER , array ( 'Content-Type: text/plain' ) ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ curl , CURLOPT_SSL_VERIFYHOST , 0 ) ; $ curlResponse = curl_exec ( $ curl ) ; if ( $ connection -> debug === true ) { if ( curl_error ( $ curl ) ) { echo "cURL error: " . curl_error ( $ curl ) . "\r\n" ; } echo "RESPONSE: " . $ curlResponse . "\r\n\r\n" ; } curl_close ( $ curl ) ; return ( $ connection -> query === 'BEGIN_TRANSACTION' ) ? json_decode ( $ curlResponse ) -> transaction_id : ( ( isset ( $ connection -> multiple ) && $ connection -> multiple ) ? new Batch ( $ curlResponse , $ connection ) : new Single ( $ curlResponse , $ connection ) ) ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4028	protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; }
8556	private function fromDOMElement ( DOMElement $ dom ) { $ xpath = new DOMXPath ( $ dom -> ownerDocument ) ; $ xpath -> registerNamespace ( 'a' , 'http://mws.amazonaws.com/doc/2009-01-01/' ) ; foreach ( $ this -> fields as $ fieldName => $ field ) { $ fieldType = $ field [ 'FieldType' ] ; if ( is_array ( $ fieldType ) ) { if ( $ this -> isComplexType ( $ fieldType [ 0 ] ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = new $ fieldType [ 0 ] ( $ element ) ; } } } else { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ text = $ xpath -> query ( './text()' , $ element ) ; $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = $ text -> item ( 0 ) -> data ; } } } } else { if ( $ this -> isComplexType ( $ fieldType ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length == 1 ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = new $ fieldType ( $ elements -> item ( 0 ) ) ; } } else { $ element = $ xpath -> query ( "./a:$fieldName/text()" , $ dom ) ; $ data = null ; if ( $ element -> length == 1 ) { switch ( $ this -> fields [ $ fieldName ] [ 'FieldType' ] ) { case 'DateTime' : $ data = new DateTime ( $ element -> item ( 0 ) -> data , new DateTimeZone ( 'UTC' ) ) ; break ; case 'bool' : $ value = $ element -> item ( 0 ) -> data ; $ data = $ value === 'true' ? true : false ; break ; default : $ data = $ element -> item ( 0 ) -> data ; break ; } $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = $ data ; } } } } }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
3372	private function getFormFactory ( ContainerInterface $ services ) { $ elements = null ; if ( $ services -> has ( 'FormElementManager' ) ) { $ elements = $ services -> get ( 'FormElementManager' ) ; } return new Factory ( $ elements ) ; }
1747	public function getCalendars ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> calendars ) ) { return array ( ) ; } $ arrCalendars = array ( ) ; $ objCalendars = $ this -> Database -> execute ( "SELECT id, title FROM tl_calendar ORDER BY title" ) ; while ( $ objCalendars -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objCalendars -> id , 'calendars' ) ) { $ arrCalendars [ $ objCalendars -> id ] = $ objCalendars -> title ; } } return $ arrCalendars ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
11901	private function assembleUrl ( ) { $ address = '' ; if ( ! empty ( $ this -> scheme ) ) { $ address .= $ this -> scheme . '://' ; } if ( ! empty ( $ this -> user ) ) { $ address .= $ this -> user ; } if ( ! empty ( $ this -> pass ) ) { $ address .= ':' . $ this -> pass . '@' ; } if ( ! empty ( $ this -> host ) ) { $ address .= $ this -> host ; } if ( ! empty ( $ this -> port ) ) { $ address .= ':' . $ this -> port ; } if ( ! empty ( $ this -> path ) ) { $ address .= $ this -> path ; } if ( count ( $ this -> query ) > 0 ) { $ this -> query_string = http_build_query ( $ this -> query ) ; $ address .= '?' . $ this -> query_string ; } if ( ! empty ( $ this -> fragment ) ) { $ address .= '#' . $ this -> fragment ; } $ this -> full_address = $ address ; }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
4165	private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; }
390	public function loadDefaultValues ( $ skipIfSet = true ) { foreach ( static :: getTableSchema ( ) -> columns as $ column ) { if ( $ column -> defaultValue !== null && ( ! $ skipIfSet || $ this -> { $ column -> name } === null ) ) { $ this -> { $ column -> name } = $ column -> defaultValue ; } } return $ this ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
7774	protected function canSkipRule ( $ ruleToCall , $ value ) { return ( ( is_array ( $ ruleToCall ) && method_exists ( $ ruleToCall [ 0 ] , 'canSkip' ) && $ ruleToCall [ 0 ] -> canSkip ( ) ) || empty ( $ value ) && ! is_array ( $ value ) ) ; }
2829	public function enableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
5534	public function paintFooter ( $ group ) { $ aspect = 1 ; $ this -> paintResultsHeader ( ) ; $ this -> paintRectangleStart ( $ this -> _reporter -> getGraph ( ) , 100 , 100 ) ; $ this -> divideMapNodes ( $ this -> _reporter -> getGraph ( ) , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; $ this -> paintResultsFooter ( ) ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
10710	public function getById ( $ id , $ columns = [ '*' ] ) { try { $ results = $ this -> getQuery ( ) -> findOrFail ( $ id , $ columns ) ; } catch ( ModelNotFoundException $ e ) { throw new NotFoundRepositoryException ( $ e ) ; } return $ this -> returnResults ( $ results ) ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
5375	protected function createInputTag ( $ attributes ) { if ( ! isset ( $ attributes [ 'type' ] ) ) { return new SimpleTextTag ( $ attributes ) ; } $ type = strtolower ( trim ( $ attributes [ 'type' ] ) ) ; $ map = array ( 'submit' => 'SimpleSubmitTag' , 'image' => 'SimpleImageSubmitTag' , 'checkbox' => 'SimpleCheckboxTag' , 'radio' => 'SimpleRadioButtonTag' , 'text' => 'SimpleTextTag' , 'hidden' => 'SimpleTextTag' , 'password' => 'SimpleTextTag' , 'file' => 'SimpleUploadTag' ) ; if ( array_key_exists ( $ type , $ map ) ) { $ tag_class = $ map [ $ type ] ; return new $ tag_class ( $ attributes ) ; } return false ; }
7905	public function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , Html :: tag ( 'i' , '' , [ 'class' => 'content icon' ] ) ) ; Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'launch-sidebar icon' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; Html :: addCssClass ( $ this -> toggleButton , 'fixed' ) ; Html :: addCssClass ( $ this -> toggleButton , 'attached' ) ; if ( $ this -> position === static :: POS_LEFT ) { $ position = static :: POS_RIGHT ; } else { $ position = static :: POS_LEFT ; } Html :: addCssClass ( $ this -> toggleButton , $ position ) ; $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
1353	protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; }
6205	public function onException ( \ Exception $ exception ) { if ( $ this -> shouldNotifyException ( $ exception ) ) { $ this -> airbrakeClient -> notifyOnException ( $ exception ) ; } return true ; }
9734	public function setRGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = '000000' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => 'FF' . $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = 'FF' . $ pValue ; } return $ this ; }
6311	public function getTable ( Table $ table ) { return $ this -> container -> get ( 'rentgen.get_table' ) -> setTableName ( $ table -> getName ( ) ) -> execute ( ) ; }
4514	public static function parse ( string $ string , array $ data = [ ] ) : array { if ( $ data ) { $ string = Parameters :: replace ( $ string , $ data ) ; } $ data = Yaml :: parse ( $ string , Yaml :: PARSE_OBJECT_FOR_MAP ) ; if ( ! property_exists ( $ data , 'objects' ) ) { throw new LogicException ( 'Property "objects" does not exist.' ) ; } if ( ! is_array ( $ data -> objects ) ) { throw new LogicException ( 'Property "objects" is not an array.' ) ; } $ prototype = [ ] ; if ( property_exists ( $ data , 'prototype' ) ) { if ( ! is_object ( $ data -> prototype ) ) { throw new LogicException ( 'Property "prototype" is not an object.' ) ; } $ prototype = $ data -> prototype ; } $ objects = [ ] ; foreach ( $ data -> objects as $ object ) { $ objects [ ] = ( object ) array_merge ( ( array ) $ prototype , ( array ) $ object ) ; } return $ objects ; }
12317	public function load ( $ name ) { foreach ( $ this -> sourceDirs as $ dir ) { if ( 0 === strpos ( $ name , DIRECTORY_SEPARATOR ) ) { $ yamlFile = $ name ; } else { $ yamlFile = $ dir . '/' . $ name ; } if ( false === strstr ( $ yamlFile , self :: EXT_YML ) ) { $ yamlFile .= self :: EXT_YML ; } if ( is_file ( $ yamlFile ) ) { return new ArrayCollection ( Yaml :: parse ( $ yamlFile ) ) ; } } throw new \ Exception ( sprintf ( 'No Yaml file found for {%s}' , $ name ) ) ; }
1379	protected function validateRelationship ( $ relation , ? string $ field = null ) : bool { $ path = $ field ? '/data/relationships' : '/' ; $ member = $ field ? : 'data' ; if ( ! is_object ( $ relation ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ path = $ field ? "{$path}/{$field}" : $ path ; if ( ! property_exists ( $ relation , 'data' ) ) { $ this -> memberRequired ( $ path , 'data' ) ; return false ; } $ data = $ relation -> data ; if ( is_array ( $ data ) ) { return $ this -> validateToMany ( $ data , $ field ) ; } return $ this -> validateToOne ( $ data , $ field ) ; }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
9458	private function mapAdminRoutes ( ) { $ this -> adminGroup ( function ( ) { $ this -> name ( 'foundation.' ) -> group ( function ( ) { Routes \ Admin \ DashboardRoute :: register ( ) ; Routes \ Admin \ SettingsRoutes :: register ( ) ; Routes \ Admin \ SystemRoutes :: register ( ) ; } ) ; } ) ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
8727	public function getDirty ( ) { $ dirty = parent :: getDirty ( ) ; if ( ! $ this -> localeChanged ) { return $ dirty ; } foreach ( $ this -> translatableAttributes ( ) as $ key ) { if ( isset ( $ this -> attributes [ $ key ] ) ) { $ dirty [ $ key ] = $ this -> attributes [ $ key ] ; } } return $ dirty ; }
5990	public function addPropertyCriteria ( $ item ) { if ( ! ( $ item instanceof PropertyCriteria ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertyCriteria ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertyCriteria. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertyCriteria"!' , E_USER_WARNING ) ; } } $ this -> properties [ ] = $ item ; return $ this ; }
1875	private function getBundlePackageName ( string $ className ) : string { if ( 'Bundle' === substr ( $ className , - 6 ) ) { $ className = substr ( $ className , 0 , - 6 ) ; } return Container :: underscore ( $ className ) ; }
8110	public static function start ( ) { $ compatibility = [ self :: SUBSITES => null , ] ; if ( ClassInfo :: exists ( Subsite :: class ) ) { $ compatibility [ self :: SUBSITES ] = Subsite :: $ disable_subsite_filter ; Subsite :: disable_subsite_filter ( true ) ; } return $ compatibility ; }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
11074	public function setDateTime ( string $ key , $ value , string $ format , string $ ignoredDefaultValue = null ) { if ( $ value instanceof DateTime ) { $ this -> set ( $ key , $ value -> format ( $ format ) , $ ignoredDefaultValue ) ; } return $ this ; }
10682	public static function quoteWith ( $ o , $ quote = '\'' ) { if ( strlen ( $ quote ) !== 1 ) { throw new InvalidArgumentException ( '2nd parameter must be single character, two or more characters are given' ) ; } if ( is_array ( $ o ) ) { $ len = count ( $ o ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ tmp [ $ i ] = $ quote . $ o [ $ i ] . $ quote ; } return $ tmp ; } return $ quote . $ o . $ quote ; }
8317	protected function sendResetMail ( $ userData ) { if ( ! $ this -> mailer ) { $ this -> getLogger ( ) -> critical ( "Sending mail but no mailer is set!" ) ; return ; } $ url = $ this -> createResetToken ( $ userData [ 'name' ] ) ; $ message = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailMessage" ] ) ; $ subject = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailSubject" ] ) ; $ message = str_replace ( "%url%" , $ url , $ message ) ; $ message = str_replace ( "%username%" , $ userData [ 'name' ] , $ message ) ; $ this -> mailer -> setup ( ) ; $ this -> mailer -> setTo ( $ userData [ 'email' ] ) ; $ this -> mailer -> setSubject ( $ subject ) ; $ this -> mailer -> setBody ( $ message ) ; if ( ! $ this -> mailer -> send ( ) ) { $ this -> getLogger ( ) -> critical ( "Mailer error: {e}" , [ "e" => $ this -> mailer -> getError ( ) ] ) ; } else { $ this -> getLogger ( ) -> info ( "PwReset email sent to {email}" , [ "email" => $ userData [ 'email' ] ] ) ; } }
8314	protected function finishPasswordReset ( array $ resetData ) { if ( time ( ) > $ resetData [ 'validity' ] ) { $ this -> session -> remove ( "pwreset" ) ; $ this -> session -> addFlash ( "error" , "Page validity expired, please try again." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } $ this -> picoAuth -> addOutput ( "isReset" , true ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwreset.md' ) ; $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ username = $ resetData [ 'user' ] ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> session -> remove ( "pwreset" ) ; $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> logPasswordReset ( $ username ) ; $ localAuth -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
614	protected function getDependencies ( $ class ) { if ( isset ( $ this -> _reflections [ $ class ] ) ) { return [ $ this -> _reflections [ $ class ] , $ this -> _dependencies [ $ class ] ] ; } $ dependencies = [ ] ; try { $ reflection = new ReflectionClass ( $ class ) ; } catch ( \ ReflectionException $ e ) { throw new InvalidConfigException ( 'Failed to instantiate component or class "' . $ class . '".' , 0 , $ e ) ; } $ constructor = $ reflection -> getConstructor ( ) ; if ( $ constructor !== null ) { foreach ( $ constructor -> getParameters ( ) as $ param ) { if ( version_compare ( PHP_VERSION , '5.6.0' , '>=' ) && $ param -> isVariadic ( ) ) { break ; } elseif ( $ param -> isDefaultValueAvailable ( ) ) { $ dependencies [ ] = $ param -> getDefaultValue ( ) ; } else { $ c = $ param -> getClass ( ) ; $ dependencies [ ] = Instance :: of ( $ c === null ? null : $ c -> getName ( ) ) ; } } } $ this -> _reflections [ $ class ] = $ reflection ; $ this -> _dependencies [ $ class ] = $ dependencies ; return [ $ reflection , $ dependencies ] ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
933	public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { if ( ! $ other -> isArray ) { $ otherPrototype = $ other -> content ; } else { $ otherPrototype = [ $ other -> id , $ other -> content , ] ; } } else { $ otherPrototype = $ other ; } if ( $ this -> isArray !== \ is_array ( $ otherPrototype ) ) { return false ; } if ( ! $ this -> isArray ) { return $ this -> content === $ otherPrototype ; } if ( $ this -> id !== $ otherPrototype [ 0 ] ) { return false ; } if ( isset ( $ otherPrototype [ 1 ] ) ) { if ( $ caseSensitive ) { if ( $ this -> content !== $ otherPrototype [ 1 ] ) { return false ; } } elseif ( 0 !== strcasecmp ( $ this -> content , $ otherPrototype [ 1 ] ) ) { return false ; } } unset ( $ otherPrototype [ 0 ] , $ otherPrototype [ 1 ] ) ; return empty ( $ otherPrototype ) ; }
2679	public function queryHistoricStats ( array $ parameters ) { $ uri = $ this -> _getHistoricalEndpoint ( ) . '?region=' . $ parameters [ 'region' ] . '&from=' . $ parameters [ 'from' ] . '&to=' . $ parameters [ 'to' ] . '&by=' . $ parameters [ 'sample_rate' ] ; $ result = $ this -> _fetch ( $ uri ) ; return $ result ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
10067	protected function registerTags ( ) { $ tags = array ( 'error' , 'hint' , 'label' , 'radioset' , 'checkboxset' ) ; foreach ( $ tags as $ tag ) { $ tagClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ tag ) ) ) ; $ this -> registerTag ( $ tag , __NAMESPACE__ . '\Tag\\' . $ tagClass ) ; } $ widgets = array ( 'text' , 'file' , 'textarea' , 'radio' , 'checkbox' , 'select' , 'multiselect' , 'checkboxset' , 'radioset' , 'email' , 'password' , 'radioset' , 'checkboxset' , 'button' , 'submit' , 'reset' , 'group' , 'fieldset' , 'collection' , 'form' ) ; foreach ( $ widgets as $ widget ) { $ widgetClass = str_replace ( ' ' , '' , ucwords ( str_replace ( '-' , ' ' , $ widget ) ) ) ; $ this -> registerTag ( 'widget-' . $ widget , __NAMESPACE__ . '\Widget\\' . $ widgetClass ) ; } }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
7251	protected function validateIdentity ( SaleInterface $ sale , Constraint $ constraint ) { if ( null === $ sale -> getCustomer ( ) ) { if ( null === $ sale -> getCustomerGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> customer_group_is_required_if_no_customer ) -> atPath ( 'customerGroup' ) -> addViolation ( ) ; } if ( 0 == strlen ( $ sale -> getEmail ( ) ) ) { $ this -> context -> buildViolation ( $ constraint -> email_is_required_if_no_customer ) -> atPath ( 'email' ) -> addViolation ( ) ; } IdentityValidator :: validateIdentity ( $ this -> context , $ sale ) ; } }
7003	public function match ( $ test ) { $ isArray = [ ] ; $ pattern = preg_replace_callback ( "~/\{(?<arg>\w+)(?<arr>\[\])?\}(?<num>\?|\+|\*|\{[0-9,]+\})?~" , function ( $ matches ) use ( & $ isArray ) { $ name = $ matches [ "arg" ] ; $ num = $ matches [ "num" ] ?? "" ; $ isArray [ $ name ] = ! empty ( $ matches [ 2 ] ) ; return "(?<$name>(?:/[^\\s/?]+)$num)" ; } , $ this -> url ) ; if ( ! $ pattern || empty ( $ pattern ) ) { error_log ( "pattern error: found in route with pattern: {$this->url}" ) ; return false ; } $ pattern = "^$pattern/?(?:\?.*)?$" ; if ( preg_match ( "~$pattern~" , $ test , $ matches ) ) { foreach ( $ matches as $ name => $ val ) { $ val = urldecode ( $ val ) ; if ( is_int ( $ name ) ) { if ( $ name === 0 ) $ this -> args [ $ name ] = $ val ; } else { $ val = ltrim ( $ val , "/" ) ; $ this -> args [ $ name ] = $ isArray [ $ name ] ? explode ( "/" , $ val ) : $ val ; } } return true ; } return false ; }
7154	protected function match ( $ role , $ action ) : bool { $ roles = $ actions = [ '*' ] ; $ allow = false ; if ( $ role != '*' ) array_unshift ( $ roles , $ role ) ; if ( $ action != '*' ) array_unshift ( $ actions , $ action ) ; foreach ( $ roles as $ _role ) { foreach ( $ actions as $ _action ) { if ( isset ( $ this -> _rules [ $ _role ] [ $ _action ] ) ) { $ allow = $ this -> _rules [ $ _role ] [ $ _action ] ; break 2 ; } } } return $ allow === true ; }
780	public function getValue ( $ name , $ defaultValue = null ) { return isset ( $ this -> _cookies [ $ name ] ) ? $ this -> _cookies [ $ name ] -> value : $ defaultValue ; }
1326	public function getSignableParameters ( ) { $ params = $ this -> parameters ; if ( isset ( $ params [ 'oauth_signature' ] ) ) { unset ( $ params [ 'oauth_signature' ] ) ; } return Util :: buildHttpQuery ( $ params ) ; }
17	public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; }
4288	public function onError ( Event $ event ) { if ( $ event [ 'inConsole' ] || ! $ event [ 'isFirstOccur' ] ) { return ; } $ this -> processLogEntry ( 'errorNotConsoled' , array ( $ event [ 'typeStr' ] . ': ' . $ event [ 'file' ] . ' (line ' . $ event [ 'line' ] . '): ' . $ event [ 'message' ] ) , array ( 'channel' => 'phpError' , 'class' => $ event [ 'type' ] & $ this -> debug -> getCfg ( 'errorMask' ) ? 'danger' : 'warning' , ) ) ; }
11878	protected static function getDumpContent ( $ var , $ maxSize = null ) { $ dump = '<div class="dump_segment_content_main">' ; $ dump .= '<div class="dump_variable">' ; $ dump .= sprintf ( '<ul>%s</ul>' , static :: dumpElement ( $ var , '' , $ maxSize ) ) ; $ dump .= '</div>' ; $ dump .= '</div>' ; return $ dump ; }
2294	public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ lang . '.js' ) ) { return $ lang ; } if ( ( $ short = substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ short . '.js' ) ) { return $ short ; } } elseif ( ( $ long = $ short . '_' . strtoupper ( $ short ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ long . '.js' ) ) { return $ long ; } } return 'en' ; }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
19	protected function getRepoData ( ) { $ resource = sprintf ( 'https://api.bitbucket.org/2.0/repositories/%s/%s?%s' , $ this -> owner , $ this -> repository , http_build_query ( array ( 'fields' => '-project,-owner' ) , null , '&' ) ) ; $ repoData = JsonFile :: parseJson ( $ this -> getContentsWithOAuthCredentials ( $ resource , true ) , $ resource ) ; if ( $ this -> fallbackDriver ) { return false ; } $ this -> parseCloneUrls ( $ repoData [ 'links' ] [ 'clone' ] ) ; $ this -> hasIssues = ! empty ( $ repoData [ 'has_issues' ] ) ; $ this -> branchesUrl = $ repoData [ 'links' ] [ 'branches' ] [ 'href' ] ; $ this -> tagsUrl = $ repoData [ 'links' ] [ 'tags' ] [ 'href' ] ; $ this -> homeUrl = $ repoData [ 'links' ] [ 'html' ] [ 'href' ] ; $ this -> website = $ repoData [ 'website' ] ; $ this -> vcsType = $ repoData [ 'scm' ] ; return true ; }
12578	public function previewVoiceByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
6777	protected function updateVatData ( SaleInterface $ sale ) { $ changed = false ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( 0 == strlen ( $ sale -> getVatNumber ( ) ) && 0 < strlen ( $ customer -> getVatNumber ( ) ) ) { $ sale -> setVatNumber ( $ customer -> getVatNumber ( ) ) ; $ changed = true ; } if ( empty ( $ sale -> getVatDetails ( ) ) && ! empty ( $ customer -> getVatDetails ( ) ) ) { $ sale -> setVatDetails ( $ customer -> getVatDetails ( ) ) ; $ changed = true ; } if ( ! $ sale -> isVatValid ( ) && $ customer -> isVatValid ( ) ) { $ sale -> setVatValid ( true ) ; $ changed = true ; } } return $ changed ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
10144	private function readBof ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ substreamType = self :: getUInt2d ( $ recordData , 2 ) ; switch ( $ substreamType ) { case self :: XLS_WORKBOOKGLOBALS : $ version = self :: getUInt2d ( $ recordData , 0 ) ; if ( ( $ version != self :: XLS_BIFF8 ) && ( $ version != self :: XLS_BIFF7 ) ) { throw new Exception ( 'Cannot read this Excel file. Version is too old.' ) ; } $ this -> version = $ version ; break ; case self :: XLS_WORKSHEET : break ; default : do { $ code = self :: getUInt2d ( $ this -> data , $ this -> pos ) ; $ this -> readDefault ( ) ; } while ( $ code != self :: XLS_TYPE_EOF && $ this -> pos < $ this -> dataSize ) ; break ; } }
5768	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( count ( $ this -> args ) > 1 ) { $ this -> setColumnsValues .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> setColumnsValues .= "$name = \$" . $ argNum ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
9161	private function addParsedHeader ( $ line ) { if ( strpos ( $ line , ':' ) === false ) { $ this -> responseCode = HttpStatus :: parseStatus ( $ line ) -> getCode ( ) ; } else { $ line = trim ( $ line ) ; list ( $ headerName , $ headerValue ) = explode ( ':' , $ line , 2 ) ; $ this -> headers [ $ headerName ] = trim ( $ headerValue ) ; } }
11622	public function api ( string $ link = null , string $ method = null ) : \ TheCMSThread \ Classes \ API { static $ api ; if ( $ api === null ) { $ api = $ this -> container -> get ( "TheCMSThread\\Core\\API" ) ; } return $ api -> set ( $ link , $ method ) ; }
4025	private function addCondition ( PropertyInterface $ property , ConditionInterface $ condition ) { $ chain = $ property -> getVisibleCondition ( ) ; if ( ! ( $ chain && ( $ chain instanceof PropertyConditionChain ) && $ chain -> getConjunction ( ) == PropertyConditionChain :: AND_CONJUNCTION ) ) { if ( $ property -> getVisibleCondition ( ) ) { $ previous = array ( $ property -> getVisibleCondition ( ) ) ; } else { $ previous = array ( ) ; } $ chain = new PropertyConditionChain ( $ previous , PropertyConditionChain :: AND_CONJUNCTION ) ; $ property -> setVisibleCondition ( $ chain ) ; } $ chain -> addCondition ( $ condition ) ; }
12329	public function enqueue_style ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue style, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ media = $ options -> get_media ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_enqueue_style ( $ handle , $ source , $ dependencies , $ version , $ media ) ; }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
9634	public function getFormField ( ) { if ( null === $ this -> field ) { $ this -> field = $ this -> initFormField ( ) ; } return $ this -> field ; }
1113	protected function mapTreeRecursive ( array $ tree , $ parentKey = null , & $ affectedKeys = array ( ) ) { foreach ( $ tree as $ attributes ) { $ node = $ this -> firstOrNew ( $ this -> getSearchAttributes ( $ attributes ) ) ; $ data = $ this -> getDataAttributes ( $ attributes ) ; if ( ! is_null ( $ parentKey ) ) $ data [ $ node -> getParentColumnName ( ) ] = $ parentKey ; $ node -> fill ( $ data ) ; $ result = $ node -> save ( ) ; if ( ! $ result ) return false ; $ affectedKeys [ ] = $ node -> getKey ( ) ; if ( array_key_exists ( $ this -> getChildrenKeyName ( ) , $ attributes ) ) { $ children = $ attributes [ $ this -> getChildrenKeyName ( ) ] ; if ( count ( $ children ) > 0 ) { $ result = $ this -> mapTreeRecursive ( $ children , $ node -> getKey ( ) , $ affectedKeys ) ; if ( ! $ result ) return false ; } } } return true ; }
10724	public function getNumRows ( ) { $ builtSql = SqlBuilder :: buildRowCountSql ( $ this ) ; if ( is_array ( $ builtSql ) ) { $ preparedSth = $ this -> connect ( ) -> prepare ( $ builtSql [ 0 ] ) ; $ boundSth = StatementBuilder :: bindValues ( $ preparedSth , $ builtSql [ 1 ] ) ; $ boundSth -> execute ( ) ; } else { $ boundSth = $ this -> connect ( ) -> query ( $ builtSql ) ; } $ result = $ boundSth -> fetch ( PDO :: FETCH_ASSOC ) ; return ( int ) $ result [ 'total_count' ] ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
7967	public function setProperties ( $ billingAccount , $ properties ) { if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; if ( ! $ properties ) throw new BadMethodCallException ( 'Parameter $properties is missing.' ) ; if ( ! is_array ( $ properties ) ) throw new BadMethodCallException ( 'Parameter $properties must be a array.' ) ; $ t = array ( ) ; if ( array_key_exists ( 'description' , $ properties ) ) $ t [ 'description' ] = $ properties [ 'description' ] ; $ properties = $ t ; unset ( $ t ) ; if ( count ( $ properties ) == 0 ) throw new BadMethodCallException ( 'Parameter $properties does not contain valid key. valid key is "description"' ) ; try { $ r = $ this -> put ( 'telephony/' . $ billingAccount , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ properties ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return true ; }
1333	protected function applyFilters ( $ query , Collection $ filters ) { if ( $ this -> isFindMany ( $ filters ) ) { $ this -> filterByIds ( $ query , $ filters ) ; } $ this -> filter ( $ query , $ filters ) ; }
7592	protected function setFormClass ( FormInterface $ oForm , $ sFormLayout = self :: LAYOUT_HORIZONTAL ) { if ( is_string ( $ sFormLayout ) ) { $ sLayoutClass = 'form-' . $ sFormLayout ; if ( $ sFormClass = $ oForm -> getAttribute ( 'class' ) ) { if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sLayoutClass , '/' ) . '(\s|$)/' , $ sFormClass ) ) { $ oForm -> setAttribute ( 'class' , trim ( $ sFormClass . ' ' . $ sLayoutClass ) ) ; } } else { $ oForm -> setAttribute ( 'class' , $ sLayoutClass ) ; } } return $ this ; }
1816	public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; }
3983	private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 'icon' => 'modPlus.gif' , 'modules' => [ ] , ] ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
6166	protected function writeProgress ( $ progress ) { $ this -> progress = ! $ this -> flawless && $ progress === '.' ? $ this -> formatWithColor ( 'fg-red' , '!' ) : $ progress ; ++ $ this -> numTestsRun ; }
11109	public function getExtensions ( Container $ app ) { $ directories = $ this -> findExtensionsDirectories ( $ app ) ; foreach ( $ directories as $ directory ) { $ extensionName = $ directory -> getRelativePathname ( ) ; $ this -> extensions [ $ extensionName ] [ 'name' ] = $ extensionName ; $ this -> extensions [ $ extensionName ] [ 'pathName' ] = $ directory -> getPathName ( ) ; } return $ this -> extensions ; }
2614	public function getWebsiteName ( ) { $ websites = $ this -> storeManager -> getWebsites ( ) ; $ websiteName = 'Not set.' ; foreach ( $ websites as $ website ) { if ( $ website -> getIsDefault ( ) ) { $ websiteName = $ website -> getName ( ) ; } } return $ websiteName ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
2171	private function login ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'login.html.twig' ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ verified = password_verify ( $ request -> request -> get ( 'password' ) , $ installTool -> getConfig ( 'installPassword' ) ) ; if ( ! $ verified ) { $ installTool -> increaseLoginCount ( ) ; return $ this -> render ( 'login.html.twig' , [ 'error' => $ this -> trans ( 'invalid_password' ) , ] ) ; } $ installTool -> resetLoginCount ( ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
1940	public function checkUniqueRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objRecipient = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( $ varValue , $ dc -> id , $ dc -> id ) ; if ( $ objRecipient -> count > 0 ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unique' ] , $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ $ dc -> field ] [ 0 ] ) ) ; } return $ varValue ; }
6048	public function retrieveObjectType ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ObjectType ( $ result ) ; return $ result ; }
11915	public static function from ( Reader $ reader , \ Reflector $ reflector ) { if ( $ reflector instanceof \ ReflectionClass ) { return new static ( Psi :: it ( $ reader -> getClassAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } if ( $ reflector instanceof \ ReflectionMethod ) { return new static ( Psi :: it ( $ reader -> getMethodAnnotations ( $ reflector ) ) -> toArray ( ) ) ; } return new static ( ) ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8953	public function createNode ( $ changeset , $ latitude , $ longitude , $ tags ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'node/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <node changeset="' . $ changeset . '" lat="' . $ latitude . '" lon="' . $ longitude . '">' . $ tagList . '</node> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
10118	private function writeMarginLeft ( ) { $ record = 0x0026 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getLeft ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
1713	protected function executePostActionsHook ( DataContainer $ dc ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executePostActions' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> strAction , $ dc ) ; } } }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
5098	private function appendByPosition ( $ values ) { $ this -> setPart ( CmdInsert :: PART_AS , false ) ; if ( ! $ this -> placeholder ) $ this -> placeholder = Assembly :: placeholder ( count ( $ values ) , true ) ; return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ this -> placeholder , $ values ) ; }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
7551	function hasAttribute ( $ attr , $ compare = 'total' , $ case_sensitive = false ) { return ( ( bool ) $ this -> findAttribute ( $ attr , $ compare , $ case_sensitive ) ) ; }
9770	function matchFormat ( string $ format ) : self { return $ this -> expect ( $ this -> target , matches ( $ format ) ) ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
6082	public function removeComment ( $ mediaId , $ commentId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ mediaId . '/comments/' . $ commentId . '' , $ parameters ) ; $ result = new Comment ( $ result ) ; return $ result ; }
9349	public function multiplyAllow ( $ matrix ) { if ( is_numeric ( $ matrix ) ) { return true ; } if ( $ matrix instanceof Complex ) { return true ; } if ( $ matrix instanceof Matrix ) { return $ this -> size -> cols == $ matrix -> rows ; } return false ; }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
6972	private function buildEntity ( ClassMetadata $ metadata , $ data ) { $ class = $ metadata -> getName ( ) ; $ entity = new $ class ; foreach ( $ data as $ propertyPath => $ value ) { if ( $ metadata -> hasField ( $ propertyPath ) ) { $ builtValue = $ this -> buildFieldValue ( $ metadata , $ propertyPath , $ value ) ; } elseif ( $ metadata -> hasAssociation ( $ propertyPath ) ) { $ builtValue = $ this -> buildAssociationValue ( $ metadata , $ propertyPath , $ value ) ; } else { throw new \ Exception ( "Unexpected property path '$propertyPath' for class '$class'." ) ; } $ this -> accessor -> setValue ( $ entity , $ propertyPath , $ builtValue ) ; } return $ entity ; }
3574	protected function update ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { $ value = $ key -> getValue ( ) ; $ group = $ key -> getMetaGroup ( ) ; $ key = $ key -> getMetaKey ( ) ; } $ this -> get ( $ key ) -> setValue ( $ value ) ; $ this -> get ( $ key ) -> setMetaGroup ( $ group ) ; return $ this ; }
9706	private function writeAllNumberFormats ( ) { foreach ( $ this -> numberFormats as $ numberFormatIndex => $ numberFormat ) { $ this -> writeNumberFormat ( $ numberFormat -> getFormatCode ( ) , $ numberFormatIndex ) ; } }
10124	private function writeGridset ( ) { $ record = 0x0082 ; $ length = 0x0002 ; $ fGridSet = ! $ this -> phpSheet -> getPrintGridlines ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fGridSet ) ; $ this -> append ( $ header . $ data ) ; }
5627	public function asString ( ) { $ path = $ this -> path ; $ scheme = $ identity = $ host = $ port = $ encoded = $ fragment = '' ; if ( $ this -> username && $ this -> password ) { $ identity = $ this -> username . ':' . $ this -> password . '@' ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ? $ this -> getScheme ( ) : 'http' ; $ scheme .= '://' ; $ host = $ this -> getHost ( ) ; } elseif ( $ this -> getScheme ( ) === 'file' ) { $ scheme = 'file://' ; } if ( $ this -> getPort ( ) && $ this -> getPort ( ) != 80 ) { $ port = ':' . $ this -> getPort ( ) ; } if ( substr ( $ this -> path , 0 , 1 ) == '/' ) { $ path = $ this -> normalisePath ( $ this -> path ) ; } $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return "$scheme$identity$host$port$path$encoded$fragment$coords" ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
2225	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( 'html' !== $ request -> getRequestFormat ( ) ) { return ; } if ( ! AcceptHeader :: fromString ( $ request -> headers -> get ( 'Accept' ) ) -> has ( 'text/html' ) ) { return ; } $ this -> handleException ( $ event ) ; }
605	protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
5787	public function routeGetLogout ( Request $ request , Response $ response ) { $ this -> events -> setAdministratorId ( $ this -> authentication -> getAdministratorId ( ) ) ; if ( null === $ username = $ this -> authentication -> getAdministratorUsername ( ) ) { $ this -> events -> insertWarning ( EVENT_LOGOUT_FAULT ) ; } else { $ this -> events -> insertInfo ( EVENT_LOGOUT ) ; $ this -> authentication -> logout ( ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( ROUTE_HOME ) ) ; }
12206	public function createPagination ( $ currentPage , $ total , $ perPage = null , $ baseUrl = null , $ neighbours = null ) { if ( isset ( $ this -> container ) && $ this -> container instanceof \ League \ Container \ ContainerInterface ) { return $ this -> getContainer ( ) -> get ( 'Laasti\Pagination\Pagination' , [ $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ] ) ; } $ perPage = $ perPage ? : 10 ; $ baseUrl = $ baseUrl ? : '' ; $ neighbours = $ neighbours ? : 3 ; return new Pagination ( $ currentPage , $ total , $ perPage , $ baseUrl , $ neighbours ) ; }
2375	public static function insertTagToSrc ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]*)\{\{file::([^"\}]+)\}\}")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 5 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByUuid ( $ paths [ $ i + 4 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ file -> path . '"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . $ paths [ $ i + 4 ] . '"' ; } } return $ return ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
270	public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
4973	private function prepareHydrateData ( array $ data ) { $ items = $ data [ 'items' ] ; $ tree = [ '__root__' => array_shift ( $ items ) ] ; foreach ( $ items as $ item ) { $ parent = substr ( $ item [ 'current' ] , 0 , strrpos ( $ item [ 'current' ] , '-' ) ) ; $ tree [ $ parent ] [ ] = $ item ; } $ this -> hydrateData = $ tree ; }
9568	protected function invokeConfigurator ( $ configurator ) { if ( is_callable ( $ configurator ) ) { call_user_func ( $ configurator , $ this ) ; return ; } if ( is_string ( $ configurator ) ) { $ configurator = $ this -> container -> resolve ( $ configurator ) ; } if ( $ configurator instanceof ConfiguratorInterface ) { $ configurator -> configure ( ) ; } else { throw new \ UnexpectedValueException ( 'Invalid configurator' ) ; } }
6571	private function getIdPath ( string $ id ) : string { if ( ! preg_match ( "/^[a-z0-9]$/ui" , $ id ) ) { throw new HandlerException ( sprintf ( "The session id %s is invalid" , $ id ) , $ this ) ; } return $ this -> savePath . "/$id.session" ; }
6022	public function request ( $ endPoint , $ httpVerb = 'GET' , $ data = array ( ) ) { if ( ! $ this -> apiKey ) { throw new \ Exception ( 'MailChimp API Key must be set before making request!' ) ; } $ endPoint = ltrim ( $ endPoint , '/' ) ; $ httpVerb = strtoupper ( $ httpVerb ) ; $ requestUrl = $ this -> apiUrl . $ endPoint ; return $ this -> curlRequest ( $ requestUrl , $ httpVerb , $ data ) ; }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
9388	public function prefix ( $ prefix = '' , $ namespace = '' ) { $ namespace === '' && $ namespace = ( string ) $ this -> namespace ; $ prefix && $ prefix [ 0 ] !== '/' && $ prefix = '/' . $ prefix ; $ namespace = str_replace ( '\\\\' , '\\' , $ namespace . '\\' ) ; $ this -> prefix = ( string ) $ prefix ; $ this -> namespace = ltrim ( $ namespace , '\\' ) ; return $ this ; }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
1922	public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
122	private function createAuthFromUrl ( ) { $ uri = parse_url ( $ this -> url ) ; if ( empty ( $ uri [ 'user' ] ) ) { return $ this -> hasAuth = false ; } $ this -> credentials [ 'username' ] = $ uri [ 'user' ] ; if ( ! empty ( $ uri [ 'pass' ] ) ) { $ this -> credentials [ 'password' ] = $ uri [ 'pass' ] ; } return $ this -> hasAuth = true ; }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
9566	public function addAfterHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'after' ] ) ) { $ this -> options [ 'after' ] = [ ] ; } $ this -> options [ 'after' ] [ ] = $ hook ; }
1244	public static function memoize ( callable $ provider ) { return function ( ) use ( $ provider ) { static $ result ; static $ isConstant ; if ( $ isConstant ) { return $ result ; } $ isConstant = true ; return $ result = $ provider ( ) ; } ; }
6306	private function register ( array $ providers , array $ values ) { foreach ( $ providers as $ provider ) { $ factories = $ provider -> getFactories ( ) ; foreach ( $ factories as $ key => $ callable ) { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } foreach ( $ providers as $ provider ) { $ extensions = $ provider -> getExtensions ( ) ; foreach ( $ extensions as $ key => $ callable ) { if ( isset ( $ this -> keys [ $ key ] ) ) { $ this [ $ key ] = $ this -> extend ( $ key , function ( $ previous , ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c , $ previous ) ; } ) ; } else { $ this [ $ key ] = function ( ContainerInterface $ c ) use ( $ callable ) { return call_user_func ( $ callable , $ c ) ; } ; } } } foreach ( $ values as $ key => $ value ) { $ this [ $ key ] = $ value ; } }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
6573	protected static function examine ( $ part , array & $ array , $ path_relative , $ allow_escape = false ) { if ( $ part === '.' ) { return ; } if ( $ part !== '..' ) { $ array [ ] = $ part ; return ; } $ last = end ( $ array ) ; if ( $ last === '..' ) { $ array [ ] = $ part ; return ; } if ( $ last !== false ) { array_pop ( $ array ) ; return ; } if ( ! $ path_relative ) { return ; } if ( ! $ allow_escape ) throw new \ UnexpectedValueException ( 'Attempt to traverse outside the root directory.' ) ; $ array [ ] = $ part ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
7381	public function route ( bool $ dropIndex = false ) : string { if ( $ dropIndex ) { if ( 'index' == $ this -> route ) { return '' ; } } return $ this -> route ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
7523	function parse_tag_default ( ) { if ( $ this -> status [ 'closing_tag' ] ) { $ this -> status [ 'attributes' ] = array ( ) ; $ this -> next_no_whitespace ( ) ; } else { if ( ! $ this -> parse_attributes ( ) ) { return false ; } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { if ( $ this -> token === self :: TOK_SLASH_FORWARD ) { $ this -> status [ 'self_close' ] = true ; $ this -> next ( ) ; } elseif ( ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '?' ) && ( $ this -> doc [ $ this -> pos ] === '?' ) ) || ( ( $ this -> status [ 'tag_name' ] [ 0 ] === '%' ) && ( $ this -> doc [ $ this -> pos ] === '%' ) ) ) { $ this -> status [ 'self_close' ] = true ; $ this -> pos ++ ; if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) && ( ! is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) ) { $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ; } else { $ this -> token = self :: TOK_UNKNOWN ; } } } if ( $ this -> token !== self :: TOK_TAG_CLOSE ) { $ this -> addError ( 'Expected ">", but found "' . $ this -> getTokenString ( ) . '"' ) ; if ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> addError ( 'No ">" tag found for "' . $ this -> status [ 'tag_name' ] . '" tag' ) ; return false ; } } return true ; }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
10020	public function removeCellXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellXfCollection ) - 1 ) { throw new Exception ( 'CellXf index is out of bounds.' ) ; } array_splice ( $ this -> cellXfCollection , $ pIndex , 1 ) ; foreach ( $ this -> workSheetCollection as $ worksheet ) { foreach ( $ worksheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ worksheet -> getCell ( $ coordinate ) ; $ xfIndex = $ cell -> getXfIndex ( ) ; if ( $ xfIndex > $ pIndex ) { $ cell -> setXfIndex ( $ xfIndex - 1 ) ; } elseif ( $ xfIndex == $ pIndex ) { $ cell -> setXfIndex ( 0 ) ; } } } }
11894	public function encrypt ( $ data ) { if ( $ this -> iv === null ) { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ dataEncrypted = mcrypt_encrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return bin2hex ( $ dataEncrypted ) ; }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
2648	public function uploadVcl ( $ version , $ vcl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/vcl' ; $ result = $ this -> _fetch ( $ url , 'POST' , $ vcl ) ; return $ result ; }
1178	protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; }
10923	public function render ( ) { $ output = [ ] ; if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; } if ( count ( $ this -> columns ) > 0 ) { $ line = [ ] ; $ line [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ this -> columns as $ index => $ column ) { $ title = $ column ; if ( isset ( $ this -> headers [ $ index ] ) ) { $ title = $ this -> headers [ $ index ] ; } $ line [ ] = $ this -> renderCell ( $ columnNumber , $ title , ' ' , 'info' ) ; $ line [ ] = $ this -> charVertical ; $ columnNumber ++ ; } $ output [ ] = implode ( '' , $ line ) ; } if ( count ( $ this -> rows ) > 0 ) { $ output [ ] = $ this -> renderLine ( ) ; foreach ( $ this -> rows as $ row ) { $ output [ ] = $ this -> renderRow ( $ row ) ; } $ output [ ] = $ this -> renderLine ( ) ; } return implode ( "\n" , $ output ) ; }
6315	public function setUpdateAction ( $ updateAction ) { $ updateAction = strtoupper ( $ updateAction ) ; if ( ! in_array ( $ updateAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ updateAction ) ) ; } $ this -> updateAction = $ updateAction ; }
3069	protected function endItemTimer ( $ timestamp = null ) { if ( $ this -> getRequestParameter ( 'itemDuration' ) ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemDuration = $ this -> getRequestParameter ( 'itemDuration' ) ; return $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ timestamp ) ; } return false ; }
5425	public function isExpected ( $ test , $ exception ) { if ( $ this -> expected ) { return $ test -> assert ( $ this -> expected , $ exception , $ this -> message ) ; } foreach ( $ this -> ignored as $ ignored ) { if ( $ ignored -> test ( $ exception ) ) { return true ; } } return false ; }
5146	public function accessInboxFor ( $ address ) { $ inbox = array ( ) ; $ addressPlusDelimiters = '<' . $ address . '>' ; foreach ( $ this -> fetchedEmails as & $ email ) { $ email -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; if ( ! isset ( $ email -> Headers -> bcc ) ) { if ( strpos ( $ email -> Headers -> to , $ addressPlusDelimiters ) || strpos ( $ email -> Headers -> cc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } else if ( strpos ( $ email -> Headers -> bcc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } $ this -> setCurrentInbox ( $ inbox ) ; }
3894	private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; }
11379	public function putAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)\/(\w+)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language , $ oldName ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ newName = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> modifyTextContainer ( $ oldName , $ newName , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
8875	public function getMimeType ( $ attachment ) { $ attachment = explode ( '.' , basename ( $ attachment ) ) ; if ( ! isset ( $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ) ) { pines_error ( 'MIME Type not found.' ) ; return null ; } return $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ; }
699	public function actionApp ( $ app , $ repo = null ) { $ base = \ dirname ( \ dirname ( __DIR__ ) ) ; $ appDir = "$base/apps/$app" ; if ( ! file_exists ( $ appDir ) ) { if ( empty ( $ repo ) ) { if ( isset ( $ this -> apps [ $ app ] ) ) { $ repo = $ this -> apps [ $ app ] ; if ( $ this -> useHttp ) { $ repo = str_replace ( 'git@github.com:' , 'https://github.com/' , $ repo ) ; } } else { $ this -> stderr ( "Repo argument is required for app '$app'.\n" , Console :: FG_RED ) ; return 1 ; } } $ this -> stdout ( "cloning application repo '$app' from '$repo'...\n" , Console :: BOLD ) ; passthru ( 'git clone ' . escapeshellarg ( $ repo ) . ' ' . $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; } $ this -> stdout ( "cleaning up application '$app' vendor directory...\n" , Console :: BOLD ) ; $ this -> cleanupVendorDir ( $ appDir ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "updating composer for app '$app'...\n" , Console :: BOLD ) ; chdir ( $ appDir ) ; $ command = 'composer update --prefer-dist' ; if ( $ this -> composerNoProgress ) { $ command .= ' --no-progress' ; } passthru ( $ command ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; $ this -> stdout ( "linking framework and extensions to '$app' app vendor dir...\n" , Console :: BOLD ) ; $ this -> linkFrameworkAndExtensions ( $ appDir , $ base ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; return 0 ; }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
558	protected function buildBlockCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ this -> buildCondition ( $ condition ) , ] ; }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
6049	public function setProperties ( array $ properties ) { $ this -> properties = [ ] ; foreach ( $ properties as $ item ) { $ this -> addPropertyResponse ( $ item ) ; } return $ this ; }
11300	protected function _fetchData ( $ name ) { $ gateway = new \ Cora \ Gateway ( $ this -> getDbAdaptor ( ) , $ this -> getTableName ( ) , $ this -> getPrimaryKey ( ) ) ; return $ gateway -> fetchData ( $ this -> getFieldName ( $ name ) , $ this ) ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
931	public function clear ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> content = '' ; $ this -> id = null ; $ this -> isArray = false ; }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
241	public function init ( ) { parent :: init ( ) ; if ( $ this -> model === null ) { throw new InvalidConfigException ( 'Please specify the "model" property.' ) ; } if ( $ this -> formatter === null ) { $ this -> formatter = Yii :: $ app -> getFormatter ( ) ; } elseif ( is_array ( $ this -> formatter ) ) { $ this -> formatter = Yii :: createObject ( $ this -> formatter ) ; } if ( ! $ this -> formatter instanceof Formatter ) { throw new InvalidConfigException ( 'The "formatter" property must be either a Format object or a configuration array.' ) ; } $ this -> normalizeAttributes ( ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } }
8683	public static function from ( $ iterable ) { if ( is_array ( $ iterable ) ) { return $ iterable ; } if ( $ iterable instanceof ImmutableBag ) { return $ iterable -> toArray ( ) ; } if ( $ iterable instanceof Traversable ) { return iterator_to_array ( $ iterable ) ; } if ( $ iterable === null ) { return [ ] ; } if ( $ iterable instanceof \ stdClass ) { return ( array ) $ iterable ; } Assert :: nullOrIsIterable ( $ iterable ) ; }
5433	public function isAbstractMethodInParents ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ parent = $ interface -> getParentClass ( ) ; while ( $ parent ) { if ( ! $ parent -> hasMethod ( $ name ) ) { return false ; } if ( $ parent -> getMethod ( $ name ) -> isAbstract ( ) ) { return true ; } $ parent = $ parent -> getParentClass ( ) ; } return false ; }
7392	public function serialize ( ) : string { $ toSerialize = [ '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , ] ; foreach ( $ this -> _publicNames as $ k ) { $ toSerialize [ $ k ] = $ this -> { $ k } ; } return serialize ( $ toSerialize ) ; }
3349	private function __getQueryString ( $ queryAr = array ( ) , $ prefixIfNotEmpty = '' ) { $ queryAr = array_filter ( $ queryAr ) ; array_walk ( $ queryAr , function ( & $ val , $ key ) { $ val = urlencode ( $ key ) . '=' . urlencode ( $ val ) ; } ) ; return $ queryAr ? $ prefixIfNotEmpty . join ( '&' , $ queryAr ) : '' ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
6798	public function install ( $ country = 'US' , $ currency = 'USD' ) { $ this -> installCountries ( $ country ) ; $ this -> installCurrencies ( $ currency ) ; $ this -> installTaxes ( $ country ) ; $ this -> installTaxGroups ( $ country ) ; $ this -> installTaxRules ( $ country ) ; $ this -> installCustomerGroups ( ) ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
10550	public function dispatch ( ) { $ response = null ; try { $ this -> resolveApp ( ) ; $ this -> getTemplate ( ) ; $ this -> request -> startSession ( $ this -> vhost -> getHost ( ) , $ this -> config ) ; FlashMessage :: setStorage ( $ this -> request -> session ) ; $ this -> setupLocale ( ) ; if ( $ this -> route === null ) throw new HTTPError ( 404 , 'Could not resolve ' . $ this -> url ) ; $ app = new AppRunner ( $ this -> app , $ this -> arguments ) ; $ app -> setVariables ( $ this -> variables ) ; $ app -> setVariable ( 'dispatcher' , $ this ) ; $ app -> execute ( ) ; } catch ( Throwable $ e ) { if ( ! ( $ e instanceof Response ) ) $ e = new HTTPError ( 500 , "Exception of type " . get_class ( $ e ) . " thrown: " . $ e -> getMessage ( ) , null , $ e ) ; if ( $ e instanceof HTTPError ) $ this -> prepareErrorResponse ( $ e ) ; $ response = $ e ; } return $ response ; }
8737	public function insertGetId ( array $ values , $ sequence = null ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ id = $ this -> query -> insertGetId ( $ values , $ sequence ) ) { if ( $ this -> insertI18n ( $ i18nValues , $ id ) ) { return $ id ; } } return false ; }
10644	public function getRelativePath ( string $ path ) : string { $ from = $ this -> path ; $ fromParts = explode ( "/" , $ from ) ; $ toParts = explode ( "/" , $ path ) ; $ max = max ( count ( $ fromParts ) , count ( $ toParts ) ) ; for ( $ i = 0 ; $ i < $ max ; $ i ++ ) { if ( ! isset ( $ fromParts [ $ i ] ) || ! isset ( $ toParts [ $ i ] ) || $ fromParts [ $ i ] !== $ toParts [ $ i ] ) { break ; } } $ len = count ( $ fromParts ) - $ i - 1 ; $ path = array_slice ( $ toParts , $ i ) ; if ( $ len < 0 ) { return implode ( "/" , $ path ) ; } return str_repeat ( "../" , $ len ) . implode ( "/" , $ path ) ; }
626	public function cache ( $ duration = null , $ dependency = null ) { $ this -> queryCacheDuration = $ duration === null ? $ this -> db -> queryCacheDuration : $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; }
535	protected function fixDocBlockIndentation ( & $ lines ) { $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; $ indent = '' ; foreach ( $ lines as $ i => $ line ) { if ( preg_match ( '~^(\s*)/\*\*$~' , $ line , $ matches ) ) { $ docBlock = true ; $ indent = $ matches [ 1 ] ; } elseif ( preg_match ( '~^(\s*)\*+/~' , $ line ) ) { if ( $ docBlock ) { $ lines [ $ i ] = $ indent . ' */' ; } $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; } elseif ( $ docBlock ) { $ line = ltrim ( $ line ) ; if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === '*' ) { $ line = substr ( $ line , 1 ) ; } if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === ' ' ) { $ line = substr ( $ line , 1 ) ; } $ docLine = str_replace ( "\t" , ' ' , rtrim ( $ line ) ) ; if ( empty ( $ docLine ) ) { $ listIndent = '' ; } elseif ( $ docLine [ 0 ] === '@' ) { $ listIndent = '' ; $ codeBlock = false ; $ tag = true ; $ docLine = preg_replace ( '/\s+/' , ' ' , $ docLine ) ; $ docLine = $ this -> fixParamTypes ( $ docLine ) ; } elseif ( preg_match ( '/^(~~~|```)/' , $ docLine ) ) { $ codeBlock = ! $ codeBlock ; $ listIndent = '' ; } elseif ( preg_match ( '/^(\s*)([0-9]+\.|-|\*|\+) /' , $ docLine , $ matches ) ) { $ listIndent = str_repeat ( ' ' , \ strlen ( $ matches [ 0 ] ) ) ; $ tag = false ; $ lines [ $ i ] = $ indent . ' * ' . $ docLine ; continue ; } if ( $ codeBlock ) { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . $ docLine ) ; } else { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . ( empty ( $ listIndent ) && ! $ tag ? $ docLine : ( $ listIndent . ltrim ( $ docLine ) ) ) ) ; } } } }
11748	public function page ( ) { if ( is_null ( $ this -> page ) ) { $ this -> page = new Page ( $ this -> accessToken ) ; } return $ this -> page ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
4936	protected function getEntities ( $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ resource = $ args -> getDocument ( ) ; $ repositoryName = $ this -> getRepositoryName ( ) ; $ resourceId = $ resource -> getPermissionsResourceId ( ) ; $ repository = $ dm -> getRepository ( $ repositoryName ) ; $ criteria = array ( 'permissions.assigned.' . $ resourceId => array ( '$exists' => true ) ) ; $ entities = $ repository -> findBy ( $ criteria ) ; return $ entities ; }
6585	protected function perform ( callable $ callback , ... $ params ) { $ result = $ callback ( $ this -> curl , ... $ params ) ; if ( curl_errno ( $ this -> curl ) !== CURLE_OK ) throw new CurlException ( $ this -> curl ) ; if ( $ result === false ) throw new CurlException ( "Unable to perform $callback - unknown error." ) ; return $ result ; }
7710	function UpdateParent ( $ Cascading = false ) { if ( $ this -> Parent ) { $ this -> Parent -> ReplaceSrc ( $ this -> Txt ) ; if ( $ Cascading ) $ this -> Parent -> UpdateParent ( $ Cascading ) ; } }
10295	public static function dayStringToNumber ( $ day ) { $ strippedDayValue = ( str_replace ( self :: $ numberSuffixes , '' , $ day ) ) ; if ( is_numeric ( $ strippedDayValue ) ) { return ( int ) $ strippedDayValue ; } return $ day ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
10933	protected function resolveParams ( UriInfo $ info , array $ params ) { $ uri = $ info -> getUri ( ) ; if ( false === strpos ( $ uri , '{' ) ) { return $ info ; } $ ctx = NULL ; $ result = '' ; foreach ( preg_split ( "'(\\{[^\\}]+\\})'" , $ uri , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) as $ part ) { if ( '{' != substr ( $ part , 0 , 1 ) ) { $ result .= $ part ; continue ; } $ placeholder = substr ( $ part , 1 , - 1 ) ; if ( '*' == substr ( $ placeholder , - 1 ) ) { $ placeholder = substr ( $ placeholder , 0 , - 1 ) ; $ multi = true ; } else { $ multi = false ; } switch ( substr ( $ placeholder , 0 , 1 ) ) { case '.' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '.' ; $ join = $ multi ? '.' : ',' ; break ; case '/' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '/' ; $ join = $ multi ? '/' : ',' ; break ; default : $ prefix = '' ; $ join = ',' ; } if ( false === strpos ( $ placeholder , '.' ) ) { $ value = array_key_exists ( $ placeholder , $ params ) ? $ params [ $ placeholder ] : $ this ; } else { if ( $ ctx === NULL ) { $ ctx = $ this -> factory -> createContext ( $ params ) ; } $ value = $ ctx -> resolveValue ( explode ( '.' , $ placeholder ) , $ this ) ; } if ( $ value === $ this ) { $ result .= $ part ; } elseif ( is_array ( $ value ) || $ value instanceof \ Traversable ) { $ i = 0 ; foreach ( $ value as $ val ) { $ result .= ( ( $ i ++ == 0 ) ? $ prefix : $ join ) . Uri :: encode ( $ val , true ) ; } } else { $ result .= $ prefix . Uri :: encode ( $ value , true ) ; } } return new UriInfo ( $ result , $ info -> getRouteName ( ) , $ info -> getMethods ( ) , $ info -> getHandler ( ) ) ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
4741	private function createProfilerProbes ( $ name , ContainerBuilder $ container ) { $ key = sprintf ( "socloz_monitoring.profiler.probe.definition.%s" , $ name ) ; if ( $ container -> hasParameter ( $ key ) ) { $ definition = $ container -> getParameter ( $ key ) ; return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS | Probe :: TRACKER_TIMING , $ definition , $ container ) ) ; } else { return array ( $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_CALLS , $ container -> getParameter ( $ key . '.calls' ) , $ container ) , $ this -> createProbeDefinition ( $ name , Probe :: TRACKER_TIMING , $ container -> getParameter ( $ key . '.timing' ) , $ container ) , ) ; } }
9334	public function deg ( ) { if ( $ this -> original -> type == self :: TYPE_DEG ) { return $ this -> original -> value ; } return rad2deg ( $ this -> float_rad ) ; }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
6238	public function write ( string $ content , bool $ append = false , int $ mode = LOCK_EX ) : self { $ this -> checkFileWritePermissions ( ) ; if ( ! $ this -> storage -> writeFile ( $ content , $ append , $ mode ) ) { throw new AccessDeniedException ( 'unable to write file-content' , 403 ) ; } return $ this ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
575	protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
10639	protected function processUrls ( Request $ request ) { $ externalRawMediaUrls = array ( ) ; if ( $ request -> get ( 'urls' ) ) { foreach ( $ request -> get ( 'urls' ) as $ url ) { $ externalRawMediaUrls [ ] = $ url ; } } return $ externalRawMediaUrls ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
3653	public static function render ( $ strTemplate , $ strOutputFormat , $ arrTplData , $ blnFailIfNotFound = false ) { $ objTemplate = new self ( $ strTemplate ) ; $ objTemplate -> setData ( $ arrTplData ) ; return $ objTemplate -> parse ( $ strOutputFormat , $ blnFailIfNotFound ) ; }
11295	public function getAttributeValue ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } return null ; }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
1441	protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; }
5047	public function getResult ( $ paginatorAlias = null , $ formAlias = null ) { if ( null === $ paginatorAlias ) { $ paginatorAlias = isset ( $ this -> stack [ 'paginator' ] [ 'as' ] ) ? $ this -> stack [ 'paginator' ] [ 'as' ] : 'paginator' ; } if ( null === $ formAlias ) { $ formAlias = isset ( $ this -> stack [ 'form' ] [ 'as' ] ) ? $ this -> stack [ 'form' ] [ 'as' ] : 'searchform' ; } $ result = [ ] ; $ controller = $ this -> getController ( ) ; $ request = $ controller -> getRequest ( ) ; $ this -> setParameters ( $ request -> getQuery ( ) ) ; if ( isset ( $ this -> stack [ 'params' ] ) ) { $ this -> callPlugin ( 'paginationParams' , $ this -> stack [ 'params' ] ) ; } if ( isset ( $ this -> stack [ 'form' ] ) ) { $ form = $ this -> callPlugin ( 'searchform' , $ this -> stack [ 'form' ] ) ; if ( ! $ request -> isXmlHttpRequest ( ) ) { $ result [ $ formAlias ] = $ form ; } } if ( isset ( $ this -> stack [ 'paginator' ] ) ) { $ result [ $ paginatorAlias ] = $ this -> callPlugin ( 'paginator' , $ this -> stack [ 'paginator' ] ) ; } return $ result ; }
6301	protected function getMain ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.main' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> main ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } $ nav = $ this -> active ( $ this -> main [ $ name ] ) ; return $ this -> process ( $ nav ) ; }
2263	public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strDatabase ) ; } $ this -> arrCache [ $ strDatabase ] = $ this -> resConnection -> getSchemaManager ( ) -> listTableNames ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strOldDatabase ) ; } } return $ this -> arrCache [ $ strDatabase ] ; }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
7698	function MsPowerpoint_SlideIsIt ( $ FileName ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) { if ( $ FileName == $ s [ 'file' ] ) return true ; } return false ; }
7223	protected function clearParcel ( Shipment \ ShipmentParcelInterface $ parcel ) { if ( empty ( $ parcel -> getTrackingNumber ( ) ) && ! $ parcel -> hasLabels ( ) ) { return false ; } $ parcel -> setTrackingNumber ( null ) ; foreach ( $ parcel -> getLabels ( ) as $ label ) { $ parcel -> removeLabel ( $ label ) ; } return true ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
7715	static function FindStartTagByPrefix ( & $ Txt , $ TagPrefix , $ PosBeg , $ Forward = true ) { $ x = '<' . $ TagPrefix ; $ xl = strlen ( $ x ) ; if ( $ Forward ) { $ PosBeg = strpos ( $ Txt , $ x , $ PosBeg ) ; } else { $ PosBeg = strrpos ( substr ( $ Txt , 0 , $ PosBeg + 2 ) , $ x ) ; } if ( $ PosBeg === false ) return false ; $ Tag = $ TagPrefix ; $ p = $ PosBeg + $ xl ; do { $ z = substr ( $ Txt , $ p , 1 ) ; if ( ( $ z !== ' ' ) && ( $ z !== "\r" ) && ( $ z !== "\n" ) && ( $ z !== '>' ) && ( $ z !== '/' ) ) { $ Tag .= $ z ; $ p ++ ; } else { $ p = false ; } } while ( $ p !== false ) ; return new clsTbsXmlLoc ( $ Txt , $ Tag , $ PosBeg ) ; }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
7671	function TbsInitArchive ( ) { $ TBS = & $ this -> TBS ; $ TBS -> OtbsCurrFile = false ; $ this -> TbsStoreLst = array ( ) ; $ this -> TbsCurrIdx = false ; $ this -> TbsNoField = array ( ) ; $ this -> IdxToCheck = array ( ) ; $ this -> PrevVals = array ( ) ; $ this -> ExtEquiv = false ; $ this -> ExtType = false ; $ this -> OtbsSheetSlidesDelete = array ( ) ; $ this -> OtbsSheetSlidesVisible = array ( ) ; $ this -> OpenDocCharts = false ; $ this -> OpenDocManif = false ; $ this -> OpenDoc_SheetSlides = false ; $ this -> OpenDoc_Styles = false ; $ this -> OpenXmlRid = false ; $ this -> OpenXmlCTypes = false ; $ this -> OpenXmlCharts = false ; $ this -> OpenXmlSharedStr = false ; $ this -> OpenXmlSlideLst = false ; $ this -> OpenXmlSlideMasterLst = false ; $ this -> MsExcel_Sheets = false ; $ this -> MsWord_HeaderFooter = false ; $ this -> Ext_PrepareInfo ( ) ; }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
11877	public static function getDumpQueryResult ( $ var ) { $ header = true ; $ dump = '<table cellpadding=5 cellspacing=0>' ; $ i = 1 ; foreach ( $ var as $ ligne ) { if ( $ header ) { $ dump .= '<tr>' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { $ dump .= '<th>' . $ key . '</th>' ; } } $ dump .= '</tr>' ; $ header = false ; } $ class = '' ; if ( ! ( $ i % 2 ) ) { $ class = 'highlight' ; } $ dump .= '<tr class="' . $ class . '">' ; foreach ( $ ligne as $ key => $ value ) { if ( ! is_numeric ( $ key ) ) { if ( $ value != '' ) { $ dump .= '<td>' . $ value . '</td>' ; } else { $ dump .= '<td>&nbsp;</td>' ; } } } $ dump .= '</tr>' ; $ i ++ ; } $ dump .= '</table>' ; return $ dump ; }
5309	protected function getPathFromCircle ( SimpleXMLElement $ circle ) { $ mult = 0.55228475 ; return 'M' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'Z' ; }
9968	public function setHyperlink ( $ pCellCoordinate , Hyperlink $ pHyperlink = null ) { if ( $ pHyperlink === null ) { unset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ; } else { $ this -> hyperlinkCollection [ $ pCellCoordinate ] = $ pHyperlink ; } return $ this ; }
777	private function defaultTimeTypeMap ( ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime' , Schema :: TYPE_TIMESTAMP => 'timestamp' , Schema :: TYPE_TIME => 'time' , ] ; if ( $ this -> supportsFractionalSeconds ( ) ) { $ map = [ Schema :: TYPE_DATETIME => 'datetime(0)' , Schema :: TYPE_TIMESTAMP => 'timestamp(0)' , Schema :: TYPE_TIME => 'time(0)' , ] ; } return $ map ; }
7662	function CreateBody ( ) { $ result = "" ; $ this -> SetWordWrap ( ) ; switch ( $ this -> message_type ) { case "alt" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/plain" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "text/html" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 1 ] ) ; break ; case "plain" : $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; break ; case "attachments" : $ result .= $ this -> GetBoundary ( $ this -> boundary [ 1 ] , "" , "" , "" ) ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE ; $ result .= $ this -> AttachAll ( ) ; break ; case "alt_attachments" : $ result .= sprintf ( "--%s%s" , $ this -> boundary [ 1 ] , $ this -> LE ) ; $ result .= sprintf ( "Content-Type: %s;%s" . "\tboundary=\"%s\"%s" , "multipart/alternative" , $ this -> LE , $ this -> boundary [ 2 ] , $ this -> LE . $ this -> LE ) ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/plain" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> AltBody , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> GetBoundary ( $ this -> boundary [ 2 ] , "" , "text/html" , "" ) . $ this -> LE ; $ result .= $ this -> EncodeString ( $ this -> Body , $ this -> Encoding ) ; $ result .= $ this -> LE . $ this -> LE ; $ result .= $ this -> EndBoundary ( $ this -> boundary [ 2 ] ) ; $ result .= $ this -> AttachAll ( ) ; break ; } if ( $ this -> IsError ( ) ) $ result = "" ; return $ result ; }
6290	public function get ( $ theme = null ) { if ( is_null ( $ theme ) ) { return $ this -> themes [ $ this -> activeTheme ] ; } return $ this -> themes [ $ theme ] ; }
5032	public function getLoadedPage ( $ default = null ) { if ( ! $ this -> loadedPage ) { if ( is_callable ( $ default ) ) { $ page = call_user_func ( $ default , $ this ) ; if ( $ page !== null ) { $ this -> setLoadedPage ( $ page ) ; } } if ( ! $ this -> loadedPage ) { throw new NotFoundHttpException ( "There is no page currently loaded, but it was expected" ) ; } } return $ this -> loadedPage ; }
950	public function createHmac ( array $ opts ) { $ data = $ opts [ 'data' ] ; $ raw = $ opts [ 'raw' ] ?? false ; $ buildQuery = $ opts [ 'buildQuery' ] ?? false ; $ buildQueryWithJoin = $ opts [ 'buildQueryWithJoin' ] ?? false ; $ encode = $ opts [ 'encode' ] ?? false ; $ secret = $ opts [ 'secret' ] ?? Config :: get ( 'shopify-app.api_secret' ) ; if ( $ buildQuery ) { ksort ( $ data ) ; $ queryCompiled = [ ] ; foreach ( $ data as $ key => $ value ) { $ queryCompiled [ ] = "{$key}=" . ( is_array ( $ value ) ? implode ( $ value , ',' ) : $ value ) ; } $ data = implode ( $ queryCompiled , ( $ buildQueryWithJoin ? '&' : '' ) ) ; } $ hmac = hash_hmac ( 'sha256' , $ data , $ secret , $ raw ) ; return $ encode ? base64_encode ( $ hmac ) : $ hmac ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
4024	public function handle ( BuildDataDefinitionEvent $ event ) { if ( 'tl_metamodel_dca_sortgroup' !== $ event -> getContainer ( ) -> getName ( ) ) { return ; } foreach ( $ event -> getContainer ( ) -> getPalettesDefinition ( ) -> getPalettes ( ) as $ palette ) { foreach ( $ palette -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) != 'rendergrouptype' ) { continue ; } $ this -> addCondition ( $ property , new PropertyConditionChain ( array ( new InputScreenRenderModeIs ( 'flat' , $ this -> connection ) , new InputScreenRenderModeIs ( 'parented' , $ this -> connection ) , ) , PropertyConditionChain :: OR_CONJUNCTION ) ) ; } } }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
1491	public static function camelize ( $ data ) { return collect ( $ data ) -> mapWithKeys ( function ( $ value , $ key ) { $ key = Str :: camelize ( $ key ) ; if ( is_array ( $ value ) ) { return [ $ key => static :: camelize ( $ value ) ] ; } return [ $ key => $ value ] ; } ) -> all ( ) ; }
5239	private function paramType ( \ ReflectionMethod $ method , \ ReflectionParameter $ param ) { $ methodAnnotations = annotationsOf ( $ method ) ; $ paramAnnotations = annotationsOf ( $ param ) ; $ paramClass = $ param -> getClass ( ) ; if ( null !== $ paramClass ) { if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return $ paramClass -> getName ( ) ; } if ( $ methodAnnotations -> contain ( 'List' ) || $ paramAnnotations -> contain ( 'List' ) ) { return ListBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Map' ) || $ paramAnnotations -> contain ( 'Map' ) ) { return MapBinding :: TYPE ; } if ( $ methodAnnotations -> contain ( 'Property' ) || $ paramAnnotations -> contain ( 'Property' ) ) { return PropertyBinding :: TYPE ; } return ConstantBinding :: TYPE ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
6895	protected function compareStockUnitByEda ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasEda = null !== $ u1 -> getEstimatedDateOfArrival ( ) ; $ u2HasEda = null !== $ u2 -> getEstimatedDateOfArrival ( ) ; if ( ! $ u1HasEda && $ u2HasEda ) { return 1 ; } if ( $ u1HasEda && ! $ u2HasEda ) { return - 1 ; } if ( $ u1 -> getEstimatedDateOfArrival ( ) != $ u2 -> getEstimatedDateOfArrival ( ) ) { return $ u1 -> getEstimatedDateOfArrival ( ) > $ u2 -> getEstimatedDateOfArrival ( ) ? 1 : - 1 ; } return 0 ; }
3169	protected function getItemHrefIndexFile ( QtiRunnerServiceContext $ context , $ itemIdentifier ) { $ compilationDirectory = $ context -> getCompilationDirectory ( ) [ 'private' ] ; return $ compilationDirectory -> getFile ( \ taoQtiTest_models_classes_QtiTestCompiler :: buildHrefIndexPath ( $ itemIdentifier ) ) ; }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
1225	private function buildQueryParameters ( array $ paramValues ) { if ( empty ( $ paramValues ) ) { return '' ; } $ query = [ ] ; foreach ( $ paramValues as $ param => $ value ) { if ( is_array ( $ value ) ) { $ value = join ( ',' , $ value ) ; } elseif ( is_bool ( $ value ) ) { $ value = $ value ? 'true' : 'false' ; } elseif ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } $ query [ ] = $ param . '=' . urlencode ( $ value ) ; } return '?' . join ( '&' , $ query ) ; }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
1887	protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
4923	public function removeTypeFromRegion ( $ type , $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { array_walk ( $ this -> matrix [ $ region ] , function ( $ value , $ idx , $ matrix ) use ( $ type , $ region ) { $ class = explode ( '\\' , $ value ) ; $ className = array_pop ( $ class ) ; if ( $ className === $ type ) { unset ( $ matrix [ $ region ] [ $ idx ] ) ; } } , $ this -> matrix ) ; } return $ this ; }
11040	function leaf_path_walk ( $ elements , $ rank , $ ptype , & $ i , $ cvalue ) { if ( count ( $ elements ) == 1 ) { $ elt [ $ ptype . ':' . $ i . ':' . $ elements [ 0 ] . ':' . $ cvalue ] = '' ; } else { $ element1 = array_shift ( $ elements ) ; $ elt [ _ETS_TEMPLATE . ':' . $ i . '.' . $ rank . ':' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , $ rank + 1 , $ ptype , $ i , $ cvalue ) ; } return $ elt ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
945	private function setOption ( $ name , $ value ) { if ( ! \ array_key_exists ( $ name , $ this -> options ) ) { throw new InvalidConfigurationException ( sprintf ( 'Unknown option name: "%s".' , $ name ) ) ; } $ this -> options [ $ name ] = $ value ; }
7007	private function format_j ( & $ str ) { if ( strstr ( $ str , '%j' ) ) $ str = str_replace ( '%j' , sprintf ( '%01d' , $ this -> day ) , $ str ) ; }
6154	public function setValue ( $ value ) { $ definition = $ this -> propertyType -> getDefinition ( ) ; if ( isset ( $ definition [ 'hierarchical' ] ) && $ definition [ 'hierarchical' ] ) { $ this -> value = [ ] ; foreach ( $ value as $ v ) { foreach ( $ v [ 'value' ] as $ itemValue ) { $ this -> value [ ] = $ this -> convertValue ( $ itemValue [ 'value' ] ) ; } } } elseif ( ! empty ( $ definition [ 'array' ] ) ) { if ( empty ( $ definition [ 'multiplechoice' ] ) && isset ( $ definition [ 'options' ] ) && is_array ( $ definition [ 'options' ] ) ) { $ this -> value = $ this -> convertValue ( current ( $ value ) [ 'value' ] ) ; } else { $ this -> value = [ ] ; foreach ( $ value as $ v ) { $ this -> value [ ] = $ this -> convertValue ( $ v [ 'value' ] ) ; } } } else { $ this -> value = $ this -> convertValue ( $ value ) ; } return $ this ; }
1842	public function process ( ContainerBuilder $ container ) : void { if ( ! $ container -> has ( 'contao.fragment.registry' ) ) { return ; } $ this -> registerFragments ( $ container , ContentElementReference :: TAG_NAME ) ; $ this -> registerFragments ( $ container , FrontendModuleReference :: TAG_NAME ) ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
7189	private function copyAdjustment ( Model \ AdjustmentInterface $ source , Model \ AdjustmentInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'type' , 'mode' , 'amount' , 'immutable' , ] ) ; }
7898	protected function dynamicFrom ( $ from ) { $ provider = Str :: snake ( substr ( $ from , 4 ) ) ; return $ this -> from ( $ provider ) ; }
3198	protected function checkTimestampCoherence ( $ points , $ timestamp ) { foreach ( $ points as $ point ) { if ( $ point -> getTimestamp ( ) > $ timestamp ) { throw new InconsistentRangeException ( 'A new TimePoint cannot be set before an existing one!' ) ; } } }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
11256	private function resolve ( string $ class ) : AbstractSeed { $ instance = $ this -> autowire ( $ class ) ; $ instance -> setDatabase ( $ this -> database ) ; $ instance -> setSeeder ( $ this ) ; if ( ! is_null ( $ this -> container ) ) { $ instance -> setContainer ( $ this -> container ) ; } return $ instance ; }
7157	private function setSubjectState ( StockSubjectInterface $ subject , $ state ) { if ( $ subject -> getStockState ( ) != $ state ) { $ subject -> setStockState ( $ state ) ; return true ; } return false ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
12152	public function setup ( ) { $ results = [ true ] ; if ( ! empty ( $ this -> primaryModel ) && ! empty ( $ this -> collectorItem -> parents ) ) { $ groups = [ 'top' ] ; foreach ( $ groups as $ groupName ) { $ group = Group :: getBySystemName ( $ groupName , false ) ; if ( empty ( $ group ) ) { continue ; } if ( $ this -> inheritParentAccess ) { $ results [ ] = $ this -> objectTypeModel -> parentAccess ( null , $ group ) ; } } } return min ( $ results ) ; }
2517	public function pnrAddMultiElements ( RequestOptions \ PnrAddMultiElementsOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
458	public function dropCheck ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
4299	public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = 'default' ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( 'default' , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ this -> data [ 'counts' ] [ $ label ] ) ) { $ this -> data [ 'counts' ] [ $ label ] = 0 ; $ args = array ( ( string ) $ label , 0 , ) ; } else { $ args = array ( 'Counter \'' . $ label . '\' doesn\'t exist.' ) ; } if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'countReset' , $ args , $ meta ) ; } }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
8336	public function setValueMutator ( callable $ callback ) : self { $ this -> valueMutator = $ callback ; $ this -> value = ( $ this -> valueMutator ) ( $ this -> value ) ; return $ this ; }
2732	public function execute ( ) { $ types = $ this -> cacheManager -> getAvailableTypes ( ) ; $ types = array_diff ( $ types , [ 'full_page' ] ) ; $ this -> cacheManager -> clean ( $ types ) ; $ result = $ this -> api -> cleanAll ( ) ; if ( $ result === true ) { $ this -> messageManager -> addSuccessMessage ( __ ( 'Full Magento & Fastly Cache has been cleaned.' ) ) ; } else { $ this -> getMessageManager ( ) -> addErrorMessage ( __ ( 'Full Magento & Fastly Cache was not cleaned successfully.' ) ) ; } return $ this -> _redirect ( '*/cache/index' ) ; }
3018	public function createPost ( $ blogName , $ data ) { $ path = $ this -> blogPath ( $ blogName , '/post' ) ; return $ this -> postRequest ( $ path , $ data , false ) ; }
8610	public function updateSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_UpdateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_UpdateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_UpdateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4059	private function drawLegend ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( is_array ( $ legend = StringUtil :: deserialize ( $ model -> getProperty ( 'legendtitle' ) ) ) ) { foreach ( [ $ metaModel -> getActiveLanguage ( ) , $ metaModel -> getFallbackLanguage ( ) ] as $ language ) { if ( array_key_exists ( $ language , $ legend ) && ! empty ( $ legend [ $ language ] ) ) { $ legend = $ legend [ $ language ] ; break ; } } } if ( empty ( $ legend ) ) { $ legend = 'legend' ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong></div> <div class="dca_palette">%s%s</div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ this -> trans ( 'dcatypes.legend' ) , $ legend , $ model -> getProperty ( 'legendhide' ) ? ':hide' : '' ] ) ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
9983	public static function dataTypeForValue ( $ pValue ) { if ( $ pValue === null ) { return DataType :: TYPE_NULL ; } elseif ( $ pValue === '' ) { return DataType :: TYPE_STRING ; } elseif ( $ pValue instanceof RichText ) { return DataType :: TYPE_INLINE ; } elseif ( $ pValue [ 0 ] === '=' && strlen ( $ pValue ) > 1 ) { return DataType :: TYPE_FORMULA ; } elseif ( is_bool ( $ pValue ) ) { return DataType :: TYPE_BOOL ; } elseif ( is_float ( $ pValue ) || is_int ( $ pValue ) ) { return DataType :: TYPE_NUMERIC ; } elseif ( preg_match ( '/^[\+\-]?(\d+\\.?\d*|\d*\\.?\d+)([Ee][\-\+]?[0-2]?\d{1,3})?$/' , $ pValue ) ) { $ tValue = ltrim ( $ pValue , '+-' ) ; if ( is_string ( $ pValue ) && $ tValue [ 0 ] === '0' && strlen ( $ tValue ) > 1 && $ tValue [ 1 ] !== '.' ) { return DataType :: TYPE_STRING ; } elseif ( ( strpos ( $ pValue , '.' ) === false ) && ( $ pValue > PHP_INT_MAX ) ) { return DataType :: TYPE_STRING ; } return DataType :: TYPE_NUMERIC ; } elseif ( is_string ( $ pValue ) ) { $ errorCodes = DataType :: getErrorCodes ( ) ; if ( isset ( $ errorCodes [ $ pValue ] ) ) { return DataType :: TYPE_ERROR ; } } return DataType :: TYPE_STRING ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
6768	protected function handleContentChange ( SaleInterface $ sale ) { $ changed = $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; if ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed = $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } $ changed |= $ this -> saleUpdater -> updateTotals ( $ sale ) ; $ changed |= $ this -> updateState ( $ sale ) ; $ changed |= $ this -> saleUpdater -> updateOutstandingDate ( $ sale ) ; return $ changed ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
4960	public function render ( FormInterface $ form , $ layout = self :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ formContent = $ this -> renderBare ( $ form , $ layout , $ parameter ) ; $ renderer = $ this -> getView ( ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ descriptionParams = $ form -> getOption ( 'description_params' ) ; $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; if ( $ descriptionParams ) { array_unshift ( $ descriptionParams , $ desc ) ; $ desc = call_user_func_array ( 'sprintf' , $ descriptionParams ) ; } } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8"><div class="panel panel-default"><div class="panel-body">%s</div></div></div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } else { $ formContent = '<div class="form-content">' . $ formContent . '</div>' ; } $ markup = '<div id="form-%s" class="form-container">' . '%s' . '%s' . '</div>' ; if ( $ label = $ form -> getLabel ( ) ) { $ label = '<div class="form-headline"><h3>' . $ renderer -> translate ( $ label ) . '</h3></div>' ; } return sprintf ( $ markup , $ form -> getAttribute ( 'id' ) ? : $ form -> getName ( ) , $ label , $ formContent ) ; }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
5152	static function sortEmailsByCreationDatePredicate ( $ emailA , $ emailB ) { $ sortKeyA = $ emailA -> sent_at ; $ sortKeyB = $ emailB -> sent_at ; return ( $ sortKeyA > $ sortKeyB ) ? - 1 : 1 ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
799	private function removeSpaceAroundToken ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isWhitespace ( ) && false === strpos ( $ token -> getContent ( ) , "\n" ) ) { $ tokens -> clearAt ( $ index ) ; } }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
6701	protected function parseString ( $ string ) { $ this -> build = null ; $ this -> major = 0 ; $ this -> minor = 0 ; $ this -> patch = 0 ; $ this -> pre = null ; if ( false === static :: isValid ( $ string ) ) { throw new InvalidArgumentException ( sprintf ( 'The version string "%s" is invalid.' , $ string ) ) ; } if ( false !== strpos ( $ string , '+' ) ) { list ( $ string , $ build ) = explode ( '+' , $ string ) ; $ this -> setBuild ( explode ( '.' , $ build ) ) ; } if ( false !== strpos ( $ string , '-' ) ) { list ( $ string , $ pre ) = explode ( '-' , $ string ) ; $ this -> setPreRelease ( explode ( '.' , $ pre ) ) ; } $ version = explode ( '.' , $ string ) ; $ this -> major = ( int ) $ version [ 0 ] ; if ( isset ( $ version [ 1 ] ) ) { $ this -> minor = ( int ) $ version [ 1 ] ; } if ( isset ( $ version [ 2 ] ) ) { $ this -> patch = ( int ) $ version [ 2 ] ; } }
3394	protected function sendConfirmationToUser ( $ user ) { $ user -> confirmation_code = str_random ( 25 ) ; $ user -> save ( ) ; $ notification = app ( config ( 'confirmation.notification' ) ) ; $ user -> notify ( $ notification ) ; }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
12352	public function allow ( array $ level_select = [ "min" => 4 , "max" => 4 ] ) : bool { if ( $ this -> details !== false ) { if ( is_array ( $ level_select ) === true && isset ( $ level_select [ "min" ] ) === true && isset ( $ level_select [ "max" ] ) === true ) { $ level_select [ "min" ] = Model \ Role :: find ( $ level_select [ "min" ] ) -> priority ; $ level_select [ "max" ] = Model \ Role :: find ( $ level_select [ "max" ] ) -> priority ; $ level_select = [ "min" => $ level_select [ "min" ] , "max" => $ level_select [ "max" ] ] ; } else { return false ; } $ current_priority = $ this -> details -> role -> priority ; if ( is_numeric ( $ level_select [ "min" ] ) === true && is_numeric ( $ level_select [ "max" ] ) === true ) { if ( $ level_select [ "min" ] >= $ current_priority && $ level_select [ "max" ] <= $ current_priority ) { return true ; } else { return false ; } } else { return false ; } } else { return false ; } }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
10809	protected function __templates ( $ customTemplate = null , $ customTemplateSuffix = null ) { $ templates = SSViewer :: get_templates_by_class ( $ this -> class , $ customTemplateSuffix , \ FormField :: class ) ; if ( ! $ templates ) { throw new \ Exception ( "No template found for {$this->class}" ) ; } if ( $ customTemplate ) { array_unshift ( $ templates , $ customTemplate ) ; } return $ templates ; }
7214	public function debit ( $ account , $ amount , \ DateTime $ date ) { $ data = [ $ this -> date , $ account , $ this -> identity , null , $ amount , $ this -> number , $ date -> format ( 'Y-m-d' ) , ] ; if ( false === fputcsv ( $ this -> handle , $ data , ';' , '"' ) ) { throw new RuntimeException ( "Failed to write line." ) ; } }
10543	public function setConfig ( Dictionary $ config ) { $ this -> config = $ config ; $ this -> configureSites ( ) ; $ this -> setVariable ( 'config' , $ config ) ; return $ this ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
9631	public function setSetting ( $ key , $ value ) { $ settings = $ this -> getSettings ( ) ; $ settings [ $ key ] = $ value ; $ this -> setSettings ( $ settings ) ; }
4118	public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; }
5308	protected function getPathFromRect ( SimpleXMLElement $ rect ) { if ( empty ( $ rect [ 'width' ] ) || $ rect [ 'width' ] < 0 || empty ( $ rect [ 'height' ] ) || $ rect [ 'height' ] < 0 ) { return '' ; } if ( empty ( $ rect [ 'x' ] ) ) { $ rect [ 'x' ] = 0 ; } if ( empty ( $ rect [ 'y' ] ) ) { $ rect [ 'y' ] = 0 ; } return 'M' . $ rect [ 'x' ] . ' ' . $ rect [ 'y' ] . 'l' . $ rect [ 'width' ] . ' 0l0 ' . $ rect [ 'height' ] . 'l' . ( - $ rect [ 'width' ] ) . ' 0Z' ; }
3244	public function getWasPurchasedAttribute ( ) { if ( Auth :: guest ( ) ) return false ; return Auth :: user ( ) -> orders ( ) -> whereSKU ( $ this -> attributes [ 'sku' ] ) -> whereStatusIn ( config ( 'shop.order_status_purchase' ) ) -> count ( ) > 0 ; }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
8795	public function view ( $ name , array $ data = [ ] ) { $ file = app_path ( 'Views' . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { extract ( $ data ) ; require $ file ; return ob_get_clean ( ) ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'View::' . $ name . ' not found.' ) ; }
5682	public function getFrameset ( ) { if ( ! $ this -> hasFrames ( ) ) { return false ; } $ urls = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ name = $ this -> frames [ $ i ] -> getAttribute ( 'name' ) ; $ url = new SimpleUrl ( $ this -> frames [ $ i ] -> getAttribute ( 'src' ) ) ; $ key = $ name ? $ name : $ i + 1 ; $ urls [ $ key ] = $ this -> expandUrl ( $ url ) ; } return $ urls ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
7396	public function execute ( ) { $ addresses = $ this -> addressRepository -> createQueryBuilder ( 'a' ) -> where ( 'a.latitude IS NULL' ) -> orWhere ( 'a.longitude IS NULL' ) -> setMaxResults ( 500 ) -> getQuery ( ) -> getResult ( ) ; foreach ( $ addresses as $ address ) { try { $ this -> updateLatLong ( $ address ) ; } catch ( \ RuntimeException $ e ) { echo "Stopping work -- over the API query limit.\n" ; break ; } $ this -> entityManager -> persist ( $ address ) ; usleep ( self :: MILLISECONDS_PAUSE_BETWEEN_QUERIES ) ; } $ this -> entityManager -> flush ( ) ; }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7368	protected function checkShipmentIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Shipment \ ShipmentSubjectInterface ) { return ; } if ( empty ( $ sale -> getShipments ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> shipmentCalculator -> calculateShippedQuantity ( $ item ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ item -> getTotalQuantity ( ) , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_shipped , [ '%min%' => $ min , ] ) -> setInvalidValue ( $ item -> getQuantity ( ) ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
9941	public function setTitle ( $ pValue , $ updateFormulaCellReferences = true , $ validate = true ) { if ( $ this -> getTitle ( ) == $ pValue ) { return $ this ; } $ oldTitle = $ this -> getTitle ( ) ; if ( $ validate ) { self :: checkSheetTitle ( $ pValue ) ; if ( $ this -> parent ) { if ( $ this -> parent -> sheetNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> parent -> sheetNameExists ( $ pValue . ' ' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue .= " $i" ; } } } $ this -> title = $ pValue ; $ this -> dirty = true ; if ( $ this -> parent && $ this -> parent -> getCalculationEngine ( ) ) { $ newTitle = $ this -> getTitle ( ) ; $ this -> parent -> getCalculationEngine ( ) -> renameCalculationCacheForWorksheet ( $ oldTitle , $ newTitle ) ; if ( $ updateFormulaCellReferences ) { ReferenceHelper :: getInstance ( ) -> updateNamedFormulas ( $ this -> parent , $ oldTitle , $ newTitle ) ; } } return $ this ; }
2521	public function pnrIgnore ( RequestOptions \ PnrIgnoreOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Ignore' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
11589	public function matrix ( ) { if ( $ this -> _matrix ) { return $ this -> _matrix ; } $ this -> _matrix = new Matrix ( $ this -> tasks ( ) ) ; $ this -> _matrix -> process ( ) ; return $ this -> _matrix ; }
10613	protected function authenticateUser ( UserInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> container -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
11605	protected function getHashGeneratorByDescription ( OptionsInterface $ options , $ description ) { if ( $ description === 'predis' ) { return new Hash \ CRC16 ( ) ; } elseif ( $ description === 'phpiredis' ) { return new Hash \ PhpiredisCRC16 ( ) ; } else { throw new \ InvalidArgumentException ( 'String value for the crc16 option must be either `predis` or `phpiredis`' ) ; } }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
2441	public static function urlDecode ( string $ data ) : self { $ decoded = base64_decode ( strtr ( $ data , '-_,' , '+/=' ) , true ) ; if ( \ function_exists ( 'gzdecode' ) && false !== ( $ uncompressed = @ gzdecode ( $ decoded ) ) ) { $ decoded = $ uncompressed ; } $ json = @ json_decode ( $ decoded , true ) ; if ( null === $ json ) { throw new \ InvalidArgumentException ( 'Invalid JSON data' ) ; } return new self ( $ json [ 'context' ] , $ json [ 'extras' ] , $ json [ 'value' ] , $ json [ 'current' ] ) ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
935	public static function isKeyCaseSensitive ( $ caseSensitive , $ key ) { if ( \ is_array ( $ caseSensitive ) ) { return isset ( $ caseSensitive [ $ key ] ) ? $ caseSensitive [ $ key ] : true ; } return $ caseSensitive ; }
12463	public function newAction ( ) { $ entity = new CustomFieldsGroup ( ) ; $ form = $ this -> createCreateForm ( $ entity ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:new.html.twig' , array ( 'entity' => $ entity , 'form' => $ form -> createView ( ) , ) ) ; }
10069	public function addDecorator ( TagDecoratorInterface $ decorator , $ priority = 0 ) { $ this -> decorators -> add ( $ decorator , $ priority ) ; return $ this ; }
1246	public static function env ( ) { return function ( ) { $ appId = getenv ( self :: ENV_APP_ID ) ; $ certId = getenv ( self :: ENV_CERT_ID ) ; $ devId = getenv ( self :: ENV_DEV_ID ) ; if ( $ appId && $ certId && $ devId ) { return new Credentials ( $ appId , $ certId , $ devId ) ; } else { return new \ InvalidArgumentException ( 'Could not find environment variable ' . 'credentials in ' . self :: ENV_APP_ID . '/' . self :: ENV_CERT_ID . '/' . self :: ENV_DEV_ID ) ; } } ; }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
11317	public function note ( string $ message ) : void { $ this -> logger -> log ( $ this -> level , strip_tags ( $ message ) ) ; }
5299	public function getGlyphs ( ) { if ( ! isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) || ! count ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) ) { return array ( ) ; } $ glyphs = array ( ) ; foreach ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph as $ xmlGlyph ) { if ( isset ( $ xmlGlyph [ 'unicode' ] ) && isset ( $ xmlGlyph [ 'd' ] ) ) { $ glyph = array ( 'char' => ( string ) $ xmlGlyph [ 'unicode' ] , 'path' => ( string ) $ xmlGlyph [ 'd' ] , ) ; if ( isset ( $ xmlGlyph [ 'glyph-name' ] ) ) { $ glyph [ 'name' ] = ( string ) $ xmlGlyph [ 'glyph-name' ] ; } if ( isset ( $ xmlGlyph [ 'horiz-adv-x' ] ) ) { $ glyph [ 'width' ] = ( string ) $ xmlGlyph [ 'horiz-adv-x' ] ; } $ glyphs [ ] = $ glyph ; } } return $ glyphs ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
8391	public function addFullOuterJoin ( $ table , $ on ) { $ this -> fullOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
6971	protected function syncLineWithResult ( Model \ DocumentLineInterface $ line , Amount $ result ) { if ( $ line -> getUnit ( ) !== $ result -> getUnit ( ) ) { $ line -> setUnit ( $ result -> getUnit ( ) ) ; $ this -> changed = true ; } if ( $ line -> getGross ( ) !== $ result -> getGross ( ) ) { $ line -> setGross ( $ result -> getGross ( ) ) ; $ this -> changed = true ; } if ( $ line -> getDiscount ( ) !== $ result -> getDiscount ( ) ) { $ line -> setDiscount ( $ result -> getDiscount ( ) ) ; $ this -> changed = true ; } $ discountRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getDiscountAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ discountRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ discountRates !== $ line -> getDiscountRates ( ) ) { $ line -> setDiscountRates ( $ discountRates ) ; $ this -> changed = true ; } if ( $ line -> getBase ( ) !== $ result -> getBase ( ) ) { $ line -> setBase ( $ result -> getBase ( ) ) ; $ this -> changed = true ; } if ( $ line -> getTax ( ) !== $ result -> getTax ( ) ) { $ line -> setTax ( $ result -> getTax ( ) ) ; $ this -> changed = true ; } $ taxRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getTaxAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ taxRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ taxRates !== $ line -> getTaxRates ( ) ) { $ line -> setTaxRates ( $ taxRates ) ; $ this -> changed = true ; } if ( $ line -> getTotal ( ) !== $ result -> getTotal ( ) ) { $ line -> setTotal ( $ result -> getTotal ( ) ) ; $ this -> changed = true ; } }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4441	public function fromSubscriptions ( string $ topic ) : array { $ response = [ ] ; if ( empty ( $ topic ) ) { return $ response ; } $ subscriptions = $ this -> client -> call ( 'subscription' , 'default' , 'all' , $ topic ) ; $ subscriptions = json_decode ( $ subscriptions , true ) ? : [ ] ; foreach ( $ subscriptions as $ subscription => $ queues ) { $ topicPattern = str_replace ( [ '.' , '*' , '#' ] , [ '\.' , '[a-zA-z0-9^.]{1,}' , '.*' ] , $ subscription ) ; if ( preg_match ( "/^$topicPattern$/" , $ topic ) ) { $ response = array_merge ( $ response , $ queues ) ; } } return array_unique ( $ response ) ; }
290	public function __isset ( $ name ) { try { return $ this -> __get ( $ name ) !== null ; } catch ( \ Throwable $ t ) { return false ; } catch ( \ Exception $ e ) { return false ; } }
232	public function quoteValue ( $ str ) { if ( ! is_string ( $ str ) ) { return $ str ; } if ( ( $ value = $ this -> db -> getSlavePdo ( ) -> quote ( $ str ) ) !== false ) { return $ value ; } return "'" . addcslashes ( str_replace ( "'" , "''" , $ str ) , "\000\n\r\\\032" ) . "'" ; }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
5288	protected static function getRequestMethodName ( ) { $ request_engine = self :: $ requestEngine ; if ( $ request_engine == 'curl' && ! function_exists ( 'curl_init' ) ) { trigger_error ( "DetectLanguage::Client - CURL not found, switching to stream" ) ; $ request_engine = self :: $ requestEngine = 'stream' ; } switch ( $ request_engine ) { case 'curl' : return 'requestCurl' ; case 'stream' : return 'requestStream' ; default : throw new Error ( "Invalid request engine: " . $ request_engine ) ; } }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
1773	public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; }
158	public function andFilterCompare ( $ name , $ value , $ defaultOperator = '=' ) { if ( preg_match ( '/^(<>|>=|>|<=|<|=)/' , $ value , $ matches ) ) { $ operator = $ matches [ 1 ] ; $ value = substr ( $ value , strlen ( $ operator ) ) ; } else { $ operator = $ defaultOperator ; } return $ this -> andFilterWhere ( [ $ operator , $ name , $ value ] ) ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
8822	public function rules ( Array $ rules ) { foreach ( $ rules as $ key => $ value ) { $ this -> rule ( $ key , $ value [ 'label' ] , $ value [ 'rules' ] , isset ( $ value [ 'text' ] ) && ! empty ( $ value [ 'text' ] ) ? $ value [ 'text' ] : [ ] ) ; } }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
9820	public function getColumn ( $ pColumn ) { $ this -> testColumnInRange ( $ pColumn ) ; if ( ! isset ( $ this -> columns [ $ pColumn ] ) ) { $ this -> columns [ $ pColumn ] = new AutoFilter \ Column ( $ pColumn , $ this ) ; } return $ this -> columns [ $ pColumn ] ; }
3202	protected function process_css_style ( $ stackPtr ) { if ( ! isset ( $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ) ) { return ; } $ css_property = $ this -> target_css_properties [ $ this -> tokens [ $ stackPtr ] [ 'content' ] ] ; $ opener = $ this -> phpcsFile -> findPrevious ( \ T_OPEN_CURLY_BRACKET , $ stackPtr ) ; if ( false !== $ opener ) { for ( $ i = ( $ opener - 1 ) ; $ i >= 0 ; $ i -- ) { if ( isset ( Tokens :: $ commentTokens [ $ this -> tokens [ $ i ] [ 'code' ] ] ) || \ T_CLOSE_CURLY_BRACKET === $ this -> tokens [ $ i ] [ 'code' ] ) { break ; } } $ start = ( $ i + 1 ) ; $ selector = trim ( $ this -> phpcsFile -> getTokensAsString ( $ start , ( $ opener - $ start ) ) ) ; unset ( $ i ) ; foreach ( $ this -> target_css_selectors as $ target_selector ) { if ( false !== strpos ( $ selector , $ target_selector ) ) { $ error = true ; if ( true === $ this -> remove_only ) { $ valuePtr = $ this -> phpcsFile -> findNext ( array ( \ T_COLON , \ T_WHITESPACE ) , ( $ stackPtr + 1 ) , null , true ) ; $ value = $ this -> tokens [ $ valuePtr ] [ 'content' ] ; $ valid = $ this -> validate_css_property_value ( $ value , $ css_property [ 'type' ] , $ css_property [ 'value' ] ) ; if ( true === $ valid ) { $ error = false ; } } if ( true === $ error ) { $ this -> phpcsFile -> addError ( 'Hiding of the admin bar is not allowed.' , $ stackPtr , 'HidingDetected' ) ; } } } } }
1298	public function getReferences ( Query $ query = null ) : ResourceArray { $ query = $ query ? : new Query ( ) ; $ query -> linksToEntry ( $ this -> getId ( ) ) ; return $ this -> client -> getEntries ( $ query ) ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
3074	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { $ session = $ context -> getTestSession ( ) ; $ routeItem = null ; if ( ! is_null ( $ itemRef ) ) { try { $ routeItem = $ session -> getRoute ( ) -> getRouteItemsByAssessmentItemRef ( $ itemRef ) ; if ( $ routeItem ) { $ routeItem = $ routeItem [ 0 ] ; } } catch ( OutOfBoundsException $ obe ) { \ common_Logger :: d ( "Could not retrieve the route for item '${itemRef}'." ) ; } } else { $ routeItem = $ session -> getRoute ( ) -> current ( ) ; } return implode ( '' , $ this -> getRubricBlock ( $ routeItem , $ session , $ context -> getCompilationDirectory ( ) ) ) ; }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
11214	public function count ( $ coraDbQuery = false ) { if ( ! $ coraDbQuery ) { $ coraDbQuery = $ this -> gateway -> getDb ( ) ; } $ coraDbQuery = $ this -> model :: model_constraints ( $ coraDbQuery ) ; return $ this -> gateway -> count ( $ coraDbQuery ) ; }
12887	private function getComposer ( $ fileOrPackage ) { if ( isset ( $ this -> jsonCache [ $ fileOrPackage ] ) ) return $ this -> jsonCache [ $ fileOrPackage ] ; if ( $ file = $ this -> files [ $ fileOrPackage ] ?? NULL ) { return $ this -> getComposer ( $ file ) ; } if ( is_dir ( $ fileOrPackage ) ) $ fileOrPackage .= "/composer.json" ; if ( is_file ( $ fileOrPackage ) ) { $ json = json_decode ( file_get_contents ( $ fileOrPackage ) , true ) ; $ name = $ json [ "name" ] ; $ this -> jsonCache [ $ name ] = $ json ; $ this -> files [ $ name ] = $ fileOrPackage ; return $ json ; } return NULL ; }
11421	public function constructSelectSQL ( $ fields ) { $ sql = array ( ) ; $ sql [ ] = "SELECT" ; $ sql [ ] = "`" . implode ( "`, `" , array_keys ( $ fields ) ) . "`" ; $ sql [ ] = "FROM `" . $ this -> dbtable . "`" ; $ sql [ ] = "WHERE `" . $ this -> pk . "` = " . $ fields [ $ this -> pk ] -> getSQL ( ) ; return implode ( " " , $ sql ) ; }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
7778	protected function extractInput ( array $ data ) { $ input = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ input [ $ field ] = $ fieldData [ 0 ] ; } return $ input ; }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
3397	public function urlDecodeUnreservedChars ( $ string ) { $ string = rawurldecode ( $ string ) ; $ string = rawurlencode ( $ string ) ; $ string = str_replace ( array ( '%2F' , '%3A' , '%40' ) , array ( '/' , ':' , '@' ) , $ string ) ; return $ string ; }
3999	protected function getCount ( $ strType , $ intID ) { switch ( $ strType ) { case 'mod' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_module' , $ intID ) ; break ; case 'ce' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_content' , $ intID ) ; break ; default : return false ; } if ( $ objMetaModelResult != null ) { return $ this -> getCountFor ( $ objMetaModelResult -> metamodel , $ objMetaModelResult -> metamodel_filtering ) ; } return false ; }
9177	public function mapBoolean ( $ value ) { if ( isset ( $ this -> booleanMapping [ $ value ] ) ) { return $ this -> booleanMapping [ $ value ] ; } throw new \ Exception ( sprintf ( 'Can\'t convert %s to boolean' , $ value ) ) ; }
2116	public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } }
8292	protected function checkAccess ( $ url ) { foreach ( $ this -> modules as $ module ) { if ( false === $ module -> handleEvent ( 'checkAccess' , [ $ url ] ) ) { return false ; } } return true ; }
8518	public function setSelectionRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SelectionRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11035	function check_level ( $ error_level , $ errno , $ message ) { if ( error_reporting ( ) & $ error_level ) { switch ( $ error_level ) { case E_NOTICE : $ type = 'notice' ; break ; case E_WARNING : $ type = 'warning' ; break ; case E_ERROR : $ type = 'error' ; break ; } echo "<b>ETS $type:</b> $message" ; } if ( $ error_level == E_ERROR ) { exit ; } }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
7950	public function orderBackend ( $ nbBackend , $ duration ) { return json_decode ( self :: getClient ( ) -> orderBackend ( $ this -> sn , $ nbBackend , $ duration ) ) ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
3920	private function addFileModels ( $ files , $ skipPaths = array ( ) ) { $ baseLanguage = $ this -> getBaseLanguage ( ) ; $ fallbackLanguage = $ this -> getFallbackLanguage ( ) ; foreach ( $ files as $ file ) { if ( 'folder' === $ file -> type && ! in_array ( $ file -> path , $ skipPaths ) ) { $ this -> pendingPaths [ ] = $ file -> path . '/' ; continue ; } if ( is_file ( TL_ROOT . DIRECTORY_SEPARATOR . $ file -> path ) && in_array ( strtolower ( pathinfo ( $ file -> path , PATHINFO_EXTENSION ) ) , $ this -> acceptedExtensions ) ) { $ path = $ file -> path ; $ this -> foundFiles [ ] = $ path ; $ this -> uuidMap [ $ file -> uuid ] = $ path ; $ meta = StringUtil :: deserialize ( $ file -> meta , true ) ; if ( isset ( $ meta [ $ baseLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ baseLanguage ] ; } elseif ( isset ( $ meta [ $ fallbackLanguage ] ) ) { $ this -> metaInformation [ dirname ( $ path ) ] [ basename ( $ path ) ] = $ meta [ $ fallbackLanguage ] ; } } } }
3410	public function runCommand ( string $ command , array $ options , InputInterface $ current , OutputInterface $ output ) : int { array_unshift ( $ options , $ command ) ; $ input = new ArrayInput ( $ options ) ; if ( ! $ current -> isInteractive ( ) ) { $ input -> setInteractive ( false ) ; } $ command = $ this -> get ( $ command ) ; return $ this -> doRunCommand ( $ command , $ input , $ output ) ; }
11905	public function getType ( ) { if ( is_null ( $ this -> _type ) ) { $ this -> _type = FieldTypeDetector :: detect ( $ this -> modelField ) ; } return $ this -> _type ; }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
9887	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ NONE = new Permission ( 1 , "none" ) ; self :: $ SOI = new Permission ( 2 , "soi" ) ; self :: $ COI = new Permission ( 3 , "coi" ) ; self :: $ DOI = new Permission ( 4 , "doi" ) ; self :: $ DOI_PLUS = new Permission ( 5 , "doi+" ) ; self :: $ OTHER = new Permission ( 6 , "other" ) ; self :: $ initialized = true ; } }
2581	protected function loadOverrideSoapClient ( $ params ) { if ( isset ( $ params [ 'overrideSoapClient' ] ) && $ params [ 'overrideSoapClient' ] instanceof \ SoapClient ) { $ this -> overrideSoapClient = $ params [ 'overrideSoapClient' ] ; } if ( isset ( $ params [ 'overrideSoapClientWsdlName' ] ) ) { $ this -> overrideSoapClientWsdlName = $ params [ 'overrideSoapClientWsdlName' ] ; } }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
8982	private function filter ( $ configurations , array $ criteria ) { $ result = array ( ) ; foreach ( $ configurations as $ configuration ) { if ( ConfigurationFilterUtil :: matches ( $ configuration , $ criteria ) ) { $ result [ ] = $ configuration ; } } return $ result ; }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
12554	public function createTable ( ) { $ stmt = $ this -> pdoConnection -> prepare ( sprintf ( self :: $ CREATE_TABLE , $ this -> tableName ) ) ; return $ stmt -> execute ( ) ; }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
9989	public function generateNavigation ( ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ sheets = [ ] ; if ( $ this -> sheetIndex === null ) { $ sheets = $ this -> spreadsheet -> getAllSheets ( ) ; } else { $ sheets [ ] = $ this -> spreadsheet -> getSheet ( $ this -> sheetIndex ) ; } $ html = '' ; if ( count ( $ sheets ) > 1 ) { $ sheetId = 0 ; $ html .= '<ul class="navigation">' . PHP_EOL ; foreach ( $ sheets as $ sheet ) { $ html .= ' <li class="sheet' . $ sheetId . '"><a href="#sheet' . $ sheetId . '">' . $ sheet -> getTitle ( ) . '</a></li>' . PHP_EOL ; ++ $ sheetId ; } $ html .= '</ul>' . PHP_EOL ; } return $ html ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
10209	private function performRequest ( $ curlSession , $ deserializationType = null ) { $ response = curl_exec ( $ curlSession ) ; $ response = $ response ? $ response : null ; try { $ result = new MaileonAPIResult ( $ response , $ curlSession , $ this -> throwException , $ deserializationType ) ; $ this -> printDebugInformation ( $ curlSession , $ result ) ; curl_close ( $ curlSession ) ; return $ result ; } catch ( MaileonAPIException $ e ) { if ( $ this -> debug ) { $ this -> printDebugInformation ( $ curlSession , null , $ this -> throwException ? null : $ e ) ; } curl_close ( $ curlSession ) ; if ( $ this -> throwException ) { throw $ e ; } return null ; } }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
5422	protected function readAll ( $ socket ) { $ all = '' ; while ( ! $ this -> isLastPacket ( $ next = $ socket -> read ( ) ) ) { $ all .= $ next ; } return $ all ; }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2336	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ response = $ event -> getResponse ( ) ; $ isSecure = $ request -> isSecure ( ) ; $ basePath = $ request -> getBasePath ( ) ? : '/' ; foreach ( $ this -> tokenStorage -> getUsedTokens ( ) as $ key => $ value ) { $ cookieKey = $ this -> cookiePrefix . $ key ; if ( $ request -> cookies -> has ( $ cookieKey ) && $ value === $ request -> cookies -> get ( $ cookieKey ) ) { continue ; } $ expires = null === $ value ? 1 : 0 ; $ response -> headers -> setCookie ( new Cookie ( $ cookieKey , $ value , $ expires , $ basePath , null , $ isSecure , true , false , Cookie :: SAMESITE_LAX ) ) ; } }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
9151	public function getSelectOptions ( ) { $ filter = new UnderscoreToCamelCase ( ) ; $ funcName = "get" . ucfirst ( $ filter -> filter ( $ this -> getUserColumn ( ) ) ) ; $ resultSet = $ this -> fetchAll ( array ( 'user_id' , $ this -> getUserColumn ( ) ) , function ( Select $ select ) { $ select -> where -> notEqualTo ( 'user_id' , $ this -> getCurrentUser ( ) -> getId ( ) ) ; } ) ; $ options = array ( ) ; foreach ( $ resultSet as $ user ) { $ options [ $ user -> getId ( ) ] = $ user -> $ funcName ( ) ; } return $ options ; }
1968	public static function findByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; if ( Validator :: isStringUuid ( $ intPid ) ) { $ intPid = StringUtil :: uuidToBin ( $ intPid ) ; } return static :: findBy ( array ( "$t.pid=UNHEX(?)" ) , bin2hex ( $ intPid ) , $ arrOptions ) ; }
3526	private function parseStatItem ( $ stat ) : array { $ result = [ ] ; $ pieces = explode ( "_" , $ stat -> name ) ; $ result [ $ pieces [ 2 ] ] [ $ pieces [ 4 ] ] [ $ pieces [ 1 ] ] = $ stat -> value ; return $ result ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
8301	public function handleAccountPage ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; $ this -> picoAuth -> addAllowed ( "account" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/account.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "new_password" ) && $ post -> has ( "new_password_repeat" ) && $ post -> has ( "old_password" ) ) { $ newPassword = new Password ( $ post -> get ( "new_password" ) ) ; $ newPasswordRepeat = new Password ( $ post -> get ( "new_password_repeat" ) ) ; $ oldPassword = new Password ( $ post -> get ( "old_password" ) ) ; $ username = $ user -> getId ( ) ; if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( $ newPassword -> get ( ) !== $ newPasswordRepeat -> get ( ) ) { $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> loginAttempt ( $ username , $ oldPassword ) ) { $ this -> session -> addFlash ( "error" , "The current password is incorrect" ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } if ( ! $ localAuth -> checkPasswordPolicy ( $ newPassword ) ) { $ this -> picoAuth -> redirectToPage ( "account" ) ; } $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ newPassword ) ; $ this -> storage -> saveUser ( $ username , $ userData ) ; $ this -> session -> addFlash ( "success" , "Password changed successfully." ) ; $ this -> picoAuth -> redirectToPage ( "account" ) ; } }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
4135	public static function decryptWithAppendedTag ( $ K , $ IV , $ Ciphertext = null , $ A = null , $ tag_length = 128 ) { $ tag_length_in_bits = $ tag_length / 8 ; $ C = mb_substr ( $ Ciphertext , 0 , - $ tag_length_in_bits , '8bit' ) ; $ T = mb_substr ( $ Ciphertext , - $ tag_length_in_bits , null , '8bit' ) ; return self :: decrypt ( $ K , $ IV , $ C , $ A , $ T ) ; }
5022	protected function copyArrayValues ( array $ source , array $ keys ) { $ target = [ ] ; foreach ( $ keys as $ key => $ spec ) { if ( is_int ( $ key ) ) { $ key = $ spec ; $ spec = null ; } if ( ! array_key_exists ( $ key , $ source ) ) { continue ; } if ( null === $ spec ) { $ target [ $ key ] = $ source [ $ key ] ; continue ; } if ( is_string ( $ spec ) ) { $ target [ $ spec ] [ $ key ] = $ source [ $ key ] ; continue ; } if ( isset ( $ spec [ 'if' ] ) && $ source [ $ key ] !== $ spec [ 'if' ] ) { continue ; } if ( isset ( $ spec [ 'key' ] ) ) { $ targetKeys = is_array ( $ spec [ 'key' ] ) ? $ spec [ 'key' ] : [ $ spec [ 'key' ] ] ; $ value = isset ( $ spec [ 'value' ] ) ? $ spec [ 'value' ] : $ source [ $ key ] ; } else { $ targetKeys = $ spec ; $ value = $ source [ $ key ] ; } $ tmpTarget = & $ target ; foreach ( $ targetKeys as $ targetKey ) { if ( '*' == $ targetKey ) { $ targetKey = $ key ; } if ( ! isset ( $ tmpTarget [ $ targetKey ] ) ) { $ tmpTarget [ $ targetKey ] = [ ] ; } $ tmpTarget = & $ tmpTarget [ $ targetKey ] ; } $ tmpTarget = $ value ; } return $ target ; }
9842	public function createSealedJsonResponse ( int $ status , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
5371	public function attach ( $ key , $ content , $ filename ) { $ this -> request [ ] = new SimpleAttachment ( $ key , $ content , $ filename ) ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
7023	private function formatZ ( & $ str ) { if ( strstr ( $ str , '%Z' ) ) $ str = str_replace ( '%Z' , $ this -> timezone -> offset * 3600 , $ str ) ; }
8590	public function setGetMatchingProductResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
49	protected function getScriptListeners ( Event $ event ) { $ package = $ this -> composer -> getPackage ( ) ; $ scripts = $ package -> getScripts ( ) ; if ( empty ( $ scripts [ $ event -> getName ( ) ] ) ) { return array ( ) ; } if ( $ this -> loader ) { $ this -> loader -> unregister ( ) ; } $ generator = $ this -> composer -> getAutoloadGenerator ( ) ; if ( $ event instanceof ScriptEvent ) { $ generator -> setDevMode ( $ event -> isDevMode ( ) ) ; } $ packages = $ this -> composer -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getCanonicalPackages ( ) ; $ packageMap = $ generator -> buildPackageMap ( $ this -> composer -> getInstallationManager ( ) , $ package , $ packages ) ; $ map = $ generator -> parseAutoloads ( $ packageMap , $ package ) ; $ this -> loader = $ generator -> createLoader ( $ map ) ; $ this -> loader -> register ( ) ; return $ scripts [ $ event -> getName ( ) ] ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
5725	protected function saveAndRedirect ( $ data , $ form , $ redirectLink ) { $ new_record = $ this -> owner -> record -> ID == 0 ; $ controller = Controller :: curr ( ) ; $ list = $ this -> owner -> gridField -> getList ( ) ; if ( $ list instanceof ManyManyList ) { $ extraData = ( isset ( $ data [ 'ManyMany' ] ) ) ? $ data [ 'ManyMany' ] : null ; } else { $ extraData = null ; } if ( ! $ this -> owner -> record -> canEdit ( ) ) { return $ controller -> httpError ( 403 ) ; } try { $ form -> saveInto ( $ this -> owner -> record ) ; $ this -> owner -> record -> write ( ) ; $ list -> add ( $ this -> owner -> record , $ extraData ) ; } catch ( ValidationException $ e ) { $ form -> sessionMessage ( $ e -> getResult ( ) -> message ( ) , 'bad' ) ; $ responseNegotiator = new PjaxResponseNegotiator ( array ( 'CurrentForm' => function ( ) use ( $ form ) { return $ form -> forTemplate ( ) ; } , 'default' => function ( ) use ( $ controller ) { return $ controller -> redirectBack ( ) ; } ) ) ; if ( $ controller -> getRequest ( ) -> isAjax ( ) ) { $ controller -> getRequest ( ) -> addHeader ( 'X-Pjax' , 'CurrentForm' ) ; } return $ responseNegotiator -> respond ( $ controller -> getRequest ( ) ) ; } return Controller :: curr ( ) -> redirect ( $ redirectLink ) ; }
9476	protected function getStartDate ( ) { $ StartDate = false ; $ objStartDate = \ Database :: getInstance ( ) -> prepare ( "SELECT MIN(`tstamp`) AS YMD FROM `tl_dlstatdets` WHERE 1" ) -> execute ( ) ; if ( $ objStartDate -> YMD !== null ) { $ StartDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , $ objStartDate -> YMD ) ; } return $ StartDate ; }
7992	public function setPassword ( $ pp , $ pca , $ passwd ) { if ( ! $ pp ) throw new BadMethodCallException ( 'Missing parameter $pp (OVH cloud passport).' ) ; if ( ! $ pca ) throw new BadMethodCallException ( 'Missing parameter $pca (PCA ServiceName).' ) ; if ( ! $ passwd ) throw new BadMethodCallException ( 'Missing parameter $passwd (Password for this pca).' ) ; $ payload = array ( 'password' => $ passwd ) ; try { $ this -> put ( 'cloud/' . $ pp . '/pca/' . $ pca , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new CloudException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
7155	private function nullDateIfLowerThanToday ( \ DateTime $ eda = null ) { if ( null === $ eda ) { return null ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; if ( $ eda < $ today ) { return null ; } return $ eda ; }
5306	protected function transformPath ( $ path , $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset ) { if ( $ flip === 'horizontal' || $ flip === 'vertical' ) { $ viewBox = $ this -> getViewBox ( ) ; } return preg_replace_callback ( '([m,l,h,v,c,s,q,t,a,z](?:[\\s,]*-?(?=\\.?\\d)\\d*(?:\\.\\d+)?)*)i' , function ( $ maches ) use ( $ scale , $ roundPrecision , $ flip , $ xOffset , $ yOffset , $ viewBox ) { $ command = substr ( $ maches [ 0 ] , 0 , 1 ) ; $ absoluteCommand = strtoupper ( $ command ) === $ command ; $ xyCommand = in_array ( strtolower ( $ command ) , array ( 'm' , 'l' , 'c' , 's' , 'q' , 't' ) ) ; $ xCommand = strtolower ( $ command ) === 'h' ; $ yCommand = strtolower ( $ command ) === 'v' ; if ( strtolower ( $ command ) === 'z' ) { return $ command ; } if ( strtolower ( $ command ) === 'a' ) { throw new \ Exception ( 'Path command "A" is currently not supportet!' ) ; } $ values = $ this -> getValuesFromList ( substr ( $ maches [ 0 ] , 1 ) ) ; foreach ( $ values as $ key => $ value ) { if ( $ flip === 'horizontal' && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'width' ] ; } } if ( $ flip === 'vertical' && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] *= - 1 ; if ( $ absoluteCommand ) { $ values [ $ key ] += $ viewBox [ 'height' ] ; } } if ( $ absoluteCommand && ( ( ! ( $ key % 2 ) && $ xyCommand ) || $ xCommand ) ) { $ values [ $ key ] += $ xOffset ; } if ( $ absoluteCommand && ( ( $ key % 2 && $ xyCommand ) || $ yCommand ) ) { $ values [ $ key ] += $ yOffset ; } $ values [ $ key ] *= $ scale ; if ( $ roundPrecision !== null ) { $ values [ $ key ] = round ( $ values [ $ key ] , $ roundPrecision ) ; } } return $ command . implode ( ' ' , $ values ) ; } , $ path ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
1392	public function isJsonApi ( $ request , Exception $ e ) { if ( Helpers :: wantsJsonApi ( $ request ) ) { return true ; } $ route = app ( JsonApiService :: class ) -> currentRoute ( ) ; return $ route -> hasCodec ( ) && $ route -> getCodec ( ) -> willEncode ( ) ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
2083	public function generateInternalCache ( ) { $ container = System :: getContainer ( ) ; $ warmer = $ container -> get ( 'contao.cache.warm_internal' ) ; $ warmer -> warmUp ( $ container -> getParameter ( 'kernel.cache_dir' ) ) ; $ this -> log ( 'Generated the internal cache' , __METHOD__ , TL_CRON ) ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
9025	public function hasUrl ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( preg_match ( "/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/i" , $ word ) ) { $ result = true ; } } return $ result ; }
12093	public function getDomainUrl ( $ address , $ scheme = false ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getDomain ( $ scheme ) ; }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
12888	public function getTheme ( ) { if ( ! isset ( $ this -> _theme ) ) { return $ this -> _lastLoadedTheme -> object ; } if ( ! isset ( $ this -> _theme ) ) { throw new Exception ( "No theme has been loaded!" ) ; } return $ this -> _theme ; }
10728	public function getMonth ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'month' ] ; } }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
3882	private function determineJumpToInformation ( ) { $ translated = $ this -> metaModel -> isTranslated ( ) ; $ desiredLanguage = $ this -> metaModel -> getActiveLanguage ( ) ; $ fallbackLanguage = $ this -> metaModel -> getFallbackLanguage ( ) ; $ jumpToPageId = '' ; $ filterSettingId = '' ; if ( ! isset ( $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ) ) { foreach ( ( array ) $ this -> get ( 'jumpTo' ) as $ jumpTo ) { $ langCode = $ jumpTo [ 'langcode' ] ; if ( ! $ translated || ( $ langCode == $ desiredLanguage ) || ( $ langCode == $ fallbackLanguage ) ) { $ jumpToPageId = $ jumpTo [ 'value' ] ; $ filterSettingId = $ jumpTo [ 'filter' ] ; if ( $ desiredLanguage == $ jumpTo [ 'langcode' ] ) { break ; } } } $ pageDetails = $ this -> getPageDetails ( $ jumpToPageId ) ; $ filterSetting = $ filterSettingId ? $ this -> getFilterFactory ( ) -> createCollection ( $ filterSettingId ) : null ; $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] = array ( 'page' => $ jumpToPageId , 'pageDetails' => $ pageDetails , 'filter' => $ filterSettingId , 'filterSetting' => $ filterSetting , 'language' => $ pageDetails [ 'language' ] , 'label' => $ this -> getJumpToLabel ( ) ) ; } return $ this -> jumpToCache [ $ desiredLanguage . '.' . $ fallbackLanguage ] ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
5606	public function paintGroupStart ( $ group , $ size ) { $ this -> group = self :: escapeVal ( $ group ) ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { xdebug_start_code_coverage ( XDEBUG_CC_UNUSED | XDEBUG_CC_DEAD_CODE ) ; } } }
8552	public function setServiceFeeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceFeeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
163	public function cache ( $ duration = true , $ dependency = null ) { $ this -> queryCacheDuration = $ duration ; $ this -> queryCacheDependency = $ dependency ; return $ this ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
59	public function addPackage ( $ source , $ target , $ reason ) { $ this -> suggestedPackages [ ] = array ( 'source' => $ source , 'target' => $ target , 'reason' => $ reason , ) ; return $ this ; }
4479	public function tag ( ... $ tags ) : void { $ response = call_user_func_array ( [ $ this -> client , 'call' ] , array_merge ( [ 'tag' , 'add' , $ this -> jid ] , array_values ( func_get_args ( ) ) ) ) ; $ this -> setTags ( json_decode ( $ response , true ) ) ; }
1415	public function invalidResource ( string $ path , ? string $ detail = null , array $ failed = [ ] ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_invalid' , 'code' ) , $ this -> trans ( 'resource_invalid' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_invalid' , 'detail' ) , $ this -> pointer ( $ path ) , $ failed ? compact ( 'failed' ) : null ) ; }
1112	public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
11952	protected function substituteSQLOperationPlaceholders ( $ sqloperation ) { $ sql_value = $ sqloperation -> toSQLString ( ) ; if ( count ( $ sqloperation -> getPlaceholderValues ( ) ) > 0 ) { $ startpos = 0 ; $ sql_value_replaced = '' ; foreach ( $ sqloperation -> getPlaceholderValues ( ) as $ avalue ) { $ qpos = strpos ( $ sql_value , '?' , $ startpos ) ; $ sql_value_replaced .= substr ( $ sql_value , $ startpos , $ qpos ) ; $ sql_value_replaced .= $ this -> db -> Quote ( $ avalue ) ; $ startpos = $ qpos + 1 ; } $ sql_value_replaced .= substr ( $ sql_value , $ startpos ) ; $ sql_value = $ sql_value_replaced ; } return $ sql_value ; }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
11579	private function config ( ) { $ handler = new RotatingFileHandler ( $ this -> getFullPath ( ) , 0 , MonoLogger :: INFO ) ; $ handler -> setFormatter ( $ this -> getLineFormater ( ) ) ; $ this -> logger -> pushHandler ( $ handler ) ; $ this -> logger -> pushProcessor ( new WebProcessor ( ) ) ; $ this -> logger -> pushProcessor ( new MemoryUsageProcessor ( ) ) ; }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
3677	private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
12533	public function bindLocation ( array $ deviceIdentifier , $ poiId , $ type = 1 , $ poiAppid = null ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'poi_id' => intval ( $ poiId ) , ] ; if ( $ type === 2 ) { if ( is_null ( $ poiAppid ) ) { throw new InvalidArgumentException ( 'If value of argument #3 is 2, argument #4 is required.' ) ; } $ params [ 'type' ] = 2 ; $ params [ 'poi_appid' ] = $ poiAppid ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDLOCATION , $ params ] ) ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
1602	private function _getSocialFallback ( ) { $ image = null ; $ assets = \ Craft :: $ app -> assets ; $ fieldFallback = $ this -> _fieldSettings [ 'socialImage' ] ; if ( ! empty ( $ fieldFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ fieldFallback [ 0 ] ) ; else { $ seoFallback = $ this -> _seoSettings [ 'socialImage' ] ; if ( ! empty ( $ seoFallback ) ) $ image = $ assets -> getAssetById ( ( int ) $ seoFallback [ 0 ] ) ; } return [ 'title' => $ this -> title , 'description' => $ this -> description , 'image' => $ image , ] ; }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
5113	public function writeQTime ( $ timestamp ) { if ( $ timestamp instanceof \ DateTime ) { $ msec = $ timestamp -> format ( 'H' ) * 3600000 + $ timestamp -> format ( 'i' ) * 60000 + $ timestamp -> format ( 's' ) * 1000 + ( int ) ( $ timestamp -> format ( '0.u' ) * 1000 ) ; } else { $ msec = round ( ( $ timestamp - strtotime ( 'midnight' , ( int ) $ timestamp ) ) * 1000 ) ; } $ this -> writeUInt ( $ msec ) ; }
7102	public static function site ( string $ uri = '' , $ protocol = null ) : string { $ path = preg_replace ( '~^[-a-z0-9+.]++://[^/]++/?~' , '' , trim ( $ uri , '/' ) ) ; if ( preg_match ( '/[^\x00-\x7F]/S' , $ path ) ) { $ path = preg_replace_callback ( '~([^/]+)~' , '\mii\util\URL::_rawurlencode_callback' , $ path ) ; } return URL :: base ( $ protocol ) . $ path ; }
1483	public function register ( AbstractProvider $ provider ) { $ this -> resolver -> attach ( $ provider -> getResolver ( ) ) ; $ this -> errors = array_replace ( $ provider -> getErrors ( ) , $ this -> errors ) ; }
4078	protected function fetchInputScreenDetails ( ) { $ inputScreenIds = array ( ) ; foreach ( $ this -> information as $ info ) { $ inputScreenIds [ ] = $ info [ self :: COMBINATION ] [ 'dca_id' ] ; } if ( ! $ inputScreenIds ) { return ; } $ statement = $ this -> connection -> query ( sprintf ( 'SELECT * FROM tl_metamodel_dca WHERE id IN (%s)' , implode ( ',' , $ inputScreenIds ) ) ) ; while ( $ inputScreens = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ screenId = $ inputScreens -> id ; $ metaModelId = $ inputScreens -> pid ; $ metaModelName = $ this -> tableNameFromId ( $ metaModelId ) ; $ propertyRows = $ this -> connection -> prepare ( 'SELECT * FROM tl_metamodel_dcasetting WHERE pid=? AND published=1 ORDER BY sorting ASC' ) ; $ propertyRows -> bindValue ( 1 , $ screenId ) ; $ propertyRows -> execute ( ) ; $ conditions = $ this -> connection -> prepare ( ' SELECT cond.*, setting.attr_id AS setting_attr_id FROM tl_metamodel_dcasetting_condition AS cond LEFT JOIN tl_metamodel_dcasetting AS setting ON (cond.settingId=setting.id) LEFT JOIN tl_metamodel_dca AS dca ON (setting.pid=dca.id) WHERE dca.id=? AND setting.published=1 AND cond.enabled=1 ORDER BY sorting ASC ' ) ; $ conditions -> bindValue ( 1 , $ screenId ) ; $ conditions -> execute ( ) ; $ groupSort = $ this -> connection -> prepare ( ' SELECT * FROM tl_metamodel_dca_sortgroup WHERE pid=? ORDER BY sorting ASC ' ) ; $ groupSort -> bindValue ( 1 , $ screenId ) ; $ groupSort -> execute ( ) ; $ inputScreen = array ( 'row' => $ inputScreens -> row ( ) , 'properties' => $ propertyRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'conditions' => $ conditions -> fetchAll ( \ PDO :: FETCH_ASSOC ) , 'groupSort' => $ groupSort -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; $ this -> information [ $ metaModelName ] [ self :: INPUTSCREEN ] = $ inputScreen ; $ this -> information [ $ metaModelName ] [ self :: MODELID ] = $ metaModelId ; $ parentTable = $ inputScreen [ 'row' ] [ 'ptable' ] ; if ( $ parentTable && ! $ this -> isInputScreenStandalone ( $ metaModelName ) ) { $ this -> parentMap [ $ parentTable ] [ ] = $ this -> information [ $ metaModelName ] [ self :: MODELID ] ; $ this -> childMap [ $ metaModelName ] = $ parentTable ; } } }
3682	private function getFilterFactory ( ) : IFilterSettingFactory { if ( null === $ this -> filterFactory ) { return $ this -> filterFactory = System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ; } return $ this -> filterFactory ; }
6347	public static function all ( Iterator $ iterator , callable $ predicate ) : bool { while ( $ iterator -> valid ( ) ) { if ( ! Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return false ; } $ iterator -> next ( ) ; } return true ; }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
10911	public function marked ( Marker ... $ markers ) : Binding { if ( empty ( $ this -> definition -> markers ) ) { $ this -> definition -> markers = [ ] ; } foreach ( $ markers as $ marker ) { $ types = $ marker -> getAllowedTyes ( ) ; if ( empty ( $ types ) ) { $ this -> definition -> markers [ ] = $ marker ; continue ; } foreach ( $ types as $ type ) { if ( $ this -> definition -> typeName == $ type || \ is_subclass_of ( $ this -> definition -> typeName , $ type ) ) { $ this -> definition -> markers [ ] = $ marker ; continue 2 ; } } throw new \ RuntimeException ( \ vsprintf ( 'Type %s cannot be marked with %s, allowed types are [ %s ]' , [ $ this -> definition -> typeName , \ get_class ( $ marker ) , \ implode ( ', ' , $ types ) ] ) ) ; } return $ this ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
9971	public function shrinkRangeToFit ( $ range ) { $ maxCol = $ this -> getHighestColumn ( ) ; $ maxRow = $ this -> getHighestRow ( ) ; $ maxCol = Coordinate :: columnIndexFromString ( $ maxCol ) ; $ rangeBlocks = explode ( ' ' , $ range ) ; foreach ( $ rangeBlocks as & $ rangeSet ) { $ rangeBoundaries = Coordinate :: getRangeBoundaries ( $ rangeSet ) ; if ( Coordinate :: columnIndexFromString ( $ rangeBoundaries [ 0 ] [ 0 ] ) > $ maxCol ) { $ rangeBoundaries [ 0 ] [ 0 ] = Coordinate :: stringFromColumnIndex ( $ maxCol ) ; } if ( $ rangeBoundaries [ 0 ] [ 1 ] > $ maxRow ) { $ rangeBoundaries [ 0 ] [ 1 ] = $ maxRow ; } if ( Coordinate :: columnIndexFromString ( $ rangeBoundaries [ 1 ] [ 0 ] ) > $ maxCol ) { $ rangeBoundaries [ 1 ] [ 0 ] = Coordinate :: stringFromColumnIndex ( $ maxCol ) ; } if ( $ rangeBoundaries [ 1 ] [ 1 ] > $ maxRow ) { $ rangeBoundaries [ 1 ] [ 1 ] = $ maxRow ; } $ rangeSet = $ rangeBoundaries [ 0 ] [ 0 ] . $ rangeBoundaries [ 0 ] [ 1 ] . ':' . $ rangeBoundaries [ 1 ] [ 0 ] . $ rangeBoundaries [ 1 ] [ 1 ] ; } unset ( $ rangeSet ) ; $ stRange = implode ( ' ' , $ rangeBlocks ) ; return $ stRange ; }
369	public function getViewNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _viewNames [ $ schema ] ) || $ refresh ) { $ this -> _viewNames [ $ schema ] = $ this -> findViewNames ( $ schema ) ; } return $ this -> _viewNames [ $ schema ] ; }
2512	public function setStatus ( $ newStatus ) { if ( $ this -> isWorseStatus ( $ newStatus , $ this -> status ) ) { $ this -> status = $ newStatus ; } }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
12020	function addSetAPIMethod ( ) { $ methodGenerator = new MethodGenerator ( 'setAPI' ) ; $ methodGenerator -> setBody ( '$this->api = $api;' ) ; $ parameterGenerator = new ParameterGenerator ( 'api' , $ this -> apiClassname ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
2764	public function run ( string $ command , array $ argsAndOptions = [ ] , bool $ setDirectory = true ) : string { $ command = new GitCommand ( $ command , ... $ argsAndOptions ) ; if ( $ setDirectory ) { $ command -> setDirectory ( $ this -> directory ) ; } return $ this -> gitWrapper -> run ( $ command ) ; }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
7506	function setDoc ( $ doc , $ pos = 0 ) { $ this -> doc = $ doc ; $ this -> size = strlen ( $ doc ) ; $ this -> setPos ( $ pos ) ; }
5910	public function createSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'key' => $ key , 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/settings' , $ parameters ) ; return $ result ; }
12892	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'plugin' ) ) { return '' ; } $ wrapperClass = '' ; $ elementMarkup = '' ; $ templateMarkup = '' ; $ attributesString = '' ; $ label = '' ; if ( $ element instanceof CollectionElement && $ element -> shouldCreateTemplate ( ) ) { $ templateMarkup = $ this -> renderTemplate ( $ element ) ; } foreach ( $ element -> getIterator ( ) as $ elementOrFieldset ) { $ elementMarkup .= $ this -> renderElement ( $ elementOrFieldset ) ; } $ helperFormButtonIcon = $ this -> getFormButtonIconHelper ( ) ; $ helperLabel = $ this -> getLabelHelper ( ) ; $ elementMarkup .= sprintf ( $ this -> elementWrap , '' , $ helperFormButtonIcon ( new Button ( null , [ 'label' => 'Add New' , 'icon' => 'fa fa-plus-circle' ] ) ) , '' ) ; if ( $ this -> shouldWrap ) { $ attributes = $ element -> getAttributes ( ) ; if ( isset ( $ attributes [ 'class' ] ) ) { $ wrapperClass = $ attributes [ 'class' ] ; unset ( $ attributes [ 'class' ] ) ; } unset ( $ attributes [ 'name' ] ) ; $ attributesString = count ( $ attributes ) ? ' ' . $ this -> createAttributesString ( $ attributes ) : '' ; if ( ! empty ( $ element -> getLabel ( ) ) ) { $ label = $ helperLabel ( $ element ) ; } } return sprintf ( $ this -> wrapper , $ wrapperClass , $ attributesString , $ label , $ this -> horizontalWrapClass , $ elementMarkup , $ templateMarkup ) ; }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
8570	public function getLastUpdatedTimeForRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLastUpdatedTimeForRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7360	private function getInStock ( SaleItemInterface $ item ) { if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return INF ; } if ( ! $ subject instanceof StockSubjectInterface ) { return INF ; } if ( $ subject -> isStockCompound ( ) ) { return INF ; } if ( $ subject -> getStockMode ( ) === StockSubjectModes :: MODE_DISABLED ) { return INF ; } return $ subject -> getInStock ( ) ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
9768	function lengthOf ( int $ value = null ) : self { if ( $ value === null ) return $ this -> setFlag ( 'length' ) ; if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( $ value ) ; $ target = mb_strlen ( $ this -> target ) ; } else { $ constraint = countOf ( $ value ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
9755	function a ( string $ type = '' ) : self { return mb_strlen ( $ type ) ? $ this -> expect ( $ this -> target , isType ( $ type ) ) : $ this ; }
11815	protected function step2 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/requirements" ) ; $ this -> view -> setData ( "step" , "2" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Requirements" ) ) ; $ systemcheck = new Helpers \ Requirements ( ) ; $ requirements = [ ] ; $ directives = require_once ( PATH_CONFIG . '/requirements.inc' ) ; $ server = [ "title" => "Required Server Software" , "tests" => [ ] ] ; foreach ( $ directives [ "server" ] as $ name => $ directive ) { $ server [ "tests" ] [ ] = $ systemcheck -> testServerVersions ( $ name , $ directive ) ; } $ requirements [ ] = $ server ; $ modules = [ "title" => "Required Modules" , "tests" => [ ] ] ; foreach ( $ directives [ "modules" ] as $ name => $ directive ) { $ modules [ "tests" ] [ ] = $ systemcheck -> testModule ( $ name , $ directive ) ; } $ requirements [ ] = $ modules ; $ limits = [ "title" => "Required Resource Limits" , "tests" => [ ] ] ; foreach ( $ directives [ "limits" ] as $ name => $ directive ) { $ limits [ "tests" ] [ ] = $ systemcheck -> testLimit ( $ name , $ directive ) ; } $ requirements [ ] = $ limits ; $ directories = [ "title" => "Required Folder Permissions" , "tests" => [ ] ] ; foreach ( $ directives [ "directories" ] as $ name => $ directive ) { $ directories [ "tests" ] [ ] = $ systemcheck -> testFolderPermissions ( $ directive [ "path" ] , $ directive ) ; } $ requirements [ ] = $ directories ; $ this -> view -> setDataArray ( [ "requirements" => $ requirements ] ) ; return ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
427	public static function setInstance ( $ instance ) { if ( $ instance === null ) { unset ( Yii :: $ app -> loadedModules [ get_called_class ( ) ] ) ; } else { Yii :: $ app -> loadedModules [ get_class ( $ instance ) ] = $ instance ; } }
5162	public function attachGallery ( Gallery $ gallery ) : self { return $ this -> attach ( self :: ATTACHMENT_FIELD_GALLERY , $ this -> ensureOrder ( $ gallery , self :: ATTACHMENT_FIELD_GALLERY ) ) ; }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
11855	public function getUrlPath ( ) : ? string { $ uri = $ this -> getServerParam ( 'REQUEST_URI' , \ FILTER_SANITIZE_URL ) ; if ( ! is_null ( $ uri ) ) { return parse_url ( $ uri , \ PHP_URL_PATH ) ; } return null ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
1001	public static function doTypesOverlap ( Schema $ schema , CompositeType $ typeA , CompositeType $ typeB ) { if ( $ typeA === $ typeB ) { return true ; } if ( $ typeA instanceof AbstractType ) { if ( $ typeB instanceof AbstractType ) { foreach ( $ schema -> getPossibleTypes ( $ typeA ) as $ type ) { if ( $ schema -> isPossibleType ( $ typeB , $ type ) ) { return true ; } } return false ; } return $ schema -> isPossibleType ( $ typeA , $ typeB ) ; } if ( $ typeB instanceof AbstractType ) { return $ schema -> isPossibleType ( $ typeB , $ typeA ) ; } return false ; }
3107	public function getItemHrefIndex ( ) { if ( isset ( $ this -> state [ self :: VAR_HREF_INDEX ] ) ) { $ table = $ this -> state [ self :: VAR_HREF_INDEX ] ; } else { $ table = [ ] ; } return $ table ; }
6158	protected function renderItem ( $ link , $ template ) { if ( isset ( $ link [ 'label' ] ) ) { $ label = $ this -> encodeLabels ? Html :: encode ( $ link [ 'label' ] ) : $ link [ 'label' ] ; } else { throw new InvalidConfigException ( 'The "label" element is required for each link.' ) ; } if ( $ link [ 'options' ] [ 'class' ] ) { $ label = Html :: tag ( 'i' , '' , $ link [ 'options' ] ) . $ label ; } if ( isset ( $ link [ 'url' ] ) ) { return strtr ( $ template , [ '{link}' => Html :: a ( $ label , $ link [ 'url' ] ) ] ) ; } else { return strtr ( $ template , [ '{link}' => $ label ] ) ; } }
1547	public function registerCustom ( ) : void { if ( ! $ fn = $ this -> group ) { return ; } $ this -> router -> group ( [ ] , function ( ) use ( $ fn ) { $ fn ( new RouteRegistrar ( $ this -> router , [ 'controller' => $ this -> controller ( ) ] , [ self :: PARAM_RESOURCE_TYPE => $ this -> resourceType ] ) ) ; } ) ; }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
7139	protected function getGroupsForStep ( $ step ) { $ groups = [ 'Default' ] ; if ( $ step === static :: CHECKOUT_STEP ) { $ groups [ ] = 'Checkout' ; $ groups [ ] = 'Identity' ; $ groups [ ] = 'Availability' ; } elseif ( $ step === static :: SHIPMENT_STEP ) { $ groups [ ] = 'Availability' ; } return $ groups ; }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
2287	public static function findActiveByEmailAndUsername ( $ strEmail , $ strUsername = null , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "$t.email=? AND $t.login='1' AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.disable=''" ) ; if ( $ strUsername !== null ) { $ arrColumns [ ] = "$t.username=?" ; } return static :: findOneBy ( $ arrColumns , array ( $ strEmail , $ strUsername ) , $ arrOptions ) ; }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
11858	public function getHandler ( ) { if ( $ this -> pairedDataItem ) { if ( ! isset ( $ this -> primaryObject ) ) { return $ this -> pairedDataItem ; } elseif ( isset ( $ this -> companionObject ) ) { return static :: getHandlingObject ( $ this , $ this -> pairedDataItem ) ; } } return $ this ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
1963	public static function encodeUrl ( $ strUrl ) { if ( $ strUrl == '' ) { return '' ; } if ( $ strUrl == '#' || strncmp ( $ strUrl , '{{' , 2 ) === 0 ) { return $ strUrl ; } if ( strncmp ( $ strUrl , 'mailto:' , 7 ) === 0 ) { return static :: encodeEmail ( $ strUrl ) ; } $ arrUrl = parse_url ( $ strUrl ) ; if ( ! isset ( $ arrUrl [ 'scheme' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Expected a FQDN, got "%s"' , $ strUrl ) ) ; } if ( isset ( $ arrUrl [ 'scheme' ] ) ) { $ arrUrl [ 'scheme' ] .= ( ( substr ( $ strUrl , \ strlen ( $ arrUrl [ 'scheme' ] ) , 3 ) == '://' ) ? '://' : ':' ) ; } if ( isset ( $ arrUrl [ 'user' ] ) ) { $ arrUrl [ 'user' ] .= isset ( $ arrUrl [ 'pass' ] ) ? ':' : '@' ; } if ( isset ( $ arrUrl [ 'pass' ] ) ) { $ arrUrl [ 'pass' ] .= '@' ; } if ( isset ( $ arrUrl [ 'host' ] ) ) { $ arrUrl [ 'host' ] = static :: encode ( $ arrUrl [ 'host' ] ) ; } if ( isset ( $ arrUrl [ 'port' ] ) ) { $ arrUrl [ 'port' ] = ':' . $ arrUrl [ 'port' ] ; } if ( isset ( $ arrUrl [ 'query' ] ) ) { $ arrUrl [ 'query' ] = '?' . $ arrUrl [ 'query' ] ; } if ( isset ( $ arrUrl [ 'fragment' ] ) ) { $ arrUrl [ 'fragment' ] = '#' . $ arrUrl [ 'fragment' ] ; } $ strReturn = '' ; foreach ( array ( 'scheme' , 'user' , 'pass' , 'host' , 'port' , 'path' , 'query' , 'fragment' ) as $ key ) { if ( isset ( $ arrUrl [ $ key ] ) ) { $ strReturn .= $ arrUrl [ $ key ] ; } } return $ strReturn ; }
1580	public function withId ( ? string $ id ) : self { $ copy = clone $ this ; $ copy -> id = $ id ? : null ; $ copy -> normalize ( ) ; return $ copy ; }
4341	public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } \ uasort ( $ this -> data , function ( $ valA , $ valB ) { return ( $ valA [ 'totalTime' ] < $ valB [ 'totalTime' ] ) ? 1 : - 1 ; } ) ; $ data = \ array_map ( function ( $ row ) { $ row [ 'totalTime' ] = \ round ( $ row [ 'totalTime' ] , 6 ) ; $ row [ 'ownTime' ] = \ round ( $ row [ 'ownTime' ] , 6 ) ; return $ row ; } , $ this -> data ) ; $ this -> data = array ( ) ; $ this -> funcStack = array ( ) ; $ this -> isProfiling = false ; $ this -> rootStack = array ( ) ; return $ data ; }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
3142	public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; }
2968	protected function pickMetadata ( $ data ) { $ metadata = [ ] ; if ( ArrayUtils :: has ( $ data , 'rows' ) ) { $ metadata = ArrayUtils :: omit ( $ data , 'rows' ) ; } else if ( ArrayUtils :: has ( $ data , 'meta' ) ) { $ metadata = ArrayUtils :: get ( $ data , 'meta' ) ; } return new Entry ( $ metadata ) ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
10857	public function getMarked ( string $ marker ) : array { if ( ! \ is_subclass_of ( $ marker , Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } return \ array_map ( function ( array $ marked ) { return $ this -> shared [ $ marked [ 0 ] -> typeName ] ?? $ this -> get ( $ marked [ 0 ] -> typeName ) ; } , $ this -> marked [ $ marker ] ) ; }
11241	public function rule ( $ fieldName , $ checks , $ humanName = false ) { $ checkFailures = 0 ; if ( $ humanName == false ) { $ humanName = ucfirst ( $ fieldName ) ; } $ fieldData = $ this -> getValue ( $ fieldName ) ; if ( ! is_array ( $ checks ) ) { $ checks = explode ( '|' , $ checks ) ; } foreach ( $ checks as $ check ) { $ checkName = $ check ; if ( isset ( $ this -> customChecks -> $ check ) ) { $ customCheckDef = $ this -> customChecks -> $ check ; $ customType = $ customCheckDef [ 0 ] ; $ arguments = array ( $ fieldData , $ customCheckDef [ 1 ] , $ customCheckDef [ 2 ] , $ customCheckDef [ 3 ] , $ customCheckDef [ 4 ] ) ; $ checkResult = call_user_func_array ( array ( $ this , $ customType ) , $ arguments ) ; } else { $ checkArgs = explode ( '[' , $ check , 2 ) ; if ( count ( $ checkArgs ) > 1 ) { $ check = $ checkArgs [ 0 ] ; $ checkName = $ checkArgs [ 0 ] ; $ checkArgs [ 1 ] = '[' . $ checkArgs [ 1 ] ; $ args = array ( ) ; preg_match_all ( "/\[([^\]]*)\]/" , $ checkArgs [ 1 ] , $ args ) ; $ this -> matchedArg = $ args [ 1 ] [ 0 ] ; $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData , $ args [ 1 ] ) ; } else { $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData ) ; } } if ( $ checkResult == false ) { $ this -> errors [ ] = sprintf ( $ this -> lang -> $ checkName , $ humanName , $ this -> matchedArg ) ; $ this -> matchedArg = false ; $ checkFailures ++ ; } } return $ checkFailures == 0 ? true : false ; }
4896	public function start ( $ type = self :: TYPE_INFO , array $ options = array ( ) ) { if ( $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot start capture, there is already a capture running.' ) ; } $ this -> captureLock = true ; $ this -> captureType = $ type ; $ this -> captureOptions = $ options ; ob_start ( ) ; return $ this ; }
6043	public function addUsage ( $ sessionId , MediaUsage $ mediaUsage ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaUsage' => $ mediaUsage ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/usage' , $ parameters ) ; $ result = new MediaUsageResponse ( $ result ) ; return $ result ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
5510	public function expectAt ( $ timing , $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments at time' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments at time' ) ; $ args = $ this -> replaceWildcards ( $ args ) ; if ( ! isset ( $ this -> expected_args_at [ $ timing ] ) ) { $ this -> expected_args_at [ $ timing ] = array ( ) ; } $ method = strtolower ( $ method ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args_at [ $ timing ] [ $ method ] = new ParametersExpectation ( $ args , $ message ) ; }
9023	public function hasConfirmation ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> confirmationWords ) ) { $ result = true ; } } return $ result ; }
4726	private function getCachedPlural ( $ singular ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( isset ( $ this -> cache [ $ singular ] ) ) { return $ this -> cache [ $ singular ] ; } return false ; }
2020	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objFaq = FaqCategoryModel :: findAll ( ) ; if ( $ objFaq !== null ) { while ( $ objFaq -> next ( ) ) { if ( ! $ objFaq -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objFaq -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objFaq -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objFaq -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objFaq -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objFaq -> jumpTo ] ; $ objItems = FaqModel :: findPublishedByPid ( $ objFaq -> id ) ; if ( $ objItems !== null ) { while ( $ objItems -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItems -> alias ? : $ objItems -> id ) ) ; } } } } return $ arrPages ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
3352	public function getUserAgentHeader ( ) { $ userAgentName = $ this -> getUserAgentName ( ) ; if ( $ userAgentName ) { return $ userAgentName ; } $ userAgent = sprintf ( '%s/%s/%s (PHP/%s.%s.%s' , $ this -> getLibraryName ( ) , $ this -> getVersion ( ) , $ this -> getPublicKey ( ) , PHP_MAJOR_VERSION , PHP_MINOR_VERSION , PHP_RELEASE_VERSION ) ; $ framework = $ this -> getFramework ( ) ; if ( $ framework ) { $ userAgent .= '; ' . $ framework ; } $ extension = $ this -> getExtension ( ) ; if ( $ extension ) { $ userAgent .= '; ' . $ extension ; } $ userAgent .= ')' ; return $ userAgent ; }
2956	public function deviceClose ( ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { return true ; } if ( fclose ( $ this -> _dHandle ) ) { $ this -> _dHandle = null ; $ this -> _dState = SERIAL_DEVICE_SET ; return true ; } trigger_error ( "Unable to close the device" , E_USER_ERROR ) ; return false ; }
7116	public function watch ( Repository \ PaymentRepositoryInterface $ paymentRepository ) { if ( null === $ term = $ this -> termRepository -> findLongest ( ) ) { return false ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; $ fromDate = clone $ today ; $ fromDate -> modify ( '-1 year' ) ; $ states = [ Model \ PaymentStates :: STATE_AUTHORIZED , Model \ PaymentStates :: STATE_CAPTURED ] ; $ method = $ this -> methodRepository -> findOneBy ( [ 'factoryName' => Constants :: FACTORY_NAME , ] ) ; if ( ! $ method || ! $ method -> isOutstanding ( ) ) { return false ; } $ result = false ; $ payments = $ paymentRepository -> findByMethodAndStates ( $ method , $ states , $ fromDate ) ; foreach ( $ payments as $ payment ) { $ sale = $ payment -> getSale ( ) ; if ( null === $ date = $ sale -> getOutstandingDate ( ) ) { continue ; } $ diff = $ date -> diff ( $ today ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ payment -> setState ( Model \ PaymentStates :: STATE_EXPIRED ) ; $ this -> persist ( $ payment ) ; $ result = true ; } } return $ result ; }
6451	public function isLoggedIn ( ) { $ cookieName = session_name ( ) ; $ cookie = $ this -> getSession ( ) -> getCookie ( $ cookieName ) ; if ( null !== $ cookie ) { $ this -> getSession ( 'goutte' ) -> setCookie ( $ cookieName , $ cookie ) ; return true ; } return false ; }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
8092	static public function decode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( '/[1][a-zA-Z]|[2-9]|[a-zA-Z]|[0]/' , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { $ f = preg_match ( '/1([a-zA-Z])/' , $ i , $ v ) ; if ( $ f == true ) { $ i = $ o + array_search ( $ v [ 1 ] , $ k ) ; } else { $ i = array_search ( $ i , $ k ) ; } $ n .= $ i ; } return $ n ; }
1728	public function save ( ) { $ arrFields = $ this -> Database -> getFieldNames ( $ this -> strTable ) ; $ arrSet = array_intersect_key ( $ this -> arrData , array_flip ( $ arrFields ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " %s WHERE id=?" ) -> set ( $ arrSet ) -> execute ( $ this -> id ) ; }
2358	public function getBackendUsername ( ) : ? string { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof BackendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
7675	function TbsStoreGet ( $ idx , $ caller ) { $ this -> LastReadNotStored = false ; if ( $ idx === $ this -> TbsCurrIdx ) { return $ this -> TBS -> Source ; } elseif ( isset ( $ this -> TbsStoreLst [ $ idx ] ) ) { $ txt = $ this -> TbsStoreLst [ $ idx ] [ 'src' ] ; if ( $ caller === false ) $ this -> TbsStoreLst [ $ idx ] [ 'src' ] = '' ; return $ txt ; } else { $ this -> LastReadNotStored = true ; $ txt = $ this -> FileRead ( $ idx , true ) ; if ( $ this -> LastReadComp > 0 ) { if ( $ caller === false ) { return $ txt ; } else { return $ this -> RaiseError ( "(" . $ caller . ") unable to uncompress '" . $ this -> TbsGetFileName ( $ idx ) . "'." ) ; } } else { return $ txt ; } } }
6181	protected function getSeverity ( $ errorCode ) { if ( isset ( $ this -> severityMapping [ $ errorCode ] ) ) { return $ this -> severityMapping [ $ errorCode ] ; } else { return $ this -> severityMapping [ Logger :: ERROR ] ; } }
2240	public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; foreach ( TemplateLoader :: getPrefixedFiles ( $ strPrefix ) as $ strTemplate ) { $ arrTemplates [ $ strTemplate ] [ ] = 'root' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrCustomized = self :: braceGlob ( $ rootDir . '/templates/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrCustomized ) ) { foreach ( $ arrCustomized as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'global' ] ; } } if ( $ strPrefix != 'be_' && $ strPrefix != 'mail_' ) { try { $ objTheme = ThemeModel :: findAll ( array ( 'order' => 'name' ) ) ; } catch ( \ Exception $ e ) { $ objTheme = null ; } if ( $ objTheme !== null ) { while ( $ objTheme -> next ( ) ) { if ( $ objTheme -> templates != '' ) { $ arrThemeTemplates = self :: braceGlob ( $ rootDir . '/' . $ objTheme -> templates . '/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrThemeTemplates ) ) { foreach ( $ arrThemeTemplates as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ objTheme -> name ; } } } } } } foreach ( $ arrTemplates as $ k => $ v ) { $ v = array_filter ( $ v , function ( $ a ) { return $ a != 'root' ; } ) ; if ( empty ( $ v ) ) { $ arrTemplates [ $ k ] = $ k ; } else { $ arrTemplates [ $ k ] = $ k . ' (' . implode ( ', ' , $ v ) . ')' ; } } ksort ( $ arrTemplates ) ; return $ arrTemplates ; }
8233	public function getToken ( $ action = null , $ reuse = true ) { $ tokenStorage = $ this -> session -> get ( self :: SESSION_KEY , [ ] ) ; $ index = ( $ action ) ? $ action : self :: DEFAULT_SELECTOR ; if ( ! isset ( $ tokenStorage [ $ index ] ) ) { $ token = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenStorage [ $ index ] = array ( 'time' => time ( ) , 'token' => $ token ) ; } else { $ token = $ tokenStorage [ $ index ] [ 'token' ] ; $ tokenStorage [ $ index ] [ 'time' ] = time ( ) ; } $ tokenStorage [ $ index ] [ 'reuse' ] = $ reuse ; $ key = bin2hex ( random_bytes ( self :: TOKEN_SIZE ) ) ; $ tokenHMAC = $ this -> tokenHMAC ( $ token , $ key ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; return $ key . self :: TOKEN_DELIMTER . $ tokenHMAC ; }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
12561	public function send ( $ msgType , $ message , $ to = null ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> build ( ) ; $ api = is_array ( $ to ) ? self :: API_SEND_BY_OPENID : self :: API_SEND_BY_GROUP ; return $ this -> post ( $ api , $ message ) ; }
8976	public static function typeOf ( $ arg ) { if ( null === $ arg ) { return 'NULL' ; } if ( is_object ( $ arg ) ) { return get_class ( $ arg ) ; } return gettype ( $ arg ) ; }
832	private function fixParent ( Tokens $ tokens , $ classStart , $ classEnd ) { foreach ( $ tokens -> findGivenKind ( T_EXTENDS ) as $ index => $ token ) { $ parentIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ parentClass = $ tokens [ $ parentIndex ] -> getContent ( ) ; $ parentSeq = $ tokens -> findSequence ( [ [ T_STRING ] , [ T_DOUBLE_COLON ] , [ T_STRING , $ parentClass ] , '(' , ] , $ classStart , $ classEnd , [ 2 => false ] ) ; if ( null !== $ parentSeq ) { $ parentSeq = array_keys ( $ parentSeq ) ; if ( $ tokens [ $ parentSeq [ 0 ] ] -> equalsAny ( [ [ T_STRING , 'parent' ] , [ T_STRING , $ parentClass ] ] , false ) ) { $ tokens [ $ parentSeq [ 0 ] ] = new Token ( [ T_STRING , 'parent' ] ) ; $ tokens [ $ parentSeq [ 2 ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } } $ parentSeq = $ tokens -> findSequence ( [ [ T_VARIABLE , '$this' ] , [ T_OBJECT_OPERATOR ] , [ T_STRING , $ parentClass ] , '(' , ] , $ classStart , $ classEnd , [ 2 => false ] ) ; if ( null !== $ parentSeq ) { $ parentSeq = array_keys ( $ parentSeq ) ; $ tokens [ $ parentSeq [ 0 ] ] = new Token ( [ T_STRING , 'parent' , ] ) ; $ tokens [ $ parentSeq [ 1 ] ] = new Token ( [ T_DOUBLE_COLON , '::' , ] ) ; $ tokens [ $ parentSeq [ 2 ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } } }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
9657	public function mount ( $ prefix = null ) { if ( $ prefix ) { $ this -> router -> group ( [ 'prefix' => $ prefix ] , function ( ) { $ this -> registerRoutes ( ) ; } ) ; } else { $ this -> registerRoutes ( ) ; } }
1682	public function sessionField ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: post ( 'FORM_SUBMIT' ) == 'tl_user' ) { $ arrPurge = Contao \ Input :: post ( 'purge' ) ; if ( \ is_array ( $ arrPurge ) ) { $ this -> import ( 'Contao\Automator' , 'Automator' ) ; if ( \ in_array ( 'purge_session' , $ arrPurge ) ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ objSessionBag -> clear ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'sessionPurged' ] ) ; } if ( \ in_array ( 'purge_images' , $ arrPurge ) ) { $ this -> Automator -> purgeImageCache ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'htmlPurged' ] ) ; } if ( \ in_array ( 'purge_pages' , $ arrPurge ) ) { $ this -> Automator -> purgePageCache ( ) ; Contao \ Message :: addConfirmation ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'tempPurged' ] ) ; } } } return '<div class="widget"> <fieldset class="tl_checkbox_container"> <legend>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'session' ] [ 0 ] . '</legend> <input type="checkbox" id="check_all_purge" class="tl_checkbox" onclick="Backend.toggleCheckboxGroup(this, \'ctrl_purge\')"> <label for="check_all_purge" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label><br> <input type="checkbox" name="purge[]" id="opt_purge_0" class="tl_checkbox" value="purge_session" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_0">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'sessionLabel' ] . '</label><br> <input type="checkbox" name="purge[]" id="opt_purge_1" class="tl_checkbox" value="purge_images" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_1">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'htmlLabel' ] . '</label><br> <input type="checkbox" name="purge[]" id="opt_purge_2" class="tl_checkbox" value="purge_pages" onfocus="Backend.getScrollOffset()"> <label for="opt_purge_2">' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_user' ] [ 'tempLabel' ] . '</label> </fieldset>' . $ dc -> help ( ) . '</div>' ; }
4198	public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { $ event [ 'properties' ] [ 'length' ] = \ array_merge ( static :: $ basePropInfo , array ( 'type' => 'integer' , 'value' => $ obj -> length , ) ) ; } elseif ( $ obj instanceof \ Exception ) { if ( isset ( $ event [ 'properties' ] [ 'xdebug_message' ] ) ) { $ event [ 'properties' ] [ 'xdebug_message' ] [ 'isExcluded' ] = true ; } } elseif ( $ obj instanceof \ mysqli && ! $ event [ 'collectPropertyValues' ] ) { $ propsAlwaysAvail = array ( 'client_info' , 'client_version' , 'connect_errno' , 'connect_error' , 'errno' , 'error' , 'stat' ) ; $ reflectionObject = $ event [ 'reflector' ] ; foreach ( $ propsAlwaysAvail as $ name ) { $ reflectionProperty = $ reflectionObject -> getProperty ( $ name ) ; $ event [ 'properties' ] [ $ name ] [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } }
12207	public function refresh ( ) { if ( null === $ this -> options || null === $ this -> sourceDir ) { return ; } $ this -> render ( $ this -> sourceDir , $ this -> options , $ this -> username ) ; }
10951	private function validateCsrfTokenInternal ( $ token , $ trueToken ) { $ token = base64_decode ( str_replace ( '.' , '+' , $ token ) ) ; $ n = StringHelper :: byteLength ( $ token ) ; if ( $ n <= static :: CSRF_MASK_LENGTH ) { return false ; } $ mask = StringHelper :: byteSubstr ( $ token , 0 , static :: CSRF_MASK_LENGTH ) ; $ token = StringHelper :: byteSubstr ( $ token , static :: CSRF_MASK_LENGTH , $ n - static :: CSRF_MASK_LENGTH ) ; $ token = $ this -> xorTokens ( $ mask , $ token ) ; return $ token === $ trueToken ; }
9421	public function getContents ( ) { if ( is_null ( $ this -> stream ) || ! $ this -> isReadable ( ) ) { $ message = 'Could not get contents of stream' ; throw new \ RuntimeException ( $ message ) ; } return stream_get_contents ( $ this -> stream ) ; }
3529	public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
6462	public function add ( $ name , $ values , bool $ append = false ) : void { $ normalizedName = self :: normalizeHeaderName ( $ name ) ; if ( ! $ append || ! $ this -> containsKey ( $ normalizedName ) ) { parent :: add ( $ normalizedName , ( array ) $ values ) ; } else { $ currentValues = [ ] ; $ this -> tryGet ( $ normalizedName , $ currentValues ) ; parent :: add ( $ normalizedName , array_merge ( $ currentValues , ( array ) $ values ) ) ; } }
9459	public function getByIds ( array $ ids , $ page = 1 , $ per_page = 100 ) { return $ this -> getCollection ( 'tickets/show_many.json?ids=' . implode ( ',' , $ ids ) , 'tickets' , $ page , $ per_page ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
6486	public function createRequestFromSuperglobals ( array $ server ) : IHttpRequestMessage { $ method = $ server [ 'REQUEST_METHOD' ] ?? 'GET' ; if ( $ method === 'POST' && isset ( $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ) ) { $ method = $ server [ 'X-HTTP-METHOD-OVERRIDE' ] ; } $ uri = $ this -> createUriFromSuperglobals ( $ server ) ; $ headers = $ this -> createHeadersFromSuperglobals ( $ server ) ; $ body = new StreamBody ( new Stream ( fopen ( 'php://input' , 'rb' ) ) ) ; $ properties = $ this -> createProperties ( $ server ) ; return new Request ( $ method , $ uri , $ headers , $ body , $ properties ) ; }
9698	public function html ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; unset ( $ this -> params [ 'plaintext' ] ) ; return $ this -> generate ( ) ; }
10974	public function saveLocation ( $ runValidation = true , $ attributeNames = null ) { $ location = $ this -> location ; if ( $ location === null ) { $ location = new Location ( ) ; } $ location -> country_id = $ this -> country_id ; $ location -> region_id = $ this -> region_id ; $ location -> city_id = $ this -> city_id ; $ location -> state_id = $ this -> state_id ; $ location -> address = $ this -> address ; $ location -> postal_code = $ this -> postal_code ; $ location -> latitude = $ this -> latitude ; $ location -> longitude = $ this -> longitude ; if ( is_array ( $ attributeNames ) ) { $ attributesNames = array_intersect ( [ 'country_id' , 'region_id' , 'city_id' , 'state_id' , 'address' , 'postal_code' , 'latitude' , 'longitude' ] , $ attributesNames ) ; } if ( empty ( $ attributeNames ) ) { $ attributeNames = null ; } if ( $ location -> save ( $ runValidation , $ attributeNames ) === false ) { $ this -> addErrors ( $ location -> getErrors ( ) ) ; return false ; } $ this -> location_id = $ location -> id ; return true ; }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
10999	public function matchLocale ( $ locale ) { $ locale = Locale :: create ( $ locale ) ; if ( ! empty ( $ this -> redirect ) ) return false ; if ( $ locale === null ) return true ; foreach ( $ this -> locales as $ l ) if ( $ l -> getLocale ( ) == $ locale -> getLocale ( ) ) return true ; return false ; }
7463	private static function renderTemplate ( string $ __file__ , array $ data ) : string { ob_start ( ) ; extract ( $ data ) ; include $ __file__ ; return ob_get_clean ( ) ; }
5953	public function channelList ( array $ filter = array ( ) ) { if ( $ this -> channelList === null ) { $ channels = $ this -> request ( "channellist -topic -flags -voice -limits -icon" ) -> toAssocArray ( "cid" ) ; $ this -> channelList = array ( ) ; foreach ( $ channels as $ cid => $ channel ) { $ this -> channelList [ $ cid ] = new Channel ( $ this , $ channel ) ; } $ this -> resetNodeList ( ) ; } return $ this -> filterList ( $ this -> channelList , $ filter ) ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
6822	protected function getGoodAccountNumber ( TaxRuleInterface $ rule , float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_GOOD ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } if ( is_null ( $ account -> getTax ( ) ) ) { if ( $ rate == 0 ) { return $ account -> getNumber ( ) ; } continue ; } if ( 0 === bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { return $ account -> getNumber ( ) ; } } throw new LogicException ( sprintf ( "No goods account number configured for tax rule '%s' and tax rate %s (%s)" , $ rule -> getName ( ) , $ rate , $ origin ) ) ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
5494	public function findFirstAction ( $ parameters ) { $ slot = $ this -> findFirstSlot ( $ parameters ) ; if ( isset ( $ slot ) && isset ( $ slot [ 'content' ] ) ) { return $ slot [ 'content' ] ; } return ; }
4006	protected function createInstance ( CreateMetaModelEvent $ event , $ arrData ) { if ( ! $ this -> createInstanceViaLegacyFactory ( $ event , $ arrData ) ) { $ metaModel = new MetaModel ( $ arrData , $ this -> dispatcher , $ this -> database ) ; $ metaModel -> setServiceContainer ( function ( ) { return $ this -> getServiceContainer ( ) ; } , false ) ; $ event -> setMetaModel ( $ metaModel ) ; } if ( $ event -> getMetaModel ( ) ) { $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] = $ event -> getMetaModel ( ) ; $ this -> instancesById [ $ event -> getMetaModel ( ) -> get ( 'id' ) ] = $ event -> getMetaModel ( ) ; } }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
1116	public function newNestedSetQuery ( $ excludeDeleted = true ) { $ builder = $ this -> newQuery ( $ excludeDeleted ) -> orderBy ( $ this -> getQualifiedOrderColumnName ( ) ) ; if ( $ this -> isScoped ( ) ) { foreach ( $ this -> scoped as $ scopeFld ) $ builder -> where ( $ scopeFld , '=' , $ this -> $ scopeFld ) ; } return $ builder ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
12132	static public function addParams ( $ url , $ params ) { $ query = parse_url ( $ url , PHP_URL_QUERY ) ; $ separator = ( Text :: isEmpty ( $ query ) ? "?" : "&" ) ; return Text :: concat ( $ separator , $ url , http_build_query ( $ params ) ) ; }
9179	public function getDatabase ( ) { if ( $ useDbId = $ this -> getUseDbId ( ) ) { return $ this -> getDatabaseById ( $ useDbId ) ; } foreach ( $ this -> databases as $ database ) { if ( $ database -> isDefault ( ) ) { return $ database ; } } if ( $ this -> databases -> count ( ) > 0 ) { return $ this -> databases -> first ( ) ; } throw new \ Exception ( 'There is no database configuration available' ) ; }
9051	protected function getMessage ( $ level , $ message , array $ context = array ( ) ) : MemoryStream { self :: checkLevel ( $ level ) ; $ ms = new MemoryStream ( ) ; $ ms -> write ( strftime ( "%Y-%m-%d %H:%M:%S" , time ( ) ) ) ; $ ms -> interpolate ( "\t[{level}]: " , array ( 'level' => sprintf ( "%6.6s" , $ level ) ) ) ; $ ms -> interpolate ( $ message , $ context ) ; $ ms -> write ( "\n" ) ; return $ ms ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
12925	public function setSearch ( $ value ) { if ( ! is_object ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> searchClass ; } $ value = Yii :: createObject ( $ value ) ; } $ value -> dataSource = $ this ; $ this -> _search = $ value ; }
8485	public static function getCpuModel ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Name FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Name ; } return 'Unknown' ; }
1610	private function _isRedirectRegex ( $ uri ) { if ( preg_match ( '/\/(.*)\/([g|m|i|x|X|s|u|U|A|J|D]+)/m' , $ uri ) === 0 ) { $ i = preg_match_all ( '/(?<!\\\\)\?(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\?' , $ x , 1 ) ; } $ i = preg_match_all ( '/(?<!\\\\)\/(?![^(]*\))/' , $ uri , $ matches , PREG_OFFSET_CAPTURE ) ; while ( $ i -- ) { $ x = $ matches [ 0 ] [ $ i ] [ 1 ] ; $ uri = substr_replace ( $ uri , '\/' , $ x , 1 ) ; } } if ( @ preg_match ( $ uri , null ) === false ) $ uri = '/^' . $ uri . '$/i' ; if ( @ preg_match ( $ uri , null ) !== false ) return $ uri ; return false ; }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
2663	public function configureBackend ( $ params , $ version , $ old_name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend/' . str_replace ( ' ' , '%20' , $ old_name ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ params ) ; return $ result ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12311	private function detectMimeType ( $ file ) { $ fileParts = explode ( '.' , $ file ) ; $ extension = array_pop ( $ fileParts ) ; $ extension = strtolower ( $ extension ) ; if ( array_key_exists ( $ extension , $ this -> mimeTypes ) ) { return $ this -> mimeTypes [ $ extension ] ; } if ( function_exists ( 'finfo_open' ) ) { $ finfo = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mimeType = finfo_file ( $ finfo , $ file ) ; finfo_close ( $ finfo ) ; return $ mimeType ; } return 'application/octet-stream' ; }
7849	public function dispatchFrom ( $ command , ArrayAccess $ source , array $ extras = [ ] ) { $ this -> command = $ command ; $ this -> values = array_merge ( ( array ) $ source , $ extras ) ; return $ this -> dispatcher -> dispatch ( $ this -> marshal ( ) ) ; }
6138	protected function parseUri ( $ uriString = '' ) { $ status = @ preg_match ( "~^((//)([^/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?$~" , $ uriString , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> path = ( isset ( $ matches [ 4 ] ) ) ? $ matches [ 4 ] : '' ; $ this -> query = ( isset ( $ matches [ 6 ] ) ) ? $ matches [ 6 ] : '' ; $ this -> fragment = ( isset ( $ matches [ 8 ] ) ) ? $ matches [ 8 ] : '' ; $ status = @ preg_match ( "~^(([^:@]*)(:([^@]*))?@)?([^:]+)(:(.*))?$~" , ( isset ( $ matches [ 3 ] ) ) ? $ matches [ 3 ] : "" , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific authority decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> user = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : "" ; $ this -> pass = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : "" ; $ this -> host = isset ( $ matches [ 5 ] ) ? $ matches [ 5 ] : "" ; $ this -> port = isset ( $ matches [ 7 ] ) ? $ matches [ 7 ] : "" ; }
12460	private function getDefaultGroupsId ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ customFieldsGroupIds = $ em -> createQuery ( 'SELECT g.id FROM ' . 'ChillCustomFieldsBundle:CustomFieldsDefaultGroup d ' . 'JOIN d.customFieldsGroup g' ) -> getResult ( Query :: HYDRATE_SCALAR ) ; $ result = array ( ) ; foreach ( $ customFieldsGroupIds as $ row ) { $ result [ ] = $ row [ 'id' ] ; } return $ result ; }
12708	public static function runCommand ( string $ command , array $ arguments = null , array $ options = null ) : void { $ commandObject = new $ command ( $ arguments , $ options ) ; $ commandObject -> update ( $ arguments , $ options ) ; $ commandObject -> handle ( ) ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
12660	public function removeAll ( ) { $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> deleteFile ( $ this -> baseDir . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ this -> baseLang . '/' . $ this -> pageName . '.json' ) ; foreach ( $ this -> extraLangs as $ language ) { $ fs -> deleteFile ( $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ) ; $ fs -> deleteFile ( $ this -> outdatedDir . $ language . '/' . $ this -> pageName . '.json' ) ; } }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
3451	protected function recordThat ( AggregateChanged $ event ) : void { $ this -> version += 1 ; $ this -> recordedEvents [ ] = $ event -> withVersion ( $ this -> version ) ; $ this -> apply ( $ event ) ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
1219	private function debugRequest ( $ url , array $ headers , $ body ) { $ str = $ url . PHP_EOL ; $ str .= array_reduce ( array_keys ( $ headers ) , function ( $ str , $ key ) use ( $ headers ) { $ str .= $ key . ': ' . $ headers [ $ key ] . PHP_EOL ; return $ str ; } , '' ) ; $ str .= $ body ; $ this -> debug ( $ str ) ; }
4447	public function fromWorker ( string $ worker , string $ subTimeInterval = '' ) : array { try { $ now = new \ DateTime ( ) ; $ interval = date_interval_create_from_date_string ( $ subTimeInterval ) ; $ timestamp = $ now -> sub ( $ interval ) -> getTimestamp ( ) ; } catch ( \ Exception $ e ) { $ timestamp = - 1 ; } if ( $ subTimeInterval === '' || $ timestamp === - 1 ) { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker ) , true ) ? : [ ] ; } else { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker , $ timestamp ) , true ) ? : [ ] ; } return $ this -> multiget ( $ jids ) ; }
9240	public function renderLanguageSwitcher ( ) { return $ this -> _View -> element ( $ this -> config ( 'element' ) , [ 'availableLanguages' => $ this -> config ( 'availableLanguages' ) , 'displayNames' => $ this -> config ( 'displayNames' ) , 'imageMapping' => $ this -> config ( 'imageMapping' ) , 'renderToggleButtonDisplayName' => $ this -> config ( 'renderToggleButtonDisplayName' ) ] ) ; }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
2031	public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
574	public function unmaskToken ( $ maskedToken ) { $ decoded = StringHelper :: base64UrlDecode ( $ maskedToken ) ; $ length = StringHelper :: byteLength ( $ decoded ) / 2 ; if ( ! is_int ( $ length ) ) { return '' ; } return StringHelper :: byteSubstr ( $ decoded , $ length , $ length ) ^ StringHelper :: byteSubstr ( $ decoded , 0 , $ length ) ; }
11630	private function getTransactions ( $ turnover , $ dsEnd ) { $ dateApplied = $ this -> hlpPeriod -> getTimestampUpTo ( $ dsEnd ) ; $ result = $ this -> aPrepareTrans -> exec ( $ turnover , $ dateApplied ) ; return $ result ; }
9762	function empty ( ) : self { if ( is_object ( $ this -> target ) && ! ( $ this -> target instanceof \ Countable ) ) { $ constraint = countOf ( 0 ) ; $ target = get_object_vars ( $ this -> target ) ; } else if ( is_string ( $ this -> target ) ) { $ constraint = equalTo ( 0 ) ; $ target = $ this -> hasFlag ( 'file' ) ? @ filesize ( $ this -> target ) : mb_strlen ( $ this -> target ) ; } else { $ constraint = isEmpty ( ) ; $ target = $ this -> target ; } return $ this -> expect ( $ target , $ constraint ) ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
309	public function export ( ) { if ( empty ( $ this -> message [ 'subject' ] ) ) { $ this -> message [ 'subject' ] = 'Application Log' ; } $ messages = array_map ( [ $ this , 'formatMessage' ] , $ this -> messages ) ; $ body = wordwrap ( implode ( "\n" , $ messages ) , 70 ) ; $ message = $ this -> composeMessage ( $ body ) ; if ( ! $ message -> send ( $ this -> mailer ) ) { throw new LogRuntimeException ( 'Unable to export log through email!' ) ; } }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
4813	public function get ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> storage ) ? $ this -> storage [ $ name ] : $ default ; }
8864	public function augmentSQL ( SQLQuery & $ query ) { $ stage = Versioned :: current_stage ( ) ; if ( $ stage == 'Live' || ! Permission :: check ( "VIEW_DRAFT_CONTENT" ) ) { $ query -> addWhere ( "PublishDate < '" . Convert :: raw2sql ( SS_Datetime :: now ( ) ) . "'" ) ; } }
7164	private function buildSaleDiscountsLinesViews ( Model \ SaleInterface $ sale ) { if ( ! $ sale -> hasAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) ) { return ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ adjustment ) { $ this -> view -> addDiscount ( $ this -> buildDiscountLine ( $ adjustment ) ) ; } }
4069	public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { return ( strlen ( $ langCode ) == 2 ) ; } ) ) ) ; }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
8786	public function generate ( ) { foreach ( $ this -> commandList as $ key => $ value ) { $ this -> app -> add ( new $ value ) ; } foreach ( $ this -> migrationCommands as $ command ) { $ newCommand = new $ command ; $ newCommand -> setName ( "migration:" . $ newCommand -> getName ( ) ) ; $ this -> app -> add ( $ newCommand ) ; } }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
11949	protected function createBaseString ( Request $ request , array $ params ) { $ request = clone $ request ; $ uri = $ request -> getUri ( ) ; $ queryString = '' ; if ( $ questionMark = strpos ( $ uri , '?' ) ) { $ uri = substr ( $ uri , 0 , $ questionMark ) ; $ request -> setUri ( $ uri ) ; } $ query = http_build_query ( $ params , '' , '&' , PHP_QUERY_RFC3986 ) ; return strtoupper ( $ request -> getMethod ( ) ) . '&' . rawurlencode ( $ uri ) . '&' . rawurlencode ( $ query ) ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
10003	protected function removeRecursive ( $ path , $ pattern , Logger $ logger ) { if ( ! is_file ( $ path ) && ! is_dir ( $ path ) ) { $ logger -> log ( "$path is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ path ) ) { $ logger -> log ( "$path is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( ! is_writeable ( $ parent = dirname ( $ path ) ) ) { $ logger -> log ( "$parent is not writable, skipping." , Logger :: WARNING ) ; return ; } $ matchesPattern = ( ( $ pattern === null ) || ( preg_match ( $ pattern , basename ( $ path ) ) ) ) ; if ( is_file ( $ path ) ) { if ( $ matchesPattern ) { unlink ( $ path ) ; } return ; } $ dh = opendir ( $ path ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> removeRecursive ( $ path . '/' . $ file , ( $ matchesPattern ? null : $ pattern ) , $ logger ) ; } if ( $ matchesPattern ) { rmdir ( $ path ) ; } }
6397	private function addEvolution ( $ decoded_taf , $ evolution , $ result , $ entity_name ) { $ new_evolution = clone ( $ evolution ) ; $ new_evolution -> setEntity ( $ result [ $ entity_name ] ) ; if ( $ entity_name == 'visibility' && $ this -> with_cavok == true ) { $ new_evolution -> setCavok ( true ) ; } $ getter_name = 'get' . ucfirst ( $ entity_name ) ; $ setter_name = 'set' . ucfirst ( $ entity_name ) ; $ decoded_entity = $ decoded_taf -> $ getter_name ( ) ; if ( $ decoded_entity == null || $ entity_name == 'clouds' || $ entity_name == 'weatherPhenomenons' ) { $ decoded_entity = $ this -> instantiateEntity ( $ entity_name ) ; } $ decoded_entity -> addEvolution ( $ new_evolution ) ; if ( $ entity_name == 'clouds' ) { $ decoded_taf -> addCloud ( $ decoded_entity ) ; } elseif ( $ entity_name == 'weatherPhenomenons' ) { $ decoded_taf -> addWeatherPhenomenon ( $ decoded_entity ) ; } else { $ decoded_taf -> $ setter_name ( $ decoded_entity ) ; } }
7599	public function render ( $ sAlertMessage , $ aAlertAttributes = null , $ bDismissable = false ) { if ( ! is_scalar ( $ sAlertMessage ) ) { throw new InvalidArgumentException ( 'Alert message expects a scalar value, "' . gettype ( $ sAlertMessage ) . '" given' ) ; } if ( empty ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => 'alert' ) ; } elseif ( is_string ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => $ aAlertAttributes ) ; } elseif ( ! is_array ( $ aAlertAttributes ) ) { throw new InvalidArgumentException ( 'Alert attributes expects a string or an array, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } elseif ( empty ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute expects string, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)alert(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sAlertMessage = $ oTranslator -> translate ( $ sAlertMessage , $ this -> getTranslatorTextDomain ( ) ) ; } if ( $ bDismissable ) { $ sAlertMessage = static :: $ dismissButtonFormat . $ sAlertMessage ; if ( ! preg_match ( '/(\s|^)alert-dismissable(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert-dismissable' ; } } return sprintf ( static :: $ alertFormat , $ this -> createAttributesString ( $ aAlertAttributes ) , $ sAlertMessage ) ; }
10703	public function loadLanguage ( $ controller , $ language = 'en_US' , $ return = FALSE ) { $ langDirEvent = new GetLanguageDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_LANG_DIR , $ langDirEvent ) ; $ langDir = $ langDirEvent -> getLangDir ( ) ; $ retVal = FALSE ; if ( NULL === $ langDir ) { $ retVal = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ language . '_lang.php' ; if ( ! file_exists ( $ file ) ) { $ defaultLangEvent = new GetDefaultLanguageEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_DEFAULT_LANG , $ defaultLangEvent ) ; $ defaultLang = $ defaultLangEvent -> getDefaultLanguage ( ) ; if ( NULL === $ defaultLang ) { $ retval = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ defaultLang . '_lang.php' ; } } if ( NULL === $ file ) { throw new RawException ( 'Failed to load language file for ' . $ controller ) ; } $ lang = include_once $ file ; $ this -> language = array_merge ( $ this -> language , $ lang ) ; $ retVal = $ lang ; } return $ retVal ; }
6106	private function getGridClass ( ) { $ class = [ ] ; foreach ( $ this -> grid as $ grid ) { if ( ! isset ( $ grid [ 'type' ] ) || ! isset ( $ grid [ 'size' ] ) ) { throw new InvalidConfigException ( get_called_class ( ) . ' must have type and size.' ) ; } if ( ! isset ( $ grid [ 'positiontype' ] ) ) $ class [ ] = $ grid [ 'type' ] . $ grid [ 'size' ] ; else $ class [ ] = $ grid [ 'type' ] . $ grid [ 'positiontype' ] . '-' . $ grid [ 'size' ] ; } return implode ( ' ' , $ class ) ; }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
1487	public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; }
10941	public function getModifiedResponse ( Request $ request , $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { $ response = $ this -> getResponse ( $ params , $ lifetime , $ response ) ; if ( $ response -> isNotModified ( $ request ) ) { throw new NotModifiedException ( $ response ) ; } return $ response ; }
8348	public function setValue ( string $ v ) : string { if ( static :: isValid ( $ v ) === false ) { throw new BadUse ( '"' . $ v . '" is not recognized as a possible value' ) ; } $ this -> value = $ v ; }
12205	public function generate ( $ date = 'global' , Response $ response = null ) { if ( ! $ response ) $ response = new Response ; if ( $ this -> maxAge ) $ response -> setMaxAge ( $ this -> maxAge ) ; if ( $ this -> sharedMaxAge ) $ response -> setSharedMaxAge ( $ this -> sharedMaxAge ) ; if ( $ date instanceof \ DateTime ) { $ response -> setLastModified ( $ date ) ; } else { $ response -> setLastModified ( $ this -> manager -> getLastUpdate ( $ date ) ) ; } return $ response ; }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
4678	public function render ( string $ file , array $ data ) : void { if ( ! is_readable ( $ file ) ) { throw new Exception ( "Could not find template file: " . $ this -> template ) ; } $ di = $ this -> di ; $ app = null ; if ( $ di -> has ( "app" ) ) { $ app = $ di -> get ( "app" ) ; } extract ( $ data ) ; require $ file ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
6427	public function getUserProfile ( ) { $ client = $ this -> getClient ( ) ; $ client -> setAccessToken ( $ this -> access_token ) ; $ plus = new \ Google_Service_Plus ( $ client ) ; $ oauth2 = new \ Google_Service_Oauth2 ( $ client ) ; if ( $ client -> getAccessToken ( ) ) { $ user = $ oauth2 -> userinfo -> get ( ) ; if ( isset ( $ user -> id ) ) { $ name = $ user -> givenName ; if ( ! empty ( $ user -> familyName ) ) { $ name = $ user -> familyName . ' ' . $ user -> givenName ; } $ profile = array ( 'userid' => $ user -> id , 'name' => $ name , 'imageurl' => $ user -> picture , 'email' => $ user -> email ) ; return $ profile ; } } throw new \ Exception ( 'Can not get google profile' ) ; }
1709	public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; }
11133	protected function calculate ( ) { $ action = false ; $ actions = 0 ; if ( $ this -> delete ) { $ actions += 1 ; $ action = 'DELETE' ; } if ( ! empty ( $ this -> inserts ) ) { $ actions += 1 ; $ action = 'INSERT' ; } if ( ! empty ( $ this -> updates ) ) { $ actions += 1 ; $ action = 'UPDATE' ; } if ( ! empty ( $ this -> selects ) ) { $ actions += 1 ; $ action = 'SELECT' ; } if ( ! empty ( $ this -> create ) ) { $ actions += 1 ; $ action = 'CREATE' ; } if ( $ actions > 1 ) { throw new \ Exception ( "More than one query action specified! When using Cora's query builder class, only one type of query (select, update, delete, insert) can be done at a time." ) ; } else { $ calcMethod = 'calculate' . $ action ; $ this -> $ calcMethod ( ) ; } }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
4012	private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; if ( ( $ this -> calculatedLimit !== null ) && ( $ this -> calculatedTotal > $ this -> calculatedLimit ) ) { $ this -> calculatedTotal -= $ this -> calculatedLimit ; } $ this -> calculatedTotal -= $ this -> calculatedOffset ; $ page = $ this -> getCurrentPage ( ) ; if ( $ page > ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ) { $ page = ( int ) ceil ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ; } $ pageOffset = ( ( max ( $ page , 1 ) - 1 ) * $ this -> getPerPage ( ) ) ; $ this -> calculatedOffset += $ pageOffset ; if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = $ this -> getPerPage ( ) ; } else { $ this -> calculatedLimit = min ( ( $ this -> calculatedLimit - $ this -> calculatedOffset ) , $ this -> getPerPage ( ) ) ; } }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
9271	protected function setUri ( $ uriToSet ) { $ uri_parts = [ ] ; array_push ( $ uri_parts , 'api' ) ; array_push ( $ uri_parts , config ( 'ckan_api.api_version' ) ) ; array_push ( $ uri_parts , trim ( $ uriToSet , '/' ) ) ; $ uri_parts = array_filter ( $ uri_parts ) ; $ this -> uri = implode ( '/' , $ uri_parts ) ; }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
2704	public function getContentTypeOptions ( ) { $ contentTypes = [ self :: CONTENT_TYPE_HTML => __ ( 'HTML' ) , self :: CONTENT_TYPE_CSS => __ ( 'CSS' ) , self :: CONTENT_TYPE_JS => __ ( 'JavaScript' ) , self :: CONTENT_TYPE_IMAGE => __ ( 'Images' ) ] ; return $ contentTypes ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
4290	private function processExistingData ( ) { $ data = $ this -> debug -> getData ( ) ; $ channelName = $ this -> debug -> getCfg ( 'channel' ) ; foreach ( $ data [ 'alerts' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } foreach ( $ data [ 'logSummary' ] as $ priority => $ entries ) { $ this -> processLogEntryWEvent ( 'groupSummary' , array ( ) , array ( 'channel' => $ channelName , 'priority' => $ priority , ) ) ; foreach ( $ entries as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } $ this -> processLogEntryWEvent ( 'groupEnd' , array ( ) , array ( 'channel' => $ channelName , 'closesSummary' => true , ) ) ; } foreach ( $ data [ 'log' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
2556	protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; }
414	public function setSecurePort ( $ value ) { if ( $ value != $ this -> _securePort ) { $ this -> _securePort = ( int ) $ value ; $ this -> _hostInfo = null ; } }
10780	private function addCacheLimiterHeaders ( ResponseInterface $ response ) : ResponseInterface { $ cache = new CacheUtil ( ) ; switch ( session_cache_limiter ( ) ) { case 'public' : $ response = $ cache -> withExpires ( $ response , time ( ) + session_cache_limiter ( ) * 60 ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPublic ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private_no_expire' : $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'private' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withMaxAge ( session_cache_limiter ( ) * 60 ) ) ; break ; case 'nocache' : $ response = $ cache -> withExpires ( $ response , 'Thu, 19 Nov 1981 08:52:00 GMT' ) ; $ response = $ cache -> withCacheControl ( $ response , ( new ResponseCacheControl ( ) ) -> withPrivate ( ) -> withCachePrevention ( ) ) ; $ response = $ response -> withHeader ( "Pragma" , "no-cache" ) ; break ; } return $ response ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3678	public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; }
7989	public function getTemplateProperties ( $ domain , $ templateId ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ templateId = ( string ) $ templateId ; if ( ! $ templateId ) throw new BadMethodCallException ( "Parameter $templateId is missing" ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/templates/' . $ templateId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( ) ; }
3647	protected function process ( string $ value , bool $ trim = true , bool $ clean = true ) { if ( $ trim ) { $ value = trim ( $ value ) ; } if ( $ clean ) { $ value = $ this -> security -> clean ( $ value ) ; } return $ value ; }
592	public function combineJsFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; foreach ( $ inputFiles as $ file ) { $ fileContent = rtrim ( file_get_contents ( $ file ) ) ; if ( substr ( $ fileContent , - 1 ) !== ';' ) { $ fileContent .= "\n;" ; } $ content .= "/*** BEGIN FILE: $file ***/\n" . $ fileContent . "\n" . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output JavaScript file '{$outputFile}'." ) ; } }
526	public function init ( ) { if ( $ this -> sourcePath !== null ) { $ this -> sourcePath = rtrim ( Yii :: getAlias ( $ this -> sourcePath ) , '/\\' ) ; } if ( $ this -> basePath !== null ) { $ this -> basePath = rtrim ( Yii :: getAlias ( $ this -> basePath ) , '/\\' ) ; } if ( $ this -> baseUrl !== null ) { $ this -> baseUrl = rtrim ( Yii :: getAlias ( $ this -> baseUrl ) , '/' ) ; } }
11403	public function getAppCodeUnlimit ( $ scene , $ width = 430 , $ autoColor = false , $ lineColor = [ 'r' => 0 , 'g' => 0 , 'b' => 0 ] ) { $ params = [ 'scene' => $ scene , 'width' => $ width , 'auto_color' => $ autoColor , 'line_color' => $ lineColor , ] ; return $ this -> getStream ( self :: API_GET_WXACODE_UNLIMIT , $ params ) ; }
9184	protected function getRememberKey ( ) { $ backtrace = debug_backtrace ( 4 ) [ 2 ] ; $ args = implode ( '_' , $ backtrace [ 'args' ] ) ; $ key = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ backtrace [ 'function' ] . '_' . $ args ) ; return $ key ; }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
4197	public function onStart ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DateTime || $ obj instanceof \ DateTimeImmutable ) { $ event [ 'stringified' ] = $ obj -> format ( \ DateTime :: ISO8601 ) ; } elseif ( $ obj instanceof \ mysqli && ( $ obj -> connect_errno || ! $ obj -> stat ) ) { $ event [ 'collectPropertyValues' ] = false ; } }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
9049	private function renderButtons ( $ rendered , $ buttons ) { foreach ( $ buttons as $ button ) { if ( ! isset ( $ button [ 'name' ] ) ) { throw new ControlException ( "Button must have at least a name!" ) ; } $ buttonType = isset ( $ button [ 'type' ] ) ? $ button [ 'type' ] : "submit" ; $ id = isset ( $ button [ 'id' ] ) ? $ button [ 'id' ] : $ button [ 'name' ] ; $ class = isset ( $ button [ 'class' ] ) ? $ button [ 'class' ] : $ button [ 'name' ] ; $ label = isset ( $ button [ 'label' ] ) ? $ button [ 'label' ] : $ button [ 'name' ] ; $ rendered .= sprintf ( '<button type="%s" id="%s" class="%s" name="%s">%s</button>' , $ buttonType , $ id , $ class , $ button [ 'name' ] , $ label ) ; } return $ rendered ; }
9990	private function writeImageInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getDrawingCollection ( ) as $ drawing ) { if ( $ drawing instanceof Drawing ) { if ( $ drawing -> getCoordinates ( ) == $ coordinates ) { $ filename = $ drawing -> getPath ( ) ; if ( substr ( $ filename , 0 , 1 ) == '.' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = $ this -> getImagesRoot ( ) . $ filename ; if ( substr ( $ filename , 0 , 1 ) == '.' && substr ( $ filename , 0 , 2 ) != './' ) { $ filename = substr ( $ filename , 1 ) ; } $ filename = htmlspecialchars ( $ filename ) ; $ html .= PHP_EOL ; if ( ( ! $ this -> embedImages ) || ( $ this -> isPdf ) ) { $ imageData = $ filename ; } else { $ imageDetails = getimagesize ( $ filename ) ; if ( $ fp = fopen ( $ filename , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ filename ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; } else { $ imageData = $ filename ; } } $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ drawing -> getOffsetX ( ) . 'px; top: ' . $ drawing -> getOffsetY ( ) . 'px; width: ' . $ drawing -> getWidth ( ) . 'px; height: ' . $ drawing -> getHeight ( ) . 'px;" src="' . $ imageData . '" border="0" />' ; $ html .= '</div>' ; } } elseif ( $ drawing instanceof MemoryDrawing ) { if ( $ drawing -> getCoordinates ( ) != $ coordinates ) { continue ; } ob_start ( ) ; imagepng ( $ drawing -> getImageResource ( ) ) ; $ contents = ob_get_contents ( ) ; ob_end_clean ( ) ; $ dataUri = 'data:image/jpeg;base64,' . base64_encode ( $ contents ) ; $ html .= '<img src="' . $ dataUri . '" style="max-width:100%;width:' . $ drawing -> getWidth ( ) . 'px;" />' ; } } return $ html ; }
3431	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'SectionQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getCount ( $ filter ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
233	public function quoteSimpleTableName ( $ name ) { if ( is_string ( $ this -> tableQuoteCharacter ) ) { $ startingCharacter = $ endingCharacter = $ this -> tableQuoteCharacter ; } else { list ( $ startingCharacter , $ endingCharacter ) = $ this -> tableQuoteCharacter ; } return strpos ( $ name , $ startingCharacter ) !== false ? $ name : $ startingCharacter . $ name . $ endingCharacter ; }
8468	public static function getActiveHandlersList ( ) { $ cacheKey = 'DevGroup/EventsSystem:activeHandlersList' ; $ handlers = Yii :: $ app -> cache -> get ( $ cacheKey ) ; if ( $ handlers === false ) { $ eventEventHandlers = EventEventHandler :: find ( ) -> where ( [ 'is_active' => 1 ] ) -> orderBy ( [ 'sort_order' => SORT_ASC ] ) -> asArray ( true ) -> all ( ) ; $ events = Event :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_id' , 'event_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventGroups = EventGroup :: find ( ) -> where ( [ 'id' => array_column ( $ events , 'event_group_id' , 'event_group_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ eventHandlers = EventHandler :: find ( ) -> where ( [ 'id' => array_column ( $ eventEventHandlers , 'event_handler_id' , 'event_handler_id' ) ] ) -> indexBy ( 'id' ) -> asArray ( true ) -> all ( ) ; $ handlers = [ ] ; foreach ( $ eventEventHandlers as $ eventEventHandler ) { if ( isset ( $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] , $ events [ $ eventEventHandler [ 'event_id' ] ] , $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] ) === false ) { continue ; } try { $ data = Json :: decode ( $ eventEventHandler [ 'packed_json_params' ] ) ; } catch ( \ Exception $ e ) { $ data = [ ] ; } $ handlers [ ] = [ 'class' => $ eventGroups [ $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'event_group_id' ] ] [ 'owner_class_name' ] , 'name' => $ events [ $ eventEventHandler [ 'event_id' ] ] [ 'execution_point' ] , 'callable' => [ $ eventHandlers [ $ eventEventHandler [ 'event_handler_id' ] ] [ 'class_name' ] , $ eventEventHandler [ 'method' ] , ] , 'data' => $ data , ] ; } Yii :: $ app -> cache -> set ( $ cacheKey , $ handlers , 86400 , new TagDependency ( [ 'tags' => [ NamingHelper :: getCommonTag ( EventGroup :: className ( ) ) , NamingHelper :: getCommonTag ( Event :: className ( ) ) , NamingHelper :: getCommonTag ( EventHandler :: className ( ) ) , NamingHelper :: getCommonTag ( EventEventHandler :: className ( ) ) , ] , ] ) ) ; } return $ handlers ; }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
6482	public function assertNoErrorMessages ( ) { foreach ( $ this -> getMessagesContainers ( 'error' ) as $ element ) { $ text = trim ( $ element -> getText ( ) ) ; if ( '' !== $ text ) { throw new \ RuntimeException ( sprintf ( 'The page "%s" contains following error messages: "%s".' , self :: $ pageUrl , $ text ) ) ; } } foreach ( $ this -> getSession ( ) -> getPage ( ) -> findAll ( 'css' , 'input, select, textarea' ) as $ formElement ) { if ( $ formElement -> hasClass ( 'error' ) ) { throw new \ Exception ( sprintf ( 'Element "#%s" has an error class.' , $ formElement -> getAttribute ( 'id' ) ) ) ; } } }
4821	public function getAsArray ( $ fieldName ) { if ( ! array_key_exists ( $ fieldName , $ this -> row ) ) { return [ ] ; } $ result = $ this -> row [ $ fieldName ] ; if ( empty ( $ result ) ) { return [ ] ; } return ( array ) $ result ; }
9550	public function getPdo ( ) { if ( empty ( $ this -> pdo ) ) { $ this -> pdo = new PDO ( sprintf ( "mysql:host=%s;port=%d" , $ this -> host , $ this -> port ) ) ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; } return $ this -> pdo ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
3405	public function timeout ( int $ timeout ) : bool { $ application = $ this -> getApplication ( ) ; if ( ! $ application instanceof Application ) { return false ; } if ( ! $ application -> timeLimit ( ) ) { return false ; } $ endTime = $ this -> startTime + $ timeout ; return ( time ( ) > $ endTime ) ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
312	public function run ( ) { try { $ this -> state = self :: STATE_BEFORE_REQUEST ; $ this -> trigger ( self :: EVENT_BEFORE_REQUEST ) ; $ this -> state = self :: STATE_HANDLING_REQUEST ; $ response = $ this -> handleRequest ( $ this -> getRequest ( ) ) ; $ this -> state = self :: STATE_AFTER_REQUEST ; $ this -> trigger ( self :: EVENT_AFTER_REQUEST ) ; $ this -> state = self :: STATE_SENDING_RESPONSE ; $ response -> send ( ) ; $ this -> state = self :: STATE_END ; return $ response -> exitStatus ; } catch ( ExitException $ e ) { $ this -> end ( $ e -> statusCode , isset ( $ response ) ? $ response : null ) ; return $ e -> statusCode ; } }
4029	protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; }
3415	public function update ( array $ fields = [ ] ) { $ keys = [ ] ; foreach ( $ fields as $ key => $ value ) { array_set ( $ this -> fields , $ key , $ value ) ; $ keys [ ] = $ key ; } return $ this -> save ( $ keys ) ; }
6886	public function lookupPostcodeMetadata ( $ postcode ) { $ path = sprintf ( self :: PATH_LOOKUP_METADATA , $ postcode ) ; $ response = $ this -> httpGet ( $ path ) ; return Response \ PostcodeInfo :: buildFromResponse ( $ response ) ; }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
9939	public function addChart ( Chart $ pChart , $ iChartIndex = null ) { $ pChart -> setWorksheet ( $ this ) ; if ( $ iChartIndex === null ) { $ this -> chartCollection [ ] = $ pChart ; } else { array_splice ( $ this -> chartCollection , $ iChartIndex , 0 , [ $ pChart ] ) ; } return $ pChart ; }
10172	function toString ( ) { $ customfields = "" ; if ( isset ( $ this -> custom_fields ) ) { foreach ( $ this -> custom_fields as $ index => $ type ) { $ customfields .= $ index . "=" . $ type . ", " ; } $ customfields = rtrim ( $ customfields , ', ' ) ; } return "CustomFields = {" . $ customfields . "}" ; }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
1603	private function _getVariables ( ) { $ variables = $ this -> _overrideObject ; if ( $ this -> _element !== null ) { foreach ( $ this -> _element -> attributes ( ) as $ name ) if ( $ name !== $ this -> _handle ) $ variables [ $ name ] = $ this -> _element -> $ name ; $ variables = array_merge ( $ variables , $ this -> _element -> toArray ( $ this -> _element -> extraFields ( ) ) ) ; } return $ variables ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
2597	public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; }
1229	private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; }
3837	private function getBaseDefinition ( ) { $ this -> setLanguageStrings ( ) ; $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; $ definition = array ( ) ; if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ) ) { $ definition = $ GLOBALS [ 'TL_DCA' ] [ $ tableName ] [ 'fields' ] [ $ this -> getColName ( ) ] ; } return array_replace_recursive ( array ( 'label' => & $ GLOBALS [ 'TL_LANG' ] [ $ tableName ] [ $ this -> getColName ( ) ] , 'eval' => array ( ) ) , $ definition ) ; }
3295	protected function getFingers ( Lead $ lead ) { $ fingers = [ ] ; if ( $ lead -> getEmail ( ) ) { $ fingers [ 'email' ] = strtolower ( $ lead -> getEmail ( ) ) ; } if ( $ lead -> getPhone ( ) ) { $ fingers [ 'phone' ] = preg_replace ( '/\D/' , '' , $ lead -> getPhone ( ) ) ; } if ( $ lead -> getMobile ( ) ) { $ fingers [ 'mobile' ] = preg_replace ( '/\D/' , '' , $ lead -> getMobile ( ) ) ; } return $ fingers ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
3810	protected function translateRows ( $ rows ) { $ metaModel = $ this -> getMetaModel ( ) ; $ activeLegend = $ this -> translateLegend ( array ( 'legendtitle' => $ metaModel -> getName ( ) , 'legendhide' => false ) , $ metaModel ) ; $ activeLegendId = null ; $ columnNames = array ( ) ; foreach ( $ rows as $ row ) { if ( $ row [ 'dcatype' ] != 'attribute' ) { continue ; } $ attribute = $ metaModel -> getAttributeById ( $ row [ 'attr_id' ] ) ; if ( $ attribute ) { $ columnNames [ $ row [ 'id' ] ] = $ attribute -> getColName ( ) ; } } $ this -> propertyMap = $ columnNames ; $ this -> propertyMap2 = array_flip ( $ columnNames ) ; foreach ( $ rows as $ row ) { switch ( $ row [ 'dcatype' ] ) { case 'legend' : $ activeLegend = $ this -> translateLegend ( $ row , $ metaModel ) ; $ activeLegendId = $ row [ 'id' ] ; break ; case 'attribute' : $ exists = $ this -> translateProperty ( $ row , $ metaModel , $ activeLegend ) ; if ( $ exists && $ activeLegendId ) { $ this -> applyLegendConditions ( $ row [ 'id' ] , $ activeLegendId ) ; } break ; default : throw new \ RuntimeException ( 'Unknown palette rendering mode ' . $ row [ 'dcatype' ] ) ; } } }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
8315	protected function checkResetLink ( ) { if ( ! $ this -> config [ "enabled" ] || ! ( $ token = $ this -> httpRequest -> query -> get ( "confirm" , false ) ) || ! preg_match ( "/^[a-f0-9]+$/" , $ token ) || strlen ( $ token ) !== 2 * ( $ this -> config [ "tokenIdLen" ] + $ this -> config [ "tokenLen" ] ) ) { return ; } $ this -> session -> remove ( "pwreset" ) ; $ tokenId = substr ( $ token , 0 , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ verifier = substr ( $ token , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ tokenData = $ this -> storage -> getResetToken ( $ tokenId ) ; if ( ! $ tokenData || time ( ) > $ tokenData [ 'valid' ] ) { $ this -> session -> addFlash ( "error" , "Reset link has expired." ) ; $ this -> getLogger ( ) -> warning ( "Bad reset token {t} from {addr}" , [ $ token , $ _SERVER [ 'REMOTE_ADDR' ] ] ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( hash_equals ( $ tokenData [ 'token' ] , hash ( 'sha256' , $ verifier ) ) ) { $ this -> session -> addFlash ( "success" , "Please set a new password." ) ; $ this -> startPasswordResetSession ( $ tokenData [ 'user' ] ) ; $ this -> logResetLinkVisit ( $ tokenData ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
3880	private function getJumpToLabel ( ) { $ tableName = $ this -> metaModel -> getTableName ( ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'details' ] ; }
6185	public function clear ( $ type = 'all' ) { if ( $ type === 'all' ) { $ this -> driver -> remove ( 'flash_messages' ) ; } else { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; unset ( $ flashMessages [ $ type ] ) ; $ this -> driver -> set ( 'flash_messages' , $ flashMessages ) ; } return true ; }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
5664	private function collectFrames ( $ node ) { $ frames = array ( ) ; if ( $ node -> name === 'frame' ) { $ frames = array ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) ) ; } elseif ( $ node -> hasChildren ( ) ) { $ frames = array ( ) ; foreach ( $ node -> child as $ child ) { $ frames = array_merge ( $ frames , $ this -> collectFrames ( $ child ) ) ; } } return $ frames ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
8421	private function getTexture ( ) { if ( isset ( $ this -> model ) ) { $ texture = $ this -> attribute ; if ( isset ( $ this -> model -> $ texture ) ) { return $ this -> model -> $ texture ; } } if ( isset ( $ this -> texture ) ) { return $ this -> texture ; } return $ this -> default ; }
2594	protected function loadCurrencyOverride ( $ currency ) { if ( is_string ( $ currency ) && strlen ( $ currency ) === 3 ) { $ this -> addPriceType ( PricingTicketing :: PRICETYPE_OVERRIDE_CURRENCY_CONVERSION ) ; $ this -> conversionRate = new ConversionRate ( $ currency ) ; } }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
1567	public function getType ( ) : string { if ( $ resource = $ this -> getResource ( ) ) { return get_class ( $ resource ) ; } $ resourceType = $ this -> getResourceType ( ) ; if ( ! $ type = $ this -> resolver -> getType ( $ resourceType ) ) { throw new RuntimeException ( "JSON API resource type {$resourceType} is not registered." ) ; } return $ type ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
6450	private function getLanguageValuesFromHeaders ( array $ headers ) : array { $ languages = [ ] ; foreach ( $ headers as $ header ) { $ languages [ ] = $ header -> getLanguage ( ) ; } return $ languages ; }
3686	protected function getAndOrFilter ( IFilter $ filter , $ operation ) { if ( ! $ operation [ 'children' ] ) { return ; } if ( $ operation [ 'operation' ] == 'AND' ) { $ filterRule = new ConditionAnd ( ) ; } else { $ filterRule = new ConditionOr ( ) ; } $ filter -> addFilterRule ( $ filterRule ) ; $ children = $ this -> optimizedFilter ( $ filterRule , $ operation [ 'children' ] , $ operation [ 'operation' ] ) ; foreach ( $ children as $ child ) { $ subFilter = $ this -> getMetaModel ( ) -> getEmptyFilter ( ) ; $ filterRule -> addChild ( $ subFilter ) ; $ this -> calculateSubfilter ( $ child , $ subFilter ) ; } }
12316	public function editAction ( Request $ request , Category $ category ) { $ deleteForm = $ this -> createDeleteForm ( $ category ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.edited' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'entity' => $ category , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
3694	public function getBreadcrumb ( GetBreadcrumbEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ elements = $ this -> storeFactory -> createStore ( ) ; $ this -> getBreadcrumbElements ( $ environment , $ elements ) ; $ event -> setElements ( $ elements -> getElements ( ) ) ; $ event -> stopPropagation ( ) ; }
5988	public function setUpdatedRange ( $ updatedRange ) { if ( $ updatedRange instanceof DateTimeRange ) { $ this -> updatedRange = $ updatedRange ; } elseif ( is_array ( $ updatedRange ) ) { $ this -> updatedRange = new DateTimeRange ( $ updatedRange ) ; } else { $ this -> updatedRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
3445	private function getAccessor ( $ field ) { $ method = 'get' . camel_case ( $ field ) . 'Attribute' ; return method_exists ( $ this , $ method ) ? $ method : false ; }
8959	private function prepareArrayParameter ( $ name ) { if ( isset ( $ this -> parameters [ $ name ] ) ) { $ parameterArray = $ this -> parameters [ $ name ] ; $ count = count ( $ parameterArray ) ; $ str = "['" . $ parameterArray [ 0 ] . "'" ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ str .= ", '" . $ parameterArray [ $ i ] . "'" ; } $ str .= ']' ; return $ str ; } }
7094	private function loadItem ( Model \ SaleItemInterface $ item ) { $ item -> getAdjustments ( ) -> toArray ( ) ; $ children = $ item -> getChildren ( ) -> toArray ( ) ; foreach ( $ children as $ child ) { $ this -> loadItem ( $ child ) ; } }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
1467	public static function doesResponseHaveBody ( $ request , $ response ) { if ( 'HEAD' === strtoupper ( $ request -> getMethod ( ) ) ) { return false ; } $ status = $ response -> getStatusCode ( ) ; if ( ( 100 <= $ status && 200 > $ status ) || 204 === $ status || 304 === $ status ) { return false ; } if ( self :: hasHeader ( $ response , 'Transfer-Encoding' ) ) { return true ; } ; if ( ! $ contentLength = self :: getHeader ( $ response , 'Content-Length' ) ) { return false ; } return 0 < $ contentLength [ 0 ] ; }
7450	public function useQueue ( int $ msgkey = 0 , int $ mode = 2 ) { $ this -> process -> useQueue ( $ msgkey , $ mode ) ; }
8698	public function attr ( $ attrKey , $ attrValue = null ) { if ( ! is_null ( $ attrValue ) ) { if ( ! is_array ( $ this -> attributes ) ) { $ this -> attributes = array ( ) ; } $ this -> attributes [ $ attrKey ] = $ attrValue ; return $ this ; } else { if ( array_key_exists ( $ attrKey , $ this -> attributes ) ) { return $ this -> attributes [ $ attrKey ] ; } else { return null ; } } }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
8827	public function token ( ) { $ token = ! empty ( $ this -> csrfToken ) ? $ this -> csrfToken : csrfToken ( ) ; return $ this -> hidden ( '_token' , $ token ) ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
5762	public function indexView ( Response $ response , ? array $ displayItems = null ) { if ( $ displayItems === null ) { $ displayItems = $ this -> getDisplayItems ( ) ; } $ filterErrorMessage = FormHelper :: getFieldError ( $ this -> sessionFilterFieldKey ) ; FormHelper :: unsetSessionFormErrors ( ) ; return $ this -> view -> render ( $ response , $ this -> template , [ 'title' => $ this -> mapper -> getListViewTitle ( ) , 'insertLinkInfo' => $ this -> insertLinkInfo , 'filterOpsList' => QueryBuilder :: getWhereOperatorsText ( ) , 'filterValue' => $ this -> getFilterFieldValue ( ) , 'filterErrorMessage' => $ filterErrorMessage , 'filterFormActionRoute' => $ this -> indexRoute , 'filterFieldName' => $ this -> sessionFilterFieldKey , 'isFiltered' => $ this -> getFilterFieldValue ( ) != '' , 'resetFilterRoute' => $ this -> filterResetRoute , 'updatesPermitted' => $ this -> updatesPermitted , 'updateColumn' => $ this -> updateColumn , 'updateRoute' => $ this -> updateRoute , 'deletesPermitted' => $ this -> deletesPermitted , 'deleteRoute' => $ this -> deleteRoute , 'displayItems' => $ displayItems , 'columnCount' => $ this -> mapper -> getCountSelectColumns ( ) , 'sortColumn' => $ this -> mapper -> getListViewSortColumn ( ) , 'sortAscending' => $ this -> mapper -> getListViewSortAscending ( ) , 'navigationItems' => $ this -> navigationItems ] ) ; }
5353	public function getSupportedAuthentication ( ) { if ( empty ( $ this -> data -> authentication ) || empty ( $ this -> data -> authentication ) ) { return array ( ) ; } return ( array ) $ this -> data -> authentication ; }
3340	public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
3286	public function onBootstrap ( EventInterface $ e ) { $ app = $ e -> getApplication ( ) ; $ container = $ app -> getServiceManager ( ) ; $ config = $ container -> get ( 'Configuration' ) ; $ env = $ container -> get ( Environment :: class ) ; $ name = static :: MODULE_NAME ; $ options = $ envOptions = empty ( $ config [ $ name ] ) ? [ ] : $ config [ $ name ] ; $ extensions = empty ( $ options [ 'extensions' ] ) ? [ ] : $ options [ 'extensions' ] ; $ renderer = $ container -> get ( TwigRenderer :: class ) ; foreach ( $ extensions as $ extension ) { if ( empty ( $ extension ) ) { continue ; } elseif ( is_string ( $ extension ) ) { if ( $ container -> has ( $ extension ) ) { $ extension = $ container -> get ( $ extension ) ; } else { $ extension = new $ extension ( $ container , $ renderer ) ; } } elseif ( ! is_object ( $ extension ) ) { throw new InvalidArgumentException ( 'Extensions should be a string or object.' ) ; } if ( ! $ env -> hasExtension ( get_class ( $ extension ) ) ) { $ env -> addExtension ( $ extension ) ; } } return ; }
5294	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing CSS file to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getCss ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created CSS file successfully</success>' ) ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
8023	public function synchronize ( \ Closure $ closure ) { $ this -> acquire ( ) ; call_user_func ( $ closure ) ; $ this -> release ( ) ; return $ this ; }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
8370	public function perform ( array $ args = [ ] ) : int { $ this -> args = $ args ; unset ( $ this -> args [ 'messages' ] ) ; $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ this -> messages = $ args [ 'messages' ] ; foreach ( $ messages as & $ message ) { if ( $ shutdown ) { break ; } $ mailer = new Swift_Mailer ( $ transport ) ; $ m = ( new Swift_Message ( $ message [ 'subject' ] ) ) -> setFrom ( [ $ message [ 'from' ] [ 'email' ] => $ message [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ message [ 'to' ] [ 'email' ] => $ message [ 'to' ] [ 'name' ] ] ) -> setBody ( $ message [ 'message' ] ) ; $ message [ 'sent' ] = ( $ mailer -> send ( $ m ) === 1 ) ; } return 0 ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
3746	public function setBaseConfig ( array $ arrConfig ) { if ( ! $ arrConfig [ 'source' ] ) { throw new \ RuntimeException ( 'Missing table name.' ) ; } $ this -> strTable = $ arrConfig [ 'source' ] ; $ this -> metaModel = $ arrConfig [ 'metaModel' ] ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
6117	public function serverGetByUid ( $ uid ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_unique_identifier" ] == $ uid ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
10468	public static function getConversionFactor ( Uom $ from , Uom $ to ) { if ( $ from -> isSameValueAs ( $ to ) ) { return new Fraction ( 1 ) ; } if ( ! isset ( static :: $ conversions ) ) { static :: $ conversions = json_decode ( utf8_encode ( file_get_contents ( __DIR__ . '/conversions.json' ) ) , true ) ; } if ( isset ( static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ) ) { $ numeratorDenominatorPair = static :: $ conversions [ $ from -> getName ( ) ] [ $ to -> getName ( ) ] ; } elseif ( isset ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ) { $ numeratorDenominatorPair = array_reverse ( static :: $ conversions [ $ to -> getName ( ) ] [ $ from -> getName ( ) ] ) ; } else { throw new ConversionNotSetException ( $ from -> getName ( ) , $ to -> getName ( ) ) ; } if ( count ( $ numeratorDenominatorPair ) == 2 ) { return new Fraction ( $ numeratorDenominatorPair [ 0 ] , $ numeratorDenominatorPair [ 1 ] ) ; } else { throw new BadConversionException ( ) ; } }
12405	public function approveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: approve ( $ options ) ; }
3091	public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; }
3429	protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; }
10463	private function bindParams ( $ statement , $ params ) { foreach ( $ params as $ param ) { $ statement -> bindValue ( $ param [ 0 ] , $ param [ 1 ] , $ param [ 2 ] ) ; } }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
9212	protected function existsOrCreate ( $ file ) { if ( ! file_exists ( $ file ) ) { $ this -> out ( '<info>Creating empty seed file: ' . $ this -> shortPath ( $ file ) . '</info>' ) ; file_put_contents ( $ file , <<<'EOD'<?php/** * BasicSeed plugin data seed file. */namespace App\Config\BasicSeed;use Cake\ORM\TableRegistry;// Write your data import statements here.$data = [ 'TableName' => [ //'_truncate' => true, //'_entityOptions' => [ // 'validate' => false, //], //'_saveOptions' => [ // 'checkRules' => false, //], '_defaults' => [], [ 'id' => 1, 'name' => 'record 1', ], ],];$this->importTables($data);EOD ) ; } }
873	public function getAnnotations ( ) { if ( null === $ this -> annotations ) { $ this -> annotations = [ ] ; $ total = \ count ( $ this -> lines ) ; for ( $ index = 0 ; $ index < $ total ; ++ $ index ) { if ( $ this -> lines [ $ index ] -> containsATag ( ) ) { $ lines = \ array_slice ( $ this -> lines , $ index , $ this -> findAnnotationLength ( $ index ) , true ) ; $ annotation = new Annotation ( $ lines ) ; $ index = $ annotation -> getEnd ( ) ; $ this -> annotations [ ] = $ annotation ; } } } return $ this -> annotations ; }
1374	private function filterCommands ( Collection $ commands , $ type ) { $ baseCommandName = 'make:json-api:' ; $ filterValues = explode ( ',' , $ this -> option ( $ type ) ) ; $ targetCommands = collect ( $ filterValues ) -> map ( function ( $ target ) use ( $ baseCommandName ) { return $ baseCommandName . strtolower ( trim ( $ target ) ) ; } ) ; return $ commands -> { $ type } ( $ targetCommands -> toArray ( ) ) ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
3293	public function linkedin ( $ summary = '' ) { $ base = config ( 'laravel-share.services.linkedin.uri' ) ; $ mini = config ( 'laravel-share.services.linkedin.extra.mini' ) ; $ url = $ base . '?mini=' . $ mini . '&url=' . $ this -> url . '&title=' . urlencode ( $ this -> title ) . '&summary=' . urlencode ( $ summary ) ; $ this -> buildLink ( 'linkedin' , $ url ) ; return $ this ; }
6445	public function getLoginStartUrl ( $ redirecturl ) { $ linkedin = $ this -> getClient ( $ redirecturl ) ; $ url = $ linkedin -> getLoginUrl ( array ( \ LinkedIn \ LinkedIn :: SCOPE_BASIC_PROFILE , \ LinkedIn \ LinkedIn :: SCOPE_EMAIL_ADDRESS ) ) ; return $ url ; }
10678	public function inflect ( $ text , $ zivotne = false , $ preferovanyRod = '' ) { $ aTxt = $ this -> _txtSplit ( $ text ) ; $ this -> PrefRod = '0' ; $ out = [ ] ; for ( $ i = \ count ( $ aTxt ) - 1 ; $ i >= 0 ; $ i -- ) { $ this -> _skl2 ( $ aTxt [ $ i ] , $ preferovanyRod , $ zivotne ) ; if ( $ i === \ count ( $ aTxt ) - 1 ) { $ this -> PrefRod = $ this -> astrTvar [ 0 ] ; } if ( $ i < \ count ( $ aTxt ) - 1 && mb_substr ( $ this -> PrefRod , 0 , 1 , 'UTF-8' ) !== '?' && mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { $ this -> astrTvar [ $ j ] = $ aTxt [ $ i ] ; } } if ( mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { $ this -> astrTvar [ 0 ] = '' ; } if ( $ i < \ count ( $ aTxt ) ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] . ' ' . @ $ out [ $ j ] ; } } else { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] ; } } } return $ out ; }
12862	public function parseBehaviour ( \ stdClass $ block , $ search ) { if ( ! isset ( $ block -> behaviour ) ) { return false ; } $ behaviours = array ( ) ; foreach ( explode ( ' ' , trim ( $ block -> behaviour ) ) as $ b ) { if ( strstr ( $ b , ':' ) ) { list ( $ name , $ prop ) = explode ( ':' , $ b , 2 ) ; $ behaviours [ $ name ] = $ prop ; } else { $ behaviours [ $ b ] = true ; } } return isset ( $ behaviours [ $ search ] ) ? $ behaviours [ $ search ] : false ; }
7377	public function fetchFloat ( string $ key , float $ default = 0.0 , int $ precision = 2 ) : float { return round ( floatval ( $ this -> fetch ( $ key , $ default ) ) , $ precision ) ; }
1911	protected function getType ( ) : string { if ( isset ( $ this -> options [ 'type' ] ) ) { return $ this -> options [ 'type' ] ; } $ className = ltrim ( strrchr ( static :: class , '\\' ) , '\\' ) ; if ( 'Controller' === substr ( $ className , - 10 ) ) { $ className = substr ( $ className , 0 , - 10 ) ; } return Container :: underscore ( $ className ) ; }
2491	private function configureSearchServices ( ContainerBuilder $ container , $ connectionName , $ connectionParams ) { $ alias = $ this -> getAlias ( ) ; $ endpointResolverDefinition = new DefinitionDecorator ( self :: ENDPOINT_RESOLVER_ID ) ; $ endpointResolverDefinition -> replaceArgument ( 0 , $ connectionParams [ 'entry_endpoints' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 1 , $ connectionParams [ 'mapping' ] [ 'translations' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 2 , $ connectionParams [ 'mapping' ] [ 'default' ] ) ; $ endpointResolverDefinition -> replaceArgument ( 3 , $ connectionParams [ 'mapping' ] [ 'main_translations' ] ) ; $ endpointResolverId = "$alias.connection.$connectionName.endpoint_resolver_id" ; $ container -> setDefinition ( $ endpointResolverId , $ endpointResolverDefinition ) ; $ coreFilterDefinition = new DefinitionDecorator ( self :: CORE_FILTER_ID ) ; $ coreFilterDefinition -> replaceArgument ( 0 , new Reference ( $ endpointResolverId ) ) ; $ coreFilterId = "$alias.connection.$connectionName.core_filter_id" ; $ container -> setDefinition ( $ coreFilterId , $ coreFilterDefinition ) ; $ gatewayDefinition = new DefinitionDecorator ( self :: GATEWAY_ID ) ; $ gatewayDefinition -> replaceArgument ( 1 , new Reference ( $ endpointResolverId ) ) ; $ gatewayId = "$alias.connection.$connectionName.gateway_id" ; $ container -> setDefinition ( $ gatewayId , $ gatewayDefinition ) ; }
10388	protected function handleTtl ( $ key , $ expireSetTs , $ expireSec ) { $ ttl = $ expireSetTs + $ expireSec - time ( ) ; if ( $ ttl <= 0 ) { $ this -> getClient ( ) -> delete ( $ key ) ; throw new KeyNotFoundException ( ) ; } return $ ttl ; }
8557	public function setType ( $ type ) { if ( ! $ this -> isNumericArray ( $ type ) ) { $ type = array ( $ type ) ; } $ this -> fields [ 'Type' ] [ 'FieldValue' ] = $ type ; return $ this ; }
9405	public function push ( $ middleware ) { if ( is_array ( $ middleware ) ) { $ this -> stack = array_merge ( $ this -> stack , $ middleware ) ; return $ this ; } $ this -> stack [ ] = $ middleware ; return $ this ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
8212	protected function validateFile ( $ filePath , $ message = 'File' , $ allowEmpty = true ) { if ( ! file_exists ( $ filePath ) || ! is_readable ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' doesn't exist or is not readable." ) ; } if ( ! $ allowEmpty && 0 === filesize ( $ filePath ) ) { throw new \ RuntimeException ( "$message '{$filePath}' is empty." ) ; } return realpath ( $ filePath ) ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
11065	public function icon ( $ level , $ default = null ) { if ( array_key_exists ( $ level , $ this -> icons ) ) { return $ this -> icons [ $ level ] ; } return $ default ; }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
5065	public function getInfo ( int $ opt ) : string { if ( $ opt <= 0 ) { throw new CurlException ( "Option must be greater than zero, " . $ opt . " given." ) ; } return curl_getinfo ( $ this -> ch , $ opt ) ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
6550	public function current ( ) { if ( $ this -> iterator -> valid ( ) === false ) { return null ; } $ iterator = $ this -> iterator -> current ( ) -> getCellIterator ( ) ; $ iterator -> setIterateOnlyExistingCells ( false ) ; $ result = [ ] ; foreach ( $ iterator as $ cell ) { $ result [ ] = $ cell -> getValue ( ) ; } return $ result ; }
8195	protected function checkConstantExpression ( Twig_NodeInterface $ node ) { if ( ! ( $ node instanceof Twig_Node_Expression_Constant || $ node instanceof Twig_Node_Expression_Array || $ node instanceof Twig_Node_Expression_Unary_Neg || $ node instanceof Twig_Node_Expression_Unary_Pos ) ) { return false ; } foreach ( $ node as $ n ) { if ( ! $ this -> checkConstantExpression ( $ n ) ) { return false ; } } return true ; }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
8303	public function assertBool ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_bool ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a boolean value." ) ; } return $ this ; }
3720	protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
4966	public function fromHeader ( $ header = null , $ default = null ) { if ( $ header === null ) { return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getHeaders ( $ header , $ default ) ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11417	public function addPiwikCode ( ViewEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof \ Zend \ View \ Model \ ViewModel ) { return ; } $ options = $ model -> getOptions ( ) ; if ( array_key_exists ( 'has_parent' , $ options ) && $ options [ 'has_parent' ] ) { return ; } $ renderer = $ event -> getRenderer ( ) ; if ( ! $ renderer instanceof \ Zend \ View \ Renderer \ PhpRenderer ) { return ; } $ config = $ this -> serviceManager -> get ( 'config' ) ; $ piwikConfig = $ config [ 'orgHeiglPiwik' ] ; $ code = str_replace ( array_map ( function ( $ e ) { return '%%' . $ e . '%%' ; } , array_keys ( $ piwikConfig ) ) , array_values ( $ piwikConfig ) , $ this -> template ) ; $ renderer -> headScript ( ) -> appendScript ( '//<![CDATA[' . "\n" . $ code . "\n" . '//]]>' ) ; return $ renderer ; }
4964	public function addViewVariables ( $ name , $ data = [ ] , $ priority = 0 ) { if ( is_array ( $ name ) ) { if ( ! isset ( $ name [ 'name' ] ) ) { throw new \ DomainException ( 'Key "name" must be specified, if array is passed as first parameter.' ) ; } if ( is_int ( $ data ) ) { $ priority = $ data ; } $ data = $ name ; $ name = $ data [ 'name' ] ; } elseif ( is_int ( $ data ) ) { $ priority = $ data ; $ data = [ ] ; } if ( ! isset ( $ data [ 'name' ] ) ) { $ data [ 'name' ] = $ name ; } return $ this -> addViewTemplate ( $ name , "core/admin/dashboard-widget" , $ data , $ priority ) ; }
9445	public function getEntityMappings ( Container $ app ) { static $ mappings = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ mappings [ $ me ] ) ) { $ subns = $ this -> packOptions [ 'entity_subnamespace' ] ; $ subns = trim ( $ subns , '\\' ) ; $ simple = $ this -> packOptions [ 'entity_use_simple_annotation' ] ; $ ns = $ this -> getReflector ( ) -> getNamespaceName ( ) . '\\' . $ subns ; $ subpath = str_replace ( '\\' , '/' , $ subns ) ; $ path = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; if ( is_dir ( $ path ) ) { $ mappings [ $ me ] = [ 'type' => 'annotation' , 'namespace' => $ ns , 'path' => $ path , 'use_simple_annotation_reader' => $ simple , ] ; } } if ( empty ( $ mappings [ $ me ] ) ) { return [ ] ; } return [ $ mappings [ $ me ] ] ; }
5024	private function findLeaf ( NodeInterface $ leaf , $ value ) { $ parts = is_array ( $ value ) ? $ value : explode ( $ this -> shouldUseNames ( ) ? ' | ' : '-' , $ value ) ; $ value = array_shift ( $ parts ) ; foreach ( $ leaf -> getChildren ( ) as $ item ) { $ compare = $ this -> shouldUseNames ( ) ? $ item -> getName ( ) : $ item -> getValue ( ) ; if ( $ compare == $ value ) { if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ item , $ parts ) ; } return $ item ; } } if ( $ value && $ this -> shouldCreateLeafs ( ) ) { $ nodeClass = get_class ( $ leaf ) ; $ node = new $ nodeClass ( $ value ) ; $ leaf -> addChild ( $ node ) ; if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ node , $ parts ) ; } return $ node ; } return null ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
5369	protected function isOnlyAscii ( $ ascii ) { for ( $ i = 0 , $ length = strlen ( $ ascii ) ; $ i < $ length ; $ i ++ ) { if ( ord ( $ ascii [ $ i ] ) > 127 ) { return false ; } } return true ; }
7801	protected function splitTransactions ( $ text ) { $ offset = 0 ; $ length = 0 ; $ position = 0 ; $ transactions = array ( ) ; while ( $ line = $ this -> getLine ( '61' , $ text , $ offset , $ offset , $ length ) ) { $ offset += 4 + $ length + 2 ; $ transaction = array ( $ line ) ; $ description = array ( ) ; while ( $ line = $ this -> getLine ( '86' , $ text , $ offset , $ position , $ length ) ) { if ( $ position == $ offset ) { $ offset += 4 + $ length + 2 ; $ description [ ] = $ line ; } else { break ; } } if ( $ description ) { $ transaction [ ] = implode ( "\r\n" , $ description ) ; } $ transactions [ ] = $ transaction ; } return $ transactions ; }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
2547	public function analyzeResponse ( $ sendResult , $ messageName ) { if ( ! empty ( $ sendResult -> exception ) ) { return $ this -> makeResultForException ( $ sendResult ) ; } $ handler = $ this -> findHandlerForMessage ( $ messageName ) ; if ( $ handler instanceof MessageResponseHandler ) { return $ handler -> analyze ( $ sendResult ) ; } else { return new Result ( $ sendResult , Result :: STATUS_UNKNOWN ) ; } }
692	protected function createView ( array $ config ) { if ( ! array_key_exists ( 'class' , $ config ) ) { $ config [ 'class' ] = View :: className ( ) ; } return Yii :: createObject ( $ config ) ; }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
6116	public function serverGetByName ( $ name ) { foreach ( $ this -> serverList ( ) as $ server ) { if ( $ server [ "virtualserver_name" ] == $ name ) { return $ server ; } } throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
1945	public function sections ( $ key = null , $ template = null ) { if ( ! array_filter ( $ this -> sections ) ) { return ; } if ( $ key && ! isset ( $ this -> positions [ $ key ] ) ) { return ; } $ matches = array ( ) ; foreach ( $ this -> positions [ $ key ] as $ id => $ section ) { if ( ! empty ( $ this -> sections [ $ id ] ) ) { $ section [ 'content' ] = $ this -> sections [ $ id ] ; $ matches [ $ id ] = $ section ; } } if ( empty ( $ matches ) ) { return ; } $ this -> matches = $ matches ; if ( $ template === null ) { $ template = 'block_sections' ; } include $ this -> getTemplate ( $ template ) ; }
6805	private function generate ( $ class , array $ names , $ defaultCode ) { $ repository = $ this -> manager -> getRepository ( $ class ) ; foreach ( $ names as $ code => $ name ) { $ result = 'already exists' ; if ( null === $ repository -> findOneBy ( [ 'code' => $ code ] ) ) { $ entity = $ repository -> createNew ( ) ; $ entity -> setName ( $ name ) -> setCode ( $ code ) -> setEnabled ( $ defaultCode === $ code ) ; $ this -> manager -> persist ( $ entity ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
11819	public function addAppDependencies ( ) { $ container = $ this -> getContainer ( ) ; $ container [ 'person' ] = $ container -> protect ( function ( $ name ) { return 'Person name: ' . $ name ; } ) ; return $ this ; }
7438	public static function handleException ( \ Throwable $ e ) { self :: render ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) , null , $ e -> getTrace ( ) , get_class ( $ e ) ) ; }
6292	private function findThemeByDirectory ( $ directory ) { if ( isset ( $ this -> themes [ $ directory ] ) ) { return $ this -> themes [ $ directory ] ; } return null ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
11292	protected function _getAttributeDataWhenUnset ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( $ attributeName != $ this -> getPrimaryKey ( ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } else { $ this -> $ attributeName = $ this -> _fetchData ( $ attributeName ) ; } } else { $ this -> $ attributeName = null ; } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
9994	public function formatColor ( $ pValue , $ pFormat ) { $ color = null ; $ matches = [ ] ; $ color_regex = '/^\\[[a-zA-Z]+\\]/' ; if ( preg_match ( $ color_regex , $ pFormat , $ matches ) ) { $ color = str_replace ( [ '[' , ']' ] , '' , $ matches [ 0 ] ) ; $ color = strtolower ( $ color ) ; } $ value = htmlspecialchars ( $ pValue ) ; if ( $ color !== null ) { $ value = '<span style="color:' . $ color . '">' . $ value . '</span>' ; } return $ value ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
9083	private static function parseGetPostSessionCookie ( Request & $ request ) { foreach ( $ _GET as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _POST as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _COOKIE as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } foreach ( $ _FILES as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } if ( isset ( $ _SESSION ) ) { foreach ( $ _SESSION as $ name => $ value ) { $ request -> params [ $ name ] = $ value ; } } }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
5176	public function add ( string $ key , $ value ) : self { if ( ! array_key_exists ( $ key , $ this -> props ) ) { return $ this -> addNew ( $ key , $ value ) ; } if ( is_array ( $ this -> props [ $ key ] ) ) { return $ this -> addArray ( $ key , $ value ) ; } return $ this -> appendToArray ( $ key , $ value ) ; }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
4969	public function fromEvent ( $ param = null , $ default = null ) { if ( null === $ param ) { return $ this -> event -> getParams ( ) ; } return $ this -> event -> getParam ( $ param , $ default ) ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
6610	public static function getByCreatedDateRange ( $ startDate , $ endDate , $ createdAtColumn = 'created_at' ) { $ model = get_called_class ( ) ; $ model = new $ model ; return self :: find ( ) -> andWhere ( $ model :: tableName ( ) . '.' . $ createdAtColumn . ' BETWEEN :start_date AND :end_date' , [ 'start_date' => $ startDate , 'end_date' => $ endDate ] ) ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
2156	protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; }
3313	protected function appendAppIdAndBucketIfEmpty ( array $ options = [ ] ) { $ options [ 'appid' ] = empty ( $ options [ 'appid' ] ) ? $ this -> authorization -> getAppId ( ) : $ options [ 'appid' ] ; $ options [ 'bucket' ] = empty ( $ options [ 'bucket' ] ) ? $ this -> authorization -> getBucket ( ) : $ options [ 'bucket' ] ; return $ options ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
6261	public function getActionMap ( ) { $ actionMap = ( array ) Configure :: read ( 'SimpleRbac.actionMap' ) ; if ( empty ( $ actionMap ) && $ this -> _config [ 'allowEmptyActionMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.actionMap configuration is empty!' ) ; } return $ actionMap ; }
4840	public function validate_webhook ( $ params ) { $ sig = $ params [ 'signature' ] ; unset ( $ params [ 'signature' ] ) ; if ( ! isset ( $ sig ) ) { return false ; } $ data = array ( 'data' => $ params , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ sig ) ; return $ this -> validate_signature ( $ data ) ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
524	protected function migrateToTime ( $ time ) { $ count = 0 ; $ migrations = array_values ( $ this -> getMigrationHistory ( null ) ) ; while ( $ count < count ( $ migrations ) && $ migrations [ $ count ] > $ time ) { ++ $ count ; } if ( $ count === 0 ) { $ this -> stdout ( "Nothing needs to be done.\n" , Console :: FG_GREEN ) ; } else { $ this -> actionDown ( $ count ) ; } }
8404	public static function registerApp ( string $ namespace , string $ path = null ) { $ namespace = rtrim ( $ namespace , '\\' ) ; if ( $ path == null ) { $ path = constant ( 'STRAY_PATH_APPS' ) . str_replace ( '_' , DIRECTORY_SEPARATOR , str_replace ( '\\' , DIRECTORY_SEPARATOR , $ namespace ) ) ; } self :: $ namespaces [ $ namespace ] = $ path ; self :: $ applications [ ] = $ namespace ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
10271	function addAttachment ( $ mailingId , $ filename , $ contentType , $ contents ) { $ queryParameters = array ( 'filename' => $ filename ) ; return $ this -> post ( "mailings/${mailingId}/attachments" , $ contents , $ queryParameters , null , null , $ contentType , strlen ( $ contents ) ) ; }
2064	public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> value || $ varValue == '' ) { return $ varValue ; } $ varValue = Contao \ StringUtil :: standardize ( $ varValue ) ; $ this -> import ( 'Contao\Automator' , 'Automator' ) ; $ arrFeeds = $ this -> Automator -> purgeXmlFiles ( true ) ; if ( \ in_array ( $ varValue , $ arrFeeds ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
6259	protected function _isAllowedRole ( $ userRoles , array $ allowedRoles ) { if ( in_array ( '*' , $ allowedRoles ) ) { return true ; } if ( is_string ( $ userRoles ) ) { $ userRoles = [ $ userRoles ] ; } foreach ( $ userRoles as $ userRole ) { if ( in_array ( $ userRole , $ allowedRoles ) ) { return true ; } } return false ; }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
1691	protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
8431	public function start ( ) { Loop :: run ( function ( ) { $ this -> logger -> info ( sprintf ( "RPQ is now started, and is listening for new jobs every %d ms" , $ this -> config [ 'poll_interval' ] ) , [ 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> setIsRunning ( false ) ; Loop :: repeat ( $ this -> config [ 'poll_interval' ] , function ( $ watcherId , $ callback ) { if ( ! $ this -> isRunning ) { return ; } $ this -> queue -> rescheduleJobs ( ) ; if ( count ( $ this -> processes ) === $ this -> config [ 'max_jobs' ] ) { return ; } $ job = $ this -> queue -> pop ( ) ; if ( $ job !== null ) { $ command = sprintf ( 'exec %s %s --jobId=%s --name=%s' , ( $ this -> config [ 'process' ] [ 'script' ] ?? $ _SERVER [ "SCRIPT_FILENAME" ] ) , $ this -> config [ 'process' ] [ 'command' ] , $ job -> getId ( ) , $ this -> queue -> getName ( ) ) ; if ( $ this -> config [ 'process' ] [ 'config' ] === true ) { $ command .= " --config={$this->args['configFile']}" ; } $ process = new Process ( $ command ) ; $ process -> start ( ) ; $ pid = yield $ process -> getPid ( ) ; $ this -> logger -> info ( 'Started worker' , [ 'pid' => $ pid , 'command' => $ command , 'id' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> processes [ $ pid ] = [ 'process' => $ process , 'id' => $ job -> getId ( ) ] ; $ stream = $ process -> getStdout ( ) ; while ( $ chunk = yield $ stream -> read ( ) ) { $ this -> logger -> info ( $ chunk , [ 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; } $ code = yield $ process -> join ( ) ; $ this -> jobHandler -> exit ( $ job -> getId ( ) , $ pid , $ code , false , $ this -> config [ 'failed_job_backoff_time' ] ) ; unset ( $ this -> processes [ $ pid ] ) ; } } ) ; $ this -> registerSignals ( ) ; } ) ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
9763	function endWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringEndsWith ( $ value ) ) ; }
8817	public function delete ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _DELETE ) ; if ( $ key == null ) { return $ _DELETE ; } return $ this -> filter ( $ _DELETE [ $ key ] , $ filter ) ; }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
798	public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; }
10065	public function setPieces ( $ pieces ) { if ( $ pieces && ! $ pieces instanceof PieceBag ) { $ pieces = new PieceBag ( is_array ( $ pieces ) ? $ pieces : [ ] ) ; } return $ this -> setParameter ( 'pieces' , $ pieces ) ; }
101	public function setPsr4 ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr4 = ( array ) $ paths ; } else { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
114	private function openBrowser ( $ url ) { $ url = ProcessExecutor :: escape ( $ url ) ; $ process = new ProcessExecutor ( $ this -> getIO ( ) ) ; if ( Platform :: isWindows ( ) ) { return $ process -> execute ( 'start "web" explorer "' . $ url . '"' , $ output ) ; } $ linux = $ process -> execute ( 'which xdg-open' , $ output ) ; $ osx = $ process -> execute ( 'which open' , $ output ) ; if ( 0 === $ linux ) { $ process -> execute ( 'xdg-open ' . $ url , $ output ) ; } elseif ( 0 === $ osx ) { $ process -> execute ( 'open ' . $ url , $ output ) ; } else { $ this -> getIO ( ) -> writeError ( 'No suitable browser opening command found, open yourself: ' . $ url ) ; } }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
6787	protected function fixDefault ( CustomerGroupInterface $ customerGroup ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ customerGroup , [ 'default' ] ) ) { return ; } if ( $ customerGroup -> isDefault ( ) ) { try { $ previousGroup = $ this -> customerGroupRepository -> findDefault ( ) ; } catch ( RuntimeException $ e ) { return ; } if ( $ previousGroup === $ customerGroup ) { return ; } $ previousGroup -> setDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ previousGroup , false ) ; } }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
315	public function setVendorPath ( $ path ) { $ this -> _vendorPath = Yii :: getAlias ( $ path ) ; Yii :: setAlias ( '@vendor' , $ this -> _vendorPath ) ; Yii :: setAlias ( '@bower' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'bower' ) ; Yii :: setAlias ( '@npm' , $ this -> _vendorPath . DIRECTORY_SEPARATOR . 'npm' ) ; }
6630	public function callback ( $ input ) { if ( isset ( $ input [ 'error' ] ) ) { throw new AuthenticationException ( $ input [ 'error' ] . ':' . $ input [ 'error_description' ] ) ; } if ( ! isset ( $ input [ 'code' ] ) || empty ( $ input [ 'code' ] ) ) { throw new AuthenticationException ( 'invalid code' ) ; } if ( ! isset ( $ input [ 'state' ] ) || empty ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'invalid state' ) ; } if ( ! $ this -> store -> has ( $ input [ 'state' ] ) ) { throw new AuthenticationException ( 'state expired' ) ; } $ access_token = $ this -> requestAccessToken ( $ input [ 'code' ] ) ; return $ this -> requestProfile ( $ access_token ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
4178	public function getFiles ( ) { return $ this -> files ? : $ this -> files = Finder :: create ( ) -> in ( realpath ( $ this -> directory ) ) ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
1074	public function toArray ( $ debug = false ) { $ result = [ ] ; if ( ! empty ( $ this -> errors ) ) { $ errorsHandler = $ this -> errorsHandler ? : static function ( array $ errors , callable $ formatter ) { return array_map ( $ formatter , $ errors ) ; } ; $ result [ 'errors' ] = $ errorsHandler ( $ this -> errors , FormattedError :: prepareFormatter ( $ this -> errorFormatter , $ debug ) ) ; } if ( $ this -> data !== null ) { $ result [ 'data' ] = $ this -> data ; } if ( ! empty ( $ this -> extensions ) ) { $ result [ 'extensions' ] = $ this -> extensions ; } return $ result ; }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
11219	protected static function invokeObject ( $ callback , $ matched = null ) { $ last = explode ( '/' , $ callback ) ; $ last = end ( $ last ) ; $ segments = explode ( '@' , $ last ) ; $ class = $ segments [ 0 ] ; $ method = $ segments [ 1 ] ; $ matched = $ matched ? $ matched : [ ] ; if ( method_exists ( $ class , self :: $ singleton ) ) { $ instance = call_user_func ( [ $ class , self :: $ singleton ] ) ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } if ( class_exists ( $ class ) ) { $ instance = new $ class ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } return false ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
11676	protected function get ( $ locale , $ file , $ key ) { $ this -> load ( $ locale , $ file ) ; if ( array_key_exists ( $ key , $ this -> translations [ $ locale ] [ $ file ] ) === false ) { throw new TranslationKeyNotFound ( $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } $ result = $ this -> translations [ $ locale ] [ $ file ] [ $ key ] ; if ( is_string ( $ result ) === false ) { throw new TranslationKeyIsNotAString ( $ result , $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } return $ result ; }
7221	protected function createLabel ( $ content , $ type , $ format , $ size ) { $ label = new OrderShipmentLabel ( ) ; $ label -> setContent ( $ content ) -> setType ( $ type ) -> setFormat ( $ format ) -> setSize ( $ size ) ; return $ label ; }
12918	protected function findContentType ( $ spaceId , $ contentTypeName ) { $ contentTypes = $ this -> contentTypeRepo -> findNewestByName ( $ spaceId , $ contentTypeName ) ; if ( $ contentTypes -> isEmpty ( ) ) { throw new InvalidArgumentException ( sprintf ( 'Content type "%s" in space "%s" not found!' , $ contentTypeName , $ spaceId ) ) ; } if ( $ contentTypes -> count ( ) > 1 ) { throw new InvalidArgumentException ( sprintf ( 'Multiple content types with name "%s" found in space "%s"!' , $ contentTypeName , $ spaceId ) ) ; } $ contentType = $ contentTypes -> first ( ) ; return $ contentType ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
9565	public function addBeforeHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'before' ] ) ) { $ this -> options [ 'before' ] = [ ] ; } $ this -> options [ 'before' ] [ ] = $ hook ; }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
713	public function bigInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BIGINT , $ length ) ; }
8400	public function button ( Environment $ environment , $ link , $ button , $ size = 'md' , $ iconDisplay = 'true' , $ location = 'right' , $ label = null , $ userStyle = null ) { extract ( $ this -> toolbarService -> defineButton ( $ button ) ) ; return $ environment -> render ( '@c975LToolbar/buttonText.html.twig' , array ( 'link' => $ link , 'style' => $ style , 'size' => $ size , 'button' => $ button , 'icon' => $ icon , 'label' => $ label , 'iconDisplay' => $ iconDisplay , 'location' => $ location , ) ) ; }
12041	public function getFullName ( $ first = NULL , $ middle = NULL , $ last = NULL ) { $ user_first_name = $ this -> getPropertyValue ( "user_first_name" ) ; $ user_middle_name = $ this -> getPropertyValue ( "user_middle_name" ) ; $ user_last_name = $ this -> getPropertyValue ( "user_last_name" ) ; $ user_full_name = implode ( ' ' , array ( empty ( $ user_first_name ) ? $ first : $ user_first_name , empty ( $ user_middle_name ) ? $ middle : $ user_middle_name , empty ( $ user_last_name ) ? $ last : $ user_last_name ) ) ; if ( ! empty ( $ user_full_name ) ) { return $ user_full_name ; } }
12753	public function sendRecoveryMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> recoverySubject , 'recovery' , [ 'user' => $ user , 'token' => $ token ] ) ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
6649	public function uploadFile ( $ event ) { if ( ! array_key_exists ( $ this -> attribute , $ event -> sender -> attributes ) ) { throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Attribute {attribute} not found in model {model}' , [ 'attribute' => $ this -> attribute , 'model' => $ event -> sender -> className ( ) ] ) ) ; } $ oldFile = false ; if ( isset ( $ event -> sender -> oldAttributes [ $ this -> attribute ] ) ) { $ oldFile = $ event -> sender -> oldAttributes [ $ this -> attribute ] ; } $ uploadedFile = UploadedFile :: getInstance ( $ event -> sender , $ this -> attribute ) ; if ( null !== $ uploadedFile && $ uploadedFile -> size !== 0 ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ oldFile ) { $ this -> unlinkFiles ( $ oldFile ) ; } $ baseName = $ uploadedFile -> baseName ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; while ( @ file_exists ( $ folder . '/' . $ fileName ) ) { $ baseName .= '_' ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; } FileHelper :: createDirectory ( $ folder , 0777 ) ; $ uploadedFile -> saveAs ( $ folder . '/' . $ fileName ) ; $ event -> sender -> { $ this -> attribute } = $ fileName ; } else { if ( Yii :: $ app -> request -> post ( $ this -> attribute . '_file_delete' ) ) { $ this -> unlinkFiles ( $ oldFile ) ; $ event -> sender -> { $ this -> attribute } = null ; } else { $ event -> sender -> { $ this -> attribute } = $ oldFile ; } } }
8978	protected function getRateKey ( $ currencyCode , $ date , $ rateType , $ sourceName ) { return str_replace ( [ '%currency_code%' , '%date%' , '%rate_type%' , '%source_name%' ] , [ $ currencyCode , $ date -> format ( 'Y-m-d' ) , $ rateType , $ sourceName ] , '%currency_code%_%date%_%rate_type%_%source_name%' ) ; }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
1534	protected function methodForRelation ( $ field ) { if ( method_exists ( $ this , $ field ) ) { return $ field ; } $ method = Str :: camelize ( $ field ) ; return method_exists ( $ this , $ method ) ? $ method : null ; }
6211	protected function cleanBacktrace ( $ backtrace ) { foreach ( $ backtrace as & $ item ) { if ( isset ( $ item [ 'file' ] ) ) { $ item [ 'file' ] = $ this -> cleanFilePath ( $ item [ 'file' ] ) ; } unset ( $ item [ 'args' ] ) ; } return $ backtrace ; }
12652	public function getPageTexts ( $ language ) { if ( ! isset ( $ this -> contents [ $ language ] ) ) { $ this -> contents [ $ language ] = $ this -> readFileContents ( $ language ) ; } return $ this -> contents [ $ language ] ; }
11351	public function submit ( Request $ request ) { $ this -> isConfirmed = false ; if ( $ this -> formTags [ 'method' ] == 'post' && $ request -> getType ( ) == 'POST' ) { $ this -> isConfirmed = true ; } $ query = $ request -> getQuery ( ) ; if ( count ( $ this -> fields ) > 0 && $ this -> formTags [ 'method' ] == 'get' && isset ( $ query [ $ this -> fields [ 0 ] -> getName ( ) ] ) ) { $ this -> isConfirmed = true ; } if ( ! $ this -> isConfirmed ) return ; if ( $ this -> formTags [ 'method' ] == 'post' ) { $ storage = $ request -> getData ( ) ; } else { $ storage = $ request -> getQuery ( ) ; } $ result = [ ] ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ storage [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ storage [ $ field -> getName ( ) ] ) ; } else if ( $ field instanceof FileField ) { try { $ field -> setData ( $ request -> getFile ( $ field -> getName ( ) ) ) ; } catch ( FileNotUploadedException $ e ) { $ field -> setData ( '' ) ; } } else if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) && isset ( $ storage [ $ result [ 1 ] ] ) ) { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ value = $ storage [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ value [ $ deep ] ) ) { $ value = null ; break ; } $ value = $ value [ $ deep ] ; } if ( $ result [ 2 ] == '' ) { } else { $ field -> setData ( $ value ) ; } } else { $ field -> setData ( null ) ; } } if ( $ request -> isFullUploadedData ( ) ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getValidator ( ) ) { if ( $ error = $ field -> getValidator ( ) -> validate ( $ field -> getData ( ) ) ) { $ field -> setError ( $ error ) ; } } } } else { foreach ( $ this -> fields as $ field ) { $ field -> setError ( 'Request data is too large.' ) ; } } }
587	protected function buildTarget ( $ target , $ type , $ bundles ) { $ inputFiles = [ ] ; foreach ( $ target -> depends as $ name ) { if ( isset ( $ bundles [ $ name ] ) ) { if ( ! $ this -> isBundleExternal ( $ bundles [ $ name ] ) ) { foreach ( $ bundles [ $ name ] -> $ type as $ file ) { if ( is_array ( $ file ) ) { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file [ 0 ] ; } else { $ inputFiles [ ] = $ bundles [ $ name ] -> basePath . '/' . $ file ; } } } } else { throw new Exception ( "Unknown bundle: '{$name}'" ) ; } } if ( empty ( $ inputFiles ) ) { $ target -> $ type = [ ] ; } else { FileHelper :: createDirectory ( $ target -> basePath , $ this -> getAssetManager ( ) -> dirMode ) ; $ tempFile = $ target -> basePath . '/' . strtr ( $ target -> $ type , [ '{hash}' => 'temp' ] ) ; if ( $ type === 'js' ) { $ this -> compressJsFiles ( $ inputFiles , $ tempFile ) ; } else { $ this -> compressCssFiles ( $ inputFiles , $ tempFile ) ; } $ targetFile = strtr ( $ target -> $ type , [ '{hash}' => md5_file ( $ tempFile ) ] ) ; $ outputFile = $ target -> basePath . '/' . $ targetFile ; rename ( $ tempFile , $ outputFile ) ; $ target -> $ type = [ $ targetFile ] ; } }
8492	public static function getTotalMemory ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT TotalPhysicalMemory FROM Win32_ComputerSystem" ) as $ mem ) { return $ mem -> TotalPhysicalMemory ; } return NULL ; }
2396	protected function unixToHex ( $ intTime = 0 ) { $ arrTime = $ intTime ? getdate ( $ intTime ) : getdate ( ) ; $ hexTime = dechex ( ( ( $ arrTime [ 'year' ] - 1980 ) << 25 ) | ( $ arrTime [ 'mon' ] << 21 ) | ( $ arrTime [ 'mday' ] << 16 ) | ( $ arrTime [ 'hours' ] << 11 ) | ( $ arrTime [ 'minutes' ] << 5 ) | ( $ arrTime [ 'seconds' ] >> 1 ) ) ; return pack ( "H*" , $ hexTime [ 6 ] . $ hexTime [ 7 ] . $ hexTime [ 4 ] . $ hexTime [ 5 ] . $ hexTime [ 2 ] . $ hexTime [ 3 ] . $ hexTime [ 0 ] . $ hexTime [ 1 ] ) ; }
7277	public function time ( $ timestamp = false ) { return $ timestamp ? ( new DateTime ( $ this -> time ) ) -> getTimestamp ( ) : $ this -> time ; }
4488	private function broadcastToPlatform ( $ message , string $ platform ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $platform" , [ 'Message' => $ message , ] ) ; return ; } foreach ( $ this -> sns -> getPaginator ( 'ListEndpointsByPlatformApplication' , [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , ] ) as $ endpointsResult ) { foreach ( $ endpointsResult [ 'Endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'Attributes' ] [ 'Enabled' ] == 'true' ) { try { $ this -> send ( $ message , $ endpoint [ 'EndpointArn' ] ) ; } catch ( \ Exception $ e ) { $ this -> logger && $ this -> logger -> error ( "Failed to push to {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Exception' => $ e , 'Endpoint' => $ endpoint , ] ) ; } } else { $ this -> logger && $ this -> logger -> info ( "Disabled endpoint {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Endpoint' => $ endpoint , ] ) ; } } } }
2978	public function getLicenseByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> licenses [ $ key ] ) ) { return ; } list ( $ identifier , $ name , $ isOsiApproved , $ isDeprecatedLicenseId ) = $ this -> licenses [ $ key ] ; return array ( $ name , $ isOsiApproved , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseText' , $ isDeprecatedLicenseId , ) ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
4780	public function clearWidgetCache ( ) { $ widgets = $ this -> getWidgets ( false ) ; $ userId = $ this -> token -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { $ this -> cache -> deleteItem ( $ widget -> getId ( ) . $ userId ) ; } }
3086	public function getAdaptiveAssessmentSectionInfo ( AssessmentTest $ test , \ tao_models_classes_service_StorageDirectory $ compilationDirectory , $ basePath , $ qtiAssessmentSectionIdentifier ) { $ info = CatUtils :: getCatInfo ( $ test ) ; $ adaptiveInfo = [ 'qtiSectionIdentifier' => $ qtiAssessmentSectionIdentifier , 'adaptiveSectionIdentifier' => false , 'adaptiveEngineRef' => false ] ; if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] ) ) { if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) ) { $ adaptiveInfo [ 'adaptiveEngineRef' ] = $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ; } if ( isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) { $ adaptiveInfo [ 'adaptiveSectionIdentifier' ] = trim ( $ compilationDirectory -> read ( "./${basePath}/" . $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ; } } return ( ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveEngineRef' ] ) || ! isset ( $ info [ $ qtiAssessmentSectionIdentifier ] [ 'adaptiveSettingsRef' ] ) ) ? false : $ adaptiveInfo ; }
2694	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3514	public function postMissingKeys ( ) { $ missingKeys = Request :: json ( 'missingKeys' ) ; $ this -> manager -> setConnectionName ( '' ) ; $ translator = App :: make ( 'translator' ) ; $ affectedGroups = [ ] ; foreach ( $ missingKeys as $ key ) { $ key = decodeKey ( $ key ) ; list ( $ namespace , $ group , $ item ) = $ translator -> parseKey ( $ key ) ; if ( $ item && $ group ) { if ( ! in_array ( $ group , $ this -> manager -> config ( Manager :: EXCLUDE_GROUPS_KEY ) ) ) { $ t = $ this -> manager -> missingKey ( $ namespace , $ group , $ item , null , false , true ) ; if ( ! $ t -> exists ) { $ affectedGroups [ ] = $ t -> group ; $ t -> save ( ) ; } } } else { } } $ data = [ 'connectionName' => '' , 'affectedGroups' => $ affectedGroups , 'missingKeys' => [ ] , ] ; $ pretty = Request :: has ( 'pretty-json' ) ? JSON_PRETTY_PRINT : 0 ; return Response :: json ( $ data , 200 , [ ] , JSON_UNESCAPED_SLASHES | $ pretty ) ; }
11231	public function post ( $ section , $ body = null , array $ headers = [ ] ) { if ( is_array ( $ body ) ) { $ body = array_merge ( $ this -> parameters , $ body , $ this -> defaultParameters ) ; $ body = http_build_query ( $ body ) ; } return $ this -> client -> post ( $ this -> getUrl ( $ section ) , $ headers , $ body ) ; }
5517	public function errorAt ( $ timing , $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error at' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
12910	public function group ( $ group ) { if ( ! is_array ( $ group ) ) { $ this -> group = array ( $ group ) ; } else { $ this -> group = $ group ; } return $ this ; }
7575	public function getCustomFields ( $ parameters = array ( ) ) { $ this -> _harvest = $ this -> _harvestHelper -> parse ( 'getCustomFields' , $ parameters ) ; if ( ! array_key_exists ( 'id' , $ parameters ) ) $ this -> _harvest [ 'url' ] = $ this -> _harvest [ 'url' ] . '/' ; $ this -> sendRequest ( ) ; }
5407	public function getCookieValue ( $ host , $ path , $ name ) { $ longest_path = '' ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ host , $ path , $ name ) ) { if ( strlen ( $ cookie -> getPath ( ) ) > strlen ( $ longest_path ) ) { $ value = $ cookie -> getValue ( ) ; $ longest_path = $ cookie -> getPath ( ) ; } } } return ( isset ( $ value ) ? $ value : false ) ; }
9396	public function setSafe ( $ options ) { if ( is_string ( $ options ) ) { $ this -> safe [ ] = $ options ; return $ this ; } if ( is_array ( $ options ) ) { foreach ( $ options as $ key => $ value ) { $ this -> safe [ ] = $ value ; } return $ this ; } throw new InvalidArgumentException ( 'This method expects a string or an array argument.' ) ; }
8560	public function setProduct ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Product' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2634	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; $ snippetName = explode ( '_' , $ snippet ) ; $ snippetName = explode ( '.' , $ snippetName [ 2 ] ) ; $ reqName = Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetName [ 0 ] ; $ checkIfSnippetExist = $ this -> api -> hasSnippet ( $ activeVersion , $ reqName ) ; if ( $ checkIfSnippetExist ) { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ this -> api -> removeSnippet ( $ clone -> number , $ reqName ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the ' . $ reqName . ' custom snippet.' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; } if ( $ write -> isExist ( $ snippetPath ) ) { $ write -> delete ( $ snippetPath ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12717	protected function getMethodParameters ( Internal \ ReflectionClassFactory $ refl , $ method ) { return ( $ refl -> hasMethod ( $ method ) ? $ refl -> getMethod ( $ method ) -> getParameters ( ) : null ) ; }
802	public static function shouldBeTogether ( Tag $ first , Tag $ second ) { $ firstName = $ first -> getName ( ) ; $ secondName = $ second -> getName ( ) ; if ( $ firstName === $ secondName ) { return true ; } foreach ( self :: $ groups as $ group ) { if ( \ in_array ( $ firstName , $ group , true ) && \ in_array ( $ secondName , $ group , true ) ) { return true ; } } return false ; }
2680	public function checkImageOptimizationStatus ( ) { $ url = $ this -> _getApiServiceUri ( ) . 'dynamic_io_settings' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
8414	public function getMasterLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } return $ this -> servers [ 'write' ] [ 'link' ] ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
7177	public static function pluck ( $ array , $ key ) { $ values = array ( ) ; foreach ( $ array as $ row ) { if ( isset ( $ row [ $ key ] ) ) { $ values [ ] = $ row [ $ key ] ; } } return $ values ; }
6426	public function completeLogin ( $ extrainputs = array ( ) ) { if ( $ extrainputs [ 'code' ] == '' && $ extrainputs [ 'error' ] != '' ) { throw new \ Exception ( $ extrainputs [ 'error' ] ) ; } $ client = $ this -> getClient ( ) ; $ client -> authenticate ( $ extrainputs [ 'code' ] ) ; $ this -> access_token = $ client -> getAccessToken ( ) ; return $ this -> getUserProfile ( ) ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
6190	public function renderJSON ( $ data , $ status = 200 ) { exit ( Response :: Create ( json_encode ( $ data ) ) -> status ( $ status ) -> headers ( [ 'Content-Type' => 'application/json' ] ) -> display ( ) ) ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
6075	public function setStatus ( $ id , $ status ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'status' => $ status ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/status' , $ parameters ) ; return $ result ; }
6867	protected function getSaleFromInvoice ( InvoiceInterface $ invoice ) { if ( null === $ sale = $ invoice -> getSale ( ) ) { $ cs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , $ this -> getSalePropertyPath ( ) ) ; if ( ! empty ( $ cs ) ) { $ sale = $ cs [ 0 ] ; } } if ( ! $ sale instanceof SaleInterface ) { throw new Exception \ RuntimeException ( "Failed to retrieve invoice's sale." ) ; } return $ sale ; }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
9226	public function get ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: get ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
6309	public function drop ( DatabaseObjectInterface $ databaseObject , $ cascade = false ) { $ command = $ this -> getCommand ( $ databaseObject , false ) ; if ( $ cascade ) { $ command -> cascade ( ) ; } return $ command -> execute ( ) ; }
11248	public function getMigrationBatches ( ) : array { $ stmt = $ this -> pdo -> prepare ( "select * from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ array = [ ] ; foreach ( $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) as $ item ) { $ array [ $ item [ 'migration' ] ] = $ item [ 'batch' ] ; } return $ array ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
8807	public function set ( $ key , $ value , $ time = 0 ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { setcookie ( $ k , $ v , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ k ] = $ v ; } } else { setcookie ( $ key , $ value , ( $ time == 0 ? 0 : time ( ) + $ time ) , '/' ) ; $ _COOKIE [ $ key ] = $ value ; } return ; }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
2181	private function filterNestedPaths ( Finder $ finder , string $ prepend ) : array { $ parents = [ ] ; $ files = iterator_to_array ( $ finder ) ; foreach ( $ files as $ key => $ file ) { $ path = rtrim ( strtr ( $ prepend . '/' . $ file -> getRelativePath ( ) , '\\' , '/' ) , '/' ) ; if ( ! empty ( $ parents ) ) { $ parent = \ dirname ( $ path ) ; while ( false !== strpos ( $ parent , '/' ) ) { if ( \ in_array ( $ parent , $ parents , true ) ) { $ this -> rows [ ] = [ sprintf ( '<fg=yellow;options=bold>%s</>' , '\\' === \ DIRECTORY_SEPARATOR ? 'WARNING' : '!' ) , $ this -> webDir . '/' . $ path , sprintf ( '<comment>Skipped because %s will be symlinked.</comment>' , $ parent ) , ] ; unset ( $ files [ $ key ] ) ; break ; } $ parent = \ dirname ( $ parent ) ; } } $ parents [ ] = $ path ; } return array_values ( $ files ) ; }
6663	public function post ( $ url , $ params ) { if ( is_array ( $ params ) ) { $ params = $ this -> filterParams ( $ params ) ; } $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url ) ; return $ this -> curlAgent -> setOption ( CURLOPT_POSTFIELDS , $ params ) -> post ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
10022	public function removeCellStyleXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellStyleXfCollection ) - 1 ) { throw new Exception ( 'CellStyleXf index is out of bounds.' ) ; } array_splice ( $ this -> cellStyleXfCollection , $ pIndex , 1 ) ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
3438	public function refreshSections ( ) { if ( $ this -> id === null ) { return [ ] ; } $ this -> fields [ 'IBLOCK_SECTION' ] = [ ] ; $ dbSections = static :: $ bxObject -> getElementGroups ( $ this -> id , true ) ; while ( $ section = $ dbSections -> Fetch ( ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] [ ] = $ section ; } $ this -> sectionsAreFetched = true ; return $ this -> fields [ 'IBLOCK_SECTION' ] ; }
7011	private function formatS ( & $ str ) { if ( strstr ( $ str , '%S' ) ) $ str = str_replace ( '%S' , static :: ordinal ( $ this -> day ) , $ str ) ; }
9513	public function setMatchModeByModeName ( $ modeName ) { $ modes = [ 'all' => 0 , 'any' => 1 , 'phrase' => 2 , 'boolean' => 3 , 'extended' => 4 , 'fullscan' => 5 , ] ; if ( array_key_exists ( $ modeName , $ modes ) ) { $ mode = $ modes [ $ modeName ] ; $ this -> SetMatchMode ( $ mode ) ; } else { throw new \ LogicException ( 'Wrong Mode' ) ; } }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
9403	public static function get ( ContainerInterface $ container , array $ components = array ( ) , & $ globals = null ) { $ configuration = new Configuration ; $ collection = new Collection ; foreach ( ( array ) $ components as $ component ) { $ instance = self :: prepare ( $ collection , $ component ) ; $ container = $ instance -> define ( $ container , $ configuration ) ; } $ collection -> setContainer ( $ container ) ; $ globals === null || $ globals [ 'container' ] = $ container ; return $ collection ; }
8826	protected function migrationToClassName ( $ migrationName ) { $ class = str_replace ( '_' , ' ' , $ migrationName ) ; $ class = ucwords ( $ class ) ; $ class = str_replace ( ' ' , '' , $ class ) ; if ( ! $ this -> isValidClassName ( $ class ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Migration class "%s" is invalid' , $ class ) ) ; } return $ class ; }
6661	protected function getControllerMethod ( $ methodName ) { $ reflectionMethod = $ this -> reflectedController -> getMethod ( $ methodName ) ; $ reflectionMethod -> setAccessible ( true ) ; return function ( ) use ( $ reflectionMethod ) { return $ reflectionMethod -> invokeArgs ( $ this -> controller , func_get_args ( ) ) ; } ; }
3775	public function maxChildren ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; if ( ! $ factory instanceof NestablePropertyConditionFactoryInterface ) { if ( null !== $ value = $ this -> fallbackFactory -> maxChildren ( $ conditionType ) ) { return $ value ; } return 0 ; } return $ factory -> maxChildren ( ) ; }
1729	protected function regenerateSessionId ( ) { @ trigger_error ( 'Using User::regenerateSessionId() has been deprecated and will no longer work in Contao 5.0. Use Symfony authentication instead.' , E_USER_DEPRECATED ) ; $ container = System :: getContainer ( ) ; $ strategy = $ container -> getParameter ( 'security.authentication.session_strategy.strategy' ) ; switch ( $ strategy ) { case SessionAuthenticationStrategy :: NONE : break ; case SessionAuthenticationStrategy :: MIGRATE : $ container -> get ( 'session' ) -> migrate ( ) ; break ; case SessionAuthenticationStrategy :: INVALIDATE : $ container -> get ( 'session' ) -> invalidate ( ) ; break ; default : throw new \ RuntimeException ( sprintf ( 'Invalid session authentication strategy "%s"' , $ strategy ) ) ; } }
11881	public function run ( ) { if ( false === $ this -> boot ( ) ) { exit ( 1 ) ; } $ this -> runner -> run ( $ this -> request , $ this -> response ) ; return $ this ; }
6747	public function bootstrap ( $ appBootstrap , $ appenv , $ debug ) { $ bootstrap = ( new $ appBootstrap ( ) ) ; $ bootstrap -> initialize ( $ appenv , $ debug ) ; $ kernel = $ bootstrap -> getApplication ( ) ; $ this -> requestHandler = new RequestHandler ( $ kernel ) ; }
10261	public function getEmail ( $ person_name = null , $ domain = null ) { $ username = $ this -> getUsername ( $ person_name ) ; $ domains = [ ] ; $ domains [ ] = ! empty ( $ domain ) ? $ domain : $ this -> getDomain ( ) ; $ domains [ ] = 'gmail.com' ; $ domains [ ] = 'yahoo.com' ; $ domains [ ] = 'me.com' ; $ domains [ ] = 'msn.com' ; $ domains [ ] = 'hotmail.com' ; $ domain = $ this -> fromArray ( $ domains ) ; return preg_replace ( '/[^0-9a-z_A-Z.]/' , '' , strtolower ( $ username ) ) . '@' . $ domain ; }
5579	public function clickImageById ( $ id , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectById ( $ id ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
4789	function update ( array $ data ) { if ( $ this -> notORM -> freeze ) { return false ; } if ( ! $ data ) { return 0 ; } $ values = array ( ) ; $ parameters = array ( ) ; $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ data as $ key => $ val ) { $ values [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; if ( $ val instanceof NotORM_Literal && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } if ( $ this -> parameters ) { $ parameters = array_merge ( $ parameters , $ this -> parameters ) ; } $ return = $ this -> query ( "UPDATE" . $ this -> topString ( $ this -> limit ) . " $this->table SET " . implode ( ", " , $ values ) . $ this -> whereString ( ) , $ parameters ) ; if ( ! $ return ) { return false ; } return $ return -> rowCount ( ) ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
3698	private function getOrCreateDefinition ( ) { if ( $ this -> container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ this -> container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; if ( ! $ view instanceof Contao2BackendViewDefinitionInterface ) { throw new DcGeneralInvalidArgumentException ( 'Configured BackendViewDefinition does not implement Contao2BackendViewDefinitionInterface.' ) ; } return $ view ; } $ this -> container -> setDefinition ( Contao2BackendViewDefinitionInterface :: NAME , $ view = new Contao2BackendViewDefinition ( ) ) ; return $ view ; }
9615	public function addManagerRegistry ( ManagerRegistry $ registry ) { if ( ! in_array ( $ registry , $ this -> registries , true ) ) { $ this -> registries [ ] = $ registry ; } }
12182	public function getPrimaryChild ( $ parentObject ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( ! $ this -> child -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ parentObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ parentObject -> primaryKey , '`' . $ alias . '`.`primary_child`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ parentObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
1301	public function parseJson ( string $ json ) { return $ this -> builder -> build ( $ this -> scopedJsonDecoder -> decode ( $ json ) ) ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
10430	protected function createPipelines ( ContainerBuilder $ container , array $ config ) { foreach ( $ config [ 'pipelines' ] as $ pipelineName => $ pipelineConfig ) { if ( ! isset ( $ pipelineConfig [ 'shop' ] ) ) { $ pipelineConfig [ 'shop' ] = $ container -> getParameter ( 'ongr_connections.active_shop' ) ; } $ serviceConfig = $ this -> prepareServiceConfigs ( $ container , $ pipelineConfig , $ pipelineName ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_sources' ] , $ serviceConfig , "data_sync.{$pipelineName}.source" , 'onSource' ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_consumers' ] , $ serviceConfig , "data_sync.{$pipelineName}.consume" , 'onConsume' ) ; foreach ( $ pipelineConfig [ 'types' ] as $ type => $ typeConfig ) { $ typeServiceConfig = $ this -> prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) ; $ serviceList = $ this -> getServiceList ( $ pipelineName , $ type ) ; foreach ( $ serviceList as $ name => $ service ) { $ this -> createServices ( $ container , array_merge ( $ pipelineConfig [ $ name ] , $ typeConfig [ $ name ] ) , $ typeServiceConfig , $ service [ 'tag' ] , $ service [ 'method' ] ) ; } } } }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
8268	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } if ( ! file_exists ( $ this -> filePath ) ) { throw new \ RuntimeException ( $ this -> filePath . " does not exist" ) ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for reading: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_SH ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire a shared lock for " . $ this -> filePath ) ; } }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
7055	public function offset ( $ jd ) { if ( $ this -> dst == false ) return $ this -> offset ; IAU :: Jd2cal ( $ jd , 0 , $ y , $ m , $ d , $ fd ) ; $ dayN = static :: dayOfYear ( $ y , $ m , $ d ) + $ fd ; IAU :: Cal2jd ( $ y , 3 , 1 , $ djm0 , $ djm ) ; $ dayB = static :: dayOfYear ( $ y , 2 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; IAU :: Cal2jd ( $ y , 11 , 1 , $ djm0 , $ djm ) ; $ dayE = static :: dayOfYear ( $ y , 11 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; if ( $ dayN >= $ dayB && $ dayN < $ dayE ) return $ this -> offset + 1 ; else return $ this -> offset ; }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
4332	private static function buildAttribArrayVal ( $ key , $ value = array ( ) ) { if ( $ key == 'class' ) { if ( ! \ is_array ( $ value ) ) { $ value = \ explode ( ' ' , $ value ) ; } $ value = \ array_filter ( \ array_unique ( $ value ) ) ; \ sort ( $ value ) ; $ value = \ implode ( ' ' , $ value ) ; } elseif ( $ key == 'style' ) { $ keyValues = array ( ) ; foreach ( $ value as $ k => $ v ) { $ keyValues [ ] = $ k . ':' . $ v . ';' ; } \ sort ( $ keyValues ) ; $ value = \ implode ( '' , $ keyValues ) ; } else { $ value = null ; } return $ value ; }
6073	public function group ( $ id , array $ children ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'children' => $ children ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/group' , $ parameters ) ; return $ result ; }
6256	public function searchPickupPointsByText ( $ query_text , $ service_provider = null , $ limit = 5 ) { if ( $ query_text == null || trim ( $ query_text ) == '' ) { return '[]' ; } $ post_params = array ( 'query' => ( string ) $ query_text , 'service_provider' => ( string ) $ service_provider , 'limit' => ( int ) $ limit ) ; return $ this -> doPost ( '/pickup-points/search' , $ post_params ) ; }
5319	public function isSuccessExit ( ) { $ this -> exitCode = pcntl_wexitstatus ( $ this -> status ) ; return ( pcntl_wifexited ( $ this -> status ) && ( $ this -> exitCode === 0 ) ) ; }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
12837	public function build ( ) { $ this -> appDir = $ this -> rootDir . '/app' ; $ siteDir = $ this -> appDir . '/data/' . $ this -> siteName ; $ siteConfigDir = $ siteDir . '/config' ; $ pagesDir = $ siteDir . '/pages/pages' ; $ rolesDir = $ siteDir . '/roles' ; $ slotsDir = $ siteDir . '/slots' ; $ usersDir = $ siteDir . '/users' ; $ folders = array ( $ siteConfigDir , $ pagesDir , $ rolesDir , $ slotsDir , $ usersDir , ) ; $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> createConfiguration ( $ siteDir ) ; $ this -> createSite ( $ siteDir ) ; $ this -> createRoles ( $ rolesDir ) ; $ this -> createUsers ( $ usersDir ) ; $ this -> filesystem -> touch ( $ siteDir . '/incomplete.json' ) ; return $ this ; }
6042	public function session ( $ sourceId , $ sessionHash , $ remoteIp , $ userAgent , $ userId = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sourceId' => $ sourceId , 'sessionHash' => $ sessionHash , 'remoteIp' => $ remoteIp , 'userAgent' => $ userAgent , 'userId' => $ userId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/session' , $ parameters ) ; return $ result ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
12607	public static function makeSafe ( $ file ) { $ regex = [ '#(\.){2,}#' , '#[^A-Za-z0-9\.\_\- ]#' , '#^\.#' , ] ; $ file = rtrim ( $ file , '.' ) ; $ clean = preg_replace ( $ regex , ' ' , $ file ) ; $ clean = preg_replace ( "/[ \_]/" , '-' , $ clean ) ; $ clean = preg_replace ( "/[\-]+/" , '-' , $ clean ) ; return $ clean ; }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
6254	public function fetchShippingLabels ( $ trackingCodes ) { $ id = str_replace ( '.' , '' , microtime ( true ) ) ; $ xml = new \ SimpleXMLElement ( '<eChannel/>' ) ; $ routing = $ xml -> addChild ( 'ROUTING' ) ; $ routing -> addChild ( 'Routing.Account' , $ this -> api_key ) ; $ routing -> addChild ( 'Routing.Id' , $ id ) ; $ routing -> addChild ( 'Routing.Key' , md5 ( "{$this->api_key}{$id}{$this->secret}" ) ) ; $ label = $ xml -> addChild ( 'PrintLabel' ) ; $ label [ 'responseFormat' ] = 'File' ; foreach ( $ trackingCodes as $ trackingCode ) { $ label -> addChild ( 'TrackingCode' , $ trackingCode ) ; } $ response = $ this -> doPost ( '/prinetti/get-shipping-label' , null , $ xml -> asXML ( ) ) ; $ response_xml = @ simplexml_load_string ( $ response ) ; if ( ! $ response_xml ) { throw new \ Exception ( "Failed to load response xml" ) ; } $ this -> response = $ response_xml ; if ( $ response_xml -> { 'response.status' } != 0 ) { throw new \ Exception ( "Error: {$response_xml->{'response.status'}}, {$response_xml->{'response.message'}}" ) ; } return $ response_xml ; }
8929	public function stack ( $ icons ) { if ( count ( $ icons ) !== 2 ) { throw new \ InvalidArgumentException ( 'Expecting exactly 2 icons in the stack' ) ; } $ contents = [ ] ; $ index = 2 ; foreach ( $ icons as $ key => $ value ) { $ contents [ ] = $ this -> getStackIconElement ( $ key , $ value , $ index ) ; -- $ index ; } return $ this -> html -> span ( $ contents ) -> addClass ( 'fa-stack' ) ; }
2734	public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ subject -> isCacheable ( ) && $ this -> config -> isEnabled ( ) && $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> getTtl ( ) ) { $ header = $ this -> response -> getHeader ( 'cache-control' ) ; if ( ( $ header instanceof \ Zend \ Http \ Header \ HeaderInterface ) && ( $ value = $ header -> getFieldValue ( ) ) ) { if ( $ ttl = $ this -> config -> getStaleTtl ( ) ) { $ value .= ', stale-while-revalidate=' . $ ttl ; } if ( $ ttl = $ this -> config -> getStaleErrorTtl ( ) ) { $ value .= ', stale-if-error=' . $ ttl ; } $ this -> response -> setHeader ( $ header -> getFieldName ( ) , $ value , true ) ; } } if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; }
1265	public function recoverLabel ( $ trackingData , $ labelSpecification = null , $ labelDelivery = null , $ translate = null ) { if ( is_array ( $ trackingData ) ) { if ( ! isset ( $ trackingData [ 'value' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `value`.' ) ; } if ( ! isset ( $ trackingData [ 'shipperNumber' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `shipperNumber`.' ) ; } } if ( ! empty ( $ translate ) ) { if ( ! isset ( $ translateOpts [ 'language' ] ) ) { $ translateOpts [ 'language' ] = 'eng' ; } if ( ! isset ( $ translateOpts [ 'dialect' ] ) ) { $ translateOpts [ 'dialect' ] = 'US' ; } } $ request = $ this -> createRecoverLabelRequest ( $ trackingData , $ labelSpecification , $ labelDelivery , $ translate ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> recoverLabelEndpoint ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } }
9848	public function createSignedRequest ( string $ method , string $ uri , string $ body , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( $ body ) , [ ] ) ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
10230	public function getContext ( ) { $ s = '' ; foreach ( [ 'a' , 'b' , 'c' , 'd' ] as $ i ) { $ v = $ this -> { $ i } ; $ s .= chr ( $ v & 0xff ) ; $ s .= chr ( ( $ v >> 8 ) & 0xff ) ; $ s .= chr ( ( $ v >> 16 ) & 0xff ) ; $ s .= chr ( ( $ v >> 24 ) & 0xff ) ; } return $ s ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
4316	private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; } , 'errorEmailer' => function ( Debug $ debug ) { return new ErrorEmailer ( $ debug -> config -> getCfgLazy ( 'errorEmailer' ) ) ; } , 'errorHandler' => function ( Debug $ debug ) { if ( ErrorHandler :: getInstance ( ) ) { return ErrorHandler :: getInstance ( ) ; } else { $ errorHandler = new ErrorHandler ( $ debug -> eventManager ) ; $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; }
1851	public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
3685	protected function optimizedFilter ( $ filterRule , $ children , $ operation ) { $ procedure = new FilterBuilderSql ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ operation , $ this -> connection ) ; $ skipped = $ this -> buildNativeSqlProcedure ( $ procedure , $ children ) ; if ( ! $ procedure -> isEmpty ( ) ) { $ filterRule -> addChild ( $ this -> getMetaModel ( ) -> getEmptyFilter ( ) -> addFilterRule ( $ procedure -> build ( ) ) ) ; } return $ skipped ; }
12082	public function getMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { return $ this -> getAllMedia ( $ objectType , $ objectURI , $ objectId ) ; }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
12779	public function getState ( $ key , $ default = null ) { return Yii :: $ app -> webState -> get ( $ this -> stateKeyName ( $ key ) , $ default ) ; }
9775	function startWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringStartsWith ( $ value ) ) ; }
3977	private function addEditMultipleCommand ( Contao2BackendViewDefinitionInterface $ view ) { $ definition = $ this -> container -> getBasicDefinition ( ) ; if ( ! $ definition -> isEditable ( ) && ! $ definition -> isDeletable ( ) && ! $ definition -> isCreatable ( ) ) { return ; } $ commands = $ view -> getGlobalCommands ( ) ; $ command = new SelectCommand ( ) ; $ command -> setName ( 'all' ) -> setLabel ( 'MSC.all.0' ) -> setDescription ( 'MSC.all.1' ) ; $ parameters = $ command -> getParameters ( ) ; $ parameters [ 'act' ] = 'select' ; $ extra = $ command -> getExtra ( ) ; $ extra [ 'class' ] = 'header_edit_all' ; $ commands -> addCommand ( $ command ) ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6184	public function display ( $ type = 'all' , $ print = false ) { $ messages = '' ; $ data = '' ; if ( in_array ( $ type , $ this -> msgTypes ) ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages [ $ type ] as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; $ this -> clear ( $ type ) ; } elseif ( $ type === 'all' ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages as $ type => $ msgArray ) { $ messages = '' ; foreach ( $ msgArray as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; } $ this -> clear ( ) ; } else { return false ; } if ( $ print ) { echo $ data ; return null ; } return $ data ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
7911	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; SemanticUiPluginAsset :: register ( $ view ) ; $ selector = $ this -> selector ? : '#' . $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('$selector').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ handler = $ handler instanceof JsExpression ? $ handler : new JsExpression ( $ handler ) ; $ js [ ] = "jQuery('$selector').$name('setting', '$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
9888	static function getPermission ( $ code ) { switch ( $ code ) { case 1 : return self :: $ NONE ; case "none" : return self :: $ NONE ; case 2 : return self :: $ SOI ; case "soi" : return self :: $ SOI ; case 3 : return self :: $ COI ; case "coi" : return self :: $ COI ; case 4 : return self :: $ DOI ; case "doi" : return self :: $ DOI ; case 5 : return self :: $ DOI_PLUS ; case "doi+" : return self :: $ DOI_PLUS ; case 6 : return self :: $ OTHER ; case "other" : return self :: $ OTHER ; default : return self :: $ OTHER ; } }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
8677	public function unique ( ) { $ items = [ ] ; foreach ( $ this -> items as $ item ) { if ( array_search ( $ item , $ items , true ) === false ) { $ items [ ] = $ item ; } } return $ this -> createFrom ( $ items ) ; }
10876	public function processApprove ( string $ hash ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { if ( ! $ item [ 'active' ] ) { if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , [ 'active' => true ] ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User is already approve!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
4561	public function transfer ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = $ model -> $ get ( ) ; if ( null !== $ values ) { foreach ( $ values as $ locale => $ value ) { $ model -> translate ( $ locale , false ) -> $ set ( $ value ) ; } } } $ model -> mergeNewTranslations ( ) ; }
4449	public function pop ( ? string $ worker = null , ? int $ numJobs = null ) { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ jids = json_decode ( $ this -> client -> pop ( $ this -> name , $ workerName , $ numJobs ? : 1 ) , true ) ; $ jobs = [ ] ; array_map ( function ( array $ data ) use ( & $ jobs ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; $ jobs [ ] = $ job ; } , $ jids ? : [ ] ) ; return $ numJobs === null ? array_shift ( $ jobs ) : $ jobs ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
2097	public static function getRegexp ( $ strFormat = null ) { if ( $ strFormat === null ) { $ strFormat = static :: getNumericDateFormat ( ) ; } if ( ! static :: isNumericFormat ( $ strFormat ) ) { throw new \ Exception ( sprintf ( 'Invalid date format "%s"' , $ strFormat ) ) ; } return preg_replace_callback ( '/[a-zA-Z]/' , function ( $ matches ) { $ arrRegexp = array ( 'a' => '(?P<a>am|pm)' , 'A' => '(?P<A>AM|PM)' , 'd' => '(?P<d>0[1-9]|[12][0-9]|3[01])' , 'g' => '(?P<g>[1-9]|1[0-2])' , 'G' => '(?P<G>[0-9]|1[0-9]|2[0-3])' , 'h' => '(?P<h>0[1-9]|1[0-2])' , 'H' => '(?P<H>[01][0-9]|2[0-3])' , 'i' => '(?P<i>[0-5][0-9])' , 'j' => '(?P<j>[1-9]|[12][0-9]|3[01])' , 'm' => '(?P<m>0[1-9]|1[0-2])' , 'n' => '(?P<n>[1-9]|1[0-2])' , 's' => '(?P<s>[0-5][0-9])' , 'Y' => '(?P<Y>[0-9]{4})' , 'y' => '(?P<y>[0-9]{2})' , ) ; return $ arrRegexp [ $ matches [ 0 ] ] ?? $ matches [ 0 ] ; } , preg_quote ( $ strFormat ) ) ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
10344	protected function extractStep ( $ definition ) { if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { return ( int ) substr ( $ definition , $ position + 1 ) ; } return false ; }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
921	private function fixAnnotations ( DocBlock $ doc ) { foreach ( $ doc -> getAnnotations ( ) as $ index => $ annotation ) { $ next = $ doc -> getAnnotation ( $ index + 1 ) ; if ( null === $ next ) { break ; } if ( true === $ next -> getTag ( ) -> valid ( ) ) { if ( TagComparator :: shouldBeTogether ( $ annotation -> getTag ( ) , $ next -> getTag ( ) ) ) { $ this -> ensureAreTogether ( $ doc , $ annotation , $ next ) ; } else { $ this -> ensureAreSeparate ( $ doc , $ annotation , $ next ) ; } } } return $ doc -> getContent ( ) ; }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
4800	function via ( $ column ) { $ this -> column = $ column ; $ this -> conditions [ 0 ] = "$this->table.$column AND" ; $ this -> where [ 0 ] = "(" . $ this -> whereIn ( "$this->table.$column" , array_keys ( ( array ) $ this -> result -> rows ) ) . ")" ; return $ this ; }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
3689	public function createButton ( GetOperationButtonEvent $ event ) { if ( 'createvariant' !== $ event -> getCommand ( ) -> getName ( ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metamodel = $ model -> getItem ( ) -> getMetaModel ( ) ; if ( ! $ metamodel -> hasVariants ( ) || $ model -> getProperty ( 'varbase' ) === '0' ) { $ event -> setHtml ( '' ) ; } }
2588	protected function addItineraries ( $ itineraries , $ legacySegments , & $ tattooCounter ) { if ( ! empty ( $ legacySegments ) ) { $ this -> addSegments ( $ legacySegments , $ tattooCounter ) ; } foreach ( $ itineraries as $ itinerary ) { $ this -> addSegments ( $ itinerary -> segments , $ tattooCounter , $ itinerary -> origin , $ itinerary -> destination ) ; } }
10471	public function checkOutItem ( $ user_id , $ item_id ) { $ request = new CheckOutRequest ( $ this -> connector -> agency_id , $ user_id , $ item_id ) ; $ this -> emit ( 'request.checkout' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckOutResponse ( $ response ) ; }
893	private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; }
6548	public function current ( ) { $ sheet = $ this -> iterator -> current ( ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
6297	protected function registerNavigation ( ) { $ this -> app -> singleton ( 'navigation' , function ( $ app ) { $ request = $ app [ 'request' ] ; $ events = $ app [ 'events' ] ; $ url = $ app [ 'url' ] ; $ view = $ app [ 'view' ] ; $ name = 'navigation::bootstrap' ; $ navigation = new Navigation ( $ request , $ events , $ url , $ view , $ name ) ; $ app -> refresh ( 'request' , $ navigation , 'setRequest' ) ; return $ navigation ; } ) ; $ this -> app -> alias ( 'navigation' , Navigation :: class ) ; }
2538	protected function initSoapClient ( $ wsdlId ) { $ wsdlPath = WsdlAnalyser :: $ wsdlIds [ $ wsdlId ] ; $ client = new Client \ SoapClient ( $ wsdlPath , $ this -> makeSoapClientOptions ( ) , $ this -> params -> logger ) ; return $ client ; }
10000	public function setSoftEdgesSize ( $ size ) { if ( $ size !== null ) { $ this -> activateObject ( ) ; $ softEdges [ 'size' ] = ( string ) $ this -> getExcelPointsWidth ( $ size ) ; } }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
12401	public function get ( $ multiple = true ) { $ scope = $ this -> scope ; return Parser :: get ( $ scope , $ this -> connection , $ multiple ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
5550	public function getRequestData ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequestData ( ) ; } return $ this -> frameset -> getRequestData ( ) ; }
1545	public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
7631	public function setContainerMetadata ( $ containerName = '' , $ metadata = array ( ) , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: isArray ( $ metadata , 'Meta data should be an array of key and value pairs.' ) ; if ( count ( $ metadata ) == 0 ) { return ; } $ headers = array ( ) ; $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'metadata' ) , 'PUT' , $ headers , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
10964	public static function getHost ( ) { $ host = null ; if ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ host = $ _SERVER [ 'SERVER_NAME' ] ; } else { $ host = gethostname ( ) ; } return $ host ; }
554	private function notifyCachesCanBeFlushed ( $ caches ) { $ this -> stdout ( "The following caches were found in the system:\n\n" , Console :: FG_YELLOW ) ; foreach ( $ caches as $ name => $ class ) { if ( $ this -> canBeFlushed ( $ class ) ) { $ this -> stdout ( "\t* $name ($class)\n" , Console :: FG_GREEN ) ; } else { $ this -> stdout ( "\t* $name ($class) - can not be flushed via console\n" , Console :: FG_YELLOW ) ; } } $ this -> stdout ( "\n" ) ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
3155	public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
5081	public function putRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , 404 ) ; } $ this -> userCan ( static :: ACTION_UPDATE , $ oItem ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; $ aData = $ this -> validateUserInput ( $ aData , $ oItem ) ; if ( ! $ this -> oModel -> update ( $ oItem -> id , $ aData ) ) { throw new ApiException ( 'Failed to update resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
7271	public function delete ( ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; if ( isset ( $ this -> $ idColumn ) ) { $ status = Db :: query ( " delete from $tableName where $idColumn = :id " , [ "id" => $ this -> $ idColumn ] , static :: getDbName ( ) , false ) ; } else { $ condition = "" ; $ params = [ ] ; foreach ( $ columns as $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( isset ( $ this -> $ name ) ) { $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } } $ condition = substr ( $ condition , 0 , - 5 ) ; var_dump ( " delete from $tableName where $condition " ) ; var_dump ( $ params ) ; $ status = Db :: query ( " delete from $tableName where $condition " , $ params , static :: getDbName ( ) , false ) ; } return $ status !== false && $ status > 0 ; }
2765	public function isUpToDate ( ) : bool { if ( ! $ this -> isTracking ( ) ) { throw new GitException ( 'Error: HEAD does not have a remote tracking branch. Cannot check if it is up-to-date.' ) ; } $ mergeBase = $ this -> run ( 'merge-base' , [ '@' , '@{u}' ] ) ; $ remoteSha = $ this -> run ( 'rev-parse' , [ '@{u}' ] ) ; return $ mergeBase === $ remoteSha ; }
8622	public function setGetLowestOfferListingsForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5472	private function getPrivatePropertyNoMatterWhat ( $ name , $ object ) { foreach ( ( array ) $ object as $ mangled_name => $ value ) { if ( $ this -> unmangle ( $ mangled_name ) == $ name ) { return $ value ; } } }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
12689	public function get ( $ namespace , $ name , $ default = null , $ require = false ) { $ configuration = $ this -> load ( $ namespace , $ require ) ; return array_key_exists ( $ name , $ configuration ) ? $ configuration [ $ name ] : $ default ; }
11013	protected function importDataFile ( string $ dataFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { $ query = $ this -> db -> createQueryBuilder ( ) ; $ query -> select ( 'count(*) AS count' ) -> from ( $ controlTableName ) ; $ data = $ query -> execute ( ) -> fetchAll ( ) ; $ contentCount = ( int ) $ data [ 0 ] [ 'count' ] ; if ( $ contentCount > 0 ) { $ this -> output -> writeln ( '<comment>Data already exists in the database, skipping data import for file <info>' . $ dataFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ dataFile ) ; }
2655	public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; }
4275	public function stream_lock ( $ operation ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ flock ( $ this -> handle , $ operation ) ; self :: register ( ) ; return $ success ; }
9729	function toDateTime ( ) { return $ this -> date . " " . str_pad ( $ this -> hours , 2 , '0' , STR_PAD_LEFT ) . ":" . str_pad ( $ this -> minutes , 2 , '0' , STR_PAD_LEFT ) ; }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
2453	public static function findByHashAndPid ( $ strHash , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "($t.hash=? AND $t.pid=?)" ) , array ( $ strHash , $ intPid ) , $ arrOptions ) ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
9301	public function setScheduleAhead ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`scheduleAhead` expects integer value!' ) ; } $ this -> options [ 'scheduleAhead' ] = ( int ) $ time ; return $ this ; }
6898	public function delete ( ... $ args ) { $ this -> open ( ) ; foreach ( $ args as $ key ) { unset ( $ this -> _data [ $ key ] ) ; } return $ this ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
5961	public function serverGroupGetByName ( $ name , $ type = TeamSpeak3 :: GROUP_DBTYPE_REGULAR ) { foreach ( $ this -> serverGroupList ( ) as $ group ) { if ( $ group [ "name" ] == $ name && $ group [ "type" ] == $ type ) { return $ group ; } } throw new Ts3Exception ( "invalid groupID" , 0xA00 ) ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
8094	public function set ( $ keyPath , $ value ) { $ stops = explode ( '.' , $ keyPath ) ; $ currentLocation = $ previousLocation = $ this ; foreach ( $ stops as $ key ) { if ( $ currentLocation instanceof Collection ) { if ( ! ( $ currentLocation -> $ key instanceof Collection ) ) { $ currentLocation -> $ key = array ( ) ; } } else { $ currentLocation = array ( ) ; $ currentLocation -> $ key = array ( ) ; } $ previousLocation = $ currentLocation ; $ currentLocation = $ currentLocation -> $ key ; } $ previousLocation -> $ key = $ value ; }
7239	protected function getAddressFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerAddressInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerAddressInterface :: class ) ; } return $ resource ; }
356	public function init ( ) { parent :: init ( ) ; if ( $ this -> enableCoreCommands ) { foreach ( $ this -> coreCommands ( ) as $ id => $ command ) { if ( ! isset ( $ this -> controllerMap [ $ id ] ) ) { $ this -> controllerMap [ $ id ] = $ command ; } } } if ( ! isset ( $ this -> controllerMap [ 'help' ] ) ) { $ this -> controllerMap [ 'help' ] = 'yii\console\controllers\HelpController' ; } }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
6935	protected function formatMessage ( $ message , $ format = [ Console :: FG_RED , Console :: BOLD ] ) { $ stream = ( PHP_SAPI === 'cli' ) ? \ STDERR : \ STDOUT ; if ( Console :: stream_supports_ansi_colors ( $ stream ) ) { $ message = Console :: ansi_format ( $ message , $ format ) ; } return $ message ; }
7616	public function authenticateApp ( $ consumer_key , $ consumer_secret ) { $ bearer_token = $ this -> encodeBearer ( $ consumer_key , $ consumer_secret ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearer_token , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ response = $ this -> client -> post ( '/oauth2/token' , $ headers , $ body ) -> send ( ) ; $ data = $ response -> json ( ) ; $ this -> bearer = $ data [ 'access_token' ] ; return $ this -> bearer ; }
3886	public function collectRules ( $ filterSettings ) { $ information = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'fid=:fid' ) -> andWhere ( 'pid=0' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'fid' , $ filterSettings -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ information -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ newSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ newSetting ) { $ filterSettings -> addSetting ( $ newSetting ) ; } } }
7660	function AddrFormat ( $ addr ) { if ( empty ( $ addr [ 1 ] ) ) $ formatted = $ addr [ 0 ] ; else { $ formatted = $ this -> EncodeHeader ( $ addr [ 1 ] , 'phrase' ) . " <" . $ addr [ 0 ] . ">" ; } return $ formatted ; }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
4831	public function retry ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/retry' ; return new self ( $ this -> client , $ this -> client -> request ( 'post' , $ endpoint ) ) ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
11251	public function getLastBatchNumber ( ) : int { $ stmt = $ this -> pdo -> query ( "select max(batch) from {$this->table}" ) ; $ stmt -> execute ( ) ; return ( int ) $ stmt -> fetch ( PDO :: FETCH_ASSOC ) [ 'max' ] ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
10893	public function add ( $ name , UriInterface $ uri ) { unset ( $ this -> uris [ $ name ] ) ; $ this -> uris [ $ name ] = $ uri ; }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
6083	public function uploadFile ( $ pathname , $ name , $ categoryId , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'upload' , true ) ) ; $ fp = fopen ( $ pathname , 'rb' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadFileChunked ( $ chunkData , $ name , $ chunk , $ chunksTotal , $ fileId , $ categoryId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } if ( isset ( $ result [ 'fileId' ] ) ) { $ fileId = $ result [ 'fileId' ] ; } ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
6130	protected function getCorpusName ( ) { if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { if ( $ this -> currObj -> spacerGetType ( ) != TeamSpeak3 :: SPACER_CUSTOM ) { return "" ; } $ string = $ this -> currObj [ "channel_name" ] -> section ( "]" , 1 , 99 ) ; if ( $ this -> currObj -> spacerGetAlign ( ) == TeamSpeak3 :: SPACER_ALIGN_REPEAT ) { $ string -> resize ( 30 , $ string ) ; } return htmlspecialchars ( $ string ) ; } if ( $ this -> currObj instanceof Client ) { $ before = array ( ) ; $ behind = array ( ) ; foreach ( $ this -> currObj -> memberOf ( ) as $ group ) { if ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEFORE ) { $ before [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } elseif ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEHIND ) { $ behind [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } } return implode ( "" , $ before ) . " " . htmlspecialchars ( $ this -> currObj ) . " " . implode ( "" , $ behind ) ; } return htmlspecialchars ( $ this -> currObj ) ; }
7820	public function store ( $ pipeline , array $ pipes ) { $ workflow = [ $ pipeline => $ pipes ] ; $ yaml = $ this -> parser -> dump ( $ workflow ) ; $ this -> files -> append ( $ this -> getSource ( ) , $ yaml ) ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
9194	public function addChild ( ModelInterface $ child , $ captureTo = null , $ append = null ) { parent :: addChild ( $ child , $ captureTo , $ append ) ; if ( $ child instanceof ThemeDefaultInterface ) { $ child -> parent = $ this ; } return $ this ; }
7946	public function getLineProperties ( $ id , $ line ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ line ) throw new BadMethodCallException ( 'Missing parameter $line.' ) ; try { $ r = $ this -> get ( 'xdsl/' . $ id . '/lines/' . $ line ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
12754	protected function prepareRequest ( ) { if ( $ this -> method === static :: GET && ! empty ( $ this -> data ) ) { $ url = trim ( $ this -> url , '/' ) . '?' ; $ url .= http_build_query ( $ this -> data ) ; } else { $ url = $ this -> url ; } $ options = array ( CURLOPT_URL => $ url , CURLOPT_POST => $ this -> method === static :: POST , CURLOPT_HEADER => true , CURLOPT_NOBODY => $ this -> method === static :: HEAD , CURLOPT_RETURNTRANSFER => true , CURLOPT_USERAGENT => $ this -> userAgent , CURLOPT_SSL_VERIFYPEER => false ) ; if ( ! in_array ( $ this -> method , [ static :: GET , static :: HEAD , static :: POST ] ) ) { $ options [ CURLOPT_CUSTOMREQUEST ] = $ this -> method ; } if ( ! empty ( $ this -> data ) && $ this -> method !== static :: GET ) { $ options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ this -> data ) ; } if ( ! empty ( $ this -> headers ) ) { $ headersToSend = [ ] ; foreach ( $ this -> headers as $ key => $ value ) { $ headersToSend [ ] = "{$key}: {$value}" ; } $ options [ CURLOPT_HTTPHEADER ] = $ headersToSend ; } if ( ! empty ( $ this -> cookies ) ) { $ cookiesToSend = [ ] ; foreach ( $ this -> cookies as $ key => $ value ) { $ cookiesToSend [ ] = "{$key}={$value}" ; } $ options [ CURLOPT_COOKIE ] = implode ( '; ' , $ cookiesToSend ) ; } curl_setopt_array ( $ this -> resource , $ options ) ; }
5226	private function isTypeMismatch ( $ type , $ value ) { if ( ! ( $ type instanceof \ ReflectionClass ) ) { return false ; } if ( ! is_object ( $ value ) ) { return true ; } return ! $ type -> isInstance ( $ value ) ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
6415	public static function get ( IteratorAggregate $ iterable , int $ position ) { return Iterators :: get ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ position ) ; }
1417	public function failedValidator ( ValidatorContract $ validator , \ Closure $ closure = null ) : ErrorCollection { $ failed = $ this -> doesIncludeFailed ( ) ? $ validator -> failed ( ) : [ ] ; $ errors = new ErrorCollection ( ) ; foreach ( $ validator -> errors ( ) -> messages ( ) as $ key => $ messages ) { $ failures = $ this -> createValidationFailures ( $ failed [ $ key ] ?? [ ] ) ; foreach ( $ messages as $ detail ) { $ failed = $ failures -> shift ( ) ? : [ ] ; if ( $ closure ) { $ errors -> add ( $ this -> call ( $ closure , $ key , $ detail , $ failed ) ) ; continue ; } $ errors -> add ( new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'failed_validator' , 'code' ) , $ this -> trans ( 'failed_validator' , 'title' ) , $ detail ? : $ this -> trans ( 'failed_validator' , 'detail' ) ) ) ; } } return $ errors ; }
10797	public function getCryptedPassword ( $ password ) { $ bcrypt = new Bcrypt ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; return $ bcrypt -> create ( $ password ) ; }
6862	protected function registerFactory ( ) { $ this -> app -> singleton ( 'notifyme.factory' , function ( ) { return new NotifyMeFactory ( ) ; } ) ; $ this -> app -> alias ( 'notifyme.factory' , NotifyMeFactory :: class ) ; $ this -> app -> alias ( 'notifyme.factory' , FactoryInterface :: class ) ; }
3478	public function withBodyLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> body = '' ; $ cloned -> bodyLocalized = $ localized ; return $ cloned ; }
6637	protected function initParams ( ) { Yii :: $ app -> view -> params [ 'h1' ] = Yii :: t ( 'wavecms/main' , '<i>Not set</i>' ) ; Yii :: $ app -> view -> params [ 'buttons_top' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_btm' ] = [ ] ; Yii :: $ app -> view -> params [ 'buttons_sublist' ] = [ ] ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
6780	protected function updateExchangeRate ( SaleInterface $ sale ) { if ( null !== $ sale -> getExchangeRate ( ) ) { return false ; } $ date = $ sale -> getExchangeDate ( ) ?? new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ sale -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ sale -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
10208	public function delete ( $ resourcePath , $ queryParameters = array ( ) , $ mimeType = 'application/vnd.maileon.api+xml' , $ deserializationType = null ) { $ curlSession = $ this -> prepareSession ( $ resourcePath , $ queryParameters , $ mimeType ) ; curl_setopt ( $ curlSession , CURLOPT_CUSTOMREQUEST , "DELETE" ) ; return $ this -> performRequest ( $ curlSession , $ deserializationType ) ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
2066	public function getPageTypes ( Contao \ DataContainer $ dc ) { $ arrOptions = array ( ) ; foreach ( array_keys ( $ GLOBALS [ 'TL_PTY' ] ) as $ pty ) { if ( $ pty == 'root' && $ dc -> activeRecord && $ dc -> activeRecord -> pid > 0 ) { continue ; } if ( $ pty == $ dc -> value || $ this -> User -> hasAccess ( $ pty , 'alpty' ) ) { $ arrOptions [ ] = $ pty ; } } return $ arrOptions ; }
7418	protected function setJSONContent ( array $ content ) { if ( $ this -> deleteJsonKeys ) { $ content = $ this -> deleteArrayKeys ( $ content ) ; } $ content = json_encode ( $ content , JSON_UNESCAPED_UNICODE ) ; $ this -> response -> setContentTypeJson ( ) ; $ this -> response -> setContent ( $ content ) ; }
7663	function AddAttachment ( $ path , $ name = "" , $ encoding = "base64" , $ type = "application/octet-stream" ) { if ( ! @ is_file ( $ path ) ) { $ this -> SetError ( $ this -> Lang ( "file_access" ) . $ path ) ; return false ; } $ filename = basename ( $ path ) ; if ( $ name == "" ) $ name = $ filename ; $ cur = count ( $ this -> attachment ) ; $ this -> attachment [ $ cur ] [ 0 ] = $ path ; $ this -> attachment [ $ cur ] [ 1 ] = $ filename ; $ this -> attachment [ $ cur ] [ 2 ] = $ name ; $ this -> attachment [ $ cur ] [ 3 ] = $ encoding ; $ this -> attachment [ $ cur ] [ 4 ] = $ type ; $ this -> attachment [ $ cur ] [ 5 ] = false ; $ this -> attachment [ $ cur ] [ 6 ] = "attachment" ; $ this -> attachment [ $ cur ] [ 7 ] = 0 ; return true ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
4540	public function get ( string $ key ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ config ) ; return $ config -> getValue ( ) ; }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
12953	public function getForeignChildren ( ) { $ children = [ ] ; foreach ( $ this -> dataSource -> foreignChildKeys as $ keySet ) { $ model = $ keySet [ 'foreignModel' ] ; unset ( $ keySet [ 'foreignModel' ] ) ; if ( ! empty ( $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ) ) { $ keySet [ 'foreignId' ] = $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ; if ( ! isset ( $ children [ $ model ] ) ) { $ children [ $ model ] = [ ] ; } $ children [ $ model ] [ ] = $ keySet ; } } return $ children ; }
12625	public function get ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'GET' , $ url , array ( 'query' => $ data ) ) ; }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
9515	private function _initLoggerCascade ( $ configFile , $ loggerName ) { $ err = '' ; try { $ fs = $ this -> _obm -> get ( Filesystem :: class ) ; if ( $ fs -> isAbsolutePath ( $ configFile ) ) { $ fileName = $ configFile ; } else { $ fileName = BP . '/' . $ configFile ; } $ realPath = realpath ( $ fileName ) ; if ( $ realPath ) { Cascade :: fileConfig ( $ realPath ) ; $ this -> _logger = Cascade :: getLogger ( $ loggerName ) ; } else { $ err = "Cannot open logging configuration file '$fileName'. Default Magento logger is used." ; } } catch ( \ Exception $ e ) { $ err = $ e -> getMessage ( ) ; } finally { if ( is_null ( $ this -> _logger ) ) { $ this -> _logger = $ this -> _obm -> get ( \ Magento \ Framework \ Logger \ Monolog :: class ) ; $ this -> warning ( $ err ) ; } } }
5443	protected function invokeParser ( $ content , $ is_match ) { if ( ( $ content === '' ) || ( $ content === false ) ) { return true ; } $ handler = $ this -> mode_handlers [ $ this -> mode -> getCurrent ( ) ] ; return $ this -> parser -> $ handler ( $ content , $ is_match ) ; }
8751	private function addCurrentMessage ( ) { if ( $ this -> currentMessage -> hasTranslation ( ) ) { $ this -> messages [ ] = $ this -> currentMessage ; $ this -> currentMessage = new Message ( ) ; } }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
10756	public function map ( $ method , $ route , $ target , $ name = null , $ hostGroup = null , $ prepend = false ) { if ( ! $ hostGroup ) { $ hostGroup = null ; } if ( $ prepend ) { array_unshift ( $ this -> routes , array ( $ method , $ route , $ target , $ name , $ hostGroup ) ) ; } else { $ this -> routes [ ] = array ( $ method , $ route , $ target , $ name , $ hostGroup ) ; } if ( $ name ) { if ( array_key_exists ( $ name , $ this -> namedRoutes ) ) { throw new HaltoRouterException ( "Can not redeclare route $name" ) ; } $ this -> namedRoutes [ $ name ] = array ( $ route , $ hostGroup ) ; } return $ this ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
1712	public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
2352	public function sendToBrowser ( $ filename = '' , $ inline = false ) { $ response = new BinaryFileResponse ( $ this -> strRootDir . '/' . $ this -> strFile ) ; $ response -> setContentDisposition ( $ inline ? ResponseHeaderBag :: DISPOSITION_INLINE : ResponseHeaderBag :: DISPOSITION_ATTACHMENT , $ filename , Utf8 :: toAscii ( $ this -> basename ) ) ; $ response -> headers -> addCacheControlDirective ( 'must-revalidate' ) ; $ response -> headers -> addCacheControlDirective ( 'post-check' , 0 ) ; $ response -> headers -> addCacheControlDirective ( 'pre-check' , 0 ) ; $ response -> headers -> set ( 'Connection' , 'close' ) ; throw new ResponseException ( $ response ) ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
9313	public function infoAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ mapper = $ this -> getJobMapper ( ) ; try { $ pendingJobs = $ mapper -> getPending ( ) -> count ( ) ; $ runningJobs = $ mapper -> getRunning ( ) -> count ( ) ; $ finishedJobs = $ mapper -> getHistory ( ) -> count ( ) ; $ console -> writeLine ( sprintf ( 'Pending jobs: %s' , $ pendingJobs ) ) ; $ console -> writeLine ( sprintf ( 'Running jobs: %s' , $ runningJobs ) ) ; $ console -> writeLine ( sprintf ( 'Finished jobs: %s' , $ finishedJobs ) ) ; } catch ( \ PDOException $ exception ) { $ console -> writeLine ( 'Something is bad with your database - either database ' . 'adapter is not properly configured or database table is ' . 'not created.' , ConsoleColor :: LIGHT_RED ) ; } }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
3100	private function getItemData ( RunnerServiceContext $ context , $ itemRef ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ context ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ context , $ itemRef ) ; $ itemDataVariable = $ this -> getRunnerService ( ) -> getItemVariableElementsData ( $ context , $ itemRef ) ; $ responses = $ itemData [ 'data' ] [ 'responses' ] ; foreach ( array_keys ( $ responses ) as $ responseId ) { if ( array_key_exists ( $ responseId , $ itemDataVariable ) ) { $ itemData [ 'data' ] [ 'responses' ] [ $ responseId ] = array_merge ( ... [ $ responses [ $ responseId ] , $ itemDataVariable [ $ responseId ] , ] ) ; } } return $ itemData ; }
11637	public function getTableRegistry ( ) { if ( is_null ( $ this -> _tableRegistry ) ) { $ objectTypeClass = Yii :: $ app -> classes [ 'ObjectTypeRegistry' ] ; $ this -> _tableRegistry = [ ] ; if ( $ objectTypeClass :: tableExists ( ) ) { $ om = $ objectTypeClass :: find ( ) -> all ( ) ; $ this -> _tableRegistry = ArrayHelper :: index ( $ om , 'name' ) ; } } return $ this -> _tableRegistry ; }
9126	private function requestImpl ( string $ requestType ) { if ( $ requestType == 'HEAD' ) { $ this -> setTimeout ( 1 ) ; } $ ms = $ this -> prepareRequest ( $ requestType ) ; $ ms = $ this -> appendPayloadToRequest ( $ ms ) ; if ( ! $ this -> isConnected ( ) ) { $ this -> connect ( ) ; } while ( $ ms -> ready ( ) ) { $ this -> write ( $ ms -> read ( 1024 ) ) ; } $ this -> retrieveAndParseResponse ( $ requestType ) ; if ( $ this -> getHeader ( 'Connection' ) == 'close' ) { $ this -> disconnect ( ) ; } }
4748	public function getPlan ( string $ planCode ) : array { $ cacheKey = sprintf ( 'plan_%s' , $ planCode ) ; $ hit = $ this -> getFromCache ( $ cacheKey ) ; if ( false === $ hit ) { $ response = $ this -> sendRequest ( 'GET' , sprintf ( 'plans/%s' , $ planCode ) ) ; $ data = $ this -> processResponse ( $ response ) ; $ plan = $ data [ 'plan' ] ; $ this -> saveToCache ( $ cacheKey , $ plan ) ; return $ plan ; } return $ hit ; }
2647	public function addComment ( $ version , $ comment ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ comment ) ; return $ result ; }
6953	private function resolvePrice ( array $ entry , $ weight ) { $ price = $ count = 0 ; if ( $ weight > $ entry [ 'max_weight' ] ) { $ count = floor ( $ weight / $ entry [ 'max_weight' ] ) ; $ weight = round ( fmod ( $ weight , $ count ) , 3 ) ; } if ( 0 < $ count ) { $ max = end ( $ entry [ 'prices' ] ) [ 'price' ] ; $ price = $ count * $ max ; } foreach ( $ entry [ 'prices' ] as $ p ) { if ( 1 === bccomp ( $ p [ 'weight' ] , $ weight , 3 ) ) { $ price += $ p [ 'price' ] ; break ; } } return $ price ; }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
1314	public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; }
9539	private function getClosure ( $ parameter ) { $ closure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ closure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] -> parameterClosure ; } } return $ closure ; }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
4183	public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; }
9300	public function setOptions ( array $ options ) { if ( ! array_key_exists ( 'options' , $ options ) ) { $ options [ 'options' ] = array ( ) ; } $ this -> options = array_merge ( $ this -> getDefaultOptions ( ) , $ options [ 'options' ] ) ; return $ this ; }
10450	public function delete ( $ key ) { try { $ this -> get ( $ key ) ; } catch ( KeyNotFoundException $ e ) { return false ; } return $ this -> getClient ( ) -> delete ( $ key ) ; }
10514	private function updateObserverState ( \ StdClass $ observer ) { $ this -> event -> function = $ observer -> function ; $ observerObject = $ observer -> observer ; $ observerObject -> update ( $ this ) ; }
11549	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ authenticate = $ request -> getConfig ( ) -> getObject ( 'authenticate' ) ; if ( $ authenticate ) { $ this -> execute ( $ event , $ authenticate ) ; } }
8713	public function orWhereTranslated ( $ column , $ operator = null , $ value = null ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , 'or' ) ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
3912	protected function remapSorting ( $ arrFiles , $ arrSource ) { $ files = array ( ) ; $ source = array ( ) ; foreach ( array_keys ( $ arrFiles ) as $ k ) { $ files [ ] = $ arrFiles [ $ k ] ; $ source [ ] = $ arrSource [ $ k ] ; } $ this -> addClasses ( $ source ) ; return array ( 'files' => $ files , 'source' => $ source ) ; }
421	public function init ( ) { parent :: init ( ) ; if ( strncmp ( $ this -> db -> driverName , 'oci' , 3 ) !== 0 && strncmp ( $ this -> db -> driverName , 'odbc' , 4 ) !== 0 ) { throw new InvalidConfigException ( 'In order to use OracleMutex connection must be configured to use Oracle database.' ) ; } }
9953	public function mergeCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) !== false ) { $ this -> mergeCells [ $ pRange ] = $ pRange ; $ aReferences = Coordinate :: extractAllCellReferencesInRange ( $ pRange ) ; $ upperLeft = $ aReferences [ 0 ] ; if ( ! $ this -> cellExists ( $ upperLeft ) ) { $ this -> getCell ( $ upperLeft ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } $ count = count ( $ aReferences ) ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { if ( $ this -> cellExists ( $ aReferences [ $ i ] ) ) { $ this -> getCell ( $ aReferences [ $ i ] ) -> setValueExplicit ( null , DataType :: TYPE_NULL ) ; } } } else { throw new Exception ( 'Merge must be set on a range of cells.' ) ; } return $ this ; }
11067	protected function compileMixins ( ) { $ sql = array ( ) ; foreach ( $ this -> mixins as $ mixin ) { $ compiled = $ this -> { $ mixin } -> compile ( ) ; if ( $ compiled !== "" ) { $ sql [ ] = $ compiled ; } } return $ sql ; }
10145	private function makeKey ( $ block , $ valContext ) { $ pwarray = str_repeat ( "\0" , 64 ) ; for ( $ i = 0 ; $ i < 5 ; ++ $ i ) { $ pwarray [ $ i ] = $ valContext [ $ i ] ; } $ pwarray [ 5 ] = chr ( $ block & 0xff ) ; $ pwarray [ 6 ] = chr ( ( $ block >> 8 ) & 0xff ) ; $ pwarray [ 7 ] = chr ( ( $ block >> 16 ) & 0xff ) ; $ pwarray [ 8 ] = chr ( ( $ block >> 24 ) & 0xff ) ; $ pwarray [ 9 ] = "\x80" ; $ pwarray [ 56 ] = "\x48" ; $ md5 = new Xls \ MD5 ( ) ; $ md5 -> add ( $ pwarray ) ; $ s = $ md5 -> getContext ( ) ; return new Xls \ RC4 ( $ s ) ; }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
11411	public function usersOfTag ( $ tagId , $ nextOpenId = '' ) { $ params = [ 'tagid' => $ tagId , 'next_openid' => $ nextOpenId ] ; return $ this -> parseJSON ( 'json' , [ self :: API_USERS_OF_TAG , $ params ] ) ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
8820	public function getClientIP ( ) { $ ip = null ; $ client = $ this -> server ( 'HTTP_CLIENT_IP' ) ; $ forward = $ this -> server ( 'HTTP_X_FORWARDED_FOR' ) ; $ remote = $ this -> server ( 'REMOTE_ADDR' ) ; if ( filter_var ( $ client , FILTER_VALIDATE_IP ) ) { $ ip = $ client ; } elseif ( filter_var ( $ forward , FILTER_VALIDATE_IP ) ) { $ ip = $ forward ; } else { $ ip = $ remote ; } return $ ip ; }
9560	protected function renderCloseButton ( ) { if ( ( $ closeButton = $ this -> closeButton ) !== false ) { $ tag = ArrayHelper :: remove ( $ closeButton , 'tag' , 'button' ) ; $ label = ArrayHelper :: remove ( $ closeButton , 'label' , 'Close' ) ; if ( $ tag === 'button' && ! isset ( $ closeButton [ 'type' ] ) ) { $ closeButton [ 'type' ] = 'button' ; } return Html :: tag ( $ tag , $ label , $ closeButton ) ; } else { return null ; } }
6758	private function messageInMessage ( string $ message ) : string { $ decodedMessage = json_decode ( $ message , true ) ; if ( is_array ( $ decodedMessage ) && isset ( $ decodedMessage [ 'message' ] ) && is_string ( $ decodedMessage [ 'message' ] ) ) { return $ decodedMessage [ 'message' ] ; } return $ message ; }
9780	private function getLength ( $ value ) : int { if ( is_array ( $ value ) || $ value instanceof \ Countable ) return count ( $ value ) ; if ( $ value instanceof \ Traversable ) return iterator_count ( $ value ) ; if ( is_string ( $ value ) ) return mb_strlen ( $ value ) ; throw new \ InvalidArgumentException ( "The specified value is not iterable: $value" ) ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
3324	public function advance ( ) { if ( $ this -> index >= $ this -> length ) { throw new LogicException ( "Argument index out of bounds." ) ; } return $ this -> argv [ $ this -> index ++ ] ; }
5757	private function selectArray ( ? string $ selectColumns = null , array $ whereColumnsInfo = null , string $ orderBy = null ) : array { $ columns = $ selectColumns ?? $ this -> defaultSelectColumnsString ; $ permissionsArray = [ ] ; if ( null !== $ records = $ this -> select ( $ columns , $ whereColumnsInfo , $ orderBy ) ) { $ rolesTableMapper = RolesTableMapper :: getInstance ( ) ; foreach ( $ records as $ record ) { if ( null === $ key = $ this -> getPermissionsArrayKeyForId ( $ permissionsArray , ( int ) $ record [ 'id' ] ) ) { $ permissionsArray [ ] = [ 'id' => ( int ) $ record [ 'id' ] , 'title' => $ record [ 'title' ] , 'description' => $ record [ 'description' ] , 'roles' => [ $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ] , 'active' => Postgres :: convertPostgresBoolToBool ( $ record [ 'active' ] ) , 'created' => new \ DateTimeImmutable ( $ record [ 'created' ] ) , ] ; } else { array_push ( $ permissionsArray [ $ key ] [ 'roles' ] , $ rolesTableMapper -> getObjectById ( ( int ) $ record [ 'role_id' ] ) ) ; } } } return $ permissionsArray ; }
12219	public function errorHandler ( $ errno , $ errstr , $ errfile , $ errline , array $ errcontext = [ ] ) { $ codes = array ( 256 => 'E_USER_ERROR' , 512 => 'E_USER_WARNING' , 1024 => 'E_USER_NOTICE' , 2048 => 'E_STRICT' , 4096 => 'E_RECOVERABLE_ERROR' , 8192 => 'E_DEPRECATED' , 16384 => 'E_USER_DEPRECATED' , 8 => 'E_NOTICE' , 2 => 'E_WARNING' ) ; $ message = 'Error of level ' ; if ( array_key_exists ( $ errno , $ codes ) ) { $ message .= $ codes [ $ errno ] ; } else { $ message .= sprintf ( 'Unknown error level, code of %d passed' , $ errno ) ; } $ message .= sprintf ( '. Error message was "%s" in file %s at line %d.' , $ errstr , $ errfile , $ errline ) ; $ this -> container [ 'log' ] -> error ( $ message , $ errcontext ) ; $ this -> exceptionHandler ( new InternalServerError ( 'An unexpected error occurred.' ) ) ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
7847	public function info ( int $ id ) : ? array { $ this -> checkConfig ( ) ; $ key = sprintf ( 'smsgatewayme.info.%s' , $ id ) ; if ( $ this -> cache === true and Cache :: has ( $ key ) ) { $ message = [ 'code' => 200 , 'message' => 'OK' , 'data' => Cache :: get ( $ key ) , ] ; } else { $ response = Request :: get ( $ this -> baseUrl . 'message/' . $ id ) ; if ( $ response -> code == 200 ) { Cache :: put ( $ key , $ response -> body , 3600 * 24 ) ; } else { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } $ message = [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; } return $ message ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
8351	protected function toSqlLevel ( array $ tree ) : string { if ( count ( $ tree ) == 0 ) { return '' ; } $ sql = '(' ; reset ( $ tree ) ; if ( is_numeric ( key ( $ tree ) ) === true ) { foreach ( $ tree as $ elem ) { $ sql .= $ elem . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } elseif ( key ( $ tree ) === 'OR' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' OR ' ; } $ sql = substr ( $ sql , 0 , - 4 ) ; } elseif ( key ( $ tree ) === 'AND' ) { foreach ( $ tree as $ value ) { if ( is_array ( $ value ) === true ) { $ sql .= $ this -> toSqlLevel ( $ value ) ; } else { $ sql .= $ value ; } $ sql .= ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } else { foreach ( $ tree as $ key => $ value ) { $ sql .= $ key . ' = ' . $ value . ' AND ' ; } $ sql = substr ( $ sql , 0 , - 5 ) ; } $ sql .= ')' ; return $ sql ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
11275	protected function buildResponse ( ) { $ res = array ( ) ; $ res [ 'type' ] = $ this -> getParameters ( ) -> getType ( ) ; $ res [ 'tid' ] = $ this -> getParameters ( ) -> getTid ( ) ; $ res [ 'action' ] = $ this -> getParameters ( ) -> getAction ( ) ; $ res [ 'method' ] = $ this -> getParameters ( ) -> getMethod ( ) ; $ res [ 'result' ] = $ this -> getResult ( ) ; return $ res ; }
12009	public function setTitle ( string $ title ) : void { $ this -> title = $ this -> translator !== null ? $ this -> translator -> translate ( $ title ) : $ title ; }
10849	protected function fillDocument ( Document $ document , object $ object ) : bool { if ( $ object instanceof SearchableEntity ) { return $ object -> indexEntity ( $ document ) ; } $ mapping = $ this -> getMapping ( \ get_class ( $ object ) ) ; $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; foreach ( $ mapping as $ fieldName => $ propertyPath ) { $ document -> addField ( $ fieldName , $ accessor -> getValue ( $ object , $ propertyPath ) ) ; } return true ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
10874	public function getEncodeHash ( int $ id , string $ slug , string $ linkValidate = null ) : string { return base64_encode ( uniqid ( ( $ linkValidate ? strtotime ( $ linkValidate ) : self :: NO_TIME ) . self :: TIME_SEPARATOR , true ) . self :: PART_SEPARATOR . $ this -> getHash ( $ id . $ slug ) . self :: ID_SEPARATOR . $ id ) ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
12208	public function getSingleWidget ( ) { if ( is_null ( $ this -> _singleWidget ) ) { $ this -> _singleWidget = false ; $ widgets = $ this -> collectorItem -> getAll ( ) ; if ( ! empty ( $ widgets ) ) { $ widget = array_shift ( $ widgets ) ; $ this -> _singleWidget = Yii :: $ app -> collectors [ 'widgets' ] -> build ( $ this , $ widget -> object ) ; } } return $ this -> _singleWidget ; }
9317	public function perform ( $ src , $ dst ) { $ inClusterHandler = eZClusterFileHandler :: instance ( $ src ) ; $ inClusterHandler -> fetch ( ) ; try { $ this -> converter -> transform ( 'transformation' , $ src , $ dst ) ; } catch ( Exception $ e ) { $ inClusterHandler -> deleteLocal ( ) ; throw $ e ; } $ outClusterHandler = eZClusterFileHandler :: instance ( ) ; $ outClusterHandler -> fileStore ( $ dst , 'image' ) ; eZImageHandler :: changeFilePermissions ( $ dst ) ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
8877	public static function formatDate ( $ timestamp , $ type = 'full_sort' , $ format = '' , $ timezone = null ) { switch ( $ type ) { case 'date_sort' : $ format = 'Y-m-d' ; break ; case 'date_long' : $ format = 'l, F j, Y' ; break ; case 'date_med' : $ format = 'j M Y' ; break ; case 'date_short' : $ format = 'n/d/Y' ; break ; case 'time_sort' : $ format = 'H:i T' ; break ; case 'time_long' : $ format = 'g:i:s A T' ; break ; case 'time_med' : $ format = 'g:i:s A' ; break ; case 'time_short' : $ format = 'g:i A' ; break ; case 'full_sort' : $ format = 'Y-m-d H:i T' ; break ; case 'full_long' : $ format = 'l, F j, Y g:i A T' ; break ; case 'full_med' : $ format = 'j M Y g:i A T' ; break ; case 'full_short' : $ format = 'n/d/Y g:i A T' ; break ; case 'custom' : default : break ; } try { $ date = new \ DateTime ( gmdate ( 'c' , ( int ) $ timestamp ) ) ; if ( isset ( $ timezone ) ) { if ( ! is_object ( $ timezone ) ) { $ timezone = new \ DateTimeZone ( $ timezone ) ; } $ date -> setTimezone ( $ timezone ) ; } else { $ date -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; } } catch ( \ Exception $ e ) { throw new \ Exception ( "Error formatting date: $e" ) ; } return $ date -> format ( $ format ) ; }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
9123	private function retrieveAndParseResponse ( $ requestType ) { $ this -> payload = new MemoryStream ( ) ; $ this -> headers = array ( ) ; $ delimiterFound = false ; $ tmp = "" ; $ numBytes = 1 ; $ start = time ( ) ; while ( true ) { if ( ! $ this -> checkConnection ( $ start ) ) { continue ; } $ c = $ this -> read ( $ numBytes ) ; if ( $ c == null ) { break ; } $ start = time ( ) ; $ tmp .= $ c ; if ( ! $ delimiterFound ) { $ this -> handleHeader ( $ delimiterFound , $ numBytes , $ tmp ) ; } if ( $ delimiterFound ) { if ( $ requestType == 'HEAD' ) { break ; } $ this -> payload -> write ( $ tmp ) ; $ tmp = "" ; if ( $ this -> checkContentLengthExceeded ( ) ) { break ; } } } $ size = $ this -> payload -> count ( ) ; if ( $ size == 0 ) { return ; } $ this -> payload -> reset ( ) ; $ mayCompressed = $ this -> payload -> read ( $ size ) ; switch ( $ this -> getContentEncoding ( ) ) { case 'gzip' : $ uncompressed = gzdecode ( strstr ( $ mayCompressed , "\x1f\x8b" ) ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; case 'deflate' : $ uncompressed = gzuncompress ( $ mayCompressed ) ; $ this -> payload -> flush ( ) ; $ this -> payload -> write ( $ uncompressed ) ; break ; default : break ; } $ this -> payload -> reset ( ) ; }
769	public static function isFatalError ( $ error ) { return isset ( $ error [ 'type' ] ) && in_array ( $ error [ 'type' ] , [ E_ERROR , E_PARSE , E_CORE_ERROR , E_CORE_WARNING , E_COMPILE_ERROR , E_COMPILE_WARNING , self :: E_HHVM_FATAL_ERROR ] ) ; }
7788	public function setContraAccountClass ( $ contraAccountClass ) { if ( ! is_callable ( $ contraAccountClass ) && ! class_exists ( $ contraAccountClass ) ) { throw new \ InvalidArgumentException ( '$contraAccountClass must be a valid classname or a PHP callable' ) ; } $ this -> contraAccountClass = $ contraAccountClass ; return $ this ; }
8081	public function error ( $ message ) { if ( $ message ) { if ( is_int ( $ message ) && isset ( $ this -> errorList [ $ message ] ) ) { $ errorMessage = $ this -> errorList [ $ message ] ; $ this -> report ( "Error[{$message}]: {$errorMessage}" ) ; } else { $ errorMessage = $ message ; $ this -> report ( "Error: {$errorMessage}" ) ; } $ errors = & $ this -> getErrors ( ) ; $ errors [ ] = $ errorMessage ; } return $ this ; }
5930	public function removeCategory ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
10263	public function getCreditCard ( $ weighted = true ) { if ( $ weighted ) { $ weight [ ] = [ 'American Express' , 1 ] ; $ weight [ ] = [ 'Discover' , 2 ] ; $ weight [ ] = [ 'MasterCard' , 10 ] ; $ weight [ ] = [ 'Visa' , 10 ] ; foreach ( $ weight as $ w ) { $ type = $ w [ 0 ] ; $ count = $ w [ 1 ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ card_types [ ] = $ type ; } } } else { $ card_types = [ 'American Express' , 'Discover' , 'MasterCard' , 'Visa' ] ; } $ cc = new Entities \ CreditCard ; $ cc -> type = $ this -> fromArray ( $ card_types ) ; $ cc -> number = $ this -> getBankNumber ( $ cc -> type ) ; $ cc -> expiration = $ this -> getExpiration ( ) ; return $ cc ; }
5868	public static function getMetadata ( $ fileName , $ fullExtract = false ) { $ metadata = static :: getBasicMetadata ( $ fileName ) ; if ( $ fullExtract && ! empty ( $ metadata ) ) { $ virtualFileObject = static :: getVirtualFileObject ( $ fileName , $ metadata ) ; $ extractorRegistry = \ TYPO3 \ CMS \ Core \ Resource \ Index \ ExtractorRegistry :: getInstance ( ) ; $ extractionServices = $ extractorRegistry -> getExtractorsWithDriverSupport ( 'Local' ) ; $ newMetadata = [ 0 => $ metadata , ] ; foreach ( $ extractionServices as $ service ) { if ( $ service -> canProcess ( $ virtualFileObject ) ) { $ newMetadata [ $ service -> getPriority ( ) ] = $ service -> extractMetaData ( $ virtualFileObject , $ newMetadata ) ; } } ksort ( $ newMetadata ) ; foreach ( $ newMetadata as $ data ) { $ metadata = array_merge ( $ metadata , $ data ) ; } } return $ metadata ; }
2089	public static function findPublishedBySourceAndParent ( $ strSource , $ intParent , $ blnDesc = false , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = ( $ blnDesc ? "$t.date DESC" : "$t.date" ) ; } return static :: findBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) , $ arrOptions ) ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
7077	static public function getSaleEditableDocumentTypes ( SaleInterface $ sale ) { $ types = [ ] ; foreach ( DocumentTypes :: getTypes ( ) as $ type ) { if ( ! static :: isSaleSupportsDocumentType ( $ sale , $ type ) ) { continue ; } foreach ( $ sale -> getAttachments ( ) as $ attachment ) { if ( $ attachment -> getType ( ) === $ type ) { continue 2 ; } } $ types [ ] = $ type ; } return $ types ; }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
1029	private function resolveOrError ( $ fieldDef , $ fieldNode , $ resolveFn , $ source , $ context , $ info ) { try { $ args = Values :: getArgumentValues ( $ fieldDef , $ fieldNode , $ this -> exeContext -> variableValues ) ; return $ resolveFn ( $ source , $ args , $ context , $ info ) ; } catch ( Exception $ error ) { return $ error ; } catch ( Throwable $ error ) { return $ error ; } }
12710	public function make ( $ instance , $ parameters = [ ] ) { return $ this -> resolve ( $ instance , is_array ( $ parameters ) ? $ parameters : array_slice ( func_get_args ( ) , 1 ) ) ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
793	public function getAttributes ( $ names = null , $ except = [ ] ) { $ values = [ ] ; if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } foreach ( $ names as $ name ) { $ values [ $ name ] = $ this -> $ name ; } foreach ( $ except as $ name ) { unset ( $ values [ $ name ] ) ; } return $ values ; }
9426	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -title {$options['title']}" ; } if ( isset ( $ options [ 'subtitle' ] ) ) { $ command .= " -subtitle {$options['subtitle']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -message {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ command .= " -appIcon {$options['image']}" ; } if ( isset ( $ options [ 'contentImage' ] ) ) { $ command .= " -contentImage {$options['contentImage']}" ; } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " -open {$options['url']}" ; } return $ command ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
4886	public function plugin ( $ plugin , $ options = null ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'getHelperPluginManager' ) ) { return true === $ options ? false : new HelperProxy ( false ) ; } $ manager = $ renderer -> getHelperPluginManager ( ) ; $ hasPlugin = $ manager -> has ( $ plugin ) ; if ( true === $ options ) { return $ hasPlugin ; } if ( $ hasPlugin ) { $ pluginInstance = $ manager -> get ( $ plugin , $ options ) ; } else { $ pluginInstance = false ; } return new HelperProxy ( $ pluginInstance ) ; }
2806	public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } }
8702	public function saveElementAsFile ( $ fileName ) { $ this -> getString ( ) ; if ( false === file_put_contents ( $ fileName , $ this -> elementString ) ) { return false ; } else { return $ fileName ; } }
3589	protected function saveMeta ( ) { foreach ( $ this -> getMetaAttributes ( ) as $ attribute ) { if ( is_null ( $ attribute -> getValue ( ) ) ) { $ attribute -> delete ( ) ; } else { $ this -> metaAttributes ( ) -> save ( $ attribute ) ; } } }
508	protected function composeFields ( $ id = null , $ data = null ) { $ fields = $ this -> writeCallback ? call_user_func ( $ this -> writeCallback , $ this ) : [ ] ; if ( $ id !== null ) { $ fields [ 'id' ] = $ id ; } if ( $ data !== null ) { $ fields [ 'data' ] = $ data ; } return $ fields ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
5429	public function getParent ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; $ parent = $ reflection -> getParentClass ( ) ; if ( $ parent ) { return $ parent -> getName ( ) ; } return false ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
6333	public function validateChecksum ( $ string ) { $ xml = new \ SimpleXMLElement ( $ string ) ; $ checksum = ( string ) $ xml -> Authentication -> Checksum ; $ original = str_replace ( $ checksum , $ this -> getMerchantPassword ( ) , $ string ) ; return md5 ( $ original ) == $ checksum ; }
1636	protected function formatQuery ( $ sql , array $ bindings , $ time , $ connection ) { $ data = [ 'sql' => $ sql ] ; foreach ( $ bindings as $ index => $ binding ) { $ data [ "binding {$index}" ] = $ binding ; } $ data [ 'time' ] = "{$time}ms" ; $ data [ 'connection' ] = $ connection ; return $ data ; }
987	public function chargeParams ( ) { $ chargeDetails = [ 'name' => $ this -> plan -> name , 'price' => $ this -> plan -> price , 'test' => $ this -> plan -> isTest ( ) , 'trial_days' => $ this -> plan -> hasTrial ( ) ? $ this -> plan -> trial_days : 0 , 'return_url' => URL :: secure ( Config :: get ( 'shopify-app.billing_redirect' ) , [ 'plan_id' => $ this -> plan -> id ] ) , ] ; if ( isset ( $ this -> plan -> capped_amount ) && $ this -> plan -> capped_amount > 0 ) { $ chargeDetails [ 'capped_amount' ] = $ this -> plan -> capped_amount ; $ chargeDetails [ 'terms' ] = $ this -> plan -> terms ; } return $ chargeDetails ; }
1532	protected function deserialize ( array $ document , $ record = null ) : ResourceObject { $ data = $ document [ 'data' ] ?? [ ] ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { throw new \ InvalidArgumentException ( 'Expecting a JSON API document with a data member.' ) ; } return ResourceObject :: create ( $ data ) ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
2434	public function set ( $ strKey , $ varValue ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ strKey , $ varValue ) ; } else { $ this -> sessionBag -> set ( $ strKey , $ varValue ) ; } }
11301	public function getFieldName ( $ attributeName ) { if ( isset ( $ this -> model_attributes [ $ attributeName ] [ 'field' ] ) ) { return $ this -> model_attributes [ $ attributeName ] [ 'field' ] ; } return $ attributeName ; }
6952	private function isSaleItemCovered ( Common \ SaleItemInterface $ saleItem , array $ coveredIds ) { if ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) { return true ; } if ( ! in_array ( $ saleItem -> getId ( ) , $ coveredIds , true ) ) { return false ; } foreach ( $ saleItem -> getChildren ( ) as $ child ) { if ( ! $ this -> isSaleItemCovered ( $ child , $ coveredIds ) ) { return false ; } } return true ; }
11120	protected function runMigration ( array $ file ) { $ this -> repository -> transaction ( function ( SqlMigrationRepository $ repo ) use ( $ file ) { $ contents = ( string ) $ this -> filesystem -> read ( $ file [ 'path' ] ) ; $ repo -> execute ( $ contents ) ; } ) ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
3811	protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; }
3948	private function buildMap ( ) { $ map = [ ] ; foreach ( $ this -> combination -> getParented ( ) as $ childName => $ child ) { $ map [ $ child [ 'meta' ] [ 'ptable' ] ] [ $ childName ] = $ child ; } return $ map ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
3885	private function collectRulesFor ( $ parentSetting , $ filterSettings ) { $ childInformation = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'pid' , $ parentSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ childInformation -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ childSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ childSetting ) { $ parentSetting -> addChild ( $ childSetting ) ; } } }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
4389	public function repay ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; if ( ( $ cfg = $ this -> getCustomerData ( $ base -> getCustomerId ( ) , 'repay' ) ) === null ) { $ msg = sprintf ( 'No reoccurring payment data available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } if ( ! isset ( $ cfg [ 'token' ] ) ) { $ msg = sprintf ( 'No payment token available for customer ID "%1$s"' , $ base -> getCustomerId ( ) ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( $ msg ) ; } $ data = array ( 'transactionId' => $ order -> getId ( ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'cardReference' => $ cfg [ 'token' ] , 'paymentPage' => false , ) ; if ( isset ( $ cfg [ 'month' ] ) && isset ( $ cfg [ 'year' ] ) ) { $ data [ 'card' ] = new \ Omnipay \ Common \ CreditCard ( [ 'expiryMonth' => $ cfg [ 'month' ] , 'expiryYear' => $ cfg [ 'year' ] , ] ) ; } $ response = $ this -> getXmlProvider ( ) -> purchase ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ this -> saveTransationRef ( $ base , $ response -> getTransactionReference ( ) ) ; $ order -> setPaymentStatus ( \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ) ; $ this -> saveOrder ( $ order ) ; } else { $ msg = ( method_exists ( $ response , 'getMessage' ) ? $ response -> getMessage ( ) : '' ) ; throw new \ Aimeos \ MShop \ Service \ Exception ( sprintf ( 'Token based payment failed: %1$s' , $ msg ) ) ; } }
6818	protected function writeInvoiceGoodsLines ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ taxRule = $ this -> taxResolver -> resolveSaleTaxRule ( $ sale ) ; $ discounts = $ sale -> getAdjustments ( AdjustmentTypes :: TYPE_DISCOUNT ) -> toArray ( ) ; $ amounts = [ ] ; foreach ( $ this -> invoice -> getLinesByType ( DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( $ line -> getSaleItem ( ) -> isPrivate ( ) ) { continue ; } $ rates = $ line -> getTaxRates ( ) ; if ( empty ( $ rates ) ) { $ rate = 0 ; } elseif ( 1 === count ( $ rates ) ) { $ rate = current ( $ rates ) ; } else { throw new LogicException ( "Multiple tax rates on goods lines are not yet supported." ) ; } $ amount = $ line -> getBase ( ) ; if ( ! empty ( $ discounts ) ) { $ base = $ amount ; foreach ( $ discounts as $ adjustment ) { if ( $ adjustment -> getMode ( ) === AdjustmentModes :: MODE_PERCENT ) { $ amount -= $ this -> round ( $ amount * $ adjustment -> getAmount ( ) / 100 ) ; } else { $ amount -= $ this -> round ( $ base / $ this -> invoice -> getGoodsBase ( ) * $ adjustment -> getAmount ( ) ) ; } } } if ( ! isset ( $ amounts [ ( string ) $ rate ] ) ) { $ amounts [ ( string ) $ rate ] = 0 ; } $ amounts [ ( string ) $ rate ] += $ this -> round ( $ amount ) ; } $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ amounts as $ rate => $ amount ) { $ amount = $ this -> round ( $ amount ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getGoodAccountNumber ( $ taxRule , ( float ) $ rate , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
9788	public function setConditions ( $ pValue ) { if ( ! is_array ( $ pValue ) ) { $ pValue = [ $ pValue ] ; } $ this -> condition = $ pValue ; return $ this ; }
8385	public function groupBy ( $ groupBy ) { if ( is_array ( $ groupBy ) === true ) { $ this -> groupBy = implode ( ', ' , $ groupBy ) ; } else { $ this -> groupBy = $ groupBy ; } return $ this ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
6510	protected function initHandler ( HandlerInterface $ handler ) { if ( $ this -> formatter != null ) { $ handler -> setFormatter ( $ this -> formatter ) ; } foreach ( $ this -> processors as $ processor ) { $ handler -> pushProcessor ( $ processor ) ; } return $ handler ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
5882	protected static function read_1_byte ( $ handle ) { $ c = fgetc ( $ handle ) ; if ( $ c === false ) { throw new \ RuntimeException ( 'Premature EOF in JPEG file' , 1363533326 ) ; } return ord ( $ c ) ; }
11520	protected function GenerateWindowsPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata , Image $ WindowsPinicon ) { $ metadata .= $ owner -> MarkupComment ( 'Windows Pinned Icon' ) ; $ appName = $ config -> fetchPiniconTitle ( ) ; if ( ! $ appName ) { $ appName = $ config -> Title ; } $ metadata .= $ owner -> MarkupMeta ( 'application-name' , $ appName ) ; if ( $ config -> fetchWindowsPiniconBackgroundColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'msapplication-TileColor' , $ config -> fetchWindowsPiniconBackgroundColor ( ) ) ; } $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square70x70logo' , $ WindowsPinicon -> Fill ( 70 , 70 ) -> getAbsoluteURL ( ) ) ; $ metadata .= $ owner -> MarkupMeta ( 'msapplication-square150x150logo' , $ WindowsPinicon -> Fill ( 150 , 150 ) -> getAbsoluteURL ( ) ) ; }
7049	protected function buildGoodsLines ( Document \ DocumentInterface $ document ) { foreach ( $ document -> getSale ( ) -> getItems ( ) as $ item ) { $ this -> buildGoodLine ( $ item , $ document ) ; } }
3860	protected function getAttributeNames ( ) { $ arrAttributes = $ this -> objView -> getSettingNames ( ) ; $ strDesiredLanguage = $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ; $ strFallbackLanguage = $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ; $ intFilterSettings = 0 ; foreach ( ( array ) $ this -> getView ( ) -> get ( 'jumpTo' ) as $ arrJumpTo ) { if ( ! $ this -> getMetaModel ( ) -> isTranslated ( ) || $ arrJumpTo [ 'langcode' ] == $ strDesiredLanguage || $ arrJumpTo [ 'langcode' ] == $ strFallbackLanguage ) { $ intFilterSettings = $ arrJumpTo [ 'filter' ] ; if ( $ strDesiredLanguage == $ arrJumpTo [ 'langcode' ] ) { break ; } } } if ( $ intFilterSettings ) { $ objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ intFilterSettings ) ; $ arrAttributes = array_merge ( $ objFilterSettings -> getReferencedAttributes ( ) , $ arrAttributes ) ; } return $ arrAttributes ; }
11291	protected function _getAttributeDataWhenSet ( $ attributeName , $ query = false , $ loadMap = false , $ record = false ) { if ( is_numeric ( $ this -> model_data [ $ attributeName ] ) ) { if ( $ this -> _isRelation ( $ attributeName ) && ! isset ( $ this -> model_dynamicOff ) ) { $ this -> $ attributeName = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap , $ record ) ; } } $ this -> beforeGet ( $ attributeName ) ; $ returnValue = $ this -> model_data [ $ attributeName ] ; $ this -> afterGet ( $ attributeName , $ returnValue ) ; return $ returnValue ; }
7904	protected function renderSides ( $ sides ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , $ this -> sidesOptions ) ; foreach ( $ sides as $ side ) { if ( ! array_key_exists ( 'content' , $ side ) ) { throw new InvalidConfigException ( "The 'content' option is required per sides" ) ; } $ options = ArrayHelper :: getValue ( $ side , 'options' , [ ] ) ; Ui :: addCssClass ( $ options , 'side' ) ; $ active = ArrayHelper :: getValue ( $ side , 'active' , false ) ; if ( $ active === true ) { Ui :: addCssClass ( $ options , 'active' ) ; } $ lines [ ] = Html :: tag ( 'div' , $ side [ 'content' ] , $ options ) ; } $ lines [ ] = Html :: endTag ( 'div' ) ; return implode ( "\n" , $ lines ) ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
11863	public function setHandledDataItem ( $ value ) { if ( isset ( $ this -> _pairedDataItem ) ) { $ this -> pairedDataItem -> handledDataItem = $ value ; } if ( ! $ this -> _handledDataItem && $ value ) { $ this -> dataSource -> reduceRemaining ( $ this ) ; } $ this -> clean ( ) ; return $ this -> _handledDataItem = $ value ; }
8658	private function convertRequestReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RequestReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetStartDate ( ) ) { $ parameters [ 'StartDate' ] = $ this -> getFormattedTimestamp ( $ request -> getStartDate ( ) ) ; } if ( $ request -> isSetEndDate ( ) ) { $ parameters [ 'EndDate' ] = $ this -> getFormattedTimestamp ( $ request -> getEndDate ( ) ) ; } if ( $ request -> isSetReportOptions ( ) ) { $ parameters [ 'ReportOptions' ] = $ request -> getReportOptions ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7058	protected function getStockAdjustmentFromEvent ( ResourceEventInterface $ event ) { $ stockAdjustment = $ event -> getResource ( ) ; if ( ! $ stockAdjustment instanceof StockAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . StockAdjustmentInterface :: class ) ; } return $ stockAdjustment ; }
10364	public function offsetSet ( $ item , $ node ) { if ( $ item !== null ) { throw new ValueException ( $ item , 'null' ) ; } return $ this -> nodes [ ] = $ node ; }
160	public function andHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'and' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
5280	public function select ( $ fields = '' ) { if ( empty ( $ fields ) ) { return $ this ; } if ( is_string ( $ fields ) ) { $ this -> statements [ 'select' ] [ ] = $ fields ; return $ this ; } foreach ( $ fields as $ key => $ field ) { if ( is_string ( $ key ) ) { $ this -> statements [ 'select' ] [ ] = "$key as $field" ; } else { $ this -> statements [ 'select' ] [ ] = $ field ; } } return $ this ; }
8983	public function isSame ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were identical: ' , [ ] , $ expected , $ actual , $ message ) ; }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
68	public function junction ( $ target , $ junction ) { if ( ! Platform :: isWindows ( ) ) { throw new \ LogicException ( sprintf ( 'Function %s is not available on non-Windows platform' , __CLASS__ ) ) ; } if ( ! is_dir ( $ target ) ) { throw new IOException ( sprintf ( 'Cannot junction to "%s" as it is not a directory.' , $ target ) , 0 , null , $ target ) ; } $ cmd = sprintf ( 'mklink /J %s %s' , ProcessExecutor :: escape ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) ) , ProcessExecutor :: escape ( realpath ( $ target ) ) ) ; if ( $ this -> getProcess ( ) -> execute ( $ cmd , $ output ) !== 0 ) { throw new IOException ( sprintf ( 'Failed to create junction to "%s" at "%s".' , $ target , $ junction ) , 0 , null , $ target ) ; } clearstatcache ( true , $ junction ) ; }
1516	public function readRelatedResource ( StoreInterface $ store , FetchRelated $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelated ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> content ( $ related ) ; }
12868	public function resetPassword ( Token $ token ) { if ( ! $ this -> validate ( ) || $ token -> user === null ) { return false ; } if ( $ token -> user -> resetPassword ( $ this -> password ) ) { \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your password has been changed successfully.' ) ) ; $ token -> delete ( ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'An error occurred and your password has not been changed. Please try again later.' ) ) ; } return true ; }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
10155	private function readMulRk ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ colFirst = self :: getUInt2d ( $ recordData , 2 ) ; $ colLast = self :: getUInt2d ( $ recordData , $ length - 2 ) ; $ columns = $ colLast - $ colFirst + 1 ; $ offset = 4 ; for ( $ i = 1 ; $ i <= $ columns ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ colFirst + $ i ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , $ offset ) ; $ numValue = self :: getIEEE754 ( self :: getInt4d ( $ recordData , $ offset + 2 ) ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } $ cell -> setValueExplicit ( $ numValue , DataType :: TYPE_NUMERIC ) ; } $ offset += 6 ; } }
9910	function toArray ( ) { $ result = array ( ) ; $ object_vars = get_object_vars ( $ this ) ; foreach ( $ object_vars as $ key => $ value ) { if ( $ value == null ) { continue ; } if ( gettype ( $ value ) == "object" && is_subclass_of ( $ value , 'AbstractJSONWrapper' ) ) { if ( ! $ value -> isEmpty ( ) ) { $ result [ $ key ] = $ value -> toArray ( ) ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; }
12435	public function add ( $ id , IFormField $ field ) { $ field -> setId ( $ id ) ; return $ this -> addFormField ( $ field ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
1276	private function isMailInnovations ( ) { $ patterns = [ '/^MI\d{6}\d{1,22}$/' , '/^94071\d{17}$/' , '/^7\d{19}$/' , '/^93033\d{17}$/' , '/^M\d{9}$/' , '/^82\d{10}$/' , '/^EC\d{9}US$/' , '/^927\d{23}$/' , '/^927\d{19}$/' , '/^EA\d{9}US$/' , '/^CP\d{9}US$/' , '/^92055\d{17}$/' , '/^14\d{18}$/' , '/^92088\d{17}$/' , '/^RA\d{9}US$/' , '/^9202\d{16}US$/' , '/^23\d{16}US$/' , '/^94\d{20}$/' , '/^03\d{18}$/' ] ; foreach ( $ patterns as $ pattern ) { if ( preg_match ( $ pattern , $ this -> trackingNumber ) ) { return true ; } } return false ; }
7021	private function format_s ( & $ str ) { if ( strstr ( $ str , '%s' ) ) $ str = str_replace ( '%s' , sprintf ( '%02d' , $ this -> sec ) , $ str ) ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
3436	protected function fetchAllPropsForSelect ( ) { $ props = [ ] ; $ rsProps = static :: $ cIblockObject -> GetProperties ( $ this -> iblockId ) ; while ( $ prop = $ rsProps -> Fetch ( ) ) { $ props [ ] = 'PROPERTY_' . $ prop [ 'CODE' ] ; } return $ props ; }
4208	private function isObjExcluded ( $ obj ) { if ( \ in_array ( \ get_class ( $ obj ) , $ this -> abstracter -> getCfg ( 'objectsExclude' ) ) ) { return true ; } foreach ( $ this -> abstracter -> getCfg ( 'objectsExclude' ) as $ exclude ) { if ( \ is_subclass_of ( $ obj , $ exclude ) ) { return true ; } } return false ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
4251	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ table = array ( ) ; $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ headerVals = $ keys ; foreach ( $ headerVals as $ i => $ val ) { if ( $ val === MethodTable :: SCALAR ) { $ headerVals [ $ i ] = 'value' ; } } \ array_unshift ( $ headerVals , '' ) ; $ table [ ] = $ headerVals ; $ classNames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { $ values [ $ k2 ] = null ; } } $ classNames [ ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; \ array_unshift ( $ values , $ k ) ; $ table [ ] = \ array_values ( $ values ) ; } if ( \ array_filter ( $ classNames ) ) { \ array_unshift ( $ table [ 0 ] , '' ) ; foreach ( $ classNames as $ i => $ className ) { \ array_splice ( $ table [ $ i + 1 ] , 1 , 0 , $ className ) ; } } return $ table ; }
8850	public function rss ( ) { $ rss = new RSSFeed ( $ this -> getBlogPosts ( ) , $ this -> Link ( ) , $ this -> MetaTitle , $ this -> MetaDescription ) ; $ this -> extend ( 'updateRss' , $ rss ) ; return $ rss -> outputToBrowser ( ) ; }
8372	public function help ( Request $ request ) { $ routes = Console :: getRoutes ( ) ; echo 'strayFw console help screen' . PHP_EOL . 'Available actions :' . PHP_EOL . PHP_EOL ; $ namespace = null ; foreach ( $ routes as $ route ) { if ( $ namespace != $ route [ 'namespace' ] ) { $ namespace = $ route [ 'namespace' ] ; echo $ namespace . PHP_EOL . PHP_EOL ; } echo ' ' . $ route [ 'usage' ] . PHP_EOL ; if ( isset ( $ route [ 'help' ] ) != null ) { echo ' ' . $ route [ 'help' ] ; } echo PHP_EOL . PHP_EOL ; } }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
11801	public function hookTemplateRender ( $ templates , $ data , $ rendered , $ controller ) { $ template = reset ( $ templates ) ; if ( strpos ( $ template , '/modules/ga_report/templates/panels/' ) !== false && isset ( $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) && isset ( $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ) ) { $ handler_id = $ data [ 'content' ] [ 'data' ] [ 'handler' ] [ 'id' ] ; $ controller -> setJsSettings ( "ga_chart_$handler_id" , $ data [ 'content' ] [ 'data' ] [ 'report' ] [ 'data' ] ) ; $ controller -> setJs ( __DIR__ . "/js/handlers/$handler_id.js" ) ; $ controller -> setJs ( __DIR__ . "/js/common.js" ) ; } }
3150	public function comment ( RunnerServiceContext $ context , $ comment ) { $ testSession = $ context -> getTestSession ( ) ; $ item = $ testSession -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ occurrence = $ testSession -> getCurrentAssessmentItemRefOccurence ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; $ transmissionId = "${sessionId}.${item}.${occurrence}" ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ transmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ resultStore ) ; $ itemUri = TestRunnerUtils :: getCurrentItemUri ( $ testSession ) ; $ testUri = $ testSession -> getTest ( ) -> getUri ( ) ; $ variable = new ResponseVariable ( 'comment' , Cardinality :: SINGLE , BaseType :: STRING , new QtismString ( $ comment ) ) ; $ transmitter -> transmitItemVariable ( $ variable , $ transmissionId , $ itemUri , $ testUri ) ; return true ; }
6984	protected function extractInputFromRules ( $ data , array $ rules ) { $ keys = collect ( $ rules ) -> keys ( ) -> map ( function ( $ rule ) { return explode ( '.' , $ rule ) [ 0 ] ; } ) -> unique ( ) -> toArray ( ) ; if ( ! ( $ data instanceof Request ) ) { $ data = collect ( $ data ) ; } return $ data -> only ( $ keys ) ; }
7784	public function addParser ( $ name , $ class , $ before = null ) { if ( $ before === null ) { $ this -> parsers [ $ name ] = $ class ; return $ this ; } if ( ( $ offset = array_search ( $ before , array_keys ( $ this -> parsers ) ) ) !== false ) { $ this -> parsers = array_slice ( $ this -> parsers , 0 , $ offset , true ) + array ( $ name => $ class ) + array_slice ( $ this -> parsers , $ offset , null , true ) ; return $ this ; } throw new \ RuntimeException ( sprintf ( 'Parser "%s" does not exist.' , $ before ) ) ; }
4809	public function deactivate ( ) { $ this -> clear_schedule ( ) ; if ( ! is_multisite ( ) || wp_is_large_network ( ) ) { return ; } $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites and $ sites = array_diff ( $ sites , [ get_current_blog_id ( ) ] ) ; foreach ( $ sites as $ site ) { switch_to_blog ( $ site ) ; $ this -> clear_schedule ( ) ; } restore_current_blog ( ) ; delete_site_option ( $ this -> args [ 'name' ] . '_sites' ) ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
12739	public function removeClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; $ className = '' ; foreach ( $ classParts as $ part ) { if ( $ name != $ part ) { $ className .= ' ' . $ part ; } } $ this -> tags [ 'class' ] = trim ( $ className ) ; }
703	public function parse ( $ rawBody , $ contentType ) { try { $ parameters = Json :: decode ( $ rawBody , $ this -> asArray ) ; return $ parameters === null ? [ ] : $ parameters ; } catch ( InvalidArgumentException $ e ) { if ( $ this -> throwException ) { throw new BadRequestHttpException ( 'Invalid JSON data in request body: ' . $ e -> getMessage ( ) ) ; } return [ ] ; } }
10243	public function isImplemented ( $ pFunction ) { $ pFunction = strtoupper ( $ pFunction ) ; $ notImplemented = ! isset ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] ) || ( is_array ( self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] ) && self :: $ phpSpreadsheetFunctions [ $ pFunction ] [ 'functionCall' ] [ 1 ] === 'DUMMY' ) ; return ! $ notImplemented ; }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
6833	public function userHasRight ( array $ user , $ right ) { $ hasRight = false ; if ( isset ( $ user [ 'role' ] ) && ! empty ( $ right ) && isset ( $ this -> _rightsConfig [ $ right ] ) ) { if ( in_array ( $ user [ 'role' ] , $ this -> _rightsConfig [ $ right ] ) ) { $ hasRight = true ; } } return $ hasRight ; }
10871	public function existLogin ( string $ login ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'login' => $ login ] ) -> fetchSingle ( ) ; }
1750	public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; }
5846	public function syslog ( $ message , $ severity = \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK ) { switch ( $ severity ) { case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: NOTICE : $ severity = GeneralUtility :: SYSLOG_SEVERITY_NOTICE ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: INFO : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: OK : $ severity = GeneralUtility :: SYSLOG_SEVERITY_INFO ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: WARNING : $ severity = GeneralUtility :: SYSLOG_SEVERITY_WARNING ; break ; case \ TYPO3 \ CMS \ Core \ Messaging \ FlashMessage :: ERROR : $ severity = GeneralUtility :: SYSLOG_SEVERITY_ERROR ; break ; } GeneralUtility :: sysLog ( $ message , 'image_autoresize' , $ severity ) ; }
1646	public function getLength ( DistanceInterface $ calculator ) : float { $ distance = 0.0 ; if ( count ( $ this -> points ) <= 1 ) { return $ distance ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ distance += $ segment -> getLength ( $ calculator ) ; } return $ distance ; }
10252	public function getLastName ( $ max = 250 ) { return LastName :: where ( 'rank' , '<=' , $ max ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
381	public function createServerInformationLink ( ) { $ serverUrls = [ 'http://httpd.apache.org/' => [ 'apache' ] , 'http://nginx.org/' => [ 'nginx' ] , 'http://lighttpd.net/' => [ 'lighttpd' ] , 'http://gwan.com/' => [ 'g-wan' , 'gwan' ] , 'http://iis.net/' => [ 'iis' , 'services' ] , 'https://secure.php.net/manual/en/features.commandline.webserver.php' => [ 'development' ] , ] ; if ( isset ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) ) { foreach ( $ serverUrls as $ url => $ keywords ) { foreach ( $ keywords as $ keyword ) { if ( stripos ( $ _SERVER [ 'SERVER_SOFTWARE' ] , $ keyword ) !== false ) { return '<a href="' . $ url . '" target="_blank">' . $ this -> htmlEncode ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) . '</a>' ; } } } } return '' ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
5533	public function paintRectangleStart ( $ node , $ horiz , $ vert ) { $ name = $ node -> getName ( ) ; $ description = $ node -> getDescription ( ) ; $ status = $ node -> getStatus ( ) ; echo "<div title=\"$name: $description\" class=\"$status\" style=\"width:{$horiz}%;height:{$vert}%\">" ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
4130	public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; }
12714	protected function resolveMethodParameters ( $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 of %s must be an array." , __METHOD__ ) ) ; } foreach ( $ params as $ key => $ value ) { if ( $ value instanceof \ ReflectionParameter ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ params [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } else { $ params [ $ key ] = ( $ value -> isDefaultValueAvailable ( ) ? $ value -> getDefaultValue ( ) : null ) ; } } else { if ( is_string ( $ value ) && class_exists ( $ value ) ) { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ value ) ; } elseif ( $ value instanceof \ Closure ) { $ params [ $ key ] = $ value ( $ this ) ; } else { $ params [ $ key ] = $ value ; } } } return $ params ; }
577	protected static function normalizeRoute ( $ route ) { $ route = Yii :: getAlias ( ( string ) $ route ) ; if ( strncmp ( $ route , '/' , 1 ) === 0 ) { return ltrim ( $ route , '/' ) ; } if ( Yii :: $ app -> controller === null ) { throw new InvalidArgumentException ( "Unable to resolve the relative route: $route. No active controller is available." ) ; } if ( strpos ( $ route , '/' ) === false ) { return $ route === '' ? Yii :: $ app -> controller -> getRoute ( ) : Yii :: $ app -> controller -> getUniqueId ( ) . '/' . $ route ; } return ltrim ( Yii :: $ app -> controller -> module -> getUniqueId ( ) . '/' . $ route , '/' ) ; }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
3259	public function placeTransaction ( $ gateway , $ transactionId , $ detail = null , $ token = null ) { return call_user_func ( Config :: get ( 'shop.transaction' ) . '::create' , [ 'order_id' => $ this -> attributes [ 'id' ] , 'gateway' => $ gateway , 'transaction_id' => $ transactionId , 'detail' => $ detail , 'token' => $ token , ] ) ; }
12712	public function getResolvedConcreteFlag ( $ abstract ) { if ( ! $ this -> hasResolvedConcrete ( $ abstract ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be an abstract class name which exists in resolved concrete stack." , __METHOD__ ) ) ; } return explode ( '|' , $ this -> resolved [ $ abstract ] [ 'flag' ] ) ; }
4522	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Config ) { return ; } $ key = $ entity -> getKey ( ) ; $ encrypt = $ this -> configCollection -> get ( $ key ) [ 'encrypt' ] ; $ entity -> setEncrypt ( $ encrypt ) ; }
6727	public function set_movie_votes ( $ post_id , $ total_votes ) { $ total_votes = $ total_votes ? : 'N/B' ; if ( ! add_post_meta ( $ post_id , 'imdbVotes' , $ total_votes , true ) ) { update_post_meta ( $ post_id , 'imdbVotes' , $ total_votes ) ; } }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
11979	public function transformCard ( AbstractMessage $ message ) { $ type = $ message -> getType ( ) ; return [ 'msgtype' => $ type , $ type => [ 'card_id' => $ message -> get ( 'card_id' ) , ] , ] ; }
10505	private function registerStyler ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogStyler :: class , Utilities \ LogStyler :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.styler' , Contracts \ Utilities \ LogStyler :: class ) ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
12004	public static function objectToArray ( $ mObject ) : array { if ( is_object ( $ mObject ) ) { $ mObject = ( array ) $ mObject ; } if ( is_array ( $ mObject ) ) { $ aNew = array ( ) ; foreach ( $ mObject as $ sKey => $ mValues ) { $ sKey = preg_replace ( "/^\\0(.*)\\0/" , "" , $ sKey ) ; $ aNew [ $ sKey ] = self :: objectToArray ( $ mValues ) ; } } else { $ aNew = $ mObject ; } return $ aNew ; }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
3036	protected function persistCacheEntry ( $ key ) { $ success = true ; if ( isset ( $ this -> cache [ $ key ] ) ) { $ cache = $ this -> cache [ $ key ] ; switch ( $ cache [ 'state' ] ) { case self :: STATE_PENDING_WRITE : $ success = $ this -> getStorage ( ) -> set ( $ cache [ 'userId' ] , $ cache [ 'callId' ] , $ cache [ 'data' ] ) ; if ( ! $ success ) { throw new \ common_exception_Error ( 'Can\'t write into test runner state storage at ' . static :: class ) ; } $ this -> cache [ $ key ] [ 'state' ] = self :: STATE_ALIGNED ; break ; case self :: STATE_PENDING_DELETE : $ success = $ this -> getStorage ( ) -> del ( $ cache [ 'userId' ] , $ cache [ 'callId' ] ) ; if ( $ success ) { unset ( $ this -> cache [ $ key ] ) ; } break ; } } return $ success ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
4740	protected static function _clear ( $ fileName , $ filePath ) { if ( ! in_array ( $ fileName , [ '.' , '..' , '.gitkeep' , '.htaccess' ] ) ) { if ( is_file ( $ filePath ) ) { @ unlink ( $ filePath ) ; } else { self :: clearTmp ( $ filePath ) ; } } }
11654	protected function _initMultiDbResources ( ) { $ registry = $ this -> getPluginResource ( 'multidb' ) ; if ( ! $ registry ) { return ; } $ options = $ registry -> getOptions ( ) ; foreach ( $ options as & $ connection ) { if ( 'db://' === substr ( $ connection [ 'dbname' ] , 0 , 5 ) ) { $ connection = array_replace ( $ connection , $ this -> _parseDsn ( $ connection [ 'dbname' ] ) ) ; } } Zend_Registry :: set ( 'multidb' , $ registry -> setOptions ( $ options ) ) ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
3981	private function getChildModelCaption ( $ metaModel , $ screen ) { $ caption = [ '' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) ] ; foreach ( $ screen [ 'label' ] as $ langCode => $ label ) { if ( ! empty ( $ label ) && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ screen [ 'description' ] [ $ langCode ] , $ label ] ; } } return $ caption ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
5925	public function addFilterItem ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FilterItem. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "FilterItem"!' , E_USER_WARNING ) ; } } $ this -> filterItems [ ] = $ item ; return $ this ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
8637	public function setOrderFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9813	protected function deleteRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> delete ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
10429	private function initSyncStorageForMysql ( ContainerBuilder $ container , array $ config ) { $ doctrineConnection = sprintf ( 'doctrine.dbal.%s_connection' , $ config [ 'connection' ] ) ; $ definition = $ container -> getDefinition ( 'ongr_connections.sync.storage_manager.mysql_storage_manager' ) ; $ definition -> setArguments ( [ new Reference ( $ doctrineConnection , ContainerInterface :: IGNORE_ON_INVALID_REFERENCE ) , $ config [ 'table_name' ] , ] ) ; $ definition -> addMethodCall ( 'setContainer' , [ new Reference ( 'service_container' ) ] ) ; $ container -> getDefinition ( 'ongr_connections.sync.sync_storage' ) -> setArguments ( [ $ definition ] ) ; }
11847	final public function save ( ) { $ this -> checkReadOnly ( ) ; $ this -> _save ( ) ; if ( count ( $ this -> _errors ) ) { throw new Zend_Db_Table_Row_Exception ( 'This row contain errors.' ) ; } foreach ( $ this -> _data as $ column => & $ value ) { if ( $ value instanceof DateTime ) { if ( ! ( $ value instanceof Benri_Util_DateTime ) ) { $ value = new Benri_Util_DateTime ( $ value -> format ( 'U' ) ) ; } $ value -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> isNewRecord ( ) ) { if ( $ this -> offsetExists ( 'created_at' ) ) { $ this -> created_at = new Benri_Util_DateTime ( ) ; $ this -> created_at -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> offsetExists ( 'updated_at' ) ) { $ this -> updated_at = new Benri_Util_DateTime ( ) ; $ this -> updated_at -> setFormat ( 'Y-m-d H:i:s' ) ; } parent :: save ( ) ; $ this -> _postSave ( ) ; return $ this ; }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
3060	public function getCurrentAssessmentItemRef ( ) { if ( $ this -> isAdaptive ( ) ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAssessmentItemRefByIdentifier ( $ this -> getCompilationDirectory ( ) [ 'private' ] , $ this -> getCurrentCatItemId ( ) ) ; } else { return $ this -> getTestSession ( ) -> getCurrentAssessmentItemRef ( ) ; } }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
5197	protected function version ( ) { $ version = explode ( '(' , $ this -> app -> version ( ) ) ; if ( isset ( $ version [ 1 ] ) ) { return substr ( $ version [ 1 ] , 0 , 3 ) ; } return null ; }
3226	function move ( $ fromPath , $ toPath ) { Path :: checkArgNonRoot ( "fromPath" , $ fromPath ) ; Path :: checkArgNonRoot ( "toPath" , $ toPath ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/move" , array ( "root" => "auto" , "from_path" => $ fromPath , "to_path" => $ toPath , ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
854	public function findSequence ( array $ sequence , $ start = 0 , $ end = null , $ caseSensitive = true ) { $ sequenceCount = \ count ( $ sequence ) ; if ( 0 === $ sequenceCount ) { throw new \ InvalidArgumentException ( 'Invalid sequence.' ) ; } $ end = null === $ end ? \ count ( $ this ) - 1 : min ( $ end , \ count ( $ this ) - 1 ) ; if ( $ start + $ sequenceCount - 1 > $ end ) { return null ; } foreach ( $ sequence as $ key => $ token ) { if ( ! $ token instanceof Token ) { if ( \ is_array ( $ token ) && ! isset ( $ token [ 1 ] ) ) { $ token [ 1 ] = 'DUMMY' ; } $ token = new Token ( $ token ) ; } if ( $ token -> isWhitespace ( ) || $ token -> isComment ( ) || '' === $ token -> getContent ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Non-meaningful token at position: %s.' , $ key ) ) ; } } if ( ! self :: isLegacyMode ( ) ) { foreach ( $ sequence as $ token ) { if ( ! $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ) { return null ; } } } $ key = key ( $ sequence ) ; $ firstCs = Token :: isKeyCaseSensitive ( $ caseSensitive , $ key ) ; $ firstToken = $ sequence [ $ key ] ; unset ( $ sequence [ $ key ] ) ; $ index = $ start - 1 ; while ( null !== $ index && $ index <= $ end ) { $ index = $ this -> getNextTokenOfKind ( $ index , [ $ firstToken ] , $ firstCs ) ; if ( null === $ index || $ index > $ end ) { return null ; } $ result = [ $ index => $ this [ $ index ] ] ; $ currIdx = $ index ; foreach ( $ sequence as $ key => $ token ) { $ currIdx = $ this -> getNextMeaningfulToken ( $ currIdx ) ; if ( null === $ currIdx || $ currIdx > $ end ) { return null ; } if ( ! $ this [ $ currIdx ] -> equals ( $ token , Token :: isKeyCaseSensitive ( $ caseSensitive , $ key ) ) ) { continue 2 ; } $ result [ $ currIdx ] = $ this [ $ currIdx ] ; } if ( \ count ( $ sequence ) < \ count ( $ result ) ) { return $ result ; } } }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
6183	public function add ( $ type , $ message , $ redirect = null ) { if ( ! isset ( $ type ) or ! isset ( $ message [ 0 ] ) ) { return false ; } if ( strlen ( trim ( $ type ) ) === 1 ) { $ type = str_replace ( [ 'h' , 'i' , 'w' , 'e' , 's' ] , [ 'help' , 'info' , 'warning' , 'error' , 'success' ] , $ type ) ; } $ router = new Router ( ) ; try { if ( ! in_array ( $ type , $ this -> msgTypes ) ) { throw new BaseException ( '"' . strip_tags ( $ type ) . '" is not a valid message type!' , 501 ) ; } } catch ( BaseException $ e ) { $ msg = null ; if ( ini_get ( 'display_errors' ) === "on" ) { $ msg .= '<pre>' ; $ msg .= 'Message: <b>' . $ e -> getMessage ( ) . '</b><br><br>' ; $ msg .= 'Accept: ' . $ _SERVER [ 'HTTP_ACCEPT' ] . '<br>' ; if ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ) { $ msg .= 'Referer: ' . $ _SERVER [ 'HTTP_REFERER' ] . '<br><br>' ; } $ msg .= 'Request Method: ' . $ _SERVER [ 'REQUEST_METHOD' ] . '<br><br>' ; $ msg .= 'Current file Path: <b>' . $ this -> router -> currentPath ( ) . '</b><br>' ; $ msg .= 'File Exception: ' . $ e -> getFile ( ) . ':' . $ e -> getLine ( ) . '<br><br>' ; $ msg .= 'Trace: <br>' . $ e -> getTraceAsString ( ) . '<br>' ; $ msg .= '</pre>' ; return Response :: create ( $ msg ) -> display ( ) ; } return Response :: create ( $ e -> getMessage ( ) ) -> status ( 501 ) -> display ( ) ; } $ get = $ this -> driver -> get ( 'flash_messages' ) ; $ get [ $ type ] [ ] = $ message ; $ this -> driver -> set ( 'flash_messages' , $ get ) ; if ( ! is_null ( $ redirect ) ) { return $ router -> redirect ( $ redirect , 301 ) ; } return true ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
10119	private function writeMarginRight ( ) { $ record = 0x0027 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getRight ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
2125	protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; }
9170	public function updateCompany ( \ Unite \ Contacts \ Http \ Requests \ UpdateRequest $ request ) { $ this -> service -> saveCompanyProfile ( $ request -> all ( ) ) ; return $ this -> successJsonResponse ( ) ; }
2186	public function fetch ( $ strTable , $ varKey , $ strAlias = null ) { $ strClass = Model :: getClassFromTable ( $ strTable ) ; $ strPk = $ strClass :: getPk ( ) ; if ( $ strAlias === null || $ strAlias == $ strPk ) { if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ) ) { return $ this -> arrRegistry [ $ strTable ] [ $ varKey ] ; } return null ; } return $ this -> fetchByAlias ( $ strTable , $ strAlias , $ varKey ) ; }
10698	public static function isPasswd ( $ passwd , $ size = Validate :: PASSWORD_LENGTH ) { return self :: getPasswordComplexity ( $ passwd , $ size ) >= self :: PASSWORD_COMPLEXITY_MEDIUM ; }
2425	public static function shouldBeSynchronized ( $ strPath ) { if ( ! isset ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) || ! \ is_bool ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) ) { static :: $ arrShouldBeSynchronized [ $ strPath ] = ! static :: isFileSyncExclude ( $ strPath ) ; } return static :: $ arrShouldBeSynchronized [ $ strPath ] ; }
6825	protected function getPaymentAccountNumber ( PaymentMethodInterface $ method , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_PAYMENT ) { continue ; } if ( $ account -> getPaymentMethod ( ) !== $ method ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No payment account number configured for payment method '%s' (%s)" , $ method -> getName ( ) , $ origin ) ) ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
8804	public function getFlash ( $ key = null ) { if ( ! is_null ( $ key ) ) { $ value = null ; if ( $ this -> hasFlash ( $ key ) ) { $ value = $ this -> get ( '_nur_flash' ) [ $ key ] ; unset ( $ _SESSION [ '_nur_flash' ] [ $ key ] ) ; } return $ value ; } return $ key ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
2249	public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; if ( ! preg_match ( '@^https?://@i' , $ strLocation ) ) { $ strLocation = Environment :: get ( 'base' ) . ltrim ( $ strLocation , '/' ) ; } if ( Environment :: get ( 'isAjaxRequest' ) ) { throw new AjaxRedirectResponseException ( $ strLocation ) ; } throw new RedirectResponseException ( $ strLocation , $ intStatus ) ; }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
2407	public static function generateScriptTag ( $ src , $ async = false , $ mtime = false , $ hash = null , $ crossorigin = null ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ src ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ src ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ src ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ src ) ; } } } if ( $ mtime ) { $ src .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<script src="' . $ src . '"' . ( $ async ? ' async' : '' ) . ( $ hash ? ' integrity="' . $ hash . '"' : '' ) . ( $ crossorigin ? ' crossorigin="' . $ crossorigin . '"' : '' ) . '></script>' ; }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
1736	public function getQrCode ( User $ user , Request $ request ) : string { $ renderer = new ImageRenderer ( new RendererStyle ( 180 , 0 ) , new SvgImageBackEnd ( ) ) ; $ writer = new Writer ( $ renderer ) ; return $ writer -> writeString ( $ this -> getProvisionUri ( $ user , $ request ) ) ; }
5573	public function setField ( $ label , $ value , $ position = false ) { return $ this -> page -> setField ( new SelectByLabelOrName ( $ label ) , $ value , $ position ) ; }
2115	private function getFieldValue ( ? PageModel $ page ) : string { if ( null === $ page ) { return '' ; } return ( string ) $ page -> { $ this -> field } ; }
1396	public function updated ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
301	public static function isPrimaryKey ( $ keys ) { $ pks = static :: primaryKey ( ) ; if ( count ( $ keys ) === count ( $ pks ) ) { return count ( array_intersect ( $ keys , $ pks ) ) === count ( $ pks ) ; } return false ; }
6980	protected function findOneAddressBy ( $ expression ) { if ( 0 < $ this -> addresses -> count ( ) ) { $ criteria = Criteria :: create ( ) -> where ( $ expression ) -> setMaxResults ( 1 ) ; $ matches = $ this -> addresses -> matching ( $ criteria ) ; if ( $ matches -> count ( ) == 1 ) { return $ matches -> first ( ) ; } } return null ; }
8088	public function generateUserPassword ( User $ user , $ password , $ generateOld = false ) { $ registrationDate = $ user -> RegDate ; $ pre = $ this -> encode ( $ registrationDate ) ; $ pos = substr ( $ registrationDate , 5 , 1 ) ; $ post = $ this -> encode ( $ registrationDate * ( substr ( $ registrationDate , $ pos , 1 ) ) ) ; $ finalString = $ pre . $ password . $ post ; return $ generateOld ? md5 ( $ finalString ) : sha1 ( $ finalString ) ; }
11649	protected function _authenticateCreateSelect ( ) { $ dbSelect = clone $ this -> getDbSelect ( ) ; $ dbSelect -> from ( $ this -> _tableName ) -> where ( "{$this->_identityColumn} = ?" , $ this -> _identity ) -> limit ( 1 ) ; return $ dbSelect ; }
11834	public function doStore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ config = $ this -> getConfig ( ) ; $ cache -> set ( 'config' , $ config ) ; }
4100	public function setType ( $ type ) { if ( is_array ( $ type ) ) $ type = implode ( "," , array_filter ( $ type ) ) ; $ this -> type = $ type ; $ this -> transport -> setType ( $ type ) ; return $ this ; }
9918	public function getTableName ( Model $ model , ModelConfig $ config = null ) { if ( empty ( $ this -> models ) ) { throw new \ LogicException ( 'AujaConfigurator not configured yet! Call configure first.' ) ; } if ( ! isset ( $ this -> configs [ $ model -> getName ( ) ] ) ) { throw new \ LogicException ( sprintf ( 'AujaConfigurator not configured for model %s' , $ model -> getName ( ) ) ) ; } $ result = null ; if ( $ config != null && $ config -> getTableName ( ) != null ) { $ result = $ config -> getTableName ( ) ; } else { $ modelConfig = $ this -> configs [ $ model -> getName ( ) ] ; $ result = $ modelConfig -> getTableName ( ) ; } return $ result ; }
4784	public function handle ( $ message , callable $ next ) { try { $ next ( $ message ) ; } catch ( UndefinedCallable $ exception ) { $ this -> logger -> log ( $ this -> logLevel , 'No message handler found, trying to handle it asynchronously' , [ 'type' => get_class ( $ message ) ] ) ; $ this -> publisher -> publish ( $ message ) ; } }
2826	public function getRequestViewUrl ( $ panel = null , $ token = null ) { $ token = $ token ? : $ this -> getRequestInfo ( ) -> getToken ( ) ; return $ token ? Mage :: helper ( 'sheep_debug/url' ) -> getRequestViewUrl ( $ token , $ panel ) : '#' ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
2033	public static function findWithDetails ( $ intId ) { $ objPage = static :: findByPk ( $ intId ) ; if ( $ objPage === null ) { return null ; } return $ objPage -> loadDetails ( ) ; }
10239	public static function unwrapResult ( $ value ) { if ( is_string ( $ value ) ) { if ( ( isset ( $ value [ 0 ] ) ) && ( $ value [ 0 ] == '"' ) && ( substr ( $ value , - 1 ) == '"' ) ) { return substr ( $ value , 1 , - 1 ) ; } } elseif ( ( is_float ( $ value ) ) && ( ( is_nan ( $ value ) ) || ( is_infinite ( $ value ) ) ) ) { return Functions :: NAN ( ) ; } return $ value ; }
4232	private static function getCommentContent ( $ what ) { $ reflector = null ; if ( \ is_object ( $ what ) ) { $ reflector = $ what instanceof \ Reflector ? $ what : new \ ReflectionObject ( $ what ) ; $ docComment = $ reflector -> getDocComment ( ) ; } else { $ docComment = $ what ; } $ docComment = \ preg_replace ( '#^/\*\*(.+)\*/$#s' , '$1' , $ docComment ) ; $ docComment = \ preg_replace ( '#^[ \t]*\*[ ]?#m' , '' , $ docComment ) ; $ docComment = \ trim ( $ docComment ) ; if ( $ reflector ) { if ( \ strtolower ( $ docComment ) == '{@inheritdoc}' ) { return self :: findInheritedDoc ( $ reflector ) ; } else { $ docComment = \ preg_replace_callback ( '/{@inheritdoc}/i' , function ( ) use ( $ reflector ) { $ phpDoc = self :: findInheritedDoc ( $ reflector ) ; return $ phpDoc [ 'description' ] ; } , $ docComment ) ; } } return $ docComment ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
10394	protected function transform ( DocumentInterface $ document , $ entity , $ skip = null ) { $ entityMethods = get_class_methods ( $ entity ) ; $ documentMethods = get_class_methods ( $ document ) ; if ( $ skip === null ) { $ skip = $ this -> getCopySkipFields ( ) ; } foreach ( $ entityMethods as $ method ) { if ( strpos ( $ method , 'get' ) !== 0 ) { continue ; } $ property = substr ( $ method , 3 ) ; if ( in_array ( lcfirst ( $ property ) , $ skip ) ) { continue ; } $ setter = 'set' . $ property ; if ( in_array ( $ setter , $ documentMethods ) ) { $ document -> { $ setter } ( $ entity -> { $ method } ( ) ) ; } } }
11234	protected function checkValue ( $ value , $ subject , $ reference ) { if ( is_null ( $ value ) ) { return $ subject ; } elseif ( $ subject != $ reference ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_MALFORMED , $ reference ) , Message :: MSG_REF_MALFORMED ) ; } else { return $ value ; } }
9665	public function setHeader ( $ header , $ value ) { if ( strlen ( $ header ) < 1 ) { throw new Exception ( 'Header must be a string.' ) ; } $ this -> customHeaders [ $ header ] = $ value ; return $ this ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
6733	public function run ( Request $ request ) { $ this -> stopwatch = microtime ( true ) ; $ starttime = $ request -> server -> get ( 'REQUEST_TIME_FLOAT' ) ; $ this -> log ( "Router: ->run() called. Starting clock at REQUEST_TIME+%.2fms" , microtime ( true ) - $ starttime ) ; try { $ response = $ this -> process ( $ request ) ; } catch ( \ Throwable $ e ) { $ this -> log ( "Router: Exception" ) ; $ response = $ this -> handleException ( $ e , $ request ) ; } $ this -> log ( "Router: Preparing to send response" ) ; $ response -> prepare ( $ request ) ; $ response -> send ( ) ; $ this -> log ( "Router: Response sent" ) ; }
8051	public function getAllEvents ( ) : array { $ calendarEvents = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_KEY ) ; } $ allEvents = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> get ( ) ; $ calendarEvents = $ allEvents -> keyBy ( 'id' ) -> toArray ( ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ calendarEvents , $ this -> cacheTimeToLive ) ; return $ calendarEvents ; }
1900	private function createImportantPart ( ImageInterface $ image ) : ? ImportantPart { $ filesModel = $ this -> framework -> getAdapter ( FilesModel :: class ) ; $ file = $ filesModel -> findByPath ( $ image -> getPath ( ) ) ; if ( null === $ file || ! $ file -> importantPartWidth || ! $ file -> importantPartHeight ) { return null ; } $ imageSize = $ image -> getDimensions ( ) -> getSize ( ) ; if ( $ file -> importantPartX + $ file -> importantPartWidth > $ imageSize -> getWidth ( ) || $ file -> importantPartY + $ file -> importantPartHeight > $ imageSize -> getHeight ( ) ) { return null ; } return new ImportantPart ( new Point ( ( int ) $ file -> importantPartX , ( int ) $ file -> importantPartY ) , new Box ( ( int ) $ file -> importantPartWidth , ( int ) $ file -> importantPartHeight ) ) ; }
3884	private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } if ( $ factory -> isNestedType ( ) ) { $ this -> collectRulesFor ( $ setting , $ filterSettings ) ; } return $ setting ; } return null ; }
1133	public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; }
6735	public function getMiddleware ( $ name ) : Middleware { if ( ! array_key_exists ( $ name , $ this -> namedMiddleware ) ) { throw new \ UnexpectedValueException ( "No middleware registered under name '{$name}'" ) ; } return $ this -> namedMiddleware [ $ name ] ; }
8731	public function whitelist ( string $ address ) : WhitelistResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'whitelist' , [ 'timeout' => 60 , 'json' => [ 'address' => $ address ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( RuntimeException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw AddressWhitelistingFailed :: forAddress ( $ address , $ e -> getMessage ( ) ) ; } return new WhitelistResponse ( $ data [ 'hydro_address_id' ] , $ data [ 'transaction_hash' ] ) ; }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
5559	protected function findFormInFrame ( $ page , $ index , $ method , $ attribute ) { $ form = $ this -> frames [ $ index ] -> $ method ( $ attribute ) ; if ( isset ( $ form ) ) { $ form -> setDefaultTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ form ; }
9934	public function setValue ( $ pValue ) { if ( is_array ( $ pValue ) ) { $ grouping = - 1 ; foreach ( $ pValue as $ key => $ value ) { if ( ! in_array ( $ key , self :: $ dateTimeGroups ) ) { unset ( $ pValue [ $ key ] ) ; } else { $ grouping = max ( $ grouping , array_search ( $ key , self :: $ dateTimeGroups ) ) ; } } if ( count ( $ pValue ) == 0 ) { throw new PhpSpreadsheetException ( 'Invalid rule value for column AutoFilter Rule.' ) ; } $ this -> setGrouping ( self :: $ dateTimeGroups [ $ grouping ] ) ; } $ this -> value = $ pValue ; return $ this ; }
12278	public function moveUser ( $ openId , $ groupId ) { $ params = [ 'openid' => $ openId , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_UPDATE , $ params ] ) ; }
7185	public static function build ( StockUnitInterface $ unit , SaleInterface $ sale ) { $ releasable = 0 ; $ map = [ ] ; foreach ( $ unit -> getStockAssignments ( ) as $ a ) { if ( $ sale === $ s = $ a -> getSaleItem ( ) -> getSale ( ) ) { continue ; } if ( $ s -> getShipmentState ( ) === ShipmentStates :: STATE_PREPARATION ) { continue ; } if ( 0 < $ d = $ a -> getSoldQuantity ( ) - $ a -> getShippedQuantity ( ) ) { $ releasable += $ d ; $ map [ $ a -> getId ( ) ] = $ d ; } } arsort ( $ map , \ SORT_NUMERIC ) ; $ candidate = new static ; $ candidate -> unit = $ unit ; $ candidate -> shippable = $ unit -> getShippableQuantity ( ) ; $ candidate -> reservable = $ unit -> getReservableQuantity ( ) ; $ candidate -> releasable = $ releasable ; $ candidate -> map = $ map ; return $ candidate ; }
177	public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
1950	public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; }
12975	public function registerMapping ( Configuration $ config ) { $ driverChain = new DriverChain ; $ aliasMap = array ( ) ; $ drivers = array ( ) ; $ this -> parseMappingInfo ( ) ; foreach ( $ this -> getMappings ( ) as $ mappingName => $ mappingConfig ) { if ( empty ( $ mappingConfig [ 'prefix' ] ) ) { $ mappingConfig [ 'prefix' ] = '__DEFAULT__' ; } $ drivers [ $ mappingConfig [ 'type' ] ] [ $ mappingConfig [ 'prefix' ] ] = $ mappingConfig [ 'dir' ] ; if ( isset ( $ mappingConfig [ 'alias' ] ) ) { $ aliasMap [ $ mappingConfig [ 'alias' ] ] = $ mappingConfig [ 'prefix' ] ; } } foreach ( $ drivers as $ driverType => $ driverPaths ) { if ( $ driverType === 'annotation' ) { $ driver = $ config -> newDefaultAnnotationDriver ( $ driverPaths , false ) ; } else { $ paths = $ driverPaths ; if ( strpos ( $ driverType , 'simplified' ) === 0 ) { $ paths = array_flip ( $ driverPaths ) ; } $ driver = DiC :: resolve ( $ driverType , [ $ paths ] ) ; } foreach ( $ driverPaths as $ prefix => $ driverPath ) { if ( $ prefix === '__DEFAULT__' or count ( $ this -> config [ 'mappings' ] ) === 1 ) { $ driverChain -> setDefaultDriver ( $ driver ) ; } else { $ driverChain -> addDriver ( $ driver , $ prefix ) ; } } } $ config -> setMetadataDriverImpl ( $ driverChain ) ; $ config -> setEntityNamespaces ( $ aliasMap ) ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
10026	function getContacts ( $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts' , $ queryParameters ) ; }
6360	public function filter ( callable $ predicate ) : BufferedIterable { return new BufferedIterable ( $ this -> chunkProvider , $ predicate , $ this -> limit , $ this -> providerCallLimit ) ; }
3252	public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; $ order = call_user_func ( Config :: get ( 'shop.order' ) . '::create' , [ 'user_id' => $ this -> user_id , 'statusCode' => $ statusCode ] ) ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; -- $ i ) { $ this -> items [ $ i ] -> order_id = $ order -> id ; $ this -> items [ $ i ] -> cart_id = null ; $ this -> items [ $ i ] -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ order ; }
4107	public function showHints ( ) { if ( is_null ( $ this -> showHints ) ) { $ this -> showHints = false ; if ( Mage :: helper ( 'core' ) -> isDevAllowed ( ) ) { if ( Mage :: getSingleton ( 'core/cookie' ) -> get ( 'ath' ) || Mage :: app ( ) -> getRequest ( ) -> get ( 'ath' ) ) { $ this -> showHints = true ; } } } return $ this -> showHints ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
4061	public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; }
5014	public function logBootstrap ( BootstrapEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Start' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInObject ( $ event -> getWorker ( ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
10534	public function allows ( $ action , $ user , $ request ) { if ( $ this -> matchAction ( $ action ) && $ this -> matchRole ( $ user ) && $ this -> matchIP ( $ request -> getUserIP ( ) ) && $ this -> matchVerb ( $ request -> getMethod ( ) ) && $ this -> matchController ( $ action -> controller ) && $ this -> matchCustom ( $ action ) ) { return $ this -> allow ? true : false ; } else { return null ; } }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
130	protected function requestXml ( $ origin , $ path ) { $ xml = simplexml_load_string ( $ this -> requestContent ( $ origin , $ path ) , "SimpleXMLElement" , LIBXML_NOERROR ) ; if ( false === $ xml ) { throw new \ UnexpectedValueException ( sprintf ( 'The PEAR channel at ' . $ origin . ' is broken. (Invalid XML at file `%s`)' , $ path ) ) ; } return $ xml ; }
3197	public function getRemainingExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { return max ( 0 , $ this -> getExtraTime ( $ maxTime ) - $ this -> getConsumedExtraTime ( $ tags , $ maxTime , $ target ) ) ; }
4974	private function hydrateTree ( NodeInterface $ object , \ ArrayObject $ currentData = null ) { if ( null === $ currentData ) { $ currentData = $ this -> hydrateData [ '__root__' ] ; } if ( 'set' == $ currentData [ 'do' ] ) { $ object -> setName ( $ currentData [ 'name' ] ) -> setValue ( $ currentData [ 'value' ] ) -> setPriority ( $ currentData [ 'priority' ] ) ; } if ( isset ( $ this -> hydrateData [ $ currentData [ 'current' ] ] ) ) { foreach ( $ this -> hydrateData [ $ currentData [ 'current' ] ] as $ childData ) { $ child = $ this -> findOrCreateChild ( $ object , $ childData [ 'id' ] ) ; if ( 'remove' == $ childData [ 'do' ] ) { $ object -> removeChild ( $ child ) ; } else { $ this -> hydrateTree ( $ child , $ childData ) ; } } } return $ object ; }
2985	protected function generateIndexView ( $ dir ) { $ this -> renderFile ( 'crud/views/index.html.twig.twig' , $ dir . '/index.html.twig' , array ( 'bundle' => $ this -> bundle -> getName ( ) , 'entity' => $ this -> entity , 'entity_pluralized' => $ this -> entityPluralized , 'entity_singularized' => $ this -> entitySingularized , 'identifier' => $ this -> metadata -> identifier [ 0 ] , 'fields' => $ this -> metadata -> fieldMappings , 'actions' => $ this -> actions , 'record_actions' => $ this -> getRecordActions ( ) , 'route_prefix' => $ this -> routePrefix , 'route_name_prefix' => $ this -> routeNamePrefix , ) ) ; }
1257	public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
6800	public function installCurrencies ( $ code = 'USD' ) { $ currencyNames = Intl :: getCurrencyBundle ( ) -> getCurrencyNames ( ) ; if ( ! isset ( $ currencyNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default currency code '$code'." ) ; } asort ( $ currencyNames ) ; $ this -> generate ( Currency :: class , $ currencyNames , $ code ) ; }
3282	public function setExt ( string $ ext ) { if ( substr ( $ ext , 0 , 1 ) !== '.' ) { $ ext = '.' . $ ext ; } $ this -> config [ 'ext' ] = $ ext ; }
10034	function unsubscribeContactById ( $ id , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( 'id' => $ id ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> delete ( "contacts/contact/unsubscribe" , $ queryParameters ) ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
6072	public function updateMedia ( $ id , Media $ media ) { if ( $ media instanceof MediaResponse ) { $ media = new Media ( json_decode ( json_encode ( $ media ) , true ) ) ; } $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'media' => $ media ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
5292	public function buildGravatarURL ( $ email , $ hash_email = true ) { if ( $ this -> usingSecureImages ( ) ) { $ url = static :: HTTPS_URL ; } else { $ url = static :: HTTP_URL ; } if ( $ hash_email == true && ! empty ( $ email ) ) { $ url .= $ this -> getEmailHash ( $ email ) ; } elseif ( ! empty ( $ email ) ) { $ url .= $ email ; } else { $ url .= str_repeat ( '0' , 32 ) ; } if ( $ this -> param_cache === NULL ) { $ params = array ( ) ; $ params [ ] = 's=' . $ this -> getAvatarSize ( ) ; $ params [ ] = 'r=' . $ this -> getMaxRating ( ) ; if ( $ this -> getDefaultImage ( ) ) { $ params [ ] = 'd=' . $ this -> getDefaultImage ( ) ; } $ this -> params_cache = ( ! empty ( $ params ) ) ? '?' . implode ( '&' , $ params ) : '' ; } $ tail = '' ; if ( empty ( $ email ) ) { $ tail = ! empty ( $ this -> params_cache ) ? '&f=y' : '?f=y' ; } return $ url . $ this -> params_cache . $ tail ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
11194	protected function fixTree ( array $ data ) { $ result = [ ] ; foreach ( $ data as $ k => $ v ) { $ res = & $ this -> searchNode ( $ k , $ result ) ; if ( is_array ( $ v ) && is_array ( $ res ) ) { $ res = array_replace_recursive ( $ res , $ this -> fixTree ( $ v ) ) ; } else { $ res = $ v ; } } return $ result ; }
46	public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
2214	public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; }
462	public function buildCondition ( $ condition , & $ params ) { if ( is_array ( $ condition ) ) { if ( empty ( $ condition ) ) { return '' ; } $ condition = $ this -> createConditionFromArray ( $ condition ) ; } if ( $ condition instanceof ExpressionInterface ) { return $ this -> buildExpression ( $ condition , $ params ) ; } return ( string ) $ condition ; }
10383	protected static function compress_files ( $ content ) { $ var = array ( "\r\n" , "\r" , "\n" , "\t" , ' ' , ' ' , ' ' ) ; $ content = preg_replace ( '!/\*[^*]*\*+([^/][^*]*\*+)*/!' , '' , $ content ) ; $ content = str_replace ( $ var , '' , $ content ) ; $ content = str_replace ( '{ ' , '{' , $ content ) ; $ content = str_replace ( ' }' , '}' , $ content ) ; $ content = str_replace ( '; ' , ';' , $ content ) ; return $ content ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
4664	public function setDynamicContent ( array $ params , string $ content ) { $ processed_content = preg_replace_callback ( '~\{(.*?)\}~si' , function ( $ match ) use ( $ params ) { return str_replace ( $ match [ 0 ] , isset ( $ params [ $ match [ 1 ] ] ) ? $ params [ $ match [ 1 ] ] : $ match [ 0 ] , $ match [ 0 ] ) ; } , $ content ) ; return $ processed_content ; }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
926	public function getLintErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_LINT === $ error -> getType ( ) ; } ) ; }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
9831	public function resource ( $ modelName , $ controller ) { if ( php_sapi_name ( ) == 'cli' ) { return ; } if ( ! class_exists ( $ controller ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not exist.' ) ; } if ( ! is_subclass_of ( $ controller , 'Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ) { throw new ExpectedAujaControllerException ( $ controller . ' does not implement Label305\AujaLaravel\Controllers\Interfaces\AujaControllerInterface' ) ; } $ this -> registerIndex ( $ modelName , $ controller ) ; $ this -> registerMenu ( $ modelName , $ controller ) ; $ this -> registerShowMenu ( $ modelName , $ controller ) ; $ this -> registerCreate ( $ modelName , $ controller ) ; $ this -> registerStore ( $ modelName , $ controller ) ; $ this -> registerShow ( $ modelName , $ controller ) ; $ this -> registerEdit ( $ modelName , $ controller ) ; $ this -> registerUpdate ( $ modelName , $ controller ) ; $ this -> registerDelete ( $ modelName , $ controller ) ; $ model = $ this -> auja -> getModel ( ucfirst ( str_singular ( camel_case ( $ modelName ) ) ) ) ; $ relations = $ this -> auja -> getRelationsForModel ( $ model ) ; foreach ( $ relations as $ relation ) { $ otherModelName = $ relation -> getRight ( ) -> getName ( ) ; if ( $ relation -> getType ( ) == Relation :: BELONGS_TO ) { $ this -> registerBelongsToAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; } else { $ this -> registerAssociation ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerAssociationMenu ( $ modelName , $ otherModelName , $ controller ) ; $ this -> registerCreateAssociation ( $ modelName , $ otherModelName , $ controller ) ; } } }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
12119	private function getCustomersMap ( ) { $ customers = $ this -> daoCustDwnl -> get ( ) ; $ result = $ this -> hlpTree -> mapById ( $ customers , ECustomer :: A_CUSTOMER_REF ) ; return $ result ; }
8057	public function setParentProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Children\'s Process Title Format for a created pool.' ) ; } $ this -> parentProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
6025	public function addMetaData ( $ item ) { if ( ! ( $ item instanceof MetaData ) ) { if ( is_array ( $ item ) ) { try { $ item = new MetaData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MetaData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "MetaData"!' , E_USER_WARNING ) ; } } $ this -> metadata [ ] = $ item ; return $ this ; }
4154	protected function getBearerTokenCredentials ( ) { $ signingKey = rawurlencode ( $ this -> getConsumerKey ( ) ) . ':' . rawurlencode ( $ this -> getConsumerSecret ( ) ) ; return base64_encode ( $ signingKey ) ; }
9675	public function allFills ( Spreadsheet $ spreadsheet ) { $ aFills = [ ] ; $ fill0 = new Fill ( ) ; $ fill0 -> setFillType ( Fill :: FILL_NONE ) ; $ aFills [ ] = $ fill0 ; $ fill1 = new Fill ( ) ; $ fill1 -> setFillType ( Fill :: FILL_PATTERN_GRAY125 ) ; $ aFills [ ] = $ fill1 ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] ) ) { $ aFills [ $ style -> getFill ( ) -> getHashCode ( ) ] = $ style -> getFill ( ) ; } } return $ aFills ; }
9787	public function parseFilteredValue ( ) { list ( $ type , $ filters ) = $ this -> pop ( 'FILTERED_VALUE' ) ; $ value = array_shift ( $ filters ) ; $ opening = '' ; $ closing = '' ; foreach ( $ filters as $ filter ) { if ( function_exists ( $ filter ) ) { $ opening .= $ filter . '(' ; $ closing .= ')' ; } else { $ opening .= '\Katar\Katar::getInstance()->filter(\'' . $ filter . '\', ' ; $ closing .= ')' ; } } return '$output .= ' . $ opening . $ value . $ closing . ";\n" ; }
12691	protected function outputError ( $ errorNumber , $ test , $ exception ) { $ feature = null ; $ scenario = null ; $ testDescription = null ; $ node = $ test ; while ( $ node !== null ) { $ class = get_class ( $ node ) ; $ description = str_replace ( "\n " , "\n " , $ node -> getDescription ( ) ) ; if ( $ description === '' ) { $ node = $ node -> getParent ( ) ; continue ; } if ( $ class === 'Peridot\Core\Test' ) { $ testDescription = $ description ; } elseif ( $ class === 'Peridot\Core\Suite' ) { if ( strpos ( $ description , 'Feature:' ) === 0 ) { $ feature = $ description ; } else { $ scenario = trim ( $ description ) ; } } $ node = $ node -> getParent ( ) ; } if ( $ this -> lastFeature !== $ feature ) { $ this -> output -> writeln ( " " . $ feature . "\n" ) ; $ this -> lastFeature = $ feature ; $ this -> lastScenario = null ; } if ( $ this -> lastScenario !== $ scenario ) { $ this -> output -> writeln ( " " . $ scenario . "\n" ) ; $ this -> lastScenario = $ scenario ; } $ this -> output -> writeln ( $ this -> color ( 'error' , sprintf ( " %d) %s" , $ errorNumber , $ testDescription ) ) ) ; $ message = sprintf ( " %s" , str_replace ( "\n" , "\n " , $ exception -> getMessage ( ) ) ) ; $ this -> output -> writeln ( $ this -> color ( 'pending' , $ message ) ) ; $ class = method_exists ( $ exception , 'getClass' ) ? $ exception -> getClass ( ) : get_class ( $ exception ) ; $ trace = method_exists ( $ exception , 'getTrueTrace' ) ? $ exception -> getTrueTrace ( ) : $ exception -> getTrace ( ) ; array_unshift ( $ trace , [ 'function' => $ class . ' thrown' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) ] ) ; $ this -> outputTrace ( $ trace ) ; }
26	protected function getRemoteContents ( $ originUrl , $ fileUrl , $ context , array & $ responseHeaders = null ) { try { $ e = null ; $ result = file_get_contents ( $ fileUrl , false , $ context ) ; } catch ( \ Throwable $ e ) { } catch ( \ Exception $ e ) { } $ responseHeaders = isset ( $ http_response_header ) ? $ http_response_header : array ( ) ; if ( null !== $ e ) { throw $ e ; } return $ result ; }
4961	public function setForm ( $ form ) { if ( ! $ form instanceof FormInterface && ! $ form instanceof Container ) { throw new \ InvalidArgumentException ( 'Form must either implement \Zend\Form\FormInterface or extend from \Core\Form\Container' ) ; } $ this -> form = $ form ; return $ this ; }
10325	protected function setOptions ( array $ options ) { if ( ! array_key_exists ( 'adapter' , $ options ) || ! array_key_exists ( 'table' , $ options ) || ! array_key_exists ( 'column_key' , $ options ) || ! array_key_exists ( 'column_value' , $ options ) ) { throw new Exception \ InvalidArgumentException ( 'Db adapter options must be defined "adapter", "table", "column_key" and "column_value" keys.' ) ; } if ( ! $ options [ 'adapter' ] instanceof Adapter ) { throw new Exception \ InvalidArgumentException ( 'Db adapter must be an instance of Zend\Db\Adapter\Adapter.' ) ; } $ this -> adapter = $ options [ 'adapter' ] ; $ options [ 'table' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'table' ] ) ; $ options [ 'column_key' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_key' ] ) ; $ options [ 'column_value' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_value' ] ) ; $ this -> options = $ options ; return $ this ; }
2574	protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } }
1956	public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; }
6356	public static function convert ( $ style = TS_UNIX , $ ts ) { try { $ ct = new static ( $ ts ) ; return $ ct -> getTimestamp ( $ style ) ; } catch ( TimestampException $ e ) { return false ; } }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
4047	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'jumpTo' ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ model -> getProperty ( 'pid' ) ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; if ( $ metaModel -> isTranslated ( ) ) { $ arrLanguages = [ ] ; foreach ( ( array ) $ metaModel -> getAvailableLanguages ( ) as $ strLangCode ) { $ arrLanguages [ $ strLangCode ] = $ this -> translator -> trans ( 'LNG.' . $ strLangCode , [ ] , 'contao_languages' ) ; } asort ( $ arrLanguages ) ; $ extra [ 'minCount' ] = count ( $ arrLanguages ) ; $ extra [ 'maxCount' ] = count ( $ arrLanguages ) ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = $ arrLanguages ; } else { $ extra [ 'minCount' ] = 1 ; $ extra [ 'maxCount' ] = 1 ; $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] = [ 'xx' => $ this -> translator -> trans ( 'tl_metamodel_rendersettings.jumpTo_allLanguages' , [ ] , 'contao_tl_metamodel_rendersettings' ) ] ; } $ extra [ 'columnFields' ] [ 'filter' ] [ 'options' ] = $ this -> getFilterSettings ( $ model ) ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; }
7667	function InlineImageExists ( ) { $ result = false ; for ( $ i = 0 ; $ i < count ( $ this -> attachment ) ; $ i ++ ) { if ( $ this -> attachment [ $ i ] [ 6 ] == "inline" ) { $ result = true ; break ; } } return $ result ; }
6441	public static function getSocialLoginObject ( $ network , $ options = array ( ) , $ logger = null ) { $ network = preg_replace ( '![^a-z0-9]!i' , '' , $ network ) ; if ( $ network == '' ) { throw new \ Exception ( 'Social Login Network can not be empty' ) ; } $ class = '\\Gelembjuk\\Auth\\SocialLogin\\' . ucfirst ( $ network ) ; if ( ! class_exists ( $ class ) ) { throw new \ Exception ( sprintf ( 'Integration with a class name %s not found' , $ class ) ) ; } $ object = new $ class ( $ options ) ; $ object -> setLogger ( $ logger ) ; return $ object ; }
1605	public function findAllRedirects ( $ currentSiteOnly = false ) { if ( $ currentSiteOnly ) return RedirectRecord :: find ( ) -> where ( '[[siteId]] IS NULL OR [[siteId]] = ' . \ Craft :: $ app -> sites -> currentSite -> id ) -> orderBy ( 'siteId asc' ) -> all ( ) ; return array_reduce ( RedirectRecord :: find ( ) -> all ( ) , function ( $ a , RedirectRecord $ record ) { $ a [ $ record -> siteId ?? 'null' ] [ ] = $ record ; return $ a ; } , array_reduce ( \ Craft :: $ app -> sites -> allSiteIds , function ( $ a , $ id ) { $ a [ $ id ] = [ ] ; return $ a ; } , [ ] ) ) ; }
7339	public function sendMessage ( Chat $ chat , User $ recipient , string $ text , Template $ template = null ) : void { $ sendMessage = new SendMessage ( ) ; if ( $ template !== null ) { $ sendMessage -> reply_markup = $ this -> templateCompiler -> compile ( $ template ) ; } $ sendMessage -> chat_id = $ chat -> getId ( ) ; $ sendMessage -> text = $ text ; $ this -> client -> performApiRequest ( $ sendMessage ) ; $ this -> loop -> run ( ) ; }
4941	public function getAllowedTypes ( $ asArray = false ) { $ types = $ this -> getAttribute ( 'data-allowedtypes' ) ; if ( $ asArray ) { return explode ( ',' , $ types ) ; } return $ types ; }
7932	public function load ( $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load' , [ $ data ] ) ; if ( is_array ( $ data ) ) { $ this -> loadFromArray ( $ data ) ; } else { $ this -> loadFromCollection ( $ data ) ; } return $ this ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
8525	public function setSellerSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SellerSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6745	private function applyResponseEncoding ( Request $ request , Response $ response ) { $ allowedCompressionAsString = $ request -> headers -> get ( 'Accept-Encoding' ) ; if ( ! $ allowedCompressionAsString ) { return ; } $ allowedCompression = explode ( ',' , $ allowedCompressionAsString ) ; $ allowedCompression = array_map ( 'trim' , $ allowedCompression ) ; if ( in_array ( 'gzip' , $ allowedCompression ) ) { $ response -> setContent ( gzencode ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'gzip' ) ; return ; } if ( in_array ( 'deflate' , $ allowedCompression ) ) { $ response -> setContent ( gzdeflate ( $ response -> getContent ( ) ) ) ; $ response -> headers -> set ( 'Content-Encoding' , 'deflate' ) ; return ; } }
2216	public function last ( ) { $ this -> intIndex = $ this -> count ( ) - 1 ; $ this -> blnDone = true ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
8517	public function setInventoryRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InventoryRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
426	public static function getInstance ( ) { $ class = get_called_class ( ) ; return isset ( Yii :: $ app -> loadedModules [ $ class ] ) ? Yii :: $ app -> loadedModules [ $ class ] : null ; }
9358	public function getModulePath ( $ moduleName ) { if ( array_key_exists ( $ moduleName , $ this -> loadedModules ) ) { $ module = $ this -> loadedModules [ $ moduleName ] ; $ moduleConfig = $ module -> getAutoloaderConfig ( ) ; return $ moduleConfig [ self :: STANDARD_AUTOLOLOADER ] [ self :: NAMESPACE_KEY ] [ $ moduleName ] ; } return null ; }
2767	public function pushTag ( string $ tag , string $ repository = 'origin' , array $ options = [ ] ) : string { return $ this -> push ( $ repository , 'tag' , $ tag , $ options ) ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
10976	public function sendVerification ( ) { $ this -> setVerificationCode ( $ this -> createVerificationCode ( ) ) ; $ user = & $ this ; return Mail :: queue ( Config :: get ( 'verifier.template' ) , [ 'user' => $ this ] , function ( $ message ) use ( $ user ) { $ message -> to ( $ user -> email , $ user -> getVerificationEmailName ( ) ) -> subject ( $ user -> getVerificationEmailSubject ( ) ) ; } ) ; }
8068	public function connect ( ) { $ port = $ this -> ssl ? $ this :: PORT_SSL : $ this :: PORT ; $ hostname = $ this -> domainController -> getHostname ( ) ; return $ this -> connection = ldap_connect ( $ hostname , $ port ) ; }
4116	public function getBlockPath ( Mage_Core_Block_Abstract $ block ) { $ blockPath = array ( ) ; $ step = $ block -> getParentBlock ( ) ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { $ blockPath [ ] = $ this -> getBlockInfo ( $ step , false ) ; $ step = $ step -> getParentBlock ( ) ; } return $ blockPath ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
4766	protected function validateInvoiceAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_invoiceaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeInvAddress' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinInvoiceAddress' ) && ( 1 == $ changeExistigAddress ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
1654	public function getReverse ( ) : Polygon { $ reversed = new static ( ) ; foreach ( array_reverse ( $ this -> points ) as $ point ) { $ reversed -> addPoint ( $ point ) ; } return $ reversed ; }
5275	public function having ( $ column , $ param1 = null , $ param2 = null ) { $ this -> statements [ 'having' ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , 'having' ) ; return $ this ; }
4984	public function setParams ( array $ params ) { $ this -> params = array_merge ( $ this -> params , $ params ) ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParams' ) ) { $ form [ '__instance__' ] -> setParams ( $ params ) ; } } return $ this ; }
2947	public function grant ( $ permission ) { if ( $ this -> hasPermission ( $ permission ) ) { return true ; } if ( ! array_key_exists ( $ permission , Gate :: abilities ( ) ) ) { abort ( 403 , 'Unknown permission' ) ; } return Permission :: create ( [ 'role_id' => $ this -> id , 'permission_slug' => $ permission , ] ) ; return false ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
9378	protected function files ( $ path ) { $ directory = new \ RecursiveDirectoryIterator ( $ path ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directory ) ; $ regex = new \ RegexIterator ( $ iterator , '/^.+\.php$/i' , 1 ) ; return ( array ) array_keys ( iterator_to_array ( $ regex ) ) ; }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
10856	public function has ( string $ typeName ) : bool { if ( isset ( $ this -> shared [ $ typeName ] ) || isset ( $ this -> definitions [ $ typeName ] ) ) { return true ; } if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } return $ this -> typeCache [ $ typeName ] !== false && $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ; }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
5745	private function getDebugBacktraceString ( ) : string { $ out = "" ; $ dbt = debug_backtrace ( ~ DEBUG_BACKTRACE_PROVIDE_OBJECT & ~ DEBUG_BACKTRACE_IGNORE_ARGS ) ; array_shift ( $ dbt ) ; array_shift ( $ dbt ) ; $ showVendorCalls = true ; $ showFullFilePath = true ; $ startFilePath = '/Src' ; $ showClassNamespace = false ; foreach ( $ dbt as $ index => $ call ) { $ outLine = "#$index:" ; if ( isset ( $ call [ 'file' ] ) ) { if ( ! $ showVendorCalls && strstr ( $ call [ 'file' ] , '/vendor/' ) ) { break ; } $ outLine .= " " ; if ( $ showFullFilePath ) { $ outLine .= $ call [ 'file' ] ; } else { $ fileParts = explode ( $ startFilePath , $ call [ 'file' ] ) ; $ outLine .= ( isset ( $ fileParts [ 1 ] ) ) ? $ fileParts [ 1 ] : $ call [ 'file' ] ; } } if ( isset ( $ call [ 'line' ] ) ) { $ outLine .= " [" . $ call [ 'line' ] . "] " ; } if ( isset ( $ call [ 'class' ] ) ) { $ classParts = explode ( "\\" , $ call [ 'class' ] ) ; $ outLine .= " " ; $ outLine .= ( $ showClassNamespace ) ? $ call [ 'class' ] : $ classParts [ count ( $ classParts ) - 1 ] ; } if ( isset ( $ call [ 'type' ] ) ) { $ outLine .= $ call [ 'type' ] ; } if ( isset ( $ call [ 'function' ] ) ) { $ outLine .= $ call [ 'function' ] . "()" ; } if ( isset ( $ call [ 'args' ] ) ) { $ outLine .= " {" . Functions :: arrayWalkToStringRecursive ( $ call [ 'args' ] , 0 , 1000 , PHP_EOL ) . "}" ; } $ out .= "$outLine" . PHP_EOL ; } return $ out ; }
3996	protected function jumpTo ( $ mixMetaModel , $ mixDataId , $ intIdRenderSetting , $ strParam = 'url' ) { if ( empty ( $ strParam ) ) { $ strParam = 'url' ; } $ objMetaModel = $ this -> loadMetaModel ( $ mixMetaModel ) ; if ( $ objMetaModel == null ) { return false ; } $ objRenderSettings = $ this -> getServiceContainer ( ) -> getRenderSettingFactory ( ) -> createCollection ( $ objMetaModel , $ intIdRenderSetting ) ; if ( $ objRenderSettings == null ) { return false ; } $ objItem = $ objMetaModel -> findById ( $ mixDataId ) ; if ( $ objItem == null ) { return false ; } $ arrRenderedItem = $ objItem -> parseValue ( 'text' , $ objRenderSettings ) ; if ( ! isset ( $ arrRenderedItem [ 'jumpTo' ] ) ) { return false ; } if ( stripos ( $ strParam , 'params.' ) !== false ) { $ mixAttName = StringUtil :: trimsplit ( '.' , $ strParam ) ; $ mixAttName = array_pop ( $ mixAttName ) ; if ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ 'params' ] [ $ mixAttName ] ; } } elseif ( isset ( $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ) ) { return $ arrRenderedItem [ 'jumpTo' ] [ $ strParam ] ; } return false ; }
5742	public function getParserForContentType ( $ contentType ) { if ( 0 !== stripos ( $ contentType , 'multipart/' ) ) { return null ; } list ( $ mime , $ boundary ) = $ this -> parseContentType ( $ contentType ) ; $ parser = new MultipartParser ( ) ; $ parser -> setBoundary ( $ boundary ) ; return $ parser ; }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
3437	public function refreshFields ( ) { if ( $ this -> id === null ) { $ this -> original = [ ] ; return $ this -> fields = [ ] ; } $ sectionsBackup = isset ( $ this -> fields [ 'IBLOCK_SECTION' ] ) ? $ this -> fields [ 'IBLOCK_SECTION' ] : null ; $ this -> fields = static :: query ( ) -> getById ( $ this -> id ) -> fields ; if ( ! empty ( $ sectionsBackup ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] = $ sectionsBackup ; } $ this -> fieldsAreFetched = true ; $ this -> original = $ this -> fields ; return $ this -> fields ; }
6564	public static function load ( $ class ) { $ class = static :: normalizeClass ( $ class ) ; foreach ( static :: $ directories as $ directory ) { if ( Sbp :: fileExists ( $ directory . DIRECTORY_SEPARATOR . $ class , $ path ) ) { require_once $ path ; return true ; } } }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
4650	private function parseEnvironmentLine ( $ environmentLine ) { $ variables = array ( ) ; @ $ variableLines = explode ( ' ' , $ environmentLine ? : '' ) ; foreach ( $ variableLines as $ variableLine ) { if ( ! empty ( $ variableLine ) ) { list ( $ key , $ value ) = $ this -> parseEnvironementVariable ( $ variableLine ) ; $ variables [ $ key ] = $ value ; } } return $ variables ; }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
4065	public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; }
2000	private function fetchData ( FileUpload $ uploader , string $ separator , callable $ callback ) : array { $ data = [ ] ; $ files = $ this -> getFiles ( $ uploader ) ; $ delimiter = $ this -> getDelimiter ( $ separator ) ; foreach ( $ files as $ file ) { $ fp = fopen ( $ file , 'r' ) ; while ( false !== ( $ row = fgetcsv ( $ fp , 0 , $ delimiter ) ) ) { $ data = $ callback ( $ data , $ row ) ; } } return $ data ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
50	protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; }
6414	public static function limit ( IteratorAggregate $ iterable , int $ limitSize ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ limitSize ) { return Iterators :: limit ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ limitSize ) ; } ) ; }
10695	public function select ( $ col = '' , $ colAlias = '' ) { return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( $ col , $ colAlias ) ; }
8225	public function handleRegistration ( Request $ httpRequest ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ user = $ this -> picoAuth -> getUser ( ) ; if ( $ user -> getAuthenticated ( ) ) { $ this -> picoAuth -> redirectToPage ( "index" ) ; } $ this -> picoAuth -> addAllowed ( "register" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/register.md' ) ; $ post = $ httpRequest -> request ; if ( $ post -> has ( "username" ) && $ post -> has ( "email" ) && $ post -> has ( "password" ) && $ post -> has ( "password_repeat" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: REGISTER_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> assertLimits ( ) ; $ reg = array ( "username" => strtolower ( trim ( $ post -> get ( "username" ) ) ) , "email" => trim ( $ post -> get ( "email" ) ) , "password" => new Password ( $ post -> get ( "password" ) ) , "passwordRepeat" => new Password ( $ post -> get ( "password_repeat" ) ) , ) ; $ isValid = $ this -> validateRegistration ( $ reg ) ; if ( $ isValid ) { if ( ! $ this -> limit -> action ( "registration" ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } $ this -> logSuccessfulRegistration ( $ reg ) ; $ userData = array ( 'email' => $ reg [ "email" ] ) ; $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; $ localAuth -> userDataEncodePassword ( $ userData , $ reg [ "password" ] ) ; $ this -> storage -> saveUser ( $ reg [ "username" ] , $ userData ) ; $ this -> session -> addFlash ( "success" , "Registration completed successfully, you can now log in." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; } else { $ this -> session -> addFlash ( "old" , array ( 'username' => $ reg [ "username" ] , 'email' => $ reg [ "email" ] ) ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } } }
11017	public function run ( ) { $ event = new BeforeControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ event ) ; $ action = $ this -> action -> getName ( ) ; if ( $ this -> action -> hasParams ( ) ) { call_user_func_array ( [ $ this , $ action ] , $ this -> action -> getParams ( ) ) ; } else { $ this -> $ action ( ) ; } $ event = new AfterControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ event ) ; }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
6801	public function installTaxes ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_taxes.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Taxes data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } $ country = $ this -> manager -> getRepository ( Country :: class ) -> findOneBy ( [ 'code' => $ code ] ) ; if ( null === $ country ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ tax = new Tax ( ) ; $ tax -> setName ( $ name ) -> setRate ( $ datum [ 'rate' ] ) -> setCountry ( $ country ) ; $ this -> manager -> persist ( $ tax ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
7798	public function parse ( $ text ) { $ statements = array ( ) ; foreach ( $ this -> splitStatements ( $ text ) as $ chunk ) { if ( $ statement = $ this -> statement ( $ chunk ) ) { $ statements [ ] = $ statement ; } } return $ statements ; }
12895	public function setPerson ( \ Chill \ PersonBundle \ Entity \ Person $ person = null ) { $ this -> person = $ person ; return $ this ; }
11759	public function deleteReply ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_REPLY , $ params ] ) ; }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
2319	public static function resize ( $ image , $ width , $ height , $ mode = '' ) { @ trigger_error ( 'Using Image::resize() has been deprecated and will no longer work in Contao 5.0. Use the contao.image.image_factory service instead.' , E_USER_DEPRECATED ) ; return static :: get ( $ image , $ width , $ height , $ mode , $ image , true ) ? true : false ; }
9936	public function setGrouping ( $ pGrouping ) { if ( ( $ pGrouping !== null ) && ( ! in_array ( $ pGrouping , self :: $ dateTimeGroups ) ) && ( ! in_array ( $ pGrouping , self :: $ dynamicTypes ) ) && ( ! in_array ( $ pGrouping , self :: $ topTenType ) ) ) { throw new PhpSpreadsheetException ( 'Invalid rule type for column AutoFilter Rule.' ) ; } $ this -> grouping = $ pGrouping ; return $ this ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
8343	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ rawRequest = null ; self :: $ routes = array ( ) ; self :: $ isInit = true ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true ) { self :: $ rawRequest = new RawRequest ( ) ; Session :: init ( ) ; Locale :: init ( self :: $ rawRequest ) ; } } }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
12358	private function registerCalc ( $ period ) { $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCalcReg :: IN_CALC_TYPE_CODE , Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ) ; $ ctx -> set ( PCalcReg :: IN_PERIOD , $ period ) ; $ res = $ this -> zCalcReg -> exec ( $ ctx ) ; $ result = $ res -> get ( PCalcReg :: OUT_CALC_ID ) ; return $ result ; }
3722	public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; if ( $ oldTable !== $ newTable ) { if ( ! empty ( $ oldTable ) ) { $ this -> tableManipulator -> renameTable ( $ oldTable , $ newTable ) ; } else { $ this -> tableManipulator -> createTable ( $ newTable ) ; } } $ this -> tableManipulator -> setVariantSupport ( $ newTable , $ new -> getProperty ( 'varsupport' ) ) ; }
12735	public function setKeyTitle ( $ class , $ column , $ title ) { $ class = ltrim ( $ this -> getClassName ( $ class ) , '\\' ) ; $ this -> manualKeyTitles [ $ class . '|' . $ column ] = $ title ; return $ this ; }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
6003	public function addVideoTemplate ( $ item ) { if ( ! ( $ item instanceof VideoTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new VideoTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate VideoTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "VideoTemplate"!' , E_USER_WARNING ) ; } } $ this -> videotemplates [ ] = $ item ; return $ this ; }
895	private function findComparisonEnd ( Tokens $ tokens , $ index ) { ++ $ index ; $ count = \ count ( $ tokens ) ; while ( $ index < $ count ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { ++ $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { ++ $ index ; continue ; } if ( ! $ block [ 'isStart' ] ) { break ; } $ index = $ tokens -> findBlockEnd ( $ block [ 'type' ] , $ index ) + 1 ; } $ prev = $ tokens -> getPrevMeaningfulToken ( $ index ) ; return $ tokens [ $ prev ] -> isGivenKind ( T_CLOSE_TAG ) ? $ tokens -> getPrevMeaningfulToken ( $ prev ) : $ prev ; }
12605	public static function getName ( $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ slash = strrpos ( $ file , '/' ) ; if ( $ slash !== false ) { return substr ( $ file , $ slash + 1 ) ; } return $ file ; }
7871	protected function drawPipesEnd ( ) { $ pipes = array_reverse ( $ this -> pipes ) ; foreach ( $ pipes as $ pipe ) { $ this -> drawBordered ( $ this -> geometry -> getSpacedPipe ( $ pipe , static :: NOCK , 'after()' ) ) ; $ this -> drawBorderBottom ( ) ; } }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
3357	public function getImgTag ( $ postfix = null , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<img src="%s" %s />' , $ this -> getUrl ( ) , join ( ' ' , $ to_compile ) ) ; }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
4442	public function completed ( int $ offset = 0 , int $ count = 25 ) { return $ this -> client -> jobs ( 'complete' , null , $ offset , $ count ) ; }
10705	public function getEntityManager ( ) { if ( null === $ this -> em ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> em = $ mainService -> getEntityManager ( ) ; } return $ this -> em ; }
4874	public function setFormId ( $ formId ) { $ this -> formId = $ formId . '-' ; foreach ( $ this as $ button ) { $ button -> setAttribute ( 'id' , $ this -> formId . $ button -> getAttribute ( 'id' ) ) ; } return $ this ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
5652	public function render ( ) { $ tab_stop = $ this -> longestFlag ( $ this -> flag_sets ) + 4 ; $ text = $ this -> overview . "\n" ; $ numberOfFlags = count ( $ this -> flag_sets ) ; for ( $ i = 0 ; $ i < $ numberOfFlags ; $ i ++ ) { $ text .= $ this -> renderFlagSet ( $ this -> flag_sets [ $ i ] , $ this -> explanations [ $ i ] , $ tab_stop ) ; } return $ this -> noDuplicateNewLines ( $ text ) ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
9373	public function display ( ) { $ handler = new PrettyPageHandler ; error_reporting ( E_ALL ) ; $ this -> __call ( 'pushHandler' , array ( $ handler ) ) ; return $ this -> whoops -> register ( ) ; }
5857	protected function localize ( $ input ) { if ( TYPO3_MODE === 'FE' ) { $ output = is_object ( $ GLOBALS [ 'TSFE' ] ) ? $ GLOBALS [ 'TSFE' ] -> sL ( $ input ) : $ input ; } else { $ output = $ GLOBALS [ 'LANG' ] -> sL ( $ input ) ; } return $ output ; }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
7178	public function isValidType ( $ type ) { return in_array ( $ type , array ( self :: ANY , self :: FIXED_LINE , self :: MOBILE , self :: PAGER , self :: PERSONAL_NUMBER , self :: PREMIUM_RATE , self :: SHARED_COST , self :: TOLL_FREE , self :: UAN , self :: VOIP , self :: VOICEMAIL , ) , true ) ; }
6068	public function listVersions ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/versions' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MediaVersion ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
83	private function copyFiles ( $ files , $ source , $ target , $ roles , $ vars ) { foreach ( $ files as $ file ) { $ from = $ this -> combine ( $ source , $ file [ 'from' ] ) ; $ to = $ this -> combine ( $ target , $ roles [ $ file [ 'role' ] ] ) ; $ to = $ this -> combine ( $ to , $ file [ 'to' ] ) ; $ tasks = $ file [ 'tasks' ] ; $ this -> copyFile ( $ from , $ to , $ tasks , $ vars ) ; } }
6911	public function removeExtraCopy ( Recipient $ copy ) { if ( $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> removeElement ( $ copy ) ; } return $ this ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
6549	public function add ( $ data ) { $ columnNum = 0 ; $ rowNum = $ this -> iterator -> current ( ) -> getRowIndex ( ) ; foreach ( ( array ) $ data as $ value ) { $ this -> sheet -> setCellValueByColumnAndRow ( $ columnNum ++ , $ rowNum , $ value ) ; } $ this -> iterator -> next ( ) ; }
11276	public function getMessage ( ) { $ response = [ ] ; if ( $ messages = $ this -> data -> query ( '/Message/Body/Errors' ) -> array ( ) ) { foreach ( $ messages as $ message ) { $ response [ ] = $ message -> textContent ; } } return count ( $ response ) ? implode ( ', ' , $ response ) : null ; }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
2930	public function getValue ( $ key ) { $ allKeys = $ this -> getKeys ( [ $ key ] ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return $ allKeys [ $ key ] [ 'value' ] ; } throw new KeyNotFoundException ( 'Requested key not found in your file.' ) ; }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
8502	public function setMarketplaceIdList ( $ value ) { $ marketplaceIdList = new MarketplaceWebService_Model_IdList ( ) ; $ marketplaceIdList -> setId ( $ value [ 'Id' ] ) ; $ this -> fields [ 'MarketplaceIdList' ] [ 'FieldValue' ] = $ marketplaceIdList ; return ; }
4160	public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; }
10909	public function inject ( string ... $ methods ) : Binding { if ( $ this -> definition -> injects === null ) { $ this -> definition -> injects = \ array_fill_keys ( $ methods , true ) ; } else { foreach ( $ methods as $ f ) { $ this -> definition -> injects [ $ f ] = true ; } } return $ this ; }
5238	private function methodBindingName ( \ ReflectionMethod $ method ) { $ annotations = annotationsOf ( $ method ) ; if ( $ annotations -> contain ( 'List' ) ) { return $ annotations -> firstNamed ( 'List' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Map' ) ) { return $ annotations -> firstNamed ( 'Map' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Named' ) ) { return $ annotations -> firstNamed ( 'Named' ) -> getName ( ) ; } if ( $ annotations -> contain ( 'Property' ) ) { return $ annotations -> firstNamed ( 'Property' ) -> getValue ( ) ; } return null ; }
7336	private function getStockSubjectMappings ( ) { return [ [ 'fieldName' => 'stockMode' , 'columnName' => 'stock_mode' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectModes :: MODE_AUTO , ] , [ 'fieldName' => 'stockState' , 'columnName' => 'stock_state' , 'type' => 'string' , 'length' => 16 , 'nullable' => false , 'default' => Stock \ StockSubjectStates :: STATE_OUT_OF_STOCK , ] , [ 'fieldName' => 'stockFloor' , 'columnName' => 'stock_floor' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => true , 'default' => 0 , ] , [ 'fieldName' => 'inStock' , 'columnName' => 'in_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'availableStock' , 'columnName' => 'available_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'virtualStock' , 'columnName' => 'virtual_stock' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 0 , ] , [ 'fieldName' => 'replenishmentTime' , 'columnName' => 'replenishment_time' , 'type' => 'smallint' , 'nullable' => false , 'default' => 7 , ] , [ 'fieldName' => 'estimatedDateOfArrival' , 'columnName' => 'estimated_date_of_arrival' , 'type' => 'datetime' , 'nullable' => true , ] , [ 'fieldName' => 'geocode' , 'columnName' => 'geocode' , 'type' => 'string' , 'length' => 16 , 'nullable' => true , ] , [ 'fieldName' => 'minimumOrderQuantity' , 'columnName' => 'minimum_order_quantity' , 'type' => 'decimal' , 'precision' => 10 , 'scale' => 3 , 'nullable' => false , 'default' => 1 , ] , [ 'fieldName' => 'quoteOnly' , 'columnName' => 'quote_only' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , [ 'fieldName' => 'endOfLife' , 'columnName' => 'end_of_life' , 'type' => 'boolean' , 'nullable' => false , 'default' => false , ] , ] ; }
10965	public static function getStandardPort ( $ scheme = null ) { if ( $ scheme === null ) { $ scheme = self :: getScheme ( ) ; } if ( isset ( self :: $ schemes [ $ scheme ] ) ) { return self :: $ schemes [ $ scheme ] ; } return 0 ; }
2060	public function scheduleUpdate ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> id || Contao \ Input :: get ( 'act' ) == 'copy' ) { return ; } $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; $ session [ ] = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> id ) -> rootId ; $ objSession -> set ( 'sitemap_updater' , array_unique ( $ session ) ) ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
84	public static function expandPath ( $ path ) { if ( preg_match ( '#^~[\\/]#' , $ path ) ) { return self :: getUserDirectory ( ) . substr ( $ path , 1 ) ; } return preg_replace_callback ( '#^(\$|(?P<percent>%))(?P<var>\w++)(?(percent)%)(?P<path>.*)#' , function ( $ matches ) { if ( Platform :: isWindows ( ) && $ matches [ 'var' ] == 'HOME' ) { return ( getenv ( 'HOME' ) ? : getenv ( 'USERPROFILE' ) ) . $ matches [ 'path' ] ; } return getenv ( $ matches [ 'var' ] ) . $ matches [ 'path' ] ; } , $ path ) ; }
11387	private function hydrate ( ) { if ( true === $ this -> hydrated ) { return ; } $ this -> filesystem -> get ( $ this -> file ) ; $ this -> hydrated = true ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
10761	public function encodeString ( $ string ) { $ string = strtolower ( $ string ) ; $ src = "abcdefghijklmnopqrstuvwxyz0123456789 " ; $ dst = "jklmnopqrstuvwxyz0123456789abcdefghi " ; for ( $ i = 0 ; $ i < strlen ( $ string ) ; $ i ++ ) { $ pos = strpos ( $ src , $ string [ $ i ] ) ; if ( $ pos === false ) { throw new \ Exception ( "Please provide only numbers and alphanumerical characters" ) ; } $ string [ $ i ] = $ dst [ $ pos ] ; } return $ string ; }
10353	private function fireEventOn ( $ action , $ payload ) { $ event = $ this -> getEventName ( ) ; $ this -> dispatcher -> fire ( "auth.{$event}.{$action}" , $ payload ) ; }
3321	public function getSuggestions ( ) { if ( $ this -> suggestions ) { if ( is_callable ( $ this -> suggestions ) ) { return call_user_func ( $ this -> suggestions ) ; } return $ this -> suggestions ; } return ; }
2222	public static function countPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
1245	public static function chain ( ) { $ providers = func_get_args ( ) ; if ( empty ( $ providers ) ) { throw new \ InvalidArgumentException ( 'No providers in chain' ) ; } return function ( ) use ( $ providers ) { $ provider = array_shift ( $ providers ) ; $ credentials = $ provider ( ) ; while ( ( $ provider = array_shift ( $ providers ) ) && ! ( $ credentials instanceof Credentials ) ) { $ credentials = $ provider ( ) ; } return $ credentials ; } ; }
7150	public function clear ( ) { $ this -> provider = null ; $ this -> identifier = null ; $ this -> subject = null ; }
951	public function activate ( ) { $ currentCharge = $ this -> shop -> planCharge ( ) ; if ( ! $ currentCharge -> isType ( Charge :: CHARGE_RECURRING ) ) { throw new Exception ( 'Can only create usage charges for recurring charge.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/recurring_application_charges/{$currentCharge->charge_id}/usage_charges.json" , [ 'usage_charge' => [ 'price' => $ this -> data [ 'price' ] , 'description' => $ this -> data [ 'description' ] , ] , ] ) -> body -> usage_charge ; return $ this -> response ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
10262	public function getInternet ( $ person_name = null , $ company = null ) { if ( empty ( $ person_name ) ) { $ person_name = $ this -> getFullName ( ) ; } $ internet = new Entities \ Internet ( ) ; $ internet -> domain = $ this -> getDomain ( $ company ) ; $ internet -> username = $ this -> getUserName ( $ person_name ) ; $ internet -> email = $ this -> getEmail ( $ person_name , $ internet -> domain ) ; $ internet -> url = $ this -> getUrl ( $ internet -> domain ) ; $ internet -> ip = $ this -> getIp ( ) ; return $ internet ; }
10808	public static function isRender ( $ request ) { return true ; $ accept = $ request -> header ( 'accept' ) ?? '' ; if ( static :: isHas ( $ accept , 'json' ) || static :: isHas ( $ accept , 'api' ) ) { return true ; } else if ( static :: isHas ( $ accept , 'html' ) || static :: isHas ( $ accept , 'xml' ) || static :: isHas ( $ accept , 'text' ) ) { return false ; } else if ( $ request -> header ( 'x-ddv-restful-api' ) ) { return true ; } else if ( $ request -> header ( 'authorization' ) ) { foreach ( $ request -> headers -> keys ( ) as $ value ) { if ( static :: isHas ( $ accept , 'x-ddv-' ) ) { return true ; } } } return false ; }
2203	public static function decodeEntities ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decodeEntities ( $ v ) ; } return $ varValue ; } $ varValue = static :: preserveBasicEntities ( $ varValue ) ; $ varValue = html_entity_decode ( $ varValue , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; return $ varValue ; }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
3550	protected function registerParser ( ) { $ this -> app -> singleton ( EmojiParser :: class , function ( Container $ app ) { return new EmojiParser ( $ app -> make ( RepositoryInterface :: class ) ) ; } ) ; }
12410	public function delete ( $ groupId ) { $ params = [ 'group_id' => intval ( $ groupId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
6647	public function callback ( $ input ) { if ( isset ( $ input [ 'denied' ] ) ) { throw new AuthenticationCanceledException ( ) ; } if ( ! isset ( $ input [ 'oauth_token' ] ) || ! isset ( $ input [ 'oauth_verifier' ] ) ) { throw new InvalidOAuthTokenException ( 'missing oauth_token or oauth_verifier' ) ; } $ verifier_token = $ this -> token -> verifier ( $ input [ 'oauth_token' ] , $ input [ 'oauth_verifier' ] ) ; $ access_token = $ this -> oauth -> getAccessToken ( $ this -> settings , $ this -> consumer , $ verifier_token ) ; return $ this -> getProfile ( $ access_token ) ; }
6619	public function hasChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
7685	function XML_DeleteColumnElements ( & $ Txt , $ Tag , $ SpanAtt , $ ColLst , $ ColMax ) { $ ColNum = 0 ; $ ColPos = 0 ; $ ColQty = 1 ; $ Continue = true ; $ ModifNbr = 0 ; while ( $ Continue && ( $ Loc = clsTbsXmlLoc :: FindElement ( $ Txt , $ Tag , $ ColPos , true ) ) ) { if ( $ SpanAtt !== false ) { $ ColQty = $ Loc -> GetAttLazy ( $ SpanAtt ) ; $ ColQty = ( $ ColQty === false ) ? 1 : intval ( $ ColQty ) ; } $ KeepQty = 0 ; for ( $ i = 1 ; $ i <= $ ColQty ; $ i ++ ) { if ( array_search ( $ ColNum + $ i , $ ColLst ) === false ) $ KeepQty ++ ; } if ( $ KeepQty == 0 ) { $ Loc -> ReplaceSrc ( '' ) ; $ ModifNbr ++ ; } else { if ( $ KeepQty != $ ColQty ) { $ Loc -> ReplaceAtt ( $ SpanAtt , $ KeepQty ) ; $ ModifNbr ++ ; } $ ColPos = $ Loc -> PosEnd + 1 ; } $ ColNum += $ ColQty ; if ( $ ColNum > $ ColMax ) $ Continue = false ; } return $ ModifNbr ; }
4600	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Translatable ) { return ; } $ this -> translationService -> translate ( $ entity ) ; }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2924	public function formatSetterLine ( $ key , $ value = null , $ comment = null , $ export = false ) { $ forceQuotes = ( strlen ( $ comment ) > 0 && strlen ( trim ( $ value ) ) == 0 ) ; $ value = $ this -> formatValue ( $ value , $ forceQuotes ) ; $ key = $ this -> formatKey ( $ key ) ; $ comment = $ this -> formatComment ( $ comment ) ; $ export = $ export ? 'export ' : '' ; $ line = "{$export}{$key}={$value}{$comment}" ; return $ line ; }
10792	public function get ( $ idOrUser ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; if ( 'current' == $ idOrUser ) { return $ userRepository -> get ( $ idOrUser , $ this -> getServiceLocator ( ) ) ; } $ user = $ this -> getEntity ( $ idOrUser ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } return $ userRepository -> get ( $ user , $ this -> getServiceLocator ( ) ) ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
12731	protected function getTasks ( ) { $ tasks = [ ] ; $ tasks [ 'flush-file-cache' ] = [ ] ; $ tasks [ 'flush-file-cache' ] [ 'title' ] = 'Flush File Cache' ; $ tasks [ 'flush-file-cache' ] [ 'description' ] = 'Clear the file cache in Cascade' ; $ tasks [ 'flush-file-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> fileCache -> flush ( ) ; Yii :: $ app -> response -> content = 'File cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; $ tasks [ 'flush-cache' ] = [ ] ; $ tasks [ 'flush-cache' ] [ 'title' ] = 'Flush Memory Cache' ; $ tasks [ 'flush-cache' ] [ 'description' ] = 'Clear the memory cache in Cascade' ; $ tasks [ 'flush-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> cache -> flush ( ) ; Yii :: $ app -> response -> content = 'Memory cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; return $ tasks ; }
10878	public function processForgotten ( string $ hash , string $ password ) : bool { $ decode = $ this -> getDecodeHash ( $ hash ) ; $ id = ( int ) $ decode [ 'id' ] ; $ verifyHash = $ decode [ 'verifyHash' ] ; $ item = $ this -> getById ( $ id ) ; if ( $ item && $ id == $ item [ 'id' ] ) { $ values [ 'hash' ] = $ this -> getHash ( $ password ) ; if ( $ this -> verifyHash ( $ item [ 'id' ] . $ item [ 'login' ] , $ verifyHash ) ) { return $ this -> update ( $ item [ 'id' ] , $ values ) ; } else { throw new IdentityException ( 'Invalid hash!' ) ; } } else { throw new IdentityException ( 'User does not exist!' ) ; } }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
6975	private function throwIllegalOperationIfAdjustmentIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ adjustment = $ this -> getAdjustmentFromEvent ( $ event ) ; if ( $ adjustment -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
9618	public function registerStackMiddleware ( $ class ) { if ( func_num_args ( ) === 0 ) { throw new \ InvalidArgumentException ( "Missing argument(s) when calling registerStackMiddlerware" ) ; } if ( ! class_exists ( $ class ) && ! is_callable ( $ class ) ) { throw new \ InvalidArgumentException ( "{$class} not found or not callable" ) ; } call_user_func_array ( [ $ this -> builder , "push" ] , func_get_args ( ) ) ; }
5445	protected function addSkipping ( ) { $ this -> mapHandler ( 'css' , 'ignore' ) ; $ this -> addEntryPattern ( '<style' , 'text' , 'css' ) ; $ this -> addExitPattern ( '</style>' , 'css' ) ; $ this -> mapHandler ( 'js' , 'ignore' ) ; $ this -> addEntryPattern ( '<script' , 'text' , 'js' ) ; $ this -> addExitPattern ( '</script>' , 'js' ) ; $ this -> mapHandler ( 'comment' , 'ignore' ) ; $ this -> addEntryPattern ( '<!--' , 'text' , 'comment' ) ; $ this -> addExitPattern ( ' , 'comment' ) ; }
6944	protected function registerClassInstanceSingleton ( $ singletonName , $ classNameOrInstance = null ) { if ( empty ( $ classNameOrInstance ) ) { $ classNameOrInstance = $ singletonName ; } $ this -> app -> singleton ( $ singletonName , function ( ) use ( $ classNameOrInstance ) { return is_string ( $ classNameOrInstance ) ? $ classNameOrInstance :: getInstance ( ) : $ classNameOrInstance ; } ) ; }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
10444	protected function handleStatement ( $ line , $ type ) { if ( ! preg_match ( "/^{$type}$/" , $ line ) ) { throw new \ UnexpectedValueException ( "Expected a {$type} statement, got {$line}" ) ; } $ params = [ ] ; $ param = $ this -> handleParam ( ) ; while ( $ param !== null ) { $ params = $ params + $ param ; $ param = $ this -> handleParam ( ) ; } return $ params ; }
386	public function getAttributeOrders ( $ recalculate = false ) { if ( $ this -> _attributeOrders === null || $ recalculate ) { $ this -> _attributeOrders = [ ] ; if ( ( $ params = $ this -> params ) === null ) { $ request = Yii :: $ app -> getRequest ( ) ; $ params = $ request instanceof Request ? $ request -> getQueryParams ( ) : [ ] ; } if ( isset ( $ params [ $ this -> sortParam ] ) ) { foreach ( $ this -> parseSortParam ( $ params [ $ this -> sortParam ] ) as $ attribute ) { $ descending = false ; if ( strncmp ( $ attribute , '-' , 1 ) === 0 ) { $ descending = true ; $ attribute = substr ( $ attribute , 1 ) ; } if ( isset ( $ this -> attributes [ $ attribute ] ) ) { $ this -> _attributeOrders [ $ attribute ] = $ descending ? SORT_DESC : SORT_ASC ; if ( ! $ this -> enableMultiSort ) { return $ this -> _attributeOrders ; } } } } if ( empty ( $ this -> _attributeOrders ) && is_array ( $ this -> defaultOrder ) ) { $ this -> _attributeOrders = $ this -> defaultOrder ; } } return $ this -> _attributeOrders ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
7361	protected function updateWeightTotal ( SaleInterface $ sale ) { $ weightTotal = $ this -> weightCalculator -> calculateSale ( $ sale ) ; if ( $ sale -> getWeightTotal ( ) != $ weightTotal ) { $ sale -> setWeightTotal ( $ weightTotal ) ; return true ; } return false ; }
2568	protected function checkAllIntegers ( ) { $ foundNonInt = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! is_int ( $ arg ) ) { $ foundNonInt = true ; break ; } } return ! $ foundNonInt ; }
8164	static public function render ( $ template , $ userData ) { if ( ! is_string ( $ template ) ) return '' ; $ path = strlen ( $ template ) <= 256 ? trim ( $ template ) : '' ; $ data = array_merge ( Tpl :: $ data , is_array ( $ userData ) ? $ userData : [ ] ) ; $ twig = TwigEnv :: instance ( ) ; if ( Str :: startsWith ( $ path , '@' ) || Str :: endsWith ( strtolower ( $ path ) , '.twig' ) ) { return $ twig -> renderPath ( $ path , $ data ) ; } return $ twig -> renderString ( $ template , $ data ) ; }
10848	protected function getTableName ( $ returnAlias = false ) { $ result = '' ; foreach ( $ this -> clause_table as $ k => $ v ) { if ( ! is_int ( $ k ) && $ returnAlias ) { return $ k ; } else { return $ v ; } } return $ result ; }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
10587	public static function cleanup ( ) : bool { $ ret = true ; foreach ( self :: $ entities as $ path => $ entity ) { if ( ! $ entity -> remove ( ) ) { $ ret = false ; } } self :: $ entities = [ ] ; return $ ret ; }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
2119	public function getFromDca ( ) { $ return = array ( ) ; $ processed = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; $ objExtract = DcaExtractor :: getInstance ( $ strTable ) ; if ( $ objExtract -> isDbTable ( ) ) { $ return [ $ strTable ] = $ objExtract -> getDbInstallerArray ( ) ; } } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromDca' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
5556	public function getUrlById ( $ id ) { foreach ( $ this -> frames as $ index => $ frame ) { if ( $ url = $ frame -> getUrlById ( $ id ) ) { if ( ! $ url -> gettarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ index ) ) ; } return $ url ; } } return false ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
955	public function retrieve ( ) { $ path = null ; switch ( $ this -> type ) { case self :: CHARGE_CREDIT : $ path = 'application_credits' ; break ; case self :: CHARGE_ONETIME : $ path = 'application_charges' ; break ; default : $ path = 'recurring_application_charges' ; break ; } return $ this -> shop -> api ( ) -> rest ( 'GET' , "/admin/{$path}/{$this->charge_id}.json" ) -> body -> { substr ( $ path , 0 , - 1 ) } ; }
9871	private function writeBreaks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ aRowBreaks = [ ] ; $ aColumnBreaks = [ ] ; foreach ( $ pSheet -> getBreaks ( ) as $ cell => $ breakType ) { if ( $ breakType == PhpspreadsheetWorksheet :: BREAK_ROW ) { $ aRowBreaks [ ] = $ cell ; } elseif ( $ breakType == PhpspreadsheetWorksheet :: BREAK_COLUMN ) { $ aColumnBreaks [ ] = $ cell ; } } if ( ! empty ( $ aRowBreaks ) ) { $ objWriter -> startElement ( 'rowBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aRowBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aRowBreaks ) ) ; foreach ( $ aRowBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , $ coords [ 1 ] ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } if ( ! empty ( $ aColumnBreaks ) ) { $ objWriter -> startElement ( 'colBreaks' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ aColumnBreaks ) ) ; $ objWriter -> writeAttribute ( 'manualBreakCount' , count ( $ aColumnBreaks ) ) ; foreach ( $ aColumnBreaks as $ cell ) { $ coords = Coordinate :: coordinateFromString ( $ cell ) ; $ objWriter -> startElement ( 'brk' ) ; $ objWriter -> writeAttribute ( 'id' , Coordinate :: columnIndexFromString ( $ coords [ 0 ] ) - 1 ) ; $ objWriter -> writeAttribute ( 'man' , '1' ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
3416	protected function normalizeFieldsForSave ( $ selectedFields ) { $ fields = [ ] ; if ( $ this -> fields === null ) { return [ ] ; } foreach ( $ this -> fields as $ field => $ value ) { if ( ! $ this -> fieldShouldNotBeSaved ( $ field , $ value , $ selectedFields ) ) { $ fields [ $ field ] = $ value ; } } return $ fields ? : null ; }
6137	public function searchtotal ( Search $ search ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/search/total' , $ parameters ) ; return $ result ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
8403	public static function loadClass ( string $ className ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'bootstrap doesn\'t seem to have been initialized' ) ; } $ fileName = null ; if ( ( $ namespacePos = strripos ( $ className , '\\' ) ) !== false ) { $ namespacePos = ( int ) $ namespacePos ; $ namespace = substr ( $ className , 0 , $ namespacePos ) ; $ subNamespaces = array ( ) ; while ( $ fileName === null && $ namespace != null ) { if ( isset ( self :: $ namespaces [ $ namespace ] ) === false ) { $ subNamespacePos = strripos ( $ namespace , '\\' ) ; $ subNamespacePos = ( int ) $ subNamespacePos ; $ subNamespaces [ ] = substr ( $ namespace , $ subNamespacePos ) ; $ namespace = substr ( $ namespace , 0 , $ subNamespacePos ) ; } else { $ fileName = self :: $ namespaces [ $ namespace ] ; } } if ( $ fileName === null ) { throw new UnknownNamespace ( 'can\'t find namespace "' . substr ( $ className , 0 , $ namespacePos ) . '"' ) ; } $ fileName = self :: $ namespaces [ $ namespace ] . str_replace ( '\\' , DIRECTORY_SEPARATOR , implode ( '' , array_reverse ( $ subNamespaces ) ) ) ; $ className = substr ( $ className , $ namespacePos + 1 ) ; } if ( $ fileName != null ) { $ fileName .= DIRECTORY_SEPARATOR . str_replace ( '_' , DIRECTORY_SEPARATOR , $ className ) . '.php' ; require $ fileName ; } }
8119	public function submitReview ( $ record , $ data ) { if ( ! $ this -> canSubmitReview ( $ record ) ) { throw new ValidationException ( _t ( __CLASS__ . '.ErrorReviewPermissionDenied' , 'It seems you don\'t have the necessary permissions to submit a content review' ) ) ; } $ notes = ( ! empty ( $ data [ 'Review' ] ) ? $ data [ 'Review' ] : _t ( __CLASS__ . '.NoComments' , '(no comments)' ) ) ; $ record -> addReviewNote ( Security :: getCurrentUser ( ) , $ notes ) ; $ record -> advanceReviewDate ( ) ; $ request = $ this -> controller -> getRequest ( ) ; $ message = _t ( __CLASS__ . '.Success' , 'Review successfully added' ) ; if ( $ request -> getHeader ( 'X-Formschema-Request' ) ) { return $ message ; } elseif ( Director :: is_ajax ( ) ) { $ response = HTTPResponse :: create ( $ message , 200 ) ; $ response -> addHeader ( 'Content-Type' , 'text/html; charset=utf-8' ) ; return $ response ; } return $ this -> controller -> redirectBack ( ) ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
5647	public function paintCaseEnd ( $ test_name ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> paintCaseEnd ( $ test_name ) ; } }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
5769	public function setSql ( ) { $ this -> args [ ] = $ this -> updateOnColumnValue ; $ lastArgNum = count ( $ this -> args ) ; $ this -> sql = "UPDATE $this->dbTable SET $this->setColumnsValues WHERE $this->updateOnColumnName = $" . $ lastArgNum ; }
11211	protected function hasInLookup ( $ key ) { foreach ( $ this -> lookup_pool as $ registry ) { if ( $ this -> hasInRegistry ( $ registry , $ key ) ) { $ this -> cache_key = $ key ; $ this -> cache_reg = $ registry ; return true ; } } return false ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
4185	public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; }
2642	public function cleanAll ( ) { if ( $ this -> purged == true ) { return true ; } $ this -> purged = true ; $ type = 'clean/purge all' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge_all' ; $ result = $ this -> _purge ( $ uri , null ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( 'clean all items' ) ; } $ canPublishPurgeAllChanges = $ this -> config -> canPublishPurgeAllChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishPurgeAllChanges || $ canPublishPurgeChanges ) ) { $ this -> sendWebHook ( '*initiated clean/purge all*' ) ; $ canPublishPurgeAllDebugBacktrace = $ this -> config -> canPublishPurgeAllDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeAllDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type ) ; } return $ result [ 'status' ] ; }
6196	public function isActive ( string $ url ) { if ( $ this -> makeUrl ( $ url , true ) === str_replace ( $ this -> uri , '' , $ _SERVER [ 'REQUEST_URI' ] ) ) { return true ; } return false ; }
11639	public function getColumnSettings ( ) { if ( is_null ( $ this -> _columnSettings ) ) { $ this -> _columnSettings = [ ] ; foreach ( $ this -> columns as $ key => $ c ) { if ( ! $ c -> visible ) { continue ; } $ this -> _columnSettings [ $ key ] = [ 'label' => $ c -> getDataLabel ( ) ] ; if ( ! isset ( $ c -> htmlOptions ) ) { $ c -> htmlOptions = [ ] ; } $ this -> _columnSettings [ $ key ] [ 'htmlOptions' ] = $ c -> htmlOptions ; $ sortableResolve = $ this -> dataProvider -> sort -> resolveAttribute ( $ c -> name ) ; $ this -> _columnSettings [ $ key ] [ 'sortable' ] = ! empty ( $ sortableResolve ) ; } } return $ this -> _columnSettings ; }
5751	public function deleteByPrimaryKey ( $ primaryKeyValue , ? string $ returnField = null ) : ? string { if ( null === $ role = $ this -> getObjectById ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ QueryResultsNotFoundException ( "Role not found: id $primaryKeyValue" ) ; } if ( ! $ role -> isDeletable ( ( int ) $ primaryKeyValue ) ) { throw new Exceptions \ UnallowedActionException ( "Role in use: id $primaryKeyValue" ) ; } return parent :: deleteByPrimaryKey ( $ primaryKeyValue , $ returnField ) ; }
12342	protected function printInfo ( $ msg , bool $ withTime = true , ? string $ fontColor = self :: FONT_COLOR_MAP [ 'lightGreen' ] , ? string $ bgColor = null ) : void { $ this -> print ( $ this -> getColoredMsg ( $ msg , $ fontColor , $ bgColor ) , $ withTime ) ; }
8192	public static function guess ( $ name ) { if ( in_array ( substr ( $ name , - 1 ) , array ( '/' , '\\' ) ) ) { return 'html' ; } if ( '.twig' === substr ( $ name , - 5 ) ) { $ name = substr ( $ name , 0 , - 5 ) ; } $ extension = pathinfo ( $ name , PATHINFO_EXTENSION ) ; switch ( $ extension ) { case 'js' : return 'js' ; case 'css' : return 'css' ; case 'txt' : return false ; default : return 'html' ; } }
6863	protected function registerManager ( ) { $ this -> app -> singleton ( 'notifyme' , function ( $ app ) { $ config = $ app [ 'config' ] ; $ factory = $ app [ 'notifyme.factory' ] ; return new NotifyMeManager ( $ config , $ factory ) ; } ) ; $ this -> app -> alias ( 'notifyme' , NotifyMeManager :: class ) ; $ this -> app -> alias ( 'notifyme' , ManagerInterface :: class ) ; }
7111	static public function isValidReason ( $ reason , $ throw = true ) { if ( in_array ( $ reason , static :: getReasons ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid stock adjustment reason." ) ; } return false ; }
6586	protected function request ( array $ options ) { $ this -> info = null ; $ this -> setOpt ( $ options ) ; $ result = $ this -> perform ( 'curl_exec' ) ; $ this -> info = $ this -> perform ( 'curl_getinfo' ) ; return $ result ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
6113	public function sendPluginCmd ( $ plugin , $ data , $ cpw = null , $ subscribed = false ) { if ( $ this -> getId ( ) != $ this -> getParent ( ) -> whoamiGet ( "client_channel_id" ) ) { $ this -> getParent ( ) -> clientMove ( $ this -> getParent ( ) -> whoamiGet ( "client_id" ) , $ this -> getId ( ) , $ cpw ) ; } $ this -> execute ( "plugincmd" , array ( "name" => $ plugin , "data" => $ data , "targetmode" => $ subscribed ? TeamSpeak3 :: PLUGINCMD_CHANNEL_SUBSCRIBED : TeamSpeak3 :: PLUGINCMD_CHANNEL ) ) ; }
2053	public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; }
1172	protected function callProtected ( $ instance , $ method , $ args = [ ] ) { if ( ! ( $ instance instanceof Closure ) ) { $ instance = $ this -> createProtectedCaller ( $ instance ) ; } return call_user_func ( $ instance , $ method , $ args ) ; }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
8584	public function setASIN ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASIN' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
7479	public function getContent ( ) { $ this -> absolute ( ) ; if ( ! is_file ( $ this -> data ) ) { Exception :: i ( ) -> setMessage ( self :: ERROR_PATH_IS_NOT_FILE ) -> addVariable ( $ this -> data ) -> trigger ( ) ; } return file_get_contents ( $ this -> data ) ; }
5644	public function getStatus ( ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> getStatus ( ) ) { return false ; } } return true ; }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
7140	protected function handleQuantityChange ( SupplierDeliveryItemInterface $ item ) { $ changeSet = $ this -> persistenceHelper -> getChangeSet ( $ item ) ; if ( null === $ orderItem = $ item -> getOrderItem ( ) ) { throw new RuntimeException ( "Failed to retrieve order item." ) ; } if ( null !== $ stockUnit = $ orderItem -> getStockUnit ( ) ) { if ( 0 != $ deltaQuantity = floatval ( $ changeSet [ 'quantity' ] [ 1 ] ) - floatval ( $ changeSet [ 'quantity' ] [ 0 ] ) ) { $ this -> stockUnitUpdater -> updateReceived ( $ stockUnit , $ deltaQuantity , true ) ; } } elseif ( $ orderItem -> hasSubjectIdentity ( ) ) { throw new RuntimeException ( "Failed to retrieve stock unit." ) ; } if ( null === $ order = $ orderItem -> getOrder ( ) ) { throw new RuntimeException ( "Failed to retrieve order." ) ; } $ this -> scheduleSupplierOrderContentChangeEvent ( $ order ) ; }
6171	protected function onAddFailure ( $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'F' ) ; $ this -> failure = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
10937	protected function getObfuscatedEmail ( CustomerInterface $ user ) { $ email = $ user -> getEmail ( ) ; if ( false !== $ pos = strpos ( $ email , '@' ) ) { $ email = '...' . substr ( $ email , $ pos ) ; } return $ email ; }
355	public function prepare ( $ forcePrepare = false ) { if ( $ forcePrepare || $ this -> _models === null ) { $ this -> _models = $ this -> prepareModels ( ) ; } if ( $ forcePrepare || $ this -> _keys === null ) { $ this -> _keys = $ this -> prepareKeys ( $ this -> _models ) ; } }
10811	protected function bindValues ( $ sql , array $ settings ) { $ bindings = & $ this -> bindings ; $ escape = $ this -> getEscapeCallable ( $ settings [ 'escapeFunction' ] ) ; $ params = $ this -> getBuilder ( ) -> getPlaceholderMapping ( ) ; $ function = function ( $ v ) use ( $ settings , & $ bindings , $ escape ) { if ( $ settings [ 'positionedParam' ] ) { $ bindings [ ] = $ v ; return '?' ; } elseif ( $ settings [ 'namedParam' ] && isset ( $ v [ 0 ] ) && ':' == $ v [ 0 ] ) { return $ v ; } elseif ( is_numeric ( $ v ) && ! is_string ( $ v ) ) { return $ v ; } else { return $ escape ( $ v ) ; } } ; return preg_replace_callback ( '/\b__PH_[0-9]++__\b/' , function ( $ m ) use ( & $ params , $ function ) { return $ function ( $ params [ $ m [ 0 ] ] ) ; } , $ sql ) ; }
231	public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
9547	public function rank ( $ info , $ weights ) { if ( ! empty ( $ weights ) ) { $ weights = explode ( ',' , $ weights ) ; } $ score = ( float ) 0.0 ; $ isize = 4 ; $ phrases = ( int ) ord ( substr ( $ info , 0 , $ isize ) ) ; $ columns = ( int ) ord ( substr ( $ info , $ isize , $ isize ) ) ; $ string = $ phrases . ' ' . $ columns . ' ' ; for ( $ p = 0 ; $ p < $ phrases ; ++ $ p ) { $ term = substr ( $ info , ( 2 + $ p * $ columns * 3 ) * $ isize ) ; for ( $ c = 0 ; $ c < $ columns ; ++ $ c ) { $ here = ( float ) ord ( substr ( $ term , ( 3 * $ c * $ isize ) , 1 ) ) ; $ total = ( float ) ord ( substr ( $ term , ( 3 * $ c + 1 ) * $ isize , 1 ) ) ; $ rows = ( float ) ord ( substr ( $ term , ( 3 * $ c + 2 ) * $ isize , 1 ) ) ; $ relevance = ( ! empty ( $ total ) ) ? ( $ rows / $ total ) * $ here : 0 ; $ weight = ( isset ( $ weights [ $ c ] ) ) ? ( float ) $ weights [ $ c ] : 1 ; $ score += $ relevance * $ weight ; $ string .= $ here . $ total . $ rows . ' (' . round ( $ relevance , 2 ) . '*' . $ weight . ') ' ; } } return $ score ; }
1389	protected function resourceExists ( string $ type , string $ id , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceExists ( $ type , $ id , $ path ) ) ; }
7622	public function signRequestUrl ( $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { foreach ( $ this -> getPermissionSet ( ) as $ permittedUrl ) { if ( $ this -> permissionMatchesRequest ( $ permittedUrl , $ requestUrl , $ resourceType , $ requiredPermission ) ) { $ parsedPermittedUrl = parse_url ( $ permittedUrl ) ; if ( strpos ( $ requestUrl , '?' ) === false ) { $ requestUrl .= '?' ; } else { $ requestUrl .= '&' ; } $ requestUrl .= $ parsedPermittedUrl [ 'query' ] ; return $ requestUrl ; } } return $ requestUrl ; }
7703	function OpenDoc_ChartInit ( ) { $ this -> OpenDocCharts = array ( ) ; $ idx = $ this -> Ext_GetMainIdx ( ) ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenDoc_ChartInit' ) ; $ p = 0 ; while ( $ drEl = clsTbsXmlLoc :: FindElement ( $ Txt , 'draw:frame' , $ p ) ) { $ src = $ drEl -> GetInnerSrc ( ) ; $ objEl = clsTbsXmlLoc :: FindStartTag ( $ src , 'draw:object' , 0 ) ; if ( $ objEl ) { $ href = $ objEl -> GetAttLazy ( 'xlink:href' ) ; if ( $ href ) { $ imgEl = clsTbsXmlLoc :: FindElement ( $ src , 'draw:image' , 0 ) ; $ img_href = ( $ imgEl ) ? $ imgEl -> GetAttLazy ( 'xlink:href' ) : false ; $ img_src = ( $ imgEl ) ? $ imgEl -> GetSrc ( 'xlink:href' ) : false ; $ titEl = clsTbsXmlLoc :: FindElement ( $ src , 'svg:title' , 0 ) ; $ title = ( $ titEl ) ? $ titEl -> GetInnerSrc ( ) : '' ; if ( substr ( $ href , 0 , 2 ) == './' ) $ href = substr ( $ href , 2 ) ; if ( is_string ( $ img_href ) && ( substr ( $ img_href , 0 , 2 ) == './' ) ) $ img_href = substr ( $ img_href , 2 ) ; $ this -> OpenDocCharts [ ] = array ( 'href' => $ href , 'title' => $ title , 'img_href' => $ img_href , 'img_src' => $ img_src , 'to_clear' => ( $ img_href !== false ) ) ; } } $ p = $ drEl -> PosEnd ; } }
1464	private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
7296	private function get_mail_to_chunk ( $ to , $ send_next_group = array ( ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ object_type = $ this -> options [ 'static_options' ] [ 'object' ] [ 'type' ] ; if ( empty ( $ send_next_group ) ) { $ chunk_size = $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunksize' ] ; $ send_next_group = array_chunk ( $ to , $ chunk_size ) ; } $ to = apply_filters ( 'iac_email_address_chunk' , array_shift ( $ send_next_group ) , $ object_id , $ object_type ) ; $ to = implode ( ',' , $ to ) ; if ( ! empty ( $ send_next_group ) ) { wp_schedule_single_event ( time ( ) + $ this -> options [ 'static_options' ] [ 'schedule_interval' ] , 'iac_schedule_send_chunks' , array ( $ object_id , $ object_type , $ send_next_group ) ) ; } return $ to ; }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
2459	public function move ( ) { if ( $ this -> intId && Input :: get ( 'sid' ) && ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] || ! \ in_array ( $ this -> intId , $ this -> root ) ) ) { $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=? OR id=?" ) -> limit ( 2 ) -> execute ( $ this -> intId , Input :: get ( 'sid' ) ) ; $ row = $ objRow -> fetchAllAssoc ( ) ; if ( $ row [ 0 ] [ 'pid' ] == $ row [ 1 ] [ 'pid' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 0 ] [ 'sorting' ] , $ row [ 1 ] [ 'id' ] ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 1 ] [ 'sorting' ] , $ row [ 0 ] [ 'id' ] ) ; $ this -> invalidateCacheTags ( $ this ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
10656	public function usort ( $ cmp_function ) { $ tmp = $ this -> getArrayCopy ( ) ; $ ret = usort ( $ tmp , $ cmp_function ) ; $ tmp = new self ( $ tmp ) ; $ this -> exchangeArray ( $ tmp -> getArrayCopy ( ) ) ; return $ ret ; }
6431	public function getUserProfile ( ) { $ facebook = $ this -> getFacebookObject ( ) ; $ response = $ facebook -> get ( '/me' , $ this -> accesstoken ) ; $ me = $ response -> getGraphUser ( ) ; return array ( 'userid' => $ me -> getId ( ) , 'name' => $ me -> getName ( ) , 'email' => $ me -> getField ( 'email' ) , 'imageurl' => 'https://graph.facebook.com/' . $ me -> getId ( ) . '/picture?type=large' ) ; }
4167	protected function stringify ( $ name ) { $ classes = array_unique ( array_merge ( $ this -> suffixClass ( $ this -> getFromConfig ( $ name ) ) , $ this -> suffixClass ( $ this -> $ name ) ) ) ; $ newLine2Tabs = PHP_EOL . ' ' ; if ( $ name == 'providers' ) { return "'$name' => [$newLine2Tabs" . implode ( ',' . $ newLine2Tabs , $ classes ) . PHP_EOL . ' ],' . PHP_EOL ; } $ template = "'$name' => [$newLine2Tabs" ; foreach ( $ classes as $ fullClassName ) { $ template .= "'{$this->getClassName($fullClassName)}' => $fullClassName,$newLine2Tabs" ; } $ template .= PHP_EOL . ' ],' . PHP_EOL ; return $ template ; }
5651	public function explainFlag ( $ flags , $ explanation ) { $ flags = is_array ( $ flags ) ? $ flags : array ( $ flags ) ; $ this -> flag_sets [ ] = $ flags ; $ this -> explanations [ ] = $ explanation ; }
9952	public function setBreak ( $ pCoordinate , $ pBreak ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( $ pCoordinate != '' ) { if ( $ pBreak == self :: BREAK_NONE ) { if ( isset ( $ this -> breaks [ $ pCoordinate ] ) ) { unset ( $ this -> breaks [ $ pCoordinate ] ) ; } } else { $ this -> breaks [ $ pCoordinate ] = $ pBreak ; } } else { throw new Exception ( 'No cell coordinate specified.' ) ; } return $ this ; }
12468	public function getStream ( $ mediaId ) { $ response = $ this -> getHttp ( ) -> get ( self :: API_GET , [ 'media_id' => $ mediaId ] ) ; $ response -> getBody ( ) -> rewind ( ) ; $ body = $ response -> getBody ( ) -> getContents ( ) ; $ json = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { $ this -> checkAndThrow ( $ json ) ; } return $ body ; }
10372	public static function add_styles ( ) { self :: look_if_process_files ( 'style' ) ; foreach ( self :: $ data [ 'style' ] as $ data ) { wp_register_style ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'media' ] ) ; wp_enqueue_style ( $ data [ 'name' ] ) ; } }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
10684	private function bootstrap ( ) { ErrorInterceptor :: registerErrorHandler ( ) ; set_exception_handler ( array ( static :: class , 'handleException' ) ) ; ini_set ( 'default_charset' , 'UTF-8' ) ; mb_internal_encoding ( 'UTF-8' ) ; ini_set ( 'log_errors' , '1' ) ; $ this -> loadConfig ( ) ; $ this -> injector -> setInstance ( Configuration :: class , $ this -> config ) ; $ this -> cachemanager = $ this -> injector -> getInstance ( Cache \ Manager :: class ) ; $ this -> dev = $ this -> config -> dget ( 'site' , 'dev' , true ) ; $ this -> configureAutoloaderAndResolver ( ) ; try { $ this -> path_config -> checkPaths ( ) ; } catch ( PermissionError $ e ) { return $ this -> showPermissionError ( $ e ) ; } $ test = defined ( 'WEDETO_TEST' ) && WEDETO_TEST === 1 ? 'test' : '' ; if ( PHP_SAPI === 'cli' ) ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php-cli' . $ test . '.log' ) ; else ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php' . $ test . '.log' ) ; $ this -> setCreatePermissions ( ) ; LoggerFactory :: setLoggerFactory ( new LoggerFactory ( ) ) ; Autoloader :: setLogger ( LoggerFactory :: getLogger ( [ 'class' => Autoloader :: class ] ) ) ; $ this -> setupLogging ( ) ; if ( $ this -> path_config -> cache ) { $ this -> cachemanager -> setCachePath ( $ this -> path_config -> cache ) ; $ this -> cachemanager -> setHook ( $ this -> config -> dget ( 'cache' , 'expiry' , 60 ) ) ; } $ this -> module_manager = new Module \ Manager ( $ this -> resolver ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> setupPlugins ( ) ; }
4422	protected function interact ( InputInterface $ input , OutputInterface $ output ) { $ this -> input = $ input ; $ this -> output = $ output ; $ this -> questionHelper = $ this -> getHelper ( 'question' ) ; if ( Kernel :: VERSION_ID < 20700 ) { throw new RuntimeException ( 'Installation is not possible. Netgen Admin UI requires Symfony 2.7 or later to work.' ) ; } if ( ! $ this -> getContainer ( ) -> hasParameter ( 'ezpublish_legacy.root_dir' ) ) { throw new RuntimeException ( sprintf ( "%s\n%s" , 'Installation is not possible because eZ Publish Legacy is not present.' , 'Netgen Admin UI requires eZ Publish Community 2014.12 (Netgen Variant), eZ Publish 5.4.x or eZ Platform with Legacy Bridge to work.' ) ) ; } $ this -> writeSection ( 'Welcome to the Netgen Admin UI installation' ) ; while ( ! $ this -> doInteract ( ) ) { } return 0 ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
4466	private function normalizeCommandArgs ( string $ command , array $ args ) : array { $ arguments = array_merge ( [ $ command , microtime ( true ) ] , $ args ) ; array_unshift ( $ arguments , 0 ) ; array_unshift ( $ arguments , $ this -> sha ) ; return $ arguments ; }
11102	public static function countryCodeThreeToTwo ( $ code ) { if ( ! array_key_exists ( $ code , self :: $ _countryCodes ) ) { return false ; } return self :: $ _countryCodes [ $ code ] ; }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
4629	protected function prepareRequestParameters ( ) { if ( $ this -> command -> hasParameters ( ) ) { $ this -> query = http_build_query ( $ this -> command -> getParameters ( ) , '' , '&' , PHP_QUERY_RFC3986 ) ; } return $ this ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
3399	public function get ( $ arguments = [ ] ) { try { $ this -> makeRequest ( $ arguments ) ; } catch ( ConnectException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; return $ this -> errorResponse ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ url ) ; } catch ( RequestException $ e ) { $ url = $ e -> getRequest ( ) -> getUrl ( ) ; $ status = $ e -> getCode ( ) ; $ response = $ e -> getResponse ( ) ; $ reason = $ e -> getMessage ( ) ; if ( ! is_null ( $ response ) ) { $ reason = $ response -> getReasonPhrase ( ) ; } return $ this -> errorResponse ( $ status , $ reason , $ url ) ; } return $ this -> parseBlueprint ( $ this -> schemaBlueprint ) ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
10847	protected function runCommand ( $ command , $ basePath , $ asset , $ result ) { $ command = Yii :: getAlias ( $ command ) ; $ command = strtr ( $ command , [ '{from}' => escapeshellarg ( "$basePath/$asset" ) , '{to}' => escapeshellarg ( "$basePath/$result" ) , ] ) ; $ descriptor = [ 1 => [ 'pipe' , 'w' ] , 2 => [ 'pipe' , 'w' ] , ] ; $ pipes = [ ] ; $ proc = proc_open ( $ command , $ descriptor , $ pipes , $ basePath ) ; $ stdout = stream_get_contents ( $ pipes [ 1 ] ) ; $ stderr = stream_get_contents ( $ pipes [ 2 ] ) ; foreach ( $ pipes as $ pipe ) { fclose ( $ pipe ) ; } $ status = proc_close ( $ proc ) ; if ( $ status === 0 ) { Yii :: trace ( "Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } elseif ( YII_DEBUG ) { throw new Exception ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" ) ; } else { Yii :: error ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } return $ status === 0 ; }
2755	public function onImport ( ImportEvent $ event ) { $ uuids = [ '0bd5c257-2231-450f-b4c2-ab156af7b78d' , '36b2e2b2-3df0-43eb-a282-d792b0999c07' , '94ad928b-3ec8-4bcb-b617-ab1607bf69cb' , 'bbb1ee17-15f8-46bd-9df5-21c58040d741' , ] ; foreach ( $ event -> getImportedEntities ( ) as $ entity ) { if ( in_array ( $ entity -> uuid ( ) , $ uuids ) ) { $ entity -> moderation_state -> value = 'published' ; $ entity -> save ( ) ; } } }
8325	public function deletePingback ( $ uri ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=del_pingback&addr={$uri}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
1902	public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; if ( strncasecmp ( $ this -> strQuery , 'INSERT' , 6 ) === 0 || strncasecmp ( $ this -> strQuery , 'UPDATE' , 6 ) === 0 ) { $ this -> strQuery = str_replace ( '%s' , '%p' , $ this -> strQuery ) ; } $ arrChunks = preg_split ( "/('[^']*')/" , $ this -> strQuery , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; foreach ( $ arrChunks as $ k => $ v ) { if ( substr ( $ v , 0 , 1 ) == "'" ) { continue ; } $ arrChunks [ $ k ] = str_replace ( '?' , '%s' , $ v ) ; } $ this -> strQuery = implode ( '' , $ arrChunks ) ; return $ this ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
4790	function insert_update ( array $ unique , array $ insert , array $ update = array ( ) ) { if ( ! $ update ) { $ update = $ insert ; } $ insert = $ unique + $ insert ; $ values = "(" . implode ( ", " , array_keys ( $ insert ) ) . ") VALUES " . $ this -> quote ( $ insert ) ; if ( $ this -> notORM -> driver == "mysql" ) { $ set = array ( ) ; if ( ! $ update ) { $ update = $ unique ; } $ quoteChar = $ this -> getQuoteChar ( ) ; foreach ( $ update as $ key => $ val ) { $ set [ ] = "{$quoteChar}{$key}{$quoteChar} = " . $ this -> quote ( $ val ) ; } return $ this -> insert ( "$values ON DUPLICATE KEY UPDATE " . implode ( ", " , $ set ) ) ; } else { $ connection = $ this -> notORM -> connection ; $ errorMode = $ connection -> getAttribute ( PDO :: ATTR_ERRMODE ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , PDO :: ERRMODE_EXCEPTION ) ; try { $ return = $ this -> insert ( $ values ) ; $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; return $ return ; } catch ( PDOException $ e ) { $ connection -> setAttribute ( PDO :: ATTR_ERRMODE , $ errorMode ) ; if ( $ e -> getCode ( ) == "23000" || $ e -> getCode ( ) == "23505" ) { if ( ! $ update ) { return 0 ; } $ clone = clone $ this ; $ return = $ clone -> where ( $ unique ) -> update ( $ update ) ; return ( $ return ? $ return + 1 : $ return ) ; } if ( $ errorMode == PDO :: ERRMODE_EXCEPTION ) { throw $ e ; } elseif ( $ errorMode == PDO :: ERRMODE_WARNING ) { trigger_error ( "PDOStatement::execute(): " . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } } return 0 ; }
2024	public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } $ arrAliases = array_filter ( array_map ( function ( $ v ) { return preg_match ( '/^[\w\/.-]+$/u' , $ v ) ? $ v : null ; } , $ arrAliases ) ) ; if ( empty ( $ arrAliases ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.alias IN('" . implode ( "','" , array_filter ( $ arrAliases ) ) . "')" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.alias" , $ arrAliases ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
1104	protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; }
11166	protected function buildHeader ( ) { if ( $ this -> getExtNamespace ( ) === null ) { throw new ExtDirectException ( "Ext js Namespace not set" ) ; } $ var = 'Ext.ns("' . $ this -> getNameSpace ( ) . '"); ' . $ this -> getNameSpace ( ) . "." . Keys :: EXT_HEADER . ' = ' ; return $ var ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
8003	public static function forCurrentSystem ( $ code = self :: CODE_FOR_SYSTEM , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . self :: MESSAGE_EXTENSION_FOR_SYSTEM ; return new static ( $ message , $ code , $ previous ) ; }
6710	protected function parseHeader ( array $ headers = [ ] ) { $ processedHeaders = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( $ key , 0 , 5 ) == 'HTTP_' ) { $ name = str_replace ( ' ' , '-' , ucwords ( strtolower ( str_replace ( '_' , ' ' , substr ( $ key , 5 ) ) ) ) ) ; $ processedHeaders [ $ name ] = $ value ; } elseif ( $ key == 'CONTENT_TYPE' ) { $ processedHeaders [ 'Content-Type' ] = $ value ; } elseif ( $ key == 'CONTENT_LENGTH' ) { $ processedHeaders [ 'Content-Length' ] = $ value ; } } return $ processedHeaders ; }
4595	public function getPermissions ( User $ user ) { $ permissions = new ArrayCollection ; $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => null ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => $ user -> getIdentity ( ) -> getType ( ) , 'assigneeUuid' => $ user -> getIdentity ( ) -> getUuid ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } $ accesses = $ this -> repository -> findBy ( [ 'assignee' => 'Role' , 'assigneeUuid' => $ user -> getIdentity ( ) -> getRoles ( ) ] ) ; foreach ( $ accesses as $ access ) { foreach ( $ access -> getPermissions ( ) as $ permission ) { $ permissions -> add ( $ permission ) ; } } return $ permissions ; }
4585	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ this -> getSignature ( ) ) { $ event -> markAsInvalid ( ) ; } }
2895	public function send ( ) { try { $ this -> captureEmail ( ) ; } catch ( Exception $ e ) { Mage :: logException ( $ e ) ; } return $ this -> parentSend ( ) ; }
1555	protected function queryValidatorWithoutSearch ( ) { return $ this -> validatorFactory ( ) -> queryParameters ( $ this -> queryRulesWithoutSearch ( ) , $ this -> queryMessages ( ) , $ this -> queryCustomAttributes ( ) , function ( Validator $ validator ) { return $ this -> conditionalQuery ( $ validator ) ; } ) ; }
4885	public function setExcludeMethods ( $ methods ) { if ( is_string ( $ methods ) ) { $ methods = array ( $ methods ) ; } foreach ( $ methods as $ method ) { $ this -> addFilter ( $ method , new MethodMatchFilter ( $ method ) , FilterComposite :: CONDITION_AND ) ; } }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
2250	protected static function replaceOldBePaths ( $ strContext ) { $ router = System :: getContainer ( ) -> get ( 'router' ) ; $ generate = function ( $ route ) use ( $ router ) { return substr ( $ router -> generate ( $ route ) , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; } ; $ arrMapper = array ( 'contao/confirm.php' => $ generate ( 'contao_backend_confirm' ) , 'contao/file.php' => $ generate ( 'contao_backend_file' ) , 'contao/help.php' => $ generate ( 'contao_backend_help' ) , 'contao/index.php' => $ generate ( 'contao_backend_login' ) , 'contao/main.php' => $ generate ( 'contao_backend' ) , 'contao/page.php' => $ generate ( 'contao_backend_page' ) , 'contao/password.php' => $ generate ( 'contao_backend_password' ) , 'contao/popup.php' => $ generate ( 'contao_backend_popup' ) , 'contao/preview.php' => $ generate ( 'contao_backend_preview' ) , 'contao/switch.php' => $ generate ( 'contao_backend_switch' ) ) ; return str_replace ( array_keys ( $ arrMapper ) , $ arrMapper , $ strContext ) ; }
3308	protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; }
11583	public function exchangeArray ( $ array ) { return $ this -> setId ( isset ( $ array [ 'id' ] ) ? $ array [ 'id' ] : null ) -> setAutenticacaoId ( $ array [ 'autenticacao_id' ] ) -> setValor ( $ array [ 'valor' ] ) -> setData ( isset ( $ array [ 'data' ] ) ? $ array [ 'data' ] : null ) ; }
1173	public function setDelegatedValidator ( DelegatedValidator $ validator ) { $ this -> validator = $ validator ; $ this -> rules -> setDelegatedValidator ( $ validator ) ; $ this -> messages -> setDelegatedValidator ( $ validator ) ; }
5487	public function submitImage ( SelectorInterface $ selector , $ x , $ y , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { $ encoding = $ this -> encode ( ) ; $ image -> write ( $ encoding , $ x , $ y ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
248	public function destroy ( ) { if ( $ this -> getIsActive ( ) ) { $ sessionId = session_id ( ) ; $ this -> close ( ) ; $ this -> setId ( $ sessionId ) ; $ this -> open ( ) ; session_unset ( ) ; session_destroy ( ) ; $ this -> setId ( $ sessionId ) ; } }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
10417	public function startPipeline ( $ prefix , $ target ) { if ( $ target === null ) { $ target = 'default' ; } $ this -> getPipelineFactory ( ) -> create ( $ prefix . $ target ) -> start ( ) ; }
1065	private function findConflict ( ValidationContext $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , array $ field1 , array $ field2 ) { [ $ parentType1 , $ ast1 , $ def1 ] = $ field1 ; [ $ parentType2 , $ ast2 , $ def2 ] = $ field2 ; $ areMutuallyExclusive = $ parentFieldsAreMutuallyExclusive || ( $ parentType1 !== $ parentType2 && $ parentType1 instanceof ObjectType && $ parentType2 instanceof ObjectType ) ; $ type1 = $ def1 === null ? null : $ def1 -> getType ( ) ; $ type2 = $ def2 === null ? null : $ def2 -> getType ( ) ; if ( ! $ areMutuallyExclusive ) { $ name1 = $ ast1 -> name -> value ; $ name2 = $ ast2 -> name -> value ; if ( $ name1 !== $ name2 ) { return [ [ $ responseName , sprintf ( '%s and %s are different fields' , $ name1 , $ name2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } if ( ! $ this -> sameArguments ( $ ast1 -> arguments ? : [ ] , $ ast2 -> arguments ? : [ ] ) ) { return [ [ $ responseName , 'they have differing arguments' ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } } if ( $ type1 && $ type2 && $ this -> doTypesConflict ( $ type1 , $ type2 ) ) { return [ [ $ responseName , sprintf ( 'they return conflicting types %s and %s' , $ type1 , $ type2 ) ] , [ $ ast1 ] , [ $ ast2 ] , ] ; } $ selectionSet1 = $ ast1 -> selectionSet ; $ selectionSet2 = $ ast2 -> selectionSet ; if ( $ selectionSet1 && $ selectionSet2 ) { $ conflicts = $ this -> findConflictsBetweenSubSelectionSets ( $ context , $ areMutuallyExclusive , Type :: getNamedType ( $ type1 ) , $ selectionSet1 , Type :: getNamedType ( $ type2 ) , $ selectionSet2 ) ; return $ this -> subfieldConflicts ( $ conflicts , $ responseName , $ ast1 , $ ast2 ) ; } return null ; }
5186	private function makeAttachmentObject ( string $ attachmentType , array $ attrReferences , array $ item ) { $ attrValues = [ ] ; foreach ( $ attrReferences as $ attrReference ) { $ attrValues [ $ attrReference ] = $ this -> getValue ( $ attrReference , $ item ) ; } switch ( $ attachmentType ) { case self :: JSON_PHOTO_FIELD : return $ this -> createPhoto ( $ attrValues [ 'photo_url' ] , $ attrValues [ 'photo_ratio' ] , '' , '' ) ; case self :: JSON_PAGE_FIELD : return $ this -> createPage ( $ attrValues [ 'page_title' ] , $ attrValues [ 'page_body' ] , $ attrValues [ 'page_source' ] , $ attrValues [ 'page_order' ] , $ attrValues [ 'page_cover' ] , $ attrValues [ 'page_lead' ] ) ; case self :: JSON_GALLERY_FIELD : return $ this -> createGallery ( $ attrValues [ 'gallery_body' ] , $ attrValues [ 'gallery_order' ] , $ attrValues [ 'gallery_photo' ] , $ attrValues [ 'gallery_source' ] , $ attrValues [ 'gallery_lead' ] ) ; case self :: JSON_VIDEO_FIELD : return $ this -> createVideo ( $ attrValues [ 'video_body' ] , $ attrValues [ 'video_source' ] , $ attrValues [ 'video_order' ] , $ attrValues [ 'video_cover' ] , $ attrValues [ 'video_lead' ] ) ; default : return null ; } }
11368	public static function deduplicate ( $ array ) { if ( empty ( $ array ) ) { return $ array ; } $ known = array ( ) ; foreach ( $ array as $ _index => $ entry ) { if ( is_array ( $ entry ) ) { foreach ( $ entry as $ i => $ _email ) { if ( ! in_array ( $ _email , $ known ) ) { $ known [ ] = $ _email ; } else { unset ( $ array [ $ _index ] ) ; } } } elseif ( is_string ( $ entry ) ) { if ( ! in_array ( $ entry , $ known ) ) { $ known [ ] = $ entry ; } else { unset ( $ array [ $ _index ] ) ; } } } return $ array ; }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
8919	protected function parseAuthority ( $ authority , & $ out ) { if ( ! empty ( $ authority ) ) { $ out [ 'id' ] = $ authority ; if ( preg_match ( '/\((.*?)\)(.*)/' , $ authority , $ matches ) ) { $ out [ 'vocabulary' ] = $ matches [ 1 ] ; $ out [ 'id' ] = $ matches [ 2 ] ; } } }
12507	public static function singleDocument ( $ document ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } $ query = "{" ; $ first = true ; foreach ( $ document as $ key => $ value ) { if ( ! $ first ) { $ query .= "," ; } $ query .= '"' . self :: escape_string ( $ key ) . '" : ' . json_encode ( $ value ) ; $ first = false ; } $ query .= '}' ; return $ query ; }
4631	protected function prepareRequestMethod ( ) { switch ( $ this -> command -> getMethod ( ) ) { case "POST" : $ this -> options [ CURLOPT_POST ] = 1 ; break ; case "PUT" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; case "DELETE" : $ this -> options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case "HEAD" : $ this -> options [ CURLOPT_NOBODY ] = 1 ; break ; default : $ this -> options [ CURLOPT_HTTPGET ] = 1 ; } return $ this ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
3273	public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { if ( $ cache -> contains ( $ key ) ) { return $ cache -> get ( $ key ) ; } } $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; $ data = false ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { $ data = $ this -> decodeData ( $ line -> getData ( ) ) ; break ; } } if ( $ cache && $ data !== false ) { $ cache -> set ( $ key , $ data ) ; } return $ data ; }
10867	public function getList ( ) : IDataSource { $ columns = array_map ( function ( $ item ) { return $ this -> tableName [ 0 ] . '.' . $ item ; } , $ this -> columns ) ; return $ this -> connection -> select ( $ columns ) -> from ( $ this -> tableIdentity ) -> as ( $ this -> tableName [ 0 ] ) ; }
5740	protected static function logDuration ( Request $ request , Response $ response , $ startTime ) { $ duration = microtime ( true ) - $ startTime ; $ tags = [ "status_code" => $ response -> getStatusCode ( ) ] ; if ( ! config ( 'datadog-helper.middleware_disable_url_tag' , false ) ) { $ tags [ "url" ] = $ request -> getSchemeAndHttpHost ( ) . $ request -> getRequestUri ( ) ; } Datadog :: timing ( 'request_time' , $ duration , 1 , $ tags ) ; }
4521	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; if ( $ user instanceof User ) { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) -> getType ( ) ) ; } else { $ this -> accessor -> setValue ( $ data , $ this -> property , $ user -> getIdentity ( ) ) ; } $ event -> setData ( $ data ) ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
11733	public function publish ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName ; $ pageCollectionSourceFile = $ baseDir . '/' . $ this -> username . '.json' ; $ pageCollectionTargetFile = $ baseDir . '/page.json' ; $ pageDir = $ baseDir . '/' . $ languageName ; $ pageSourceFile = $ pageDir . '/' . $ this -> username . '.json' ; $ pageTargetFile = $ pageDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHING , new PagePublishingEvent ( ) ) ; copy ( $ pageCollectionSourceFile , $ pageCollectionTargetFile ) ; copy ( $ pageSourceFile , $ pageTargetFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_PUBLISHED , new PagePublishedEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was published in production' , $ pageName , $ languageName ) ) ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
8114	public function addReviewNote ( Member $ reviewer , $ message ) { $ reviewLog = ContentReviewLog :: create ( ) ; $ reviewLog -> Note = $ message ; $ reviewLog -> ReviewerID = $ reviewer -> ID ; $ this -> owner -> ReviewLogs ( ) -> add ( $ reviewLog ) ; }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
3330	public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; }
11879	public static function getTrace ( ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Trace du contexte' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; $ nb = count ( $ trace ) ; for ( $ i = 1 ; $ i < $ nb ; $ i ++ ) { if ( $ i < $ nb - 1 ) { $ dump .= static :: getContext ( $ trace [ $ i ] , $ trace [ $ i + 1 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ $ i ] ) ; } } $ dump .= static :: getFooter ( ) ; return $ dump ; }
5924	public function setFilterItems ( array $ filterItems ) { $ this -> filterItems = [ ] ; foreach ( $ filterItems as $ item ) { $ this -> addFilterItem ( $ item ) ; } return $ this ; }
8160	public function confirm ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
1385	protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
5068	public function setOpt ( int $ option , string $ value ) : bool { return curl_share_setopt ( $ this -> sh , $ option , $ value ) ; }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
11060	public function value ( $ encoding = null ) { if ( $ this -> value !== null ) { if ( $ encoding === null ) { return mb_convert_encoding ( $ this -> value , $ this -> encoding , 'UTF-8' ) ; } else { $ encoding = $ this -> getRealEncoding ( $ encoding ) ; return mb_convert_encoding ( $ this -> value , $ encoding , 'UTF-8' ) ; } } }
12600	public static function copy ( $ src , $ dest , $ force = true ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( dirname ( $ dest ) ) ) { Folder :: create ( dirname ( $ dest ) ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> copy ( $ src , $ dest , $ force ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
6466	private static function createDefaultBoundary ( ) : string { try { $ string = random_bytes ( 16 ) ; $ string [ 6 ] = chr ( ord ( $ string [ 6 ] ) & 0x0f | 0x40 ) ; $ string [ 8 ] = chr ( ord ( $ string [ 8 ] ) & 0x3f | 0x80 ) ; return vsprintf ( '%s%s-%s-%s-%s-%s%s%s' , str_split ( bin2hex ( $ string ) , 4 ) ) ; } catch ( Exception $ ex ) { throw new RuntimeException ( 'Failed to generate random bytes' , 0 , $ ex ) ; } }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
12099	public function priceNetto ( $ brutto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ brutto ; } $ result = $ brutto / ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
3713	public function isNestedType ( ) { if ( ! isset ( $ this -> isNestedType ) ) { $ this -> isNestedType = in_array ( 'MetaModels\Filter\Setting\IWithChildren' , class_implements ( $ this -> typeClass , true ) ) ; } return $ this -> isNestedType ; }
3997	protected function getItem ( $ metaModelIdOrName , $ mixDataId , $ intIdRenderSetting , $ strOutput = null ) { $ objMetaModel = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( $ objMetaModel == null ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'html5' ; } $ objMetaModelList = new ItemList ( ) ; $ objMetaModelList -> setServiceContainer ( $ this -> getServiceContainer ( ) ) -> setMetaModel ( $ objMetaModel -> get ( 'id' ) , $ intIdRenderSetting ) -> overrideOutputFormat ( $ strOutput ) ; $ arrIds = StringUtil :: trimsplit ( ',' , $ mixDataId ) ; foreach ( $ arrIds as $ intKey => $ intId ) { if ( ! $ this -> isPublishedItem ( $ objMetaModel , $ intId ) ) { unset ( $ arrIds [ $ intKey ] ) ; } } if ( count ( $ arrIds ) < 1 ) { return '' ; } $ objMetaModelList -> addFilterRule ( new StaticIdList ( $ arrIds ) ) ; return $ objMetaModelList -> render ( false , $ this ) ; }
2110	public function setRelatedRecords ( array $ arrRelated ) { $ objDatabase = Database :: getInstance ( ) ; $ objCount = $ objDatabase -> prepare ( "SELECT COUNT(*) AS count FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; if ( $ objCount -> count > 0 ) { throw new \ LogicException ( sprintf ( 'Token "%s" already contains related records' , $ this -> token ) ) ; } foreach ( $ arrRelated as $ strTable => $ arrIds ) { foreach ( $ arrIds as $ intId ) { $ objDatabase -> prepare ( "INSERT INTO tl_opt_in_related (pid, relTable, relId) VALUES (?, ?, ?)" ) -> execute ( $ this -> id , $ strTable , $ intId ) ; } } }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
8368	private static function validateConfig ( array $ config ) { if ( isset ( $ config [ 'name' ] ) === false ) { throw new BadUse ( 'there\'s no name in mapping configuration' ) ; } if ( isset ( $ config [ 'schema' ] ) === false ) { throw new BadUse ( 'there\'s no schema in mapping configuration' ) ; } if ( isset ( $ config [ 'provider' ] ) === false ) { throw new BadUse ( 'there\'s no provider in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] ) === false ) { throw new BadUse ( 'there\'s no models in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'path' ] ) === false ) { throw new BadUse ( 'there\'s no models.path in mapping configuration' ) ; } if ( isset ( $ config [ 'models' ] [ 'namespace' ] ) === false ) { throw new BadUse ( 'there\'s no models.namespace in mapping configuration' ) ; } }
12752	public function sendConfirmationMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> confirmationSubject , 'confirmation' , [ 'user' => $ user , 'token' => $ token ] ) ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
4487	public function send ( $ message , string $ endpointArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $endpointArn" , [ 'Message' => $ message , ] ) ; return ; } if ( ! ( $ message instanceof Message ) ) { $ message = new Message ( $ message ) ; } $ this -> sns -> publish ( [ 'TargetArn' => $ endpointArn , 'Message' => $ this -> encodeMessage ( $ message ) , 'MessageStructure' => 'json' , ] ) ; }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
940	public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; }
226	protected function asCurrencyStringFallback ( $ value , $ currency = null ) { if ( $ currency === null ) { if ( $ this -> currencyCode === null ) { throw new InvalidConfigException ( 'The default currency code for the formatter is not defined.' ) ; } $ currency = $ this -> currencyCode ; } return $ currency . ' ' . $ this -> asDecimalStringFallback ( $ value , 2 ) ; }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
173	private static function firstWildcardInPattern ( $ pattern ) { $ wildcards = [ '*' , '?' , '[' , '\\' ] ; $ wildcardSearch = function ( $ r , $ c ) use ( $ pattern ) { $ p = strpos ( $ pattern , $ c ) ; return $ r === false ? $ p : ( $ p === false ? $ r : min ( $ r , $ p ) ) ; } ; return array_reduce ( $ wildcards , $ wildcardSearch , false ) ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
1569	public function getResourceIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ resourceId = $ this -> getResourceId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getResourceType ( ) , $ resourceId ) ; }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
5707	public function getButtonLink ( ) { $ link = Controller :: join_links ( 'customaction' , $ this -> actionName ) ; return $ this -> gridFieldRequest -> Link ( $ link ) ; }
4693	public function orderBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'order' ] = $ args ; return $ this ; }
12186	public function getCompanionNiceId ( $ queryRole ) { $ companionRoleType = $ this -> companionRoleType ( $ queryRole ) ; if ( empty ( $ companionRoleType ) ) { return false ; } return implode ( ':' , [ $ this -> companionRole ( $ queryRole ) , $ companionRoleType -> systemId ] ) ; }
4581	private function getProperties ( Encryptable $ model ) : array { $ properties = [ ] ; $ reflection = new ReflectionObject ( $ model ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Encrypt :: class ) ; if ( ! $ annotation ) { continue ; } if ( null !== $ annotation -> applicable && ! $ this -> expressionLanguage -> evaluate ( $ annotation -> applicable , [ 'object' => $ model ] ) ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
6044	public function view ( $ sessionId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaId' => $ mediaId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/view' , $ parameters , true ) ; return $ result ; }
11042	function store_text ( & $ elts , & $ i , $ ptype , $ ntext , $ ctext ) { if ( $ ntext == 1 && $ ptype != _ETS_ROOT ) { $ elts [ _ETS_TEXT . ':' . $ i ] = $ ctext ; } }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
5597	protected function createErrorQueue ( ) { $ context = SimpleTest :: getContext ( ) ; $ test = $ this -> getTestCase ( ) ; $ queue = $ context -> get ( 'SimpleErrorQueue' ) ; $ queue -> setTestCase ( $ test ) ; return $ queue ; }
4605	public function setEntityUuid ( ? string $ entityUuid ) { if ( null !== $ entityUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ entityUuid ) ) { throw new InvalidArgumentException ( 'Entity uuid is not valid.' ) ; } } $ this -> entityUuid = $ entityUuid ; return $ this ; }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
11438	public function getDefault ( $ name ) { return isset ( $ this -> options [ 'defaults' ] [ $ name ] ) ? $ this -> options [ 'defaults' ] [ $ name ] : null ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
4922	public function removeRegion ( $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { unset ( $ this -> matrix [ $ region ] ) ; } return $ this ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
6125	public function setRoles ( array $ roles ) { $ this -> roles = [ ] ; foreach ( $ roles as $ item ) { $ this -> addRole ( $ item ) ; } return $ this ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
8422	public function addNoticeBoardItem ( ProductionMenuCollectionEvent $ event ) : void { $ menu = $ event -> getMenu ( ) ; $ group = $ event -> getGroup ( ) ; $ board = $ this -> factory -> createItem ( 'menu_item.notice_board' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'icon' => 'comment' , 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN , ] , ] ) ; $ menu -> addChild ( $ board ) ; if ( $ this -> auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ group ) ) { $ posts = $ this -> factory -> createItem ( 'menu_item.notice_board_posts' , [ 'route' => 'bkstg_board_show' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ posts ) ; $ archive = $ this -> factory -> createItem ( 'menu_item.notice_board_archive' , [ 'route' => 'bkstg_board_archive' , 'routeParameters' => [ 'production_slug' => $ group -> getSlug ( ) ] , 'extras' => [ 'translation_domain' => BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ] , ] ) ; $ board -> addChild ( $ archive ) ; } }
7677	function TbsSearchInFiles ( $ files , $ str , $ returnFirstFound = true ) { $ keys_ok = array ( ) ; $ keys_todo = array ( ) ; $ idx_keys = array ( ) ; foreach ( $ files as $ k => $ f ) { $ idx = $ this -> FileGetIdx ( $ f ) ; if ( $ idx !== false ) { $ keys_todo [ $ k ] = $ idx ; $ idx_keys [ $ idx ] = $ k ; } } if ( ( $ this -> TbsCurrIdx !== false ) && isset ( $ idx_keys [ $ this -> TbsCurrIdx ] ) ) { $ key = $ idx_keys [ $ this -> TbsCurrIdx ] ; $ p = strpos ( $ this -> TBS -> Source , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ this -> TbsCurrIdx , 'src' => & $ this -> TBS -> Source , 'pos' => $ p , 'curr' => true ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } foreach ( $ this -> TbsStoreLst as $ idx => $ s ) { if ( ( $ idx !== $ this -> TbsCurrIdx ) && isset ( $ idx_keys [ $ idx ] ) ) { $ key = $ idx_keys [ $ idx ] ; $ p = strpos ( $ s [ 'src' ] , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => & $ s [ 'src' ] , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } unset ( $ keys_todo [ $ key ] ) ; } } foreach ( $ keys_todo as $ key => $ idx ) { $ txt = $ this -> FileRead ( $ idx ) ; $ p = strpos ( $ txt , $ str ) ; if ( $ p !== false ) { $ keys_ok [ ] = array ( 'key' => $ key , 'idx' => $ idx , 'src' => $ txt , 'pos' => $ p , 'curr' => false ) ; if ( $ returnFirstFound ) return $ keys_ok [ 0 ] ; } } if ( $ returnFirstFound ) { return array ( 'key' => false , 'idx' => false , 'src' => false , 'pos' => false , 'curr' => false ) ; } else { return $ keys_ok ; } }
10268	function createMailing ( $ name , $ subject , $ deprecatedParameter = false , $ type = "regular" ) { $ queryParameters = array ( 'name' => urlencode ( $ name ) , 'subject' => urlencode ( $ subject ) , 'type' => urlencode ( $ type ) , ) ; return $ this -> post ( 'mailings' , "" , $ queryParameters ) ; }
6842	public function produce ( $ key , $ params = array ( ) , $ enable_reflect = true ) { if ( isset ( $ this -> data [ $ key ] ) ) return $ this -> data [ $ key ] ; if ( isset ( $ this -> caches [ $ key ] ) ) return $ this -> caches [ $ key ] ; if ( isset ( $ this -> objects [ $ key ] ) ) { $ obj = $ this -> get ( $ key ) ; $ concrete = $ obj [ self :: INDEX_CONCRETE ] ; } else { if ( $ this -> MUST_REG || ! $ enable_reflect ) { throw new InjectorException ( "$key not registered" ) ; } else { $ concrete = $ key ; $ not_reg = true ; } } $ result = $ this -> build ( $ concrete , $ params ) ; if ( $ not_reg === true || $ obj [ self :: INDEX_CACHED ] === true ) { $ this -> caches [ $ key ] = $ result ; } return $ result ; }
6439	public function getUserProfile ( ) { $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ this -> access_token [ 'oauth_token' ] , $ this -> access_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ user = $ connection -> get ( "account/verify_credentials" ) ; return array ( 'userid' => $ user -> id , 'name' => $ user -> screen_name , 'imageurl' => $ user -> profile_image_url ) ; }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
6340	public function SearchForm ( ) { if ( count ( Searchable :: config ( ) -> objects ) ) { $ searchText = "" ; if ( $ this -> owner -> request && $ this -> owner -> request -> getVar ( 'Search' ) ) { $ searchText = $ this -> owner -> request -> getVar ( 'Search' ) ; } $ fields = FieldList :: create ( TextField :: create ( 'Search' , false , $ searchText ) -> setAttribute ( "placeholder" , _t ( 'Searchable.Search' , 'Search' ) ) ) ; $ actions = FieldList :: create ( FormAction :: create ( 'results' , _t ( 'Searchable.Go' , 'Go' ) ) ) ; $ template_class = Searchable :: config ( ) -> template_class ; $ results_page = Injector :: inst ( ) -> create ( $ template_class ) ; $ form = Form :: create ( $ this -> owner , 'SearchForm' , $ fields , $ actions ) -> setFormMethod ( 'get' ) -> setFormAction ( $ results_page -> Link ( ) ) -> setTemplate ( 'ilateral\SilverStripe\Searchable\Includes\SearchForm' ) -> disableSecurityToken ( ) ; $ this -> owner -> extend ( "updateSearchForm" , $ form ) ; return $ form ; } }
12492	public static function orderBy ( $ field , $ order ) { if ( ! $ order ) { $ order = 'DESC' ; } $ order = strtoupper ( $ order ) ; if ( ! ( $ order == 'ASC' || $ order == 'DESC' ) ) { throw new ClusterpointException ( "\"->order()\" function: ordering should be DESC or ASC." , 9002 ) ; } if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->order()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field} {$order}" ; }
184	public function init ( ) { parent :: init ( ) ; $ this -> cache = $ this -> enabled ? Instance :: ensure ( $ this -> cache , 'yii\caching\CacheInterface' ) : null ; if ( $ this -> cache instanceof CacheInterface && $ this -> getCachedContent ( ) === false ) { $ this -> getView ( ) -> pushDynamicContent ( $ this ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; } }
629	public function queryScalar ( ) { $ result = $ this -> queryInternal ( 'fetchColumn' , 0 ) ; if ( is_resource ( $ result ) && get_resource_type ( $ result ) === 'stream' ) { return stream_get_contents ( $ result ) ; } return $ result ; }
4682	private static function formatTime ( float $ value , $ format ) : string { switch ( $ format ) { case static :: FORMAT_PRECISE : return ( string ) ( $ value * 1000 ) ; case static :: FORMAT_MILLISECONDS : return ( string ) round ( $ value * 1000 , 2 ) ; case static :: FORMAT_SECONDS : return ( string ) round ( $ value , 3 ) ; default : return ( string ) ( $ value * 1000 ) ; } }
5788	public function runExecute ( bool $ alterBooleanArgs = false ) { if ( ! isset ( $ this -> sql ) ) { $ this -> setSql ( ) ; } if ( isset ( $ this -> primaryKeyName ) ) { return parent :: executeWithReturnField ( $ this -> primaryKeyName , $ alterBooleanArgs ) ; } else { return parent :: execute ( $ alterBooleanArgs ) ; } }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
10503	private function setParameter ( $ subject , string $ key , $ value ) { $ setter = 'set' . $ this -> snakeToCamelCase ( $ key ) ; if ( is_callable ( [ $ subject , $ setter ] ) ) { call_user_func ( [ $ subject , $ setter ] , $ value ) ; } }
12778	public function getRefreshInstructions ( ) { $ i = [ ] ; $ i [ 'type' ] = 'widget' ; $ i [ 'systemId' ] = $ this -> collectorItem -> systemId ; $ i [ 'recreateParams' ] = $ this -> recreateParams ; if ( $ this -> section ) { $ i [ 'section' ] = $ this -> section -> systemId ; } return $ i ; }
6722	public function fetchAccessToken ( $ code ) { $ this -> validateTokenParams ( ) ; $ this -> oauth2 -> tokenUrl = $ this -> tokenUrl ; $ this -> oauth2 -> clientId = $ this -> clientId ; $ this -> oauth2 -> clientSecret = $ this -> clientSecret ; try { $ response = $ this -> oauth2 -> fetchAccessToken ( $ code ) ; } catch ( Exception $ ex ) { throw new Oauth2ClientException ( $ ex -> getMessage ( ) ) ; } return $ this -> handleTokenResponse ( $ response ) ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
11615	public function delete ( $ account ) { $ accessTokenField = sprintf ( '%s=%s' , $ this -> accessToken -> getQueryName ( ) , $ this -> accessToken -> getToken ( ) ) ; $ url = sprintf ( self :: API_DELETE . '?%s&kf_account=%s' , $ accessTokenField , $ account ) ; $ contents = $ this -> getHttp ( ) -> parseJSON ( file_get_contents ( $ url ) ) ; $ this -> checkAndThrow ( $ contents ) ; return new Collection ( $ contents ) ; }
6179	private function loadAllColumnsSchema ( ) { $ schema = $ this -> tableSchema [ 'fields' ] ; foreach ( $ this -> request [ 'leftJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } foreach ( $ this -> request [ 'rightJoin' ] as $ value ) { $ schemaTable = $ this -> schema -> getSchemaTable ( $ value [ 'table' ] ) ; $ schema = array_merge ( $ schema , $ schemaTable [ 'fields' ] ) ; } $ this -> request [ 'allColumnsSchema' ] = $ schema ; }
5665	private function innerHtml ( $ node ) { $ raw = '' ; if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ raw .= $ child -> value ; } } return $ this -> stripGuards ( $ raw ) ; }
4891	protected function getTarget ( $ generateInstance = true ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ this -> getGenerator ( ) ; $ target = null ; if ( array_key_exists ( 'target' , $ this -> options ) ) { $ target = $ this -> options [ 'target' ] ; if ( is_string ( $ target ) ) { if ( $ serviceLocator -> has ( $ target ) ) { $ target = $ serviceLocator -> get ( $ target ) ; if ( $ generateInstance ) { $ target = get_class ( $ target ) ; } } else { if ( $ generateInstance ) { $ target = new $ target ; } } } } return $ target ; }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
5733	public function getLeagueTeams ( int $ leagueID , array $ filter = [ 'stage' => '' ] ) { $ leagueTeams = $ this -> run ( "v2/competitions/{$leagueID}/teams" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueTeams -> teams ) ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
10035	function unsubscribeContactByExternalId ( $ externalId , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedExternalId = utf8_encode ( $ externalId ) ; return $ this -> delete ( "contacts/externalid/${encodedExternalId}/unsubscribe" , $ queryParameters ) ; }
10183	private function getAllCacheKeys ( ) { $ keys = [ ] ; foreach ( $ this -> getCoordinates ( ) as $ coordinate ) { $ keys [ ] = $ this -> cachePrefix . $ coordinate ; } return $ keys ; }
11507	public function serve ( ) { Log :: debug ( 'Request received:' , [ 'Method' => $ this -> request -> getMethod ( ) , 'URI' => $ this -> request -> getRequestUri ( ) , 'Query' => $ this -> request -> getQueryString ( ) , 'Protocal' => $ this -> request -> server -> get ( 'SERVER_PROTOCOL' ) , 'Content' => $ this -> request -> getContent ( ) , ] ) ; $ this -> validate ( $ this -> token ) ; if ( $ str = $ this -> request -> get ( 'echostr' ) ) { Log :: debug ( "Output 'echostr' is '$str'." ) ; return new Response ( $ str ) ; } $ result = $ this -> handleRequest ( ) ; $ response = $ this -> buildResponse ( $ result [ 'to' ] , $ result [ 'from' ] , $ result [ 'response' ] ) ; Log :: debug ( 'Server response created:' , compact ( 'response' ) ) ; return new Response ( $ response ) ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
9035	public function persist ( TopicInterface $ thread ) { if ( $ thread -> getId ( ) > 0 ) { $ this -> update ( $ thread , null , null , new TopicHydrator ( ) ) ; } else { $ this -> insert ( $ thread , null , new TopicHydrator ( ) ) ; } return $ thread ; }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
9413	public static function instance ( array $ server ) { $ secure = isset ( $ server [ 'HTTPS' ] ) ? $ server [ 'HTTPS' ] : 'off' ; $ http = $ secure === 'off' ? 'http' : 'https' ; $ url = $ http . '://' . $ server [ 'SERVER_NAME' ] ; $ url .= ( string ) $ server [ 'SERVER_PORT' ] ; return new Uri ( $ url . $ server [ 'REQUEST_URI' ] ) ; }
11889	public function paginate ( ) { $ model = $ this -> model ; if ( property_exists ( $ model , 'order' ) ) { $ paginator = $ model :: orderBy ( $ model :: $ order , $ model :: $ sort ) -> paginate ( $ model :: $ paginate , $ model :: $ index ) ; } else { $ paginator = $ model :: paginate ( $ model :: $ paginate , $ model :: $ index ) ; } if ( ! $ this -> isPageInRange ( $ paginator ) && ! $ this -> isFirstPage ( $ paginator ) ) { throw new NotFoundHttpException ( ) ; } if ( $ paginator -> getTotal ( ) ) { $ this -> paginateLinks = $ paginator -> links ( ) ; } return $ paginator ; }
4564	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof NoPermissionsException ) { return ; } $ response = new JsonResponse ( [ ] ) ; $ event -> setResponse ( $ response ) ; }
4181	public function getResources ( ) { return $ this -> resources ? : $ this -> resources = Resource :: instance ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
6271	protected function throwException ( $ msg ) { if ( $ this -> handle ) { fclose ( $ this -> handle ) ; unlink ( $ this -> tmpFileName ) ; } throw new Exception ( $ msg ) ; }
1433	public static function dasherize ( $ value ) { if ( isset ( self :: $ dasherized [ $ value ] ) ) { return self :: $ dasherized [ $ value ] ; } return self :: $ dasherized [ $ value ] = str_replace ( '_' , '-' , self :: decamelize ( $ value ) ) ; }
12945	public function getTagValues ( $ asString = false ) { if ( $ this -> _tagsList === null && ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> _tagsList = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsList = array_unique ( $ relation -> select ( 'text' ) -> column ( ) ) ; } } return $ asString === true ? implode ( ',' , $ this -> _tagsList ) : $ this -> _tagsList ; }
9771	function most ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , lessThanOrEqual ( $ value ) ) ; }
11528	public function registerCustomHelpers ( ) { foreach ( glob ( app_path ( $ this -> namespace . '/*' ) ) as $ helper ) { $ helperName = last ( explode ( '/' , $ helper ) ) ; if ( ! in_array ( $ helperName , $ this -> customExclude ) ) { if ( in_array ( '*' , $ this -> customInclude ) || in_array ( $ helperName , $ this -> customInclude ) ) { require_once $ helper ; } } } }
3491	public function withHeader ( string $ name , string $ value ) : Request { $ cloned = clone $ this ; $ cloned -> headers [ $ name ] = $ value ; return $ cloned ; }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
4099	public function setIndex ( $ index ) { if ( is_array ( $ index ) ) $ index = implode ( "," , array_filter ( $ index ) ) ; $ this -> index = $ index ; $ this -> transport -> setIndex ( $ index ) ; return $ this ; }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
8016	public function close ( ) { $ uri = $ this -> current ( ) -> getNextUri ( ) ; if ( ! is_null ( $ uri ) ) { $ this -> client -> deleteAsync ( $ uri ) -> wait ( ) ; } $ this -> closed = true ; }
9014	public function longtext ( string $ charset = null ) : self { $ this -> type = 'longtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
6277	protected function readInt32 ( $ pos = 0 ) { static $ lookups ; if ( ! $ lookups ) { $ lookups = [ ] ; for ( $ i = 1 ; $ i < 256 ; $ i ++ ) { $ lookups [ chr ( $ i ) ] = $ i ; } } $ buf = $ this -> read ( $ pos , 4 ) ; $ rv = 0 ; if ( $ buf [ 0 ] !== "\x0" ) { $ rv = $ lookups [ $ buf [ 0 ] ] ; } if ( $ buf [ 1 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 1 ] ] << 8 ) ; } if ( $ buf [ 2 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 2 ] ] << 16 ) ; } if ( $ buf [ 3 ] !== "\x0" ) { $ rv |= ( $ lookups [ $ buf [ 3 ] ] << 24 ) ; } return $ rv ; }
12972	protected function createEntityManager ( ) { if ( $ cache = $ this -> getConfig ( 'cache_driver' , 'array' ) ) { $ cache = 'doctrine.cache.' . $ cache ; $ cache = DiC :: resolve ( $ cache ) ; } if ( $ this -> getConfig ( 'auto_config' , false ) ) { $ dev = $ this -> getConfig ( 'dev_mode' , \ Fuel :: $ env === \ Fuel :: DEVELOPMENT ) ; $ proxy_dir = $ this -> getConfig ( 'proxy_dir' ) ; $ config = Setup :: createConfiguration ( $ dev , $ proxy_dir , $ cache ) ; } else { $ config = new Configuration ; $ config -> setProxyDir ( $ this -> getConfig ( 'proxy_dir' ) ) ; $ config -> setProxyNamespace ( $ this -> getConfig ( 'proxy_namespace' ) ) ; $ config -> setAutoGenerateProxyClasses ( $ this -> getConfig ( 'auto_generate_proxy_classes' , false ) ) ; if ( $ cache ) { $ config -> setMetadataCacheImpl ( $ cache ) ; $ config -> setQueryCacheImpl ( $ cache ) ; $ config -> setResultCacheImpl ( $ cache ) ; } } $ config -> newDefaultAnnotationDriver ( array ( ) ) ; $ this -> registerMapping ( $ config ) ; $ conn = DiC :: multiton ( 'dbal' , $ this -> getConfig ( 'dbal' ) , [ $ this -> getConfig ( 'dbal' ) ] ) ; $ evm = $ conn -> getEventManager ( ) ; $ this -> registerBehaviors ( $ evm , $ config ) ; return $ this -> entityManager = EntityManager :: create ( $ conn , $ config , $ evm ) ; }
837	public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4547	public function check ( $ alias = null ) { if ( null === $ alias ) { $ statuses = new Statuses ; $ statuses -> setHealthy ( true ) ; foreach ( $ this -> checkCollection as $ check ) { $ status = $ check -> execute ( ) ; $ statuses -> getCollection ( ) -> add ( $ status ) ; if ( ! $ status -> getHealthy ( ) ) { $ statuses -> setHealthy ( false ) ; } } return $ statuses ; } else { $ check = $ this -> checkCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ check ) { throw new InvalidAliasException ( 'Check alias does not exist.' ) ; } $ status = $ check -> execute ( ) ; return $ status ; } }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
11570	final public static function load ( & $ object , & $ params ) { $ attachments = static :: getInstance ( ) ; $ attachment = & $ object ; if ( ! is_a ( $ attachment , Entity :: class ) ) { $ attachment = $ attachments -> loadObjectByURI ( $ attachment ) ; } if ( $ attachment -> getObjectType ( ) !== "attachment" ) return false ; $ fileId = $ attachment -> getObjectType ( ) ; $ filePath = FSPATH . DS . $ attachment -> getPropertyValue ( "attachment_src" ) ; $ contentType = $ attachment -> getPropertyValue ( "attachment_type" ) ; static :: place ( $ fileId , $ filePath , $ contentType , $ params ) ; }
3310	public function getAccessToken ( $ forceRefresh = false ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ cached = $ this -> getCache ( ) -> fetch ( $ cacheKey ) ; if ( empty ( $ cached ) || $ forceRefresh ) { $ token = $ this -> getTokenFormApi ( ) ; $ this -> getCache ( ) -> save ( $ cacheKey , $ token [ $ this -> tokenSucessKey ] , $ token [ 'expires_in' ] ) ; return $ token [ $ this -> tokenSucessKey ] ; } return $ cached ; }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
2527	protected function getEndpointFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , self :: XPATH_ENDPOINT ) ; }
12709	public static function parse ( string $ word ) : array { $ word = ltrim ( rtrim ( trim ( $ word ) , '}' ) , '{' ) ; if ( $ separatorPosition = strpos ( $ word , '=' ) ) { $ key = substr ( $ word , 0 , $ separatorPosition ) ; $ defaultValue = substr ( $ word , $ separatorPosition + 1 ) ; return [ $ key , $ defaultValue ] ; } return [ $ word , null ] ; }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
8169	public static function register ( $ prepend = false ) { @ trigger_error ( 'Using Twig_Autoloader is deprecated since version 1.21. Use Composer instead.' , E_USER_DEPRECATED ) ; if ( PHP_VERSION_ID < 50300 ) { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) ) ; } else { spl_autoload_register ( array ( __CLASS__ , 'autoload' ) , true , $ prepend ) ; } }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
3168	private function getCurrentThemeId ( ) { $ themeService = $ this -> getServiceLocator ( ) -> get ( ThemeService :: SERVICE_ID ) ; return $ themeService -> getTheme ( ) -> getId ( ) ; }
9008	private function prepareColumn ( Row $ row ) : string { $ nullable = $ row -> Null === 'YES' ; if ( $ row -> Default === null && ! $ nullable ) { $ default = ' NOT null' ; } elseif ( $ row -> Default === null && $ nullable ) { $ default = ' DEFAULT null' ; } else { $ default = ( $ nullable ? '' : ' NOT null' ) . " DEFAULT '{$row->Default}'" ; } if ( ! empty ( $ row -> Collation ) ) { $ collate = ' COLLATE ' . $ row -> Collation ; } else { $ collate = '' ; } if ( $ row -> Extra === 'auto_increment' ) { $ autoIncrement = ' AUTO_INCREMENT' ; } else { $ autoIncrement = '' ; } return "`{$row->Field}` " . $ row -> Type . $ collate . $ default . $ autoIncrement ; }
2370	public static function highlight ( $ strString , $ strPhrase , $ strOpeningTag = '<strong>' , $ strClosingTag = '</strong>' ) { if ( $ strString == '' || $ strPhrase == '' ) { return $ strString ; } return preg_replace ( '/(' . preg_quote ( $ strPhrase , '/' ) . ')/i' , $ strOpeningTag . '\\1' . $ strClosingTag , $ strString ) ; }
12168	public function createPropertyValuesProxyTable ( $ group , $ dropExisting = true ) { $ group = strtolower ( $ group ) ; if ( ! empty ( $ group ) ) : $ this -> database -> query ( "DROP TABLE IF EXISTS `?{$group}_property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?{$group}_property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_insert` BEFORE INSERT ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_update` BEFORE UPDATE ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "ALTER TABLE `?{$group}_property_values` ADD CONSTRAINT `{$group}_property_values_ibfk_1` FOREIGN KEY (`object_id`) REFERENCES `?objects` (`object_id`), ADD CONSTRAINT `{$group}_property_values_ibfk_2` FOREIGN KEY (`property_id`) REFERENCES `?properties` (`property_id`) ON DELETE CASCADE;" ) ; endif ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
10290	protected function storeLastRun ( ) { if ( ! @ file_put_contents ( $ this -> lockDir . '/lastRun' , time ( ) ) ) { $ this -> logger -> log ( 'Failure storing last run time: ' . ( isset ( $ php_errormsg ) ? $ php_errormsg : 'Unknown error - enable the track_errors ini directive.' ) , Logger :: ERROR ) ; return ; } $ this -> logger -> log ( 'Stored last run time.' , Logger :: INFO ) ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
11413	public function batchUntagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UNTAG , $ params ] ) ; }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
2842	public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
3305	public function getFixedFormat ( $ images , array $ options = [ ] ) { $ images = is_array ( $ images ) ? $ images [ 0 ] : $ images ; if ( FileConverter :: isUrl ( $ images ) ) { throw new RuntimeException ( "Aliyun ocr not support online picture." ) ; } if ( $ this -> simpleRequestBody ) { return [ 'image' => FileConverter :: toBase64Encode ( $ images ) , 'configure' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ; } return [ 'inputs' => [ [ 'image' => [ 'dataType' => 50 , 'dataValue' => FileConverter :: toBase64Encode ( $ images ) ] , 'configure' => [ 'dataType' => 50 , 'dataValue' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ] ] ] ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
12337	public function confirmEmailAction ( ) { $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ; if ( $ token ) { $ identity = $ this -> getUserService ( ) -> confirmEmail ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/confirm-email' ) ; return $ viewModel ; } } return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; }
200	private function checkTargetRelationExistence ( $ model , $ attribute ) { $ exists = false ; $ relationQuery = $ model -> { 'get' . ucfirst ( $ this -> targetRelation ) } ( ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ relationQuery ) ; } elseif ( $ this -> filter !== null ) { $ relationQuery -> andWhere ( $ this -> filter ) ; } if ( $ this -> forceMasterDb && method_exists ( $ model :: getDb ( ) , 'useMaster' ) ) { $ model :: getDb ( ) -> useMaster ( function ( ) use ( $ relationQuery , & $ exists ) { $ exists = $ relationQuery -> exists ( ) ; } ) ; } else { $ exists = $ relationQuery -> exists ( ) ; } if ( ! $ exists ) { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
7962	public function canChangeLns ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeLns ; }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
11899	public function getDuration ( ) { $ ended = microtime ( true ) ; if ( $ this -> ended ) { $ ended = strtotime ( $ this -> ended ) ; } $ started = strtotime ( $ this -> started ) ; return Date :: niceDuration ( $ ended - $ started ) ; }
4169	public function tokenizePackageInfo ( ) { $ info = explode ( ':' , $ this -> argument ( 'package' ) ) ; return [ 'name' => $ info [ 0 ] , 'version' => ( count ( $ info ) > 1 ) ? last ( $ info ) : null , ] ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
9859	public function getStream ( $ stream ) { if ( $ stream === null ) { return null ; } $ streamData = '' ; if ( $ this -> props [ $ stream ] [ 'size' ] < self :: SMALL_BLOCK_THRESHOLD ) { $ rootdata = $ this -> _readData ( $ this -> props [ $ this -> rootentry ] [ 'startBlock' ] ) ; $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = $ block * self :: SMALL_BLOCK_SIZE ; $ streamData .= substr ( $ rootdata , $ pos , self :: SMALL_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> smallBlockChain , $ block * 4 ) ; } return $ streamData ; } $ numBlocks = $ this -> props [ $ stream ] [ 'size' ] / self :: BIG_BLOCK_SIZE ; if ( $ this -> props [ $ stream ] [ 'size' ] % self :: BIG_BLOCK_SIZE != 0 ) { ++ $ numBlocks ; } if ( $ numBlocks == 0 ) { return '' ; } $ block = $ this -> props [ $ stream ] [ 'startBlock' ] ; while ( $ block != - 2 ) { $ pos = ( $ block + 1 ) * self :: BIG_BLOCK_SIZE ; $ streamData .= substr ( $ this -> data , $ pos , self :: BIG_BLOCK_SIZE ) ; $ block = self :: getInt4d ( $ this -> bigBlockChain , $ block * 4 ) ; } return $ streamData ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
936	public static function getNameForId ( $ id ) { if ( CT :: has ( $ id ) ) { return CT :: getName ( $ id ) ; } $ name = token_name ( $ id ) ; return 'UNKNOWN' === $ name ? null : $ name ; }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
6150	public function setJsonBody ( $ data ) { $ this -> addHeader ( "Content-Type: application/json; charset=utf8" ) ; $ this -> setBody ( json_encode ( $ data , JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ) ) ; return $ this ; }
3467	public function patch ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: patch ( $ route ) ) ; }
641	public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2902	public function downloadAction ( ) { $ type = $ this -> getRequest ( ) -> getParam ( 'type' , 'xml' ) ; $ configNode = Mage :: app ( ) -> getConfig ( ) -> getNode ( ) ; switch ( $ type ) { case 'txt' ; $ this -> downloadAsText ( $ configNode ) ; break ; case 'xml' : default : $ this -> downloadAsXml ( $ configNode ) ; } }
10499	public function gte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value >= $ value ) { return true ; } return false ; }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
1830	public function refresh ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ res = Database :: getInstance ( ) -> prepare ( "SELECT * FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) ; $ this -> setRow ( $ res -> row ( ) ) ; }
296	public function isAttributeChanged ( $ name , $ identical = true ) { if ( isset ( $ this -> _attributes [ $ name ] , $ this -> _oldAttributes [ $ name ] ) ) { if ( $ identical ) { return $ this -> _attributes [ $ name ] !== $ this -> _oldAttributes [ $ name ] ; } return $ this -> _attributes [ $ name ] != $ this -> _oldAttributes [ $ name ] ; } return isset ( $ this -> _attributes [ $ name ] ) || isset ( $ this -> _oldAttributes [ $ name ] ) ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
6167	protected function writePerformance ( $ time ) { $ ms = round ( $ time * 1000 ) ; foreach ( self :: $ performanceThresholds as $ colour => $ threshold ) { if ( $ ms > $ threshold ) { break ; } } $ this -> writeWithColor ( $ colour , " ($ms ms)" ) ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
1490	public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
4993	public function getActiveFormActual ( $ setDefault = true ) { $ key = null ; if ( ! empty ( $ this -> activeForms ) ) { $ key = $ this -> activeForms [ 0 ] ; } if ( ! isset ( $ key ) && $ setDefault ) { $ formsAvailable = array_keys ( $ this -> forms ) ; $ key = array_shift ( $ formsAvailable ) ; } return $ key ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
11382	public function pipe ( $ stage ) { $ pipeline = new self ( $ this -> container , $ this -> stages ) ; $ this -> handleStage ( $ pipeline -> stages , $ stage ) ; return $ pipeline ; }
2252	protected function redirectToFrontendPage ( $ intPage , $ strArticle = null , $ blnReturn = false ) { if ( ( $ intPage = ( int ) $ intPage ) <= 0 ) { return '' ; } $ objPage = PageModel :: findWithDetails ( $ intPage ) ; if ( $ objPage === null ) { return '' ; } $ strParams = null ; if ( $ strArticle !== null && ( $ objArticle = ArticleModel :: findByAlias ( $ strArticle ) ) !== null ) { $ strParams = '/articles/' . ( ( $ objArticle -> inColumn != 'main' ) ? $ objArticle -> inColumn . ':' : '' ) . $ strArticle ; } $ strUrl = $ objPage -> getFrontendUrl ( $ strParams ) ; if ( strncmp ( $ strUrl , 'http://' , 7 ) !== 0 && strncmp ( $ strUrl , 'https://' , 8 ) !== 0 ) { $ strUrl = Environment :: get ( 'base' ) . $ strUrl ; } if ( ! $ blnReturn ) { $ this -> redirect ( $ strUrl ) ; } return $ strUrl ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
5243	public function transform ( string $ target ) { if ( $ this -> filesystem -> isFile ( $ target ) ) { $ this -> doTransform ( $ target ) ; return ; } $ files = $ this -> filesystem -> allFiles ( $ target ) ; array_walk ( $ files , function ( SplFileInfo $ file ) { $ this -> doTransform ( $ file -> getRealPath ( ) ) ; } ) ; }
8798	public function registerDirectives ( BladeCompiler $ blade ) { $ keywords = [ "namespace" , "use" , ] ; foreach ( $ keywords as $ keyword ) { $ blade -> directive ( $ keyword , function ( $ parameter ) use ( $ keyword ) { $ parameter = trim ( $ parameter , "()" ) ; return "<?php {$keyword} {$parameter} ?>" ; } ) ; } $ assetify = function ( $ file , $ type ) { $ file = trim ( $ file , "()" ) ; if ( in_array ( substr ( $ file , 0 , 1 ) , [ "'" , '"' ] , true ) ) { $ file = trim ( $ file , "'\"" ) ; } else { return "{{ {$file} }}" ; } if ( substr ( $ file , 0 , 1 ) !== "/" ) { $ file = "/{$type}/{$file}" ; } if ( substr ( $ file , ( strlen ( $ type ) + 1 ) * - 1 ) !== ".{$type}" ) { $ file .= ".{$type}" ; } return $ file ; } ; $ blade -> directive ( "css" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "css" ) ; return '<link rel="stylesheet" type="text/css" href="' . $ file . '"/>' ; } ) ; $ blade -> directive ( "js" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "js" ) ; return '<script type="text/javascript" src="' . $ file . '"></script>' ; } ) ; }
12834	private function generatePureCreatorMethod ( ServiceDefinition $ service ) : string { $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get service {$service->getId()} (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = new $classNormalized({$this->buildInjectionParameters($this->container, $service->getInjection()->getCreatorInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
11808	public function paginate ( $ perPage = null , $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) && ( $ columns !== null ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( $ columnsPassed ) { return $ query -> paginate ( $ perPage , $ columns ) ; } return $ query -> paginate ( $ perPage , $ this -> getQueryColumns ( ) ) ; }
99	public function addPsr4 ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr4 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr4 ) ; } else { $ this -> fallbackDirsPsr4 = array_merge ( $ this -> fallbackDirsPsr4 , ( array ) $ paths ) ; } } elseif ( ! isset ( $ this -> prefixDirsPsr4 [ $ prefix ] ) ) { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } elseif ( $ prepend ) { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixDirsPsr4 [ $ prefix ] ) ; } else { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( $ this -> prefixDirsPsr4 [ $ prefix ] , ( array ) $ paths ) ; } }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
11156	public function getArrayValue ( array $ values ) { if ( empty ( $ values ) ) { throw new InvalidArgumentException ( 'Empty parameter' ) ; } $ values = \ array_values ( $ values ) ; return $ values [ $ this -> generator -> getInt ( 0 , count ( $ values ) - 1 ) ] ; }
18	private function getPackageTime ( PackageInterface $ package ) { if ( ! function_exists ( 'proc_open' ) ) { return null ; } $ path = realpath ( $ this -> installationManager -> getInstallPath ( $ package ) ) ; $ sourceType = $ package -> getSourceType ( ) ; $ datetime = null ; if ( $ path && in_array ( $ sourceType , array ( 'git' , 'hg' ) ) ) { $ sourceRef = $ package -> getSourceReference ( ) ? : $ package -> getDistReference ( ) ; switch ( $ sourceType ) { case 'git' : GitUtil :: cleanEnv ( ) ; if ( 0 === $ this -> process -> execute ( 'git log -n1 --pretty=%ct ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*\d+\s*$}' , $ output ) ) { $ datetime = new \ DateTime ( '@' . trim ( $ output ) , new \ DateTimeZone ( 'UTC' ) ) ; } break ; case 'hg' : if ( 0 === $ this -> process -> execute ( 'hg log --template "{date|hgdate}" -r ' . ProcessExecutor :: escape ( $ sourceRef ) , $ output , $ path ) && preg_match ( '{^\s*(\d+)\s*}' , $ output , $ match ) ) { $ datetime = new \ DateTime ( '@' . $ match [ 1 ] , new \ DateTimeZone ( 'UTC' ) ) ; } break ; } } return $ datetime ? $ datetime -> format ( DATE_RFC3339 ) : null ; }
4702	protected function runHelp ( InputInterface $ input , OutputInterface $ output ) { $ help = $ this -> getApplication ( ) -> find ( 'help' ) ; $ help -> setCommand ( $ this ) ; $ help -> run ( $ input , $ output ) ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
3225	function createFolder ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/fileops/create_folder" , array ( "root" => "auto" , "path" => $ path , ) ) ; if ( $ response -> statusCode === 403 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
8198	public function next ( ) { if ( ! isset ( $ this -> tokens [ ++ $ this -> current ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current - 1 ] ; }
7285	protected function initializeInvoiceSubject ( ) { $ this -> invoiceTotal = 0 ; $ this -> creditTotal = 0 ; $ this -> invoiceState = InvoiceStates :: STATE_NEW ; $ this -> invoices = new ArrayCollection ( ) ; }
1914	protected function generateHashes ( $ sum ) { $ time = ( int ) round ( time ( ) / 60 / 30 ) ; return array_map ( function ( $ hashTime ) use ( $ sum ) { return hash_hmac ( 'sha256' , $ sum . "\0" . $ hashTime , System :: getContainer ( ) -> getParameter ( 'kernel.secret' ) ) ; } , array ( $ time , $ time - 1 ) ) ; }
5094	public function executeIterator ( ) { $ result = $ this -> execute ( ) ; if ( ! $ result ) throw new MySqlException ( 'Could not execute multiset query!' ) ; while ( true ) { yield new StatementResult ( $ result ) ; if ( ! $ result -> nextRowset ( ) ) { $ this -> checkForError ( $ result ) ; break ; } } }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
250	public function setUseCookies ( $ value ) { $ this -> freeze ( ) ; if ( $ value === false ) { ini_set ( 'session.use_cookies' , '0' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } elseif ( $ value === true ) { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '1' ) ; } else { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } $ this -> unfreeze ( ) ; }
8810	public function destroy ( ) { foreach ( $ _COOKIE as $ key => $ value ) { setcookie ( $ key , null , - 1 , '/' ) ; unset ( $ _COOKIE [ $ key ] ) ; } return ; }
3792	private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; }
2508	public function createRequest ( $ messageName , RequestOptionsInterface $ params ) { $ this -> checkMessageIsInWsdl ( $ messageName ) ; $ builder = $ this -> findBuilderForMessage ( $ messageName ) ; if ( $ builder instanceof ConvertInterface ) { return $ builder -> convert ( $ params , $ this -> getActiveVersionFor ( $ messageName ) ) ; } else { throw new \ RuntimeException ( 'No builder found for message ' . $ messageName ) ; } }
10163	private function readSheetLayout ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ sz = self :: getInt4d ( $ recordData , 12 ) ; switch ( $ sz ) { case 0x14 : $ colorIndex = self :: getUInt2d ( $ recordData , 16 ) ; $ color = Xls \ Color :: map ( $ colorIndex , $ this -> palette , $ this -> version ) ; $ this -> phpSheet -> getTabColor ( ) -> setRGB ( $ color [ 'rgb' ] ) ; break ; case 0x28 : return ; break ; } } }
3863	private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; }
12017	public function calculateRequestFilename ( Request $ request ) { $ string = $ request -> getUri ( ) ; $ filename = parse_url ( $ string , PHP_URL_HOST ) ; $ filename .= '_' . parse_url ( $ string , PHP_URL_PATH ) ; $ headers = $ request -> getAllHeaders ( ) ; ksort ( $ headers ) ; foreach ( $ headers as $ header => $ values ) { $ string .= $ header ; foreach ( $ values as $ value ) { $ string .= $ value ; } } $ filename .= '_' . sha1 ( $ string ) ; if ( strpos ( $ filename , '_' ) === 0 ) { $ filename = substr ( $ filename , 1 ) ; } return $ this -> cacheDirectory . '/' . $ filename . '.cache' ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
1535	protected function fill ( $ record , ResourceObject $ resource , EncodingParametersInterface $ parameters ) { $ this -> fillAttributes ( $ record , $ resource -> getAttributes ( ) ) ; $ this -> fillRelationships ( $ record , $ resource -> getRelationships ( ) , $ parameters ) ; }
4765	protected function validateRegistrationOptin ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_userregistration' ) ; $ registrationOption = ( int ) $ this -> getRequestParameter ( 'option' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinUserRegistration' ) && ( 3 == $ registrationOption ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
3214	function disableAccessToken ( ) { $ response = $ this -> doPost ( $ this -> apiHost , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
3269	public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } }
11565	private function getApp ( ) { if ( is_null ( $ this -> app ) ) { $ this -> app = \ Concrete \ Core \ Support \ Facade \ Application :: getFacadeApplication ( ) ; } return $ this -> app ; }
3050	protected function initStorage ( ) { $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ this -> getTestExecutionUri ( ) ) ; $ testResource = new \ core_kernel_classes_Resource ( $ this -> getTestDefinitionUri ( ) ) ; $ sessionManager = new \ taoQtiTest_helpers_SessionManager ( $ resultStore , $ testResource ) ; $ seeker = new BinaryAssessmentTestSeeker ( $ this -> getTestDefinition ( ) ) ; $ userUri = $ this -> getUserUri ( ) ; $ config = \ common_ext_ExtensionsManager :: singleton ( ) -> getExtensionById ( 'taoQtiTest' ) -> getConfig ( 'testRunner' ) ; $ storageClassName = $ config [ 'test-session-storage' ] ; $ this -> storage = new $ storageClassName ( $ sessionManager , $ seeker , $ userUri ) ; $ this -> sessionManager = $ sessionManager ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
2577	protected function hasPricingOption ( $ optionKey , $ priceOptions ) { $ found = false ; foreach ( $ priceOptions as $ pog ) { if ( $ pog -> pricingOptionKey -> pricingOptionKey === $ optionKey ) { $ found = true ; } } return $ found ; }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
9818	private function polynomialRegression ( $ order , $ yValues , $ xValues ) { $ x_sum = array_sum ( $ xValues ) ; $ y_sum = array_sum ( $ yValues ) ; $ xx_sum = $ xy_sum = 0 ; for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ xy_sum += $ xValues [ $ i ] * $ yValues [ $ i ] ; $ xx_sum += $ xValues [ $ i ] * $ xValues [ $ i ] ; $ yy_sum += $ yValues [ $ i ] * $ yValues [ $ i ] ; } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { for ( $ j = 0 ; $ j <= $ order ; ++ $ j ) { $ A [ $ i ] [ $ j ] = pow ( $ xValues [ $ i ] , $ j ) ; } } for ( $ i = 0 ; $ i < $ this -> valueCount ; ++ $ i ) { $ B [ $ i ] = [ $ yValues [ $ i ] ] ; } $ matrixA = new Matrix ( $ A ) ; $ matrixB = new Matrix ( $ B ) ; $ C = $ matrixA -> solve ( $ matrixB ) ; $ coefficients = [ ] ; for ( $ i = 0 ; $ i < $ C -> getRowDimension ( ) ; ++ $ i ) { $ r = $ C -> get ( $ i , 0 ) ; if ( abs ( $ r ) <= pow ( 10 , - 9 ) ) { $ r = 0 ; } $ coefficients [ ] = $ r ; } $ this -> intersect = array_shift ( $ coefficients ) ; $ this -> slope = $ coefficients ; $ this -> calculateGoodnessOfFit ( $ x_sum , $ y_sum , $ xx_sum , $ yy_sum , $ xy_sum ) ; foreach ( $ this -> xValues as $ xKey => $ xValue ) { $ this -> yBestFitValues [ $ xKey ] = $ this -> getValueOfYForX ( $ xValue ) ; } }
480	public function alterColumn ( $ table , $ column , $ type ) { $ time = $ this -> beginCommand ( "alter column $column in table $table to $type" ) ; $ this -> db -> createCommand ( ) -> alterColumn ( $ table , $ column , $ type ) -> execute ( ) ; if ( $ type instanceof ColumnSchemaBuilder && $ type -> comment !== null ) { $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ type -> comment ) -> execute ( ) ; } $ this -> endCommand ( $ time ) ; }
9055	public function addColumnToRename ( string $ name , Column $ column ) : self { $ this -> oldColumns [ $ name ] = $ column ; return $ this ; }
10008	public function disconnectWorksheets ( ) { $ worksheet = null ; foreach ( $ this -> workSheetCollection as $ k => & $ worksheet ) { $ worksheet -> disconnectCells ( ) ; $ this -> workSheetCollection [ $ k ] = null ; } unset ( $ worksheet ) ; $ this -> workSheetCollection = [ ] ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
5891	public static function permissionType ( $ type ) { if ( $ type == TeamSpeak3 :: PERM_TYPE_SERVERGROUP ) { return "Server Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CLIENT ) { return "Client" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNEL ) { return "Channel" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELGROUP ) { return "Channel Group" ; } if ( $ type == TeamSpeak3 :: PERM_TYPE_CHANNELCLIENT ) { return "Channel Client" ; } return "Unknown" ; }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
5103	public static function appendSet ( $ values , $ forceExist = false ) { if ( $ forceExist && ! $ values ) throw new SquidException ( 'SET clause must be present for this type of command!' ) ; return Assembly :: append ( 'SET' , $ values , ', ' ) ; }
1737	public function loadFromPlugins ( ) : RouteCollection { $ collection = array_reduce ( $ this -> pluginLoader -> getInstancesOf ( PluginLoader :: ROUTING_PLUGINS , true ) , function ( RouteCollection $ collection , RoutingPluginInterface $ plugin ) : RouteCollection { $ routes = $ plugin -> getRouteCollection ( $ this -> loader -> getResolver ( ) , $ this -> kernel ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } return $ collection ; } , new RouteCollection ( ) ) ; if ( file_exists ( $ configFile = $ this -> rootDir . '/app/config/routing.yml' ) ) { $ routes = $ this -> loader -> getResolver ( ) -> resolve ( $ configFile ) -> load ( $ configFile ) ; if ( $ routes instanceof RouteCollection ) { $ collection -> addCollection ( $ routes ) ; } } foreach ( [ 'contao_frontend' , 'contao_index' , 'contao_root' , 'contao_catch_all' ] as $ name ) { if ( $ route = $ collection -> get ( $ name ) ) { $ collection -> add ( $ name , $ route ) ; } } return $ collection ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
8970	protected function toJson ( RateInterface $ rate ) { return json_encode ( array ( 'sourceName' => $ rate -> getSourceName ( ) , 'value' => $ rate -> getValue ( ) , 'currencyCode' => $ rate -> getCurrencyCode ( ) , 'rateType' => $ rate -> getRateType ( ) , 'date' => $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) , 'baseCurrencyCode' => $ rate -> getBaseCurrencyCode ( ) , 'createdAt' => $ rate -> getCreatedAt ( ) -> format ( \ DateTime :: ATOM ) , 'modifiedAt' => $ rate -> getModifiedAt ( ) -> format ( \ DateTime :: ATOM ) , ) ) ; }
9524	public function deploy ( ) { $ pullRequest = getenv ( 'TRAVIS_PULL_REQUEST' ) ; $ branch = getenv ( 'TRAVIS_BRANCH' ) ; if ( ( int ) $ pullRequest >= 1 ) { die ( 'Not deploying pull requests.' . PHP_EOL ) ; } if ( ! array_key_exists ( $ branch , $ this -> branches ) ) { die ( 'Branch ' . $ branch . ' has no environment to deploy to.' . PHP_EOL ) ; } $ environment = $ this -> branches [ $ branch ] ; echo 'Downloading Deployer.phar...' . PHP_EOL ; passthru ( 'wget http://deployer.org/deployer.phar' ) ; echo 'Deploying...' . PHP_EOL ; $ deployCommand = 'php deployer.phar deploy' ; $ deployCommand .= ' ' . $ environment ; $ deployCommand .= $ this -> verbose ? ' -vvv' : '' ; passthru ( $ deployCommand ) ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
8415	public function beginTransaction ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } ++ $ this -> transactionLevel ; if ( $ this -> transactionLevel == 1 ) { return $ this -> providerDatabase -> beginTransaction ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> savePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . ( $ this -> transactionLevel - 1 ) ) ; }
8511	public function listInboundShipmentItems ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItems' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
6272	public static function open ( $ fileName ) { return self :: haveExtension ( ) ? new Reader \ DBA ( $ fileName ) : new Reader \ PHP ( $ fileName ) ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
11634	public function bindPage ( array $ deviceIdentifier , array $ pageIds ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'page_ids' => $ pageIds , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDPAGE , $ params ] ) ; }
5896	public function retrieveImageTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ImageTemplate ( $ result ) ; return $ result ; }
5616	public function compareChildren ( $ a , $ b ) { if ( $ this -> _children [ $ a ] -> getTotalSize ( ) > $ this -> _children [ $ b ] -> getTotalSize ( ) ) { $ node_a = $ this -> _children [ $ a ] ; $ node_b = $ this -> _children [ $ b ] ; $ this -> _children [ $ a ] = $ node_b ; $ this -> _children [ $ b ] = $ node_a ; } }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
2108	public static function findByRelatedTableAndIds ( $ strTable , array $ arrIds , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE $t.id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")) ORDER BY $t.createdOn DESC" ) -> execute ( $ strTable , $ arrIds ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ arrModels = array ( ) ; $ objRegistry = Registry :: getInstance ( ) ; while ( $ objResult -> next ( ) ) { if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { $ arrModels [ ] = $ objOptIn ; } else { $ arrModels [ ] = new static ( $ objResult -> row ( ) ) ; } } return static :: createCollection ( $ arrModels , $ t ) ; }
10298	private function writeLegend ( XMLWriter $ objWriter , Legend $ legend = null ) { if ( $ legend === null ) { return ; } $ objWriter -> startElement ( 'c:legend' ) ; $ objWriter -> startElement ( 'c:legendPos' ) ; $ objWriter -> writeAttribute ( 'val' , $ legend -> getPosition ( ) ) ; $ objWriter -> endElement ( ) ; $ this -> writeLayout ( $ objWriter , $ legend -> getLayout ( ) ) ; $ objWriter -> startElement ( 'c:overlay' ) ; $ objWriter -> writeAttribute ( 'val' , ( $ legend -> getOverlay ( ) ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:txPr' ) ; $ objWriter -> startElement ( 'a:bodyPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:lstStyle' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:p' ) ; $ objWriter -> startElement ( 'a:pPr' ) ; $ objWriter -> writeAttribute ( 'rtl' , 0 ) ; $ objWriter -> startElement ( 'a:defRPr' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'a:endParaRPr' ) ; $ objWriter -> writeAttribute ( 'lang' , 'en-US' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
5402	public function isExpired ( $ now ) { if ( ! $ this -> expiry ) { return true ; } if ( is_string ( $ now ) ) { $ now = strtotime ( $ now ) ; } return ( $ this -> expiry < $ now ) ; }
8732	public function challenge ( string $ hydroAddressId ) : ChallengeResponse { try { $ response = $ this -> callHydroApi ( 'post' , 'challenge' , [ 'json' => [ 'hydro_address_id' => $ hydroAddressId ] ] ) ; $ data = \ GuzzleHttp \ json_decode ( $ response -> getBody ( ) -> getContents ( ) , true , 512 , JSON_BIGINT_AS_STRING ) ; } catch ( RuntimeException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( InvalidArgumentException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( GuzzleException $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } catch ( ApiRequestFailed $ e ) { throw ChallengeFailed :: forHydroAddressId ( $ hydroAddressId , $ e -> getMessage ( ) ) ; } return new ChallengeResponse ( $ data [ 'amount' ] , ( int ) $ data [ 'challenge' ] , ( int ) $ data [ 'partner_id' ] , $ data [ 'transaction_hash' ] ) ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
7829	public function getLeftBordersWith ( $ border ) { $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; return str_repeat ( "{$border}{$space}" , $ this -> nesting ) ; }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
4308	public function trace ( ) { if ( ! $ this -> cfg [ 'collect' ] ) { return ; } $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'caption' => 'trace' , 'channel' => $ this -> cfg [ 'channel' ] , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ backtrace = $ this -> errorHandler -> backtrace ( ) ; for ( $ i = 1 , $ count = \ count ( $ backtrace ) - 1 ; $ i < $ count ; $ i ++ ) { $ frame = $ backtrace [ $ i ] ; $ function = isset ( $ frame [ 'function' ] ) ? $ frame [ 'function' ] : '' ; if ( ! \ preg_match ( '/^' . \ preg_quote ( __CLASS__ ) . '(::|->)/' , $ function ) ) { break ; } } $ backtrace = \ array_slice ( $ backtrace , $ i - 1 ) ; unset ( $ backtrace [ 0 ] [ 'function' ] ) ; $ this -> appendLog ( 'trace' , array ( $ backtrace ) , $ meta ) ; }
10090	public function getUrl ( $ identifier , $ options = array ( ) ) { if ( ! $ identifier ) { $ identifier = null ; } else { $ identifier = $ this -> normalizeIdentifier ( $ identifier ) ; } $ options = $ this -> checkOptionsArray ( $ options ) ; $ https = $ this -> https ; if ( isset ( $ options [ 'https' ] ) ) { $ https = ( bool ) $ options [ 'https' ] ; } $ algorithm = $ this -> algorithm ; if ( isset ( $ options [ 'algorithm' ] ) ) { $ algorithm = $ this -> processAlgorithm ( $ options [ 'algorithm' ] ) ; } $ default = $ this -> default ; if ( isset ( $ options [ 'default' ] ) ) { $ default = $ this -> processDefault ( $ options [ 'default' ] ) ; } $ size = $ this -> size ; if ( isset ( $ options [ 'size' ] ) ) { $ size = $ this -> processSize ( $ options [ 'size' ] ) ; } $ identifierHash = $ this -> identifierHash ( $ identifier , $ algorithm ) ; $ domain = $ this -> domainGet ( $ identifier ) ; $ service = $ this -> srvGet ( $ domain , $ https ) ; $ protocol = $ https ? 'https' : 'http' ; $ params = array ( ) ; if ( $ size !== null ) { $ params [ 'size' ] = $ size ; } if ( $ default !== null ) { $ params [ 'default' ] = $ default ; } $ paramString = '' ; if ( count ( $ params ) > 0 ) { $ paramString = '?' . http_build_query ( $ params ) ; } $ url = $ protocol . '://' . $ service . '/avatar/' . $ identifierHash . $ paramString ; return $ url ; }
9696	function createTransactions ( $ transactions , $ release = true , $ ignoreInvalidEvents = false ) { $ queryParameters = array ( 'release' => ( $ release == true ) ? 'true' : 'false' , 'ignore_invalid_transactions' => ( $ ignoreInvalidEvents == true ) ? 'true' : 'false' ) ; $ data = JSONSerializer :: json_encode ( $ transactions ) ; $ result = $ this -> post ( "transactions" , $ data , $ queryParameters , "application/json" , 'com_maileon_api_transactions_ProcessingReports' ) ; return $ result ; }
7782	public function init ( ) { $ this -> actionRoute = Url :: toRoute ( $ this -> actionRoute ) ; $ this -> name = Yii :: $ app -> session -> get ( 'timezone' ) ; if ( $ this -> name == null ) { $ this -> registerTimezoneScript ( $ this -> actionRoute ) ; $ this -> name = date_default_timezone_get ( ) ; } Yii :: $ app -> setTimeZone ( $ this -> name ) ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
157	public function where ( $ condition , $ params = [ ] ) { $ this -> where = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
12692	public function synchronize ( Page $ page , array $ pages ) { if ( ! $ this -> configurationHandler -> isTheme ( ) ) { return ; } foreach ( $ pages as $ pageValues ) { $ tokens = explode ( "_" , $ pageValues [ "seo" ] [ 0 ] [ "language" ] ) ; $ pageOptions = array ( 'page' => $ pageValues [ "name" ] , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ page -> render ( $ this -> configurationHandler -> siteDir ( ) , $ pageOptions ) ; $ this -> saveTemplateSlots ( $ page -> getPageSlots ( ) , $ pageValues [ "template" ] ) ; } $ this -> saveTemplateSlots ( $ page -> getCommonSlots ( ) , 'base' ) ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
3019	public function getTaggedPosts ( $ tag , $ options = null ) { if ( ! $ options ) { $ options = array ( ) ; } $ options [ 'tag' ] = $ tag ; return $ this -> getRequest ( 'v2/tagged' , $ options , true ) ; }
4020	protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } if ( ( $ arrField [ 'inputType' ] == 'checkbox' ) && isset ( $ varInput [ $ strRow ] [ $ strKey ] ) ) { $ _POST [ $ objWidget -> name ] = $ varValue ; } $ objWidget -> validate ( ) ; $ varValue = $ objWidget -> value ; $ rgxp = $ arrField [ 'eval' ] [ 'rgxp' ] ; if ( ( $ rgxp == 'date' || $ rgxp == 'time' || $ rgxp == 'datim' ) && $ varValue != '' ) { $ objDate = new Date ( $ varValue , $ GLOBALS [ 'TL_CONFIG' ] [ $ rgxp . 'Format' ] ) ; $ varValue = $ objDate -> tstamp ; } $ varValue = $ this -> handleSaveCallback ( $ arrField , $ objWidget , $ varValue ) ; $ varInput [ $ strRow ] [ $ strKey ] = $ varValue ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } return true ; }
8592	public function setFilterOptions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FilterOptions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10139	private function writeCFHeader ( ) { $ record = 0x01B0 ; $ length = 0x0016 ; $ numColumnMin = null ; $ numColumnMax = null ; $ numRowMin = null ; $ numRowMax = null ; $ arrConditional = [ ] ; foreach ( $ this -> phpSheet -> getConditionalStylesCollection ( ) as $ cellCoordinate => $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditional ) { if ( $ conditional -> getConditionType ( ) == Conditional :: CONDITION_EXPRESSION || $ conditional -> getConditionType ( ) == Conditional :: CONDITION_CELLIS ) { if ( ! in_array ( $ conditional -> getHashCode ( ) , $ arrConditional ) ) { $ arrConditional [ ] = $ conditional -> getHashCode ( ) ; } $ arrCoord = Coordinate :: coordinateFromString ( $ cellCoordinate ) ; if ( ! is_numeric ( $ arrCoord [ 0 ] ) ) { $ arrCoord [ 0 ] = Coordinate :: columnIndexFromString ( $ arrCoord [ 0 ] ) ; } if ( $ numColumnMin === null || ( $ numColumnMin > $ arrCoord [ 0 ] ) ) { $ numColumnMin = $ arrCoord [ 0 ] ; } if ( $ numColumnMax === null || ( $ numColumnMax < $ arrCoord [ 0 ] ) ) { $ numColumnMax = $ arrCoord [ 0 ] ; } if ( $ numRowMin === null || ( $ numRowMin > $ arrCoord [ 1 ] ) ) { $ numRowMin = $ arrCoord [ 1 ] ; } if ( $ numRowMax === null || ( $ numRowMax < $ arrCoord [ 1 ] ) ) { $ numRowMax = $ arrCoord [ 1 ] ; } } } } $ needRedraw = 1 ; $ cellRange = pack ( 'vvvv' , $ numRowMin - 1 , $ numRowMax - 1 , $ numColumnMin - 1 , $ numColumnMax - 1 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , count ( $ arrConditional ) , $ needRedraw ) ; $ data .= $ cellRange ; $ data .= pack ( 'v' , 0x0001 ) ; $ data .= $ cellRange ; $ this -> append ( $ header . $ data ) ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
10617	protected function setEtag ( Response $ response ) { if ( ! $ response -> getEtag ( ) ) { $ response -> setEtag ( $ this -> key_builder -> getEtag ( $ response ) ) ; } return $ this ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
10356	public function lockOut ( ) { $ this -> resetAttempts ( ) ; $ this -> cache -> add ( $ this -> lockOutKey , $ this -> getDelay ( ) + time ( ) , $ this -> getExpiry ( ) ) ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
2779	public function git ( string $ commandLine , ? string $ cwd = null ) : string { $ command = new GitCommand ( $ commandLine ) ; $ command -> executeRaw ( is_string ( $ commandLine ) ) ; $ command -> setDirectory ( $ cwd ) ; return $ this -> run ( $ command ) ; }
12240	public function getElementsByClassName ( $ class ) { if ( strpos ( $ class , '"' ) !== false || strpos ( $ class , "'" ) !== false ) { return array ( ) ; } $ xpath = './/*[contains(concat(" ", @class, " "), " ' . htmlspecialchars ( $ class ) . ' ")]' ; return $ this -> xpath ( $ xpath ) ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
9480	public function setErrorCode ( $ errorCode ) { $ this -> error = $ this -> config [ $ errorCode ] ; $ this -> errorCode = $ errorCode ; return $ this ; }
4265	private function sortSubscribers ( $ eventName ) { \ krsort ( $ this -> subscribers [ $ eventName ] ) ; $ this -> sorted [ $ eventName ] = array ( ) ; foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ subscriber ) { if ( $ this -> isClosureFactory ( $ subscriber ) ) { $ subscriber [ 0 ] = $ subscriber [ 0 ] ( ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ $ k ] = $ subscriber ; } $ this -> sorted [ $ eventName ] [ ] = $ subscriber ; } } }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
2503	public static function loadMessagesAndVersions ( $ wsdls ) { $ msgAndVer = [ ] ; foreach ( $ wsdls as $ wsdl ) { $ wsdlIdentifier = self :: makeWsdlIdentifier ( $ wsdl ) ; self :: $ wsdlIds [ $ wsdlIdentifier ] = $ wsdl ; self :: loadWsdlXpath ( $ wsdl , $ wsdlIdentifier ) ; $ operations = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_ALL_OPERATIONS ) ; if ( $ operations -> length === 0 ) { $ imports = self :: $ wsdlDomXpath [ $ wsdlIdentifier ] -> query ( self :: XPATH_IMPORTS ) ; $ operations = [ ] ; foreach ( $ imports as $ import ) { if ( ! empty ( $ import -> value ) ) { $ tmpMsg = self :: getMessagesAndVersionsFromImportedWsdl ( $ import -> value , $ wsdl , $ wsdlIdentifier ) ; foreach ( $ tmpMsg as $ msgName => $ msgInfo ) { $ msgAndVer [ $ msgName ] = $ msgInfo ; } } } } $ msgAndVer = array_merge ( $ msgAndVer , self :: loopOperationsWithQuery ( $ operations , self :: XPATH_VERSION_FOR_OPERATION , $ wsdlIdentifier , self :: $ wsdlDomXpath [ $ wsdlIdentifier ] ) ) ; } return $ msgAndVer ; }
645	public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; }
8831	protected function getCheckboxCheckedState ( $ name , $ value , $ checked ) { $ posted = $ this -> getValueAttribute ( $ name , $ checked ) ; if ( is_array ( $ posted ) ) { return in_array ( $ value , $ posted ) ; } else { return ( bool ) $ posted ; } }
12306	protected function __apiUpdateStrict ( string $ id ) { HCLanguages :: where ( 'id' , $ id ) -> update ( $ this -> getStrictRequestParameters ( ) ) ; return $ this -> apiShow ( $ id ) ; }
5339	public function setMode ( $ mode ) { if ( ! in_array ( $ mode , $ this -> acceptedModes ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid mode: [%s]' , $ mode ) ) ; } $ this -> mode = $ mode ; }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
6638	protected function initContainer ( $ module ) { $ map = [ ] ; $ defaultClassMap = [ 'AddPermissionForm' => AddPermissionForm :: class , 'AssignRoleForm' => AssignRoleForm :: class , 'LoginForm' => LoginForm :: class , 'RequestPasswordResetForm' => RequestPasswordResetForm :: class , 'ResetPasswordForm' => ResetPasswordForm :: class , 'AuthAssignment' => AuthAssignment :: class , 'AuthItem' => AuthItem :: class , 'AuthItemChild' => AuthItemChild :: class , 'AuthRule' => AuthRule :: class , 'Message' => Message :: class , 'SourceMessage' => SourceMessage :: class , 'User' => User :: class , 'MessageQuery' => MessageQuery :: class , 'SourceMessageQuery' => SourceMessageQuery :: class , 'UserQuery' => UserQuery :: class , 'SourceMessageSearch' => SourceMessageSearch :: class , 'UserSearch' => UserSearch :: class , ] ; $ routes = [ 'mrstroz\\wavecms\\forms' => [ 'AddPermissionForm' , 'AssignRoleForm' , 'LoginForm' , 'RequestPasswordResetForm' , 'ResetPasswordForm' , ] , 'mrstroz\\wavecms\\models' => [ 'AuthAssignment' , 'AuthItem' , 'AuthItemChild' , 'AuthRule' , 'Message' , 'SourceMessage' , 'User' , ] , 'mrstroz\\wavecms\\models\\query' => [ 'MessageQuery' , 'SourceMessageQuery' , 'UserQuery' , ] , 'mrstroz\\wavecms\\models\\search' => [ 'SourceMessageSearch' , 'UserSearch' , ] ] ; $ mapping = array_merge ( $ defaultClassMap , $ module -> classMap ) ; foreach ( $ mapping as $ name => $ definition ) { $ map [ $ this -> getContainerRoute ( $ routes , $ name ) . "\\$name" ] = $ definition ; } $ di = Yii :: $ container ; foreach ( $ map as $ class => $ definition ) { if ( ! $ di -> has ( $ class ) ) { $ di -> set ( $ class , $ definition ) ; } } }
7040	protected function hasDifferentCurrencies ( PaymentSubjectInterface $ subject ) { $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getCurrency ( ) -> getCode ( ) !== $ currency ) { return true ; } } return false ; }
4103	public function search ( $ query , array $ options = array ( ) ) { $ start = microtime ( true ) ; $ result = $ this -> transport -> search ( $ query , $ options ) ; $ result [ 'time' ] = microtime ( true ) - $ start ; return $ result ; }
455	public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; }
8572	private function _convertListRecommendations ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetRecommendationCategory ( ) ) { $ parameters [ 'RecommendationCategory' ] = $ request -> getRecommendationCategory ( ) ; } if ( $ request -> isSetCategoryQueryList ( ) ) { $ parameters [ 'CategoryQueryList' ] = $ request -> getCategoryQueryList ( ) ; } return $ parameters ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
9608	public function angleBetween ( self $ b ) { $ denominator = $ this -> length ( ) * $ b -> length ( ) ; if ( $ denominator == 0 ) { throw new Exception ( 'Cannot divide by zero' ) ; } return acos ( $ this -> dotProduct ( $ b ) / $ denominator ) ; }
5903	public function retrieveCurrentUser ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/me' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
11096	public static function sendHipChatMessage ( $ room , $ token , $ text , $ notify = true , $ format = 'text' ) { $ session = curl_init ( ) ; curl_setopt ( $ session , CURLOPT_URL , 'https://api.hipchat.com/v2/room/' . $ room . '/notification?auth_token=' . $ token ) ; curl_setopt ( $ session , CURLOPT_POST , 1 ) ; curl_setopt ( $ session , CURLOPT_POSTFIELDS , http_build_query ( [ 'message' => $ text , 'message_format' => $ format , 'notify' => $ notify , ] ) ) ; curl_setopt ( $ session , CURLOPT_RETURNTRANSFER , true ) ; curl_exec ( $ session ) ; curl_close ( $ session ) ; }
9366	public function divide ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } if ( $ z -> is_zero ) { throw new \ InvalidArgumentException ( 'Cannot divide by zero!' ) ; } $ divisor = pow ( $ z -> re , 2 ) + pow ( $ z -> im , 2 ) ; $ r = ( $ this -> float_r * $ z -> re ) + ( $ this -> float_i * $ z -> im ) ; $ i = ( $ this -> float_i * $ z -> re ) - ( $ this -> float_r * $ z -> im ) ; $ r = $ r / $ divisor ; $ i = $ i / $ divisor ; return new self ( $ r , $ i ) ; }
11871	public function buildForm ( FormBuilderInterface $ builder , CustomField $ customField ) { $ options = $ customField -> getOptions ( ) ; $ type = ( $ options [ self :: MAX_LENGTH ] < 256 ) ? 'text' : 'textarea' ; $ attrArray = array ( ) ; if ( array_key_exists ( self :: MULTIPLE_CF_INLINE , $ options ) and $ options [ self :: MULTIPLE_CF_INLINE ] ) { $ attrArray [ 'class' ] = 'multiple-cf-inline' ; } $ builder -> add ( $ customField -> getSlug ( ) , $ type , array ( 'label' => $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) , 'required' => false , 'attr' => $ attrArray ) ) ; }
2656	public function createHeader ( $ version , array $ condition ) { $ checkIfExists = $ this -> getHeader ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/header' ; if ( $ checkIfExists === false ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; return $ result ; }
12960	public function query ( $ sql , $ return = false ) { $ query = $ this -> getDb ( ) -> query ( $ sql , true ) ; if ( $ return ) { return $ query ; } }
3325	public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; }
8025	public function addFree ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; $ this -> processDetails [ $ pid ] = $ processDetails ; $ this -> sockets [ $ pid ] = $ processDetails -> getSocket ( ) ; $ this -> registerFreeProcess ( $ processDetails ) ; return $ this ; }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
1337	protected function getQueryParameters ( EncodingParametersInterface $ parameters ) { return new EncodingParameters ( $ parameters -> getIncludePaths ( ) , $ parameters -> getFieldSets ( ) , $ parameters -> getSortParameters ( ) ? : $ this -> defaultSort ( ) , $ parameters -> getPaginationParameters ( ) ? : $ this -> defaultPagination ( ) , $ parameters -> getFilteringParameters ( ) , $ parameters -> getUnrecognizedParameters ( ) ) ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
10309	function getOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/opens/count' , $ params ) ; }
11670	public function getClientBy ( $ selector , $ value , $ callable = null ) { $ selector = strtolower ( $ selector ) ; if ( ! in_array ( $ selector , array ( 'id' , 'key' , 'slot' , 'role' , 'alias' , 'command' ) ) ) { throw new \ InvalidArgumentException ( "Invalid selector type: `$selector`" ) ; } if ( ! method_exists ( $ this -> connection , $ method = "getConnectionBy$selector" ) ) { $ class = get_class ( $ this -> connection ) ; throw new \ InvalidArgumentException ( "Selecting connection by $selector is not supported by $class" ) ; } if ( ! $ connection = $ this -> connection -> $ method ( $ value ) ) { throw new \ InvalidArgumentException ( "Cannot find a connection by $selector matching `$value`" ) ; } $ client = new static ( $ connection , $ this -> getOptions ( ) ) ; if ( $ callable ) { return call_user_func ( $ callable , $ client ) ; } else { return $ client ; } }
1974	public static function findMultipleByUuidsAndExtensions ( $ arrUuids , $ arrExtensions , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || empty ( $ arrExtensions ) || ! \ is_array ( $ arrUuids ) || ! \ is_array ( $ arrExtensions ) ) { return null ; } foreach ( $ arrExtensions as $ k => $ v ) { if ( ! preg_match ( '/^[a-z0-9]{2,5}$/i' , $ v ) ) { unset ( $ arrExtensions [ $ k ] ) ; } } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ") AND $t.extension IN('" . implode ( "','" , $ arrExtensions ) . "')" ) , null , $ arrOptions ) ; }
9118	private function getViewBestMatch ( Request $ request , $ applicationName ) { $ best = null ; if ( count ( $ this -> views [ $ applicationName ] ) > 0 ) { foreach ( $ this -> views [ $ applicationName ] as $ orderLevel => $ views ) { foreach ( $ views as $ view ) { assert ( $ view instanceof View ) ; if ( $ view -> matchBoth ( $ request -> getController ( ) , $ request -> getAction ( ) ) ) { $ best [ $ orderLevel ] = $ view ; continue 2 ; } } } } if ( null == $ best ) { throw new ViewException ( "No view found for request" ) ; } if ( count ( $ best ) > 1 ) { krsort ( $ best ) ; } return reset ( $ best ) ; }
2265	public function fieldExists ( $ strField , $ strTable , $ blnNoCache = false ) { if ( $ strField == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strField && $ arrField [ 'type' ] != 'index' ) { return true ; } } return false ; }
4	private function buildDepExtensionConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { $ depChannelName = 'ext' ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
6267	public static function open ( $ fileName ) { return Reader :: haveExtension ( ) ? new Writer \ DBA ( $ fileName ) : new Writer \ PHP ( $ fileName ) ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
5753	public function getRoleIdsForRoles ( array $ roles ) : array { if ( count ( $ roles ) == 0 ) { throw new \ InvalidArgumentException ( "Roles array must be populated." ) ; } $ roleIds = [ ] ; foreach ( $ roles as $ role ) { if ( null === $ roleIds [ ] = $ this -> getRoleIdForRole ( $ role ) ) { throw new \ InvalidArgumentException ( "Role $role does not exist" ) ; } } return $ roleIds ; }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
10522	protected function quoteIndex ( array $ cols ) { $ q = [ ] ; foreach ( $ cols as $ col ) { $ q [ ] = $ this -> quoteLeading ( $ col ) ; } return $ q ; }
8163	static public function register ( ) { if ( static :: $ registered === true ) { return true ; } $ kirby = kirby ( ) ; if ( ! class_exists ( 'Kirby\Component\Template' ) ) { throw new Exception ( 'The Kirby Twig plugin requires Kirby 2.3 or higher. Current version: ' . $ kirby -> version ( ) ) ; } if ( ! class_exists ( 'Twig_Environment' ) ) { require_once __DIR__ . '/../lib/Twig/lib/Twig/Autoloader.php' ; \ Twig_Autoloader :: register ( ) ; } $ kirby -> set ( 'component' , 'template' , 'Kirby\Twig\TwigComponent' ) ; if ( is_executable ( 'twig' ) === false ) { require_once __DIR__ . '/helpers.php' ; } return static :: $ registered = true ; }
4171	public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
4193	protected function dumpProperties ( $ abs ) { $ label = \ count ( $ abs [ 'properties' ] ) ? 'properties' : 'no properties' ; if ( $ abs [ 'viaDebugInfo' ] ) { $ label .= ' <span class="text-muted">(via __debugInfo)</span>' ; } $ str = '<dt class="properties">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__get' , '__set' ) , \ array_keys ( $ abs [ 'methods' ] ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ abs [ 'properties' ] as $ k => $ info ) { $ vis = ( array ) $ info [ 'visibility' ] ; $ isPrivateAncestor = \ in_array ( 'private' , $ vis ) && $ info [ 'inheritedFrom' ] ; $ classes = \ array_keys ( \ array_filter ( array ( 'debuginfo-value' => $ info [ 'valueFrom' ] == 'debugInfo' , 'excluded' => $ info [ 'isExcluded' ] , 'forceShow' => $ info [ 'forceShow' ] , 'debug-value' => $ info [ 'valueFrom' ] == 'debug' , 'private-ancestor' => $ isPrivateAncestor , 'property' => true , \ implode ( ' ' , $ vis ) => $ info [ 'visibility' ] !== 'debug' , ) ) ) ; $ modifiers = $ vis ; if ( $ info [ 'isStatic' ] ) { $ modifiers [ ] = 'static' ; } $ str .= '<dd class="' . \ implode ( ' ' , $ classes ) . '">' . \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ( $ isPrivateAncestor ? ' (<i>' . $ info [ 'inheritedFrom' ] . '</i>)' : '' ) . ( $ info [ 'type' ] ? ' <span class="t_type">' . $ info [ 'type' ] . '</span>' : '' ) . ' <span class="property-name"' . ' title="' . \ htmlspecialchars ( $ info [ 'desc' ] ) . '"' . '>' . $ k . '</span>' . ( $ info [ 'value' ] !== $ this -> debug -> abstracter -> UNDEFINED ? ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ info [ 'value' ] ) : '' ) . '</dd>' . "\n" ; } return $ str ; }
11506	public function offsetSet ( $ slot , $ connection ) { if ( ! static :: isValid ( $ slot ) ) { throw new \ OutOfBoundsException ( "Invalid slot $slot for `$connection`" ) ; } $ this -> slots [ ( int ) $ slot ] = ( string ) $ connection ; }
11560	public function SetShortcuts ( array $ shortcuts , $ lang = '' ) { if ( ! $ lang ) $ lang = $ this -> lang ; $ this -> shortcuts [ $ lang ] = $ shortcuts ; return $ this ; }
620	protected function generateDependencyData ( $ cache ) { $ db = $ this -> db ; if ( $ db !== null ) { $ db = Instance :: ensure ( $ db ) ; } if ( ! $ this -> query instanceof QueryInterface ) { throw new InvalidConfigException ( '"' . get_class ( $ this ) . '::$query" should be an instance of "yii\db\QueryInterface".' ) ; } if ( ! empty ( $ db -> enableQueryCache ) ) { $ originEnableQueryCache = $ db -> enableQueryCache ; $ db -> enableQueryCache = false ; $ result = $ this -> executeQuery ( $ this -> query , $ db ) ; $ db -> enableQueryCache = $ originEnableQueryCache ; } else { $ result = $ this -> executeQuery ( $ this -> query , $ db ) ; } return $ result ; }
10424	public function parseXml ( $ xml ) { if ( is_null ( $ xml ) ) { return null ; } $ xml = new QuiteSimpleXMLElement ( $ xml ) ; $ xml -> registerXPathNamespaces ( $ this -> namespaces ) ; return $ xml ; }
1148	protected function getAttributeName ( $ attribute ) { $ attributeArray = explode ( '.' , $ attribute ) ; if ( count ( $ attributeArray ) > 1 ) { return $ attributeArray [ 0 ] . '[' . implode ( '][' , array_slice ( $ attributeArray , 1 ) ) . ']' ; } return $ attribute ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
11451	public function getParentKeyName ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; $ relat = $ this -> $ func ( ) ; $ field = $ relat -> getForeignKey ( ) ; return $ field ; } return 'id' ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
367	public function renderFilters ( ) { if ( $ this -> filterModel !== null ) { $ cells = [ ] ; foreach ( $ this -> columns as $ column ) { $ cells [ ] = $ column -> renderFilterCell ( ) ; } return Html :: tag ( 'tr' , implode ( '' , $ cells ) , $ this -> filterRowOptions ) ; } return '' ; }
11826	public function remove ( $ encoding ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , substr ( $ str , ( strlen ( $ this -> getBom ( $ encoding ) ) ) ) ) ; }
9672	private function writeBorderPr ( XMLWriter $ objWriter , $ pName , Border $ pBorder ) { if ( $ pBorder -> getBorderStyle ( ) != Border :: BORDER_NONE ) { $ objWriter -> startElement ( $ pName ) ; $ objWriter -> writeAttribute ( 'style' , $ pBorder -> getBorderStyle ( ) ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pBorder -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } }
7373	public function updatePasswordAction ( Request $ request ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ChangePasswordType :: class ) ; $ form -> bind ( $ request ) ; $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ current = $ encoder -> encodePassword ( $ data [ 'current' ] , $ user -> getSalt ( ) ) ; if ( $ current !== $ user -> getPassword ( ) ) { $ form -> get ( 'current' ) -> addError ( new FormError ( 'Current password is not correct' ) ) ; } if ( $ form -> isValid ( ) ) { $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your password has been changed.' ) ; return new JsonReloadResponse ( ) ; } return new JsonErrorResponse ( $ form ) ; }
8056	public function setChildProcessTitleFormat ( $ string ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Parent\'s Process Title Format for a created pool.' ) ; } $ this -> childProcessTitleFormat = ProcessDetails :: sanitizeProcessTitleFormat ( $ string ) ; return $ this ; }
10160	private function readMsoDrawing ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingData .= $ recordData ; }
10422	public function addToInsertList ( $ key , $ value , $ isString = true ) { $ this -> sqlInsertList [ $ key ] = [ 'value' => $ value , 'string' => $ isString , ] ; }
4654	protected function getJobs ( $ projectPath ) { $ jobs = array ( ) ; $ project = $ this -> naming -> getProjectName ( $ projectPath ) ; $ repositoryRegex = sprintf ( '#^%s_([a-z]+?)/%s:\d+-\d+$#' , Job :: BASE_NAME , $ project ) ; foreach ( $ this -> docker -> getImageManager ( ) -> findAll ( ) as $ image ) { foreach ( $ image -> getRepoTags ( ) as $ name ) { if ( preg_match ( $ repositoryRegex , $ name , $ matches ) ) { $ jobs [ ] = $ this -> getJobFromImage ( $ image , $ name , $ matches [ 1 ] , $ project ) ; } } } return $ jobs ; }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
6602	public function make ( $ key , $ secret ) { $ this -> credentials [ 'key' ] = $ key ; $ this -> credentials [ 'secret' ] = $ secret ; return $ this ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
3475	public function getGateway ( ) { $ gateway = $ this -> gateway ; try { $ response = $ this -> guzzle -> get ( 'https://discordapp.com/api/gateway' , [ 'headers' => [ 'Authorization' => 'Bot ' . $ this -> token , ] , ] ) ; $ gateway = Arr :: get ( json_decode ( $ response -> getBody ( ) , true ) , 'url' , $ gateway ) ; } catch ( Exception $ e ) { $ this -> warn ( "Could not get a websocket gateway address, defaulting to '{$gateway}'." ) ; } return $ gateway ; }
7934	public function alreadyLoaded ( $ name ) { foreach ( $ this -> loaded as $ item ) { if ( $ item [ 'name' ] === $ name ) { return true ; } } return false ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
5820	protected function transformFiles ( $ files ) { $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = [ 'type' => $ file [ 'content_type' ] === 'application/directory' ? 'dir' : 'file' , 'path' => $ file [ 'name' ] , 'size' => intval ( $ file [ 'bytes' ] ) , 'timestamp' => strtotime ( $ file [ 'last_modified' ] ) , 'mimetype' => $ file [ 'content_type' ] , ] ; } return $ result ; }
1157	protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; }
993	public static function isValidLiteralValue ( Type $ type , $ valueNode ) { $ emptySchema = new Schema ( [ ] ) ; $ emptyDoc = new DocumentNode ( [ 'definitions' => [ ] ] ) ; $ typeInfo = new TypeInfo ( $ emptySchema , $ type ) ; $ context = new ValidationContext ( $ emptySchema , $ emptyDoc , $ typeInfo ) ; $ validator = new ValuesOfCorrectType ( ) ; $ visitor = $ validator -> getVisitor ( $ context ) ; Visitor :: visit ( $ valueNode , Visitor :: visitWithTypeInfo ( $ typeInfo , $ visitor ) ) ; return $ context -> getErrors ( ) ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
9418	public function f ( $ x ) { if ( ! is_numeric ( $ x ) ) { throw new \ InvalidArgumentException ( 'x variable must be numeric value.' ) ; } $ float_fx = exp ( - 0.5 * pow ( ( $ x - $ this -> float_mu ) / $ this -> float_sigma , 2 ) ) / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_fx , $ this -> int_precision ) ; } return $ float_fx ; }
5650	private function parseArgument ( & $ arguments ) { $ argument = array_shift ( $ arguments ) ; if ( preg_match ( '/^-(\w)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^-(\w)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } elseif ( preg_match ( '/^--(\w+)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^--(\w+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
305	private function setRelationDependencies ( $ name , $ relation , $ viaRelationName = null ) { if ( empty ( $ relation -> via ) && $ relation -> link ) { foreach ( $ relation -> link as $ attribute ) { $ this -> _relationsDependencies [ $ attribute ] [ $ name ] = $ name ; if ( $ viaRelationName !== null ) { $ this -> _relationsDependencies [ $ attribute ] [ ] = $ viaRelationName ; } } } elseif ( $ relation -> via instanceof ActiveQueryInterface ) { $ this -> setRelationDependencies ( $ name , $ relation -> via ) ; } elseif ( is_array ( $ relation -> via ) ) { list ( $ viaRelationName , $ viaQuery ) = $ relation -> via ; $ this -> setRelationDependencies ( $ name , $ viaQuery , $ viaRelationName ) ; } }
1868	public function maintenanceCheck ( ) { $ this -> import ( BackendUser :: class , 'User' ) ; if ( ! $ this -> User -> hasAccess ( 'maintenance' , 'modules' ) ) { return '' ; } try { if ( System :: getContainer ( ) -> get ( 'lexik_maintenance.driver.factory' ) -> getDriver ( ) -> isExists ( ) ) { return '<p class="tl_error">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'maintenanceEnabled' ] . '</p>' ; } } catch ( \ Exception $ e ) { } return '' ; }
7923	private function extractFilename ( \ ZipArchive $ zipArchive , $ fileIndex ) { $ entry = $ zipArchive -> statIndex ( $ fileIndex ) ; $ filename = str_replace ( '\\' , '/' , $ entry [ 'name' ] ) ; if ( $ this -> isValidPath ( $ filename ) ) { return $ filename ; } throw new \ Exception ( 'Invalid filename path in zip archive' ) ; }
139	public function uninstall ( RepositoryInterface $ repo , UninstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> uninstall ( $ repo , $ package ) ; }
659	public function noCache ( callable $ callable ) { $ this -> _queryCacheInfo [ ] = false ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
1766	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_GET ) ) { return ; } $ response = $ event -> getResponse ( ) ; if ( 200 !== $ response -> getStatusCode ( ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ this -> storeBackendReferer ( $ request ) ; } else { $ this -> storeFrontendReferer ( $ request ) ; } }
11814	protected function step1 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/license" ) ; $ this -> view -> setData ( "step" , "1" ) ; $ this -> view -> setData ( "title" , t ( "Installation | EULA" ) ) ; return ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
2417	protected function addDataRow ( \ DOMDocument $ xml , \ DOMElement $ table , array $ arrRow , array $ arrOrder = array ( ) ) { $ t = $ table -> getAttribute ( 'name' ) ; $ row = $ xml -> createElement ( 'row' ) ; $ row = $ table -> appendChild ( $ row ) ; foreach ( $ arrRow as $ k => $ v ) { $ field = $ xml -> createElement ( 'field' ) ; $ field -> setAttribute ( 'name' , $ k ) ; $ field = $ row -> appendChild ( $ field ) ; if ( $ v === null ) { $ v = 'NULL' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' && ! $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'eval' ] [ 'multiple' ] ) { $ objFile = FilesModel :: findByUuid ( $ v ) ; if ( $ objFile !== null ) { $ v = $ this -> standardizeUploadPath ( $ objFile -> path ) ; } else { $ v = 'NULL' ; } } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' || \ in_array ( $ k , $ arrOrder ) ) { $ arrFiles = StringUtil :: deserialize ( $ v ) ; if ( ! empty ( $ arrFiles ) && \ is_array ( $ arrFiles ) ) { $ objFiles = FilesModel :: findMultipleByUuids ( $ arrFiles ) ; if ( $ objFiles !== null ) { $ arrTmp = array ( ) ; while ( $ objFiles -> next ( ) ) { $ arrTmp [ ] = $ this -> standardizeUploadPath ( $ objFiles -> path ) ; } $ v = serialize ( $ arrTmp ) ; } else { $ v = 'NULL' ; } } } elseif ( $ t == 'tl_style' && ( $ k == 'bgimage' || $ k == 'liststyleimage' ) ) { $ v = $ this -> standardizeUploadPath ( $ v ) ; } $ value = $ xml -> createTextNode ( $ v ) ; $ field -> appendChild ( $ value ) ; } }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
4751	public function getPriceByPlanCode ( string $ planCode ) : float { $ plan = $ this -> getPlan ( $ planCode ) ; return ( array_key_exists ( 'recurring_price' , $ plan ) ) ? $ plan [ 'recurring_price' ] : 0 ; }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
9790	public function getFormattedValue ( ) { return ( string ) NumberFormat :: toFormattedString ( $ this -> getCalculatedValue ( ) , $ this -> getStyle ( ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; }
10402	public function createApplication ( string $ app_type , FileSystemInterface $ filesystem ) : ApplicationInterface { switch ( $ app_type ) { case ApplicationType :: SHELL : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; case ApplicationType :: CRON : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( CalgamoShellRequestModule :: class ) ; break ; case ApplicationType :: HTTP : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( 'zend.request' ) ; break ; case ApplicationType :: REST : return ( new Calgamo ( $ filesystem ) ) -> newApp ( ) -> requireModule ( ZendRequestModule :: class ) -> requireModule ( CalgamoRestApiModule :: class ) ; break ; } return new NullApplication ( ) ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
5688	public function getFormByImage ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasImage ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
10752	protected function getStateFormatted ( UserEntity $ user ) { switch ( $ user -> getState ( ) ) { case UserEntity :: USER_STATE_ACTIVE : $ this -> stateClass = 'success' ; return 'Attivo' ; break ; case UserEntity :: USER_STATE_BANNED : $ this -> stateClass = 'danger' ; return 'Bannato' ; break ; case UserEntity :: USER_STATE_DEACTIVE : $ this -> stateClass = 'warning' ; return 'Disattivo' ; break ; case UserEntity :: USER_STATE_DELETED : $ this -> stateClass = 'danger' ; return 'Eliminato' ; break ; } $ this -> stateClass = 'danger' ; return 'Error with user state' ; }
5413	protected function createSocket ( $ scheme , $ host , $ port , $ timeout ) { if ( in_array ( $ scheme , array ( 'file' ) ) ) { return new SimpleFileSocket ( $ this -> url ) ; } elseif ( in_array ( $ scheme , array ( 'https' ) ) ) { return new SimpleSecureSocket ( $ host , $ port , $ timeout ) ; } else { return new SimpleSocket ( $ host , $ port , $ timeout ) ; } }
11340	public function generateRules ( $ table ) { $ types = [ ] ; $ lengths = [ ] ; foreach ( $ table -> columns as $ column ) { if ( $ column -> autoIncrement ) { continue ; } if ( ! $ column -> allowNull && $ column -> defaultValue === null && ! $ column -> isPrimaryKey ) { $ types [ 'required' ] [ ] = $ column -> name ; } switch ( $ column -> type ) { case Schema :: TYPE_SMALLINT : case Schema :: TYPE_INTEGER : case Schema :: TYPE_BIGINT : $ types [ 'integer' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_BOOLEAN : $ types [ 'boolean' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_FLOAT : case Schema :: TYPE_DECIMAL : case Schema :: TYPE_MONEY : $ types [ 'number' ] [ ] = $ column -> name ; break ; case Schema :: TYPE_DATE : case Schema :: TYPE_TIME : case Schema :: TYPE_DATETIME : case Schema :: TYPE_TIMESTAMP : if ( ! in_array ( $ column -> name , [ 'created' , 'deleted' , 'modified' ] ) ) { $ types [ 'safe' ] [ ] = $ column -> name ; } break ; default : if ( $ column -> size > 0 ) { $ lengths [ $ column -> size ] [ ] = $ column -> name ; } else { $ types [ 'string' ] [ ] = $ column -> name ; } } } $ rules = [ ] ; foreach ( $ types as $ type => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], '$type']" ; } foreach ( $ lengths as $ length => $ columns ) { $ rules [ ] = "[['" . implode ( "', '" , $ columns ) . "'], 'string', 'max' => $length]" ; } return $ rules ; }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
6692	public function addGroup ( $ prefix , array $ middleware , callable $ callback ) { $ previousMiddlewareStack = $ this -> middlewareStack ; $ previousGroupPrefix = $ this -> currentGroupPrefix ; $ this -> currentGroupPrefix = $ previousGroupPrefix . $ prefix ; $ this -> middlewareStack = array_merge ( $ previousMiddlewareStack , $ middleware ) ; $ callback ( $ this ) ; $ this -> currentGroupPrefix = $ previousGroupPrefix ; $ this -> middlewareStack = $ previousMiddlewareStack ; }
939	public function isWhitespace ( $ whitespaces = " \t\n\r\0\x0B" ) { if ( null === $ whitespaces ) { $ whitespaces = " \t\n\r\0\x0B" ; } if ( $ this -> isArray && ! $ this -> isGivenKind ( T_WHITESPACE ) ) { return false ; } return '' === trim ( $ this -> content , $ whitespaces ) ; }
5385	public function isId ( $ id ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isId ( $ id ) ) { return true ; } } return false ; }
1322	private function parseHeaders ( $ header ) { $ headers = [ ] ; foreach ( explode ( "\r\n" , $ header ) as $ line ) { if ( strpos ( $ line , ':' ) !== false ) { list ( $ key , $ value ) = explode ( ': ' , $ line ) ; $ key = str_replace ( '-' , '_' , strtolower ( $ key ) ) ; $ headers [ $ key ] = trim ( $ value ) ; } } return $ headers ; }
10942	private function reset ( ) { $ time = new \ DateTime ( ) ; $ this -> driver -> set ( self :: LAST_UPDATE_KEY , $ time ) ; return $ time ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2569	protected function checkAnyTrue ( ) { $ foundTrue = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( $ arg === true ) { $ foundTrue = true ; break ; } } return $ foundTrue ; }
8215	protected function getServerStats ( $ pattern = '' ) { $ stats = ( array ) $ this -> getPheanstalk ( ) -> stats ( ) ; if ( ! empty ( $ pattern ) ) { $ stats = array_filter ( $ stats , function ( $ key ) use ( $ pattern ) { return 1 === preg_match ( "/$pattern/i" , $ key ) ; } , ARRAY_FILTER_USE_KEY ) ; } ksort ( $ stats ) ; return $ stats ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
3661	private function addParameters ( $ parameters ) { if ( empty ( $ parameters ) ) { return ; } $ this -> queryParameter = array_merge ( $ this -> queryParameter , $ parameters ) ; }
7836	protected function deleteAllFilesOfWorkflowIfForced ( $ workflow ) { $ files = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ files [ ] = $ this -> inflector -> getRequest ( ) ; $ files [ ] = $ this -> inflector -> getJob ( ) ; $ this -> deleteIfForced ( $ files ) ; }
4045	public function decodeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ propInfo = $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getPropertiesDefinition ( ) -> getProperty ( 'jumpTo' ) ; $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; $ extra = $ propInfo -> getExtra ( ) ; $ newValues = [ ] ; $ languages = $ extra [ 'columnFields' ] [ 'langcode' ] [ 'options' ] ; foreach ( array_keys ( $ languages ) as $ key ) { $ newValue = '' ; $ filter = 0 ; if ( $ value ) { foreach ( $ value as $ arr ) { if ( ! is_array ( $ arr ) ) { break ; } if ( array_search ( $ key , $ arr ) !== false ) { $ newValue = '{{link_url::' . $ arr [ 'value' ] . '}}' ; $ filter = $ arr [ 'filter' ] ; break ; } } } $ newValues [ ] = [ 'langcode' => $ key , 'value' => $ newValue , 'filter' => $ filter ] ; } $ event -> setValue ( $ newValues ) ; }
506	public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; }
11118	protected function runDown ( array $ file ) : void { $ this -> notify -> note ( "<comment>Rolling back:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> delete ( $ this -> getMigrationName ( $ file ) ) ; $ this -> notify -> note ( "<info>Rolled back:</info> {$file['basename']}" ) ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
9814	public function addEntriesToBlacklist ( $ id , $ entries , $ importName = null ) { if ( $ importName == null ) { $ importName = "phpclient_import_" . uniqid ( ) ; } $ action = new AddEntriesAction ( ) ; $ action -> importName = $ importName ; $ action -> entries = $ entries ; return $ this -> post ( "blacklists/" . $ id . "/actions" , $ action -> toXMLString ( ) ) ; }
3530	public static function sendUnrealClientPostRequest ( $ endpoint , $ params = null , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( [ 'http_errors' => false ] ) ; try { $ response = $ client -> post ( $ endpoint , [ 'form_params' => $ params , 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization , 'X-Epic-Device-ID' => self :: generateDeviceId ( ) ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
11322	protected function getAnnotationClassForAction ( $ requestAction ) { $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ action ) { if ( $ action -> getAnnotatedName ( ) === $ requestAction ) { return $ action ; } } throw new ExtDirectException ( "extjs direct name '{$requestAction}' does not exist'" ) ; }
11776	public function getHelper ( ) { if ( $ this -> helper === null ) { $ this -> helper = $ this -> command -> getHelper ( 'question' ) ; } return $ this -> helper ; }
1893	public function onAuthenticationFailure ( Request $ request , AuthenticationException $ exception ) : Response { if ( null === $ this -> logger ) { return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } if ( $ exception instanceof AccountStatusException && ( $ user = $ exception -> getUser ( ) ) instanceof UserInterface ) { $ username = $ user -> getUsername ( ) ; } else { $ username = $ request -> request -> get ( 'username' ) ; } $ this -> logger -> info ( $ exception -> getMessage ( ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ username ) ] ) ; return parent :: onAuthenticationFailure ( $ request , $ exception ) ; }
6	private function parse20VersionConstraint ( array $ data ) { static $ dep20toOperatorMap = array ( 'has' => '==' , 'min' => '>=' , 'max' => '<=' , 'exclude' => '!=' ) ; $ versions = array ( ) ; $ values = array_intersect_key ( $ data , $ dep20toOperatorMap ) ; if ( 0 == count ( $ values ) ) { return '*' ; } if ( isset ( $ values [ 'min' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'min' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '>' . $ this -> parseVersion ( $ values [ 'min' ] ) ; } elseif ( isset ( $ values [ 'max' ] ) && isset ( $ values [ 'exclude' ] ) && $ data [ 'max' ] == $ data [ 'exclude' ] ) { $ versions [ ] = '<' . $ this -> parseVersion ( $ values [ 'max' ] ) ; } else { foreach ( $ values as $ op => $ version ) { if ( 'exclude' == $ op && is_array ( $ version ) ) { foreach ( $ version as $ versionPart ) { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ versionPart ) ; } } else { $ versions [ ] = $ dep20toOperatorMap [ $ op ] . $ this -> parseVersion ( $ version ) ; } } } return implode ( ',' , $ versions ) ; }
5437	public function addPattern ( $ pattern , $ label = true ) { $ count = count ( $ this -> patterns ) ; $ this -> patterns [ $ count ] = $ pattern ; $ this -> labels [ $ count ] = $ label ; $ this -> regex = null ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
11577	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> enableConfirmation == false ) { throw new NotFoundHttpException ; } $ user -> attemptConfirmation ( $ code ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Account confirmation' ) , 'module' => $ this -> module , ] ) ; }
7120	protected function getFindBySubjectAndSupplierQuery ( ) { if ( null !== $ this -> findBySubjectAndSupplierQuery ) { return $ this -> findBySubjectAndSupplierQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectAndSupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ this -> getAlias ( ) . '.supplier' , ':supplier' ) ) -> getQuery ( ) ; }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
20	protected function propagate ( $ level ) { while ( $ this -> decisions -> validOffset ( $ this -> propagateIndex ) ) { $ decision = $ this -> decisions -> atOffset ( $ this -> propagateIndex ) ; $ conflict = $ this -> watchGraph -> propagateLiteral ( $ decision [ Decisions :: DECISION_LITERAL ] , $ level , $ this -> decisions ) ; $ this -> propagateIndex ++ ; if ( $ conflict ) { return $ conflict ; } } return null ; }
9511	public function delete ( Log $ log ) { $ this -> authorize ( LogViewerPolicy :: PERMISSION_DELETE ) ; $ date = $ log -> date ; if ( $ this -> logViewer -> delete ( $ date ) ) { $ this -> notifySuccess ( $ message = trans ( 'foundation::log-viewer.messages.deleted.message' , compact ( 'date' ) ) , trans ( 'foundation::log-viewer.messages.deleted.title' ) ) ; return $ this -> jsonResponseSuccess ( compact ( 'message' ) ) ; } return $ this -> jsonResponseError ( [ 'message' => "An error occurred while deleting the log [$date]" ] ) ; }
9484	public function fromArray ( array $ array ) { foreach ( $ array as $ k => $ v ) { if ( ! is_null ( $ v ) && property_exists ( get_class ( $ this ) , $ k ) ) { $ meta = new \ ReflectionProperty ( get_class ( $ this ) , $ k ) ; $ info = $ this -> parsePropertyDocComment ( $ meta -> getDocComment ( ) ) ; $ type = $ info [ 'type' ] ; if ( strtolower ( $ type ) == "array" && $ elementType = $ info [ 'array_element' ] ) { if ( class_exists ( $ elementType ) ) { $ children = array ( ) ; foreach ( $ v as $ subV ) { $ newElement = new $ elementType ( ) ; $ children [ ] = $ newElement -> fromArray ( $ subV ) ; } $ this -> $ k = $ children ; } else { throw new \ Exception ( '@element Class Not Found:' . $ elementType ) ; } } else if ( class_exists ( $ type ) ) { $ typeObject = new $ type ( ) ; $ this -> $ k = $ typeObject -> fromArray ( $ v ) ; } else { $ this -> $ k = $ v ; } } } return $ this ; }
693	public function compose ( $ view = null , array $ params = [ ] ) { $ message = $ this -> createMessage ( ) ; if ( $ view === null ) { return $ message ; } if ( ! array_key_exists ( 'message' , $ params ) ) { $ params [ 'message' ] = $ message ; } $ this -> _message = $ message ; if ( is_array ( $ view ) ) { if ( isset ( $ view [ 'html' ] ) ) { $ html = $ this -> render ( $ view [ 'html' ] , $ params , $ this -> htmlLayout ) ; } if ( isset ( $ view [ 'text' ] ) ) { $ text = $ this -> render ( $ view [ 'text' ] , $ params , $ this -> textLayout ) ; } } else { $ html = $ this -> render ( $ view , $ params , $ this -> htmlLayout ) ; } $ this -> _message = null ; if ( isset ( $ html ) ) { $ message -> setHtmlBody ( $ html ) ; } if ( isset ( $ text ) ) { $ message -> setTextBody ( $ text ) ; } elseif ( isset ( $ html ) ) { if ( preg_match ( '~<body[^>]*>(.*?)</body>~is' , $ html , $ match ) ) { $ html = $ match [ 1 ] ; } $ html = preg_replace ( '~<((style|script))[^>]*>(.*?)</\1>~is' , '' , $ html ) ; $ text = html_entity_decode ( strip_tags ( $ html ) , ENT_QUOTES | ENT_HTML5 , Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ) ; $ text = preg_replace ( "~^[ \t]+~m" , '' , trim ( $ text ) ) ; $ text = preg_replace ( '~\R\R+~mu' , "\n\n" , $ text ) ; $ message -> setTextBody ( $ text ) ; } return $ message ; }
411	private function utf8Encode ( $ s ) { $ s .= $ s ; $ len = \ strlen ( $ s ) ; for ( $ i = $ len >> 1 , $ j = 0 ; $ i < $ len ; ++ $ i , ++ $ j ) { switch ( true ) { case $ s [ $ i ] < "\x80" : $ s [ $ j ] = $ s [ $ i ] ; break ; case $ s [ $ i ] < "\xC0" : $ s [ $ j ] = "\xC2" ; $ s [ ++ $ j ] = $ s [ $ i ] ; break ; default : $ s [ $ j ] = "\xC3" ; $ s [ ++ $ j ] = \ chr ( \ ord ( $ s [ $ i ] ) - 64 ) ; break ; } } return substr ( $ s , 0 , $ j ) ; }
1860	public function rcopy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; $ this -> mkdir ( $ strDestination ) ; $ arrFiles = scan ( $ this -> strRootDir . '/' . $ strSource , true ) ; foreach ( $ arrFiles as $ strFile ) { if ( is_dir ( $ this -> strRootDir . '/' . $ strSource . '/' . $ strFile ) ) { $ this -> rcopy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } else { $ this -> copy ( $ strSource . '/' . $ strFile , $ strDestination . '/' . $ strFile ) ; } } }
8612	public function setMarketplace ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Marketplace' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11487	protected function callResolvingCallbacks ( $ key , $ object ) { foreach ( $ this -> resolvingAnyCallbacks as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } if ( isset ( $ this -> resolvingCallbacks [ $ key ] ) ) { foreach ( $ this -> resolvingCallbacks [ $ key ] as $ callback ) { call_user_func ( $ callback , $ object , $ this ) ; } } }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
2415	protected function addTableTlImageSize ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ imageSizeTable = $ xml -> createElement ( 'table' ) ; $ imageSizeTable -> setAttribute ( 'name' , 'tl_image_size' ) ; $ imageSizeTable = $ tables -> appendChild ( $ imageSizeTable ) ; $ imageSizeItemTable = $ xml -> createElement ( 'table' ) ; $ imageSizeItemTable -> setAttribute ( 'name' , 'tl_image_size_item' ) ; $ imageSizeItemTable = $ tables -> appendChild ( $ imageSizeItemTable ) ; $ objSizes = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size WHERE pid=?" ) -> execute ( $ objTheme -> id ) ; while ( $ objSizes -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeTable , $ objSizes -> row ( ) ) ; $ objSizeItems = $ this -> Database -> prepare ( "SELECT * FROM tl_image_size_item WHERE pid=?" ) -> execute ( $ objSizes -> id ) ; while ( $ objSizeItems -> next ( ) ) { $ this -> addDataRow ( $ xml , $ imageSizeItemTable , $ objSizeItems -> row ( ) ) ; } } }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
8903	public function delete_by_at ( $ condition , $ time ) { $ this -> prevent_if_not_soft_deletable ( ) ; $ this -> _set_where ( $ condition ) ; return $ this -> _delete ( $ condition , $ time ) ; }
4215	private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { if ( $ val [ 'type' ] == 'object' ) { if ( $ val [ 'traverseValues' ] ) { $ val = $ val [ 'traverseValues' ] ; } elseif ( $ val [ 'stringified' ] ) { $ val = null ; } elseif ( isset ( $ val [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = null ; } else { $ val = \ array_filter ( $ val [ 'properties' ] , function ( $ prop ) { return $ prop [ 'visibility' ] === 'public' ; } ) ; \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { $ val = null ; } } return \ is_array ( $ val ) ? \ array_keys ( $ val ) : array ( self :: SCALAR ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
3738	private function getConnection ( ) { if ( $ this -> connection ) { return $ this -> connection ; } $ reflection = new \ ReflectionProperty ( \ Contao \ Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ this -> connection = $ reflection -> getValue ( $ this -> getDatabase ( ) ) ; }
6514	public function invoke ( JobInterface $ job , ContextInterface $ context ) { $ jobType = $ this -> registry -> get ( $ job -> getType ( ) ) ; $ callableArray = $ jobType -> getCallable ( ) ; $ parameters = static :: resolveParameters ( $ jobType , $ context , $ job -> getParameters ( ) ) ; if ( is_array ( $ callableArray ) && $ callable = $ callableArray [ 0 ] ) { if ( $ callable instanceof JobAwareInterface ) { $ callable -> setJob ( $ job ) ; } if ( $ callable instanceof ManagerAwareInterface ) { $ callable -> setManager ( $ this -> manager ) ; } if ( $ callable instanceof ControllerAwareInterface ) { $ callable -> setController ( $ this -> controllerFactory -> create ( $ job ) ) ; } if ( $ callable instanceof LoggerAwareInterface && $ context -> has ( 'abc.logger' ) ) { $ callable -> setLogger ( $ context -> get ( 'abc.logger' ) ) ; } } return call_user_func_array ( $ callableArray , $ parameters ) ; }
10300	private function writeBubbles ( $ plotSeriesValues , $ objWriter ) { if ( $ plotSeriesValues === null ) { return ; } $ objWriter -> startElement ( 'c:bubbleSize' ) ; $ objWriter -> startElement ( 'c:numLit' ) ; $ objWriter -> startElement ( 'c:formatCode' ) ; $ objWriter -> writeRawData ( 'General' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:ptCount' ) ; $ objWriter -> writeAttribute ( 'val' , $ plotSeriesValues -> getPointCount ( ) ) ; $ objWriter -> endElement ( ) ; $ dataValues = $ plotSeriesValues -> getDataValues ( ) ; if ( ! empty ( $ dataValues ) ) { if ( is_array ( $ dataValues ) ) { foreach ( $ dataValues as $ plotSeriesKey => $ plotSeriesValue ) { $ objWriter -> startElement ( 'c:pt' ) ; $ objWriter -> writeAttribute ( 'idx' , $ plotSeriesKey ) ; $ objWriter -> startElement ( 'c:v' ) ; $ objWriter -> writeRawData ( 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; } } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:bubble3D' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
8936	public function createChangeset ( $ changesets = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , 'oauth_token_secret' => $ token [ 'secret' ] , ) ; $ base = 'changeset/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap">' ; if ( ! empty ( $ changesets ) ) { foreach ( $ changesets as $ tags ) { $ xml .= '<changeset>' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ xml .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml .= '</changeset>' ; } } $ xml .= '</osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
8917	public function message ( $ messageId ) { $ params = [ 'query' => [ 'apikey' => $ this -> apikey , ] ] ; $ response = $ this -> client -> get ( 'messages/' . $ messageId , $ params ) ; return $ response -> getBody ( ) ; }
485	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
3092	public function load ( ) { if ( ! isset ( $ this -> cache [ $ this -> testSessionId ] ) ) { $ encodedData = $ this -> getStorageService ( ) -> get ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Loaded %d bytes from state storage' , strlen ( $ encodedData ) ) ) ; $ this -> cache [ $ this -> testSessionId ] = $ this -> getStorageFormat ( ) -> decode ( $ encodedData ) ; } return $ this -> cache [ $ this -> testSessionId ] ; }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
1742	public function syncFiles ( $ href , $ label , $ title , $ class , $ attributes ) { return $ this -> User -> hasAccess ( 'f6' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" class="' . $ class . '"' . $ attributes . '>' . $ label . '</a> ' : '' ; }
5661	private function attributes ( $ node ) { if ( ! preg_match ( '|<[^ ]+\s(.*?)/?>|s' , $ node -> value , $ first_tag_contents ) ) { return array ( ) ; } $ attributes = array ( ) ; preg_match_all ( '/\S+\s*=\s*\'[^\']*\'|(\S+\s*=\s*"[^"]*")|([^ =]+\s*=\s*[^ "\']+?)|[^ "\']+/' , $ first_tag_contents [ 1 ] , $ matches ) ; foreach ( $ matches [ 0 ] as $ unparsed ) { $ attributes = $ this -> mergeAttribute ( $ attributes , $ unparsed ) ; } return $ attributes ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
11714	public function getTokenFromServer ( ) { $ params = [ 'appid' => $ this -> appId , 'secret' => $ this -> secret , 'grant_type' => 'client_credential' , ] ; $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJSON ( $ http -> get ( self :: API_TOKEN_GET , $ params ) ) ; if ( empty ( $ token [ $ this -> tokenJsonKey ] ) ) { throw new HttpException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
5918	protected function setSecretKey ( $ passphrase ) { $ length = strlen ( $ passphrase ) ; if ( strlen ( $ passphrase ) < 1 || strlen ( $ passphrase ) > 56 ) { throw new Ts3Exception ( "secret passphrase must contain at least one but less than 56 characters" ) ; } $ k = 0 ; $ data = 0 ; $ datal = 0 ; $ datar = 0 ; for ( $ i = 0 ; $ i < 18 ; $ i ++ ) { $ data = 0 ; for ( $ j = 4 ; $ j > 0 ; $ j -- ) { $ data = $ data << 8 | ord ( $ passphrase { $ k } ) ; $ k = ( $ k + 1 ) % $ length ; } $ this -> p [ $ i ] ^= $ data ; } for ( $ i = 0 ; $ i <= 16 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> p [ $ i ] = $ datal ; $ this -> p [ $ i + 1 ] = $ datar ; } foreach ( $ this -> s as $ key => $ val ) { for ( $ i = 0 ; $ i < 256 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> s [ $ key ] [ $ i ] = $ datal ; $ this -> s [ $ key ] [ $ i + 1 ] = $ datar ; } } }
9857	public function isValid ( Cell $ cell ) { if ( ! $ cell -> hasDataValidation ( ) ) { return true ; } $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; if ( ! $ dataValidation -> getAllowBlank ( ) && ( $ cellValue === null || $ cellValue === '' ) ) { return false ; } switch ( $ dataValidation -> getType ( ) ) { case DataValidation :: TYPE_LIST : return $ this -> isValueInList ( $ cell ) ; } return false ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
4337	private function getDefaultOutputAs ( ) { $ ret = 'html' ; $ interface = $ this -> debug -> utilities -> getInterface ( ) ; if ( $ interface == 'ajax' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } elseif ( $ interface == 'http' ) { $ contentType = $ this -> debug -> utilities -> getResponseHeader ( ) ; if ( $ contentType && $ contentType !== 'text/html' ) { $ ret = $ this -> cfg [ 'outputAsDefaultNonHtml' ] ; } } else { $ ret = 'text' ; } return $ ret ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2196	protected function sendAdminNotification ( $ intId , $ arrData ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ strData = "\n\n" ; foreach ( $ arrData as $ k => $ v ) { if ( $ k == 'password' || $ k == 'tstamp' || $ k == 'dateAdded' ) { continue ; } $ v = StringUtil :: deserialize ( $ v ) ; if ( $ k == 'dateOfBirth' && \ strlen ( $ v ) ) { $ v = Date :: parse ( Config :: get ( 'dateFormat' ) , $ v ) ; } $ strData .= $ GLOBALS [ 'TL_LANG' ] [ 'tl_member' ] [ $ k ] [ 0 ] . ': ' . ( \ is_array ( $ v ) ? implode ( ', ' , $ v ) : $ v ) . "\n" ; } $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'adminText' ] , $ intId , $ strData . "\n" ) . "\n" ; $ objEmail -> sendTo ( $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ) ; $ this -> log ( 'A new user (ID ' . $ intId . ') has registered on the website' , __METHOD__ , TL_ACCESS ) ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
5463	protected function getCommonPath ( $ first , $ second ) { $ first = explode ( '/' , $ first ) ; $ second = explode ( '/' , $ second ) ; for ( $ i = 0 ; $ i < min ( count ( $ first ) , count ( $ second ) ) ; $ i ++ ) { if ( $ first [ $ i ] != $ second [ $ i ] ) { return implode ( '/' , array_slice ( $ first , 0 , $ i ) ) . '/' ; } } return implode ( '/' , $ first ) . '/' ; }
1936	protected function getForwardUrl ( $ objPage ) { if ( $ objPage -> jumpTo ) { $ objNextPage = PageModel :: findPublishedById ( $ objPage -> jumpTo ) ; } else { $ objNextPage = PageModel :: findFirstPublishedRegularByPid ( $ objPage -> id ) ; } if ( ! $ objNextPage instanceof PageModel ) { $ this -> log ( 'Forward page ID "' . $ objPage -> jumpTo . '" does not exist' , __METHOD__ , TL_ERROR ) ; throw new ForwardPageNotFoundException ( 'Forward page not found' ) ; } $ strGet = '' ; $ strQuery = Environment :: get ( 'queryString' ) ; $ arrQuery = array ( ) ; if ( $ strQuery != '' ) { $ arrChunks = explode ( '&' , $ strQuery ) ; foreach ( $ arrChunks as $ strChunk ) { list ( $ k ) = explode ( '=' , $ strChunk , 2 ) ; $ arrQuery [ ] = $ k ; } } if ( ! empty ( $ _GET ) ) { foreach ( array_keys ( $ _GET ) as $ key ) { if ( Config :: get ( 'addLanguageToUrl' ) && $ key == 'language' ) { continue ; } if ( \ in_array ( $ key , $ arrQuery ) ) { continue ; } if ( $ key == 'auto_item' ) { $ strGet .= '/' . Input :: get ( $ key ) ; } else { $ strGet .= '/' . $ key . '/' . Input :: get ( $ key ) ; } } } if ( $ strQuery != '' ) { $ strQuery = '?' . $ strQuery ; } return $ objNextPage -> getAbsoluteUrl ( $ strGet ) . $ strQuery ; }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
156	public function addSelect ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ columns = $ this -> getUniqueColumns ( $ columns ) ; if ( $ this -> select === null ) { $ this -> select = $ columns ; } else { $ this -> select = array_merge ( $ this -> select , $ columns ) ; } return $ this ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
2065	public function checkJumpTo ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> id ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'circularReference' ] ) ; } return $ varValue ; }
4124	private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; }
3729	protected function getAttributeImplementing ( $ interface ) { $ result = array ( ) ; foreach ( $ this -> getAttributes ( ) as $ colName => $ attribute ) { if ( $ attribute instanceof $ interface ) { $ result [ $ colName ] = $ attribute ; } } return $ result ; }
2875	public function getCategory ( $ timerName ) { $ category = self :: CORE_CATEGORY ; if ( strpos ( $ timerName , 'mage::dispatch' ) === 0 || strpos ( $ timerName , 'column.phtml' ) > 0 ) { $ category = self :: SECTION ; } else if ( strpos ( $ timerName , 'Model_Resource' ) > 0 ) { $ category = self :: DB_CATEGORY ; } else if ( strpos ( $ timerName , 'EAV' ) === 0 || strpos ( $ timerName , '_LOAD_ATTRIBUTE_' ) === 0 || strpos ( $ timerName , '__EAV_' ) === 0 ) { $ category = self :: EAV_CATEGORY ; } else if ( strpos ( $ timerName , 'CORE::create_object_of' ) === 0 ) { $ category = self :: CORE_CATEGORY ; } else if ( strpos ( $ timerName , 'OBSERVER' ) === 0 || strpos ( $ timerName , 'DISPATCH EVENT' ) === 0 ) { $ category = self :: EVENT_CATEGORY ; } else if ( strpos ( $ timerName , 'BLOCK' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'init_config' ) === 0 ) { $ category = self :: CONFIG_CATEGORY ; } else if ( strpos ( $ timerName , 'layout/' ) === 0 || strpos ( $ timerName , 'layout_' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'Mage_Core_Model_Design' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , '.phtml' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } return $ category ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
7584	protected function extractResponse ( $ curlResponse ) { $ this -> headers = substr ( $ curlResponse , 0 , $ this -> info [ 'header_size' ] ) ; $ this -> body = substr ( $ curlResponse , $ this -> info [ 'header_size' ] ) ; }
5862	protected function expandValuesInRuleset ( array $ ruleset ) { $ values = [ ] ; foreach ( $ ruleset as $ key => $ value ) { switch ( $ key ) { case 'usergroup' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; break ; case 'directories' : $ values [ 'directories_config' ] = '' ; $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; foreach ( $ value as & $ directory ) { $ directory = rtrim ( $ directory , '/' ) . '/' ; if ( ! empty ( $ values [ 'directories_config' ] ) ) { $ values [ 'directories_config' ] .= ',' ; } $ values [ 'directories_config' ] .= $ directory ; $ directory = $ this -> getDirectoryPattern ( $ directory ) ; } if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'file_types' : $ value = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; if ( count ( $ value ) == 0 ) { $ value = '' ; } break ; case 'threshold' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'K' ? 1024 : ( $ unit === 'M' ? 1024 * 1024 : 0 ) ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } case 'max_width' : case 'max_height' : if ( $ value <= 0 ) { $ value = '' ; } break ; case 'max_size' : if ( ! is_numeric ( $ value ) ) { $ unit = strtoupper ( substr ( $ value , - 1 ) ) ; $ factor = 1 * ( $ unit === 'M' ? 1000000 : 1 ) ; $ value = intval ( trim ( substr ( $ value , 0 , strlen ( $ value ) - 1 ) ) ) * $ factor ; } break ; case 'conversion_mapping' : if ( strpos ( $ value , CRLF ) !== false ) { $ mapping = GeneralUtility :: trimExplode ( CRLF , $ value , true ) ; } else { $ mapping = GeneralUtility :: trimExplode ( ',' , $ value , true ) ; } if ( count ( $ mapping ) > 0 ) { $ value = $ this -> expandConversionMapping ( $ mapping ) ; } else { $ value = '' ; } break ; } $ values [ $ key ] = $ value ; } return $ values ; }
11625	public function processContent ( Operation $ operation , $ data ) { if ( is_array ( $ data ) ) { $ status = $ this -> contentService -> getSocialMediaScheduleByOperation ( $ operation ) ; if ( ! $ data [ 'locations' ] instanceof ArrayCollection ) { $ locations = $ this -> em -> getRepository ( 'CampaignChainCoreBundle:Location' ) -> findById ( array_values ( $ data [ 'locations' ] ) ) ; $ locations = new ArrayCollection ( $ locations ) ; } else { $ locations = $ data [ 'locations' ] ; } $ status -> setLocations ( $ locations ) ; $ status -> setMessage ( $ data [ 'message' ] ) ; } else { $ status = $ data ; } return $ status ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
10735	public function setUpper ( $ upper ) : self { if ( ! is_numeric ( $ upper ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, upper, to be a number" ) ; } $ this -> upper = $ upper ; return $ this ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
12787	public static function getPut ( ) { $ aPut = array ( ) ; $ rPutResource = fopen ( "php://input" , "r" ) ; while ( $ sData = fread ( $ rPutResource , 1024 ) ) { $ aSeparatePut = explode ( '&' , $ sData ) ; foreach ( $ aSeparatePut as $ sOne ) { $ aOnePut = explode ( '=' , $ sOne ) ; $ aPut [ $ aOnePut [ 0 ] ] = $ aOnePut [ 1 ] ; } } return $ aPut ; }
9111	protected function getConfig ( ) { $ config = $ this -> getServiceLocator ( ) -> get ( 'config' ) ; if ( isset ( $ config [ 'yima-theme' ] ) && is_array ( $ config [ 'yima-theme' ] ) ) { $ config = $ config [ 'yima-theme' ] ; } else { $ config = array ( ) ; } return $ config ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
11021	private function findTasks ( ) { if ( $ this -> init ) return ; $ resolver = $ this -> app -> moduleManager ; $ modules = $ resolver -> getModules ( ) ; foreach ( $ modules as $ mod ) $ mod -> registerTasks ( $ this ) ; Hook :: execute ( "Wedeto.Application.Task.TaskRunner.findTasks" , [ 'taskrunner' => $ this ] ) ; $ this -> init = true ; }
6460	public function radioAction ( $ customized , $ selector ) { $ field = $ this -> getWorkingElement ( ) -> findField ( $ selector ) ; $ customized = ( bool ) $ customized ; if ( $ field !== null && ! $ customized ) { $ field -> selectOption ( $ field -> getAttribute ( 'value' ) ) ; return ; } foreach ( $ this -> findLabels ( $ selector ) as $ label ) { if ( $ customized && ! $ label -> isVisible ( ) ) { continue ; } $ label -> click ( ) ; return ; } $ this -> throwNoSuchElementException ( $ selector , $ field ) ; }
12663	static public function getMessage ( $ code = self :: CODE_INTERNAL_SERVER_ERROR ) { if ( isset ( self :: $ messages [ $ code ] ) ) { return self :: $ messages [ $ code ] ; } return self :: $ messages [ self :: CODE_INTERNAL_SERVER_ERROR ] ; }
8346	public static function route ( $ method , $ path , $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'route' , 'method' => $ method , 'path' => $ path , 'action' => $ action , 'namespace' => self :: $ namespace , 'subdomain' => self :: $ subdomain , 'uri' => self :: $ uri ) ; } }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
2887	public function onLayoutGenerate ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ layout = $ observer -> getData ( 'layout' ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; $ layoutBlocks = $ layout -> getAllBlocks ( ) ; foreach ( $ layoutBlocks as $ block ) { if ( ! $ this -> canCaptureBlock ( $ block ) ) { continue ; } $ requestInfo -> addBlock ( $ block ) ; } $ design = Mage :: getSingleton ( 'core/design_package' ) ; $ requestInfo -> addLayout ( $ layout , $ design ) ; $ this -> saveProfiling ( ) ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
3408	public function getLockFactory ( ) : Factory { if ( $ this -> lockFactory !== null ) { return $ this -> lockFactory ; } if ( ! is_dir ( $ this -> lockPath ) ) { ( new Filesystem ( ) ) -> mkdir ( $ this -> lockPath ) ; } $ store = new FlockStore ( $ this -> lockPath ) ; return $ this -> setLockStore ( $ store ) ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
3480	public function withLaunchImage ( string $ launchImage ) : Alert { $ cloned = clone $ this ; $ cloned -> launchImage = $ launchImage ; return $ cloned ; }
154	public function populate ( $ rows ) { if ( $ this -> indexBy === null ) { return $ rows ; } $ result = [ ] ; foreach ( $ rows as $ row ) { $ result [ ArrayHelper :: getValue ( $ row , $ this -> indexBy ) ] = $ row ; } return $ result ; }
7182	protected function generateKey ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ payment ) ; return true ; } return false ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
11066	public function addMethods ( $ mixin , array $ methods ) { foreach ( $ methods as $ method ) { $ this -> method_map [ $ method ] = $ mixin ; } return $ this ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
1019	public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; }
531	protected function splitChangelog ( $ file , $ version ) { $ lines = explode ( "\n" , file_get_contents ( $ file ) ) ; $ start = [ ] ; $ changelog = [ ] ; $ end = [ ] ; $ state = 'start' ; foreach ( $ lines as $ l => $ line ) { if ( isset ( $ lines [ $ l - 2 ] ) && strpos ( $ lines [ $ l - 2 ] , $ version ) !== false && isset ( $ lines [ $ l - 1 ] ) && strncmp ( $ lines [ $ l - 1 ] , '---' , 3 ) === 0 ) { $ state = 'changelog' ; } if ( $ state === 'changelog' && isset ( $ lines [ $ l + 1 ] ) && strncmp ( $ lines [ $ l + 1 ] , '---' , 3 ) === 0 ) { $ state = 'end' ; } if ( ! empty ( $ { $ state } ) && trim ( $ line ) !== '' && strncmp ( $ line , '- ' , 2 ) !== 0 ) { end ( $ { $ state } ) ; $ { $ state } [ key ( $ { $ state } ) ] .= "\n" . $ line ; } else { $ { $ state } [ ] = $ line ; } } return [ $ start , $ changelog , $ end ] ; }
7172	protected function resolveSaleTargetCountry ( SaleInterface $ sale ) : ? CountryInterface { if ( null !== $ country = $ sale -> getDeliveryCountry ( ) ) { return $ country ; } if ( null !== $ customer = $ sale -> getCustomer ( ) ) { return $ this -> resolveCustomerTargetCountry ( $ customer ) ; } return null ; }
3395	protected function attemptLogin ( Request $ request ) { if ( $ this -> guard ( ) -> validate ( $ this -> credentials ( $ request ) ) ) { $ user = $ this -> guard ( ) -> getLastAttempted ( ) ; if ( ! is_null ( $ user -> confirmed_at ) ) { return $ this -> baseAttemptLogin ( $ request ) ; } session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } return false ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
6622	public function add_styles ( ) { $ css = App :: EFG ( ) -> getOption ( 'assets' , 'css' ) ; WP_Register :: add ( 'style' , $ css [ 'extensionsForGrifusAdmin' ] ) ; WP_Register :: add ( 'style' , Module :: CustomRatingGrifus ( ) -> getOption ( 'assets' , 'css' , 'customRatingGrifusAdmin' ) ) ; }
980	public function api ( ) { if ( ! $ this -> api ) { $ shopDomain = $ this -> shopify_domain ; $ token = $ this -> session ( ) -> getToken ( ) ; $ this -> api = ShopifyApp :: api ( ) ; $ this -> api -> setSession ( $ shopDomain , $ token ) ; } return $ this -> api ; }
11325	public static function hasSuffix ( $ string , $ suffix ) { $ len = strlen ( $ suffix ) ; if ( $ len && substr ( $ string , - $ len ) === $ suffix ) { return true ; } return false ; }
12117	public static function displayConsoleException ( \ Throwable $ Throwable ) { ob_start ( ) ; echo PHP_EOL . ' ' ; echo ( ( $ Throwable instanceof PHPAssertionFailed ) ? 'Assertion Failed' : 'Uncaught ' . self :: getShortName ( get_class ( $ Throwable ) ) ) ; echo ' <' . basename ( $ Throwable -> getFile ( ) ) . ':' . $ Throwable -> getLine ( ) . '>' ; echo PHP_EOL . PHP_EOL . ' ' ; if ( $ Throwable instanceof PHPAssertionFailed ) { $ message = $ Throwable -> getExpression ( ) ; if ( $ message == '' ) { $ message = 'false' ; } } else { $ message = $ Throwable -> getMessage ( ) ; } echo wordwrap ( $ message , self :: CONSOLE_WIDTH - 2 , PHP_EOL . ' ' ) ; echo PHP_EOL . PHP_EOL . ' Stack Trace:' . PHP_EOL . PHP_EOL ; if ( $ Throwable instanceof BaseException || $ Throwable instanceof PHPErrorException ) { $ trace = $ Throwable -> getStackTrace ( ) ; } else { $ trace = array_reverse ( $ Throwable -> getTrace ( ) ) ; } $ trace_empty = [ 'class' => '' , 'type' => '' , 'function' => '' , 'file' => '{unknown}' , 'line' => 0 ] ; foreach ( $ trace as $ key => $ trace_item ) { $ trace_item = array_merge ( $ trace_empty , $ trace_item ) ; $ trace_item [ 'file' ] = basename ( $ trace_item [ 'file' ] ) ; if ( $ trace_item [ 'function' ] != '{closure}' ) { $ trace_item [ 'function' ] .= '()' ; } $ key ++ ; echo str_pad ( " $key. " , 6 , ' ' ) ; echo self :: getShortName ( $ trace_item [ 'class' ] ) . $ trace_item [ 'type' ] . $ trace_item [ 'function' ] ; echo " <{$trace_item['file']}:{$trace_item['line']}>" . PHP_EOL ; } return ob_get_clean ( ) ; }
10332	public function setSize ( $ width , $ height ) { if ( ! is_string ( $ width ) && ! is_int ( $ width ) ) { throw new \ InvalidArgumentException ( 'The width argument must be of type string or integer' ) ; } if ( ! is_string ( $ height ) && ! is_int ( $ height ) ) { throw new \ InvalidArgumentException ( 'The height argument must be of type string or integer' ) ; } $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " width=\"" . $ width . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)[\"\']([0-9\.]+)[\"\']/" , " height=\"" . $ height . "\"" , $ this -> html ) ; $ this -> html = preg_replace ( "/width:([0-9\.]+)px/" , "width:" . ( is_numeric ( $ width ) ? $ width . 'px' : $ width ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/height:([0-9\.]+)px/" , "height:" . ( is_numeric ( $ height ) ? $ height . 'px' : $ height ) . "" , $ this -> html ) ; $ this -> html = preg_replace ( "/ width([ ]?)=([ ]?)([0-9\.]+)/" , " width=" . $ width , $ this -> html ) ; $ this -> html = preg_replace ( "/ height([ ]?)=([ ]?)([0-9\.]+)/" , " height=" . $ height , $ this -> html ) ; $ this -> width = $ width ; $ this -> height = $ height ; }
5812	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ tagging = array ( ) ; foreach ( $ this -> owner -> FusionTags ( ) as $ tag ) { $ tagging [ ] = $ tag -> Title ; } } else { $ this -> owner -> FusionTags ( ) -> removeAll ( ) ; $ tagging = array ( ) ; foreach ( $ types as $ relationship => $ type ) { foreach ( $ this -> owner -> $ relationship ( ) as $ tag ) { $ fusion = FusionTag :: get ( ) -> byID ( $ tag -> FusionTagID ) ; $ this -> owner -> FusionTags ( ) -> add ( $ fusion ) ; $ tagging [ ] = $ fusion -> Title ; } } } $ this -> owner -> Tagging = implode ( ' ' , $ tagging ) ; }
12560	public function fixFileSlashes ( $ file , & $ contents ) { $ changed = false ; foreach ( $ contents as $ lineNumber => $ line ) { if ( preg_match ( '/(psesd|canis|cascade)\\\\\\\/' , $ line ) === 1 ) { $ fixedLine = preg_replace ( '/\\\\\\\/' , '\\' , $ line ) ; if ( $ fixedLine !== $ line ) { $ contents [ $ lineNumber ] = $ fixedLine ; $ changed = true ; } } } return $ changed ; }
6071	public function uploadFileChunked ( $ fileData , $ name , $ chunk , $ chunks , $ fileId , $ categoryId , $ title = null ) { $ parameters = [ 'query' => [ 'name' => $ name , 'chunk' => $ chunk , 'chunks' => $ chunks , 'fileId' => $ fileId , 'categoryId' => $ categoryId , 'title' => $ title , ] , 'multipart' => [ [ 'name' => 'file' , 'contents' => \ GuzzleHttp \ Psr7 \ stream_for ( $ fileData ) , 'filename' => $ name , ] , ] , 'headers' => null , ] ; $ result = $ this -> post ( 'v1/media.json' , $ parameters ) ; return $ result ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
3144	public function finish ( RunnerServiceContext $ context , $ finalState = DeliveryExecution :: STATE_FINISHED ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ executionUri = $ context -> getTestExecutionUri ( ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ executionService = ServiceProxy :: singleton ( ) ; $ deliveryExecution = $ executionService -> getDeliveryExecution ( $ executionUri ) ; if ( $ deliveryExecution -> getUserIdentifier ( ) == $ userUri ) { \ common_Logger :: i ( "Finishing the delivery execution {$executionUri}" ) ; $ result = $ deliveryExecution -> setState ( $ finalState ) ; } else { \ common_Logger :: w ( "Non owner {$userUri} tried to finish deliveryExecution {$executionUri}" ) ; $ result = false ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ executionUri ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'finish' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
5455	public function addContent ( $ text ) { if ( isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag -> addContent ( $ text ) ; } else { $ this -> addContentToAllOpenTags ( $ text ) ; } return true ; }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
8958	public function validateResponse ( $ url , $ response ) { if ( $ response -> code != 200 ) { $ error = htmlspecialchars ( $ response -> body ) ; throw new \ DomainException ( $ error , $ response -> code ) ; } }
5322	public function lockExecute ( callable $ callable ) { $ this -> isAcquired = $ this -> acquire ( ) ; $ result = $ callable ( ) ; $ this -> isAcquired = $ this -> release ( ) ; return $ result ; }
10925	private function renderRow ( array $ row ) { $ output = [ ] ; $ output [ ] = $ this -> charVertical ; $ columnNumber = 0 ; foreach ( $ row as $ column => $ value ) { $ output [ ] = $ this -> renderCell ( $ columnNumber , $ value , ' ' ) ; $ output [ ] = $ this -> charVertical ; $ columnNumber ++ ; } return implode ( '' , $ output ) ; }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
3261	public static function placeOrder ( $ cart = null ) { try { if ( empty ( static :: $ gatewayKey ) ) throw new ShopException ( 'Payment gateway not selected.' ) ; if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; $ order = $ cart -> placeOrder ( ) ; $ statusCode = $ order -> statusCode ; \ event ( new OrderPlaced ( $ order -> id ) ) ; static :: $ gateway -> setCallbacks ( $ order ) ; if ( static :: $ gateway -> onCharge ( $ order ) ) { $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } catch ( GatewayException $ e ) { static :: $ exception = $ e ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } if ( $ order ) { static :: checkStatusChange ( $ order , $ statusCode ) ; return $ order ; } else { return ; } }
6580	public static function fromPolar ( $ length , $ ap , $ av ) { return new static ( $ length * cos ( $ ap ) * cos ( $ av ) , $ length * sin ( $ ap ) * cos ( $ av ) , $ length * sin ( $ av ) ) ; }
9495	public function createService ( ) { $ host = $ this -> getParameters ( ) -> get ( 'host' ) ; $ port = $ this -> getParameters ( ) -> get ( 'port' ) ; $ timeout = $ this -> getParameters ( ) -> get ( 'timeout' ) ; if ( is_null ( $ host ) || is_null ( $ port ) ) { throw new \ Exception ( 'No sphinx server information found within the configuration!' ) ; } $ sphinxClient = new SphinxClient ( ) ; $ sphinxClient -> SetServer ( $ host , $ port ) ; $ sphinxClient -> SetConnectTimeout ( $ timeout ) ; $ sphinxClient -> SetArrayResult ( true ) ; $ sphinxClient -> setMatchModeByModeName ( 'any' ) ; $ sphinxClient -> SetSortMode ( SPH_SORT_RELEVANCE ) ; $ sphinxClient -> SetRankingMode ( SPH_RANK_PROXIMITY ) ; return $ sphinxClient ; }
3991	public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; }
1756	public static function setCookie ( $ strName , $ varValue , $ intExpires , $ strPath = null , $ strDomain = null , $ blnSecure = false , $ blnHttpOnly = false ) { if ( $ strPath == '' ) { $ strPath = Environment :: get ( 'path' ) ? : '/' ; } $ objCookie = new \ stdClass ( ) ; $ objCookie -> strName = $ strName ; $ objCookie -> varValue = $ varValue ; $ objCookie -> intExpires = $ intExpires ; $ objCookie -> strPath = $ strPath ; $ objCookie -> strDomain = $ strDomain ; $ objCookie -> blnSecure = $ blnSecure ; $ objCookie -> blnHttpOnly = $ blnHttpOnly ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setCookie' ] as $ callback ) { $ objCookie = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objCookie ) ; } } setcookie ( $ objCookie -> strName , $ objCookie -> varValue , $ objCookie -> intExpires , $ objCookie -> strPath , $ objCookie -> strDomain , $ objCookie -> blnSecure , $ objCookie -> blnHttpOnly ) ; }
4802	protected function locateDirectory ( string $ name ) : ? string { $ parts = [ $ name ] ; foreach ( Database :: COLLECTION_SEPARATOR_CHARACTERS as $ char ) { if ( ! strstr ( $ name , $ char ) ) { continue ; } $ parts = explode ( $ char , $ name ) ; break ; } return $ this -> recurseLocateDirectory ( $ parts ) ; }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
11304	public static function name ( $ string = null ) { if ( ! $ string ) return null ; return trim ( ucwords ( mb_strtolower ( trim ( $ string ) , "UTF-8" ) ) ) ; }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
6715	protected function getFormatFromUri ( $ requestedUri ) { $ uriParts = explode ( '?' , $ requestedUri , 2 ) ; $ uriWithoutGet = reset ( $ uriParts ) ; $ uriAndFormat = explode ( '.' , $ uriWithoutGet ) ; if ( count ( $ uriAndFormat ) >= 2 ) { return end ( $ uriAndFormat ) ; } return null ; }
12007	final public function getPermissions ( $ authenticated ) { $ this -> userid = ( int ) $ authenticated -> get ( "user_id" ) ; if ( $ authenticated -> authenticated && ! empty ( $ this -> userid ) ) { $ this -> setAuthority ( AUTHROITY_IMPLIED_AUTHENTICATED ) ; } }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
1903	public function limit ( $ intRows , $ intOffset = 0 ) { if ( $ intRows <= 0 ) { $ intRows = 30 ; } if ( $ intOffset < 0 ) { $ intOffset = 0 ; } if ( strncasecmp ( $ this -> strQuery , 'SELECT' , 6 ) === 0 ) { $ this -> strQuery .= ' LIMIT ' . $ intOffset . ',' . $ intRows ; } else { $ this -> strQuery .= ' LIMIT ' . $ intRows ; } return $ this ; }
6666	public function setBodyData ( $ data ) { if ( ! $ data instanceof \ Generator ) { $ this -> body [ static :: DEFAULT_DATA_NAME ] = $ data ; return $ this ; } foreach ( $ data as $ key => $ value ) { $ actualKey = $ key ? : static :: DEFAULT_DATA_NAME ; $ this -> body [ $ actualKey ] = $ value ; } return $ this ; }
7505	public function assignNamespace ( string $ namespace , $ prepend = false ) { if ( $ prepend ) { array_unshift ( $ this -> namespaces , $ namespace ) ; return ; } array_push ( $ this -> namespaces , $ namespace ) ; }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
11947	public function getPriority ( ) { if ( isset ( $ this -> object -> singleWidget ) ) { if ( isset ( $ this -> object -> singleWidget ) && isset ( $ this -> object -> singleWidget -> content -> priorityAdjust ) ) { return $ this -> _priority + $ this -> object -> singleWidget -> content -> priorityAdjust ; } } return $ this -> _priority ; }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1743	public function uploadFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'closed' ] && ! $ GLOBALS [ 'TL_DCA' ] [ 'tl_files' ] [ 'config' ] [ 'notCreatable' ] && Contao \ Input :: get ( 'act' ) != 'select' && isset ( $ row [ 'type' ] ) && $ row [ 'type' ] == 'folder' ) { return '<a href="' . $ this -> addToUrl ( $ href . '&amp;pid=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } return ' ' ; }
11991	private function validateSlug ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SlugException ( "A Slug cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SlugException ( sprintf ( "A Slug cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SlugException ( sprintf ( "The Slug \"%s\" contains invalid characters. A Slug can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too short. The minimum length for a Slug is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SlugException ( sprintf ( "The given Slug \"%s\" is too long (%s character). The maximum length for a Slug is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
4754	public function startProfiling ( ) { if ( PHP_SAPI == 'cli' ) { $ _SERVER [ 'REMOTE_ADDR' ] = null ; $ _SERVER [ 'REQUEST_URI' ] = $ _SERVER [ 'SCRIPT_NAME' ] ; } if ( function_exists ( 'xhprof_enable' ) && count ( $ this -> probes ) > 0 ) { $ this -> profiling = true ; xhprof_enable ( $ this -> memory ? XHPROF_FLAGS_MEMORY : null ) ; } }
2430	public function listStyleSheet ( $ row ) { $ cc = '' ; $ media = Contao \ StringUtil :: deserialize ( $ row [ 'media' ] ) ; if ( $ row [ 'cc' ] != '' ) { $ cc = ' &lt;!--[' . $ row [ 'cc' ] . ']&gt;' ; } if ( $ row [ 'mediaQuery' ] != '' ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . $ row [ 'mediaQuery' ] . $ cc . '</span>' . "</div>\n" ; } elseif ( ! empty ( $ media ) && \ is_array ( $ media ) ) { return '<div class="tl_content_left">' . $ row [ 'name' ] . ' <span style="color:#999;padding-left:3px">@media ' . implode ( ', ' , $ media ) . $ cc . '</span>' . "</div>\n" ; } else { return '<div class="tl_content_left">' . $ row [ 'name' ] . $ cc . "</div>\n" ; } }
11903	public function getDescriptor ( ) { $ logModel = $ this -> getLogModel ( true ) ; if ( empty ( $ logModel ) || ! isset ( $ logModel -> dataInterface ) ) { return 'Unknown Data Interface' ; } return 'Interface: ' . $ logModel -> dataInterface -> name ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
2443	public static function encrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } $ iv = mcrypt_create_iv ( mcrypt_enc_get_iv_size ( static :: $ resTd ) ) ; mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strEncrypted = mcrypt_generic ( static :: $ resTd , $ varValue ) ; $ strEncrypted = base64_encode ( $ iv . $ strEncrypted ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strEncrypted ; }
818	private function fixNewline ( Tokens $ tokens , $ index , $ indentation , $ override = true ) { if ( $ tokens [ $ index + 1 ] -> isComment ( ) ) { return ; } if ( $ tokens [ $ index + 2 ] -> isComment ( ) ) { $ nextMeaningfulTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index + 2 ) ; if ( ! $ this -> isNewline ( $ tokens [ $ nextMeaningfulTokenIndex - 1 ] ) ) { $ tokens -> ensureWhitespaceAtIndex ( $ nextMeaningfulTokenIndex , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; } return ; } $ tokens -> ensureWhitespaceAtIndex ( $ index + 1 , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; }
7726	public function postback ( $ text , $ title , $ postback ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'postback' , 'title' => $ title , 'payload' => $ postback ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
7371	public function editAction ( ) { $ user = $ this -> getUser ( ) ; $ form = $ this -> createForm ( ProfileType :: class , $ user ) ; return array ( 'form' => $ form -> createView ( ) , ) ; }
1859	public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
2419	protected function addTemplatesToArchive ( ZipWriter $ objArchive , $ strFolder ) { $ strFolder = preg_replace ( '@^templates/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strFolder = 'templates' ; } else { $ strFolder = 'templates/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( preg_match ( '/\.(html5|sql)$/' , $ strFile ) && strncmp ( $ strFile , 'be_' , 3 ) !== 0 && strncmp ( $ strFile , 'nl_' , 3 ) !== 0 ) { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile ) ; } } }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
3277	public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; }
8777	public function assets ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ASSETS_FOLDER . '/' . $ data : $ this -> url . '/' . ASSETS_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
2707	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ response = $ this -> api -> getResponse ( $ activeVersion , Config :: WAF_PAGE_RESPONSE_OBJECT ) ; if ( ! $ response ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch WAF page Response object.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'wafPageResp' => $ response ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
6282	public static function buildHttpClient ( LoopInterface $ loop , $ connector = null ) { if ( class_exists ( HttpClientFactory :: class ) ) { return static :: buildHttpClient04 ( $ loop , $ connector ) ; } else { return static :: buildHttpClient05 ( $ loop , $ connector ) ; } }
8479	public function bootstrap ( $ app ) { $ app -> i18n -> translations [ 'devgroup.events-system' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@DevGroup/EventsSystem/messages' , ] ; $ error = [ ] ; try { foreach ( EventHelper :: getActiveHandlersList ( ) as $ handler ) { Event :: on ( $ handler [ 'class' ] , $ handler [ 'name' ] , $ handler [ 'callable' ] , $ handler [ 'data' ] ) ; } } catch ( \ yii \ db \ Exception $ e ) { $ error = [ 'message' => '`DevGroup\EventsSystem` extension is not fully installed yet.' , 'hint' => 'Please run the `./yii migrate --migrationPath=@DevGroup/EventsSystem/migrations` command from your application directory to finish the installation process.' , ] ; } catch ( \ Exception $ e ) { $ error = [ 'message' => $ e -> getCode ( ) , 'hint' => $ e -> getMessage ( ) , ] ; } if ( empty ( $ error ) === false ) { if ( $ app instanceof \ yii \ console \ Application ) { $ app -> on ( Application :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ app , $ error ) { $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL . PHP_EOL ) ; $ app -> controller -> stderr ( $ error [ 'message' ] . PHP_EOL ) ; $ app -> controller -> stdout ( $ error [ 'hint' ] . PHP_EOL ) ; $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL ) ; } ) ; } elseif ( $ app instanceof \ yii \ web \ Application && YII_DEBUG === true ) { $ app -> session -> setFlash ( 'warning' , Html :: tag ( 'h4' , $ error [ 'message' ] ) . Html :: tag ( 'p' , $ error [ 'hint' ] ) ) ; } } }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
6695	public static function applyVisible ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( ! isset ( $ one [ 'visible' ] ) ) { if ( isset ( $ one [ 'permission' ] ) ) { $ authItemModel = Yii :: createObject ( AuthItem :: class ) ; $ one [ 'visible' ] = Yii :: $ app -> user -> can ( $ authItemModel :: SUPER_ADMIN ) || Yii :: $ app -> user -> can ( $ one [ 'permission' ] ) ; } else { if ( is_array ( $ one [ 'url' ] ) ) { $ url = explode ( '/' , trim ( $ one [ 'url' ] [ 0 ] , '/' ) ) ; if ( isset ( $ url [ '0' ] ) && isset ( $ url [ '1' ] ) ) { $ one [ 'visible' ] = Yii :: $ app -> user -> can ( 'Super admin' ) || Yii :: $ app -> user -> can ( $ url [ 0 ] . '/' . $ url [ 1 ] ) ; } } } } if ( isset ( $ one [ 'items' ] ) ) { self :: applyVisible ( $ one [ 'items' ] ) ; } } } }
4854	protected function profiling ( $ signal = true ) { static $ timeStart ; if ( $ signal ) { $ timeStart = microtime ( true ) ; } if ( ! $ signal ) { $ this -> timeExecution = ( microtime ( true ) - $ timeStart ) / 60 ; return $ this -> timeExecution ; } }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
6472	public function getBestEncodingMatch ( IMediaTypeFormatter $ formatter , array $ acceptCharsetHeaders , ? MediaTypeHeaderValue $ mediaTypeHeader ) : ? string { $ rankedAcceptCharsetHeaders = $ this -> rankAcceptCharsetHeaders ( $ acceptCharsetHeaders ) ; foreach ( $ rankedAcceptCharsetHeaders as $ acceptCharsetHeader ) { foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ acceptCharsetHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } } if ( $ mediaTypeHeader === null || $ mediaTypeHeader -> getCharset ( ) === null ) { return null ; } foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ mediaTypeHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } return null ; }
3737	protected function createNewItem ( $ item ) { $ data = [ 'tstamp' => $ item -> get ( 'tstamp' ) ] ; $ isNewItem = false ; if ( $ this -> hasVariants ( ) ) { if ( $ item -> get ( 'vargroup' ) === null ) { $ item -> set ( 'varbase' , '1' ) ; $ item -> set ( 'vargroup' , '0' ) ; $ isNewItem = true ; } $ data [ 'varbase' ] = $ item -> get ( 'varbase' ) ; $ data [ 'vargroup' ] = $ item -> get ( 'vargroup' ) ; } $ connection = $ this -> getConnection ( ) ; $ builder = $ connection -> createQueryBuilder ( ) ; $ parameters = [ ] ; foreach ( array_keys ( $ data ) as $ key ) { $ parameters [ $ key ] = ':' . $ key ; } $ builder -> insert ( $ this -> getTableName ( ) ) -> values ( $ parameters ) -> setParameters ( $ data ) -> execute ( ) ; $ item -> set ( 'id' , $ connection -> lastInsertId ( ) ) ; if ( $ isNewItem ) { $ this -> saveSimpleColumn ( 'vargroup' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'id' ) ) ; } }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
8694	public static function parse ( $ size , $ fallbackUnits = null ) { preg_match ( '/^(\d+)[.,]?(\d*)\s*(\w*)$/' , $ size , $ matches ) ; if ( empty ( $ matches [ 1 ] ) || ( empty ( $ matches [ 3 ] ) && null === $ fallbackUnits ) ) { throw new \ UnexpectedValueException ( "Unable to parse : '{$size}'" ) ; } $ oSize = $ matches [ 1 ] ; if ( ! empty ( $ matches [ 2 ] ) ) { $ oSize .= '.' . $ matches [ 2 ] ; } $ oSize = ( float ) $ oSize ; $ unit = strtolower ( empty ( $ matches [ 3 ] ) ? $ fallbackUnits : $ matches [ 3 ] ) ; $ byteMultiplier = 1 ; if ( 'b' === substr ( $ unit , - 1 ) ) { $ byteMultiplier = 8 ; $ unit = substr ( $ unit , 0 , - 1 ) . 'o' ; } if ( ! array_key_exists ( $ unit , self :: getBinarySizes ( ) ) ) { throw new \ UnexpectedValueException ( "Unexpected unit {$unit}" ) ; } return ( int ) ( $ oSize * self :: getBinarySizes ( ) [ $ unit ] * $ byteMultiplier ) ; }
11954	public function resetAllPropertiesExcept ( $ properties = array ( ) ) { foreach ( $ this -> obj_to_db_trans as $ obj_prop => $ db_field ) { if ( ! in_array ( $ obj_prop , $ this -> key_properties ) && ! in_array ( $ obj_prop , $ properties ) ) { $ this -> { $ obj_prop } = null ; } } }
1661	public function render ( ) { $ mediaObject = [ ] ; $ mediaObject [ 'contentUrl' ] = $ this -> url ; if ( $ this -> name ) { $ mediaObject [ 'name' ] = $ this -> name ; } if ( $ this -> description ) { $ mediaObject [ 'description' ] = $ this -> description ; } if ( $ this -> icon ) { $ mediaObject [ 'icon' ] = [ 'url' => $ this -> icon ] ; } if ( $ this -> image ) { $ mediaObject [ 'largeImage' ] = [ 'url' => $ this -> image ] ; } return $ mediaObject ; }
7498	public function createAndSendMessageFromTemplate ( ) { $ args = func_get_args ( ) ; if ( empty ( $ args [ 0 ] ) ) { throw new \ RuntimeException ( 'First parameter must be a template filename or EmailTemplate entity' ) ; } elseif ( $ args [ 0 ] instanceof EmailTemplate ) { $ method = 'createMessageFromTemplateEntity' ; } else { $ method = 'createMessageFromTemplateFile' ; } $ message = call_user_func_array ( array ( $ this , $ method ) , $ args ) ; $ this -> mailer -> send ( $ message ) ; return true ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
1073	private function getSuggestedFieldNames ( Schema $ schema , $ type , $ fieldName ) { if ( $ type instanceof ObjectType || $ type instanceof InterfaceType ) { $ possibleFieldNames = array_keys ( $ type -> getFields ( ) ) ; return Utils :: suggestionList ( $ fieldName , $ possibleFieldNames ) ; } return [ ] ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
12528	public function getLocalDataSource ( $ localModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> localModel === $ localModelClass ) { return $ dataSource ; } } return false ; }
7210	public function getAutoLoginUrl ( array $ autoUrl , array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ autoUrl [ '?' ] [ 't' ] = $ this -> generateLoginToken ( $ redirectUrl , $ expireInterval , $ addRememberMeCookie ) ; $ url = Router :: url ( $ autoUrl , true ) ; $ urlLength = strlen ( $ url ) ; if ( strlen ( $ url ) > 2080 ) { throw new \ Exception ( 'Generated url "' . $ url . '" is too long' ) ; } return $ url ; }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
5831	public function sendRequest ( Request $ request ) { $ this -> prepareRequest ( $ request ) ; $ result = curl_exec ( $ this -> ch ) ; if ( $ result === false ) { throw new \ RuntimeException ( "cURL request failed with error: " . curl_error ( $ this -> ch ) ) ; } $ response = $ this -> createResponseObject ( $ result ) ; curl_close ( $ this -> ch ) ; return $ response ; }
6752	public static function getCallable ( Logger $ logger , $ type , $ maxMessageLength ) { return function ( MessageInterface $ message ) use ( $ logger , $ type , $ maxMessageLength ) { $ startMessage = null ; if ( $ message instanceof RequestInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getMethod ( ) , $ message -> getRequestTarget ( ) ) ; } elseif ( $ message instanceof ResponseInterface ) { $ startMessage = sprintf ( 'Proxy %s start: HTTP/%s %s %s' , $ type , $ message -> getProtocolVersion ( ) , $ message -> getStatusCode ( ) , $ message -> getReasonPhrase ( ) ) ; } if ( ! is_null ( $ startMessage ) ) { $ logger -> log ( Logger :: INFO , $ startMessage ) ; } foreach ( $ message -> getHeaders ( ) as $ name => $ value ) { $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s header: %s => %s" , $ type , $ name , implode ( ', ' , $ value ) ) ) ; } $ body = $ message -> getBody ( ) ; if ( strlen ( $ body ) > $ maxMessageLength ) { $ body = substr ( $ body , 0 , $ maxMessageLength ) . '[TRUNCATED]' ; } $ logger -> log ( Logger :: INFO , sprintf ( "Proxy %s body: %s" , $ type , $ body ) ) ; if ( ! is_null ( $ message ) && $ message -> getBody ( ) -> isSeekable ( ) ) { $ message -> getBody ( ) -> rewind ( ) ; } return $ message ; } ; }
7516	protected function expect ( $ token , $ do_next = true , $ try_next = false , $ next_on_match = 1 ) { if ( $ do_next ) { if ( $ do_next === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } if ( is_int ( $ token ) ) { if ( ( $ this -> token !== $ token ) && ( ( ! $ try_next ) || ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== $ token ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== $ token ) ) ) ) ) { $ this -> addError ( 'Unexpected "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } else { if ( ( $ this -> doc [ $ this -> pos ] !== $ token ) && ( ( ! $ try_next ) || ( ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== self :: TOK_NULL ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== self :: TOK_NULL ) ) ) && ( $ this -> doc [ $ this -> pos ] !== $ token ) ) ) ) { $ this -> addError ( 'Expected "' . $ token . '", but found "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } if ( $ next_on_match ) { if ( $ next_on_match === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } return true ; }
6453	private function createBody ( IHttpRequestMessage $ request , $ rawBody , ContentNegotiationResult & $ contentNegotiationResult = null ) : ? IHttpBody { if ( $ rawBody === null || $ rawBody instanceof IHttpBody ) { return $ rawBody ; } if ( $ rawBody instanceof IStream ) { return new StreamBody ( $ rawBody ) ; } if ( is_scalar ( $ rawBody ) ) { return new StringBody ( ( string ) $ rawBody ) ; } if ( ( ! is_object ( $ rawBody ) && ! is_array ( $ rawBody ) ) || is_callable ( $ rawBody ) ) { throw new InvalidArgumentException ( 'Unsupported body type ' . gettype ( $ rawBody ) ) ; } $ type = TypeResolver :: resolveType ( $ rawBody ) ; $ contentNegotiationResult = $ this -> contentNegotiator -> negotiateResponseContent ( $ type , $ request ) ; $ mediaTypeFormatter = $ contentNegotiationResult -> getFormatter ( ) ; if ( $ mediaTypeFormatter === null ) { throw $ this -> createNotAcceptableException ( $ type ) ; } $ bodyStream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; try { $ mediaTypeFormatter -> writeToStream ( $ rawBody , $ bodyStream , $ contentNegotiationResult -> getEncoding ( ) ) ; } catch ( SerializationException $ ex ) { throw new HttpException ( HttpStatusCodes :: HTTP_INTERNAL_SERVER_ERROR , 'Failed to serialize response body' , 0 , $ ex ) ; } return new StreamBody ( $ bodyStream ) ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
5048	protected function callPlugin ( $ name , $ args ) { $ controller = $ this -> getController ( ) ; $ plugin = $ controller -> plugin ( $ name ) ; unset ( $ args [ 'as' ] ) ; array_push ( $ args , $ this -> parameters ) ; return call_user_func_array ( $ plugin , $ args ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
1126	public function isSelfOrDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) >= $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
7512	function next ( ) { $ this -> token_start = null ; if ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { return ( $ this -> token = self :: TOK_NULL ) ; } }
3609	public function getUserLocations ( ) { $ this -> prepareForGet ( ) ; $ structures = ( array ) $ this -> last_status -> structure ; $ user_structures = array ( ) ; $ class_name = get_class ( $ this ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ structures as $ struct_id => $ structure ) { $ protects = array ( ) ; foreach ( $ topaz as $ protect ) { if ( $ protect -> structure_id == $ struct_id ) { $ protects [ ] = $ protect -> serial_number ; } } $ weather_data = $ this -> getWeather ( $ structure -> postal_code , $ structure -> country_code ) ; $ user_structures [ ] = ( object ) array ( 'name' => isset ( $ structure -> name ) ? $ structure -> name : '' , 'address' => ! empty ( $ structure -> street_address ) ? $ structure -> street_address : NULL , 'city' => $ structure -> location , 'postal_code' => $ structure -> postal_code , 'country' => $ structure -> country_code , 'outside_temperature' => $ weather_data -> outside_temperature , 'outside_humidity' => $ weather_data -> outside_humidity , 'away' => $ structure -> away , 'away_last_changed' => date ( DATETIME_FORMAT , $ structure -> away_timestamp ) , 'thermostats' => array_map ( array ( $ class_name , 'cleanDevices' ) , $ structure -> devices ) , 'protects' => $ protects , ) ; } return $ user_structures ; }
5301	public function getCss ( ) { $ css = '' ; foreach ( $ this -> getGlyphNames ( ) as $ unicode => $ name ) { $ css .= ".icon-" . $ name . ":before {" . "\n" ; $ css .= "\tcontent: \"\\" . $ unicode . "\";\n" ; $ css .= "}\n" ; } return $ css ; }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
6598	protected function getParameters ( array $ lines ) { $ comment = implode ( "\n" , $ lines ) ; preg_match_all ( '/@param\s([\s\S]+?(?=@))/' , $ comment , $ paramsDoc ) ; $ params = [ ] ; if ( isset ( $ paramsDoc [ 1 ] ) ) { foreach ( $ paramsDoc [ 1 ] as $ paramDoc ) { $ documentation = [ ] ; preg_match ( '/([^$]+)?\$(\w+)(.+)?/s' , $ paramDoc , $ documentation ) ; list ( , $ type , $ name , $ description ) = $ documentation ; $ lines = preg_split ( "/((\r?\n)|(\r\n?))/" , $ description ) ; foreach ( $ lines as $ key => $ value ) { $ value = preg_replace ( '/\r/' , '' , $ value ) ; $ value = preg_replace ( '/^\s+\*/' , '' , $ value ) ; $ value = trim ( $ value ) ; $ lines [ $ key ] = $ value ; } $ description = implode ( "\n" , $ lines ) ; $ params [ $ name ] = [ 'type' => trim ( $ type ) , 'description' => trim ( $ description ) , ] ; } } return $ params ; }
6289	public function set ( $ theme ) { if ( ! $ this -> has ( $ theme ) ) { throw new ThemeNotFoundException ( $ theme ) ; } $ this -> loadTheme ( $ theme ) ; }
901	public function getMethodAttributes ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ token -> getName ( ) ) ) ; } $ attributes = [ 'visibility' => null , 'static' => false , 'abstract' => false , 'final' => false , ] ; for ( $ i = $ index ; $ i >= 0 ; -- $ i ) { $ tokenIndex = $ tokens -> getPrevMeaningfulToken ( $ i ) ; $ i = $ tokenIndex ; $ token = $ tokens [ $ tokenIndex ] ; if ( $ token -> isGivenKind ( T_STATIC ) ) { $ attributes [ 'static' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_FINAL ) ) { $ attributes [ 'final' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_ABSTRACT ) ) { $ attributes [ 'abstract' ] = true ; continue ; } if ( $ token -> isGivenKind ( T_PRIVATE ) ) { $ attributes [ 'visibility' ] = T_PRIVATE ; continue ; } if ( $ token -> isGivenKind ( T_PROTECTED ) ) { $ attributes [ 'visibility' ] = T_PROTECTED ; continue ; } if ( $ token -> isGivenKind ( T_PUBLIC ) ) { $ attributes [ 'visibility' ] = T_PUBLIC ; continue ; } break ; } return $ attributes ; }
9885	private function writeDefinedNameForNamedRange ( XMLWriter $ objWriter , NamedRange $ pNamedRange ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , $ pNamedRange -> getName ( ) ) ; if ( $ pNamedRange -> getLocalOnly ( ) ) { $ objWriter -> writeAttribute ( 'localSheetId' , $ pNamedRange -> getScope ( ) -> getParent ( ) -> getIndex ( $ pNamedRange -> getScope ( ) ) ) ; } $ range = Coordinate :: splitRange ( $ pNamedRange -> getRange ( ) ) ; $ iMax = count ( $ range ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ range [ $ i ] [ 0 ] = '\'' . str_replace ( "'" , "''" , $ pNamedRange -> getWorksheet ( ) -> getTitle ( ) ) . '\'!' . Coordinate :: absoluteReference ( $ range [ $ i ] [ 0 ] ) ; if ( isset ( $ range [ $ i ] [ 1 ] ) ) { $ range [ $ i ] [ 1 ] = Coordinate :: absoluteReference ( $ range [ $ i ] [ 1 ] ) ; } } $ range = Coordinate :: buildRange ( $ range ) ; $ objWriter -> writeRawData ( $ range ) ; $ objWriter -> endElement ( ) ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
7852	protected function dispatchWorkflow ( $ workflow ) { $ job = $ this -> inflector -> getJob ( ) ; $ request = $ this -> resolveRequest ( ) ; $ pipes = $ this -> pipelines -> getPipesByPipeline ( $ workflow ) ; $ parameters = $ this -> container -> make ( 'router' ) -> current ( ) -> parameters ( ) ; return $ this -> dispatcher -> pipeThrough ( $ pipes ) -> dispatchFrom ( $ job , $ request , $ parameters ) ; }
6368	private function parseWithMode ( $ raw_taf , $ strict ) { $ clean_taf = trim ( $ raw_taf ) ; $ clean_taf = preg_replace ( "#\n+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( "#\r+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( '#[ ]{2,}#' , ' ' , $ clean_taf ) . ' ' ; $ clean_taf = strtoupper ( $ clean_taf ) ; if ( strpos ( $ clean_taf , 'CNL' ) === false ) { $ remaining_taf = trim ( $ clean_taf ) . ' END' ; } else { $ remaining_taf = $ clean_taf ; } $ decoded_taf = new DecodedTaf ( $ clean_taf ) ; $ with_cavok = false ; foreach ( $ this -> decoder_chain as $ chunk_decoder ) { try { $ decoded = $ chunk_decoder -> parse ( $ remaining_taf , $ with_cavok ) ; $ result = $ decoded [ 'result' ] ; if ( $ result != null ) { foreach ( $ result as $ key => $ value ) { if ( $ value !== null ) { $ setter_name = 'set' . ucfirst ( $ key ) ; $ decoded_taf -> $ setter_name ( $ value ) ; } } } $ remaining_taf = $ decoded [ 'remaining_taf' ] ; } catch ( ChunkDecoderException $ cde ) { $ decoded_taf -> addDecodingException ( $ cde ) ; if ( $ strict ) { break ; } $ remaining_taf = $ cde -> getRemainingTaf ( ) ; } if ( $ chunk_decoder instanceof VisibilityChunkDecoder ) { $ with_cavok = $ decoded_taf -> getCavok ( ) ; } } $ evolutionDecoder = new EvolutionChunkDecoder ( $ strict , $ with_cavok ) ; while ( $ remaining_taf != null && trim ( $ remaining_taf ) != 'END' ) { $ evolutionDecoder -> parse ( $ remaining_taf , $ decoded_taf ) ; $ remaining_taf = $ evolutionDecoder -> getRemaining ( ) ; } return $ decoded_taf ; }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
6969	protected function calculateDiscountLine ( Model \ DocumentLineInterface $ line , Amount $ gross , Amount $ final ) { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_DISCOUNT ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_DISCOUNT ) ) ; } if ( null === $ adjustment = $ line -> getSaleAdjustment ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleDiscount ( $ adjustment , $ gross , $ final ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; }
7606	public function render ( array $ aDropdownOptions ) { if ( empty ( $ aDropdownOptions [ 'attributes' ] ) ) { $ aDropdownOptions [ 'attributes' ] = array ( 'class' => 'dropdown' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] = 'dropdown' ; } elseif ( ! preg_match ( '/(\s|^)dropdown(\s|$)/' , $ aDropdownOptions [ 'attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'attributes' ] [ 'class' ] .= ' dropdown' ; } } return sprintf ( static :: $ dropdownContainerFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'attributes' ] ) , $ this -> renderToggle ( $ aDropdownOptions ) . $ this -> renderListItems ( $ aDropdownOptions ) ) ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
11708	public function actionCreate ( ) { $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'create' , ] ) ; $ this -> performAjaxValidation ( $ user ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been created' ) ) ; return $ this -> redirect ( [ 'index' ] ) ; } return $ this -> render ( 'create' , [ 'user' => $ user ] ) ; }
2151	public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
1675	public function unsynchronize ( ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { System :: getContainer ( ) -> get ( 'filesystem' ) -> touch ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ; } }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
8500	protected function setSSLCurlOptions ( $ ch ) { curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , $ this -> _config [ 'SSL_VerifyPeer' ] ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , $ this -> _config [ 'SSL_VerifyHost' ] ) ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
6387	public function readDiscussion ( $ id ) { $ model = $ this -> readObject ( $ id , 'forum_discussions' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/forum/discuss.php?d=' . $ id ; return $ model ; }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
4676	public function render ( $ region = "main" ) { if ( ! isset ( $ this -> views [ $ region ] ) ) { return $ this ; } mergesort ( $ this -> views [ $ region ] , function ( $ viewA , $ viewB ) { $ sortA = $ viewA -> sortOrder ( ) ; $ sortB = $ viewB -> sortOrder ( ) ; if ( $ sortA == $ sortB ) { return 0 ; } return $ sortA < $ sortB ? - 1 : 1 ; } ) ; foreach ( $ this -> views [ $ region ] as $ view ) { $ view -> render ( $ this -> di ) ; } }
11367	public static function getMimeType ( $ filename = '' ) { $ ext = strtolower ( substr ( $ filename , strrpos ( $ filename , '.' ) ) ) ; switch ( $ ext ) { case '.jpeg' : case '.jpg' : $ mimetype = 'image/jpeg' ; break ; case '.gif' : $ mimetype = 'image/gif' ; break ; case '.png' : $ mimetype = 'image/png' ; break ; case '.txt' : $ mimetype = 'text/plain' ; break ; case '.html' : case '.htm' : $ mimetype = 'text/html' ; break ; case '.zip' : $ mimetype = 'application/x-zip-compressed' ; break ; default : $ mimetype = 'application/octet-stream' ; } return $ mimetype ; }
4655	protected function getJobFromImage ( ImageItem $ image , $ imageName , $ strategy , $ project ) { $ tag = explode ( ':' , $ imageName ) [ 1 ] ; list ( $ uniq , $ timestamp ) = explode ( '-' , $ tag ) ; return new Job ( $ project , $ strategy , $ uniq , array ( 'image' => $ image ) , "" , \ DateTime :: createFromFormat ( 'U' , $ timestamp ) ) ; }
3597	protected function createIndexes ( ) { $ this -> createIndex ( $ this -> db -> getIndexName ( '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) , '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) ; switch ( $ this -> driver ) { case DbConfig :: DRIVER_MYSQL : break ; case DbConfig :: DRIVER_PGSQL : break ; } }
2524	protected function loadFromAuthParams ( AuthParams $ authParams ) { $ this -> officeId = $ authParams -> officeId ; $ this -> dutyCode = $ authParams -> dutyCode ; $ this -> organizationId = $ authParams -> organizationId ; $ this -> originatorTypeCode = $ authParams -> originatorTypeCode ; $ this -> userId = $ authParams -> userId ; $ this -> passwordLength = $ authParams -> passwordLength ; $ this -> passwordData = $ authParams -> passwordData ; }
2462	public function generateMarkup ( ) { $ intMaxSize = round ( static :: getMaxUploadSize ( ) / 1024 / 1024 ) ; $ strAccepted = implode ( ',' , array_map ( function ( $ a ) { return '.' . $ a ; } , StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'uploadTypes' ) ) ) ) ) ; $ GLOBALS [ 'TL_CSS' ] [ ] = 'assets/dropzone/css/dropzone.min.css' ; $ GLOBALS [ 'TL_JAVASCRIPT' ] [ ] = 'assets/dropzone/js/dropzone.min.js' ; $ return = ' <input type="hidden" name="action" value="fileupload"> <div class="fallback"> <input type="file" name="' . $ this -> strName . '[]" class="tl_upload_field" onfocus="Backend.getScrollOffset()" multiple> </div> <div class="dropzone"> <div class="dz-default dz-message"> <span>' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzone' ] . '</span> </div> <span class="dropzone-previews"></span> </div> <script> Dropzone.autoDiscover = false; window.addEvent("domready", function() { new Dropzone("#tl_files", { paramName: "' . $ this -> strName . '", maxFilesize: ' . $ intMaxSize . ', acceptedFiles: "' . $ strAccepted . '", timeout: 0, previewsContainer: ".dropzone-previews", clickable: ".dropzone", dictFileTooBig: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneFileTooBig' ] ) . ', dictInvalidFileType: ' . json_encode ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'dropzoneInvalidType' ] ) . ' }).on("addedfile", function() { $$(".dz-message").setStyle("display", "none"); }).on("success", function(file, message) { if (!message) return; var container = $("tl_message"); if (!container) { container = new Element("div", { "id": "tl_message", "class": "tl_message" }).inject($("tl_buttons"), "before"); } container.appendHTML(message); }); $$("div.tl_formbody_submit").setStyle("display", "none"); }); </script>' ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] ) ) { $ return .= ' <p class="tl_help tl_tip">' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_files' ] [ 'fileupload' ] [ 1 ] , System :: getReadableSize ( static :: getMaxUploadSize ( ) ) , Config :: get ( 'gdMaxImgWidth' ) . 'x' . Config :: get ( 'gdMaxImgHeight' ) ) . '</p>' ; } return $ return ; }
2855	public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
6393	public static function run ( callable $ tryBlock , array $ exceptions = [ ] , callable $ finallyBlock = null ) : TryTo { try { return Success :: of ( Functions :: call ( $ tryBlock ) ) ; } catch ( Exception $ e ) { if ( count ( $ exceptions ) === 0 ) { return Failure :: of ( $ e ) ; } $ error = FluentIterable :: of ( $ exceptions ) -> filter ( Predicates :: assignableFrom ( get_class ( $ e ) ) ) -> first ( ) ; if ( $ error -> isPresent ( ) ) { return Failure :: of ( $ e ) ; } throw $ e ; } finally { if ( $ finallyBlock !== null ) { Functions :: call ( $ finallyBlock ) ; } } }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
4539	public function setIndividualUuid ( ? string $ individualUuid ) { $ this -> individualUuid = $ individualUuid ; $ this -> _individualUuid = true ; return $ this ; }
1810	public function adjustDcaByType ( $ dc ) { $ objCte = Contao \ ContentModel :: findByPk ( $ dc -> id ) ; if ( $ objCte === null ) { return ; } switch ( $ objCte -> type ) { case 'hyperlink' : unset ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imageUrl' ] ) ; break ; case 'image' : $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'imagemargin' ] [ 'eval' ] [ 'tl_class' ] .= ' clr' ; break ; } }
6736	public function instantiate ( $ provider ) { if ( ! $ this -> supported ( $ provider ) ) { throw new ProviderNotSupportedException ( $ provider ) ; } $ class = $ this -> providerClass ( $ provider ) ; switch ( $ provider ) { case 'facebook' : return new $ class ( $ this -> config , $ this -> redirector , $ this -> http , $ this -> store , $ this -> profile , $ this -> access_token ) ; break ; case 'twitter' : return new $ class ( $ this -> config , $ this -> http , $ this -> redirector , $ this -> store , $ this -> profile , $ this -> signature , $ this -> consumer , $ this -> token , $ this -> oauth ) ; break ; } }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
1473	public function createValidator ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , \ Closure $ callback = null ) : ValidatorInterface { $ translator = $ this -> createErrorTranslator ( ) ; return new Validation \ Validator ( $ this -> makeValidator ( $ data , $ rules , $ messages , $ customAttributes ) , $ translator , $ callback ) ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
1477	public function update ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: update ( $ resourceType ) , $ id , $ queryParams ) ; }
9158	protected function addControls ( Response & $ response , Request $ request , View $ view ) { $ matches = array ( ) ; while ( preg_match ( "/\{(\w+)=(\w+)\}/" , $ response -> getBody ( ) , $ matches ) ) { $ controlIdentifier = $ matches [ 1 ] ; $ controlName = $ matches [ 2 ] ; $ currentBody = $ response -> getBody ( ) ; if ( ! isset ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) || ! $ view -> hasControl ( $ controlIdentifier ) ) { $ response -> setBody ( str_replace ( $ matches [ 0 ] , '' , $ currentBody ) ) ; continue ; } if ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] instanceof Control ) { $ repl = $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] -> render ( $ request ) ; } else { $ control = $ view -> createControl ( $ controlIdentifier ) ; $ repl = $ control -> render ( $ request , $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) ; } $ response -> setBody ( str_replace ( $ matches [ 0 ] , $ repl , $ currentBody ) ) ; } }
9424	public function write ( $ string ) { if ( ! $ this -> isWritable ( ) ) { $ message = 'Stream is not writable' ; throw new \ RuntimeException ( $ message ) ; } $ this -> size = null ; return fwrite ( $ this -> stream , $ string ) ; }
9331	private function region ( $ filter , $ resource , $ region , $ colorspace = null , $ value = null ) { $ dest = imagecreatetruecolor ( $ region [ "w" ] , $ region [ "h" ] ) ; if ( ! imagecopy ( $ dest , $ resource , 0 , 0 , $ region [ "x" ] , $ region [ "y" ] , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "1/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } if ( ! $ colorspace ) { if ( $ filter == "pixelateImg" ) { $ result = $ this -> $ filter ( $ dest , imagesx ( $ resource ) , imagesy ( $ resource ) ) ; } else $ result = $ this -> $ filter ( $ dest , $ value ) ; } else { $ this -> setActiveResource ( $ dest ) ; parent :: colorspace ( $ colorspace ) ; $ result = $ dest ; } if ( ! imagecopy ( $ resource , $ result , $ region [ "x" ] , $ region [ "y" ] , 0 , 0 , $ region [ "w" ] , $ region [ "h" ] ) ) { throw new ezcImageFilterFailedException ( "2/ {$function} applied on region {$region['x']}x{$region['y']}" ) ; } return $ resource ; }
3228	function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
8857	private function _relativeSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir , true ) ; $ method = AssetsInstallCommand :: METHOD_RELATIVE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _absoluteSymlinkWithFallback ( $ originDir , $ targetDir ) ; } return $ method ; }
11240	public function def ( $ checkName , $ class , $ method , $ errorMessage , $ passing = true , $ arguments = false ) { $ this -> customChecks -> $ checkName = [ '_call' , $ class , $ method , $ passing , $ arguments ] ; $ this -> lang -> $ checkName = $ errorMessage ; }
11922	public function getAmount ( ) { $ amount = $ this -> getPerUnitAmount ( ) ; $ totalAmount = bcmul ( $ amount , $ this -> getQuantity ( ) , 2 ) ; return floatval ( $ totalAmount ) ; }
11232	public function getLocation ( $ ip = '' , $ baseCurrency = '' , $ renameArrayKeys = false ) { $ params = [ 'ip' => ! $ ip ? $ _SERVER [ 'REMOTE_ADDR' ] : $ ip , 'base_currency' => $ baseCurrency , ] ; $ response = $ this -> client -> get ( 'json.gp' , $ params ) ; $ data = $ this -> handleResponseContent ( $ response , 'json' ) ; if ( $ renameArrayKeys ) { $ tmpData = [ ] ; foreach ( $ data as $ key => $ value ) { $ tmpData [ str_replace ( 'geoplugin_' , '' , $ key ) ] = $ value ; } $ data = $ tmpData ; } return $ data ; }
7604	protected function renderAddOn ( $ aAddOnOptions ) { if ( empty ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( 'Addon options are empty' ) ; } if ( $ aAddOnOptions instanceof ElementInterface ) { $ aAddOnOptions = array ( 'element' => $ aAddOnOptions ) ; } elseif ( is_scalar ( $ aAddOnOptions ) ) { $ aAddOnOptions = array ( 'text' => $ aAddOnOptions ) ; } elseif ( ! is_array ( $ aAddOnOptions ) ) { throw new InvalidArgumentException ( sprintf ( 'Addon options expects an array or a scalar value, "%s" given' , is_object ( $ aAddOnOptions ) ? get_class ( $ aAddOnOptions ) : gettype ( $ aAddOnOptions ) ) ) ; } $ sMarkup = '' ; $ sAddonTagName = 'span' ; $ sAddonClass = '' ; if ( ! empty ( $ aAddOnOptions [ 'text' ] ) ) { if ( ! is_scalar ( $ aAddOnOptions [ 'text' ] ) ) { throw new InvalidArgumentException ( sprintf ( '"text" option expects a scalar value, "%s" given' , is_object ( $ aAddOnOptions [ 'text' ] ) ? get_class ( $ aAddOnOptions [ 'text' ] ) : gettype ( $ aAddOnOptions [ 'text' ] ) ) ) ; } elseif ( ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sMarkup .= $ oTranslator -> translate ( $ aAddOnOptions [ 'text' ] , $ this -> getTranslatorTextDomain ( ) ) ; } else { $ sMarkup .= $ aAddOnOptions [ 'text' ] ; } $ sAddonClass .= ' input-group-addon' ; } elseif ( ! empty ( $ aAddOnOptions [ 'element' ] ) ) { if ( is_array ( $ aAddOnOptions [ 'element' ] ) || ( $ aAddOnOptions [ 'element' ] instanceof Traversable && ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ aAddOnOptions [ 'element' ] = $ oFactory -> create ( $ aAddOnOptions [ 'element' ] ) ; } elseif ( ! ( $ aAddOnOptions [ 'element' ] instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( '"element" option expects an instanceof Zend\Form\ElementInterface, "%s" given' , is_object ( $ aAddOnOptions [ 'element' ] ) ? get_class ( $ aAddOnOptions [ 'element' ] ) : gettype ( $ aAddOnOptions [ 'element' ] ) ) ) ; } $ aAddOnOptions [ 'element' ] -> setOptions ( array_merge ( $ aAddOnOptions [ 'element' ] -> getOptions ( ) , array ( 'disable-twb' => true ) ) ) ; $ sMarkup .= $ this -> render ( $ aAddOnOptions [ 'element' ] ) ; if ( $ aAddOnOptions [ 'element' ] instanceof Button ) { $ sAddonClass .= ' input-group-btn' ; $ sAddonTagName = 'div' ; } else { $ sAddonClass .= ' input-group-addon' ; } } return sprintf ( static :: $ addonFormat , $ sAddonTagName , trim ( $ sAddonClass ) , $ sMarkup , $ sAddonTagName ) ; }
8654	private function convertSubmitFeed ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'SubmitFeed' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMarketplaceIdList ( ) ) { $ marketplaceIdList = $ request -> getMarketplaceIdList ( ) ; foreach ( $ marketplaceIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'MarketplaceIdList.Id.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedType ( ) ) { $ parameters [ 'FeedType' ] = $ request -> getFeedType ( ) ; } if ( $ request -> isSetPurgeAndReplace ( ) ) { $ parameters [ 'PurgeAndReplace' ] = $ request -> getPurgeAndReplace ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } $ headers = array ( ) ; array_push ( $ headers , "Content-Type: " . $ request -> getContentType ( ) -> toString ( ) ) ; return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ headers ) ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
2175	private function adjustDatabaseTables ( ) : ? RedirectResponse { $ this -> container -> get ( 'contao.install_tool' ) -> handleRunOnce ( ) ; $ installer = $ this -> container -> get ( 'contao.installer' ) ; $ this -> context [ 'sql_form' ] = $ installer -> getCommands ( ) ; $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_database_update' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return null ; } $ sql = $ request -> request -> get ( 'sql' ) ; if ( ! empty ( $ sql ) && \ is_array ( $ sql ) ) { foreach ( $ sql as $ hash ) { $ installer -> execCommand ( $ hash ) ; } } return $ this -> getRedirectResponse ( ) ; }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
6398	private function instantiateEntity ( $ entity_name ) { $ entity = null ; if ( $ entity_name == 'weatherPhenomenons' ) { $ entity = new WeatherPhenomenon ( ) ; } else if ( $ entity_name == 'maxTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'minTemperature' ) { $ entity = new Temperature ( ) ; } else if ( $ entity_name == 'clouds' ) { $ entity = new CloudLayer ( ) ; } else if ( $ entity_name == 'surfaceWind' ) { $ entity = new SurfaceWind ( ) ; } else if ( $ entity_name = 'visibility' ) { $ entity = new Visibility ( ) ; } return $ entity ; }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
6465	public function isMultipart ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/multipart\//i" , $ contentType ) === 1 ; }
11868	public function destroy ( string $ sessionIdentifier ) : void { if ( ! isset ( self :: $ files [ $ sessionIdentifier ] ) ) { throw new SessionNotFoundException ( ) ; } unset ( self :: $ files [ $ sessionIdentifier ] ) ; }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
12510	public function buildPreview ( $ by ) { if ( ! in_array ( $ by , $ this -> previewBys , true ) ) { throw new InvalidArgumentException ( 'This preview by not exist.' ) ; } if ( empty ( $ this -> msgType ) ) { throw new RuntimeException ( 'Message type not exist.' ) ; } elseif ( $ this -> msgType === Broadcast :: MSG_TYPE_VIDEO ) { if ( is_array ( $ this -> message ) ) { $ this -> message = array_shift ( $ this -> message ) ; } $ this -> msgType = 'mpvideo' ; } if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message content to send.' ) ; } if ( empty ( $ this -> to ) ) { throw new RuntimeException ( 'No to.' ) ; } $ content = ( new Transformer ( $ this -> msgType , $ this -> message ) ) -> transform ( ) ; $ message = array_merge ( $ this -> buildTo ( $ this -> to , $ by ) , $ content ) ; return $ message ; }
900	public function isArrayMultiLine ( $ index ) { if ( ! $ this -> isArray ( $ index ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Not an array at given index %d.' , $ index ) ) ; } $ tokens = $ this -> tokens ; if ( $ tokens [ $ index ] -> isGivenKind ( T_ARRAY ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; } $ endIndex = $ tokens [ $ index ] -> equals ( '(' ) ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) : $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; for ( ++ $ index ; $ index < $ endIndex ; ++ $ index ) { $ token = $ tokens [ $ index ] ; $ blockType = Tokens :: detectBlockType ( $ token ) ; if ( $ blockType && $ blockType [ 'isStart' ] ) { $ index = $ tokens -> findBlockEnd ( $ blockType [ 'type' ] , $ index ) ; continue ; } if ( $ token -> isWhitespace ( ) && ! $ tokens [ $ index - 1 ] -> isGivenKind ( T_END_HEREDOC ) && false !== strpos ( $ token -> getContent ( ) , "\n" ) ) { return true ; } } return false ; }
5420	protected function parseCookie ( $ cookie_line ) { $ parts = explode ( ';' , $ cookie_line ) ; $ cookie = array ( ) ; preg_match ( '/\s*(.*?)\s*=(.*)/' , array_shift ( $ parts ) , $ cookie ) ; foreach ( $ parts as $ part ) { if ( preg_match ( '/\s*(.*?)\s*=(.*)/' , $ part , $ matches ) ) { $ cookie [ $ matches [ 1 ] ] = trim ( $ matches [ 2 ] ) ; } } return new SimpleCookie ( $ cookie [ 1 ] , trim ( $ cookie [ 2 ] ) , isset ( $ cookie [ 'path' ] ) ? $ cookie [ 'path' ] : '' , isset ( $ cookie [ 'expires' ] ) ? $ cookie [ 'expires' ] : false ) ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
7174	public static function path ( $ array , $ path , $ default = null , $ delimiter = null ) { if ( ! static :: is_array ( $ array ) ) { return $ default ; } if ( is_array ( $ path ) ) { $ keys = $ path ; } else { if ( array_key_exists ( $ path , $ array ) ) { return $ array [ $ path ] ; } if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ path = trim ( $ path , "{$delimiter} " ) ; $ keys = explode ( $ delimiter , $ path ) ; } do { $ key = array_shift ( $ keys ) ; if ( ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( isset ( $ array [ $ key ] ) ) { if ( ! $ keys ) { return $ array [ $ key ] ; } if ( ! static :: is_array ( $ array [ $ key ] ) ) { break ; } $ array = $ array [ $ key ] ; } else { break ; } } while ( $ keys ) ; return $ default ; }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
6394	public function andFinally ( callable $ finallyBlock ) : TryTo { return TryTo :: run ( $ this -> tryBlock , $ this -> exceptions , $ finallyBlock ) ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
883	private function isUseForLambda ( Tokens $ tokens , $ index ) { $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; return $ nextToken -> equals ( '(' ) ; }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
600	public function andOnCondition ( $ condition , $ params = [ ] ) { if ( $ this -> on === null ) { $ this -> on = $ condition ; } else { $ this -> on = [ 'and' , $ this -> on , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
14	public function copyTo ( $ file , $ target ) { if ( $ this -> enabled ) { $ file = preg_replace ( '{[^' . $ this -> whitelist . ']}i' , '-' , $ file ) ; if ( file_exists ( $ this -> root . $ file ) ) { try { touch ( $ this -> root . $ file , filemtime ( $ this -> root . $ file ) , time ( ) ) ; } catch ( \ ErrorException $ e ) { Silencer :: call ( 'touch' , $ this -> root . $ file ) ; } $ this -> io -> writeError ( 'Reading ' . $ this -> root . $ file . ' from cache' , true , IOInterface :: DEBUG ) ; return copy ( $ this -> root . $ file , $ target ) ; } } return false ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
12166	private function createMenutable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu` ( `menu_id` int(11) NOT NULL AUTO_INCREMENT, `menu_parent_id` int(11) NOT NULL DEFAULT '0', `menu_title` varchar(45) NOT NULL, `menu_url` varchar(100) NOT NULL, `menu_classes` varchar(45) DEFAULT NULL, `menu_order` int(11) NOT NULL DEFAULT '0', `menu_group_id` int(11) NOT NULL, `menu_type` varchar(45) NOT NULL DEFAULT 'link', `menu_callback` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, `menu_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=99 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu` (`menu_id`, `menu_parent_id`, `menu_title`, `menu_url`, `menu_classes`, `menu_order`, `menu_group_id`, `menu_type`, `menu_callback`, `lft`, `rgt`, `menu_iscore`) VALUES (85, 0, 'Photos', '/photo/gallery', NULL, 0, 1, 'link', NULL, 3, 12, 1), (86, 0, 'Audio', '/audio/gallery', NULL, 0, 1, 'link', NULL, 4, 11, 1), (87, 0, 'Videos', '/video/gallery', NULL, 0, 1, 'link', NULL, 5, 10, 1), (88, 0, 'Text', '/text/gallery', '', 23, 1, 'link', '', 6, 9, 1), (73, 0, 'Dashboard', '/member/dashboard', '', 0, 2, 'link', NULL, 1, 2, 1), (74, 0, 'Settings', '/member/settings', NULL, 0, 2, 'link', NULL, 3, 4, 1), (75, 0, 'Inbox', '/member/messages', NULL, 0, 3, 'link', NULL, 2, 3, 1), (25, 80, 'Maintenance', '/admin/settings/maintenance', '', 20, 3, 'link', '', 12, 13, 1), (30, 80, 'Emails', '/admin/settings/emails', '', 20, 3, 'link', '', 10, 11, 1), (32, 80, 'Localization', '/admin/settings/localization', '', 20, 3, 'link', '', 8, 9, 1), (33, 80, 'Input', '/admin/settings/input', '', 20, 3, 'link', '', 6, 7, 1), (34, 80, 'Server', '/admin/settings/server', '', 20, 3, 'link', '', 4, 5, 1), (56, 0, 'Dashboard', '/member/dashboard', NULL, 0, 3, 'link', NULL, 1, 2, 1), (78, 80, 'Permissions', '/admin/settings/permissions', '', 20, 3, 'link', '', 14, 15, 1), (80, 0, 'Configuration', '/admin/settings/configuration', '', 20, 3, 'link', '', 3, 16, 1), (98, 0, 'Appearance', '/admin/settings/appearance', NULL, 0, 3, 'link', NULL, 17, 18, 1), (99, 0, 'Pages', '/admin/pages', NULL , 0, 3, 'link', NULL, 3, 4, 1), (101,0, 'Navigation', '/admin/settings/navigation', NULL, 0, 3, 'link', NULL, 17, 18, 1), (102,0, 'Extensions', '/admin/settings/extensions', NULL, 0, 3, 'link', NULL, 17, 18, 1), (103,0, 'Users', '/admin/users', NULL, 0, 3, 'link', NULL, 17, 18, 1);" ) ; }
8490	public static function getUpTime ( ) { $ wmi = Windows :: getInstance ( ) ; $ booted_str = '' ; foreach ( $ wmi -> ExecQuery ( "SELECT LastBootUpTime FROM Win32_OperatingSystem" ) as $ os ) { $ booted_str = $ os -> LastBootUpTime ; } $ booted = [ 'year' => substr ( $ booted_str , 0 , 4 ) , 'month' => substr ( $ booted_str , 4 , 2 ) , 'day' => substr ( $ booted_str , 6 , 2 ) , 'hour' => substr ( $ booted_str , 8 , 2 ) , 'minute' => substr ( $ booted_str , 10 , 2 ) , 'second' => substr ( $ booted_str , 12 , 2 ) ] ; $ booted_ts = mktime ( $ booted [ 'hour' ] , $ booted [ 'minute' ] , $ booted [ 'second' ] , $ booted [ 'month' ] , $ booted [ 'day' ] , $ booted [ 'year' ] ) ; return date ( 'm/d/y h:i A (T)' , $ booted_ts ) ; }
10107	private function writeColinfo ( $ col_array ) { if ( isset ( $ col_array [ 0 ] ) ) { $ colFirst = $ col_array [ 0 ] ; } if ( isset ( $ col_array [ 1 ] ) ) { $ colLast = $ col_array [ 1 ] ; } if ( isset ( $ col_array [ 2 ] ) ) { $ coldx = $ col_array [ 2 ] ; } else { $ coldx = 8.43 ; } if ( isset ( $ col_array [ 3 ] ) ) { $ xfIndex = $ col_array [ 3 ] ; } else { $ xfIndex = 15 ; } if ( isset ( $ col_array [ 4 ] ) ) { $ grbit = $ col_array [ 4 ] ; } else { $ grbit = 0 ; } if ( isset ( $ col_array [ 5 ] ) ) { $ level = $ col_array [ 5 ] ; } else { $ level = 0 ; } $ record = 0x007D ; $ length = 0x000C ; $ coldx *= 256 ; $ ixfe = $ xfIndex ; $ reserved = 0x0000 ; $ level = max ( 0 , min ( $ level , 7 ) ) ; $ grbit |= $ level << 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvv' , $ colFirst , $ colLast , $ coldx , $ ixfe , $ grbit , $ reserved ) ; $ this -> append ( $ header . $ data ) ; }
7529	function dumpLocation ( ) { return ( ( $ this -> parent ) ? ( ( $ p = $ this -> parent -> dumpLocation ( ) ) ? $ p . ' > ' : '' ) . $ this -> tag . '(' . $ this -> typeIndex ( ) . ')' : '' ) ; }
11817	protected function step4 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/user" ) ; $ this -> view -> setData ( "step" , "4" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Install SuperUser" ) ) ; if ( $ this -> application -> input -> methodIs ( "post" ) ) { $ install = new Helpers \ Install ( $ this -> application -> config , $ this -> application -> encrypt ) ; if ( ! $ install -> database ( $ this -> application ) ) { $ this -> application -> dispatcher -> redirect ( "/admin/setup/install/3" ) ; } $ this -> response -> addAlert ( "Wohooo! The database was successfully configure. Now please create a super user." , "info" ) ; } return ; }
781	public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
11210	protected function addRegistry ( $ registry ) { $ this -> removeFromLookup ( $ registry ) ; if ( $ registry instanceof DelegatorAwareInterface ) { $ registry -> setDelegator ( $ this ) ; } $ this -> lookup_pool [ ] = $ registry ; return $ this ; }
12530	public function apply ( $ quantity , $ reason , $ comment = '' , $ poiId = null ) { $ params = [ 'quantity' => intval ( $ quantity ) , 'apply_reason' => $ reason , ] ; if ( ! empty ( $ comment ) ) { $ params [ 'comment' ] = $ comment ; } if ( ! is_null ( $ poiId ) ) { $ params [ 'poi_id' ] = intval ( $ poiId ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYID , $ params ] ) ; }
11711	public function actionBlock ( $ id , $ back = 'index' ) { if ( $ id == \ Yii :: $ app -> user -> getId ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'You can not block your own account' ) ) ; } else { $ user = $ this -> findModel ( $ id ) ; if ( $ user -> getIsBlocked ( ) ) { $ user -> unblock ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been unblocked' ) ) ; } else { $ user -> block ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been blocked' ) ) ; } } $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
2789	public static function reconstructFromTokens ( array & $ tokens ) { $ str = '' ; foreach ( $ tokens as $ token ) { if ( is_string ( $ token ) ) { $ str .= $ token ; } else { $ str .= $ token [ 1 ] ; } } return $ str ; }
4066	public function handle ( BuildWidgetEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; if ( ( $ environment -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_dcasetting' ) || ( $ event -> getProperty ( ) -> getName ( ) !== 'mandatory' ) || ( null === $ event -> getModel ( ) -> getId ( ) ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( null === $ attribute ) { return ; } if ( $ attribute -> get ( 'isunique' ) ) { Message :: addInfo ( $ this -> translator -> trans ( 'tl_metamodel_dcasetting.mandatory_for_unique_attr' , [ ] , 'contao_tl_metamodel_dcasetting' ) ) ; $ extra = $ event -> getProperty ( ) -> getExtra ( ) ; $ extra [ 'disabled' ] = true ; $ event -> getProperty ( ) -> setExtra ( $ extra ) ; $ model -> setProperty ( 'mandatory' , true ) ; } }
2213	public function first ( ) { $ this -> intIndex = 0 ; $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ $ this -> intIndex ] ; return $ this ; }
8331	public function constructPdoDsn ( array $ params ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> constructPdoDsnWindows ( $ params ) ; } return $ this -> constructPdoDsnUnix ( $ params ) ; }
5674	protected function isMatchingKeys ( $ first , $ second , $ identical ) { $ first_keys = array_keys ( $ first ) ; $ second_keys = array_keys ( $ second ) ; if ( $ identical ) { return ( $ first_keys === $ second_keys ) ; } sort ( $ first_keys ) ; sort ( $ second_keys ) ; return ( $ first_keys == $ second_keys ) ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
863	private function changeCodeHash ( $ codeHash ) { if ( null !== $ this -> codeHash ) { self :: clearCache ( $ this -> codeHash ) ; } $ this -> codeHash = $ codeHash ; self :: setCache ( $ this -> codeHash , $ this ) ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
7268	public function hasMany ( $ forClass , $ forColumn = null , $ condition = "" , array $ conditionParams = [ ] ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id $condition " , array_merge ( [ "id" => $ this -> $ refColumn ] , $ conditionParams ) , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ forModel = new $ forClass ; foreach ( $ row as $ column => $ val ) $ forModel -> $ column = $ forModel -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ forModel ; } return new Collection ( $ collection ) ; }
2881	public function getBodyAction ( ) { if ( $ email = $ this -> _initEmail ( ) ) { $ this -> getResponse ( ) -> setHeader ( 'Content-Type' , $ email -> getIsPlain ( ) ? 'text/plain' : 'text/html' ) ; $ this -> getResponse ( ) -> setBody ( $ email -> getBody ( ) ) ; } }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
9894	public function add ( $ item ) { if ( $ item instanceof ShippingMethodInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new Item ( $ item ) ; } }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
7233	protected function assertSaleClass ( Common \ SaleInterface $ sale ) { if ( ! $ sale instanceof Model \ CartInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartInterface :: class ) ; } }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
10123	private function writePrintGridlines ( ) { $ record = 0x002b ; $ length = 0x0002 ; $ fPrintGrid = $ this -> phpSheet -> getPrintGridlines ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintGrid ) ; $ this -> append ( $ header . $ data ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
8393	public static function run ( ) { if ( self :: $ isInit === true ) { self :: $ request = new Request ( self :: $ routes ) ; self :: $ controllers = array ( ) ; try { $ before = self :: $ request -> getBefore ( ) ; foreach ( $ before as $ b ) { $ controller = Controllers :: get ( $ b [ 'class' ] ) ; $ action = $ b [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } if ( self :: $ request -> hasEnded ( ) === false ) { $ controller = Controllers :: get ( self :: $ request -> getClass ( ) ) ; $ action = self :: $ request -> getAction ( ) ; $ controller -> $ action ( self :: $ request ) ; if ( self :: $ request -> hasEnded ( ) === false ) { $ after = self :: $ request -> getAfter ( ) ; foreach ( $ after as $ a ) { $ controller = Controllers :: get ( $ a [ 'class' ] ) ; $ action = $ a [ 'action' ] ; $ controller -> $ action ( self :: $ request ) ; } } } } catch ( \ Exception $ e ) { echo 'Exception: ' . $ e -> getMessage ( ) . PHP_EOL ; echo $ e -> getTraceAsString ( ) ; } } }
7917	protected function renderInput ( ) { return $ this -> hasModel ( ) ? Html :: activeRadio ( $ this -> model , $ this -> attribute , $ this -> options ) : Html :: radio ( $ this -> name , $ this -> checked , $ this -> options ) ; }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
4421	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ legacyRootDir = $ this -> container -> getParameter ( 'ezpublish_legacy.root_dir' ) ; $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageCode = $ input -> getOption ( 'language-code' ) ; $ siteAccessLocation = $ legacyRootDir . '/settings/siteaccess/' . $ siteAccessName ; $ skeletonDir = __DIR__ . '/../_templates/legacy_siteaccess' ; if ( $ fileSystem -> exists ( $ siteAccessLocation ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>' . $ siteAccessName . '</comment> legacy siteaccess already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ fileSystem -> remove ( $ siteAccessLocation ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ relatedSiteAccessList = $ this -> container -> getParameter ( 'ezpublish.siteaccess.list' ) ; $ relatedSiteAccessList [ ] = $ siteAccessName ; $ availableLocales = array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languageService -> loadLanguages ( ) ) ; $ availableLocales = array_values ( array_diff ( $ availableLocales , array ( $ languageCode ) ) ) ; $ siteLanguageList = array_merge ( array ( $ languageCode ) , $ availableLocales ) ; $ translationList = implode ( ';' , $ availableLocales ) ; $ fileSystem -> mirror ( $ skeletonDir , $ siteAccessLocation ) ; $ this -> setSkeletonDirs ( $ siteAccessLocation ) ; $ this -> renderFile ( 'site.ini.append.php' , $ siteAccessLocation . '/site.ini.append.php' , array ( 'relatedSiteAccessList' => $ relatedSiteAccessList , 'siteAccessLocale' => $ languageCode , 'siteLanguageList' => $ siteLanguageList , 'translationList' => $ translationList , ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>' . $ siteAccessName . '</comment> legacy siteaccess!' , '' , ) ) ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
10497	public function sqrt ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( sqrt ( $ this -> value ) ) ; }
7456	private function ensureDirectoryExists ( $ path ) { if ( ! is_dir ( $ path ) ) { if ( ! mkdir ( $ path , 0777 , true ) ) { throw new \ RuntimeException ( sprintf ( 'Could not create directory "%s"' , $ path ) ) ; } } return $ path ; }
12584	static function run_generate_extension_config ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ overwrite = @ $ cliopts [ 'overwrite-existing' ] ; if ( count ( $ args ) == 0 ) { throw new pakeException ( "Missing extension name" ) ; } $ extname = $ args [ 0 ] ; $ configfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; if ( file_exists ( $ configfile ) && ! $ overwrite ) { pake_echo ( "File $configfile already exists. Must overwrite it to continue" ) ; $ ok = pake_input ( "Do you want to overwrite it? [y/n]" , 'n' ) ; if ( $ ok != 'y' ) { return ; } } pake_mkdirs ( self :: getOptionsDir ( ) ) ; pake_copy ( self :: getResourceDir ( ) . '/options-sample.yaml' , $ configfile , array ( 'override' => true ) ) ; pake_echo ( "Created file $configfile, now go and edit it" ) ; }
12164	private function createAuthorityTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority` ( `authority_id` bigint(20) NOT NULL AUTO_INCREMENT, `authority_title` varchar(100) NOT NULL, `authority_parent_id` bigint(20) NOT NULL, `authority_name` varchar(45) NOT NULL COMMENT ' ', `authority_description` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, PRIMARY KEY (`authority_id`), UNIQUE KEY `authority_name_UNIQUE` (`authority_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority` (`authority_id`, `authority_title`, `authority_parent_id`, `authority_name`, `authority_description`, `lft`, `rgt`) VALUES (1, 'PUBLIC', 0, 'PUBLIC', 'All unregistered nodes, users and applications', 1, 8), (2, 'Registered Users', 1, 'REGISTEREDUSERS', 'All registered nodes with a known unique identifier', 2, 7), (3, 'Moderators', 2, 'MODERATORS', 'System moderators, Users allowed to manage user generated import', 3, 6), (4, 'Super Administrators', 3, 'MASTERADMINISTRATORS', 'Special users with awesome powers', 4, 5);" ) ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
1343	public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
8419	public static function get ( string $ alias ) { if ( isset ( self :: $ databases [ $ alias ] ) === false ) { throw new DatabaseNotFound ( 'database "' . $ alias . '" doesn\'t seem to be registered' ) ; } return self :: $ databases [ $ alias ] ; }
8985	public function isComparable ( TableNode $ expected , TableNode $ actual , array $ diff_options , $ message = NULL ) { $ this -> doAssert ( 'Failed comparing two tables: ' , $ diff_options , $ expected , $ actual , $ message ) ; }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
6861	public function doDefaultValueConversionByType ( $ value , $ type , array $ record ) { switch ( $ type ) { case static :: TYPE_DATETIME : return date ( static :: FORMAT_DATETIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_DATE : return date ( static :: FORMAT_DATE , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_TIME : return date ( static :: FORMAT_TIME , is_numeric ( $ value ) ? $ value : strtotime ( $ value ) ) ; case static :: TYPE_MULTILINE : return '<pre class="multiline-text">' . $ value . '</pre>' ; case static :: TYPE_JSON : case static :: TYPE_JSONB : if ( ! is_array ( $ value ) && $ value !== null ) { if ( is_string ( $ value ) || is_numeric ( $ value ) || is_bool ( $ value ) ) { $ value = json_decode ( $ value , true ) ; if ( $ value === null && strtolower ( $ value ) !== 'null' ) { $ value = 'Failed to decode JSON: ' . print_r ( $ value , true ) ; } } else { $ value = 'Invalid value for JSON: ' . print_r ( $ value , true ) ; } } return '<pre class="json-text">' . htmlentities ( stripslashes ( json_encode ( $ value , JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE ) ) ) . '</pre>' ; break ; } return $ value ; }
8186	public function displayBlock ( $ name , array $ context , array $ blocks = array ( ) , $ useBlocks = true ) { $ name = ( string ) $ name ; if ( $ useBlocks && isset ( $ blocks [ $ name ] ) ) { $ template = $ blocks [ $ name ] [ 0 ] ; $ block = $ blocks [ $ name ] [ 1 ] ; } elseif ( isset ( $ this -> blocks [ $ name ] ) ) { $ template = $ this -> blocks [ $ name ] [ 0 ] ; $ block = $ this -> blocks [ $ name ] [ 1 ] ; } else { $ template = null ; $ block = null ; } if ( null !== $ template && ! $ template instanceof self ) { throw new LogicException ( 'A block must be a method on a Twig_Template instance.' ) ; } if ( null !== $ template ) { try { $ template -> $ block ( $ context , $ blocks ) ; } catch ( Twig_Error $ e ) { if ( ! $ e -> getSourceContext ( ) ) { $ e -> setSourceContext ( $ template -> getSourceContext ( ) ) ; } if ( false === $ e -> getTemplateLine ( ) ) { $ e -> setTemplateLine ( - 1 ) ; $ e -> guess ( ) ; } throw $ e ; } catch ( Exception $ e ) { throw new Twig_Error_Runtime ( sprintf ( 'An exception has been thrown during the rendering of a template ("%s").' , $ e -> getMessage ( ) ) , - 1 , $ template -> getSourceContext ( ) , $ e ) ; } } elseif ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ parent -> displayBlock ( $ name , $ context , array_merge ( $ this -> blocks , $ blocks ) , false ) ; } else { @ trigger_error ( sprintf ( 'Silent display of undefined block "%s" in template "%s" is deprecated since version 1.29 and will throw an exception in 2.0. Use the "block(\'%s\') is defined" expression to test for block existence.' , $ name , $ this -> getTemplateName ( ) , $ name ) , E_USER_DEPRECATED ) ; } }
8240	protected function saveResetTokens ( $ tokens , FileWriter $ writer = null ) { $ time = time ( ) ; foreach ( $ tokens as $ id => $ token ) { if ( $ time > $ token [ 'valid' ] ) { unset ( $ tokens [ $ id ] ) ; } } $ fileName = $ this -> dir . self :: RESET_TOKENS ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ tokens , 1 , 2 ) ; if ( $ writer && $ writer -> isOpened ( ) ) { $ writer -> write ( $ yaml ) ; } else { self :: preparePath ( $ this -> dir , dirname ( self :: RESET_TOKENS ) ) ; if ( ( self :: writeFile ( $ fileName , $ yaml ) === false ) ) { throw new \ RuntimeException ( "Unable to save token file (" . self :: RESET_TOKENS . ")." ) ; } } }
8444	public function matchesRequest ( ) { if ( isset ( $ this -> headers [ 'x-twitter-webhooks-signature' ] ) ) { $ signature = $ this -> headers [ 'x-twitter-webhooks-signature' ] [ 0 ] ; $ hash = hash_hmac ( 'sha256' , json_encode ( $ this -> payload -> all ( ) ) , $ this -> config -> get ( 'consumer_secret' ) , true ) ; return $ signature === 'sha256=' . base64_encode ( $ hash ) ; } return false ; }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
5522	public function generate ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; }
3158	public function getResponseVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_ResponseVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
12238	public function innerHTML ( ) { $ dom = dom_import_simplexml ( $ this ) ; $ doc = $ dom -> ownerDocument ; $ html = '' ; foreach ( $ dom -> childNodes as $ child ) { $ html .= ( $ child instanceof DOMText ) ? $ child -> textContent : $ doc -> saveXML ( $ child ) ; } return $ html ; }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
2808	protected function _getFilteredRequests ( ) { $ requests = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> getCollection ( ) ; $ requests -> setCurPage ( 1 ) ; $ requests -> setPageSize ( Mage :: helper ( 'sheep_debug/filter' ) -> getLimitDefaultValue ( ) ) ; if ( $ sessionId = $ this -> getRequest ( ) -> getParam ( 'session_id' ) ) { $ requests -> addSessionIdFilter ( $ sessionId ) ; } if ( $ ip = $ this -> getRequest ( ) -> getParam ( 'ip' ) ) { $ requests -> addIpFilter ( $ ip ) ; } if ( $ method = $ this -> getRequest ( ) -> getParam ( 'method' ) ) { $ requests -> addHttpMethodFilter ( $ method ) ; } if ( $ limit = $ this -> getRequest ( ) -> getParam ( 'limit' ) ) { $ requests -> setPageSize ( $ limit ) ; } if ( $ path = $ this -> getRequest ( ) -> getParam ( 'path' ) ) { $ requests -> addRequestPathFilter ( $ path ) ; } if ( $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ) { $ requests -> addTokenFilter ( $ token ) ; } if ( $ startDate = $ this -> getRequest ( ) -> getParam ( 'start' ) ) { $ requests -> addAfterFilter ( $ startDate ) ; } if ( $ endDate = $ this -> getRequest ( ) -> getParam ( 'end' ) ) { $ requests -> addEarlierFilter ( $ endDate ) ; } if ( $ page = ( int ) $ this -> getRequest ( ) -> getParam ( 'page' ) ) { $ requests -> setCurPage ( $ page ) ; } $ requests -> addOrder ( 'id' , Varien_Data_Collection_Db :: SORT_ORDER_DESC ) ; return $ requests ; }
7747	private function findAdderAndRemover ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ singulars = ( array ) StringUtil :: singularify ( $ this -> camelize ( $ this -> name ) ) ; foreach ( $ singulars as $ singular ) { $ addMethod = 'add' . $ singular ; $ removeMethod = 'remove' . $ singular ; $ addMethodFound = $ this -> isAccessible ( $ reflClass , $ addMethod , 1 ) ; $ removeMethodFound = $ this -> isAccessible ( $ reflClass , $ removeMethod , 1 ) ; if ( $ addMethodFound && $ removeMethodFound ) { $ this -> adderRemover = $ singular ; return ; } } }
7878	protected function registerLogFilesystem ( ) { $ this -> app -> singleton ( 'logviewer.filesystem' , function ( $ app ) { $ files = $ app [ 'files' ] ; $ path = $ app [ 'path.storage' ] . '/logs' ; return new Filesystem ( $ files , $ path ) ; } ) ; $ this -> app -> alias ( 'logviewer.filesystem' , Filesystem :: class ) ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
7394	public function replace ( $ in ) : void { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { return ; } foreach ( $ in as $ k => $ v ) { if ( $ this -> _keyExists ( $ k ) ) { if ( $ this -> { $ k } instanceof TypedAbstract ) { $ this -> { $ k } -> replace ( $ v ) ; } else { $ this -> _setByName ( $ k , $ v ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
204	public static function moveCursorTo ( $ column , $ row = null ) { if ( $ row === null ) { echo "\033[" . ( int ) $ column . 'G' ; } else { echo "\033[" . ( int ) $ row . ';' . ( int ) $ column . 'H' ; } }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
10173	public function has ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate ) { return true ; } return isset ( $ this -> index [ $ pCoord ] ) ; }
3631	public function events ( Request $ request ) : array { $ type = ( int ) $ request -> query ( 'type' ) ; if ( $ type === 1 ) { return ServerListenerCollector :: getCollector ( ) ; } if ( $ type === 2 ) { return SwooleListenerCollector :: getCollector ( ) ; } return [ 'server' => ServerListenerCollector :: getCollector ( ) , 'swoole' => SwooleListenerCollector :: getCollector ( ) , ] ; }
10653	protected function __propertyTraitHasProperty ( $ propertyName ) { if ( method_exists ( $ this , 'get' . $ propertyName ) || method_exists ( $ this , 'set' . $ propertyName ) ) { return true ; } try { $ classReflection = new \ ReflectionProperty ( get_class ( $ this ) , $ propertyName ) ; return $ classReflection -> isPublic ( ) ; } catch ( \ ReflectionException $ ex ) { return false ; } }
1744	public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
11106	public function having ( $ column , $ op , $ value , $ isParam = true ) { $ this -> having -> andHaving ( $ column , $ op , $ value , $ isParam ) ; return $ this ; }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
12159	public function getTitle ( ) { if ( ! is_object ( $ this -> _title ) ) { $ this -> _title = new Noun ( $ this -> _title ) ; } return $ this -> _title ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
729	protected function addDefaultPrimaryKey ( & $ fields ) { foreach ( $ fields as $ field ) { if ( false !== strripos ( $ field [ 'decorators' ] , 'primarykey()' ) ) { return ; } } array_unshift ( $ fields , [ 'property' => 'id' , 'decorators' => 'primaryKey()' ] ) ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
12571	public function previewVoice ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , $ by ) ; }
3703	protected function getProperty ( $ name , $ legend ) { foreach ( $ legend -> getProperties ( ) as $ property ) { if ( $ property -> getName ( ) === $ name ) { return $ property ; } } $ property = new Property ( $ name ) ; $ legend -> addProperty ( $ property ) ; return $ property ; }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
10294	public static function excelToTimestamp ( $ excelTimestamp , $ timeZone = null ) { return ( int ) self :: excelToDateTimeObject ( $ excelTimestamp , $ timeZone ) -> format ( 'U' ) ; }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
3913	public function sortFiles ( $ sortType , $ sortIds = array ( ) ) { switch ( $ sortType ) { case 'name_desc' : return $ this -> sortByName ( false ) ; case 'date_asc' : return $ this -> sortByDate ( true ) ; case 'date_desc' : return $ this -> sortByDate ( false ) ; case 'manual' : return $ this -> sortByIdList ( $ sortIds ) ; case 'random' : return $ this -> sortByRandom ( ) ; default : case 'name_asc' : } return $ this -> sortByName ( true ) ; }
8641	public function setShipmentItemAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8874	public function addAttachment ( $ attachment ) { if ( ! file_exists ( $ attachment ) ) { pines_error ( 'Invalid attachment.' ) ; return false ; } $ this -> attachments [ ] = $ attachment ; return true ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
7273	public static function tableName ( ) { $ cc = static :: modelName ( ) ; $ cc [ 0 ] = strtolower ( $ cc [ 0 ] ) ; return preg_replace_callback ( "/[A-Z]/" , function ( $ uppercase ) { return "_" . strtolower ( $ uppercase [ 0 ] ) ; } , $ cc ) . "s" ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
10569	protected function getOrder ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter , array $ default = [ ] ) : array { $ order = [ ] ; $ params = $ request -> getQueryParams ( ) ; if ( isset ( $ params [ $ sortParameter ] ) ) { if ( isset ( $ params [ self :: ORDER ] ) ) { $ order [ $ params [ $ sortParameter ] ] = strcasecmp ( self :: DESC , $ params [ self :: ORDER ] ) !== 0 ; } else { $ param = $ params [ $ sortParameter ] ; foreach ( ( is_array ( $ param ) ? $ param : [ $ param ] ) as $ s ) { $ this -> parseSort ( $ s , $ order ) ; } } } else { foreach ( preg_grep ( self :: REGEX_DOJO_SORT , array_keys ( $ params ) ) as $ s ) { $ this -> parseSort ( substr ( $ s , 5 , - 1 ) , $ order ) ; } } return empty ( $ order ) ? $ default : $ order ; }
8819	public function server ( $ key = null ) { if ( is_null ( $ key ) ) { return $ _SERVER ; } $ key = strtoupper ( $ key ) ; return ( isset ( $ _SERVER [ $ key ] ) ? $ _SERVER [ $ key ] : null ) ; }
9180	final public function getViewSettings ( ) { $ rf = new \ ReflectionClass ( $ this ) ; $ this -> viewName = str_replace ( 'View' , '' , $ rf -> getShortName ( ) ) ; $ matches = array ( ) ; if ( preg_match ( "#@applyTo\((.*)\)#" , $ rf -> getDocComment ( ) , $ matches ) ) { $ params = array ( ) ; parse_str ( str_replace ( ',' , '&' , $ matches [ 1 ] ) , $ params ) ; if ( is_array ( $ params ) ) { foreach ( $ params as $ param => $ value ) { if ( $ param == 'controller' ) { $ this -> controllers = explode ( '|' , $ value ) ; } if ( $ param == 'action' ) { $ this -> actions = explode ( '|' , $ value ) ; } } } } return $ this ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
1510	public function getRelatedUrl ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , $ field ] , $ params ) ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
8860	public function onBeforePublish ( ) { if ( $ this -> dbObject ( 'PublishDate' ) -> InPast ( ) && ! $ this -> isPublished ( ) ) { $ this -> setCastedField ( "PublishDate" , time ( ) ) ; $ this -> write ( ) ; } }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
12073	public function getForcedQualificationCustomers ( ) { if ( is_null ( $ this -> cacheForcedRanks ) ) { $ custIds = $ this -> getForcedCustomersIds ( ) ; $ ranks = $ this -> getCfgParamsByRanks ( ) ; $ this -> cacheForcedRanks = [ ] ; foreach ( $ custIds as $ item ) { $ custId = $ item [ Customer :: A_CUSTOMER_REF ] ; $ ref = $ item [ Customer :: A_MLM_ID ] ; $ rankCode = $ this -> QUALIFIED_CUSTOMERS [ $ ref ] [ 1 ] ; $ cfgParamsWithSchemes = $ ranks [ $ rankCode ] ; $ this -> cacheForcedRanks [ $ custId ] = $ cfgParamsWithSchemes ; } $ this -> cacheForcedCustomerIds = array_keys ( $ this -> cacheForcedRanks ) ; } return $ this -> cacheForcedRanks ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
8993	public function expecting ( ) { $ possibilities = count ( $ this -> samples ) ; $ orderedByOccurance = array_count_values ( $ this -> samples ) ; array_multisort ( $ orderedByOccurance , SORT_DESC ) ; $ probabilities = [ ] ; foreach ( $ orderedByOccurance as $ item => $ value ) { $ probabilities [ $ item ] = $ value / $ possibilities ; } return $ probabilities ; }
10159	private function readLabel ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( substr ( $ recordData , 6 ) ) ; $ value = $ string [ 'value' ] ; } else { $ string = $ this -> readByteStringLong ( substr ( $ recordData , 6 ) ) ; $ value = $ string [ 'value' ] ; } if ( $ this -> readEmptyCells || trim ( $ value ) !== '' ) { $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_STRING ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } } }
10405	public function set ( $ key , $ value ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair === null ) { $ pair = new Pair ( ) ; $ pair -> setId ( $ key ) ; } $ pair -> setValue ( $ value ) ; $ this -> save ( $ pair ) ; return $ pair ; }
638	public function addColumn ( $ table , $ column , $ type ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addColumn ( $ table , $ column , $ type ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5083	protected function lookUpResource ( $ aData = [ ] , $ iSegment = 4 ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sIdentifier = $ oUri -> segment ( $ iSegment ) ; $ oInput = Factory :: service ( 'Input' ) ; $ aData = array_merge ( static :: CONFIG_LOOKUP_DATA , $ aData ) ; $ aExpansions = array_filter ( ( array ) $ oInput -> get ( 'expand' ) ) ; if ( $ aExpansions ) { if ( ! array_key_exists ( 'expand' , $ aData ) ) { $ aData [ 'expand' ] = [ ] ; } $ aData [ 'expand' ] = array_merge ( $ aData [ 'expand' ] , $ aExpansions ) ; } switch ( static :: CONFIG_LOOKUP_METHOD ) { case 'ID' : return $ this -> oModel -> getById ( $ sIdentifier , $ aData ) ; break ; case 'SLUG' : return $ this -> oModel -> getBySlug ( $ sIdentifier , $ aData ) ; break ; case 'TOKEN' : return $ this -> oModel -> getByToken ( $ sIdentifier , $ aData ) ; break ; } }
6931	private function feedShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; $ calculator = $ this -> invoiceBuilder -> getInvoiceCalculator ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { $ saleItem = $ shipmentItem -> getSaleItem ( ) ; $ max = $ shipment -> isReturn ( ) ? $ calculator -> calculateCreditableQuantity ( $ saleItem ) : $ calculator -> calculateInvoiceableQuantity ( $ saleItem ) ; if ( 0 < $ quantity = min ( $ max , $ shipmentItem -> getQuantity ( ) ) ) { $ line = $ this -> invoiceBuilder -> findOrCreateGoodLine ( $ invoice , $ saleItem , $ max ) ; if ( $ line -> getQuantity ( ) !== $ quantity ) { $ line -> setQuantity ( $ quantity ) ; $ changed = true ; } } } if ( $ invoice -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { if ( $ saleAdjustment === $ line -> getSaleAdjustment ( ) ) { continue 2 ; } } $ this -> invoiceBuilder -> buildDiscountLine ( $ saleAdjustment , $ invoice ) ; $ changed = true ; } if ( null !== $ sale -> getShipmentMethod ( ) && ! $ this -> isShipmentAmountInvoiced ( $ invoice ) ) { $ this -> invoiceBuilder -> buildShipmentLine ( $ invoice ) ; } } return $ changed ; }
1720	private function getChunksFromUnit ( \ DOMElement $ unit ) : array { $ chunks = explode ( '.' , $ unit -> getAttribute ( 'id' ) ) ; if ( preg_match ( '/tl_layout\.[a-z]+\.css\./' , $ unit -> getAttribute ( 'id' ) ) ) { $ chunks = [ $ chunks [ 0 ] , $ chunks [ 1 ] . '.' . $ chunks [ 2 ] , $ chunks [ 3 ] ] ; } return $ chunks ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
3426	public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; }
5085	protected function buildUrl ( $ iTotal , $ iPage , $ iPageOffset ) { $ aParams = [ 'page' => $ iPage + $ iPageOffset , ] ; if ( $ aParams [ 'page' ] <= 0 ) { return null ; } elseif ( $ aParams [ 'page' ] === 1 ) { unset ( $ aParams [ 'page' ] ) ; } $ iTotalPages = ceil ( $ iTotal / static :: CONFIG_PER_PAGE ) ; if ( ! empty ( $ aParams [ 'page' ] ) && $ aParams [ 'page' ] > $ iTotalPages ) { return null ; } $ sUrl = site_url ( ) . uri_string ( ) ; if ( ! empty ( $ aParams ) ) { $ sUrl .= '?' . http_build_query ( $ aParams ) ; } return $ sUrl ; }
5546	public function getTransportError ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getTransportError ( ) ; } return $ this -> frameset -> getTransportError ( ) ; }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
5410	public function close ( ) { if ( ! $ this -> is_open ) { return false ; } $ this -> is_open = false ; return fclose ( $ this -> handle ) ; }
3097	protected function getItemData ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ itemRef = $ this -> getRunnerService ( ) -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ serviceContext , $ itemRef ) ; $ baseUrl = $ this -> getRunnerService ( ) -> getItemPublicUrl ( $ serviceContext , $ itemRef ) ; $ itemState = $ this -> getRunnerService ( ) -> getItemState ( $ serviceContext , $ itemIdentifier ) ; if ( $ itemState === null || ! count ( $ itemState ) ) { $ itemState = new stdClass ( ) ; } return [ 'baseUrl' => $ baseUrl , 'itemData' => $ itemData , 'itemState' => $ itemState , 'itemIdentifier' => $ itemIdentifier , ] ; }
2142	private function getSessionBag ( Request $ request ) : SessionBagInterface { if ( ! $ request -> hasSession ( ) || null === ( $ session = $ request -> getSession ( ) ) ) { throw new \ RuntimeException ( 'The request did not contain a session.' ) ; } $ name = 'contao_frontend' ; if ( $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { $ name = 'contao_backend' ; } return $ session -> getBag ( $ name ) ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
1132	public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
4866	public function delete ( JobInterface $ job , array $ options = [ ] ) { $ result = $ this -> mongoCollection -> deleteOne ( [ '_id' => $ job -> getId ( ) ] ) ; return ( bool ) $ result -> getDeletedCount ( ) ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
11303	protected static function checkPath ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new NotFoundException ( Message :: get ( Message :: MSG_PATH_NOTFOUND , $ path ) , Message :: MSG_PATH_NOTFOUND ) ; } if ( ! is_readable ( $ path ) ) { throw new RuntimeException ( Message :: get ( Message :: MSG_PATH_NONREADABLE , $ path ) , Message :: MSG_PATH_NONREADABLE ) ; } }
10810	public function actionIndex ( $ option = null ) { $ allNames = [ 'web/assets' , 'runtime' , 'runtime/cache' , 'tests/_output' , ] ; $ answer = Select :: display ( 'Select objects' , $ allNames , 1 ) ; $ result = ClearHelper :: run ( $ answer ) ; if ( $ result ) { Output :: items ( $ result , "Clear completed: " . count ( $ result ) . " objects" ) ; } else { Output :: block ( "Not fount object for clear!" ) ; } }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
6175	public function rightJoin ( $ table , $ column , $ operator = null , $ value = null ) { if ( $ column instanceof \ Closure ) { $ where = new Where ( ) ; call_user_func_array ( $ column , [ & $ where ] ) ; } else { $ where = ( new Where ( ) ) -> where ( $ column , $ operator , $ value ) ; } $ this -> request [ 'rightJoin' ] [ $ table ] [ 'table' ] = $ table ; $ this -> request [ 'rightJoin' ] [ $ table ] [ 'where' ] = $ where ; return $ this ; }
4909	public function renderForm ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ formHelper = $ renderer -> plugin ( 'form' ) ; $ fieldset = $ form -> getBaseFieldset ( ) ; $ resetPartial = false ; if ( $ fieldset instanceof ViewPartialProviderInterface ) { $ origPartial = $ fieldset -> getViewPartial ( ) ; $ partial = "$origPartial.form" ; if ( $ renderer -> resolver ( $ partial ) ) { $ fieldset -> setViewPartial ( $ partial ) ; $ resetPartial = true ; } } $ markup = $ formHelper -> renderBare ( $ form , $ layout , $ parameter ) ; if ( $ resetPartial ) { $ fieldset -> setViewPartial ( $ origPartial ) ; } return $ markup ; }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
1775	protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
2388	private function implode ( array $ config ) : string { $ palette = '' ; foreach ( $ config as $ legend => $ group ) { if ( \ count ( $ group [ 'fields' ] ) < 1 ) { continue ; } if ( '' !== $ palette ) { $ palette .= ';' ; } if ( ! \ is_int ( $ legend ) ) { $ palette .= sprintf ( '{%s%s},' , $ legend , ( $ group [ 'hide' ] ? ':hide' : '' ) ) ; } $ palette .= implode ( ',' , $ group [ 'fields' ] ) ; } return $ palette ; }
12819	public static function setPermission ( array $ paths ) { foreach ( $ paths as $ path => $ permission ) { echo "chmod('$path', $permission)..." ; if ( is_dir ( $ path ) || is_file ( $ path ) ) { chmod ( $ path , octdec ( $ permission ) ) ; echo "done.\n" ; } else { echo "file not found.\n" ; } } }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
2971	public static function processAttachments ( array $ attachments ) { $ processed = [ ] ; foreach ( $ attachments as $ attachment ) { if ( ! ( $ attachment instanceof Attachment ) ) { throw new \ InvalidArgumentException ( 'Attachments must implement Stampie\\Attachment' ) ; } $ name = $ attachment -> getName ( ) ; if ( isset ( $ processed [ $ name ] ) ) { $ name = static :: findUniqueName ( $ name , array_keys ( $ processed ) ) ; } $ processed [ $ name ] = $ attachment ; } return $ processed ; }
8555	public function setAdjustmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
10666	public function setReportUri ( string $ reportUri ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't set the report URI because the XSS protection is disabled" ) ; } if ( $ this -> blockMode ) { throw new MiddlewareException ( $ this , sprintf ( "You can't set the report URI because the block mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> reportUri = $ reportUri ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
3290	public function join ( ) : Promise { if ( ! $ this -> handle ) { throw new StatusError ( "Process has not been started." ) ; } return $ this -> processRunner -> join ( $ this -> handle ) ; }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
5881	public function processUpload_postProcessAction ( & $ filename , DataHandler $ pObj ) { $ filename = static :: $ imageResizer -> processFile ( $ filename , '' , '' , null , $ GLOBALS [ 'BE_USER' ] , [ $ this , 'notify' ] ) ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
9586	public function scaffoldFormField ( $ title = null , $ params = null ) { $ field = new ExternalURLField ( $ this -> name , $ title ) ; $ field -> setMaxLength ( $ this -> getSize ( ) ) ; return $ field ; }
1153	public function view ( $ view ) { $ this -> view = is_null ( $ view ) ? $ this -> view : $ view ; return $ this ; }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
1339	public function add ( ResourceIdentifierInterface $ identifier , $ record ) { if ( ! is_object ( $ record ) && ! is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Expecting an object or a boolean to add to the identity map.' ) ; } $ existing = $ this -> lookup ( $ identifier ) ; if ( is_object ( $ existing ) && is_bool ( $ record ) ) { throw new InvalidArgumentException ( 'Attempting to push a boolean into the map in place of an object.' ) ; } $ this -> map [ $ identifier -> toString ( ) ] = $ record ; return $ this ; }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
2920	public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
2158	public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
1991	protected function getLoginStatus ( $ strCookie ) { @ trigger_error ( 'Using Frontend::getLoginStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; $ objTokenChecker = System :: getContainer ( ) -> get ( 'contao.security.token_checker' ) ; if ( $ strCookie == 'BE_USER_AUTH' && $ objTokenChecker -> hasBackendUser ( ) ) { if ( TL_MODE == 'FE' && ! $ objTokenChecker -> isPreviewMode ( ) ) { return false ; } return true ; } if ( $ strCookie == 'FE_USER_AUTH' && $ objTokenChecker -> hasFrontendUser ( ) ) { return true ; } return false ; }
6729	public function set_movie_rating ( $ post_id , $ rating ) { if ( ! add_post_meta ( $ post_id , 'imdbRating' , $ rating , true ) ) { update_post_meta ( $ post_id , 'imdbRating' , $ rating ) ; } }
12090	public function then ( callable $ success = null , callable $ fail = null ) { if ( $ this -> success && is_callable ( $ success ) ) { return $ success ( $ this -> request , $ this -> request -> getStatusCode ( ) ) ; } elseif ( is_callable ( $ fail ) ) { return $ fail ( $ this -> error ) ; } }
1319	private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { if ( is_bool ( $ value ) ) { $ parameters [ $ key ] = var_export ( $ value , true ) ; } } return $ parameters ; }
11626	private function isrunning ( ) { $ pids = explode ( PHP_EOL , `ps -e | awk '{print $1}'` ) ; if ( in_array ( $ this -> pid , $ pids ) ) return true ; return false ; }
11950	private function buildAuthorizationHeader ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ key . '="' . rawurlencode ( $ value ) . '"' ; } if ( $ this -> realm ) { array_unshift ( $ params , 'realm="' . rawurlencode ( $ this -> realm ) . '"' ) ; } return [ 'Authorization' , 'OAuth ' . implode ( ', ' , $ params ) ] ; }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
3558	public function setValue ( $ value ) { $ this -> setType ( $ value ) ; if ( $ this -> hasMutator ( $ value , 'setter' ) ) { $ value = $ this -> mutateValue ( $ value , 'setter' ) ; } elseif ( ! $ this -> isStringable ( $ value ) && ! is_null ( $ value ) ) { throw new InvalidTypeException ( "Unsupported meta value type [{$this->getValueType($value)}]." ) ; } $ this -> attributes [ 'meta_value' ] = $ value ; }
12039	public function sendHeaders ( ) { if ( count ( $ this -> _headersRaw ) || count ( $ this -> _headers ) || ( 200 !== $ this -> _httpResponseCode ) ) { $ this -> canSendHeaders ( true ) ; } elseif ( 200 === $ this -> _httpResponseCode ) { return $ this ; } $ httpCodeSent = false ; foreach ( $ this -> _headersRaw as $ header ) { if ( ! $ httpCodeSent && $ this -> _httpResponseCode ) { header ( $ header , true , $ this -> _httpResponseCode ) ; $ httpCodeSent = true ; } else { header ( $ header ) ; } } foreach ( $ this -> _headers as $ header ) { header ( "{$header['name']}: {$header['value']}" , $ header [ 'replace' ] ) ; } if ( ! $ httpCodeSent ) { $ message = array_key_exists ( $ this -> _httpResponseCode , self :: $ _messages ) ? self :: $ _messages [ $ this -> _httpResponseCode ] : 'No Reason Phrase' ; header ( "HTTP/1.1 {$this->_httpResponseCode} {$message}" , true ) ; $ httpCodeSent = true ; } return $ this ; }
6744	public function handleServerRequest ( ServerRequestInterface $ request ) : array { $ messages = [ ] ; try { $ body = $ request -> getBody ( ) -> getContents ( ) ; $ uriPath = $ request -> getUri ( ) -> getPath ( ) ; if ( '/favicon.ico' === $ uriPath ) { return [ $ this -> createFaviconResponse ( ) , [ ] ] ; } $ from = microtime ( true ) ; $ method = $ request -> getMethod ( ) ; $ headers = $ request -> getHeaders ( ) ; $ symfonyRequest = new Request ( $ request -> getQueryParams ( ) , $ request -> getParsedBody ( ) ?? [ ] , $ request -> getAttributes ( ) , $ request -> getCookieParams ( ) , $ request -> getUploadedFiles ( ) , [ ] , $ body ) ; $ symfonyRequest -> setMethod ( $ method ) ; $ symfonyRequest -> headers -> replace ( $ headers ) ; $ symfonyRequest -> server -> set ( 'REQUEST_URI' , $ uriPath ) ; if ( isset ( $ headers [ 'Host' ] ) ) { $ symfonyRequest -> server -> set ( 'SERVER_NAME' , explode ( ':' , $ headers [ 'Host' ] [ 0 ] ) ) ; } $ symfonyResponse = $ this -> kernel -> handle ( $ symfonyRequest ) ; $ this -> kernel -> terminate ( $ symfonyRequest , $ symfonyResponse ) ; $ to = microtime ( true ) ; $ messages [ ] = new ConsoleMessage ( $ request -> getUri ( ) -> getPath ( ) , $ method , $ symfonyResponse -> getStatusCode ( ) , $ symfonyResponse -> getContent ( ) , \ intval ( ( $ to - $ from ) * 1000 ) ) ; $ this -> applyResponseEncoding ( $ symfonyRequest , $ symfonyResponse ) ; $ httpResponse = new \ React \ Http \ Response ( $ symfonyResponse -> getStatusCode ( ) , $ symfonyResponse -> headers -> all ( ) , $ symfonyResponse -> getContent ( ) ) ; $ symfonyRequest = null ; $ symfonyResponse = null ; } catch ( \ Throwable $ exception ) { $ messages [ ] = new ConsoleException ( $ exception ) ; $ httpResponse = new \ React \ Http \ Response ( 400 , [ 'Content-Type' => 'text/plain' ] , $ exception -> getMessage ( ) ) ; } return [ $ httpResponse , $ messages ] ; }
7532	function html ( $ value = null ) { if ( $ value !== null ) { $ this -> setInnerText ( $ value ) ; } return $ this -> getInnerText ( ) ; }
339	public function registerClientScript ( ) { $ id = $ this -> options [ 'id' ] ; $ options = Json :: htmlEncode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: htmlEncode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; ActiveFormAsset :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
3016	public function reblogPost ( $ blogName , $ postId , $ reblogKey , $ options = null ) { $ params = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; $ params = array_merge ( $ options ? : array ( ) , $ params ) ; $ path = $ this -> blogPath ( $ blogName , '/post/reblog' ) ; return $ this -> postRequest ( $ path , $ params , false ) ; }
1402	public function getErrors ( ) { if ( ! is_null ( $ this -> errors ) ) { return collect ( $ this -> errors ) ; } try { $ this -> errors = $ this -> parse ( ) ; } catch ( \ Exception $ ex ) { $ this -> errors = [ ] ; } return collect ( $ this -> errors ) ; }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
3519	public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML<script>var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES";var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES";var TITLE_TRANSLATE = "$TITLE_TRANSLATE";var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY";var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS";var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN";var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE";var TITLE_LOWERCASE = "$TITLE_LOWERCASE";var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD";var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY";var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE";var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR";var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST";</script>HTML ; }
9230	public function patch ( $ path , $ data = array ( ) , $ headers = array ( ) ) { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'The Canvas API does not support the PATCH method' , CanvasPest_Exception :: UNSUPPORTED_METHOD ) ; } return false ; }
870	public function configure ( array $ configuration = null ) { parent :: configure ( $ configuration ) ; $ this -> candidateTokenKind = 'long' === $ this -> configuration [ 'syntax' ] ? CT :: T_DESTRUCTURING_SQUARE_BRACE_OPEN : T_LIST ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
6830	protected function moveAssignment ( Stock \ StockAssignmentInterface $ assignment , Stock \ StockUnitInterface $ targetUnit , $ quantity ) { $ quantity = min ( $ quantity , $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippedQuantity ( ) ) ; if ( 0 >= $ quantity ) { return 0 ; } $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ saleItem = $ assignment -> getSaleItem ( ) ; $ this -> logger -> unitSold ( $ sourceUnit , - $ quantity ) ; $ sourceUnit -> setSoldQuantity ( $ sourceUnit -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ sourceUnit ) ; $ this -> logger -> unitSold ( $ targetUnit , $ quantity ) ; $ targetUnit -> setSoldQuantity ( $ targetUnit -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ targetUnit ) ; $ merge = null ; foreach ( $ targetUnit -> getStockAssignments ( ) as $ m ) { if ( $ m -> getSaleItem ( ) === $ saleItem ) { $ merge = $ m ; break ; } } if ( $ quantity == $ assignment -> getSoldQuantity ( ) ) { if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; $ this -> logger -> assignmentSold ( $ assignment , 0 , false ) ; $ assignment -> setSoldQuantity ( 0 ) -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> manager -> remove ( $ assignment ) ; } else { $ this -> logger -> assignmentUnit ( $ assignment , $ targetUnit ) ; $ assignment -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ assignment ) ; } } else { $ this -> logger -> assignmentSold ( $ assignment , - $ quantity ) ; $ assignment -> setSoldQuantity ( $ assignment -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ assignment ) ; if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; } else { $ create = $ this -> saleFactory -> createStockAssignmentForItem ( $ saleItem ) ; $ this -> logger -> assignmentSold ( $ create , $ quantity , false ) ; $ create -> setSoldQuantity ( $ quantity ) -> setSaleItem ( $ saleItem ) -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ create ) ; } } return $ quantity ; }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
6348	public static function indexOf ( Iterator $ iterator , callable $ predicate ) : int { $ i = 0 ; while ( $ iterator -> valid ( ) ) { if ( Predicates :: call ( $ predicate , $ iterator -> current ( ) ) ) { return $ i ; } $ i ++ ; $ iterator -> next ( ) ; } return - 1 ; }
10340	public static function checkErrorCode ( $ pValue ) { $ pValue = ( string ) $ pValue ; if ( ! isset ( self :: $ errorCodes [ $ pValue ] ) ) { $ pValue = '#NULL!' ; } return $ pValue ; }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
10831	public static function createFromSplFileInfo ( \ SplFileInfo $ info ) { $ realpath = $ info -> getRealPath ( ) ; if ( $ info -> isFile ( ) ) { return new fs \ entity \ FileEntity ( $ realpath ) ; } return new fs \ entity \ DirEntity ( $ realpath ) ; }
825	public function setName ( $ name ) { $ current = $ this -> getName ( ) ; if ( 'other' === $ current ) { throw new \ RuntimeException ( 'Cannot set name on unknown tag.' ) ; } $ this -> line -> setContent ( Preg :: replace ( "/@{$current}/" , "@{$name}" , $ this -> line -> getContent ( ) , 1 ) ) ; $ this -> name = $ name ; }
12732	public function handle ( $ signal ) { if ( isset ( $ this -> _bySignal [ $ signal ] ) ) { foreach ( $ this -> _bySignal [ $ signal ] as $ reg ) { $ reg -> interrupt = $ signal ; } } else { return SIG_DFL ; } }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
4021	protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; }
8598	public function createSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_CreateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_CreateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_CreateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3462	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ next ) : ResponseInterface { $ route = $ this -> router -> find ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; $ controller = $ route -> getController ( ) ; if ( $ request instanceof ServerRequest ) { $ request = $ request -> withAttributes ( $ route -> getAttributes ( ) ) ; } if ( is_string ( $ controller ) && class_exists ( $ controller ) && is_subclass_of ( $ controller , Controller :: class ) ) { $ instance = $ this -> resolver -> resolve ( $ controller ) ; return $ instance ( $ request ) ; } if ( is_callable ( $ controller ) ) { $ response = $ controller ( $ request ) ; if ( ! $ response instanceof ResponseInterface ) { throw ControllerException :: forInvalidReturnValue ( ) ; } return $ response ; } throw ControllerException :: forMissingController ( $ route -> getPath ( ) ) ; }
12816	private static function getColumns ( string $ table ) : array { if ( self :: $ columnsCache !== null && array_key_exists ( $ table , self :: $ columnsCache ) ) return self :: $ columnsCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT * FROM information_schema.columns WHERE table_name = '$table' " ; self :: $ columnsCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ columnsCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ columnsCache [ $ table ] ; }
7477	public function downloadAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ file = $ em -> find ( 'Orkestra\Bundle\ApplicationBundle\Entity\File' , $ id ) ; if ( ! $ file ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } $ securityContext = $ this -> get ( 'security.authorization_checker' ) ; foreach ( $ file -> getGroups ( ) as $ group ) { if ( ! $ securityContext -> isGranted ( $ group -> getRole ( ) ) ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } } return new Response ( $ file -> getContent ( ) , 200 , array ( 'Content-Type' => $ file -> getMimeType ( ) , 'Content-Disposition' => sprintf ( 'attachment; filename="%s"' , $ file -> getFilename ( ) ) ) ) ; }
2540	protected function makeSegmentNameForRequestElement ( $ elementType , $ element ) { $ elementName = '' ; $ sourceArray = [ 'Contact' => ElementManagementData :: SEGNAME_CONTACT_ELEMENT , 'FormOfPayment' => ElementManagementData :: SEGNAME_FORM_OF_PAYMENT , 'MiscellaneousRemark' => ElementManagementData :: SEGNAME_GENERAL_REMARK , 'ReceivedFrom' => ElementManagementData :: SEGNAME_RECEIVE_FROM , 'ServiceRequest' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'Ticketing' => ElementManagementData :: SEGNAME_TICKETING_ELEMENT , 'AccountingInfo' => ElementManagementData :: SEGNAME_ACCOUNTING_INFORMATION , 'Address' => null , 'FrequentFlyer' => ElementManagementData :: SEGNAME_SPECIAL_SERVICE_REQUEST , 'OtherServiceInfo' => ElementManagementData :: SEGNAME_OTHER_SERVICE_INFORMATION , 'ManualCommission' => ElementManagementData :: SEGNAME_COMMISSION , 'SeatRequest' => ElementManagementData :: SEGNAME_SEAT_REQUEST , 'TourCode' => ElementManagementData :: SEGNAME_TOUR_CODE , 'ManualIssuedTicket' => ElementManagementData :: SEGNAME_MANUAL_DOCUMENT_REGISTRATION_WITH_ET_NUMBER ] ; if ( array_key_exists ( $ elementType , $ sourceArray ) ) { $ elementName = $ sourceArray [ $ elementType ] ; if ( $ elementType === 'Address' ) { $ elementName = $ element -> type ; } } return $ elementName ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
2269	public function lockTables ( $ arrTables ) { $ arrLocks = array ( ) ; foreach ( $ arrTables as $ table => $ mode ) { $ arrLocks [ ] = $ this -> resConnection -> quoteIdentifier ( $ table ) . ' ' . $ mode ; } $ this -> resConnection -> exec ( 'LOCK TABLES ' . implode ( ', ' , $ arrLocks ) . ';' ) ; }
8136	public function setCache ( $ cache ) { if ( is_string ( $ cache ) ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Filesystem ( $ cache ) ; } elseif ( false === $ cache ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( null === $ cache ) { @ trigger_error ( 'Using "null" as the cache strategy is deprecated since version 1.23 and will be removed in Twig 2.0.' , E_USER_DEPRECATED ) ; $ this -> originalCache = false ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( $ cache instanceof Twig_CacheInterface ) { $ this -> originalCache = $ this -> cache = $ cache ; } else { throw new LogicException ( sprintf ( 'Cache can only be a string, false, or a Twig_CacheInterface implementation.' ) ) ; } }
6176	public static function arrayUniqueMultidimensional ( array $ input ) { $ serialized = array_map ( 'serialize' , $ input ) ; $ unique = array_unique ( $ serialized ) ; $ output = array_intersect_key ( $ input , $ unique ) ; return array_values ( $ output ) ; }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
1438	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; $ this -> replaceNamespace ( $ stub , $ name ) -> replaceClassName ( $ stub , $ name ) -> replaceResourceType ( $ stub ) -> replaceApplicationNamespace ( $ stub ) -> replaceRecord ( $ stub ) ; return $ stub ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
5190	private function filterString ( $ str ) : string { if ( is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ) { return $ str ; } throw new \ Exception ( 'String required' , 1 ) ; }
10929	public function getCountOf ( string $ strSQL , ? array $ parans = null ) : int { $ r = $ this -> getDataColumn ( $ strSQL , $ parans , "int" ) ; return ( ( $ r === null ) ? 0 : $ r ) ; }
9332	public function requireField ( ) { $ charset = MySQLDatabase :: config ( ) -> charset ; $ collation = MySQLDatabase :: config ( ) -> collation ; $ spec = [ 'type' => 'varchar' , 'parts' => [ 'datatype' => 'varchar' , 'precision' => 64 , 'collate' => $ collation , 'character set' => $ charset , 'arrayValue' => $ this -> arrayValue ] ] ; DB :: require_field ( $ this -> tableName , $ this -> name , $ spec ) ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
10269	function setHTMLContent ( $ mailingId , $ html , $ doImageGrabbing = true , $ doLinkTracking = false ) { $ queryParameters = array ( 'doImageGrabbing' => ( $ doImageGrabbing == TRUE ) ? "true" : "false" , 'doLinkTracking' => ( $ doLinkTracking == TRUE ) ? "true" : "false" ) ; return $ this -> post ( 'mailings/' . $ mailingId . '/contents/html' , $ html , $ queryParameters , "text/html" ) ; }
3291	public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; }
10870	public function verifyHash ( string $ password , string $ hash ) : bool { return Passwords :: verify ( $ password , $ hash ) ; }
3101	private function getSubIdentifiersRecursively ( $ array , $ identifiers ) { $ identifier = array_shift ( $ identifiers ) ; if ( count ( $ identifiers ) > 0 ) { $ result = [ ] ; foreach ( $ array [ $ identifier ] as $ key => $ value ) { $ result [ ] = $ this -> getSubIdentifiersRecursively ( $ array [ $ identifier ] [ $ key ] , $ identifiers ) ; } return array_merge ( ... $ result ) ; } return array_keys ( $ array [ $ identifier ] ) ; }
9078	private static function parseContextPrefix ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'CONTEXT_PREFIX' ] ) && $ serverVars [ 'CONTEXT_PREFIX' ] != '' ) { $ request -> setContextPrefix ( $ serverVars [ 'CONTEXT_PREFIX' ] . '/' ) ; } elseif ( isset ( $ serverVars [ 'REDIRECT_BASE' ] ) ) { $ request -> setContextPrefix ( $ serverVars [ 'REDIRECT_BASE' ] ) ; } elseif ( isset ( $ serverVars [ 'SCRIPT_FILENAME' ] ) && isset ( $ serverVars [ 'SCRIPT_NAME' ] ) ) { if ( isset ( $ serverVars [ 'HTTP_HOST' ] ) ) { $ scriptName = preg_replace ( '/^.+[\\\\\\/]/' , '' , $ serverVars [ 'SCRIPT_FILENAME' ] ) ; $ request -> contextPrefix = str_replace ( $ scriptName , '' , $ serverVars [ 'SCRIPT_NAME' ] ) ; } } }
4311	public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
11169	public static function boot ( ) { parent :: boot ( ) ; static :: addGlobalScope ( 'type' , function ( $ query ) { return $ query -> when ( static :: class !== StripeObject :: class , function ( $ query ) { $ query -> where ( 'type' , class_basename ( ( new static ( ) ) -> objectClass ) ) ; } ) ; } ) ; static :: created ( function ( StripeObject $ object ) { if ( $ object -> relatesWith ) { list ( $ related , $ tag ) = $ object -> relatesWith ; $ object -> relations ( get_class ( $ related ) ) -> attach ( $ related -> id , [ 'tag' => $ tag ] ) ; } } ) ; }
294	public function setAttribute ( $ name , $ value ) { if ( $ this -> hasAttribute ( $ name ) ) { if ( ! empty ( $ this -> _relationsDependencies [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _attributes ) || $ this -> _attributes [ $ name ] !== $ value ) ) { $ this -> resetDependentRelations ( $ name ) ; } $ this -> _attributes [ $ name ] = $ value ; } else { throw new InvalidArgumentException ( get_class ( $ this ) . ' has no attribute named "' . $ name . '".' ) ; } }
8180	public function setDefaultStrategy ( $ defaultStrategy ) { if ( true === $ defaultStrategy ) { @ trigger_error ( 'Using "true" as the default strategy is deprecated since version 1.21. Use "html" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'html' ; } if ( 'filename' === $ defaultStrategy ) { @ trigger_error ( 'Using "filename" as the default strategy is deprecated since version 1.27. Use "name" instead.' , E_USER_DEPRECATED ) ; $ defaultStrategy = 'name' ; } if ( 'name' === $ defaultStrategy ) { $ defaultStrategy = array ( 'Twig_FileExtensionEscapingStrategy' , 'guess' ) ; } $ this -> defaultStrategy = $ defaultStrategy ; }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
6463	public function tryGetFirst ( $ name , & $ value ) : bool { try { $ value = $ this -> get ( $ name ) [ 0 ] ; return true ; } catch ( OutOfBoundsException $ ex ) { return false ; } }
10997	public function read ( int $ offset = 0 ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { $ this -> error = "failed to read file; {$this->error}" ; return false ; } return $ this -> readFile ( $ offset ) ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
5404	public function restartSession ( $ date = false ) { $ surviving_cookies = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { if ( ! $ this -> cookies [ $ i ] -> getValue ( ) ) { continue ; } if ( ! $ this -> cookies [ $ i ] -> getExpiry ( ) ) { continue ; } if ( $ date && $ this -> cookies [ $ i ] -> isExpired ( $ date ) ) { continue ; } $ surviving_cookies [ ] = $ this -> cookies [ $ i ] ; } $ this -> cookies = $ surviving_cookies ; }
37	protected function printLicenses ( CompletePackageInterface $ package ) { $ spdxLicenses = new SpdxLicenses ( ) ; $ licenses = $ package -> getLicense ( ) ; $ io = $ this -> getIO ( ) ; foreach ( $ licenses as $ licenseId ) { $ license = $ spdxLicenses -> getLicenseByIdentifier ( $ licenseId ) ; if ( ! $ license ) { $ out = $ licenseId ; } else { if ( $ license [ 1 ] === true ) { $ out = sprintf ( '%s (%s) (OSI approved) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } else { $ out = sprintf ( '%s (%s) %s' , $ license [ 0 ] , $ licenseId , $ license [ 2 ] ) ; } } $ io -> write ( '<info>license</info> : ' . $ out ) ; } }
10232	private function writeLine ( $ pFileHandle , array $ pValues ) { $ writeDelimiter = false ; $ line = '' ; foreach ( $ pValues as $ element ) { $ element = str_replace ( $ this -> enclosure , $ this -> enclosure . $ this -> enclosure , $ element ) ; if ( $ writeDelimiter ) { $ line .= $ this -> delimiter ; } else { $ writeDelimiter = true ; } $ line .= $ this -> enclosure . $ element . $ this -> enclosure ; } $ line .= $ this -> lineEnding ; fwrite ( $ pFileHandle , $ line ) ; }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
2730	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , Config :: AUTH_DICTIONARY_NAME ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( ( $ status == true && is_array ( $ authItems ) && count ( $ authItems ) < 2 ) || $ authItems == false ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'While Basic Authentication is enabled, at least one user must exist.' , ] ) ; } $ itemKey = $ this -> getRequest ( ) -> getParam ( 'item_key_id' ) ; $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionary -> id , $ itemKey ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create Dictionary item.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
4836	public function create_bill ( $ params ) { if ( ! isset ( $ params [ 'pre_authorization_id' ] ) ) { throw new GoCardless_ArgumentsException ( 'pre_authorization_id missing' ) ; } $ pre_auth = new GoCardless_PreAuthorization ( $ this , array ( 'id' => $ params [ 'pre_authorization_id' ] ) ) ; return $ pre_auth -> create_bill ( array ( 'amount' => $ params [ 'amount' ] ) ) ; }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
2720	public function execute ( ) { $ resultLayout = null ; try { $ resultLayout = $ this -> resultLayoutFactory -> create ( ) ; $ resultLayout -> addDefaultHandle ( ) ; $ countryCode = $ this -> getRequest ( ) -> getParam ( self :: REQUEST_PARAM_COUNTRY ) ; $ storeId = $ this -> config -> getGeoIpMappingForCountry ( $ countryCode ) ; if ( $ storeId !== null ) { $ redirectUrl = null ; $ targetStore = $ this -> storeRepository -> getActiveStoreById ( $ storeId ) ; $ currentStore = $ this -> storeManager -> getStore ( ) ; if ( $ currentStore -> getId ( ) != $ targetStore -> getId ( ) ) { $ this -> url -> setScope ( $ targetStore -> getId ( ) ) ; $ this -> url -> addQueryParams ( [ ' store' => $ targetStore -> getCode ( ) , ' from_store' => $ currentStore -> getCode ( ) ] ) ; $ redirectUrl = $ this -> url -> getUrl ( 'stores/store/switch' ) ; } if ( $ redirectUrl ) { switch ( $ this -> config -> getGeoIpAction ( ) ) { case Config :: GEOIP_ACTION_DIALOG : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_dialog' ] ) ; $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setMessage ( $ this -> getMessageInStoreLocale ( $ targetStore ) ) ; break ; case Config :: GEOIP_ACTION_REDIRECT : $ resultLayout -> getLayout ( ) -> getUpdate ( ) -> load ( [ 'geoip_getaction_redirect' ] ) ; break ; } $ resultLayout -> getLayout ( ) -> getBlock ( 'geoip_getaction' ) -> setRedirectUrl ( $ redirectUrl ) ; } } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) ) ; } $ resultLayout -> setHeader ( "x-esi" , "1" ) ; return $ resultLayout ; }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
8009	protected function processKey ( $ raw_key ) { $ key = $ raw_key ; if ( $ this -> expand_and_normalize_keys ) { $ key = self :: expand56BitKeyTo64BitKey ( $ key , true ) ; } return $ key ; }
3028	public function setConsumer ( $ key , $ secret ) { $ this -> consumer = new \ Eher \ OAuth \ Consumer ( $ key , $ secret ) ; }
11088	public static function getUserBrowser ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_browser = 'unknown' ; if ( false !== stripos ( $ user_agent , 'MSIE' ) && false === stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Internet Explorer' ; } elseif ( false !== stripos ( $ user_agent , 'Firefox' ) ) { $ user_browser = 'Mozilla Firefox' ; } elseif ( false !== stripos ( $ user_agent , 'Chrome' ) ) { $ user_browser = 'Google Chrome' ; } elseif ( false !== stripos ( $ user_agent , 'Safari' ) ) { $ user_browser = 'Apple Safari' ; } elseif ( false !== stripos ( $ user_agent , 'Opera' ) ) { $ user_browser = 'Opera' ; } elseif ( false !== stripos ( $ user_agent , 'Netscape' ) ) { $ user_browser = 'Netscape' ; } return $ user_browser ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
6929	private function checkShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { if ( null === $ shipment = $ invoice -> getShipment ( ) ) { throw new LogicException ( "Invoice's shipment must be set at this point." ) ; } if ( $ shipment -> getSale ( ) !== $ sale = $ invoice -> getSale ( ) ) { throw new LogicException ( "Shipment/Invoice sale miss match." ) ; } if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { throw new LogicException ( "Expected instance of " . Invoice \ InvoiceSubjectInterface :: class ) ; } if ( $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isCredit ( $ invoice ) ) { throw new LogicException ( "Invoice should not be associated with Return." ) ; } elseif ( ! $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) ) { throw new LogicException ( "Credit should not be associated with Shipment." ) ; } }
971	public function getToken ( bool $ strict = false ) { $ tokens = [ self :: GRANT_PERUSER => Session :: get ( self :: TOKEN ) , self :: GRANT_OFFLINE => $ this -> shop -> { self :: TOKEN } , ] ; if ( $ strict ) { return $ tokens [ $ this -> getType ( ) ] ; } return $ tokens [ self :: GRANT_PERUSER ] ?? $ tokens [ self :: GRANT_OFFLINE ] ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
10470	public function lookupUser ( $ user_id ) { $ request = new UserRequest ( $ user_id ) ; $ this -> emit ( 'request.user' , array ( $ user_id ) ) ; $ response = $ this -> post ( $ request ) ; return new UserResponse ( $ response ) ; }
8849	public function category ( ) { $ category = $ this -> getCurrentCategory ( ) ; if ( $ category ) { $ this -> blogPosts = $ category -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
5765	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ administrators = $ this -> administratorsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) , null , $ this -> authentication , $ this -> authorization ) ; } catch ( QueryFailureException $ e ) { $ administrators = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ administrators ) ; }
104	public function isRateLimited ( array $ headers ) { foreach ( $ headers as $ header ) { if ( preg_match ( '{^X-RateLimit-Remaining: *0$}i' , trim ( $ header ) ) ) { return true ; } } return false ; }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
3098	public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } }
10553	public static function findVirtualHost ( URL $ url , array $ sites ) { foreach ( $ sites as $ site ) { $ vhost = $ site -> match ( $ url ) ; if ( $ vhost !== null ) return $ vhost ; } return null ; }
1241	private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } }
10530	public function toJson ( $ prettyPrint = false ) { $ options = 0 ; if ( $ prettyPrint ) { $ options += JSON_PRETTY_PRINT ; } return json_encode ( $ this -> items , $ options ) ; }
5080	public function postIndex ( ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ this -> userCan ( static :: ACTION_CREATE ) ; $ aData = $ oInput -> post ( ) ; if ( empty ( $ aData ) ) { $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; } $ aData = $ this -> validateUserInput ( $ aData ) ; $ iItemId = $ this -> oModel -> create ( $ aData ) ; if ( empty ( $ iItemId ) ) { throw new ApiException ( 'Failed to create resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } $ oItem = $ this -> oModel -> getById ( $ iItemId , static :: CONFIG_LOOKUP_DATA ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
5381	public function getValue ( ) { if ( $ this -> choice === false ) { return $ this -> getDefault ( ) ; } return $ this -> options [ $ this -> choice ] -> getValue ( ) ; }
6518	public static function fromDateTime ( \ DateTimeInterface $ date ) { $ str = $ date -> format ( 'U' ) . str_pad ( $ date -> format ( 'u' ) , 6 , '0' ) ; $ m = new self ( ) ; $ m -> int = ( int ) $ str ; $ m -> sec = ( int ) substr ( $ str , 0 , 10 ) ; $ m -> usec = ( int ) substr ( $ str , - 6 ) ; return $ m ; }
4823	public function removeField ( $ fieldName ) { if ( array_key_exists ( $ fieldName , $ this -> row ) ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } }
3427	public function addFilter ( $ filters ) { foreach ( $ filters as $ field => $ value ) { $ this -> filter [ $ field ] = $ value ; } return $ this ; }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
9122	private function prepareRequest ( $ requestType ) : MemoryStream { $ ms = new MemoryStream ( ) ; $ ms -> interpolate ( "{rqtype} {path}{query} {proto}\r\n" , array ( 'rqtype' => $ requestType , 'path' => $ this -> path , 'proto' => $ this -> protocol , 'query' => ( strlen ( $ this -> queryString ) ? '?' . $ this -> queryString : '' ) ) ) ; $ ms -> interpolate ( "Host: {host}\r\n" , array ( 'host' => $ this -> getEndpoint ( ) -> getAddress ( ) ) ) ; $ this -> adjustHeaders ( $ requestType ) ; foreach ( $ this -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( isset ( $ headerValue ) && strlen ( $ headerValue ) > 0 ) { $ ms -> interpolate ( "{headerName}: {headerValue}\r\n" , array ( 'headerName' => $ headerName , 'headerValue' => $ headerValue ) ) ; } } $ ms -> write ( "\r\n" ) ; return $ ms ; }
11755	public function markElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MARK_ELECT , $ params ] ) ; }
9133	public function route ( string $ name , Request $ request ) { $ parts = \ explode ( '/' , $ request -> getOrigin ( ) ) ; $ found = false ; for ( $ i = 0 ; $ i < count ( $ parts ) ; $ i ++ ) { if ( $ parts [ $ i ] === $ name && isset ( $ parts [ $ i + 1 ] ) ) { $ action = $ parts [ $ i + 1 ] ; if ( strpos ( $ action , "?" ) ) { $ action = strstr ( $ action , "?" , true ) ; } $ request -> setAction ( $ action ) ; $ found = true ; } } if ( ! $ found ) { $ request -> setAction ( "index" ) ; } $ controller = $ this -> getRoute ( $ name ) ; $ request -> setController ( $ controller -> getControllerSimpleName ( ) ) ; return $ controller ; }
8863	public function getHTMLFragments ( $ gridField ) { $ dataClass = $ gridField -> getList ( ) -> dataClass ( ) ; $ obj = singleton ( $ dataClass ) ; if ( ! $ obj -> canCreate ( ) ) return "" ; $ dbField = $ this -> getDataObjectField ( ) ; $ textField = TextField :: create ( "gridfieldaddbydbfield[" . $ obj -> ClassName . "][" . Convert :: raw2htmlatt ( $ dbField ) . "]" ) -> setAttribute ( "placeholder" , $ obj -> fieldLabel ( $ dbField ) ) -> addExtraClass ( "no-change-track" ) ; $ addAction = new GridField_FormAction ( $ gridField , 'add' , _t ( 'GridFieldAddByDBField.Add' , "Add {name}" , "Add button text" , array ( "name" => $ obj -> i18n_singular_name ( ) ) ) , 'add' , 'add' ) ; $ addAction -> setAttribute ( 'data-icon' , 'add' ) ; $ forTemplate = new ArrayData ( array ( ) ) ; $ forTemplate -> Fields = new ArrayList ( ) ; $ forTemplate -> Fields -> push ( $ textField ) ; $ forTemplate -> Fields -> push ( $ addAction ) ; return array ( $ this -> targetFragment => $ forTemplate -> renderWith ( "GridFieldAddByDBField" ) ) ; }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
2050	public function findBy ( $ strColumn , $ varValue ) { if ( parent :: findBy ( $ strColumn , $ varValue ) === false ) { return false ; } $ this -> arrGroups = $ this -> groups ; return true ; }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
11914	public function addDynamic ( $ name , $ factory , $ createDefault = 0 , $ forceDefault = false ) { $ control = new RContainer ( $ factory , $ createDefault , $ forceDefault ) ; $ control -> currentGroup = $ this -> currentGroup ; return $ this [ $ name ] = $ control ; }
7984	public function getCurrentMonitoring ( $ domain , $ type ) { $ type = strtolower ( $ type ) ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! in_array ( $ type , array ( 'cpu:max' , 'cpu:used' , 'mem:max' , 'mem:used' , 'net:rx' , 'net:tx' ) ) ) throw new BadMethodCallException ( 'Parameter $type must be "cpu:max" or "cpu:used" or "mem:max" or "mem:used" or "net:rx" or "net:tx". "' . $ type . '" given.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/use?type=' . $ type ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
12750	public function getUserAlias4User ( UserInterface $ user ) { if ( ! isset ( $ this -> userAliasCache [ $ user -> getUsername ( ) ] ) ) { $ userAliasEntityTmp = $ this -> getUserAliasEntity4User ( $ user ) ; if ( ! $ userAliasEntityTmp ) { $ userAliasEntityTmp = false ; } $ this -> userAliasCache [ $ user -> getUsername ( ) ] = $ userAliasEntityTmp ; } $ userAliasEntity = $ this -> userAliasCache [ $ user -> getUsername ( ) ] ; if ( $ userAliasEntity ) { $ result = $ userAliasEntity -> getCharName ( ) ; } else { $ result = $ user -> getUsername ( ) ; } return $ result ; }
9457	public function addCountableAttribute ( $ attribute ) { if ( empty ( $ attribute ) ) { return false ; } if ( in_array ( $ attribute , $ this -> getCountableAttributes ( ) , true ) ) { return false ; } $ this -> addToArrayValue ( 'countableAttributes' , $ attribute ) ; return $ this ; }
2463	public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
2183	public function create ( ) : ItemInterface { $ tree = $ this -> factory -> createItem ( 'root' ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: BACKEND_MENU_BUILD , new MenuEvent ( $ this -> factory , $ tree ) ) ; return $ tree ; }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7621	public function permissionMatchesRequest ( $ permissionUrl = '' , $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { $ requiredResourceType = $ resourceType ; if ( $ requiredResourceType == Storage :: RESOURCE_BLOB ) { $ requiredResourceType .= Storage :: RESOURCE_CONTAINER ; } $ parsedPermissionUrl = parse_url ( $ permissionUrl ) ; $ permissionParts = explode ( '&' , $ parsedPermissionUrl [ 'query' ] ) ; $ parsedRequestUrl = parse_url ( $ requestUrl ) ; $ matches = true ; foreach ( $ permissionParts as $ part ) { list ( $ property , $ value ) = explode ( '=' , $ part , 2 ) ; if ( $ property == 'sr' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredResourceType ) !== false ) ; } if ( $ property == 'sp' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredPermission ) !== false ) ; } } $ matches = $ matches && ( strpos ( $ parsedRequestUrl [ 'path' ] , $ parsedPermissionUrl [ 'path' ] ) !== false ) ; return $ matches ; }
9109	public function getResolverObject ( $ state = null , array $ options = array ( ) ) { if ( $ state == null && isset ( $ this -> resolverObject [ 'last_resolver' ] ) ) { return $ this -> resolverObject [ 'last_resolver' ] ; } if ( $ state != 'resolver_adapter_service' && $ state != 'mvclayout_resolver_adapter' ) throw new \ Exception ( 'Invalid state name provided.' ) ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] ) ) $ config = $ config [ 'theme_locator' ] ; else $ config = array ( ) ; if ( ! isset ( $ config [ $ state ] ) ) throw new \ Exception ( "Theme Resolver Service not present in config[$state]." ) ; $ config = $ config [ $ state ] ; if ( is_string ( $ config ) ) { $ config = array ( "{$config}" => 1 ) ; } if ( isset ( $ this -> resolverObject [ $ state ] ) ) { $ resolver = $ this -> resolverObject [ $ state ] ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; } else $ resolver = new Resolvers \ Aggregate ( ) ; foreach ( $ config as $ service => $ priority ) { if ( $ this -> getServiceLocator ( ) -> has ( $ service ) ) { $ service = $ this -> getServiceLocator ( ) -> get ( $ service ) ; } else { if ( ! class_exists ( $ service ) ) throw new \ Exception ( "Resolver '$service' not found for yimaTheme as Service either Class." ) ; $ service = new $ service ( ) ; } if ( $ service instanceof Resolvers \ LocatorResolverAwareInterface ) { $ service -> setThemeLocator ( $ this ) ; } if ( $ service instanceof Resolvers \ ConfigResolverAwareInterface ) { $ service -> setConfig ( $ this -> getConfig ( ) ) ; } if ( isset ( $ options [ 'event_mvc' ] ) ) if ( $ service instanceof Resolvers \ MvcResolverAwareInterface ) $ service -> setMvcEvent ( $ options [ 'event_mvc' ] ) ; $ resolver -> attach ( $ service , $ priority ) ; } $ this -> resolverObject [ $ state ] = $ resolver ; $ this -> resolverObject [ 'last_resolver' ] = $ resolver ; return $ resolver ; }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
10814	protected function _setDataStore ( $ dataStore ) { if ( ! is_null ( $ dataStore ) ) { $ dataStore = $ this -> _normalizeContainer ( $ dataStore ) ; } $ this -> dataStore = $ dataStore ; }
4214	public static function keyValues ( $ row , $ keys , & $ objInfo ) { $ objInfo = array ( 'row' => false , 'cols' => array ( ) , ) ; $ rowIsAbstraction = Abstracter :: isAbstraction ( $ row ) ; if ( $ rowIsAbstraction ) { if ( $ row [ 'type' ] == 'object' ) { $ objInfo [ 'row' ] = array ( 'className' => $ row [ 'className' ] , 'phpDoc' => $ row [ 'phpDoc' ] , ) ; $ row = self :: objectValues ( $ row ) ; if ( ! \ is_array ( $ row ) ) { $ objInfo [ 'row' ] = false ; $ row = array ( self :: SCALAR => $ row ) ; } elseif ( Abstracter :: isAbstraction ( $ row ) ) { $ objInfo [ 'row' ] = false ; $ row = array ( self :: SCALAR => $ row ) ; } } else { $ row = array ( self :: SCALAR => $ row ) ; } } if ( ! \ is_array ( $ row ) ) { $ row = array ( self :: SCALAR => $ row ) ; } $ values = array ( ) ; foreach ( $ keys as $ key ) { if ( \ array_key_exists ( $ key , $ row ) ) { $ value = $ row [ $ key ] ; if ( $ value !== null ) { $ objInfo [ 'cols' ] [ $ key ] = false ; } if ( Abstracter :: isAbstraction ( $ value ) ) { if ( isset ( $ value [ 'stringified' ] ) ) { $ objInfo [ 'cols' ] [ $ key ] = $ value [ 'className' ] ; $ value = $ value [ 'stringified' ] ; } elseif ( isset ( $ value [ '__toString' ] [ 'returnValue' ] ) ) { $ objInfo [ 'cols' ] [ $ key ] = $ value [ 'className' ] ; $ value = $ value [ '__toString' ] [ 'returnValue' ] ; } } } else { $ value = Abstracter :: UNDEFINED ; } $ values [ $ key ] = $ value ; } return $ values ; }
8968	protected function load ( ) { $ this -> rates = array ( ) ; $ this -> latest = array ( ) ; $ handle = fopen ( $ this -> pathToFile , 'rb' ) ; if ( ! $ handle ) { throw new RuntimeException ( sprintf ( 'Error opening file on path "%s".' , $ this -> pathToFile ) ) ; } while ( ( $ line = fgets ( $ handle ) ) !== false ) { $ rate = $ this -> fromJson ( $ line ) ; $ this -> rates [ $ this -> getRateKey ( $ rate -> getCurrencyCode ( ) , $ rate -> getDate ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ] = $ rate ; $ latestKey = sprintf ( '%s_%s_%s' , $ rate -> getCurrencyCode ( ) , $ rate -> getRateType ( ) , $ rate -> getSourceName ( ) ) ; if ( ! isset ( $ this -> latest [ $ latestKey ] ) || ( $ this -> latest [ $ latestKey ] -> getDate ( ) < $ rate -> getDate ( ) ) ) { $ this -> latest [ $ latestKey ] = $ rate ; } } fclose ( $ handle ) ; return $ this -> rates ; }
919	public function getEnd ( ) { $ reachedContent = false ; foreach ( $ this -> doc -> getLines ( ) as $ index => $ line ) { if ( $ reachedContent && ( $ line -> containsATag ( ) || ! $ line -> containsUsefulContent ( ) ) ) { return $ index - 1 ; } if ( $ line -> containsATag ( ) ) { return null ; } if ( $ line -> containsUsefulContent ( ) ) { $ reachedContent = true ; } } }
1454	protected function validateRelationship ( RelationshipInterface $ relationship , $ key = null ) { if ( ! $ relationship -> has ( RelationshipInterface :: DATA ) ) { $ this -> addError ( $ this -> errorFactory -> memberRequired ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ relationship -> isHasOne ( ) && ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> memberRelationshipExpected ( RelationshipInterface :: DATA , $ key ? P :: relationship ( $ key ) : P :: data ( ) ) ) ; return false ; } if ( ! $ this -> validateEmpty ( $ relationship , $ key ) ) { return false ; } return true ; }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
5185	private function generalAttachment ( Article $ article , array $ attachmentConst , array $ attachmentype , array $ attributes , array $ dataArticle ) : Article { $ numOfAttachments = count ( $ attachmentConst ) ; for ( $ i = 0 ; $ i < $ numOfAttachments ; $ i ++ ) { $ attachments = $ this -> attachment ( $ attachmentype [ $ i ] , $ attributes [ $ i ] , $ dataArticle ) ; for ( $ j = 0 ; $ j < $ attachments [ 'numberOfItems' ] ; $ j ++ ) { $ attachment = $ attachments [ 'attachments' ] [ $ j ] ; $ article -> attach ( $ attachmentConst [ $ i ] , $ attachment ) ; } } return $ article ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
557	protected function buildConjunctionCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } $ result = [ $ operator ] ; foreach ( $ condition as $ part ) { $ result [ ] = $ this -> buildCondition ( $ part ) ; } return $ result ; }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
11155	public function getValueByPowers ( array $ values , array $ powers ) { if ( empty ( $ values ) || empty ( $ powers ) || \ count ( $ values ) !== \ count ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty parameter or count not equal' ) ; } $ values = \ array_values ( $ values ) ; $ powers = \ array_values ( $ powers ) ; $ rolledIndex = $ this -> getArrayKeyByPowers ( $ powers ) ; return $ values [ $ rolledIndex ] ; }
8354	private function buildEnum ( string $ enumName , array $ enumDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ enumRealName = null ; if ( isset ( $ enumDefinition [ 'name' ] ) === true ) { $ enumRealName = $ enumDefinition [ 'name' ] ; } else { $ enumRealName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ enumName ) ; } if ( isset ( $ enumDefinition [ 'values' ] ) === false ) { throw new InvalidSchemaDefinition ( 'enum "' . $ enumName . '" has no value' ) ; } $ values = array ( ) ; foreach ( $ enumDefinition [ 'values' ] as $ valueName => $ valueAlias ) { $ valueRealName = null ; if ( is_string ( $ valueName ) === true ) { $ valueRealName = $ valueName ; } else { $ valueRealName = Helper :: codifyName ( $ enumName ) . '_' . Helper :: codifyName ( $ valueAlias ) ; } $ values [ ] = $ valueRealName ; } $ statement = Mutation \ AddEnum :: statement ( $ database , $ enumRealName , $ values ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } echo $ enumName . ' - Done' . PHP_EOL ; }
10602	public function addQuery ( $ name , $ value ) { $ part = $ name . '=' . $ value ; $ this -> _urlParts [ 'query' ] .= empty ( $ this -> _urlParts [ 'query' ] ) ? $ part : '&' . $ part ; return $ this ; }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
2035	public function onUnregister ( Registry $ registry ) { parent :: onUnregister ( $ registry ) ; if ( $ this -> fallback && $ this -> type == 'root' && $ registry -> isRegisteredAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ) { $ registry -> unregisterAlias ( $ this , 'contao.dns-fallback' , $ this -> dns ) ; } }
681	protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
5392	public function paintPass ( $ message ) { parent :: paintPass ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'pass>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "pass>\n" ; }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
5034	public function hydrate ( $ value ) { if ( ! is_array ( $ value ) ) { return null ; } $ entity = $ this -> getTargetEntity ( ) ; foreach ( $ value as $ key => $ v ) { $ entity -> { "set$key" } ( $ v ) ; } return $ entity ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
10132	private function writePassword ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) || ! $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) { return ; } $ record = 0x0013 ; $ length = 0x0002 ; $ wPassword = hexdec ( $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ wPassword ) ; $ this -> append ( $ header . $ data ) ; }
11311	protected static function getMessage ( $ code ) { $ mapping = static :: getMappings ( ) ; if ( isset ( $ mapping [ $ code ] ) ) { return $ mapping [ $ code ] ; } return ( string ) $ code ; }
3037	public function set ( $ userId , $ callId , $ data ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ cache = $ this -> getFromCache ( $ key ) ; if ( is_null ( $ cache ) || $ cache != $ data ) { $ this -> putInCache ( $ key , $ userId , $ callId , $ data , self :: STATE_PENDING_WRITE ) ; } return true ; }
7781	public function get ( $ key ) { if ( array_key_exists ( $ key , $ this -> messages ) ) { return ! empty ( $ this -> messages [ $ key ] ) ? $ this -> messages [ $ key ] : null ; } return null ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
11537	public function get ( $ name , $ default = "" ) { $ param = Arr :: get ( $ _REQUEST , $ name , $ default ) ; if ( $ _SERVER [ "REQUEST_METHOD" ] == "GET" && is_string ( $ param ) ) { $ param = urldecode ( $ param ) ; } return $ param ; }
1942	public function listRecipient ( $ row ) { $ label = Contao \ Idna :: decodeEmail ( $ row [ 'email' ] ) ; if ( $ row [ 'addedOn' ] ) { $ label .= ' <span style="color:#999;padding-left:3px">(' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'subscribed' ] , Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ row [ 'addedOn' ] ) ) . ')</span>' ; } else { $ label .= ' <span style="color:#999;padding-left:3px">(' . $ GLOBALS [ 'TL_LANG' ] [ 'tl_newsletter_recipients' ] [ 'manually' ] . ')</span>' ; } return sprintf ( '<div class="tl_content_left"><div class="list_icon" style="background-image:url(\'%ssystem/themes/%s/icons/%s.svg\')" data-icon="member.svg" data-icon-disabled="member_.svg">%s</div></div>' , Contao \ System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) , Contao \ Backend :: getTheme ( ) , ( $ row [ 'active' ] ? 'member' : 'member_' ) , $ label ) . "\n" ; }
1458	protected function previous ( Cursor $ cursor , $ columns ) { $ items = $ this -> whereId ( $ cursor -> getBefore ( ) , $ this -> descending ? '>' : '<' ) -> orderForPrevious ( ) -> get ( $ cursor -> getLimit ( ) , $ columns ) -> reverse ( ) -> values ( ) ; return new CursorPaginator ( $ items , true , $ cursor , $ this -> key ) ; }
8401	public function render ( RenderInterface $ render , $ status = 200 ) { $ this -> renderInst = $ render ; $ this -> status = $ status ; }
