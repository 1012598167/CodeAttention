12749	private function validateSKU ( string $ sku ) { if ( strlen ( $ sku ) == 0 ) { throw new SKUException ( "A SKU cannot be empty" ) ; } $ containsWhitespace = preg_match ( $ this -> whiteSpacePattern , $ sku ) == 1 ; if ( $ containsWhitespace ) { throw new SKUException ( sprintf ( "A SKU cannot contain white space characters: \"%s\"" , $ sku ) ) ; } $ containsUppercaseCharacters = preg_match ( $ this -> uppercaseCharactersPattern , $ sku ) == 1 ; if ( $ containsUppercaseCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot contain uppercase characters: \"%s\"" , $ sku ) ) ; } $ containsInvalidCharacters = preg_match ( $ this -> invalidCharactersPattern , $ sku ) == 1 ; if ( $ containsInvalidCharacters ) { throw new SKUException ( sprintf ( "The SKU \"%s\" contains invalid characters. A SKU can only contain the following characters: a-z, 0-9 and -" , $ sku ) ) ; } $ prefixMatches = [ ] ; $ prefixContainsInvalidCharacters = preg_match ( $ this -> invalidPrefixCharacters , $ sku , $ prefixMatches ) == 1 ; if ( $ prefixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot start with the given characters: \"%s\"" , implode ( "" , $ prefixMatches ) ) ) ; } $ suffixMatches = [ ] ; $ suffixContainsInvalidCharacters = preg_match ( $ this -> invalidSuffixCharacters , $ sku , $ suffixMatches ) == 1 ; if ( $ suffixContainsInvalidCharacters ) { throw new SKUException ( sprintf ( "A SKU cannot end with the given characters: \"%s\"" , implode ( "" , $ suffixMatches ) ) ) ; } if ( strlen ( $ sku ) < $ this -> minLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too short. The minimum length for a SKU is: %s" , $ sku , $ this -> minLength ) ) ; } if ( strlen ( $ sku ) > $ this -> maxLength ) { throw new SKUException ( sprintf ( "The given SKU \"%s\" is too long (%s character). The maximum length for a SKU is: %s" , strlen ( $ sku ) , $ sku , $ this -> maxLength ) ) ; } }
7220	public static function json ( $ content , $ code = 200 ) { if ( is_a ( $ content , "SnooPHP\Model\Collection" ) ) $ content = $ content -> array ( ) ; return new static ( to_json ( $ content ) , $ code , [ "Content-Type" => "application/json; charset=utf-8" ] ) ; }
1914	protected function generateHashes ( $ sum ) { $ time = ( int ) round ( time ( ) / 60 / 30 ) ; return array_map ( function ( $ hashTime ) use ( $ sum ) { return hash_hmac ( 'sha256' , $ sum . "\0" . $ hashTime , System :: getContainer ( ) -> getParameter ( 'kernel.secret' ) ) ; } , array ( $ time , $ time - 1 ) ) ; }
122	private function createAuthFromUrl ( ) { $ uri = parse_url ( $ this -> url ) ; if ( empty ( $ uri [ 'user' ] ) ) { return $ this -> hasAuth = false ; } $ this -> credentials [ 'username' ] = $ uri [ 'user' ] ; if ( ! empty ( $ uri [ 'pass' ] ) ) { $ this -> credentials [ 'password' ] = $ uri [ 'pass' ] ; } return $ this -> hasAuth = true ; }
1485	public function prepend ( Decoding ... $ decodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ decodings ) ; return $ copy ; }
9539	private function getClosure ( $ parameter ) { $ closure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ closure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] -> parameterClosure ; } } return $ closure ; }
572	public function validatePassword ( $ password , $ hash ) { if ( ! is_string ( $ password ) || $ password === '' ) { throw new InvalidArgumentException ( 'Password must be a string and cannot be empty.' ) ; } if ( ! preg_match ( '/^\$2[axy]\$(\d\d)\$[\.\/0-9A-Za-z]{22}/' , $ hash , $ matches ) || $ matches [ 1 ] < 4 || $ matches [ 1 ] > 30 ) { throw new InvalidArgumentException ( 'Hash is invalid.' ) ; } if ( function_exists ( 'password_verify' ) ) { return password_verify ( $ password , $ hash ) ; } $ test = crypt ( $ password , $ hash ) ; $ n = strlen ( $ test ) ; if ( $ n !== 60 ) { return false ; } return $ this -> compareString ( $ test , $ hash ) ; }
11002	public function setRedirect ( $ hostname ) { if ( ! empty ( $ hostname ) ) { $ this -> redirect = new URL ( $ hostname ) ; $ this -> redirect -> set ( 'path' , rtrim ( $ this -> redirect -> path , '/' ) ) ; } else $ this -> redirect = false ; return $ this ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
1375	private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
12558	public function actionFlush ( $ category = null ) { if ( is_null ( $ category ) ) { $ category = $ this -> prompt ( "Category (blank for all): " ) ; } if ( empty ( $ category ) ) { $ category = 'all' ; } else { $ category = [ 'category' , $ category ] ; } Cacher :: invalidateGroup ( $ category ) ; $ this -> out ( "Done!" ) ; }
5810	public function updateSearchableFields ( & $ fields ) { $ fields = array_merge ( array ( 'Tagging' => array ( 'title' => 'Tags' , 'field' => ListboxField :: create ( 'Tagging' , 'Tags' , FusionTag :: get ( ) -> map ( 'Title' , 'Title' ) -> toArray ( ) , ( Controller :: has_curr ( ) && ( $ filtering = Controller :: curr ( ) -> getRequest ( ) -> getVar ( 'q' ) ) && isset ( $ filtering [ 'Tagging' ] ) ) ? $ filtering [ 'Tagging' ] : array ( ) , null , true ) , 'filter' => $ this -> owner -> dbObject ( 'Tagging' ) -> stat ( 'default_search_filter_class' ) ) ) , $ fields ) ; $ this -> owner -> extend ( 'updateTaggingExtensionSearchableFields' , $ fields ) ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
285	public function setDefault ( $ name , $ value ) { $ name = strtolower ( $ name ) ; if ( empty ( $ this -> _headers [ $ name ] ) ) { $ this -> _headers [ $ name ] [ ] = $ value ; } return $ this ; }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
12923	public function getLocalDataItems ( ) { if ( ! isset ( $ this -> _localDataItems ) ) { $ this -> trigger ( self :: EVENT_LOAD_LOCAL_DATA_ITEMS ) ; } return $ this -> _localDataItems ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
5670	protected function describeGenericDifference ( $ first , $ second ) { return sprintf ( 'as [%s] does not match [%s]' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) ) ; }
10622	public static function forThe ( MapsObjectsByIdentity $ mapped , string ... $ allowedClasses ) : MapsObjectsByIdentity { foreach ( $ mapped -> objects ( ) as $ object ) { if ( Whitelist :: doesNotHave ( $ object , $ allowedClasses ) ) { $ mapped = $ mapped -> removeThe ( $ object ) ; } } return new Whitelist ( $ allowedClasses , $ mapped ) ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
7933	public function loadFromArray ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'load-from-array' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ item = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; if ( isset ( $ item [ 'files' ] [ 'js' ] ) && is_array ( $ item [ 'files' ] [ 'js' ] ) ) $ item [ 'files' ] [ 'js' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'js' ] ) ; if ( isset ( $ item [ 'files' ] [ 'css' ] ) && is_array ( $ item [ 'files' ] [ 'css' ] ) ) $ item [ 'files' ] [ 'css' ] = $ this -> applyNamespaces ( $ item [ 'files' ] [ 'css' ] ) ; $ this -> loaded [ ] = $ item ; if ( isset ( $ item [ 'require' ] ) && is_array ( $ item [ 'require' ] ) ) { foreach ( $ item [ 'require' ] as $ name ) { $ this -> loadFromCollection ( $ name ) ; } } return $ this ; }
10089	function addAttachmentFromBase64Data ( $ filename , $ mimetype , $ contents ) { $ attachment = new Attachment ( $ filename , $ mimetype , $ contents ) ; $ this -> attachments [ ] = $ attachment ; }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
2433	public function get ( $ strKey ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { return $ this -> session -> get ( $ strKey ) ; } return $ this -> sessionBag -> get ( $ strKey ) ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
2999	public function setErrors ( $ email , $ title = null ) { $ this -> set ( 'Sender' , $ this -> buildMail ( $ email , $ title ) ) ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
1874	private function addComponents ( ContainerBuilder $ container ) : void { $ packages = $ container -> getDefinition ( 'assets.packages' ) ; $ context = new Reference ( 'contao.assets.assets_context' ) ; foreach ( Versions :: VERSIONS as $ name => $ version ) { if ( 0 !== strncmp ( 'contao-components/' , $ name , 18 ) ) { continue ; } $ serviceId = 'assets._package_' . $ name ; $ basePath = 'assets/' . substr ( $ name , 18 ) ; $ version = $ this -> createVersionStrategy ( $ container , $ version , $ name ) ; $ container -> setDefinition ( $ serviceId , $ this -> createPackageDefinition ( $ basePath , $ version , $ context ) ) ; $ packages -> addMethodCall ( 'addPackage' , [ $ name , new Reference ( $ serviceId ) ] ) ; } }
239	private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; }
8242	protected function handleLogin ( Request $ httpRequest ) { $ post = $ httpRequest -> request ; if ( ! $ post -> has ( "username" ) || ! $ post -> has ( "password" ) ) { return ; } if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGIN_CSRF_ACTION ) ) { $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } $ username = strtolower ( trim ( $ post -> get ( "username" ) ) ) ; $ password = new Password ( $ post -> get ( "password" ) ) ; if ( ! $ this -> limit -> action ( "login" , false , array ( "name" => $ username ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } if ( ! $ this -> loginAttempt ( $ username , $ password ) ) { $ this -> logInvalidLoginAttempt ( $ username ) ; $ this -> limit -> action ( "login" , true , array ( "name" => $ username ) ) ; $ this -> session -> addFlash ( "error" , "Invalid username or password" ) ; $ this -> picoAuth -> redirectToLogin ( null , $ httpRequest ) ; return ; } else { $ userData = $ this -> storage -> getUserByName ( $ username ) ; if ( $ this -> needsPasswordRehash ( $ userData ) ) { $ this -> passwordRehash ( $ username , $ password ) ; } $ this -> login ( $ username , $ userData ) ; $ this -> picoAuth -> afterLogin ( ) ; } }
7974	public function getSender ( $ domain , $ sender ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ sender ) throw new BadMethodCallException ( 'Parameter $sender is missing.' ) ; $ sender = urlencode ( $ sender ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/senders/' . $ sender ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
1057	public static function findTypesThatChangedKind ( Schema $ schemaA , Schema $ schemaB ) : iterable { $ schemaATypeMap = $ schemaA -> getTypeMap ( ) ; $ schemaBTypeMap = $ schemaB -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( $ schemaATypeMap as $ typeName => $ schemaAType ) { if ( ! isset ( $ schemaBTypeMap [ $ typeName ] ) ) { continue ; } $ schemaBType = $ schemaBTypeMap [ $ typeName ] ; if ( $ schemaAType instanceof $ schemaBType ) { continue ; } if ( $ schemaBType instanceof $ schemaAType ) { continue ; } $ schemaATypeKindName = self :: typeKindName ( $ schemaAType ) ; $ schemaBTypeKindName = self :: typeKindName ( $ schemaBType ) ; $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_CHANGED_KIND , 'description' => "${typeName} changed from ${schemaATypeKindName} to ${schemaBTypeKindName}." , ] ; } return $ breakingChanges ; }
10932	public function hasRowsWith ( string $ tablename , string $ colName , $ colValue ) : bool { return ( $ this -> countRowsWith ( $ tablename , $ colName , $ colValue ) > 0 ) ; }
8865	public function run ( PayloadInterface $ payload ) { $ tasks = $ this -> getTaskCollection ( ) -> getTasks ( ) ; $ tasksCount = $ tasks -> count ( ) ; if ( 0 === $ tasksCount ) { throw new LogicException ( 'Can\'t invoke task run. Empty task collection set.' ) ; } $ this -> log ( LogLevel :: INFO , sprintf ( 'Starting runner with %s tasks ready for execution.' , $ tasksCount ) ) ; $ this -> dispatch ( 'runner.start' , null , $ payload ) ; foreach ( $ tasks as $ task ) { try { $ task -> setPayload ( $ payload ) ; $ this -> runTask ( $ task , $ payload ) ; } catch ( \ Exception $ e ) { $ this -> logTask ( $ task , LogLevel :: ERROR , sprintf ( 'An exception was thrown. Message: %s' , $ e -> getMessage ( ) ) ) ; $ this -> dispatch ( 'runner.failure' , null , null , null , $ e ) ; throw new RunFailedException ( 'Complete run failed: ' . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } $ this -> log ( LogLevel :: INFO , 'All tasks were processed.' ) ; $ this -> log ( LogLevel :: INFO , 'Calling attached runners.' ) ; $ this -> notify ( $ payload ) ; $ this -> log ( LogLevel :: INFO , 'Execution successful.' ) ; $ this -> dispatch ( 'runner.success' , null , $ payload ) ; return $ payload ; }
7633	public function putBlock ( $ containerName = '' , $ blobName = '' , $ identifier = '' , $ contents = '' , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ identifier , 'Block identifier is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; if ( strlen ( $ contents ) > self :: MAX_BLOB_TRANSFER_SIZE ) { throw new BlobException ( 'Block size is too big.' ) ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'block' , 'blockid' => base64_encode ( $ identifier ) ) , 'PUT' , $ headers , false , $ contents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
1123	public function descendantsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '>=' , $ this -> getLeft ( ) ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getRight ( ) ) ; }
9854	protected function append ( $ data ) { if ( strlen ( $ data ) - 4 > $ this -> limit ) { $ data = $ this -> addContinue ( $ data ) ; } $ this -> _data .= $ data ; $ this -> _datasize += strlen ( $ data ) ; }
11061	public static function supportedEncodings ( ) { if ( static :: $ supported_encodings === null ) { $ supported = mb_list_encodings ( ) ; foreach ( $ supported as $ key => $ value ) { static :: $ supported_encodings [ strtolower ( $ value ) ] = $ value ; foreach ( mb_encoding_aliases ( $ value ) as $ k => $ v ) { static :: $ supported_encodings [ strtolower ( $ v ) ] = $ value ; } } } return static :: $ supported_encodings ; }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
8438	public function setPostLink ( TimelineLinkEvent $ event ) : void { $ action = $ event -> getAction ( ) ; if ( ! in_array ( $ action -> getVerb ( ) , [ 'post' , 'reply' ] ) ) { return ; } $ production = $ action -> getComponent ( 'indirectComplement' ) -> getData ( ) ; $ post = $ action -> getComponent ( 'directComplement' ) -> getData ( ) ; $ event -> setLink ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) , '_fragment' => 'post-' . $ post -> getId ( ) , ] ) ) ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
753	public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
1033	private function getPromise ( $ value ) { if ( $ value === null || $ value instanceof Promise ) { return $ value ; } if ( $ this -> exeContext -> promises -> isThenable ( $ value ) ) { $ promise = $ this -> exeContext -> promises -> convertThenable ( $ value ) ; if ( ! $ promise instanceof Promise ) { throw new InvariantViolation ( sprintf ( '%s::convertThenable is expected to return instance of GraphQL\Executor\Promise\Promise, got: %s' , get_class ( $ this -> exeContext -> promises ) , Utils :: printSafe ( $ promise ) ) ) ; } return $ promise ; } return null ; }
10561	public function createController ( $ route , $ params ) { $ control = NULL ; $ route = ltrim ( $ route , '/' ) ; $ route = rtrim ( $ route , '/' ) ; $ vars = explode ( '/' , $ route ) ; if ( 1 === count ( $ vars ) && '' == $ vars [ 0 ] ) { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 1 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ this -> defaultAction ) ; } else if ( 2 === count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; } else if ( 2 < count ( $ vars ) ) { $ control = $ this -> _buildControllerName ( $ vars [ 0 ] . 'Controller' ) ; array_shift ( $ vars ) ; $ aName = $ this -> _buildActionName ( $ control , $ vars [ 0 ] ) ; array_shift ( $ vars ) ; } else { $ control = $ this -> _buildControllerName ( $ this -> defaultController . 'Controller' ) ; $ aName = $ this -> defaultAction . 'Action' ; } $ action = new Action ( $ aName , $ params ) ; $ controller = new $ control ( $ this -> config ) ; $ controller -> setAction ( $ action ) ; $ controller -> setDispatcher ( $ this -> dispatcher ) ; $ controller -> addDefaultListeners ( ) ; return $ controller ; }
4954	public function initialize ( $ instance , ServiceLocatorInterface $ serviceLocator ) { if ( ! $ instance instanceof HeadscriptProviderInterface ) { return ; } $ scripts = $ instance -> getHeadscripts ( ) ; if ( ! is_array ( $ scripts ) || empty ( $ scripts ) ) { return ; } $ services = $ serviceLocator ; $ helpers = $ services -> get ( 'ViewHelperManager' ) ; $ basepath = $ helpers -> get ( 'basepath' ) ; $ headscript = $ helpers -> get ( 'headscript' ) ; foreach ( $ scripts as $ script ) { $ headscript -> appendFile ( $ basepath ( $ script ) ) ; } }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
5820	protected function transformFiles ( $ files ) { $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = [ 'type' => $ file [ 'content_type' ] === 'application/directory' ? 'dir' : 'file' , 'path' => $ file [ 'name' ] , 'size' => intval ( $ file [ 'bytes' ] ) , 'timestamp' => strtotime ( $ file [ 'last_modified' ] ) , 'mimetype' => $ file [ 'content_type' ] , ] ; } return $ result ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
4082	public function getInputScreen ( $ metaModel ) { $ inputScreen = $ this -> getInputScreenDetails ( $ metaModel ) ; return $ inputScreen ? $ inputScreen -> getId ( ) : null ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
3277	public function getKeys ( ) : array { $ keys = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ keys [ ] = $ line -> getKey ( ) ; } return $ keys ; }
7428	public function renderObject ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> objectDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
8686	public static function remove ( & $ data , $ path , $ default = null ) { if ( ! static :: $ unsetMarker ) { static :: $ unsetMarker = new \ stdClass ( ) ; } $ value = static :: get ( $ data , $ path , static :: $ unsetMarker ) ; if ( $ value === static :: $ unsetMarker ) { return $ default ; } static :: set ( $ data , $ path , static :: $ unsetMarker ) ; return $ value ; }
10902	public function loadRelation ( string $ name ) { if ( ! isset ( $ this -> relationObjects [ $ name ] ) || empty ( $ this -> relationObjects [ $ name ] ) ) { $ relation = $ this -> getRelations ( ) [ $ name ] ; if ( ! $ relation || ! $ relation [ 'entity' ] || ! $ this -> get ( $ relation [ 'key' ] ?? 'id' ) ) { return null ; } $ entity = $ this -> entity ( $ relation [ 'entity' ] ) ; $ type = $ relation [ 'type' ] ?? 'has_one' ; $ key = $ relation [ 'key' ] ?? ( 'has_one' === $ type ? $ this -> __getEntityName ( ) . '_id' : 'id' ) ; $ foreignKey = $ relation [ 'foreign_key' ] ?? ( 'has_one' === $ type ? 'id' : $ this -> __getEntityName ( ) . '_id' ) ; $ assoc = $ relation [ 'assoc' ] ?? false ; $ this -> relationObjects [ $ name ] = ( 'has_one' === $ type ) ? $ entity -> load ( $ this -> get ( $ key ) , $ foreignKey ) : $ entity -> loadAll ( [ $ foreignKey => $ this -> get ( $ key ) ] , $ assoc ) ; } return $ this -> relationObjects [ $ name ] ?? null ; }
316	public function renderAjax ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; ob_start ( ) ; ob_implicit_flush ( false ) ; $ this -> beginPage ( ) ; $ this -> head ( ) ; $ this -> beginBody ( ) ; echo $ this -> renderFile ( $ viewFile , $ params , $ context ) ; $ this -> endBody ( ) ; $ this -> endPage ( true ) ; return ob_get_clean ( ) ; }
8324	public function getPingbacks ( ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get_pingback" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ data = explode ( '|' , $ responseText ) ; unset ( $ data [ 0 ] ) ; return empty ( $ data [ 1 ] ) ? [ ] : array_values ( $ data ) ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
1156	public function sometimes ( $ attribute , $ rules , callable $ callback ) { $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; }
94	protected function hasVendorIgnore ( $ ignoreFile , $ vendor = 'vendor' ) { if ( ! file_exists ( $ ignoreFile ) ) { return false ; } $ pattern = sprintf ( '{^/?%s(/\*?)?$}' , preg_quote ( $ vendor ) ) ; $ lines = file ( $ ignoreFile , FILE_IGNORE_NEW_LINES ) ; foreach ( $ lines as $ line ) { if ( preg_match ( $ pattern , $ line ) ) { return true ; } } return false ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
11632	private function groupPvTrans ( $ transData ) { $ result = [ ] ; foreach ( $ transData as $ one ) { $ debitAccId = $ one -> get ( DTrans :: A_ACC_ID_DEBIT ) ; $ creditAccId = $ one -> get ( DTrans :: A_ACC_ID_CREDIT ) ; $ value = $ one -> get ( DTrans :: A_AMOUNT ) ; if ( isset ( $ result [ $ debitAccId ] ) ) { $ result [ $ debitAccId ] -= $ value ; } else { $ result [ $ debitAccId ] = - $ value ; } if ( isset ( $ result [ $ creditAccId ] ) ) { $ result [ $ creditAccId ] += $ value ; } else { $ result [ $ creditAccId ] = $ value ; } } return $ result ; }
7746	private function findSetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ setter = 'set' . $ this -> camelize ( $ this -> name ) ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ setter ) && $ reflClass -> getMethod ( $ setter ) -> isPublic ( ) ) { $ this -> setter = $ setter ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( 0 === strpos ( $ this -> name , 'set' ) ) && $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__set' ) && $ reflClass -> getMethod ( '__set' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_PROPERTY ; } }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
6182	public static function redirect ( $ url = '' , $ status = 301 , $ headers = [ ] ) { $ Response = new Response ( ) ; $ Response -> status ( $ status ) ; if ( ! empty ( $ headers ) ) { $ Response -> headers ( $ headers ) ; } $ Response -> headers ( [ 'Location' => ( new Router ( ) ) -> makeUrl ( $ url ) , ] ) ; return $ Response ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
2687	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ configPaths = [ 'geoip_country_mapping' => \ Fastly \ Cdn \ Model \ Config :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ] ; foreach ( $ configPaths as $ path ) { $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ output -> writeln ( 'Warning : This function is used for converting serialized data to JSON' . ' (recommended for Magento versions above 2.2)' ) ; } $ oldData = $ this -> scopeConfig -> getValue ( $ path ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = false ; } if ( $ oldData === false ) { $ output -> writeln ( 'Invalid serialization format, unable to unserialize config data : ' . $ path ) ; return ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ path , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; $ output -> writeln ( 'Config Cache Flushed' ) ; } }
1234	private function toXml ( $ elementName , $ rootElement = false ) { return sprintf ( '%s<%s%s%s>%s</%s>' , $ rootElement ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" : '' , $ elementName , $ this -> attributesToXml ( ) , array_key_exists ( get_class ( $ this ) , self :: $ xmlNamespaces ) ? sprintf ( ' %s' , self :: $ xmlNamespaces [ get_class ( $ this ) ] ) : '' , $ this -> propertiesToXml ( ) , $ elementName ) ; }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
3524	private function fetch ( $ account_id ) { if ( ! $ account_id ) return null ; $ data = FortniteClient :: sendFortniteGetRequest ( FortniteClient :: FORTNITE_API . 'stats/accountId/' . $ account_id . '/bulk/window/alltime' , $ this -> access_token ) ; $ this -> display_name = Account :: getDisplayNameFromID ( str_replace ( "-" , "" , $ this -> account_id ) , $ this -> access_token ) ; $ compiledStats = [ ] ; foreach ( $ data as $ stat ) { $ parsed = $ this -> parseStatItem ( $ stat ) ; $ compiledStats = array_merge_recursive ( $ compiledStats , $ parsed ) ; } $ platforms = [ ] ; foreach ( $ compiledStats as $ key => $ platform ) { $ platforms [ $ key ] = new Platform ( $ platform ) ; } return $ platforms ; }
2363	public static function decodeEntities ( $ strString , $ strQuoteStyle = ENT_COMPAT , $ strCharset = null ) { if ( $ strString == '' ) { return '' ; } if ( $ strCharset === null ) { $ strCharset = Config :: get ( 'characterSet' ) ; } $ strString = preg_replace ( '/(&#*\w+)[\x00-\x20]+;/i' , '$1;' , $ strString ) ; $ strString = preg_replace ( '/(&#x*)([0-9a-f]+);/i' , '$1$2;' , $ strString ) ; return html_entity_decode ( $ strString , $ strQuoteStyle , $ strCharset ) ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
5672	protected function describeFloatDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return sprintf ( 'because [%s] differs from [%s] by %s' , $ this -> describeValue ( $ first ) , $ this -> describeValue ( $ second ) , abs ( $ first - $ second ) ) ; }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
1816	public function pagePicker ( Contao \ DataContainer $ dc ) { @ trigger_error ( 'Using tl_content::pagePicker() has been deprecated and will no longer work in Contao 5.0. Set the "dcaPicker" eval attribute instead.' , E_USER_DEPRECATED ) ; return Contao \ Backend :: getDcaPickerWizard ( true , $ dc -> table , $ dc -> field , $ dc -> inputName ) ; }
8678	public function chunk ( $ size , $ preserveKeys = false ) { $ create = function ( $ items ) { return $ this -> createFrom ( $ items ) ; } ; return $ this -> createFrom ( array_map ( $ create , array_chunk ( $ this -> items , $ size , $ preserveKeys ) ) ) ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
10985	public static function checkPhpVersion ( ) { $ version = null ; if ( \ defined ( 'PHP_VERSION' ) ) { $ version = PHP_VERSION ; } else { $ version = phpversion ( '' ) ; } if ( strpos ( $ version , '-' ) !== false ) { $ version = substr ( $ version , 0 , strpos ( $ version , '-' ) ) ; } return $ version ; }
5003	protected function getConfig ( $ services , $ name ) { $ defaults = [ 'service' => 'EventManager' , 'configure' => true , 'identifiers' => [ $ name ] , 'event' => '\Zend\EventManager\Event' , 'listeners' => [ ] , ] ; $ config = $ services -> get ( 'Config' ) ; $ config = isset ( $ config [ 'event_manager' ] [ $ name ] ) ? $ config [ 'event_manager' ] [ $ name ] : [ ] ; $ config = array_replace_recursive ( $ defaults , $ config ) ; return $ config ; }
7440	protected function reloadModule ( Wrapper $ wrapper , $ module ) { $ moduleStatus = $ wrapper -> ModuleManager -> reload ( $ module ) ; $ module = Inflector :: camelize ( $ module ) ; switch ( $ moduleStatus ) { case 'AU' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` doesn\'t exist and cannot be reloaded.' ) ; break ; case 'AL' : $ wrapper -> Channel -> sendMessage ( 'The Module `' . $ module . '` is already loaded.' ) ; break ; case 'L' : $ wrapper -> Channel -> sendMessage ( 'Module `' . $ module . '` reloaded successfully.' ) ; break ; case 'NF' : $ wrapper -> Channel -> sendMessage ( 'Failed to reload the Module `' . $ module . '`.' ) ; break ; } }
648	public function addCommentOnTable ( $ table , $ comment ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addCommentOnTable ( $ table , $ comment ) ; return $ this -> setSql ( $ sql ) ; }
6819	protected function writeInvoiceShipmentLine ( ) { $ amount = $ this -> invoice -> getShipmentBase ( ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { return ; } $ amount = $ this -> round ( $ amount ) ; $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ taxRule = $ this -> taxResolver -> resolveSaleTaxRule ( $ sale ) ; $ account = $ this -> getShipmentAccountNumber ( $ taxRule , $ this -> invoice -> getNumber ( ) ) ; if ( $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } }
4534	public function setCandidateGroup ( ? string $ candidateGroup ) { $ this -> candidateGroup = $ candidateGroup ; $ this -> _candidateGroup = null !== $ candidateGroup ; return $ this ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
2532	protected function loadOptionalSegmentInformation ( $ options ) { if ( ! empty ( $ options -> operatingCompany ) ) { $ this -> segmentInformation -> companyDetails -> operatingCompany = $ options -> operatingCompany ; } if ( $ options -> arrivalDate instanceof \ DateTime ) { $ this -> segmentInformation -> flightDate -> setArrivalDate ( $ options -> arrivalDate ) ; } if ( ! empty ( $ options -> groupNumber ) ) { $ this -> segmentInformation -> flightTypeDetails = new FlightTypeDetails ( $ options -> groupNumber ) ; } $ this -> loadAdditionalSegmentDetails ( $ options -> airplaneCode , $ options -> nrOfStops ) ; }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
12887	private function getComposer ( $ fileOrPackage ) { if ( isset ( $ this -> jsonCache [ $ fileOrPackage ] ) ) return $ this -> jsonCache [ $ fileOrPackage ] ; if ( $ file = $ this -> files [ $ fileOrPackage ] ?? NULL ) { return $ this -> getComposer ( $ file ) ; } if ( is_dir ( $ fileOrPackage ) ) $ fileOrPackage .= "/composer.json" ; if ( is_file ( $ fileOrPackage ) ) { $ json = json_decode ( file_get_contents ( $ fileOrPackage ) , true ) ; $ name = $ json [ "name" ] ; $ this -> jsonCache [ $ name ] = $ json ; $ this -> files [ $ name ] = $ fileOrPackage ; return $ json ; } return NULL ; }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
7610	public function signup ( ) { if ( $ this -> validate ( ) ) { $ user = new User ( ) ; $ user -> username = $ this -> username ; $ user -> email = $ this -> email ; $ user -> setPassword ( $ this -> password ) ; $ user -> generateAuthKey ( ) ; if ( $ user -> save ( ) ) { return $ user ; } } return null ; }
672	public function upgrade ( ) { $ owner = $ this -> owner ; if ( $ owner -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Upgrading the model version is not possible on a new record.' ) ; } $ lock = $ this -> getLockAttribute ( ) ; $ version = $ owner -> $ lock ? : 0 ; $ owner -> updateAttributes ( [ $ lock => $ version + 1 ] ) ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
6327	private function getConstraintsSql ( ) { $ sql = '' ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { $ sql .= ',' ; if ( $ constraint instanceof PrimaryKey ) { $ sql .= ( string ) $ constraint ; } elseif ( $ constraint instanceof ForeignKey ) { $ sql .= sprintf ( 'CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s (%s) MATCH SIMPLE ON UPDATE %s ON DELETE %s' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) , $ constraint -> getReferencedTable ( ) -> getQualifiedName ( ) , implode ( ',' , $ constraint -> getReferencedColumns ( ) ) , $ constraint -> getUpdateAction ( ) , $ constraint -> getDeleteAction ( ) ) ; } elseif ( $ constraint instanceof Unique ) { $ sql .= sprintf ( 'CONSTRAINT %s UNIQUE (%s)' , $ constraint -> getName ( ) , implode ( ',' , $ constraint -> getColumns ( ) ) ) ; } } return rtrim ( $ sql , ',' ) ; }
12521	public function renderLabel ( $ customFieldOrClass , $ slug = null , array $ params = array ( ) ) { $ resolvedParams = array_merge ( $ this -> defaultParams , $ params ) ; $ customField = ( $ customFieldOrClass instanceof CustomField ) ? $ customFieldOrClass : $ this -> container -> get ( 'chill.custom_field.provider' ) -> getCustomField ( $ customFieldOrClass , $ slug ) ; return $ this -> container -> get ( 'templating' ) -> render ( $ resolvedParams [ 'label_layout' ] , array ( 'customField' => $ customField ) ) ; }
5727	public function recordIsDeletedFromStage ( ) { if ( $ this -> owner -> hasMethod ( 'getIsDeletedFromStage' ) ) { return $ this -> owner -> IsDeletedFromStage ; } if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return true ; } $ class = $ this -> owner -> record -> class ; $ stageVersion = Versioned :: get_versionnumber_by_stage ( $ class , 'Stage' , $ this -> owner -> record -> ID ) ; return ! ( $ stageVersion ) ; }
8124	protected function findRecord ( $ data ) { if ( empty ( $ data [ "ID" ] ) ) { throw new HTTPResponse_Exception ( "No record ID" , 404 ) ; } $ page = null ; $ id = $ data [ "ID" ] ; if ( is_numeric ( $ id ) ) { $ page = SiteTree :: get ( ) -> byID ( $ id ) ; } if ( ! $ page || ! $ page -> ID ) { throw new HTTPResponse_Exception ( "Bad record ID #{$id}" , 404 ) ; } return $ page ; }
5598	public function add ( $ severity , $ content , $ filename , $ line ) { $ content = str_replace ( '%' , '%%' , $ content ) ; $ this -> testLatestError ( $ severity , $ content , $ filename , $ line ) ; }
9549	public function setPdo ( PDO $ pdo ) { $ this -> pdo = $ pdo ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; return $ this ; }
7669	function ServerVar ( $ varName ) { global $ HTTP_SERVER_VARS ; global $ HTTP_ENV_VARS ; if ( ! isset ( $ _SERVER ) ) { $ _SERVER = $ HTTP_SERVER_VARS ; if ( ! isset ( $ _SERVER [ "REMOTE_ADDR" ] ) ) $ _SERVER = $ HTTP_ENV_VARS ; } if ( isset ( $ _SERVER [ $ varName ] ) ) return $ _SERVER [ $ varName ] ; else return "" ; }
7797	protected function statementNumber ( $ text ) { if ( $ line = $ this -> getLine ( '60F' , $ text ) ) { if ( preg_match ( '/(C|D)(\d{6})([A-Z]{3})([0-9,]{1,15})/' , $ line , $ match ) ) { return $ match [ 2 ] ; } } return null ; }
742	public function afterRun ( $ event ) { echo $ event -> result ; $ event -> result = null ; $ this -> owner -> view -> endCache ( ) ; }
12826	protected function saveSlotDefinition ( $ dir , array $ slot ) { $ slotsFilename = $ this -> getSlotDefinitionFile ( $ dir ) ; FilesystemTools :: writeFile ( $ slotsFilename , json_encode ( $ slot ) , $ this -> filesystem ) ; }
7714	function switchToRelative ( ) { $ this -> FindEndTag ( ) ; $ this -> rel_Txt = & $ this -> Txt ; $ this -> rel_PosBeg = $ this -> PosBeg ; $ this -> rel_Len = $ this -> GetLen ( ) ; $ src = $ this -> GetSrc ( ) ; $ this -> Txt = & $ src ; $ this -> _ApplyDiffToAll ( - $ this -> PosBeg ) ; }
9747	public function setTimeZone ( $ timezone ) { if ( ! $ timezone ) { return $ this ; } try { Carbon :: now ( $ timezone ) ; } catch ( \ Exception $ e ) { $ this -> invalidArguments ( '10004' , sprintf ( 'Invalid timezone set "%s"' , $ timezone ) ) ; } return $ this -> setParameter ( 'timezone' , $ timezone ) ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
7202	public function getGross ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> gross ) : $ this -> gross ; }
12018	protected function setup ( \ AMQPQueue $ queue ) { $ queue -> declareQueue ( ) ; foreach ( $ this -> binds as $ exchange => $ params ) { $ queue -> bind ( $ exchange , $ params [ 'routing_key' ] , $ params [ 'arguments' ] ) ; } }
12796	public function clear ( $ queue ) { $ this -> client -> request -> post ( $ this -> apiEndpoint . '/projects/' . $ this -> params [ 'project' ] . '/queues/' . $ queue . '/clear' ) ; }
8506	public function getBillOfLading ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetBillOfLadingRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetBillOfLadingRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetBillOfLading' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetBillOfLadingResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7174	public static function path ( $ array , $ path , $ default = null , $ delimiter = null ) { if ( ! static :: is_array ( $ array ) ) { return $ default ; } if ( is_array ( $ path ) ) { $ keys = $ path ; } else { if ( array_key_exists ( $ path , $ array ) ) { return $ array [ $ path ] ; } if ( ! $ delimiter ) { $ delimiter = static :: $ delimiter ; } $ path = trim ( $ path , "{$delimiter} " ) ; $ keys = explode ( $ delimiter , $ path ) ; } do { $ key = array_shift ( $ keys ) ; if ( ctype_digit ( $ key ) ) { $ key = ( int ) $ key ; } if ( isset ( $ array [ $ key ] ) ) { if ( ! $ keys ) { return $ array [ $ key ] ; } if ( ! static :: is_array ( $ array [ $ key ] ) ) { break ; } $ array = $ array [ $ key ] ; } else { break ; } } while ( $ keys ) ; return $ default ; }
4844	public static function singularize ( $ string ) { if ( substr ( $ string , - 1 ) == 's' ) { return substr ( $ string , 0 , - 1 ) ; } elseif ( substr ( $ string , - 1 ) == 'i' ) { return substr ( $ string , 0 , - 1 ) . 'us' ; } else { return $ string ; } }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
2029	public static function findPublishedFallbackByHostname ( $ strHost , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ strHost , 'contao.dns-fallback' ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.dns=? AND $t.fallback='1'" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; }
12741	public function getTag ( $ name ) { if ( ! isset ( $ this -> tags [ $ name ] ) ) { throw new AttributeNotFoundException ( $ name ) ; } return $ this -> tags [ $ name ] ; }
3041	public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
12600	public static function copy ( $ src , $ dest , $ force = true ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; if ( ! Folder :: exists ( dirname ( $ dest ) ) ) { Folder :: create ( dirname ( $ dest ) ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> copy ( $ src , $ dest , $ force ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
8680	public function sortKeys ( $ order = SORT_ASC , $ flags = SORT_REGULAR ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( $ order === SORT_ASC ) { ksort ( $ items , $ flags ) ; } else { krsort ( $ items , $ flags ) ; } return $ this -> createFrom ( $ items ) ; }
1689	public function updateStyleSheets ( ) { $ objStyleSheets = $ this -> Database -> execute ( "SELECT * FROM tl_style_sheet" ) ; $ arrStyleSheets = $ objStyleSheets -> fetchEach ( 'name' ) ; if ( file_exists ( $ this -> strRootDir . '/system/config/dcaconfig.php' ) ) { @ trigger_error ( 'Using the dcaconfig.php file has been deprecated and will no longer work in Contao 5.0. Create one or more DCA files in app/Resources/contao/dca instead.' , E_USER_DEPRECATED ) ; include $ this -> strRootDir . '/system/config/dcaconfig.php' ; } foreach ( scan ( $ this -> strRootDir . '/assets/css' , true ) as $ file ) { if ( is_dir ( $ this -> strRootDir . '/assets/css/' . $ file ) ) { continue ; } if ( \ is_array ( Config :: get ( 'rootFiles' ) ) && \ in_array ( $ file , Config :: get ( 'rootFiles' ) ) ) { continue ; } if ( preg_match ( '/^[a-f0-9]{12}\.css$/' , $ file ) ) { continue ; } $ objFile = new File ( 'assets/css/' . $ file ) ; if ( $ objFile -> extension == 'css' && ! \ in_array ( $ objFile -> filename , $ arrStyleSheets ) ) { $ objFile -> delete ( ) ; } } $ objStyleSheets -> reset ( ) ; while ( $ objStyleSheets -> next ( ) ) { $ this -> writeStyleSheet ( $ objStyleSheets -> row ( ) ) ; $ this -> log ( 'Generated style sheet "' . $ objStyleSheets -> name . '.css"' , __METHOD__ , TL_CRON ) ; } }
7949	public function updateDomainProperties ( $ domain , $ properties ) { self :: getClient ( ) -> updateDomainProperties ( $ this -> sn , $ domain , $ properties ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
10754	public function getDateBorn ( UserEntity $ user , $ sm ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMMM YYYY" ) ; $ date = $ user -> getDateBorn ( ) ; return $ dateFormatter -> format ( $ date ) ; }
4185	public function search ( ) { $ this -> console -> info ( 'Searching directory for service providers.' ) ; $ sps = $ this -> getProviders ( ) ; if ( ! $ sps -> count ( ) ) { $ this -> console -> warn ( 'No service provider file found. Nothing to install.' ) ; return [ ] ; } $ this -> console -> line ( " Found {$sps->count()} Service provider" . ( $ sps -> count ( ) > 1 ? 's' : '' ) . '.' ) ; $ sps -> each ( function ( $ sp , $ index ) { $ currentCount = $ index + 1 ; $ this -> console -> line ( " $currentCount. $sp" ) ; } ) ; if ( ! $ this -> console -> confirm ( 'Register service providers?' , true ) ) { return [ ] ; } $ this -> registered = true ; return $ this -> getProviders ( ) -> toArray ( ) ; }
10502	public function setParameters ( $ subject , ParameterBagInterface $ parameters ) { if ( ! is_object ( $ subject ) ) { throw new InvalidSubjectException ( $ subject ) ; } if ( $ subject instanceof ParameterBagAwareInterface ) { $ subject -> setParameters ( $ parameters ) ; } else { foreach ( $ parameters as $ key => $ value ) { $ this -> setParameter ( $ subject , $ key , $ value ) ; } } }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
1772	public function getAttribute ( $ strKey ) { if ( ! isset ( $ this -> arrAttributes [ $ strKey ] ) ) { return '' ; } $ varValue = $ this -> arrAttributes [ $ strKey ] ; if ( $ strKey == 'autofocus' ) { unset ( $ this -> arrAttributes [ $ strKey ] ) ; } if ( $ strKey == 'disabled' || $ strKey == 'readonly' || $ strKey == 'required' || $ strKey == 'autofocus' || $ strKey == 'multiple' ) { return ' ' . $ strKey ; } elseif ( $ varValue != '' ) { return ' ' . $ strKey . '="' . StringUtil :: specialchars ( $ varValue ) . '"' ; } return '' ; }
11512	public function actionRequest ( ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'request' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> sendRecoveryMessage ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Recovery message sent' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'request' , [ 'model' => $ model , ] ) ; }
11470	public function store ( ResponseRequest $ request ) { try { $ request = $ request -> all ( ) ; $ slug = $ request [ 'slug' ] ; $ attributes [ 'comment' ] = $ request [ 'comment' ] ; $ attributes [ 'question_id' ] = $ request [ 'question_id' ] ; $ attributes [ 'user_id' ] = user_id ( ) ; $ attributes [ 'user_type' ] = user_type ( ) ; $ response = $ this -> repository -> create ( $ attributes ) ; return $ this -> response -> message ( trans ( 'messages.success.created' , [ 'Module' => trans ( 'forum::response.name' ) ] ) ) -> code ( 204 ) -> status ( 'success' ) -> url ( trans_url ( '/discussion/' . $ slug ) ) -> redirect ( ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( trans_url ( '/question/' . $ slug ) ) -> redirect ( ) ; } }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
9509	public function search ( Log $ log , $ level = 'all' , Request $ request ) { if ( is_null ( $ query = $ request -> get ( 'query' ) ) ) return redirect ( ) -> route ( 'admin::foundation.system.log-viewer.logs.show' , [ $ log -> date ] ) ; $ levels = $ this -> logViewer -> levelsNames ( ) ; $ entries = $ log -> entries ( $ level ) -> filter ( function ( LogEntry $ value ) use ( $ query ) { return Str :: contains ( $ value -> header , $ query ) ; } ) -> paginate ( $ this -> perPage ) ; return $ this -> view ( 'admin.system.log-viewer.show' , compact ( 'log' , 'levels' , 'level' , 'query' , 'entries' ) ) ; }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
2537	protected function getSoapClient ( $ msgName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ msgName ) ; if ( ! empty ( $ msgName ) ) { if ( ! isset ( $ this -> soapClients [ $ wsdlId ] ) || ! ( $ this -> soapClients [ $ wsdlId ] instanceof \ SoapClient ) ) { $ this -> soapClients [ $ wsdlId ] = $ this -> initSoapClient ( $ wsdlId ) ; } return $ this -> soapClients [ $ wsdlId ] ; } else { return null ; } }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
5300	public function getGlyphNames ( ) { $ glyphNames = array ( ) ; foreach ( $ this -> font -> getGlyphs ( ) as $ glyph ) { $ glyphNames [ static :: unicodeToHex ( $ glyph [ 'char' ] ) ] = empty ( $ glyph [ 'name' ] ) ? null : $ glyph [ 'name' ] ; } return $ glyphNames ; }
7318	public function toMJD ( $ scale = null ) { $ mjd = static :: MJD ; if ( $ scale ) { return bcsub ( bcadd ( $ this -> jd , $ this -> dayFrac , $ scale ) , $ mjd , $ scale ) ; } else { return $ this -> jd + $ this -> dayFrac - $ mjd ; } }
11807	public function lists ( $ column , $ key = null ) { return $ this -> buildQuery ( [ $ column ] ) -> lists ( $ column , $ key ) ; }
1159	public function getMessage ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> fakeValidationData ( $ attribute , $ rule , $ parameters ) ; $ message = $ this -> validator -> getMessage ( $ attribute , $ rule ) ; $ message = $ this -> validator -> makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) ; $ this -> validator -> setData ( $ data ) ; return $ message ; }
1286	private function createIdChunks ( array $ resourceIds ) : array { $ chunks = [ ] ; $ chunkId = - 1 ; $ resourceIds = \ array_values ( $ resourceIds ) ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( 0 === $ index % 30 ) { ++ $ chunkId ; $ chunks [ $ chunkId ] = [ ] ; } $ chunks [ $ chunkId ] [ ] = $ resourceId ; } return $ chunks ; }
6475	public function readAsFormInput ( ? IHttpBody $ body ) : IDictionary { if ( $ body === null ) { return new HashTable ( ) ; } $ parsedFormInputCacheKey = spl_object_hash ( $ body ) ; if ( isset ( $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ) ) { return $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] ; } $ formInputArray = [ ] ; parse_str ( $ body -> readAsString ( ) , $ formInputArray ) ; $ kvps = [ ] ; foreach ( $ formInputArray as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ formInputs = new HashTable ( $ kvps ) ; $ this -> parsedFormInputCache [ $ parsedFormInputCacheKey ] = $ formInputs ; return $ formInputs ; }
3508	private static function doCharDiff ( $ from_text , $ to_text ) { $ result = array ( ) ; $ jobs = array ( array ( 0 , strlen ( $ from_text ) , 0 , strlen ( $ to_text ) ) ) ; while ( $ job = array_pop ( $ jobs ) ) { list ( $ from_segment_start , $ from_segment_end , $ to_segment_start , $ to_segment_end ) = $ job ; $ from_segment_len = $ from_segment_end - $ from_segment_start ; $ to_segment_len = $ to_segment_end - $ to_segment_start ; if ( ! $ from_segment_len || ! $ to_segment_len ) { if ( $ from_segment_len ) { $ result [ $ from_segment_start * 4 + 0 ] = new FineDiffDeleteOp ( $ from_segment_len ) ; } else if ( $ to_segment_len ) { $ result [ $ from_segment_start * 4 + 1 ] = new FineDiffInsertOp ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } continue ; } if ( $ from_segment_len >= $ to_segment_len ) { $ copy_len = $ to_segment_len ; while ( $ copy_len ) { $ to_copy_start = $ to_segment_start ; $ to_copy_start_max = $ to_segment_end - $ copy_len ; while ( $ to_copy_start <= $ to_copy_start_max ) { $ from_copy_start = strpos ( substr ( $ from_text , $ from_segment_start , $ from_segment_len ) , substr ( $ to_text , $ to_copy_start , $ copy_len ) ) ; if ( $ from_copy_start !== false ) { $ from_copy_start += $ from_segment_start ; break 2 ; } $ to_copy_start ++ ; } $ copy_len -- ; } } else { $ copy_len = $ from_segment_len ; while ( $ copy_len ) { $ from_copy_start = $ from_segment_start ; $ from_copy_start_max = $ from_segment_end - $ copy_len ; while ( $ from_copy_start <= $ from_copy_start_max ) { $ to_copy_start = strpos ( substr ( $ to_text , $ to_segment_start , $ to_segment_len ) , substr ( $ from_text , $ from_copy_start , $ copy_len ) ) ; if ( $ to_copy_start !== false ) { $ to_copy_start += $ to_segment_start ; break 2 ; } $ from_copy_start ++ ; } $ copy_len -- ; } } if ( $ copy_len ) { $ jobs [ ] = array ( $ from_segment_start , $ from_copy_start , $ to_segment_start , $ to_copy_start ) ; $ result [ $ from_copy_start * 4 + 2 ] = new FineDiffCopyOp ( $ copy_len ) ; $ jobs [ ] = array ( $ from_copy_start + $ copy_len , $ from_segment_end , $ to_copy_start + $ copy_len , $ to_segment_end ) ; } else { $ result [ $ from_segment_start * 4 ] = new FineDiffReplaceOp ( $ from_segment_len , substr ( $ to_text , $ to_segment_start , $ to_segment_len ) ) ; } } ksort ( $ result , SORT_NUMERIC ) ; return array_values ( $ result ) ; }
782	public function add ( $ cookie ) { if ( $ this -> readOnly ) { throw new InvalidCallException ( 'The cookie collection is read only.' ) ; } $ this -> _cookies [ $ cookie -> name ] = $ cookie ; }
4688	public function andWhere ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ this -> where ? '(' . $ this -> where . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'where' , $ args ) ; return $ this ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
3594	public static function getCurrentMacAddress ( $ interface ) { $ ifconfig = self :: runCommand ( "ifconfig {$interface}" ) ; preg_match ( "/" . self :: $ valid_mac . "/i" , $ ifconfig , $ ifconfig ) ; if ( isset ( $ ifconfig [ 0 ] ) ) { return trim ( strtoupper ( $ ifconfig [ 0 ] ) ) ; } return false ; }
8302	public function assertArray ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_array ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " section must be an array." ) ; } return $ this ; }
1436	public static function camelize ( $ value ) { if ( isset ( self :: $ camelized [ $ value ] ) ) { return self :: $ camelized [ $ value ] ; } return self :: $ camelized [ $ value ] = lcfirst ( self :: classify ( $ value ) ) ; }
11458	public function batchPageSummary ( $ timestamp , $ pageIndex ) { $ params = [ 'date' => $ timestamp , 'page_index' => $ pageIndex , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE_LIST , $ params ] ) ; }
5193	public function dispatch ( ServerRequestInterface $ request ) : ServerRequestInterface { $ dispatcher = simpleDispatcher ( [ $ this , 'addRoutes' ] ) ; $ routeInfo = $ dispatcher -> dispatch ( $ request -> getMethod ( ) , $ request -> getUri ( ) -> getPath ( ) ) ; if ( $ routeInfo [ 0 ] === Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedException ( $ request -> getMethod ( ) , $ routeInfo [ 1 ] ) ; } if ( $ routeInfo [ 0 ] === Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( sprintf ( "Route '%s' not found." , $ request -> getUri ( ) -> getPath ( ) ) ) ; } foreach ( $ routeInfo [ 2 ] as $ key => $ value ) { $ request = $ request -> withAttribute ( $ key , $ value ) ; } return $ request -> withAttribute ( 'route' , $ this -> routes [ $ routeInfo [ 1 ] ] ) ; }
5007	private function init ( $ name ) { if ( null === $ name ) { $ name = $ this -> default ; } if ( ! isset ( static :: $ orderMap [ $ name ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Unknown status name "%s" for "%s"' , $ name , static :: class ) ) ; } $ this -> name = $ name ; $ this -> order = static :: $ orderMap [ $ name ] ; }
7550	function wrapInner ( $ node , $ start = 0 , $ end = - 1 , $ wrap_index = - 1 , $ node_index = null ) { if ( $ end < 0 ) { $ end += count ( $ this -> children ) ; } if ( $ node_index === null ) { $ node_index = $ end + 1 ; } if ( ! is_object ( $ node ) ) { $ node = $ this -> addChild ( $ node , $ node_index ) ; } elseif ( $ node -> parent !== $ this ) { $ node -> changeParent ( $ this -> parent , $ node_index ) ; } $ this -> moveChildren ( $ node , $ wrap_index , $ start , $ end ) ; return $ node ; }
1085	private function parseName ( ) { $ token = $ this -> expect ( Token :: NAME ) ; return new NameNode ( [ 'value' => $ token -> value , 'loc' => $ this -> loc ( $ token ) , ] ) ; }
9584	public function getRouteForRequest ( Request $ request ) { $ method = $ request -> getMethod ( ) ; $ path = $ request -> getPathInfo ( ) ? : '/' ; $ result = $ this -> getDispatcher ( ) -> dispatch ( $ method , $ path ) ; if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( "No route match for path $path" ) ; } else if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedHttpException ( $ result [ 1 ] , "Method $method not allowed for path $path" ) ; } else if ( $ result [ 0 ] !== \ FastRoute \ Dispatcher :: FOUND ) { throw new \ RuntimeException ( 'Unknown result from FastRoute: ' . $ result [ 0 ] ) ; } return $ this -> matchRoute ( $ result [ 1 ] , $ result [ 2 ] , $ request ) ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
1196	protected function renderHtmlAttribute ( $ name , $ value ) { if ( true === $ value ) { return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ name ) ) ; } return sprintf ( '%s="%s"' , $ name , $ this -> escape ( $ value ) ) ; }
11285	public function isPlaceholder ( $ attributeName ) { $ def = $ this -> model_attributes [ $ attributeName ] ; if ( isset ( $ def [ 'models' ] ) || ( isset ( $ def [ 'model' ] ) && isset ( $ def [ 'usesRefTable' ] ) ) ) { return true ; } return false ; }
6984	protected function extractInputFromRules ( $ data , array $ rules ) { $ keys = collect ( $ rules ) -> keys ( ) -> map ( function ( $ rule ) { return explode ( '.' , $ rule ) [ 0 ] ; } ) -> unique ( ) -> toArray ( ) ; if ( ! ( $ data instanceof Request ) ) { $ data = collect ( $ data ) ; } return $ data -> only ( $ keys ) ; }
3307	protected function buildRequestParam ( $ images , $ options = [ ] ) { if ( is_array ( $ images ) && ! empty ( $ images [ 0 ] ) ) { $ images = $ images [ 0 ] ; } if ( $ this -> supportUrl && FileConverter :: isUrl ( $ images ) ) { $ options [ 'url' ] = $ images ; } else { $ options [ 'image' ] = FileConverter :: toBase64Encode ( $ images ) ; } return $ options ; }
1659	public static function create ( $ reply = null ) { $ suggestion = new self ( ) ; if ( $ reply ) { $ suggestion -> reply ( $ reply ) ; } return $ suggestion ; }
6498	public function useScreenResolution ( $ width_height ) { list ( $ width , $ height ) = explode ( 'x' , $ width_height ) ; $ this -> getSessionDriver ( ) -> resizeWindow ( ( int ) $ width , ( int ) $ height ) ; }
3188	public function getFirstTimestamp ( $ tags ) { $ range = $ this -> getRange ( $ tags ) ; $ last = false ; if ( count ( $ range ) ) { $ last = $ range [ 0 ] -> getTimestamp ( ) ; } return $ last ; }
11548	public function getGroup ( $ name ) { if ( array_key_exists ( $ name , $ this -> groups ) ) { return $ this -> groups [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> groups ) , 'groups' ) ; }
7529	function dumpLocation ( ) { return ( ( $ this -> parent ) ? ( ( $ p = $ this -> parent -> dumpLocation ( ) ) ? $ p . ' > ' : '' ) . $ this -> tag . '(' . $ this -> typeIndex ( ) . ')' : '' ) ; }
8200	public function look ( $ number = 1 ) { if ( ! isset ( $ this -> tokens [ $ this -> current + $ number ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current + $ number - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current + $ number ] ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
5918	protected function setSecretKey ( $ passphrase ) { $ length = strlen ( $ passphrase ) ; if ( strlen ( $ passphrase ) < 1 || strlen ( $ passphrase ) > 56 ) { throw new Ts3Exception ( "secret passphrase must contain at least one but less than 56 characters" ) ; } $ k = 0 ; $ data = 0 ; $ datal = 0 ; $ datar = 0 ; for ( $ i = 0 ; $ i < 18 ; $ i ++ ) { $ data = 0 ; for ( $ j = 4 ; $ j > 0 ; $ j -- ) { $ data = $ data << 8 | ord ( $ passphrase { $ k } ) ; $ k = ( $ k + 1 ) % $ length ; } $ this -> p [ $ i ] ^= $ data ; } for ( $ i = 0 ; $ i <= 16 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> p [ $ i ] = $ datal ; $ this -> p [ $ i + 1 ] = $ datar ; } foreach ( $ this -> s as $ key => $ val ) { for ( $ i = 0 ; $ i < 256 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> s [ $ key ] [ $ i ] = $ datal ; $ this -> s [ $ key ] [ $ i + 1 ] = $ datar ; } } }
3360	public function op ( $ operation ) { if ( ! $ operation ) { return $ this ; } $ result = clone $ this ; $ result -> operations [ ] [ 'custom' ] = $ operation ; return $ result ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
11508	public function validate ( $ token ) { $ params = [ $ token , $ this -> request -> get ( 'timestamp' ) , $ this -> request -> get ( 'nonce' ) , ] ; if ( ! $ this -> debug && $ this -> request -> get ( 'signature' ) !== $ this -> signature ( $ params ) ) { throw new FaultException ( 'Invalid request signature.' , 400 ) ; } }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
9576	protected function resolveKernel ( ) { if ( $ this -> kernel !== null ) { return $ this -> kernel ; } $ class = 'Symfony\Component\EventDispatcher\EventDispatcherInterface' ; $ eventDispatcher = $ this -> container -> isBound ( $ class ) ? $ this -> container -> resolve ( $ class ) : null ; $ kernel = new Kernel ( $ this -> getRouter ( ) , $ this -> requests , $ this -> errorHandler , $ eventDispatcher ) ; return $ this -> kernel = $ this -> resolveStack ( ) -> resolve ( $ kernel ) ; }
3330	public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; }
4944	public function grant ( $ resource , $ permission = null , $ build = true ) { if ( is_array ( $ resource ) ) { foreach ( $ resource as $ r ) { $ this -> grant ( $ r , $ permission , false ) ; } if ( $ build ) { $ this -> build ( ) ; } return $ this ; } true === $ permission || ( null === $ permission && $ resource instanceof PermissionsResourceInterface ) || $ this -> checkPermission ( $ permission ) ; $ resourceId = $ this -> getResourceId ( $ resource ) ; if ( true === $ permission ) { $ permission = $ this -> getFrom ( $ resource ) ; } if ( self :: PERMISSION_NONE == $ permission ) { if ( $ resource instanceof PermissionsResourceInterface ) { $ refs = $ this -> getResources ( ) ; if ( $ refs -> contains ( $ resource ) ) { $ refs -> removeElement ( $ resource ) ; } } unset ( $ this -> assigned [ $ resourceId ] ) ; } else { if ( $ resource instanceof PermissionsResourceInterface ) { $ spec = $ resource -> getPermissionsUserIds ( $ this -> type ) ; if ( ! is_array ( $ spec ) || ! count ( $ spec ) ) { $ spec = array ( ) ; } elseif ( is_numeric ( key ( $ spec ) ) ) { $ spec = array ( $ permission => $ spec ) ; } } else { $ spec = array ( $ permission => $ resource instanceof UserInterface ? array ( $ resource -> getId ( ) ) : array ( $ resource ) ) ; } $ this -> assigned [ $ resourceId ] = $ spec ; if ( $ resource instanceof PermissionsResourceInterface ) { try { $ refs = $ this -> getResources ( ) ; if ( ! $ refs -> contains ( $ resource ) ) { $ refs -> add ( $ resource ) ; } } catch ( \ Exception $ e ) { } ; } } if ( $ build ) { $ this -> build ( ) ; } $ this -> hasChanged = true ; return $ this ; }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
8754	public function start ( $ block = true , $ interval = 100 ) { $ loop = $ this -> loop ; $ this -> pool = new ParallelPool ( function ( ) use ( $ loop ) { $ loop -> run ( ) ; } , $ this -> count ) ; $ this -> pool -> start ( ) ; $ this -> pool -> keep ( $ block , $ interval ) ; }
2507	protected static function loopOperationsWithQuery ( $ operations , $ query , $ wsdlIdentifier , $ domXpath ) { $ msgAndVer = [ ] ; foreach ( $ operations as $ operation ) { if ( ! empty ( $ operation -> value ) ) { $ fullVersion = $ domXpath -> evaluate ( sprintf ( $ query , $ operation -> value ) ) ; if ( ! empty ( $ fullVersion ) ) { $ extractedVersion = self :: extractMessageVersion ( $ fullVersion ) ; $ msgAndVer [ $ operation -> value ] = [ 'version' => $ extractedVersion , 'wsdl' => $ wsdlIdentifier ] ; } } } return $ msgAndVer ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
12670	public function stream_open ( $ path ) { $ scheme = parse_url ( $ path , PHP_URL_SCHEME ) ; if ( substr ( $ scheme , - 10 ) === '-emulation' ) { $ scheme = substr ( $ scheme , 0 , - 10 ) ; } $ emulator = static :: getEmulatorInstance ( $ scheme , $ path , $ this -> getContext ( ) ) ; if ( ! $ emulator ) { return false ; } $ this -> setEmulator ( $ emulator ) ; $ this -> getEmulator ( ) -> setResponseStream ( $ this -> callEmulation ( $ this -> getEmulator ( ) -> getIncomingStream ( ) ) ) ; $ this -> setResponse ( $ this -> getEmulator ( ) -> getOutgoingStream ( ) ) ; return true ; }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
7740	public function validate ( $ entity ) { if ( ! $ this -> container -> has ( 'validator' ) ) { throw new \ LogicException ( 'The validator service is not available.' ) ; } $ errors = $ this -> container -> get ( 'validator' ) -> validate ( $ entity ) ; if ( count ( $ errors ) === 0 ) { return false ; } return new JsonLdResponse ( '{ "error": "Validation error" }' , 400 ) ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2704	public function getContentTypeOptions ( ) { $ contentTypes = [ self :: CONTENT_TYPE_HTML => __ ( 'HTML' ) , self :: CONTENT_TYPE_CSS => __ ( 'CSS' ) , self :: CONTENT_TYPE_JS => __ ( 'JavaScript' ) , self :: CONTENT_TYPE_IMAGE => __ ( 'Images' ) ] ; return $ contentTypes ; }
2374	public static function srcToInsertTag ( $ data ) { $ return = '' ; $ paths = preg_split ( '/((src|href)="([^"]+)")/i' , $ data , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; for ( $ i = 0 , $ c = \ count ( $ paths ) ; $ i < $ c ; $ i += 4 ) { $ return .= $ paths [ $ i ] ; if ( ! isset ( $ paths [ $ i + 1 ] ) ) { continue ; } $ file = FilesModel :: findByPath ( $ paths [ $ i + 3 ] ) ; if ( $ file !== null ) { $ return .= $ paths [ $ i + 2 ] . '="{{file::' . static :: binToUuid ( $ file -> uuid ) . '}}"' ; } else { $ return .= $ paths [ $ i + 2 ] . '="' . $ paths [ $ i + 3 ] . '"' ; } } return $ return ; }
8946	public function changePreference ( $ key , $ preference ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences/' . $ key ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ preference ) ; return $ response -> body ; }
1142	public function availableOptionValues ( ) { $ options = [ ] ; foreach ( $ this -> selector -> getOptions ( ) as $ option ) { $ options [ ] = $ option -> getAttribute ( 'value' ) ; } return $ options ; }
11694	protected function getCompiler ( SplFileInfo $ file ) : Compiler { $ source_type = $ this -> getSourceType ( $ file ) ; $ compiler_type = '\Gears\Asset\Compilers\\' ; $ compiler_type .= ucfirst ( $ source_type ) ; if ( ! class_exists ( $ compiler_type ) ) { throw new RuntimeException ( 'The source file type is not supported! - (' . $ file . ')' ) ; } return new $ compiler_type ( $ file , $ this -> destination , $ this -> debug , $ this -> autoprefix ) ; }
5329	final public function push ( string $ data ) { if ( $ this -> generator === null ) { throw new \ Error ( "The parser is no longer writable" ) ; } $ this -> buffer .= $ data ; $ end = false ; try { while ( $ this -> buffer !== "" ) { if ( \ is_int ( $ this -> delimiter ) ) { if ( \ strlen ( $ this -> buffer ) < $ this -> delimiter ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ this -> delimiter ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ this -> delimiter ) ; } elseif ( \ is_string ( $ this -> delimiter ) ) { if ( ( $ position = \ strpos ( $ this -> buffer , $ this -> delimiter ) ) === false ) { break ; } $ send = \ substr ( $ this -> buffer , 0 , $ position ) ; $ this -> buffer = \ substr ( $ this -> buffer , $ position + \ strlen ( $ this -> delimiter ) ) ; } else { $ send = $ this -> buffer ; $ this -> buffer = "" ; } $ this -> delimiter = $ this -> generator -> send ( $ send ) ; if ( ! $ this -> generator -> valid ( ) ) { $ end = true ; break ; } if ( $ this -> delimiter !== null && ( ! \ is_int ( $ this -> delimiter ) || $ this -> delimiter <= 0 ) && ( ! \ is_string ( $ this -> delimiter ) || ! \ strlen ( $ this -> delimiter ) ) ) { throw new InvalidDelimiterError ( $ this -> generator , \ sprintf ( "Invalid value yielded: Expected NULL, an int greater than 0, or a non-empty string; %s given" , \ is_object ( $ this -> delimiter ) ? \ sprintf ( "instance of %s" , \ get_class ( $ this -> delimiter ) ) : \ gettype ( $ this -> delimiter ) ) ) ; } } } catch ( \ Throwable $ exception ) { $ end = true ; throw $ exception ; } finally { if ( $ end ) { $ this -> generator = null ; } } }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
27	public function write ( ) { $ data = array ( ) ; $ dumper = new ArrayDumper ( ) ; foreach ( $ this -> getCanonicalPackages ( ) as $ package ) { $ data [ ] = $ dumper -> dump ( $ package ) ; } usort ( $ data , function ( $ a , $ b ) { return strcmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; $ this -> file -> write ( $ data ) ; }
10948	public function getCsrfToken ( $ regenerate = false ) { if ( $ this -> _csrfToken === null || $ regenerate ) { if ( $ regenerate || ( $ token = $ this -> loadCsrfToken ( ) ) === null ) { $ token = $ this -> generateCsrfToken ( ) ; } $ chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-.' ; $ mask = substr ( str_shuffle ( str_repeat ( $ chars , 5 ) ) , 0 , static :: CSRF_MASK_LENGTH ) ; $ this -> _csrfToken = str_replace ( '+' , '.' , base64_encode ( $ mask . $ this -> xorTokens ( $ token , $ mask ) ) ) ; } return $ this -> _csrfToken ; }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
996	public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; }
10457	public function to ( Uom $ uom ) { $ conversionFactor = Uom :: getConversionFactor ( $ this -> getUom ( ) , $ uom ) ; return new static ( $ this -> getAmount ( ) -> multiply ( $ conversionFactor ) , $ uom ) ; }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
3555	protected function castValue ( ) { $ value = $ this -> attributes [ 'meta_value' ] ; $ validTypes = [ 'boolean' , 'integer' , 'float' , 'double' , 'array' , 'object' , 'null' ] ; if ( in_array ( $ this -> attributes [ 'meta_type' ] , $ validTypes ) ) { settype ( $ value , $ this -> attributes [ 'meta_type' ] ) ; } return $ value ; }
653	protected function getCacheKey ( $ method , $ fetchMode , $ rawSql ) { return [ __CLASS__ , $ method , $ fetchMode , $ this -> db -> dsn , $ this -> db -> username , $ rawSql , ] ; }
7090	public function removeDefaultHeader ( $ headers = "" ) { foreach ( $ headers as $ header ) foreach ( $ this -> defaultHeaders as $ h => $ v ) if ( $ header === $ h ) unset ( $ this -> defaultHeaders [ $ h ] ) ; return $ this -> defaultHeaders ; }
6413	public static function transform ( IteratorAggregate $ fromIterable , callable $ transformer ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ fromIterable , $ transformer ) { return Iterators :: transform ( Iterators :: from ( $ fromIterable -> getIterator ( ) ) , $ transformer ) ; } ) ; }
12070	public function createProject ( $ composerJson ) { $ response = $ this -> getResponse ( 'post' , 'v2/projects' , array ( ) , array ( 'upload' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( new Project ( ) , $ response ) ; }
5315	protected function generateBlocks ( ) { $ blocks = [ ] ; foreach ( range ( 1 , $ this -> getBlocks ( ) ) as $ counter ) { $ blocks [ ] = $ this -> generateChars ( ) ; } return implode ( $ this -> blockSeparator , $ blocks ) ; }
3393	public function register ( Request $ request ) { $ this -> validator ( $ request -> all ( ) ) -> validate ( ) ; event ( new Registered ( $ user = $ this -> create ( $ request -> all ( ) ) ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return $ this -> registered ( $ request , $ user ) ? : redirect ( $ this -> redirectAfterRegistrationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_info' ) ) ; }
12774	public function __authorize ( $ hashEmail = null , $ hashPassword = null ) { $ asyncResult = $ this -> __async_authorize ( $ hashEmail , $ hashPassword ) ; if ( $ asyncResult ) { } }
6245	public function storages ( ) : \ Generator { foreach ( $ this -> storage -> list ( $ this -> recursive ) as $ storage ) { foreach ( $ this -> storageFilters as $ filter ) { if ( ! call_user_func ( $ filter , $ storage ) ) { continue 2 ; } } yield $ storage ; } }
4588	public function setMaxResults ( ? int $ maxResults ) { $ this -> maxResults = $ maxResults ; $ this -> _maxResults = null !== $ maxResults ; return $ this ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
10352	private function getSourceByJob ( $ job ) { $ login = head ( array_except ( $ job -> credentials , 'password' ) ) ; return $ login . app ( 'request' ) -> ip ( ) ; }
4989	public function enableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array_keys ( $ this -> forms ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> enableForm ( $ childForm ) ; } else { if ( isset ( $ this -> forms [ $ k ] ) && ! in_array ( $ k , $ this -> activeForms ) ) { $ this -> activeForms [ ] = $ k ; } } } return $ this ; }
6914	public function removeShipment ( ShipmentInterface $ shipment ) { if ( $ this -> shipments -> contains ( $ shipment ) ) { $ this -> shipments -> removeElement ( $ shipment ) ; } return $ this ; }
5225	private function resolve ( Injector $ injector , $ type ) { $ resolved = [ ] ; foreach ( $ this -> getBindings ( ) as $ key => $ bindingValue ) { $ value = $ bindingValue ( $ injector , $ this -> name , $ key ) ; if ( $ this -> isTypeMismatch ( $ type , $ value ) ) { $ valueType = ( ( is_object ( $ value ) ) ? ( get_class ( $ value ) ) : ( gettype ( $ value ) ) ) ; throw new BindingException ( 'Value of type ' . $ valueType . ' for ' . ( ( is_int ( $ key ) ) ? ( 'list' ) : ( 'map' ) ) . ' named ' . $ this -> name . ' at position ' . $ key . ' is not of type ' . $ type -> getName ( ) ) ; } $ resolved [ $ key ] = $ value ; } return $ resolved ; }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
9465	public function getSummary ( ) { $ string = "---\n" ; foreach ( $ this -> getWords ( ) as $ k => $ v ) { $ string .= '[' . $ k . ']: Docs:' . $ v [ 'docs' ] . ' | Hits:' . $ v [ 'hits' ] . "\n" ; } return $ string ; }
2480	protected function mapSearchFieldValue ( $ value , FieldType $ searchFieldType = null ) { if ( null === $ searchFieldType ) { return $ value ; } $ searchField = new SearchField ( 'field' , $ value , $ searchFieldType ) ; $ value = ( array ) $ this -> fieldValueMapper -> map ( $ searchField ) ; return current ( $ value ) ; }
8726	public function shouldFallback ( $ locale = null ) { if ( ! $ this -> getWithFallback ( ) || ! $ this -> getFallbackLocale ( ) ) { return false ; } $ locale = $ locale ? : $ this -> getLocale ( ) ; return $ locale != $ this -> getFallbackLocale ( ) ; }
1521	public function processes ( StoreInterface $ store , FetchProcesses $ request ) { $ result = $ store -> queryRecords ( $ request -> getProcessType ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> content ( $ result ) ; }
12523	public function update ( array $ arguments = null , array $ options = null ) : void { if ( $ arguments ) { $ keys = array_keys ( $ this -> arguments ) ; for ( $ index = 0 ; $ index < count ( $ keys ) ; $ index ++ ) { $ this -> arguments [ $ keys [ $ index ] ] = $ arguments [ $ index ] ; } } if ( $ options ) { foreach ( $ options as $ option => $ value ) { $ this -> options [ $ option ] = $ value ; } } }
4265	private function sortSubscribers ( $ eventName ) { \ krsort ( $ this -> subscribers [ $ eventName ] ) ; $ this -> sorted [ $ eventName ] = array ( ) ; foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ subscriber ) { if ( $ this -> isClosureFactory ( $ subscriber ) ) { $ subscriber [ 0 ] = $ subscriber [ 0 ] ( ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ $ k ] = $ subscriber ; } $ this -> sorted [ $ eventName ] [ ] = $ subscriber ; } } }
4555	protected function addJoinTranslation ( QueryBuilder $ queryBuilder , string $ resourceClass ) { $ rootAlias = $ queryBuilder -> getRootAliases ( ) [ 0 ] ; $ translationAlias = $ rootAlias . '_t' ; $ translationClass = call_user_func ( $ resourceClass . '::getTranslationEntityClass' ) ; $ parts = $ queryBuilder -> getDQLParts ( ) [ 'join' ] ; foreach ( $ parts as $ joins ) { foreach ( $ joins as $ join ) { if ( $ translationAlias === $ join -> getAlias ( ) ) { return $ translationAlias ; } } } $ queryBuilder -> leftJoin ( $ translationClass , $ translationAlias , Join :: WITH , $ rootAlias . '.id = ' . $ translationAlias . '.translatable' ) ; return $ translationAlias ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
6554	public function removeLineFromFile ( $ line , $ fh ) { $ lines = array ( ) ; $ found = false ; rewind ( $ fh ) ; while ( ( $ buffer = fgets ( $ fh , 4096 ) ) !== false ) { $ buffer = trim ( $ buffer ) ; if ( $ line === $ buffer ) { $ found = true ; continue ; } $ lines [ ] = $ buffer ; } if ( ! $ found ) { throw new LineNotFoundException ( sprintf ( 'Line %s can not be found' , $ line ) ) ; } ftruncate ( $ fh , 0 ) ; rewind ( $ fh ) ; foreach ( $ lines as $ ln ) { if ( fwrite ( $ fh , $ ln . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write %s to file' , $ ln ) ) ; } } }
9256	public function set ( $ id , $ service , $ scope = ContainerInterface :: SCOPE_CONTAINER ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ this -> container -> set ( $ id , $ service , $ scope ) ; }
12892	public function render ( ElementInterface $ element ) { $ renderer = $ this -> getView ( ) ; if ( ! method_exists ( $ renderer , 'plugin' ) ) { return '' ; } $ wrapperClass = '' ; $ elementMarkup = '' ; $ templateMarkup = '' ; $ attributesString = '' ; $ label = '' ; if ( $ element instanceof CollectionElement && $ element -> shouldCreateTemplate ( ) ) { $ templateMarkup = $ this -> renderTemplate ( $ element ) ; } foreach ( $ element -> getIterator ( ) as $ elementOrFieldset ) { $ elementMarkup .= $ this -> renderElement ( $ elementOrFieldset ) ; } $ helperFormButtonIcon = $ this -> getFormButtonIconHelper ( ) ; $ helperLabel = $ this -> getLabelHelper ( ) ; $ elementMarkup .= sprintf ( $ this -> elementWrap , '' , $ helperFormButtonIcon ( new Button ( null , [ 'label' => 'Add New' , 'icon' => 'fa fa-plus-circle' ] ) ) , '' ) ; if ( $ this -> shouldWrap ) { $ attributes = $ element -> getAttributes ( ) ; if ( isset ( $ attributes [ 'class' ] ) ) { $ wrapperClass = $ attributes [ 'class' ] ; unset ( $ attributes [ 'class' ] ) ; } unset ( $ attributes [ 'name' ] ) ; $ attributesString = count ( $ attributes ) ? ' ' . $ this -> createAttributesString ( $ attributes ) : '' ; if ( ! empty ( $ element -> getLabel ( ) ) ) { $ label = $ helperLabel ( $ element ) ; } } return sprintf ( $ this -> wrapper , $ wrapperClass , $ attributesString , $ label , $ this -> horizontalWrapClass , $ elementMarkup , $ templateMarkup ) ; }
8614	public function setFeedSubmissionInfoList ( $ feedSubmissionInfo ) { if ( ! $ this -> _isNumericArray ( $ feedSubmissionInfo ) ) { $ feedSubmissionInfo = array ( $ feedSubmissionInfo ) ; } $ this -> fields [ 'FeedSubmissionInfo' ] [ 'FieldValue' ] = $ feedSubmissionInfo ; return $ this ; }
1863	protected function validate ( ) { foreach ( \ func_get_args ( ) as $ strPath ) { if ( $ strPath == '' ) { throw new \ RuntimeException ( 'No file or folder name given' ) ; } elseif ( Validator :: isInsecurePath ( $ strPath ) ) { throw new \ RuntimeException ( 'Invalid file or folder name ' . $ strPath ) ; } } }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
6149	public function sendJson ( $ data , $ statusCode = null ) { return $ this -> setStatusCode ( $ statusCode ) -> setJsonBody ( $ data ) -> send ( ) ; }
4492	public function broadcast ( Message $ message , string $ topicArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $topicArn" , [ 'Message' => $ message , ] ) ; return ; } $ this -> messages -> send ( $ message , $ topicArn ) ; }
3504	private function createByReason ( string $ reason , array $ json ) : SendNotificationException { $ reason = strtolower ( $ reason ) ; switch ( $ reason ) { case 'badcollapseid' : return new BadCollapseIdException ( ) ; case 'baddevicetoken' : return new BadDeviceTokenException ( ) ; case 'badexpirationdate' : return new BadExpirationDateException ( ) ; case 'badmessageid' : return new BadMessageIdException ( ) ; case 'badpriority' : return new BadPriorityException ( ) ; case 'badtopic' : return new BadTopicException ( ) ; case 'devicetokennotfortopic' : return new DeviceTokenNotForTopicException ( ) ; case 'duplicateheaders' : return new DuplicateHeadersException ( ) ; case 'idletimeout' : return new IdleTimeoutException ( ) ; case 'missingdevicetoken' : return new MissingDeviceTokenException ( ) ; case 'missingtopic' : return new MissingTopicException ( ) ; case 'payloadempty' : return new PayloadEmptyException ( ) ; case 'topicdisallowed' : return new TopicDisallowedException ( ) ; case 'badcertificate' : return new BadCertificateException ( ) ; case 'badcertificateenvironment' : return new BadCertificateEnvironmentException ( ) ; case 'expiredprovidertoken' : return new ExpiredProviderTokenException ( ) ; case 'forbidden' : return new ForbiddenException ( ) ; case 'invalidprovidertoken' : return new InvalidProviderTokenException ( ) ; case 'missingprovidertoken' : return new MissingProviderTokenException ( ) ; case 'badpath' : return new BadPathException ( ) ; case 'methodnotallowed' : return new MethodNotAllowedException ( ) ; case 'unregistered' : $ timestamp = array_key_exists ( 'timestamp' , $ json ) ? $ json [ 'timestamp' ] : 0 ; $ lastConfirmed = new \ DateTime ( 'now' , new \ DateTimeZone ( 'UTC' ) ) ; $ lastConfirmed -> setTimestamp ( $ timestamp ) ; return new UnregisteredException ( $ lastConfirmed ) ; case 'payloadtoolarge' : return new PayloadTooLargeException ( ) ; case 'toomanyprovidertokenupdates' : return new TooManyProviderTokenUpdatesException ( ) ; case 'toomanyrequests' : return new TooManyRequestsException ( ) ; case 'internalservererror' : return new InternalServerErrorException ( ) ; case 'serviceunavailable' : return new ServiceUnavailableException ( ) ; case 'shutdown' : return new ShutdownException ( ) ; default : return new UndefinedErrorException ( ) ; } }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
11734	public function hide ( $ pageName , $ languageName ) { $ this -> contributorDefined ( ) ; $ baseDir = $ this -> pagesDir . '/' . $ pageName . '/' . $ languageName ; $ sourceFile = $ baseDir . '/seo.json' ; Dispatcher :: dispatch ( PageEvents :: PAGE_HIDING , new PageHidingEvent ( ) ) ; unlink ( $ sourceFile ) ; Dispatcher :: dispatch ( PageEvents :: PAGE_HID , new PageHidEvent ( ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" for language "%s" was hidden from production' , $ pageName , $ languageName ) ) ; }
9625	public function getById ( $ characterId ) { try { $ result = $ this -> client -> get ( $ this -> slug . '/' . $ characterId ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
6526	public static function resolveId ( SchemaId $ id ) : string { $ curieMajor = $ id -> getCurieMajor ( ) ; if ( isset ( self :: $ curies [ $ curieMajor ] ) ) { return self :: $ classes [ self :: $ curies [ $ curieMajor ] ] ; } $ curie = $ id -> getCurie ( ) -> toString ( ) ; if ( isset ( self :: $ curies [ $ curie ] ) ) { return self :: $ classes [ self :: $ curies [ $ curie ] ] ; } throw new NoMessageForSchemaId ( $ id ) ; }
860	public function clearRange ( $ indexStart , $ indexEnd ) { for ( $ i = $ indexStart ; $ i <= $ indexEnd ; ++ $ i ) { $ this -> clearAt ( $ i ) ; } }
5726	public function recordIsPublished ( ) { if ( ! $ this -> owner -> record -> checkVersioned ( ) ) { return false ; } if ( ! $ this -> owner -> record -> isInDB ( ) ) { return false ; } $ baseClass = DataObject :: getSchema ( ) -> baseDataClass ( $ this -> owner -> record ) ; $ stageTable = DataObject :: getSchema ( ) -> tableName ( $ baseClass ) . '_Live' ; return ( bool ) DB :: query ( "SELECT \"ID\" FROM \"{$stageTable}\" WHERE \"ID\" = {$this->owner->record->ID}" ) -> value ( ) ; }
7218	public function create ( $ argv ) { $ custom_name = false ; if ( $ argv && count ( $ argv ) ) { $ custom_name = mb_strtolower ( $ argv [ 0 ] , 'utf-8' ) ; } DB :: begin ( ) ; try { $ name = 'm' . gmdate ( 'ymd_His' ) ; if ( $ custom_name ) $ name = $ name . '_' . $ custom_name ; $ file = '<?php// ' . strftime ( '%F %T' ) . 'use mii\db\Migration;use mii\db\DB;class ' . $ name . ' extends Migration { public function up() { } public function down() { return false; } public function safe_up() { } public function safe_down() { return false; }}' ; reset ( $ this -> migrations_paths ) ; file_put_contents ( current ( $ this -> migrations_paths ) . '/' . $ name . '.php' , $ file ) ; DB :: commit ( ) ; $ this -> info ( 'migration :name created' , [ ':name' => $ name ] ) ; } catch ( \ Exception $ e ) { DB :: rollback ( ) ; throw $ e ; } }
3809	protected function applyLegendConditions ( $ attributeId , $ activeLegendId ) { if ( ! isset ( $ this -> conditions [ $ activeLegendId ] ) ) { return ; } if ( ! isset ( $ this -> conditions [ $ attributeId ] ) ) { $ this -> conditions [ $ attributeId ] = new PropertyConditionChain ( ) ; } $ this -> conditions [ $ attributeId ] -> addCondition ( $ this -> conditions [ $ activeLegendId ] ) ; }
8036	public static function convert ( $ input , $ outputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { if ( is_int ( $ minLength ) ) { $ input += self :: getMinForlength ( $ outputFormat , $ minLength ) ; } static :: throwUnlessAcceptable ( $ outputFormat , $ input ) ; return self :: convertBase ( $ input , self :: FORMAT_NUMBER , $ outputFormat ) ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
6234	protected function applyAccessMode ( int $ mode ) : void { if ( $ this -> mode === self :: MODE_CLOSED ) { $ this -> mode = $ mode ; return ; } elseif ( $ mode === $ this -> mode ) { return ; } throw new AccessDeniedException ( 'unable to switch access-mode for existing binary file handle' , 500 ) ; }
5044	public function onRoute ( MvcEvent $ e ) { $ routeMatch = $ e -> getRouteMatch ( ) ; if ( 0 !== strpos ( $ routeMatch -> getMatchedRouteName ( ) , 'lang' ) ) { $ lang = $ this -> detectLanguage ( $ e ) ; $ this -> setLocale ( $ e , $ lang ) ; return ; } $ language = $ routeMatch -> getParam ( 'lang' , '__NOT_SET__' ) ; if ( $ this -> localeService -> isLanguageSupported ( $ language ) ) { $ this -> setLocale ( $ e , $ language ) ; } else { $ e -> setError ( Application :: ERROR_ROUTER_NO_MATCH ) ; $ e -> setTarget ( $ this ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ eventManager -> setEventPrototype ( $ e ) ; $ result = $ eventManager -> trigger ( MvcEvent :: EVENT_DISPATCH_ERROR , $ e ) ; return $ result -> last ( ) ; } }
40	protected function fetchRootIdentifier ( ) { if ( $ this -> repoData ) { return ; } $ repoDataUrl = $ this -> getApiUrl ( ) . '/repos/' . $ this -> owner . '/' . $ this -> repository ; $ this -> repoData = JsonFile :: parseJson ( $ this -> getContents ( $ repoDataUrl , true ) , $ repoDataUrl ) ; if ( null === $ this -> repoData && null !== $ this -> gitDriver ) { return ; } $ this -> owner = $ this -> repoData [ 'owner' ] [ 'login' ] ; $ this -> repository = $ this -> repoData [ 'name' ] ; $ this -> isPrivate = ! empty ( $ this -> repoData [ 'private' ] ) ; if ( isset ( $ this -> repoData [ 'default_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'default_branch' ] ; } elseif ( isset ( $ this -> repoData [ 'master_branch' ] ) ) { $ this -> rootIdentifier = $ this -> repoData [ 'master_branch' ] ; } else { $ this -> rootIdentifier = 'master' ; } $ this -> hasIssues = ! empty ( $ this -> repoData [ 'has_issues' ] ) ; }
1201	public function isCurrent ( ItemInterface $ item ) { if ( null === $ this -> matcher ) { throw new \ BadMethodCallException ( 'The matcher must be set to get the breadcrumbs array' ) ; } return $ this -> matcher -> isCurrent ( $ item ) ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
6471	public function parseContentTypeHeader ( HttpHeaders $ headers ) : ? ContentTypeHeaderValue { if ( ! $ headers -> containsKey ( 'Content-Type' ) ) { return null ; } $ contentTypeHeaderParameters = $ this -> parseParameters ( $ headers , 'Content-Type' ) ; $ contentType = $ contentTypeHeaderParameters -> getKeys ( ) [ 0 ] ; return new ContentTypeHeaderValue ( $ contentType , $ contentTypeHeaderParameters ) ; }
4889	public function viewAction ( Request $ request , $ id ) { $ pageManager = $ this -> getPageManager ( ) ; $ page = $ pageManager -> findForView ( $ id ) ; if ( null !== ( $ validator = $ this -> getViewActionValidator ( ) ) ) { $ validator -> validate ( $ page ) ; } if ( $ page instanceof ControllerPageInterface ) { return $ this -> forward ( $ page -> getController ( ) , ( array ) $ page -> getControllerParameters ( ) + array ( 'parameters' => $ request -> query -> all ( ) , '_locale' => $ request -> attributes -> get ( '_locale' ) , '_internal_url' => $ request -> attributes -> get ( '_internal_url' ) , ) , $ request -> query -> all ( ) ) ; } return $ this -> renderPage ( $ page ) ; }
7027	public function autoLogin ( EntityInterface $ user ) : ? Response { $ controller = $ this -> getController ( ) ; $ request = $ controller -> request ; $ token = $ request -> getQuery ( 't' ) ; if ( empty ( $ token ) ) { return null ; } $ this -> Auth -> logout ( ) ; $ tokenData = $ user -> validateLoginToken ( $ token , $ user -> getKey ( ) , $ user -> getSalt ( ) ) ; if ( ! is_array ( $ tokenData ) ) { return null ; } if ( ! empty ( $ tokenData [ 'addRememberMeCookie' ] ) && $ tokenData [ 'addRememberMeCookie' ] ) { $ this -> addRememberMeCookie ( ( string ) $ user -> id ) ; } $ userData = $ user -> toArray ( ) ; $ userData [ 'user' ] = $ user ; $ this -> Auth -> setUser ( $ userData ) ; if ( ! empty ( $ tokenData [ 'url' ] ) ) { return $ controller -> redirect ( $ tokenData [ 'url' ] ) ; } return $ controller -> redirect ( $ this -> getConfig ( 'defaultRedirect' ) ) ; }
11186	public function setPrivateChatUpdateRead ( Neuron_GameServer_Player $ from , Neuron_GameServer_Player $ target ) { $ db = Neuron_DB_Database :: getInstance ( ) ; $ db -> query ( " UPDATE n_privatechat_updates SET pu_read = '1' WHERE pu_to = {$target->getId ()} AND pu_from = {$from->getId ()} " ) ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
3040	public function del ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; $ this -> putInCache ( $ key , $ userId , $ callId , null , self :: STATE_PENDING_DELETE ) ; return true ; }
6561	public static function getRelativePath ( $ path , $ start = null ) { if ( $ start === null ) { $ start = getcwd ( ) ; } if ( substr ( $ path , 0 , 1 ) !== '/' || substr ( $ start , 0 , 1 ) !== '/' ) { return false ; } $ pathParts = self :: splitPath ( $ path ) ; $ countPathParts = count ( $ pathParts ) ; $ startParts = self :: splitPath ( $ start ) ; $ countStartParts = count ( $ startParts ) ; $ commonLength = min ( $ countPathParts , $ countStartParts ) ; for ( $ i = 0 ; $ i < $ commonLength ; $ i ++ ) { if ( $ startParts [ $ i ] !== $ pathParts [ $ i ] ) { break ; } } $ relList = ( $ countStartParts > $ i ) ? array_fill ( 0 , $ countStartParts - $ i , '..' ) : [ ] ; $ relList = array_merge ( $ relList , array_slice ( $ pathParts , $ i ) ) ; return implode ( '/' , $ relList ) ? : '.' ; }
10295	public static function dayStringToNumber ( $ day ) { $ strippedDayValue = ( str_replace ( self :: $ numberSuffixes , '' , $ day ) ) ; if ( is_numeric ( $ strippedDayValue ) ) { return ( int ) $ strippedDayValue ; } return $ day ; }
7830	public function getRightBordersWith ( $ border ) { $ space = str_repeat ( ' ' , static :: MIN_SPACE_FROM_BORDER_X ) ; $ border = str_repeat ( $ border , static :: BORDER_WIDTH ) ; return str_repeat ( "{$space}{$border}" , $ this -> nesting ) ; }
12841	static public function recursiveDelete ( $ path ) { if ( is_file ( $ path ) ) { return unlink ( $ path ) ; } $ scans = glob ( rtrim ( $ path , '/' ) . '/*' ) ; foreach ( $ scans as $ scan ) { self :: recursiveDelete ( $ scan ) ; } return rmdir ( $ path ) ; }
4608	public function createStatus ( string $ status , array $ options = null ) : array { $ url = '/statuses' ; if ( empty ( $ options ) ) { $ options = [ ] ; } $ params = array_merge ( [ 'status' => $ status , ] , $ options ) ; return $ this -> post ( $ url , $ params ) ; }
9691	private function compile ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } if ( ! file_exists ( $ this -> views_cache ) && ! mkdir ( $ this -> views_cache ) ) { throw new \ Exception ( "Could no create cache directory." . " Make sure you have write permissions." ) ; } $ hash = md5 ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; $ compiled = null ; if ( $ this -> debug || ( ! file_exists ( $ compiled_file ) || filemtime ( $ compiled_file ) < filemtime ( $ file ) ) ) { $ source = file_get_contents ( $ file ) ; $ compiled = $ this -> compileString ( $ source ) ; $ compiled = "<?php\nfunction katar_" . $ hash . "(\$args) {\nextract(\$args);\n\$output = null;\n" . $ compiled . "\nreturn \$output;\n}\n" ; file_put_contents ( $ compiled_file , $ compiled ) ; } else { $ compiled = file_get_contents ( $ cache_file ) ; } return $ compiled ; }
6054	public function createFolder ( Folder $ folder , $ parentId = 0 , $ inheritAccess = null ) { $ parameters = [ 'query' => [ 'parentId' => $ parentId ] , 'body' => json_encode ( [ 'folder' => $ folder , 'inheritAccess' => $ inheritAccess ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders' , $ parameters ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
10735	public function setUpper ( $ upper ) : self { if ( ! is_numeric ( $ upper ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, upper, to be a number" ) ; } $ this -> upper = $ upper ; return $ this ; }
9838	public function createSymmetricAuthenticatedJsonResponse ( int $ status , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
5676	protected function getMembers ( $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ members = array ( ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { $ members [ $ property -> getName ( ) ] = $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { $ members [ $ property -> getName ( ) ] = $ this -> getPrivatePropertyNoMatterWhat ( $ property -> getName ( ) , $ object ) ; } } return $ members ; }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
2768	public function checkoutNewBranch ( string $ branch , array $ options = [ ] ) : string { $ options [ 'b' ] = true ; return $ this -> checkout ( $ branch , $ options ) ; }
8501	public function setGetMatchingProductForIdResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductForIdResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9306	public function setAllowJsonApi ( $ allowJsonApi ) { if ( ! is_bool ( $ allowJsonApi ) ) { throw new \ InvalidArgumentException ( '`allowJsonApi` expects boolean value!' ) ; } $ this -> options [ 'allowJsonApi' ] = ( bool ) $ allowJsonApi ; return $ this ; }
7494	public function trimRight ( $ characters = null ) { $ this -> string = rtrim ( $ this -> string , $ characters ) ; return $ this ; }
10949	protected function loadCsrfToken ( ) { if ( $ this -> enableCsrfCookie ) { return $ this -> getCookies ( ) -> getValue ( $ this -> csrfParam ) ; } else { return Yii :: $ app -> getSession ( ) -> get ( $ this -> csrfParam ) ; } }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
10810	public function actionIndex ( $ option = null ) { $ allNames = [ 'web/assets' , 'runtime' , 'runtime/cache' , 'tests/_output' , ] ; $ answer = Select :: display ( 'Select objects' , $ allNames , 1 ) ; $ result = ClearHelper :: run ( $ answer ) ; if ( $ result ) { Output :: items ( $ result , "Clear completed: " . count ( $ result ) . " objects" ) ; } else { Output :: block ( "Not fount object for clear!" ) ; } }
463	public function buildAndCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
11887	public function getUser ( $ owner = true ) { if ( $ owner && $ this -> owner -> getBehavior ( 'Ownable' ) !== null && isset ( $ this -> owner -> objectOwner ) ) { return $ this -> owner -> objectOwner ; } elseif ( isset ( Yii :: $ app -> user ) && isset ( Yii :: $ app -> user -> identity -> primaryKey ) ) { return Yii :: $ app -> user -> identity ; } return false ; }
7665	function EncodeFile ( $ path , $ encoding = "base64" ) { if ( ! @ $ fd = fopen ( $ path , "rb" ) ) { $ this -> SetError ( $ this -> Lang ( "file_open" ) . $ path ) ; return "" ; } $ magic_quotes = get_magic_quotes_runtime ( ) ; set_magic_quotes_runtime ( 0 ) ; $ file_buffer = fread ( $ fd , filesize ( $ path ) ) ; $ file_buffer = $ this -> EncodeString ( $ file_buffer , $ encoding ) ; fclose ( $ fd ) ; set_magic_quotes_runtime ( $ magic_quotes ) ; return $ file_buffer ; }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
1699	public function getFile ( $ strName ) { foreach ( $ this -> arrFiles as $ k => $ v ) { if ( $ strName == $ v [ 'file_name' ] ) { $ this -> intIndex = $ k ; return true ; } } return false ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
6006	public function toUnicode ( ) { $ h = ord ( $ this -> char { 0 } ) ; if ( $ h <= 0x7F ) { return $ h ; } else { if ( $ h < 0xC2 ) { return false ; } else { if ( $ h <= 0xDF ) { return ( $ h & 0x1F ) << 6 | ( ord ( $ this -> char { 1 } ) & 0x3F ) ; } else { if ( $ h <= 0xEF ) { return ( $ h & 0x0F ) << 12 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 2 } ) & 0x3F ) ; } else { if ( $ h <= 0xF4 ) { return ( $ h & 0x0F ) << 18 | ( ord ( $ this -> char { 1 } ) & 0x3F ) << 12 | ( ord ( $ this -> char { 2 } ) & 0x3F ) << 6 | ( ord ( $ this -> char { 3 } ) & 0x3F ) ; } else { return false ; } } } } } }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
1068	private function collectConflictsBetween ( ValidationContext $ context , array & $ conflicts , $ parentFieldsAreMutuallyExclusive , array $ fieldMap1 , array $ fieldMap2 ) { foreach ( $ fieldMap1 as $ responseName => $ fields1 ) { if ( ! isset ( $ fieldMap2 [ $ responseName ] ) ) { continue ; } $ fields2 = $ fieldMap2 [ $ responseName ] ; $ fields1Length = count ( $ fields1 ) ; $ fields2Length = count ( $ fields2 ) ; for ( $ i = 0 ; $ i < $ fields1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fields2Length ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , $ parentFieldsAreMutuallyExclusive , $ responseName , $ fields1 [ $ i ] , $ fields2 [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
2294	public static function getTinyMceLanguage ( ) { $ lang = $ GLOBALS [ 'TL_LANGUAGE' ] ; if ( $ lang == '' ) { return 'en' ; } $ lang = str_replace ( '-' , '_' , $ lang ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ lang . '.js' ) ) { return $ lang ; } if ( ( $ short = substr ( $ GLOBALS [ 'TL_LANGUAGE' ] , 0 , 2 ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ short . '.js' ) ) { return $ short ; } } elseif ( ( $ long = $ short . '_' . strtoupper ( $ short ) ) != $ lang ) { if ( file_exists ( $ rootDir . '/assets/tinymce4/js/langs/' . $ long . '.js' ) ) { return $ long ; } } return 'en' ; }
9634	public function getFormField ( ) { if ( null === $ this -> field ) { $ this -> field = $ this -> initFormField ( ) ; } return $ this -> field ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
5716	public function doSaveAndQuit ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ this -> getBackLink ( ) ) ; }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
12336	public function changePasswordAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-password' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangePasswordForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> changePassword ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-password-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
4745	public function isReviewOptInValidationRequired ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInValidationRequired ( ) ; }
4892	protected function getGenerator ( ) { if ( isset ( $ this -> generator ) ) { return $ this -> generator ; } if ( $ this -> entity instanceof SnapshotGeneratorProviderInterface ) { $ serviceLocator = $ this -> getServicelocator ( ) ; $ className = get_class ( $ this -> entity ) ; if ( $ serviceLocator -> has ( 'snapshotgenerator' . $ className ) ) { $ generator = $ this -> serviceLocator -> get ( 'snapshotgenerator' . $ className ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; $ generator = null ; } } if ( ! isset ( $ generator ) ) { $ generator = $ this -> entity -> getSnapshotGenerator ( ) ; if ( is_array ( $ generator ) ) { $ this -> options = ArrayUtils :: merge ( $ generator , $ this -> options ) ; if ( array_key_exists ( 'generator' , $ generator ) ) { $ generator = $ this -> options [ 'generator' ] ; unset ( $ this -> options [ 'generator' ] ) ; } else { $ generator = null ; } } if ( is_string ( $ generator ) ) { $ generator = $ serviceLocator -> get ( $ generator ) ; } } if ( ! isset ( $ generator ) ) { $ generator = new SnapshotGenerator ( ) ; } if ( array_key_exists ( 'hydrator' , $ this -> options ) ) { $ hydrator = $ this -> options [ 'hydrator' ] ; if ( is_string ( $ hydrator ) && ! empty ( $ hydrator ) ) { $ hydrator = $ serviceLocator -> get ( 'HydratorManager' ) -> get ( $ hydrator ) ; } $ generator -> setHydrator ( $ hydrator ) ; } if ( array_key_exists ( 'exclude' , $ this -> options ) ) { $ hydrator = $ generator -> getHydrator ( ) ; $ exclude = $ this -> options [ 'exclude' ] ; if ( is_array ( $ exclude ) ) { $ hydrator -> setExcludeMethods ( $ exclude ) ; } } $ generator -> setSource ( $ this -> entity ) ; $ this -> generator = $ generator ; } return $ this -> generator ; }
11166	protected function buildHeader ( ) { if ( $ this -> getExtNamespace ( ) === null ) { throw new ExtDirectException ( "Ext js Namespace not set" ) ; } $ var = 'Ext.ns("' . $ this -> getNameSpace ( ) . '"); ' . $ this -> getNameSpace ( ) . "." . Keys :: EXT_HEADER . ' = ' ; return $ var ; }
11240	public function def ( $ checkName , $ class , $ method , $ errorMessage , $ passing = true , $ arguments = false ) { $ this -> customChecks -> $ checkName = [ '_call' , $ class , $ method , $ passing , $ arguments ] ; $ this -> lang -> $ checkName = $ errorMessage ; }
9552	public function allowMimeTypes ( $ mimeTypes ) { if ( ! is_array ( $ mimeTypes ) ) { $ mimeTypes = [ $ mimeTypes ] ; } $ this -> constraints [ ] = new MimeTypeConstraint ( $ mimeTypes ) ; return $ this ; }
5416	protected function dispatchRequest ( $ socket , $ encoding ) { foreach ( $ this -> headers as $ header_line ) { $ socket -> write ( $ header_line . "\r\n" ) ; } if ( count ( $ this -> cookies ) > 0 ) { $ socket -> write ( 'Cookie: ' . implode ( ';' , $ this -> cookies ) . "\r\n" ) ; } $ encoding -> writeHeadersTo ( $ socket ) ; $ socket -> write ( "\r\n" ) ; $ encoding -> writeTo ( $ socket ) ; }
9221	public function offsetExists ( $ offset ) { if ( ! isset ( $ this -> data [ $ offset ] ) ) { $ this -> requestAllPages ( ) ; } return isset ( $ this -> data [ $ offset ] ) ; }
4813	public function get ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> storage ) ? $ this -> storage [ $ name ] : $ default ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
3187	public function end ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'end() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; } else { \ common_Logger :: t ( 'Range already closed, or missing START TimePoint in QtiTimer, continue anyway' ) ; } return $ this ; }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
12280	protected function initTemplateAssetsManager ( ) { $ templateAssetsManager = $ this -> options [ "template_assets" ] ; $ pluginManager = $ this -> options [ "plugin_manager" ] ; $ templateAssetsManager -> backend ( ) -> add ( $ pluginManager -> getAssets ( ) ) ; return $ templateAssetsManager ; }
4571	public function setAnonymousUuid ( ? string $ anonymousUuid ) { $ this -> anonymousUuid = $ anonymousUuid ; $ this -> _anonymousUuid = true ; return $ this ; }
1187	protected function createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) { if ( is_null ( $ this -> resolver ) ) { return new BaseValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; } return call_user_func ( $ this -> resolver , $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; }
8749	public function loadFromRegistry ( Registry $ registry ) { foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderFactories ( $ serviceProvider , $ key ) ; } foreach ( $ registry as $ key => $ serviceProvider ) { $ this -> loadServiceProviderExtensions ( $ serviceProvider , $ key ) ; } }
11363	public static function mailListTagger ( array $ list ) { $ str = '' ; foreach ( $ list as $ name => $ mail ) { if ( is_string ( $ mail ) ) { $ str .= self :: mailTagger ( $ mail , $ name ) . Mailer :: $ ADDERSSES_SEPARATOR ; } elseif ( is_array ( $ mail ) ) { foreach ( $ mail as $ subname => $ submail ) { $ str .= self :: mailTagger ( $ submail , $ subname ) . Mailer :: $ ADDERSSES_SEPARATOR ; } } } return $ str ; }
9866	private function writeProtectedRanges ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getProtectedCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'protectedRanges' ) ; foreach ( $ pSheet -> getProtectedCells ( ) as $ protectedCell => $ passwordHash ) { $ objWriter -> startElement ( 'protectedRange' ) ; $ objWriter -> writeAttribute ( 'name' , 'p' . md5 ( $ protectedCell ) ) ; $ objWriter -> writeAttribute ( 'sqref' , $ protectedCell ) ; if ( ! empty ( $ passwordHash ) ) { $ objWriter -> writeAttribute ( 'password' , $ passwordHash ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
3342	public function getGroupList ( $ options = array ( ) ) { $ options = array_replace ( array ( 'from' => null , 'to' => null , 'limit' => null , 'request_limit' => null , 'reversed' => false , ) , $ options ) ; if ( ! empty ( $ options [ 'from' ] ) && ! empty ( $ options [ 'to' ] ) ) { throw new \ Exception ( 'Only one of "from" and "to" arguments is allowed' ) ; } $ options [ 'from' ] = self :: dateTimeString ( $ options [ 'from' ] ) ; $ options [ 'to' ] = self :: dateTimeString ( $ options [ 'to' ] ) ; return new GroupIterator ( $ this , $ options ) ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
5476	protected function encode ( ) { $ class = $ this -> encoding ; $ encoding = new $ class ( ) ; for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { $ this -> widgets [ $ i ] -> write ( $ encoding ) ; } return $ encoding ; }
5260	public function setOptions ( $ mode = null , $ logicalOperator = null , array $ linkedFilters = [ ] ) { $ this -> mode = is_null ( $ mode ) ? Filter :: MODE_INCLUDE : $ mode ; $ this -> logicalOperator = is_null ( $ logicalOperator ) ? Filter :: MERGE_OR : $ logicalOperator ; $ this -> linkedFilters = $ linkedFilters ; return $ this ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
1391	protected function resourceFieldsExistInAttributesAndRelationships ( iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> resourceFieldExistsInAttributesAndRelationships ( $ field ) ) ; } }
12446	protected function _setContainer ( $ container ) { if ( ! is_null ( $ container ) && ! ( $ container instanceof BaseContainerInterface ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Not a valid container' ) , 0 , null , $ container ) ; } $ this -> container = $ container ; return $ this ; }
8638	public function setOrderFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9653	public function addLoader ( $ extensions , $ loaderClass ) { foreach ( ( array ) $ extensions as $ extension ) { $ this -> extensions [ ] = $ extension ; if ( is_string ( $ loaderClass ) ) { $ this -> loaderClasses [ $ extension ] = $ loaderClass ; } elseif ( $ loaderClass instanceof LoaderInterface ) { $ this -> loaders [ $ extension ] = $ loaderClass ; } } }
9544	public static function allExcept ( $ except ) { $ result = [ 'parameter' => [ 'longest' => 9 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> prefix . $ parameter -> parameterName ; } , ] , 'properties' => [ 'longest' => 10 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getPropertiesAsString ( ) ; } , ] , 'aliases' => [ 'longest' => 7 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> getAliasUsage ( false ) ; } , ] , 'description' => [ 'longest' => 11 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> description ; } , ] , 'required' => [ 'longest' => 8 + $ columnPadding , 'values' => [ ] , 'fetch' => function ( $ parameter ) { return $ parameter -> required ? 'Yes' : '' ; } , ] , ] ; foreach ( $ except as $ exceptKey ) { unset ( $ result [ $ exceptKey ] ) ; } return $ result ; }
8982	private function filter ( $ configurations , array $ criteria ) { $ result = array ( ) ; foreach ( $ configurations as $ configuration ) { if ( ConfigurationFilterUtil :: matches ( $ configuration , $ criteria ) ) { $ result [ ] = $ configuration ; } } return $ result ; }
1959	public static function encode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> encode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
4213	public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ lastKeys ) ; $ lastKeys = \ array_unique ( $ newKeys ) ; } } return $ lastKeys ; }
6092	public function removeMediaFromMoodboard ( $ moodboardId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ moodboardId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
2245	public static function getPageStatusIcon ( $ objPage ) { $ sub = 0 ; $ image = $ objPage -> type . '.svg' ; if ( ! $ objPage -> published || ( $ objPage -> start != '' && $ objPage -> start > time ( ) ) || ( $ objPage -> stop != '' && $ objPage -> stop < time ( ) ) ) { ++ $ sub ; } if ( $ objPage -> hide && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 2 ; } if ( $ objPage -> protected && ! \ in_array ( $ objPage -> type , array ( 'root' , 'error_401' , 'error_403' , 'error_404' ) ) ) { $ sub += 4 ; } if ( $ sub > 0 ) { $ image = $ objPage -> type . '_' . $ sub . '.svg' ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageStatusIcon' ] as $ callback ) { $ image = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objPage , $ image ) ; } } return $ image ; }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
612	public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
3419	protected static function instantiateServiceContainer ( ) { $ container = Container :: getInstance ( ) ; if ( ! $ container ) { $ container = new Container ( ) ; Container :: setInstance ( $ container ) ; } return $ container ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
2536	protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; }
5128	public function readQDateTime ( ) { $ day = $ this -> readUInt ( ) ; $ msec = $ this -> readUInt ( ) ; $ this -> readBool ( ) ; if ( $ day === 0 && $ msec === 0xFFFFFFFF ) { return null ; } $ time = ( $ day - 2440588 ) * 86400 + $ msec / 1000 ; $ dt = \ DateTime :: createFromFormat ( 'U.u' , sprintf ( '%.6F' , $ time ) ) ; $ dt -> setTimezone ( new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; return $ dt ; }
8448	public function broadcastMsg ( array $ peers , $ msg ) { $ peerList = $ this -> formatPeers ( $ peers ) ; return $ this -> exec ( 'broadcast ' . $ peerList . ' ' . $ msg ) ; }
5823	private function resolveOptions ( array $ options = array ( ) ) { $ this -> options [ 'alertPublisher' ] = $ this -> alertPublisher ; return array_merge ( $ this -> options , $ options ) ; }
7119	protected function getGetMinEdaBySubjectQuery ( ) { if ( null !== $ this -> getMinEdaBySubjectQuery ) { return $ this -> getMinEdaBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> isNotNull ( $ as . '.estimatedDateOfArrival' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> gte ( $ as . '.orderedStock' , 0 ) , $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) ) -> select ( 'MIN(' . $ as . '.estimatedDateOfArrival) as eda' ) ; return $ this -> getMinEdaBySubjectQuery = $ qb -> getQuery ( ) ; }
8442	public function render ( array $ args , bool $ prettyPrint = null ) { header ( 'Content-type: application/json' ) ; if ( ( constant ( 'STRAY_ENV' ) === 'development' && $ prettyPrint !== false ) || $ prettyPrint === true ) { return ( string ) json_encode ( $ args , JSON_PRETTY_PRINT ) ; } return ( string ) json_encode ( $ args ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
12444	public static function run ( $ source , $ destination , $ width , $ height = "" ) { $ mime = exif_imagetype ( $ source ) ; switch ( $ mime ) { case IMAGETYPE_JPEG : $ source = imagecreatefromjpeg ( $ source ) ; break ; case IMAGETYPE_PNG : $ source = imagecreatefrompng ( $ source ) ; break ; case IMAGETYPE_GIF : $ source = imagecreatefromgif ( $ source ) ; break ; default : return ; } $ width_src = imagesx ( $ source ) ; $ height_src = imagesy ( $ source ) ; $ width_dest = 0 ; $ height_dest = 0 ; if ( ! $ height ) { $ ratio = ( $ width * 100 ) / $ width_src ; if ( $ ratio > 100 ) { imagejpeg ( $ source , $ destination , 70 ) ; imagedestroy ( $ source ) ; return ; } $ width_dest = $ width ; $ height_dest = $ height_src * $ ratio / 100 ; } else { if ( $ height_src >= $ width_src ) { $ height_dest = ( $ height_src * $ width ) / $ width_src ; $ width_dest = $ width ; } elseif ( $ height_src < $ width_src ) { $ width_dest = ( $ width_src * $ height ) / $ height_src ; $ height_dest = $ height ; } } $ emptyPicture = imagecreatetruecolor ( $ width , ( $ height ) ? $ height : $ height_dest ) ; imagecopyresampled ( $ emptyPicture , $ source , 0 , 0 , 0 , 0 , $ width_dest , $ height_dest , $ width_src , $ height_src ) ; imagejpeg ( $ emptyPicture , $ destination , 70 ) ; imagedestroy ( $ source ) ; imagedestroy ( $ emptyPicture ) ; return ; }
4999	protected function fixOneToMany ( PageInterface $ object ) { $ items = $ object -> getContentItems ( ) ; if ( $ items ) { foreach ( $ object -> getContentItems ( ) as $ item ) { $ item -> setPage ( $ object ) ; } } if ( $ this -> menuManager ) { $ this -> menuManager -> flush ( ) ; } }
4283	public function unlink ( $ path ) { self :: restorePrev ( ) ; $ success = \ unlink ( $ path ) ; self :: register ( ) ; return $ success ; }
11437	protected function init ( array $ options = null ) { $ this -> boot ( ) ; if ( ! is_null ( $ options ) ) { $ this -> setOptions ( array_merge ( $ this -> getOptions ( ) , $ options ) ) ; } }
7955	public function setUnblockSpam ( $ ipblock , $ ipv4 ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/unblock' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
9499	public function processRequest ( RequestInterface $ request ) { $ response = $ request -> send ( ) ; $ attempt = 0 ; while ( $ response -> getStatusCode ( ) == 429 && $ attempt < 5 ) { $ wait = $ response -> getHeader ( 'Retry-After' ) ; if ( $ wait > 0 ) { sleep ( $ wait ) ; } $ attempt ++ ; $ response = $ request -> send ( ) ; } if ( $ response -> getStatusCode ( ) >= 500 ) { throw new ZendeskException ( 'Zendesk Server Error Detected.' ) ; } if ( $ response -> getStatusCode ( ) >= 400 ) { if ( $ response -> getContentType ( ) == 'application/json' ) { $ result = $ response -> json ( ) ; $ description = array_key_exists ( $ result , 'description' ) ? $ result [ 'description' ] : 'Invalid Request' ; $ value = array_key_exists ( $ result , 'value' ) ? $ result [ 'value' ] : array ( ) ; $ exception = new ZendeskException ( $ description ) ; $ exception -> setError ( $ value ) ; throw $ exception ; } else { throw new ZendeskException ( 'Invalid API Request' ) ; } } return $ response ; }
3597	protected function createIndexes ( ) { $ this -> createIndex ( $ this -> db -> getIndexName ( '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) , '{{%dolphiq_sitemap_entries}}' , [ 'type' , 'linkId' ] , true ) ; switch ( $ this -> driver ) { case DbConfig :: DRIVER_MYSQL : break ; case DbConfig :: DRIVER_PGSQL : break ; } }
5697	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getPreviousRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
8263	protected function onStateMismatch ( ) { $ this -> logger -> warning ( "OAuth2 response state mismatch: provider: {provider} from {addr}" , array ( "provider" => get_class ( $ this -> provider ) , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] ) ) ; $ this -> session -> remove ( "oauth2state" ) ; $ this -> session -> addFlash ( "error" , "Invalid OAuth response." ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
1357	public function field ( string $ field , string $ inverse = null ) : self { $ this -> defaults = array_merge ( $ this -> defaults , [ ResourceRegistrar :: PARAM_RELATIONSHIP_NAME => $ field , ResourceRegistrar :: PARAM_RELATIONSHIP_INVERSE_TYPE => $ inverse ? : Str :: plural ( $ field ) , ] ) ; return $ this ; }
10701	public static function isBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return false ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return false ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return checkdate ( $ month , $ day , $ year ) ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
12717	protected function getMethodParameters ( Internal \ ReflectionClassFactory $ refl , $ method ) { return ( $ refl -> hasMethod ( $ method ) ? $ refl -> getMethod ( $ method ) -> getParameters ( ) : null ) ; }
9585	public function Nice ( ) { if ( $ this -> value && $ parts = parse_url ( $ this -> URL ( ) ) ) { $ remove = array ( 'scheme' , 'user' , 'pass' , 'port' , 'query' , 'fragment' ) ; foreach ( $ remove as $ part ) { unset ( $ parts [ $ part ] ) ; } return rtrim ( http_build_url ( $ parts ) , "/" ) ; } }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
9243	private function __setCookieAndLocale ( $ locale ) { if ( PHP_SAPI !== 'cli' ) { $ time = $ this -> __getCookieExpireTime ( ) ; I18n :: locale ( $ locale ) ; setcookie ( $ this -> __getCookieName ( ) , $ locale , $ time , '/' , $ this -> config ( 'Cookie.domain' ) ) ; } }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
2662	public function getBackends ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7831	public function getSpacedCore ( ) { $ left = $ this -> getSpacesByCore ( ) ; $ right = $ this -> getSpacesByCore ( true ) ; return $ left . $ this -> core . $ right ; }
8182	public function getDuration ( ) { if ( $ this -> isRoot ( ) && $ this -> profiles ) { $ duration = 0 ; foreach ( $ this -> profiles as $ profile ) { $ duration += $ profile -> getDuration ( ) ; } return $ duration ; } return isset ( $ this -> ends [ 'wt' ] ) && isset ( $ this -> starts [ 'wt' ] ) ? $ this -> ends [ 'wt' ] - $ this -> starts [ 'wt' ] : 0 ; }
11222	private static function checkRoutes ( ) { $ method = $ _SERVER [ 'REQUEST_METHOD' ] ; $ route_pos = array_keys ( self :: $ routes , self :: $ uri , true ) ; foreach ( $ route_pos as $ route ) { $ methodRoute = self :: $ methods [ $ route ] ; if ( $ methodRoute == $ method || $ methodRoute == 'ANY' ) { if ( ! is_object ( $ callback = self :: $ callbacks [ $ route ] ) ) { self :: $ response = self :: invokeObject ( $ callback ) ; } else { self :: $ response = call_user_func ( $ callback ) ; } if ( ! self :: $ halts ) { return self :: $ response ; } self :: $ halts -- ; } } return self :: $ response ; }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
2292	public static function getTheme ( ) { $ theme = Config :: get ( 'backendTheme' ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( $ theme != '' && $ theme != 'flexible' && is_dir ( $ rootDir . '/system/themes/' . $ theme ) ) { return $ theme ; } return 'flexible' ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
10155	private function readMulRk ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ colFirst = self :: getUInt2d ( $ recordData , 2 ) ; $ colLast = self :: getUInt2d ( $ recordData , $ length - 2 ) ; $ columns = $ colLast - $ colFirst + 1 ; $ offset = 4 ; for ( $ i = 1 ; $ i <= $ columns ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ colFirst + $ i ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , $ offset ) ; $ numValue = self :: getIEEE754 ( self :: getInt4d ( $ recordData , $ offset + 2 ) ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } $ cell -> setValueExplicit ( $ numValue , DataType :: TYPE_NUMERIC ) ; } $ offset += 6 ; } }
1117	public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
2384	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; if ( ! $ exception instanceof ResponseException ) { return ; } $ event -> allowCustomResponseCode ( ) ; $ event -> setResponse ( $ exception -> getResponse ( ) ) ; }
8706	public function setLastFolderID ( $ folderID ) { $ request = Controller :: curr ( ) -> getRequest ( ) ; $ session = $ request -> getSession ( ) ; $ session -> set ( get_class ( ) . '.FolderID' , $ folderID ) ; }
3985	private function isActive ( $ route , $ params , Request $ request ) { if ( '/contao' === $ request -> getPathInfo ( ) || ! ( $ request -> attributes -> get ( '_route' ) === $ route ) ) { return false ; } $ attributes = $ request -> attributes -> get ( '_route_params' ) ; $ query = $ request -> query ; foreach ( $ params as $ param => $ value ) { if ( isset ( $ attributes [ $ param ] ) && ( $ value !== $ request -> attributes [ '_route_params' ] [ $ param ] ) ) { return false ; } if ( $ query -> has ( $ param ) && ( $ value !== $ query -> get ( $ param ) ) ) { return false ; } } return true ; }
11282	public function _populate ( $ record = null , $ db = false , $ loadMap = false ) { $ this -> model_hydrating = true ; if ( $ db ) { $ this -> model_db = $ db ; } if ( $ record ) { $ this -> _populateAttributes ( $ record ) ; $ this -> _populateNonModelData ( $ record ) ; } if ( $ this -> model_loadMapsEnabled ) { $ this -> _populateLoadMap ( $ record , $ loadMap ) ; } $ this -> onLoad ( ) ; if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && $ func = $ loadMap -> getOnLoadFunction ( ) ) { $ args = $ loadMap -> getOnLoadArgs ( ) ; array_unshift ( $ args , $ this ) ; call_user_func_array ( $ func , $ args ) ; } $ this -> model_hydrating = false ; return $ this ; }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
8297	protected function createBkFile ( ) { if ( ! is_writable ( dirname ( $ this -> filePath ) ) ) { return ; } $ this -> bkFilePath = $ this -> filePath . '.' . date ( "y-m-d-H-i-s" ) . '.bak' ; $ bkHandle = @ fopen ( $ this -> bkFilePath , 'x+' ) ; if ( $ bkHandle === false ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a temporary file " . $ this -> bkFilePath ) ; } $ stat = fstat ( $ this -> handle ) ; if ( stream_copy_to_stream ( $ this -> handle , $ bkHandle ) !== $ stat [ 'size' ] ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not create a copy of " . $ this -> filePath ) ; } if ( ! fclose ( $ bkHandle ) ) { throw new \ RuntimeException ( "Could not close a backup file " . $ this -> bkFilePath ) ; } fseek ( $ this -> handle , 0 ) ; }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
8273	public function validateUserData ( $ userData ) { $ this -> assertRequired ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "pwhash" ) ; $ this -> assertString ( $ userData , "email" ) ; $ this -> assertArray ( $ userData , "attributes" ) ; $ this -> assertString ( $ userData , "encoder" ) ; $ this -> assertBool ( $ userData , "pwreset" ) ; $ this -> assertArrayOfStrings ( $ userData , "groups" ) ; $ this -> assertString ( $ userData , "displayName" ) ; }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
6441	public static function getSocialLoginObject ( $ network , $ options = array ( ) , $ logger = null ) { $ network = preg_replace ( '![^a-z0-9]!i' , '' , $ network ) ; if ( $ network == '' ) { throw new \ Exception ( 'Social Login Network can not be empty' ) ; } $ class = '\\Gelembjuk\\Auth\\SocialLogin\\' . ucfirst ( $ network ) ; if ( ! class_exists ( $ class ) ) { throw new \ Exception ( sprintf ( 'Integration with a class name %s not found' , $ class ) ) ; } $ object = new $ class ( $ options ) ; $ object -> setLogger ( $ logger ) ; return $ object ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
9203	public function get ( $ endpoint , $ params = null ) { $ endpoint = $ this -> prependVersionToEndpoint ( $ endpoint , Config :: get ( 'api_version' ) ) ; $ options = $ this -> constructRequestOptions ( $ params ) ; $ response = $ this -> guzzleClient -> get ( $ endpoint , $ options ) ; return $ response ; }
9276	public function validateFields ( Request $ request , Repository $ repository , $ data ) { $ config = [ ] ; $ validation = [ ] ; foreach ( $ this -> versions as $ version ) { foreach ( $ version [ 'endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'repository' ] == $ request -> attributes -> get ( 'repository' ) ) { $ config = $ endpoint ; break ; } } if ( $ config != [ ] ) { break ; } } if ( ! $ config [ 'allow_extra_fields' ] || $ config [ 'allow_fields' ] ) { $ mapping = $ this -> manager -> getMetadataCollector ( ) -> getMapping ( $ repository -> getClassName ( ) ) ; $ forbiddenFields = $ mapping [ 'properties' ] ; if ( $ config [ 'allow_fields' ] ) { foreach ( $ config [ 'allow_fields' ] as $ field ) { unset ( $ forbiddenFields [ $ field ] ) ; } } foreach ( $ data as $ parameter => $ value ) { if ( ! array_key_exists ( $ parameter , $ mapping [ 'properties' ] ) && $ parameter != '_id' ) { $ validation [ 'message' ] = sprintf ( 'Property `%s` does not exist in the mapping of `%s`.' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } if ( $ config [ 'allow_fields' ] && array_key_exists ( $ parameter , $ forbiddenFields ) ) { $ validation [ 'message' ] = sprintf ( 'You are not allowed to insert or modify the field `%s` in `%s`' , $ parameter , $ repository -> getType ( ) ) ; return $ validation ; } } } return $ validation ; }
8766	protected function loadConfigFiles ( ) { try { if ( file_exists ( $ this -> cachePath ( 'config.php' ) ) ) { $ this -> config = require $ this -> cachePath ( 'config.php' ) ; } else { $ dotenv = new \ Dotenv \ Dotenv ( $ this -> root ) ; $ dotenv -> load ( ) ; foreach ( glob ( $ this -> root . '/config/*.php' ) as $ file ) { $ keyName = strtolower ( str_replace ( [ $ this -> root . '/config/' , '.php' ] , '' , $ file ) ) ; $ this -> config [ $ keyName ] = require $ file ; } } } catch ( Exception $ e ) { die ( printf ( "Configuration information could not be retrieved properly.\nError Message: %s" , $ e -> getMessage ( ) ) ) ; } }
9997	protected function inferSeparator ( ) { if ( $ this -> delimiter !== null ) { return ; } $ potentialDelimiters = [ ',' , ';' , "\t" , '|' , ':' , ' ' ] ; $ counts = [ ] ; foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] = [ ] ; } $ numberLines = 0 ; while ( ( $ line = fgets ( $ this -> fileHandle ) ) !== false && ( ++ $ numberLines < 1000 ) ) { $ enclosure = preg_quote ( $ this -> enclosure , '/' ) ; $ line = preg_replace ( '/(' . $ enclosure . '.*' . $ enclosure . ')/U' , '' , $ line ) ; $ countLine = [ ] ; for ( $ i = strlen ( $ line ) - 1 ; $ i >= 0 ; -- $ i ) { $ char = $ line [ $ i ] ; if ( isset ( $ counts [ $ char ] ) ) { if ( ! isset ( $ countLine [ $ char ] ) ) { $ countLine [ $ char ] = 0 ; } ++ $ countLine [ $ char ] ; } } foreach ( $ potentialDelimiters as $ delimiter ) { $ counts [ $ delimiter ] [ ] = isset ( $ countLine [ $ delimiter ] ) ? $ countLine [ $ delimiter ] : 0 ; } } $ meanSquareDeviations = [ ] ; $ middleIdx = floor ( ( $ numberLines - 1 ) / 2 ) ; foreach ( $ potentialDelimiters as $ delimiter ) { $ series = $ counts [ $ delimiter ] ; sort ( $ series ) ; $ median = ( $ numberLines % 2 ) ? $ series [ $ middleIdx ] : ( $ series [ $ middleIdx ] + $ series [ $ middleIdx + 1 ] ) / 2 ; if ( $ median === 0 ) { continue ; } $ meanSquareDeviations [ $ delimiter ] = array_reduce ( $ series , function ( $ sum , $ value ) use ( $ median ) { return $ sum + pow ( $ value - $ median , 2 ) ; } ) / count ( $ series ) ; } $ min = INF ; foreach ( $ potentialDelimiters as $ delimiter ) { if ( ! isset ( $ meanSquareDeviations [ $ delimiter ] ) ) { continue ; } if ( $ meanSquareDeviations [ $ delimiter ] < $ min ) { $ min = $ meanSquareDeviations [ $ delimiter ] ; $ this -> delimiter = $ delimiter ; } } if ( $ this -> delimiter === null ) { $ this -> delimiter = reset ( $ potentialDelimiters ) ; } return $ this -> skipBOM ( ) ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
7312	public static function equinoxAutumn ( $ year ) { $ jd = static :: equinoxSeptember ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
669	protected function generateDependencyData ( $ cache ) { $ db = Instance :: ensure ( $ this -> db , Connection :: className ( ) ) ; if ( $ this -> sql === null ) { throw new InvalidConfigException ( 'DbDependency::sql must be set.' ) ; } if ( $ db -> enableQueryCache ) { $ db -> enableQueryCache = false ; $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; $ db -> enableQueryCache = true ; } else { $ result = $ db -> createCommand ( $ this -> sql , $ this -> params ) -> queryOne ( ) ; } return $ result ; }
6089	public function updateMoodboard ( $ id , Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
1125	public function isDescendantOf ( $ other ) { return ( $ this -> getLeft ( ) > $ other -> getLeft ( ) && $ this -> getLeft ( ) < $ other -> getRight ( ) && $ this -> inSameScope ( $ other ) ) ; }
6047	public function listObjectTypes ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ObjectType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
6691	public function addRoute ( $ httpMethod , $ route , $ handler , array $ middleware = [ ] ) { if ( ! $ handler instanceof HandlerContainer ) { $ handler = new HandlerContainer ( $ handler , array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } else { $ handler -> addMiddleware ( array_merge ( $ this -> middlewareStack , $ middleware ) ) ; } $ handler = serialize ( $ handler ) ; $ route = $ this -> currentGroupPrefix . $ route ; $ routeDatas = $ this -> routeParser -> parse ( $ route ) ; foreach ( ( array ) $ httpMethod as $ method ) { foreach ( $ routeDatas as $ routeData ) { $ this -> dataGenerator -> addRoute ( $ method , $ routeData , $ handler ) ; } } }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
9896	private function convertNumber ( $ num ) { if ( ( preg_match ( '/^\\d+$/' , $ num ) ) and ( $ num <= 65535 ) ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgInt' ] , $ num ) ; } if ( BIFFwriter :: getByteOrder ( ) ) { $ num = strrev ( $ num ) ; } return pack ( 'Cd' , $ this -> ptg [ 'ptgNum' ] , $ num ) ; }
10026	function getContacts ( $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts' , $ queryParameters ) ; }
1161	private function fakeRequiredIfData ( $ data , $ rule , $ parameters ) { if ( $ rule !== 'RequiredIf' ) { return ; } $ newData = $ data ; $ newData [ $ parameters [ 0 ] ] = $ parameters [ 1 ] ; $ this -> validator -> setData ( $ newData ) ; }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
3734	protected function saveSimpleColumn ( $ strColumn , $ arrIds , $ varData ) { if ( is_array ( $ varData ) ) { $ varData = serialize ( $ varData ) ; } $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ builder -> update ( $ this -> getTableName ( ) , 'v2' ) -> set ( 'v2.' . $ strColumn , is_array ( $ varData ) ? serialize ( $ varData ) : $ varData ) -> where ( $ builder -> expr ( ) -> in ( 'v2.id' , ':ids' ) ) -> setParameter ( 'ids' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> execute ( ) ; }
12961	public function getDb ( ) { if ( is_null ( $ this -> db ) ) { if ( $ this -> getAccessType ( ) == 'mysqli' && function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { if ( $ this -> getAccessType ( ) == 'pdo' && class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } } if ( is_null ( $ this -> db ) ) { if ( class_exists ( 'PDO' ) ) { $ this -> db = new Db \ Pdo ( ) ; } elseif ( function_exists ( 'mysqli_select_db' ) ) { $ this -> db = new Db \ Mysqli ( ) ; } else { throw new DbException ( 'Database engine not available! Must be either PDO or mysqli' ) ; } } $ this -> db -> setCredentials ( $ this -> credentials ) ; } return $ this -> db ; }
3247	public function add ( $ item , $ quantity = 1 , $ quantityReset = false ) { if ( ! is_array ( $ item ) && ! $ item -> isShoppable ) return ; $ cartItem = $ this -> getItem ( is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku ) ; if ( empty ( $ cartItem ) ) { $ reflection = null ; if ( is_object ( $ item ) ) { $ reflection = new \ ReflectionClass ( $ item ) ; } $ cartItem = call_user_func ( Config :: get ( 'shop.item' ) . '::create' , [ 'user_id' => $ this -> user -> shopId , 'cart_id' => $ this -> attributes [ 'id' ] , 'sku' => is_array ( $ item ) ? $ item [ 'sku' ] : $ item -> sku , 'price' => is_array ( $ item ) ? $ item [ 'price' ] : $ item -> price , 'tax' => is_array ( $ item ) ? ( array_key_exists ( 'tax' , $ item ) ? $ item [ 'tax' ] : 0 ) : ( isset ( $ item -> tax ) && ! empty ( $ item -> tax ) ? $ item -> tax : 0 ) , 'shipping' => is_array ( $ item ) ? ( array_key_exists ( 'shipping' , $ item ) ? $ item [ 'shipping' ] : 0 ) : ( isset ( $ item -> shipping ) && ! empty ( $ item -> shipping ) ? $ item -> shipping : 0 ) , 'currency' => Config :: get ( 'shop.currency' ) , 'quantity' => $ quantity , 'class' => is_array ( $ item ) ? null : $ reflection -> getName ( ) , 'reference_id' => is_array ( $ item ) ? null : $ item -> shopId , ] ) ; } else { $ cartItem -> quantity = $ quantityReset ? $ quantity : $ cartItem -> quantity + $ quantity ; $ cartItem -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ this ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
8540	public function setmember ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'member' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11289	protected function _getModel ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false , $ record = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = null ; if ( $ relatedObjName ) { if ( $ loadMap instanceof \ Cora \ Adm \ LoadMap && ! $ loadMap -> fetchData ( ) && $ record !== false ) { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ result = $ relatedObj -> _populate ( $ record , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelFromTableColumn ( $ attributeName , $ def [ 'model' ] , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelFromCustomRelationship ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'usesRefTable' ] ) ) { $ result = $ this -> _getModelFromRelationTable ( $ attributeName , $ def [ 'model' ] , $ query , $ loadMap ) ; } else { $ relatedObj = $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; if ( $ query && $ query -> isCustom ( ) ) { $ data = $ query -> fetch ( ) ; $ result = $ relatedObj -> _populate ( $ data ) ; } else { if ( ! isset ( $ this -> model_data [ $ attributeName ] ) ) { $ this -> model_data [ $ attributeName ] = $ this -> _fetchData ( $ attributeName ) ; } if ( ! is_object ( $ this -> model_data [ $ attributeName ] ) ) { $ relObjRepo = $ relatedObj -> getRepository ( true ) ; $ result = $ relObjRepo -> find ( $ this -> model_data [ $ attributeName ] ) ; } else { $ result = $ this -> model_data [ $ attributeName ] ; } if ( $ result ) { $ result -> _populate ( [ ] , false , $ loadMap ) ; } } } } return $ result ; }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
8073	public function post ( $ endpoint , $ data , $ headers = [ ] ) { $ request = new Request ( 'POST' , $ endpoint , $ headers , $ data ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
859	public function isAllTokenKindsFound ( array $ tokenKinds ) { foreach ( $ tokenKinds as $ tokenKind ) { if ( empty ( $ this -> foundTokenKinds [ $ tokenKind ] ) ) { return false ; } } return true ; }
488	public static function getInstances ( $ model , $ attribute ) { $ name = Html :: getInputName ( $ model , $ attribute ) ; return static :: getInstancesByName ( $ name ) ; }
7341	protected function assertDeletable ( ResourceInterface $ resource ) { if ( $ resource instanceof Model \ SupplierOrderItemInterface ) { if ( null === $ stockUnit = $ resource -> getStockUnit ( ) ) { return ; } if ( 0 < $ stockUnit -> getShippedQuantity ( ) ) { throw new Exception \ IllegalOperationException ( "Supplier delivery can't be removed as at least one " . "of its items is linked to a shipped stock unit." ) ; } } elseif ( $ resource instanceof Model \ SupplierOrderInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } elseif ( $ resource instanceof Model \ SupplierDeliveryItemInterface ) { $ this -> assertDeletable ( $ resource -> getOrderItem ( ) ) ; } elseif ( $ resource instanceof Model \ SupplierDeliveryInterface ) { foreach ( $ resource -> getItems ( ) as $ item ) { $ this -> assertDeletable ( $ item ) ; } } else { throw new Exception \ InvalidArgumentException ( "Unexpected resource." ) ; } }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
4803	public function renderRichText ( $ richText ) { if ( strlen ( $ richText ) < 1 ) { return '' ; } $ templatePath = $ this -> getTemplatePathAndFilename ( 'RichText' ) ; $ view = $ this -> createView ( $ templatePath ) ; $ view -> assign ( 'richText' , $ richText ) ; return $ view -> render ( $ templatePath ) ; }
6986	protected function createDefaultContext ( ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; return $ context ; }
5575	public function clickSubmitByName ( $ name , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByName ( $ name ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByName ( $ name ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
2423	public static function updateFolderHashes ( $ varResource ) { $ arrPaths = array ( ) ; if ( ! \ is_array ( $ varResource ) ) { $ varResource = array ( $ varResource ) ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ varResource as $ strResource ) { $ arrChunks = explode ( '/' , $ strResource ) ; $ strPath = array_shift ( $ arrChunks ) ; if ( is_file ( $ rootDir . '/' . $ strResource ) ) { array_pop ( $ arrChunks ) ; } while ( \ count ( $ arrChunks ) ) { $ strPath .= '/' . array_shift ( $ arrChunks ) ; $ arrPaths [ ] = $ strPath ; } unset ( $ arrChunks ) ; } $ arrPaths = array_values ( array_unique ( $ arrPaths ) ) ; foreach ( array_reverse ( $ arrPaths ) as $ strPath ) { $ objModel = FilesModel :: findByPath ( $ strPath ) ; if ( $ objModel === null ) { $ objModel = static :: addResource ( $ strPath , false ) ; } $ objModel -> hash = static :: getFolderHash ( $ strPath ) ; $ objModel -> save ( ) ; } }
7965	public function getVoiceConsumptions ( $ service , $ billingAccount , $ params = null ) { $ paramsString = "" ; if ( ! $ service ) throw new BadMethodCallException ( 'Parameter $service is missing.' ) ; if ( ! $ billingAccount ) throw new BadMethodCallException ( 'Parameter $billingAccount is missing.' ) ; if ( $ params != null && is_array ( $ params ) && count ( $ params ) > 0 ) { $ paramsString = "?" ; if ( array_key_exists ( 'creationDatetime.from' , $ params ) ) { $ string = $ params [ 'creationDatetime.from' ] ; if ( $ params [ 'creationDatetime.from' ] instanceof \ Datetime ) $ string = $ params [ 'creationDatetime.from' ] -> format ( "Y-m-d\TH:i:sP" ) ; $ paramsString .= "creationDatetime.from=" . urlencode ( $ string ) ; } if ( array_key_exists ( 'creationDatetime.to' , $ params ) ) { $ paramsString .= "&" ; $ string = $ params [ 'creationDatetime.to' ] ; if ( $ params [ 'creationDatetime.to' ] instanceof \ Datetime ) $ string = $ params [ 'creationDatetime.to' ] -> format ( "Y-m-d\TH:i:sP" ) ; $ paramsString .= "creationDatetime.to=" . urlencode ( $ string ) ; } if ( array_key_exists ( 'destinationType' , $ params ) && in_array ( $ params [ 'destinationType' ] , array ( 'landline' , 'mobile' , 'special' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "destinationType=" . $ params [ 'destinationType' ] ; } if ( array_key_exists ( 'planType' , $ params ) && in_array ( $ params [ 'planType' ] , array ( 'outplan' , 'priceplan' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "planType=" . $ params [ 'planType' ] ; } if ( array_key_exists ( 'wayType' , $ params ) && in_array ( $ params [ 'wayType' ] , array ( 'incoming' , 'outgoing' , 'transfer' ) ) ) { $ paramsString .= "&" ; $ paramsString .= "wayType=" . $ params [ 'wayType' ] ; } } try { $ r = $ this -> get ( 'telephony/' . $ billingAccount -> getBillingAccount ( ) . '/service/' . $ service . '/voiceConsumption' . $ paramsString ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new TelephonyAccountServiceException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
11090	public static function getGreeting ( $ time = null ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( \ is_string ( $ time ) ) { $ time = strtotime ( $ time ) ; } switch ( date ( 'G' , $ time ) ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : return self :: poorManTranslate ( 'fts-shared' , 'Good morning' ) ; case 8 : case 9 : case 10 : case 11 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good morning' ) , '_' ) ; case 12 : return self :: poorManTranslate ( 'fts-shared' , 'Good noon' ) ; case 13 : case 14 : case 15 : case 16 : return self :: poorManTranslate ( 'fts-shared' , 'Good afternoon' ) ; case 17 : case 18 : case 19 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good afternoon' ) , '_' ) ; case 20 : case 21 : case 22 : case 23 : return self :: poorManTranslate ( 'fts-shared' , 'Good evening' ) ; default : return '' ; } }
12371	public function addItem ( array $ item ) : self { if ( count ( $ item ) < 2 ) { throw new Exception ( 'Invalid count of item elements.' ) ; } $ this -> items [ ] = $ item ; return $ this ; }
10662	public function withoutParam ( $ paramName = null ) { $ object = clone $ this ; if ( is_null ( $ paramName ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] ) ; } else { if ( isset ( $ object -> configs [ $ this -> currentParamType ] ) ) { if ( ! is_array ( $ object -> configs [ $ this -> currentParamType ] ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] ) ; } else { if ( is_array ( $ paramName ) ) { $ paramName = [ $ paramName ] ; } foreach ( $ paramName as $ paramKey ) { if ( is_string ( $ paramKey ) || is_numeric ( $ paramKey ) ) { unset ( $ object -> configs [ $ this -> currentParamType ] [ $ paramName ] ) ; } } } } } return $ object -> buildConfigClient ( ) ; }
3965	protected function authenticateUser ( ) { if ( \ System :: getContainer ( ) -> get ( 'cca.dc-general.scope-matcher' ) -> currentScopeIsUnknown ( ) ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'contao/login' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'request' ) , 'install' ) !== false ) { return false ; } if ( strpos ( Environment :: get ( 'script' ) , 'system/bin' ) !== false ) { return false ; } $ authResult = $ this -> getUser ( ) -> authenticate ( ) ; return ( $ authResult === true || $ authResult === null ) ? true : false ; }
12973	public function setMappings ( $ mappingName , array $ mappingConfig = null ) { if ( is_array ( $ mappingName ) === false ) { $ mappingName = array ( $ mappingName => $ mappingConfig ) ; } \ Arr :: set ( $ this -> config [ 'mappings' ] , $ mappingName ) ; return $ this ; }
12564	public function sendVoice ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VOICE , $ message , $ to ) ; }
12085	public function store ( $ objectURI = null ) { $ this -> setPropertyValue ( "media_owner" , $ this -> user -> getPropertyValue ( "user_name_id" ) ) ; if ( ! $ this -> saveObject ( $ objectURI , $ this -> getObjectType ( ) ) ) { return false ; } return true ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
6085	public function retrieveMoodboard ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
2851	public function searchConfig ( $ query ) { $ configArray = array ( ) ; $ configArray = Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ this -> getConfig ( ) -> getNode ( ) , $ configArray ) ; $ results = array ( ) ; $ configKeys = array_keys ( $ configArray ) ; foreach ( $ configKeys as $ configKey ) { if ( strpos ( $ configKey , $ query ) !== FALSE ) { $ results [ $ configKey ] = $ configArray [ $ configKey ] ; } } return $ results ; }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
3477	public function withLocalizedTitle ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> title = '' ; $ cloned -> titleLocalized = $ localized ; return $ cloned ; }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
9914	public function create ( $ modelName , ModelConfig $ config = null ) { $ menu = new Menu ( ) ; $ addMenuItem = new LinkMenuItem ( ) ; $ addMenuItem -> setText ( Lang :: trans ( 'Add' ) ) ; $ addMenuItem -> setIcon ( Icons :: ion_plus ) ; $ addMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getCreateName ( $ modelName ) ) ) ; $ menu -> addMenuItem ( $ addMenuItem ) ; $ spacerMenuItem = new SpacerMenuItem ( ) ; $ spacerMenuItem -> setText ( Lang :: trans ( $ modelName ) ) ; $ menu -> addMenuItem ( $ spacerMenuItem ) ; $ resourceMenuItem = new ResourceMenuItem ( ) ; $ resourceMenuItem -> setTarget ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) ) ) ; $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; if ( $ this -> aujaConfigurator -> isSearchable ( $ model , $ config ) ) { $ target = urldecode ( URL :: route ( $ this -> aujaRouter -> getIndexName ( $ modelName ) , [ 'q' => '%s' ] ) ) ; $ property = new Searchable ( $ target ) ; $ resourceMenuItem -> addProperty ( $ property ) ; } $ menu -> addMenuItem ( $ resourceMenuItem ) ; return $ menu ; }
10164	private function readRangeProtection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ offset = 0 ; if ( ! $ this -> readDataOnly ) { $ offset += 12 ; $ isf = self :: getUInt2d ( $ recordData , 12 ) ; if ( $ isf != 2 ) { return ; } $ offset += 2 ; $ offset += 5 ; $ cref = self :: getUInt2d ( $ recordData , 19 ) ; $ offset += 2 ; $ offset += 6 ; $ cellRanges = [ ] ; for ( $ i = 0 ; $ i < $ cref ; ++ $ i ) { try { $ cellRange = $ this -> readBIFF8CellRangeAddressFixed ( substr ( $ recordData , 27 + 8 * $ i , 8 ) ) ; } catch ( PhpSpreadsheetException $ e ) { return ; } $ cellRanges [ ] = $ cellRange ; $ offset += 8 ; } $ rgbFeat = substr ( $ recordData , $ offset ) ; $ offset += 4 ; $ wPassword = self :: getInt4d ( $ recordData , $ offset ) ; $ offset += 4 ; if ( $ cellRanges ) { $ this -> phpSheet -> protectCells ( implode ( ' ' , $ cellRanges ) , strtoupper ( dechex ( $ wPassword ) ) , true ) ; } } }
8971	protected function fromJson ( $ json ) { $ data = json_decode ( $ json , true ) ; return new Rate ( $ data [ 'sourceName' ] , ( float ) $ data [ 'value' ] , $ data [ 'currencyCode' ] , $ data [ 'rateType' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'date' ] ) , $ data [ 'baseCurrencyCode' ] , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'createdAt' ] ) , \ DateTime :: createFromFormat ( \ DateTime :: ATOM , $ data [ 'modifiedAt' ] ) ) ; }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
8222	protected function getLimitFor ( $ actionName , $ blockType , $ entityId ) { $ limit = $ this -> storage -> getLimitFor ( $ actionName , $ blockType , $ entityId ) ; if ( $ limit === null ) { $ limit = array ( "ts" => 0 , "cnt" => 0 ) ; } return $ limit ; }
2170	private function setPassword ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_password' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'password.html.twig' ) ; } $ password = $ request -> request -> get ( 'password' ) ; $ confirmation = $ request -> request -> get ( 'confirmation' ) ; if ( $ password !== $ confirmation ) { return $ this -> render ( 'password.html.twig' , [ 'error' => $ this -> trans ( 'password_confirmation_mismatch' ) , ] ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ minlength = $ installTool -> getConfig ( 'minPasswordLength' ) ; if ( Utf8 :: strlen ( $ password ) < $ minlength ) { return $ this -> render ( 'password.html.twig' , [ 'error' => sprintf ( $ this -> trans ( 'password_too_short' ) , $ minlength ) , ] ) ; } $ installTool -> persistConfig ( 'installPassword' , password_hash ( $ password , PASSWORD_DEFAULT ) ) ; $ this -> container -> get ( 'contao.install_tool_user' ) -> setAuthenticated ( true ) ; return $ this -> getRedirectResponse ( ) ; }
11047	function get_value ( $ parent , $ varname ) { if ( isset ( $ parent -> $ varname ) ) { return $ parent -> $ varname ; } else { $ elements = explode ( '[' , $ varname ) ; if ( count ( $ elements ) == 1 ) { return NULL ; } else { $ vartest = $ parent ; foreach ( $ elements as $ elementid => $ element ) { if ( $ elementid == 0 ) { $ vartest = $ parent -> $ element ; if ( ! isset ( $ vartest ) ) { return NULL ; } } else { $ index = substr ( $ element , 0 , - 1 ) ; if ( $ index == '_first' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ 0 ] ; } elseif ( $ index == '_last' ) { $ keys = array_keys ( $ vartest ) ; $ index = $ keys [ count ( $ keys ) - 2 ] ; } if ( ! isset ( $ vartest [ $ index ] ) ) { return NULL ; } else { $ vartest = $ vartest [ $ index ] ; } } } } return $ vartest ; } }
4173	public function hasMigrationFile ( ) { $ this -> count = $ this -> fileHas ( '/class [A-Z]\w+ extends Migration/i' ) -> getClasses ( ) -> count ( ) ; return $ this -> hasMigrationFile = $ this -> count > 0 ; }
10670	protected static function _fromArray ( $ dom , $ node , & $ data , $ format ) { if ( $ data === null || $ data === '' || ! \ is_array ( $ data ) ) { return ; } foreach ( $ data as $ key => $ value ) { if ( \ is_string ( $ key ) ) { if ( ! \ is_array ( $ value ) ) { if ( \ is_bool ( $ value ) ) { $ value = ( int ) $ value ; } elseif ( $ value === null ) { $ value = '' ; } $ isNamespace = strpos ( $ key , 'xmlns:' ) ; if ( $ isNamespace !== false ) { $ node -> setAttributeNS ( 'http://www.w3.org/2000/xmlns/' , $ key , $ value ) ; continue ; } if ( $ key [ 0 ] !== '@' && $ format === 'tags' ) { $ child = null ; if ( ! is_numeric ( $ value ) ) { $ child = $ dom -> createElement ( $ key , '' ) ; $ child -> appendChild ( new \ DOMText ( $ value ) ) ; } else { $ child = $ dom -> createElement ( $ key , $ value ) ; } $ node -> appendChild ( $ child ) ; } else { if ( $ key [ 0 ] === '@' ) { $ key = substr ( $ key , 1 ) ; } $ attribute = $ dom -> createAttribute ( $ key ) ; $ attribute -> appendChild ( $ dom -> createTextNode ( $ value ) ) ; $ node -> appendChild ( $ attribute ) ; } } else { if ( $ key [ 0 ] === '@' ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } if ( array_keys ( $ value ) === range ( 0 , \ count ( $ value ) - 1 ) ) { foreach ( $ value as $ item ) { $ data = compact ( 'dom' , 'node' , 'key' , 'format' ) ; $ data [ 'value' ] = $ item ; self :: _createChild ( $ data ) ; } } else { self :: _createChild ( compact ( 'dom' , 'node' , 'key' , 'value' , 'format' ) ) ; } } } else { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid array' ) ) ; } } }
12176	public function addClassArgument ( $ name , $ class , $ required = true ) { return $ this -> addArgument ( new ClassArgument ( $ this -> argumentPosition ++ , $ name , $ class , $ required ) ) ; }
811	private function fixSpaceBelowClassElement ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { for ( $ nextNotWhite = $ elementEndIndex + 1 ; ; ++ $ nextNotWhite ) { if ( ( $ tokens [ $ nextNotWhite ] -> isComment ( ) || $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) && false === strpos ( $ tokens [ $ nextNotWhite ] -> getContent ( ) , "\n" ) ) { continue ; } break ; } if ( $ tokens [ $ nextNotWhite ] -> isWhitespace ( ) ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ nextNotWhite ) ; } $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
7668	function RFCDate ( ) { $ tz = date ( "Z" ) ; $ tzs = ( $ tz < 0 ) ? "-" : "+" ; $ tz = abs ( $ tz ) ; $ tz = ( $ tz / 3600 ) * 100 + ( $ tz % 3600 ) / 60 ; $ result = sprintf ( "%s %s%04d" , date ( "D, j M Y H:i:s" ) , $ tzs , $ tz ) ; return $ result ; }
5923	public function addPropertySet ( $ item ) { if ( ! ( $ item instanceof PropertySet ) ) { if ( is_array ( $ item ) ) { try { $ item = new PropertySet ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate PropertySet. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "PropertySet"!' , E_USER_WARNING ) ; } } $ this -> propertySets [ ] = $ item ; return $ this ; }
9793	public function hasDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for data validation when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> dataValidationExists ( $ this -> getCoordinate ( ) ) ; }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
12811	private static function getForeignKeysNames ( string $ table ) : array { if ( self :: $ foreignKeysCache === null || ! array_key_exists ( $ table , self :: $ foreignKeysCache ) ) self :: getForeignKeys ( $ table ) ; return array_keys ( self :: $ foreignKeysCache [ $ table ] ) ; }
6687	protected function mergeFlashMessages ( $ messageArray ) { $ messages = array_values ( $ messageArray ) ; $ flashMessage = '' ; $ flashMessageArr = [ ] ; foreach ( $ messages as $ message ) { if ( is_array ( $ message ) ) { if ( strlen ( $ flashMessage ) > 0 ) { $ flashMessage .= '<br/>' ; } $ flashMessage .= $ this -> mergeFlashMessages ( $ message ) ; } else { $ flashMessageArr [ ] = $ message ; } } return $ flashMessage . implode ( '<br/>' , $ flashMessageArr ) ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
4673	public function getTemplateFile ( $ template ) { $ file = $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } foreach ( $ this -> paths as $ path ) { $ file = $ path . "/" . $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } } throw new Exception ( "Could not find template file '$template'." ) ; }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
5124	private function castToArray ( $ input ) : array { $ result = array ( ) ; foreach ( $ input as $ key => $ value ) { $ result [ $ key ] = $ this -> castValue ( $ value ) ; } return $ result ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
4358	protected function processSubstitutions ( $ args , & $ hasSubs ) { $ subRegex = '/%' . '(?:' . '[coO]|' . '[+-]?' . '(?:[ 0]|\'.{1})?' . '-?' . '\d*' . '(?:\.\d+)?' . '[difs]' . ')' . '/' ; if ( ! \ is_string ( $ args [ 0 ] ) ) { return $ args ; } $ index = 0 ; $ indexes = array ( 'c' => array ( ) , ) ; $ hasSubs = false ; $ args [ 0 ] = \ preg_replace_callback ( $ subRegex , function ( $ matches ) use ( & $ args , & $ hasSubs , & $ index , & $ indexes ) { $ hasSubs = true ; $ index ++ ; $ replacement = $ matches [ 0 ] ; $ type = \ substr ( $ matches [ 0 ] , - 1 ) ; if ( \ strpos ( 'difs' , $ type ) !== false ) { $ format = $ matches [ 0 ] ; $ sub = $ args [ $ index ] ; if ( $ type == 'i' ) { $ format = \ substr_replace ( $ format , 'd' , - 1 , 1 ) ; } elseif ( $ type === 's' ) { $ sub = $ this -> substitutionAsString ( $ sub ) ; } $ replacement = \ sprintf ( $ format , $ sub ) ; } elseif ( $ type === 'c' ) { $ asHtml = \ get_called_class ( ) == __NAMESPACE__ . '\\Html' ; if ( ! $ asHtml ) { return '' ; } $ replacement = '' ; if ( $ indexes [ 'c' ] ) { $ replacement = '</span>' ; } $ replacement .= '<span' . $ this -> debug -> utilities -> buildAttribString ( array ( 'style' => $ args [ $ index ] , ) ) . '>' ; $ indexes [ 'c' ] [ ] = $ index ; } elseif ( \ strpos ( 'oO' , $ type ) !== false ) { $ replacement = $ this -> dump ( $ args [ $ index ] ) ; } return $ replacement ; } , $ args [ 0 ] ) ; if ( $ indexes [ 'c' ] ) { $ args [ 0 ] .= '</span>' ; } if ( $ hasSubs ) { $ args = array ( $ args [ 0 ] ) ; } return $ args ; }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
8916	public function parseSubjectAddedEntry ( QuiteSimpleXmlElement & $ node ) { $ out = array ( 'term' => '' , 'vocabulary' => null ) ; $ vocabularies = array ( '0' => 'lcsh' , '1' => 'lccsh' , '2' => 'mesh' , '3' => 'atg' , '5' => 'cash' , '6' => 'rvm' , ) ; $ ind2 = $ node -> attr ( 'ind2' ) ; $ id = $ node -> text ( 'marc:subfield[@code="0"]' ) ; $ out [ 'id' ] = empty ( $ id ) ? null : $ id ; if ( isset ( $ vocabularies [ $ ind2 ] ) ) { $ out [ 'vocabulary' ] = $ vocabularies [ $ ind2 ] ; } elseif ( $ ind2 == '7' ) { $ vocab = $ node -> text ( 'marc:subfield[@code="2"]' ) ; if ( ! empty ( $ vocab ) ) { $ out [ 'vocabulary' ] = $ vocab ; } } elseif ( $ ind2 == '4' ) { $ this -> parseAuthority ( $ node -> text ( 'marc:subfield[@code="0"]' ) , $ out ) ; } $ out [ 'parts' ] = array ( ) ; $ subdivtypes = array ( 'v' => 'form' , 'x' => 'general' , 'y' => 'chronologic' , 'z' => 'geographic' , ) ; foreach ( $ node -> all ( 'marc:subfield' ) as $ subdiv ) { $ code = $ subdiv -> attr ( 'code' ) ; if ( in_array ( $ code , array_keys ( $ subdivtypes ) ) ) { $ subdiv = trim ( $ subdiv , '.' ) ; $ out [ 'parts' ] [ ] = array ( 'value' => $ subdiv , 'type' => $ subdivtypes [ $ code ] ) ; $ out [ 'term' ] .= self :: $ subfieldSeparator . $ subdiv ; } } return $ out ; }
12527	public function getDataSources ( ) { if ( is_null ( $ this -> _dataSources ) ) { $ this -> _dataSources = [ ] ; foreach ( $ this -> dataSources ( ) as $ foreignModel => $ dataSource ) { if ( is_numeric ( $ foreignModel ) || isset ( $ dataSources [ 'foreignModel' ] ) ) { if ( ! isset ( $ dataSources [ 'foreignModel' ] ) ) { continue ; } $ foreignModel = $ dataSources [ 'foreignModel' ] ; unset ( $ dataSources [ 'foreignModel' ] ) ; } if ( ! isset ( $ dataSource [ 'class' ] ) ) { $ dataSource [ 'class' ] = $ this -> dataSourceClass ; } $ dataSource [ 'name' ] = $ foreignModel ; $ dataSource [ 'foreignModel' ] = $ this -> getForeignModel ( $ foreignModel ) ; if ( empty ( $ dataSource [ 'foreignModel' ] ) ) { continue ; } $ this -> _dataSources [ $ foreignModel ] = Yii :: createObject ( array_merge ( [ 'module' => $ this ] , $ dataSource ) ) ; } } return $ this -> _dataSources ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
8748	public function addMethodCall ( $ methodName , array $ arguments = array ( ) ) { $ this -> actions [ ] = $ methodCall = new MethodCall ( $ methodName , $ arguments ) ; return $ methodCall ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
9724	public function getFilename ( $ filename , $ extension = 'xlsx' ) { $ originalExtension = pathinfo ( $ filename , PATHINFO_EXTENSION ) ; return $ this -> getTemporaryFolder ( ) . '/' . str_replace ( '.' . $ originalExtension , '.' . $ extension , basename ( $ filename ) ) ; }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
8801	public function set ( $ key , $ value ) { if ( is_array ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ _SESSION [ $ k ] = $ v ; } } else { $ _SESSION [ $ key ] = $ value ; } return ; }
3013	public function like ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/like' , $ options , false ) ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
4799	function exec ( $ query ) { $ conn = $ this -> getConn ( ) ; $ sql = $ conn -> quote ( $ query ) ; return $ conn -> exec ( $ sql ) ; }
5945	public function freetext ( $ freetext , $ deploymentSiteIds = null , $ mode = self :: FREETEXT_OR , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'mode' => $ mode , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/freetext/' . $ freetext . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
11667	private function addDefaultFunction ( ) { $ this -> addFunction ( 'app' , function ( ) { return app ( ) ; } ) ; $ this -> addFunction ( 'url' , function ( $ url , $ absolute = false , array $ params = array ( ) ) { if ( $ absolute ) { return Url :: createAbsolute ( $ url , $ params ) ; } else { return Url :: create ( $ url , $ params ) ; } } ) ; $ this -> addFunction ( 'assets' , function ( $ path ) { return Url :: createAbsolute ( $ path ) ; } ) ; }
11384	protected function resolve ( ) { if ( $ this -> resolved ) { return ; } $ this -> resolved = [ ] ; foreach ( $ this -> stages as $ stage ) { $ this -> resolved [ ] = $ this -> build ( $ stage ) ; } }
10529	protected function normalizeProxyHeader ( $ header ) { $ header = strtoupper ( $ header ) ; $ header = str_replace ( '-' , '_' , $ header ) ; if ( 0 !== strpos ( $ header , 'HTTP_' ) ) { $ header = 'HTTP_' . $ header ; } return $ header ; }
2888	public function onBlockToHtml ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ block = $ observer -> getData ( 'block' ) ; if ( $ block -> getNameInLayout ( ) == 'debug_panels' ) { $ this -> updateProfiling ( ) ; } if ( ! $ this -> canCaptureBlock ( $ block ) ) { return ; } $ blockName = Mage :: helper ( 'sheep_debug' ) -> getBlockName ( $ block ) ; $ requestInfo = $ this -> getRequestInfo ( ) ; try { $ blockInfo = $ requestInfo -> getBlock ( $ blockName ) ; } catch ( Exception $ e ) { $ blockInfo = $ requestInfo -> addBlock ( $ block ) ; } $ blockInfo -> startRendering ( $ block ) ; }
7485	public function charAt ( $ index ) { $ index = ( int ) $ index ; if ( $ index < 0 || $ index >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_substr ( $ this -> string , $ index , 1 , $ this -> encoding ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
52	public function setOutputProgress ( $ outputProgress ) { foreach ( $ this -> downloaders as $ downloader ) { $ downloader -> setOutputProgress ( $ outputProgress ) ; } return $ this ; }
8905	function dropdown ( ) { $ args = func_get_args ( ) ; if ( count ( $ args ) == 2 ) { list ( $ key , $ value ) = $ args ; } else { $ key = $ this -> primary_key ; $ value = $ args [ 0 ] ; } $ this -> trigger ( 'before_dropdown' , array ( $ key , $ value ) ) ; $ this -> apply_soft_delete_filter ( ) ; $ result = $ this -> _database -> select ( array ( $ key , $ value ) ) -> get ( $ this -> _table ) -> result ( ) ; $ options = array ( ) ; foreach ( $ result as $ row ) { $ options [ $ row -> { $ key } ] = $ row -> { $ value } ; } $ options = $ this -> trigger ( 'after_dropdown' , $ options ) ; return $ options ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
6694	public static function applyActive ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( isset ( $ one [ 'items' ] ) ) { self :: applyActive ( $ one [ 'items' ] ) ; } if ( ! isset ( $ one [ 'active' ] ) ) { if ( is_array ( $ one [ 'url' ] ) ) { $ url = $ one [ 'url' ] [ 0 ] ; $ route = Yii :: $ app -> requestedRoute ; $ params = Yii :: $ app -> request -> getQueryParams ( ) ; if ( $ url === '/' && $ route === Yii :: $ app -> controller -> module -> id . '/dashboard/index' ) { $ one [ 'active' ] = true ; } else { $ url = $ one [ 'url' ] ; $ urlExploded = explode ( '/' , $ url [ 0 ] ) ; $ one [ 'submenuTemplate' ] = '' ; foreach ( self :: $ active as $ activeAction ) { $ urlExploded [ count ( $ urlExploded ) - 1 ] = $ activeAction ; $ url [ 0 ] = implode ( '/' , $ urlExploded ) ; $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - ' . $ activeAction , 'url' => $ url , 'options' => [ 'class' => 'hidden' ] ] ; if ( '/' . Yii :: $ app -> request -> getQueryParam ( 'parentRoute' ) === trim ( $ url [ 0 ] ) ) { $ one [ 'items' ] [ ] = [ 'label' => $ one [ 'label' ] . ' - Sub List' , 'url' => array_merge ( [ '/' . $ route ] , $ params ) , 'options' => [ 'class' => 'hidden' ] ] ; } } } } } } } }
3916	protected function sortByIdList ( $ sortIds ) { $ fileMap = $ this -> foundFiles ; if ( ! $ fileMap ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ fileKeys = array_flip ( array_keys ( $ this -> uuidMap ) ) ; $ sorted = array ( ) ; foreach ( $ sortIds as $ sortStringId ) { $ key = $ fileKeys [ $ sortStringId ] ; $ sorted [ $ key ] = $ fileMap [ $ key ] ; unset ( $ fileMap [ $ key ] ) ; } $ sorted += $ fileMap ; return $ this -> remapSorting ( $ sorted , $ this -> outputBuffer ) ; }
3141	public function move ( RunnerServiceContext $ context , $ direction , $ scope , $ ref ) { $ result = true ; if ( $ context instanceof QtiRunnerServiceContext ) { try { $ result = QtiRunnerNavigation :: move ( $ direction , $ scope , $ context , $ ref ) ; if ( $ result ) { $ this -> continueInteraction ( $ context ) ; } } catch ( AssessmentTestSessionException $ e ) { switch ( $ e -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : $ this -> onTimeout ( $ context , $ e ) ; break ; } } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'move' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return $ result ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
4479	public function tag ( ... $ tags ) : void { $ response = call_user_func_array ( [ $ this -> client , 'call' ] , array_merge ( [ 'tag' , 'add' , $ this -> jid ] , array_values ( func_get_args ( ) ) ) ) ; $ this -> setTags ( json_decode ( $ response , true ) ) ; }
11910	public function getDefaultParams ( ) { $ defaultParams = [ ] ; foreach ( $ this -> parameters as $ parameter ) { if ( $ parameter -> hasDefault ( ) ) { if ( $ parameter -> getIsAPIParameter ( ) == false ) { $ defaultParams [ ] = $ parameter ; } } } return $ defaultParams ; }
2854	public function getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ updateFiles = Mage :: helper ( 'sheep_debug' ) -> getLayoutUpdatesFiles ( $ storeId , $ area ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ designPackageName = $ designPackage -> getPackageName ( ) ; $ layoutTheme = $ designPackage -> getTheme ( 'layout' ) ; $ handleFiles = array ( ) ; foreach ( $ updateFiles as $ file ) { $ filename = $ designPackage -> getLayoutFilename ( $ file , array ( '_area' => $ area , '_package' => $ designPackageName , '_theme' => $ layoutTheme ) ) ; if ( ! is_readable ( $ filename ) ) { continue ; } $ fileXml = $ this -> loadXmlFile ( $ filename ) ; if ( $ fileXml === false ) { continue ; } $ relativeFilename = str_replace ( $ this -> getBaseDir ( ) , '' , $ filename ) ; $ results = $ fileXml -> xpath ( "/layout/{$handle}" ) ; if ( $ results ) { $ handleFiles [ $ relativeFilename ] = array ( ) ; foreach ( $ results as $ result ) { $ handleFiles [ $ relativeFilename ] [ ] = $ result -> asXML ( ) ; } } } return $ handleFiles ; }
5797	public static function getRouteName ( bool $ isAdmin = true , string $ routePrefix = null , string $ routeType = null , string $ requestMethod = null ) : string { $ routeName = '' ; if ( $ isAdmin ) { $ routeName .= ROUTEPREFIX_ADMIN ; } if ( $ routePrefix !== null ) { $ routeName .= '.' . $ routePrefix ; } if ( $ requestMethod !== null ) { $ validActionMethods = [ 'put' , 'post' ] ; if ( ! in_array ( $ requestMethod , $ validActionMethods ) ) { throw new \ Exception ( "Invalid request method $requestMethod. Only post and put accepted in route names." ) ; } $ routeName .= '.' . $ requestMethod ; } if ( $ routeType !== null ) { if ( ! in_array ( $ routeType , self :: VALID_ROUTE_TYPES ) ) { throw new \ Exception ( "Invalid route type $routeType" ) ; } $ routeName .= '.' . $ routeType ; } return $ routeName ; }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
8685	public static function set ( & $ data , $ path , $ value ) { Assert :: isArrayAccessible ( $ data ) ; Assert :: stringNotEmpty ( $ path ) ; $ queue = explode ( '/' , $ path ) ; if ( count ( $ queue ) === 1 ) { if ( $ path === '[]' ) { $ data [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ data [ $ path ] ) ; } else { $ data [ $ path ] = $ value ; } return ; } $ invalidKey = null ; $ current = & $ data ; while ( ( $ key = array_shift ( $ queue ) ) !== null ) { if ( ! is_array ( $ current ) && ! ( $ current instanceof ArrayAccess ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is already set and not an array or an object implementing ArrayAccess." , $ path , $ invalidKey ) ) ; } if ( ! $ queue ) { if ( $ key === '[]' ) { $ current [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ current [ $ key ] ) ; } else { $ current [ $ key ] = $ value ; } return ; } if ( $ current instanceof Bag && ! ( $ current instanceof MutableBag ) ) { Deprecated :: warn ( 'Mutating items in a ' . Bag :: class , 1.1 , 'Use a ' . MutableBag :: class . ' instead.' ) ; } if ( ! isset ( $ current [ $ key ] ) ) { $ current [ $ key ] = [ ] ; } $ next = null ; if ( $ current instanceof ArrayAccess && ! static :: canReturnArraysByReference ( $ current , $ key , $ next , $ e ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is an %s which does not return arrays by reference from its offsetGet() method. See %s for an example of how to do this." , $ path , $ invalidKey , get_class ( $ current ) , MutableBag :: class ) , 0 , $ e ) ; } if ( $ next !== null ) { $ current = & $ next ; unset ( $ next ) ; } else { $ current = & $ current [ $ key ] ; } $ invalidKey = $ key ; } }
12557	private static function init ( ) : void { static $ inited = false ; if ( ! $ inited ) { if ( ! isset ( $ _SESSION [ 'Booby' ] ) || ! $ _SESSION [ 'Booby' ] ) { $ _SESSION [ 'Booby' ] = [ ] ; } self :: $ store = & $ _SESSION [ 'Booby' ] ; $ inited = true ; } }
12366	public function getNextVideoToConvert ( ) { $ query = $ this -> createQueryBuilder ( 'v' ) ; $ this -> onlyUploaded ( $ query ) ; return $ query -> getQuery ( ) -> getOneOrNullResult ( ) ; }
9810	private function readClientAnchor ( ) { $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ c1 = Xls :: getUInt2d ( $ recordData , 2 ) ; $ startOffsetX = Xls :: getUInt2d ( $ recordData , 4 ) ; $ r1 = Xls :: getUInt2d ( $ recordData , 6 ) ; $ startOffsetY = Xls :: getUInt2d ( $ recordData , 8 ) ; $ c2 = Xls :: getUInt2d ( $ recordData , 10 ) ; $ endOffsetX = Xls :: getUInt2d ( $ recordData , 12 ) ; $ r2 = Xls :: getUInt2d ( $ recordData , 14 ) ; $ endOffsetY = Xls :: getUInt2d ( $ recordData , 16 ) ; $ this -> object -> setStartCoordinates ( Coordinate :: stringFromColumnIndex ( $ c1 + 1 ) . ( $ r1 + 1 ) ) ; $ this -> object -> setStartOffsetX ( $ startOffsetX ) ; $ this -> object -> setStartOffsetY ( $ startOffsetY ) ; $ this -> object -> setEndCoordinates ( Coordinate :: stringFromColumnIndex ( $ c2 + 1 ) . ( $ r2 + 1 ) ) ; $ this -> object -> setEndOffsetX ( $ endOffsetX ) ; $ this -> object -> setEndOffsetY ( $ endOffsetY ) ; }
9620	protected function httpPost ( $ host , $ path , array $ data , $ port = 80 ) { $ req = $ this -> qsencode ( $ data ) ; $ http_request = "POST {$path} HTTP/1.0\r\n" ; $ http_request .= "Host: {$host}\r\n" ; $ http_request .= "Content-Type: application/x-www-form-urlencoded;\r\n" ; $ http_request .= "Content-Length: " . strlen ( $ req ) . "\r\n" ; $ http_request .= "User-Agent: reCAPTCHA/PHP\r\n" ; $ http_request .= "\r\n" ; $ http_request .= $ req ; $ response = '' ; if ( false == ( $ fs = @ fsockopen ( $ host , ( int ) $ port , $ errno , $ errstr , 10 ) ) ) { throw new \ Exception ( 'Could not open socket' ) ; } fwrite ( $ fs , $ http_request ) ; while ( ! feof ( $ fs ) ) { $ response .= fgets ( $ fs , 1160 ) ; } fclose ( $ fs ) ; $ response = explode ( "\r\n\r\n" , $ response , 2 ) ; return $ response ; }
7882	public function getIndex ( ) { $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; if ( Session :: has ( 'success' ) || Session :: has ( 'error' ) ) { Session :: reflash ( ) ; } return Redirect :: to ( 'logviewer/' . $ today . '/all' ) ; }
12721	public function isShared ( $ abstract ) { if ( ! isset ( $ this -> bindings [ $ abstract ] ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: invalidArgument ( sprintf ( "Parameter 1 of %s must be valid keys in binding container stack." , __METHOD__ ) ) ; } return ( $ this -> bindings [ $ abstract ] [ 'shared' ] ? true : false ) ; }
8426	public function getAllInactiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) , $ qb -> expr ( ) -> lt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , false ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> addOrderBy ( 'p.updated' , 'DESC' ) -> getQuery ( ) ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
11865	public function get ( string $ sessionIdentifier ) : string { if ( ! $ this -> sessionExists ( $ sessionIdentifier ) ) { throw new SessionNotFoundException ( ) ; } return self :: $ files [ $ sessionIdentifier ] [ 'data' ] ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
12059	public function setTarget ( $ value ) { if ( in_array ( $ value , $ this -> possibleTargets ) ) { $ this -> _target = $ value ; } else { throw new Exception ( 'Unknown deletion target ' . $ value ) ; } }
6111	public function fileDelete ( $ cpw = "" , $ name = "/" ) { return $ this -> getParent ( ) -> channelFileDelete ( $ this -> getId ( ) , $ cpw , $ name ) ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
1680	public function handleUserProfile ( Contao \ DataContainer $ dc ) { if ( Contao \ Input :: get ( 'do' ) != 'login' ) { return ; } if ( Contao \ BackendUser :: getInstance ( ) -> id != Contao \ Input :: get ( 'id' ) || Contao \ Input :: get ( 'act' ) != 'edit' ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not allowed to edit this page.' ) ; } $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'closed' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'hideVersionMenu' ] = true ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = array ( '__selector__' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ '__selector__' ] , 'default' => $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'login' ] ) ; $ arrFields = Contao \ StringUtil :: trimsplit ( '[,;]' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] [ 'default' ] ) ; foreach ( $ arrFields as $ strField ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ strField ] [ 'exclude' ] = false ; } }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
8668	public function setSelf ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Self' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
9503	public function joinCommand ( array $ parts ) { $ command = 'php ' . implode ( ' ' , $ parts ) ; $ stripped = str_replace ( '--watch' , '' , $ command ) ; return trim ( $ stripped ) ; }
2081	public function purgeOptInTokens ( ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optIn -> purgeTokens ( ) ; $ this -> log ( 'Purged the expired double opt-in tokens' , __METHOD__ , TL_CRON ) ; }
1738	public function generate ( ) { if ( $ this -> singleSRC == '' ) { return '' ; } $ objFile = FilesModel :: findByUuid ( $ this -> singleSRC ) ; if ( $ objFile === null ) { return '' ; } $ allowedDownload = StringUtil :: trimsplit ( ',' , strtolower ( Config :: get ( 'allowedDownload' ) ) ) ; if ( ! \ in_array ( $ objFile -> extension , $ allowedDownload ) ) { return '' ; } $ file = Input :: get ( 'file' , true ) ; if ( $ file && ( ! isset ( $ _GET [ 'cid' ] ) || Input :: get ( 'cid' ) == $ this -> id ) ) { if ( $ file == $ objFile -> path ) { Controller :: sendFileToBrowser ( $ file , ( bool ) $ this -> inline ) ; } if ( isset ( $ _GET [ 'cid' ] ) ) { throw new PageNotFoundException ( 'Invalid file name' ) ; } } $ this -> objFile = $ objFile ; $ this -> singleSRC = $ objFile -> path ; return parent :: generate ( ) ; }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
8951	public function getCapabilities ( ) { $ base = 'capabilities' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , array ( ) ) ; return simplexml_load_string ( $ response -> body ) ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
2160	public function run32Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` CHANGE `sections` `sections` varchar(1022) NOT NULL default ''" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strSections = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { $ strSections = implode ( ', ' , $ tmp ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET sections=? WHERE id=?" ) -> execute ( $ strSections , $ objLayout -> id ) ; } if ( ! $ this -> Database -> fieldExists ( 'uuid' , 'tl_files' ) ) { $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `uuid` binary(16) NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD UNIQUE KEY `uuid` (`uuid`)" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` ADD `pid_backup` int(10) unsigned NOT NULL default 0" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid_backup`=`pid`" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_files` CHANGE `pid` `pid` binary(16) NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_files` SET `pid`=NULL WHERE `pid_backup`=0" ) ; $ objFiles = $ this -> Database -> query ( "SELECT id FROM tl_files" ) ; while ( $ objFiles -> next ( ) ) { $ this -> Database -> prepare ( "UPDATE tl_files SET uuid=? WHERE id=?" ) -> execute ( $ this -> Database -> getUuid ( ) , $ objFiles -> id ) ; } $ objFiles = $ this -> Database -> query ( "SELECT pid_backup FROM tl_files WHERE pid_backup>0 GROUP BY pid_backup" ) ; while ( $ objFiles -> next ( ) ) { $ objParent = $ this -> Database -> prepare ( "SELECT uuid FROM tl_files WHERE id=?" ) -> execute ( $ objFiles -> pid_backup ) ; if ( $ objParent -> numRows < 1 ) { throw new \ Exception ( 'Invalid parent ID ' . $ objFiles -> pid_backup ) ; } $ this -> Database -> prepare ( "UPDATE tl_files SET pid=? WHERE pid_backup=?" ) -> execute ( $ objParent -> uuid , $ objFiles -> pid_backup ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_files` DROP `pid_backup`" ) ; } $ this -> updateFileTreeFields ( ) ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
3915	protected function sortByDate ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; $ arrDates = $ this -> modifiedTime ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } if ( $ blnAscending ) { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_ASC ) ; } else { array_multisort ( $ arrFiles , SORT_NUMERIC , $ arrDates , SORT_DESC ) ; } return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
11444	public function setTransporter ( TransportInterface $ transporter ) { if ( $ transporter -> validate ( ) ) { $ this -> transporter = $ transporter ; } else { throw new \ Exception ( sprintf ( 'Transporter "%s" is not valid for current environment!' , get_class ( $ transporter ) ) ) ; } return $ this ; }
12576	public function previewTextByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
6425	public function getLoginStartUrl ( $ redirecturl ) { $ client = $ this -> getClient ( $ redirecturl ) ; $ authUrl = $ client -> createAuthUrl ( ) ; return $ authUrl ; }
4810	private function is_scheduled ( $ name ) { $ crons = _get_cron_array ( ) ; if ( empty ( $ crons ) ) { return false ; } foreach ( $ crons as $ cron ) { if ( isset ( $ cron [ $ name ] ) ) { return true ; } } return false ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
8555	public function setAdjustmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
6643	public static function decodeId ( $ hash , $ salt , $ hashLength = self :: MIN_HASH_LENGTH ) { $ hashIds = new Hashids ( $ salt , $ hashLength ) ; return ArrayHelper :: getValue ( $ hashIds -> decode ( $ hash ) , '0' ) ; }
8979	protected function initialize ( ) { if ( $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ this -> tableName ] ) ) { return ; } $ schema = new Schema ( ) ; $ table = $ schema -> createTable ( $ this -> tableName ) ; $ table -> addColumn ( 'source_name' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_value' , 'float' , [ 'precision' => 10 , 'scale' => 4 ] ) ; $ table -> addColumn ( 'currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'rate_type' , 'string' , [ 'length' => 255 ] ) ; $ table -> addColumn ( 'rate_date' , 'date' , [ ] ) ; $ table -> addColumn ( 'base_currency_code' , 'string' , [ 'length' => 3 ] ) ; $ table -> addColumn ( 'created_at' , 'datetime' , [ ] ) ; $ table -> addColumn ( 'modified_at' , 'datetime' , [ ] ) ; $ table -> setPrimaryKey ( [ 'currency_code' , 'rate_date' , 'rate_type' , 'source_name' ] ) ; $ this -> connection -> exec ( $ schema -> toSql ( $ this -> connection -> getDatabasePlatform ( ) ) [ 0 ] ) ; }
3085	public function getAssessmentItemRefsByPlaceholder ( \ tao_models_classes_service_StorageDirectory $ privateCompilationDirectory , AssessmentItemRef $ placeholder ) { $ urlinfo = parse_url ( $ placeholder -> getHref ( ) ) ; $ adaptiveSectionId = ltrim ( $ urlinfo [ 'path' ] , '/' ) ; $ compilationDataService = $ this -> getServiceLocator ( ) -> get ( CompilationDataService :: SERVICE_ID ) ; $ filename = "adaptive-assessment-section-${adaptiveSectionId}" ; $ component = $ compilationDataService -> readPhpCompilationData ( $ privateCompilationDirectory , "${filename}.php" , $ filename ) ; return $ component -> getComponentsByClassName ( 'assessmentItemRef' ) -> getArrayCopy ( ) ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
12611	public function getChecked ( ) { if ( is_null ( $ this -> object ) || ! $ this -> object ) { return false ; } if ( is_null ( $ this -> _checked ) ) { $ this -> _checked = true ; foreach ( $ this -> object -> dependencies ( ) as $ dep ) { if ( ! $ this -> collector -> has ( $ dep , false ) ) { $ this -> _checked = false ; } } } return $ this -> _checked ; }
11055	public function getBundle ( $ name , $ publish = true ) { if ( $ this -> bundles === false ) { return $ this -> loadDummyBundle ( $ name ) ; } elseif ( ! isset ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , [ ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] instanceof AssetBundle ) { return $ this -> bundles [ $ name ] ; } elseif ( is_array ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , $ this -> bundles [ $ name ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] === false ) { return $ this -> loadDummyBundle ( $ name ) ; } else { throw new InvalidConfigException ( "Invalid asset bundle configuration: $name" ) ; } }
7629	public function setContainerAcl ( $ containerName = '' , $ acl = self :: ACL_PRIVATE , $ signedIdentifiers = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ headers = array ( ) ; if ( $ acl != self :: ACL_PRIVATE && ! is_null ( $ acl ) && $ acl != '' ) { $ headers [ Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ] = $ acl ; } $ policies = null ; if ( is_array ( $ signedIdentifiers ) && count ( $ signedIdentifiers ) > 0 ) { $ policies = '' ; $ policies .= '<?xml version="1.0" encoding="utf-8"?>' . "\r\n" ; $ policies .= '<SignedIdentifiers>' . "\r\n" ; foreach ( $ signedIdentifiers as $ signedIdentifier ) { $ policies .= ' <SignedIdentifier>' . "\r\n" ; $ policies .= ' <Id>' . $ signedIdentifier -> Id . '</Id>' . "\r\n" ; $ policies .= ' <AccessPolicy>' . "\r\n" ; if ( $ signedIdentifier -> Start != '' ) $ policies .= ' <Start>' . $ signedIdentifier -> Start . '</Start>' . "\r\n" ; if ( $ signedIdentifier -> Expiry != '' ) $ policies .= ' <Expiry>' . $ signedIdentifier -> Expiry . '</Expiry>' . "\r\n" ; if ( $ signedIdentifier -> Permissions != '' ) $ policies .= ' <Permission>' . $ signedIdentifier -> Permissions . '</Permission>' . "\r\n" ; $ policies .= ' </AccessPolicy>' . "\r\n" ; $ policies .= ' </SignedIdentifier>' . "\r\n" ; } $ policies .= '</SignedIdentifiers>' . "\r\n" ; } $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'PUT' , $ headers , false , $ policies , self :: RESOURCE_CONTAINER , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
7234	protected function assertItemClass ( Common \ SaleItemInterface $ child ) { if ( ! $ child instanceof Model \ CartItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemInterface :: class ) ; } }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
1767	private function getRelativeRequestUri ( Request $ request ) : string { return ( string ) substr ( $ request -> getRequestUri ( ) , \ strlen ( $ request -> getBasePath ( ) ) + 1 ) ; }
8833	public function generateFromPattern ( $ pattern , $ amount = 1 , $ safeguard = 100 ) { $ lexer = new \ Gajus \ Paggern \ Lexer ( ) ; $ tokens = $ lexer -> tokenise ( $ pattern , true ) ; $ codes = array_fill ( 0 , $ amount + $ safeguard , '' ) ; foreach ( $ tokens as & $ token ) { if ( $ token [ 'type' ] !== 'literal' ) { $ token [ 'pool' ] = $ this -> generator -> generateString ( $ token [ 'repetition' ] * ( $ amount + $ safeguard ) , $ token [ 'haystack' ] ) ; } unset ( $ token ) ; } foreach ( $ codes as $ i => & $ code ) { foreach ( $ tokens as $ token ) { if ( $ token [ 'type' ] === 'literal' ) { $ code .= $ token [ 'string' ] ; } else { $ code .= mb_substr ( $ token [ 'pool' ] , $ token [ 'repetition' ] * $ i , $ token [ 'repetition' ] ) ; } } unset ( $ code ) ; } $ codes = array_slice ( array_unique ( $ codes ) , 0 , $ amount ) ; if ( count ( $ codes ) < $ amount ) { throw new Exception \ RuntimeException ( 'Unique combination pool exhausted.' ) ; } return $ codes ; }
7589	protected function configureType ( ) { switch ( $ this -> type ) { case 'POST' : $ this -> setOption ( CURLOPT_POST , true ) ; break ; case 'DELETE' : case 'PUT' : $ this -> setOption ( CURLOPT_CUSTOMREQUEST , $ this -> type ) ; break ; } }
1406	protected function getDefaultAttributes ( Model $ model ) { $ defaults = [ ] ; if ( $ this -> hasCreatedAtAttribute ( $ model ) ) { $ createdAt = $ model -> getCreatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ createdAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ createdAt , $ field ) ; } if ( $ this -> hasUpdatedAtAttribute ( $ model ) ) { $ updatedAt = $ model -> getUpdatedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ updatedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ updatedAt , $ field ) ; } if ( $ this -> hasDeletedAtAttribute ( $ model ) ) { $ deletedAt = $ model -> getDeletedAtColumn ( ) ; $ field = $ this -> fieldForAttribute ( $ deletedAt ) ; $ defaults [ $ field ] = $ this -> extractAttribute ( $ model , $ deletedAt , $ field ) ; } return $ defaults ; }
1246	public static function env ( ) { return function ( ) { $ appId = getenv ( self :: ENV_APP_ID ) ; $ certId = getenv ( self :: ENV_CERT_ID ) ; $ devId = getenv ( self :: ENV_DEV_ID ) ; if ( $ appId && $ certId && $ devId ) { return new Credentials ( $ appId , $ certId , $ devId ) ; } else { return new \ InvalidArgumentException ( 'Could not find environment variable ' . 'credentials in ' . self :: ENV_APP_ID . '/' . self :: ENV_CERT_ID . '/' . self :: ENV_DEV_ID ) ; } } ; }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
9956	public function protectCells ( $ pRange , $ pPassword , $ pAlreadyHashed = false ) { $ pRange = strtoupper ( $ pRange ) ; if ( ! $ pAlreadyHashed ) { $ pPassword = Shared \ PasswordHasher :: hashPassword ( $ pPassword ) ; } $ this -> protectedCells [ $ pRange ] = $ pPassword ; return $ this ; }
5503	protected function addCall ( $ method , $ args ) { if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { $ this -> call_counts [ $ method ] = 0 ; } $ this -> call_counts [ $ method ] ++ ; }
2828	public function getOptionArray ( array $ data ) { $ options = array ( ) ; foreach ( $ data as $ value ) { $ options [ ] = array ( 'value' => $ value , 'label' => $ value ) ; } return $ options ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
4448	public function put ( string $ className , array $ data , ? string $ jid = null , ? int $ delay = null , ? int $ retries = null , ? int $ priority = null , ? array $ tags = null , ? array $ depends = null ) { try { $ jid = $ jid ? : str_replace ( '-' , '' , Uuid :: uuid4 ( ) -> toString ( ) ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = new JobData ( $ data ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ BeforeEnqueue ( $ this , $ jid , $ data , $ className ) ) ; if ( ! $ putData = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to put the described job "%s" to the "%s" queue.' , $ jid , $ this -> name ) ) ; } $ jid = $ this -> client -> put ( '' , $ this -> name , $ jid , $ className , $ putData , is_null ( $ delay ) ? 0 : $ delay , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'depends' , json_encode ( $ depends ? : [ ] , JSON_UNESCAPED_SLASHES ) ) ; $ this -> getEventsManager ( ) -> fire ( new QueueEvent \ AfterEnqueue ( $ this , $ jid , $ data -> toArray ( ) , $ className ) ) ; return $ jid ; }
11385	public static function signUrlForGoogle ( string $ sUrlToSign , string $ sClientId , string $ sPrivateKey ) : string { $ aUrl = parse_url ( $ sUrlToSign ) ; $ aUrl [ 'query' ] .= '&client=' . $ sClientId ; $ aUrlToSign = $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; $ decodedKey = base64_decode ( str_replace ( array ( '-' , '_' ) , array ( '+' , '/' ) , $ sPrivateKey ) ) ; $ sSignature = hash_hmac ( "sha1" , $ aUrlToSign , $ decodedKey , true ) ; $ sEncodedSignature = str_replace ( array ( '+' , '/' ) , array ( '-' , '_' ) , base64_encode ( $ sSignature ) ) ; $ sOriginalUrl = $ aUrl [ 'scheme' ] . "://" . $ aUrl [ 'host' ] . $ aUrl [ 'path' ] . "?" . $ aUrl [ 'query' ] ; return $ sOriginalUrl . '&signature=' . $ sEncodedSignature ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
481	public function addPrimaryKey ( $ name , $ table , $ columns ) { $ time = $ this -> beginCommand ( "add primary key $name on $table (" . ( is_array ( $ columns ) ? implode ( ',' , $ columns ) : $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> addPrimaryKey ( $ name , $ table , $ columns ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
2591	public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } }
10841	public function sayHello ( ) { $ text = $ this -> getHALLogo ( ) ; if ( $ this -> showText ) { $ text .= $ this -> getHelloDave ( ) ; } $ lines = explode ( "\n" , $ text ) ; $ spaces = '' ; if ( $ this -> center ) { $ max_length = 0 ; foreach ( $ lines as $ line ) { $ max_length = max ( $ max_length , Helper :: strlenWithoutDecoration ( $ this -> output -> getFormatter ( ) , $ line ) ) ; } $ numberOfSpaces = floor ( ( $ this -> screenSize [ 0 ] - $ max_length ) / 2 ) ; if ( $ numberOfSpaces > 0 ) { $ spaces = str_repeat ( ' ' , $ numberOfSpaces ) ; } } foreach ( $ lines as $ line ) { $ this -> output -> writeln ( $ spaces . $ line ) ; } }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
11135	protected function calculateUPDATE ( ) { $ this -> query .= 'UPDATE ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'updates' , ' SET ' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
12747	public function getInputSpecification ( ) { $ dateValidator = $ this -> getDateValidator ( ) ; $ dateValidatorName = get_class ( $ dateValidator ) ; return [ 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => [ Filter \ StringTrim :: class => [ 'name' => Filter \ StringTrim :: class ] , Filter \ StripNewlines :: class => [ 'name' => Filter \ StripNewlines :: class ] , Filter \ StripTags :: class => [ 'name' => Filter \ StripTags :: class ] , TimeToDateTime :: class => [ 'name' => TimeToDateTime :: class , 'options' => [ 'time_format' => $ this -> getFormat ( ) ] ] ] , 'validators' => [ $ dateValidatorName => $ dateValidator ] ] ; }
6946	private function getRegularDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; return $ qb -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ ex -> eq ( 'o.shipmentState' , ':shipped' ) , $ ex -> isNull ( 'o.paymentTerm' ) ) ) -> addOrderBy ( 'o.createdAt' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'shipped' , ShipmentStates :: STATE_COMPLETED ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; }
5295	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ fontFile = realpath ( $ input -> getArgument ( 'font-file' ) ) ; if ( $ fontFile === false || ! file_exists ( $ fontFile ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'font-file' ) . '" does not exist' ) ; } $ outputDirectory = realpath ( $ input -> getArgument ( 'output-directory' ) ) ; if ( $ outputDirectory === false || ! file_exists ( $ outputDirectory ) || ! is_dir ( $ outputDirectory ) ) { throw new \ InvalidArgumentException ( '"' . $ input -> getArgument ( 'output-directory' ) . '" is no directory' ) ; } $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading font file from "' . $ fontFile . '" ...' ) ; $ generator -> generateFromFont ( new Font ( array ( ) , file_get_contents ( $ fontFile ) ) ) ; $ output -> writeln ( 'writing SVG files to "' . $ outputDirectory . '" ...' ) ; $ generator -> saveGlyphsToDir ( $ outputDirectory ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created SVG files successfully</success>' ) ; }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
5045	public function paginator ( $ paginatorName , $ defaultParams = [ ] , $ as = 'paginator' ) { if ( is_string ( $ defaultParams ) ) { $ as = $ defaultParams ; $ defaultParams = [ ] ; } $ this -> stack [ 'paginator' ] = [ 'as' => $ as , $ paginatorName , $ defaultParams ] ; return $ this ; }
9705	private function calcSheetOffsets ( ) { $ boundsheet_length = 10 ; $ offset = $ this -> _datasize ; $ total_worksheets = count ( $ this -> spreadsheet -> getAllSheets ( ) ) ; foreach ( $ this -> spreadsheet -> getWorksheetIterator ( ) as $ sheet ) { $ offset += $ boundsheet_length + strlen ( StringHelper :: UTF8toBIFF8UnicodeShort ( $ sheet -> getTitle ( ) ) ) ; } for ( $ i = 0 ; $ i < $ total_worksheets ; ++ $ i ) { $ this -> worksheetOffsets [ $ i ] = $ offset ; $ offset += $ this -> worksheetSizes [ $ i ] ; } $ this -> biffSize = $ offset ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
9449	protected function allowed ( $ method ) { if ( in_array ( $ method , $ this -> allowed ) === false ) { $ message = 'Used method is not allowed' ; throw new \ UnexpectedValueException ( $ message ) ; } return true ; }
11145	protected function scanDir ( $ dir ) { $ result = array ( ) ; $ list = $ this -> scanDirExec ( $ dir ) ; foreach ( $ list as $ element ) { $ elementPath = $ dir . DIRECTORY_SEPARATOR . $ element ; if ( is_file ( $ elementPath ) ) { $ fileInfo = pathinfo ( $ element ) ; if ( in_array ( $ fileInfo [ 'extension' ] , $ this -> getAllowedFileExtensions ( ) ) ) { $ result [ ] = $ this -> getNameSpace ( ) . "\\" . $ fileInfo [ 'filename' ] ; } } } return $ result ; }
2724	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ object = $ observer -> getEvent ( ) -> getObject ( ) ; if ( $ object instanceof \ Magento \ Framework \ DataObject \ IdentityInterface && $ this -> canPurgeObject ( $ object ) ) { $ tags = [ ] ; foreach ( $ object -> getIdentities ( ) as $ tag ) { $ tag = $ this -> cacheTags -> convertCacheTags ( $ tag ) ; if ( ! in_array ( $ tag , $ this -> alreadyPurged ) ) { $ tags [ ] = $ tag ; $ this -> alreadyPurged [ ] = $ tag ; } } if ( ! empty ( $ tags ) ) { $ this -> purgeCache -> sendPurgeRequest ( array_unique ( $ tags ) ) ; } } } }
6156	public function redirect ( string $ url ) : object { return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
12645	public function render ( ElementInterface $ element ) { $ label = $ element -> getLabel ( ) ; if ( isset ( $ label ) && '' !== $ label ) { if ( null !== ( $ translator = $ this -> getTranslator ( ) ) ) { $ label = $ translator -> translate ( $ label , $ this -> getTranslatorTextDomain ( ) ) ; $ element -> setLabel ( $ label ) ; } } return parent :: render ( $ element ) ; }
145	public function propagateLiteral ( $ decidedLiteral , $ level , $ decisions ) { $ literal = - $ decidedLiteral ; if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { return null ; } $ chain = $ this -> watchChains [ $ literal ] ; $ chain -> rewind ( ) ; while ( $ chain -> valid ( ) ) { $ node = $ chain -> current ( ) ; $ otherWatch = $ node -> getOtherWatch ( $ literal ) ; if ( ! $ node -> getRule ( ) -> isDisabled ( ) && ! $ decisions -> satisfy ( $ otherWatch ) ) { $ ruleLiterals = $ node -> getRule ( ) -> getLiterals ( ) ; $ alternativeLiterals = array_filter ( $ ruleLiterals , function ( $ ruleLiteral ) use ( $ literal , $ otherWatch , $ decisions ) { return $ literal !== $ ruleLiteral && $ otherWatch !== $ ruleLiteral && ! $ decisions -> conflict ( $ ruleLiteral ) ; } ) ; if ( $ alternativeLiterals ) { reset ( $ alternativeLiterals ) ; $ this -> moveWatch ( $ literal , current ( $ alternativeLiterals ) , $ node ) ; continue ; } if ( $ decisions -> conflict ( $ otherWatch ) ) { return $ node -> getRule ( ) ; } $ decisions -> decide ( $ otherWatch , $ level , $ node -> getRule ( ) ) ; } $ chain -> next ( ) ; } return null ; }
4736	public function process ( ContainerBuilder $ container ) { $ serviceId = 'simple_bus.asynchronous.publishes_predefined_messages_middleware' ; if ( ! $ container -> hasDefinition ( $ serviceId ) ) { return ; } $ names = array ( ) ; $ this -> collectServiceIds ( $ container , 'asynchronous_event_subscriber' , 'subscribes_to' , function ( $ key ) use ( & $ names ) { $ names [ ] = $ key ; } ) ; $ container -> getDefinition ( $ serviceId ) -> replaceArgument ( 2 , array_unique ( $ names ) ) ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
4648	private function getConfigValue ( $ config , $ language , $ key ) { if ( ! isset ( $ config [ $ key ] ) || empty ( $ config [ $ key ] ) ) { if ( isset ( $ this -> defaults [ $ language ] [ $ key ] ) ) { return $ this -> defaults [ $ language ] [ $ key ] ; } return array ( ) ; } if ( ! is_array ( $ config [ $ key ] ) ) { return array ( $ config [ $ key ] ) ; } return $ config [ $ key ] ; }
11531	public static function slotDir ( $ sourceDir , array $ options ) { $ paths = array ( sprintf ( '%s/pages/pages/%s/%s_%s/%s' , $ sourceDir , $ options [ 'page' ] , $ options [ 'language' ] , $ options [ 'country' ] , $ options [ 'slot' ] ) , sprintf ( '%s/slots/%s/%s_%s' , $ sourceDir , $ options [ 'slot' ] , $ options [ 'language' ] , $ options [ 'country' ] ) , sprintf ( '%s/slots/%s' , $ sourceDir , $ options [ 'slot' ] ) , ) ; return self :: cascade ( $ paths ) ; }
5187	private function createPhoto ( string $ url , string $ ratio , string $ desc , string $ info ) : \ One \ Model \ Photo { return new Photo ( $ url , $ ratio , $ this -> handleString ( $ desc ) , $ this -> handleString ( $ info ) ) ; }
9984	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> entries ) ) { $ this -> entries = array ( ) ; foreach ( $ xmlElement -> entries -> children ( ) as $ entry ) { $ this -> entries [ ] = $ entry ; } } }
4077	protected function getPaletteCombinationRows ( ) { $ combinations = $ this -> getCombinationsFromDatabase ( ) ; $ success = array ( ) ; if ( ! $ combinations ) { return array_keys ( $ this -> information ) ; } foreach ( $ combinations as $ combination ) { $ modelId = $ combination -> pid ; $ modelName = $ this -> tableNameFromId ( $ modelId ) ; if ( ! empty ( $ this -> information [ $ modelName ] [ self :: COMBINATION ] ) ) { continue ; } $ this -> information [ $ modelName ] [ self :: MODELID ] = $ modelId ; $ this -> information [ $ modelName ] [ self :: COMBINATION ] = array ( 'dca_id' => $ combination -> dca_id , 'view_id' => $ combination -> view_id ) ; $ this -> setTableMapping ( $ modelId , $ modelName ) ; $ success [ ] = $ modelId ; } return $ success ; }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
3183	private function durationToMs ( $ duration ) { if ( ! is_null ( $ duration ) && $ duration instanceof QtiDuration ) { return TestRunnerUtils :: getDurationWithMicroseconds ( $ duration ) ; } return false ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
7421	protected function initializeProductMediaGalleryValueToEntity ( array $ attr ) { $ rowId = $ attr [ MemberNames :: ROW_ID ] ; $ valueId = $ attr [ MemberNames :: VALUE_ID ] ; if ( $ this -> loadProductMediaGalleryValueToEntityByValueIdAndRowId ( $ valueId , $ rowId ) ) { return ; } return $ attr ; }
9941	public function setTitle ( $ pValue , $ updateFormulaCellReferences = true , $ validate = true ) { if ( $ this -> getTitle ( ) == $ pValue ) { return $ this ; } $ oldTitle = $ this -> getTitle ( ) ; if ( $ validate ) { self :: checkSheetTitle ( $ pValue ) ; if ( $ this -> parent ) { if ( $ this -> parent -> sheetNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> parent -> sheetNameExists ( $ pValue . ' ' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue .= " $i" ; } } } $ this -> title = $ pValue ; $ this -> dirty = true ; if ( $ this -> parent && $ this -> parent -> getCalculationEngine ( ) ) { $ newTitle = $ this -> getTitle ( ) ; $ this -> parent -> getCalculationEngine ( ) -> renameCalculationCacheForWorksheet ( $ oldTitle , $ newTitle ) ; if ( $ updateFormulaCellReferences ) { ReferenceHelper :: getInstance ( ) -> updateNamedFormulas ( $ this -> parent , $ oldTitle , $ newTitle ) ; } } return $ this ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
6840	public function getData ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { return $ this -> data [ $ key ] ; } throw new InjectorException ( "data $key not found" ) ; }
12534	public function pagination ( $ lastSeen , $ count ) { $ params = [ 'type' => 2 , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
5511	public function expectCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_counts [ strtolower ( $ method ) ] = new CallCountExpectation ( $ method , $ count , $ message ) ; }
8570	public function getLastUpdatedTimeForRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetLastUpdatedTimeForRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetLastUpdatedTimeForRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_GetLastUpdatedTimeForRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4403	public function loadRelatedLayouts ( Location $ location ) { $ query = $ this -> databaseConnection -> createQueryBuilder ( ) ; $ valueColumnName = class_exists ( 'Netgen\BlockManager\Version' ) && Version :: VERSION_ID < 1100 ? 'value_id' : 'value' ; $ query -> select ( 'DISTINCT b.layout_id' ) -> from ( 'ngbm_collection_item' , 'ci' ) -> innerJoin ( 'ci' , 'ngbm_block_collection' , 'bc' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'bc.collection_id' , 'ci.collection_id' ) , $ query -> expr ( ) -> eq ( 'bc.collection_status' , 'ci.status' ) ) ) -> innerJoin ( 'bc' , 'ngbm_block' , 'b' , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'b.id' , 'bc.block_id' ) , $ query -> expr ( ) -> eq ( 'b.status' , 'bc.block_status' ) ) ) -> where ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> orX ( $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':content_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':content_id' ) ) , $ query -> expr ( ) -> andX ( $ query -> expr ( ) -> eq ( 'ci.value_type' , ':location_value_type' ) , $ query -> expr ( ) -> eq ( 'ci.' . $ valueColumnName , ':location_id' ) ) ) , $ query -> expr ( ) -> eq ( 'ci.status' , ':status' ) ) ) -> setParameter ( 'status' , Value :: STATUS_PUBLISHED , Type :: INTEGER ) -> setParameter ( 'content_value_type' , 'ezcontent' , Type :: STRING ) -> setParameter ( 'location_value_type' , 'ezlocation' , Type :: STRING ) -> setParameter ( 'content_id' , $ location -> contentInfo -> id , Type :: INTEGER ) -> setParameter ( 'location_id' , $ location -> id , Type :: INTEGER ) ; $ relatedLayouts = array_map ( function ( array $ dataRow ) { return $ this -> layoutService -> loadLayout ( $ dataRow [ 'layout_id' ] ) ; } , $ query -> execute ( ) -> fetchAll ( PDO :: FETCH_ASSOC ) ) ; usort ( $ relatedLayouts , function ( Layout $ layout1 , Layout $ layout2 ) { if ( $ layout1 -> getName ( ) === $ layout2 -> getName ( ) ) { return 0 ; } return $ layout1 -> getName ( ) > $ layout2 -> getName ( ) ? 1 : - 1 ; } ) ; return $ relatedLayouts ; }
7128	public function addRanges ( string $ from , string $ to ) { $ this -> ranges [ ] = [ 'from' => $ from , 'to' => $ to , ] ; return $ this ; }
6418	public static function isEmpty ( IteratorAggregate $ iterable ) : bool { return Iterators :: isEmpty ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
4254	public function build ( $ stats ) { $ this -> stats = $ stats ; return '' . $ this -> buildFatal ( ) . $ this -> buildInConsole ( ) . $ this -> buildNotInConsole ( ) ; }
11232	public function getLocation ( $ ip = '' , $ baseCurrency = '' , $ renameArrayKeys = false ) { $ params = [ 'ip' => ! $ ip ? $ _SERVER [ 'REMOTE_ADDR' ] : $ ip , 'base_currency' => $ baseCurrency , ] ; $ response = $ this -> client -> get ( 'json.gp' , $ params ) ; $ data = $ this -> handleResponseContent ( $ response , 'json' ) ; if ( $ renameArrayKeys ) { $ tmpData = [ ] ; foreach ( $ data as $ key => $ value ) { $ tmpData [ str_replace ( 'geoplugin_' , '' , $ key ) ] = $ value ; } $ data = $ tmpData ; } return $ data ; }
9411	protected function exceptions ( \ Exception $ exception , $ uri ) { $ interface = 'Phroute\Phroute\Exception\HttpRouteNotFoundException' ; $ message = ( string ) $ exception -> getMessage ( ) ; is_a ( $ exception , $ interface ) && $ message = 'Route "' . $ uri . '" not found' ; throw new \ UnexpectedValueException ( ( string ) $ message ) ; }
8086	private function cleanConsole ( ) { $ channel = $ this -> namespaceChannel ( $ this -> currentChannel ) ; if ( empty ( $ this -> console [ 'errors' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'errors' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'form' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'form' ] [ $ channel ] ) ; } if ( empty ( $ this -> console [ 'reports' ] [ $ channel ] ) ) { unset ( $ this -> console [ 'reports' ] [ $ channel ] ) ; } }
5163	public function serialize ( EntityContract $ entity , Collection $ select = null ) { $ bag = parent :: serialize ( $ entity , $ select ) ; return $ bag ; }
4058	private function drawAttribute ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; $ attribute = $ metaModel -> getAttributeById ( $ model -> getProperty ( 'attr_id' ) ) ; if ( $ attribute ) { $ type = $ attribute -> get ( 'type' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> attributeFactory -> getIconForType ( $ type ) , $ type , '' , 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = $ attribute -> getName ( ) ; $ colName = $ attribute -> getColName ( ) ; $ isUnique = $ attribute -> get ( 'isunique' ) ; } else { $ type = 'unknown ID: ' . $ model -> getProperty ( 'attr_id' ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( 'bundles/metamodelscore/images/icons/fields.png' ) ; $ name = 'unknown attribute' ; $ colName = 'unknown column' ; $ isUnique = false ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong><span class="mandatory">%s</span> <span class="tl_class">%s</span> </div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ colName , $ type , $ image , $ name , $ model -> getProperty ( 'mandatory' ) || $ isUnique ? ' [' . $ this -> trans ( 'mandatory.0' ) . ']' : '' , $ model -> getProperty ( 'tl_class' ) ? sprintf ( '[%s]' , $ model -> getProperty ( 'tl_class' ) ) : '' ] ) ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
2585	protected function loadReferences ( $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> passengers , $ params -> segments ) ) { $ this -> psaInformation = new PsaInformation ( ) ; foreach ( $ params -> passengers as $ passenger ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ passenger , RefDetails :: QUAL_PASSENGER ) ; } foreach ( $ params -> segments as $ segment ) { $ this -> psaInformation -> refDetails [ ] = new RefDetails ( $ segment , RefDetails :: QUAL_SEGMENT_REFERENCE ) ; } } }
2685	public function aroundDispatch ( FrontController $ subject , callable $ proceed , ... $ args ) { $ isRateLimitingEnabled = $ this -> config -> isRateLimitingEnabled ( ) ; $ isCrawlerProtectionEnabled = $ this -> config -> isCrawlerProtectionEnabled ( ) ; if ( ! $ isRateLimitingEnabled && ! $ isCrawlerProtectionEnabled ) { return $ proceed ( ... $ args ) ; } $ path = strtolower ( $ this -> request -> getPathInfo ( ) ) ; if ( $ isRateLimitingEnabled && $ this -> sensitivePathProtection ( $ path ) ) { return $ this -> response ; } if ( $ isCrawlerProtectionEnabled && $ this -> crawlerProtection ( $ path ) ) { return $ this -> response ; } return $ proceed ( ... $ args ) ; }
6731	public function get_posts ( ) { $ total_posts = wp_count_posts ( ) ; $ total_posts = isset ( $ total_posts -> publish ) ? $ total_posts -> publish : 0 ; return get_posts ( [ 'post_type' => 'post' , 'numberposts' => $ total_posts , 'post_status' => 'publish' , ] ) ; }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
564	public function renderSorter ( ) { $ sort = $ this -> dataProvider -> getSort ( ) ; if ( $ sort === false || empty ( $ sort -> attributes ) || $ this -> dataProvider -> getCount ( ) <= 0 ) { return '' ; } $ sorter = $ this -> sorter ; $ class = ArrayHelper :: remove ( $ sorter , 'class' , LinkSorter :: className ( ) ) ; $ sorter [ 'sort' ] = $ sort ; $ sorter [ 'view' ] = $ this -> getView ( ) ; return $ class :: widget ( $ sorter ) ; }
3810	protected function translateRows ( $ rows ) { $ metaModel = $ this -> getMetaModel ( ) ; $ activeLegend = $ this -> translateLegend ( array ( 'legendtitle' => $ metaModel -> getName ( ) , 'legendhide' => false ) , $ metaModel ) ; $ activeLegendId = null ; $ columnNames = array ( ) ; foreach ( $ rows as $ row ) { if ( $ row [ 'dcatype' ] != 'attribute' ) { continue ; } $ attribute = $ metaModel -> getAttributeById ( $ row [ 'attr_id' ] ) ; if ( $ attribute ) { $ columnNames [ $ row [ 'id' ] ] = $ attribute -> getColName ( ) ; } } $ this -> propertyMap = $ columnNames ; $ this -> propertyMap2 = array_flip ( $ columnNames ) ; foreach ( $ rows as $ row ) { switch ( $ row [ 'dcatype' ] ) { case 'legend' : $ activeLegend = $ this -> translateLegend ( $ row , $ metaModel ) ; $ activeLegendId = $ row [ 'id' ] ; break ; case 'attribute' : $ exists = $ this -> translateProperty ( $ row , $ metaModel , $ activeLegend ) ; if ( $ exists && $ activeLegendId ) { $ this -> applyLegendConditions ( $ row [ 'id' ] , $ activeLegendId ) ; } break ; default : throw new \ RuntimeException ( 'Unknown palette rendering mode ' . $ row [ 'dcatype' ] ) ; } } }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
8932	public function loadDependencies ( ) { $ config = ConfigService :: fetch ( dirname ( __DIR__ ) ) ; $ config = array_merge ( $ config , ConfigService :: fetch ( ) ) ; $ moduleService = new ModuleService ; if ( ! array_key_exists ( 'slim-api' , $ config ) ) { $ config [ 'slim-api' ] = [ 'modules' => [ 'SlimApi\Phinx' , 'SlimApi\Mvc' ] ] ; } else { require 'vendor/autoload.php' ; } foreach ( $ config [ 'slim-api' ] [ 'modules' ] as $ moduleNamespace ) { $ config = array_merge ( $ config , $ moduleService -> load ( $ moduleNamespace ) ) ; } return $ config ; }
12480	protected function findSlotsInTemplates ( ) { $ templates = $ this -> findTemplates ( ) ; $ slots = array ( ) ; foreach ( $ templates [ "base" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots = array_merge_recursive ( $ slots , $ this -> findSlots ( $ templateName , $ templateContents ) ) ; } $ baseSlots [ "base" ] = $ slots ; $ slots = array ( ) ; foreach ( $ templates [ "template" ] as $ templateName => $ templateFile ) { $ templateContents = FilesystemTools :: readFile ( $ templateFile ) ; $ slots [ $ templateName ] = $ this -> findSlots ( $ templateName , $ templateContents ) ; } return array ( 'base' => $ baseSlots , 'templates' => $ slots , ) ; }
10292	public static function setDefaultTimezone ( $ timeZone ) { if ( $ timeZone = self :: validateTimeZone ( $ timeZone ) ) { self :: $ defaultTimeZone = $ timeZone ; return true ; } return false ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
3379	protected function getDefaultNamespace ( $ rootNamespace ) { $ controllersPath = \ Config :: get ( 'panel.controllers' ) ; if ( isset ( $ controllersPath ) && $ controllersPath != NULL ) { return $ controllersPath ; } else { return $ rootNamespace . '\Http\Controllers' ; } }
7046	protected function buildCustomerData ( Common \ SaleInterface $ sale ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { return [ 'number' => $ customer -> getNumber ( ) , 'company' => $ customer -> getCompany ( ) , 'full_name' => trim ( $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ) , 'email' => $ customer -> getEmail ( ) , 'phone' => $ this -> formatPhoneNumber ( $ customer -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ customer -> getMobile ( ) ) , ] ; } else { return [ 'number' => null , 'company' => $ sale -> getCompany ( ) , 'full_name' => trim ( $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ) , 'email' => $ sale -> getEmail ( ) , 'phone' => null , 'mobile' => null , ] ; } }
7278	public function input ( $ name = null , $ default = null ) { return ! $ name ? $ this -> inputs : ( $ this -> inputs [ $ name ] ?? $ default ) ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
9009	public function decimal ( int $ total , int $ decimal ) : self { $ this -> type = 'decimal(' . $ total . ',' . $ decimal . ')' ; return $ this ; }
6625	public function put ( $ key , $ data , $ duration = null ) { return $ this -> cache -> put ( $ key , $ data , ( $ duration ) ? : $ this -> duration ) ; }
1133	public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; }
11767	protected function wipeServerList ( ) { $ this -> reset ( ) ; $ this -> master = null ; $ this -> slaves = array ( ) ; $ this -> pool = array ( ) ; }
11754	public function lists ( $ msgId , $ index , $ begin , $ count , $ type = 0 ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'begin' => $ begin , 'count' => $ count , 'type' => $ type , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST_COMMENT , $ params ] ) ; }
12935	protected function resolveMoveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'sourceSlot' , 'position' , ) ) ; $ this -> optionsResolver -> setDefined ( array ( 'targetSlot' , 'blockname' , 'oldName' , 'newName' , 'slot' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
4004	public function getMetaModelNameFromId ( GetMetaModelNameFromIdEvent $ event ) { $ metaModelId = $ event -> getMetaModelId ( ) ; if ( array_key_exists ( $ metaModelId , $ this -> instancesById ) ) { $ event -> setMetaModelName ( $ this -> instancesById [ $ metaModelId ] -> getTableName ( ) ) ; return ; } if ( isset ( $ this -> tableNames [ $ metaModelId ] ) ) { $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; return ; } if ( ! $ this -> tableNamesCollected ) { $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ metaModelId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ this -> tableNames [ $ metaModelId ] = $ table [ 'tableName' ] ; $ event -> setMetaModelName ( $ this -> tableNames [ $ metaModelId ] ) ; } } }
10591	protected function findProduct ( int $ id ) : ProductInterface { $ product = $ this -> repository -> find ( $ id ) ; if ( ! $ product instanceof ProductInterface ) { throw new ProductNotFoundException ( $ id ) ; } return $ product ; }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
7953	public function getSpam ( $ ipblock , $ spamstate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ spamstate ) throw new BadMethodCallException ( 'Parameter $spamstate is missing.' ) ; switch ( $ spamstate ) { case "blockedForSpam" : case "unblocked" : case "unblocking" : break ; default : throw new BadMethodCallException ( 'Parameter $spamstate is invalid.' ) ; } try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/?state=' . $ spamstate ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6221	public function setHttpClient ( $ httpClient ) { if ( is_null ( $ httpClient ) ) { $ httpClient = new Curl ; $ threeScaleVersion = new ThreeScaleVersion ( ) ; $ version = $ threeScaleVersion -> getVersion ( ) ; $ httpClient -> options [ 'CURLOPT_FOLLOWLOCATION' ] = false ; $ httpClient -> headers [ 'X-3scale-User-Agent' ] = 'plugin-php-v' . $ version ; } $ this -> httpClient = $ httpClient ; }
3891	public function loadCallback ( string $ value = null ) { return null === $ value ? null : trim ( \ base64_encode ( $ value ) , '=' ) ; }
11345	public function render ( ) { $ html = $ this -> formatter -> renderFormBegin ( $ this -> formTags ) ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } $ html .= $ this -> renderSubmit ( ) ; $ html .= $ this -> renderEnd ( ) ; return $ html ; }
4959	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ index => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ index ] ) ; } } $ sharedEvents = $ events -> getSharedManager ( ) ; foreach ( $ this -> sharedListeners as $ index => $ listener ) { if ( $ sharedEvents -> detach ( $ listener ) ) { unset ( $ this -> sharedListeners [ $ index ] ) ; } } }
8407	private function getIcon ( ) { if ( isset ( $ this -> model ) ) { $ icon = $ this -> attribute ; if ( isset ( $ this -> model -> $ icon ) ) { return $ this -> model -> $ icon ; } } if ( isset ( $ this -> icon ) ) { return $ this -> icon ; } return $ this -> default ; }
5362	public function createContext ( Registry $ registry , $ name ) { $ schemas = array_values ( $ registry -> getSchemas ( ) ) ; foreach ( $ schemas as $ schema ) { $ openApiSpec = $ this -> schemaParser -> parseSchema ( $ schema -> getOrigin ( ) ) ; $ this -> chainGuesser -> guessClass ( $ openApiSpec , $ schema -> getRootName ( ) , $ schema -> getOrigin ( ) . '#' , $ registry ) ; $ schema -> setParsed ( $ openApiSpec ) ; } foreach ( $ registry -> getSchemas ( ) as $ schema ) { foreach ( $ schema -> getClasses ( ) as $ class ) { $ properties = $ this -> chainGuesser -> guessProperties ( $ class -> getObject ( ) , $ schema -> getRootName ( ) , $ class -> getReference ( ) , $ registry ) ; foreach ( $ properties as $ property ) { $ property -> setType ( $ this -> chainGuesser -> guessType ( $ property -> getObject ( ) , $ property -> getName ( ) , $ property -> getReference ( ) , $ registry ) ) ; } $ class -> setProperties ( $ properties ) ; } } return new Context ( $ registry ) ; }
8509	public function getPrepInstructionsForSKU ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForSKURequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForSKU' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForSKUResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8493	public function setFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7404	private function convertFileInformation ( $ file ) { if ( $ file instanceof FileUpload ) { return $ file ; } $ file = $ this -> fixPhpFilesArray ( $ file ) ; if ( is_array ( $ file ) ) { $ keys = array_keys ( $ file ) ; sort ( $ keys ) ; if ( $ keys == [ 'error' , 'name' , 'size' , 'tmp_name' , 'type' ] ) { if ( UPLOAD_ERR_NO_FILE == $ file [ 'error' ] ) { $ file = null ; } else { $ file = new FileUpload ( $ file [ 'tmp_name' ] , $ file [ 'name' ] , $ file [ 'size' ] , $ file [ 'type' ] , $ file [ 'error' ] ) ; } } else { $ file = array_map ( [ $ this , 'convertFileInformation' ] , $ file ) ; } } return $ file ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
11178	public function getApi ( ) { $ api = $ this -> get ( Keys :: EXT_API ) ; if ( is_array ( $ api ) ) { return $ api ; } return false ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
4960	public function render ( FormInterface $ form , $ layout = self :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ formContent = $ this -> renderBare ( $ form , $ layout , $ parameter ) ; $ renderer = $ this -> getView ( ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ descriptionParams = $ form -> getOption ( 'description_params' ) ; $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; if ( $ descriptionParams ) { array_unshift ( $ descriptionParams , $ desc ) ; $ desc = call_user_func_array ( 'sprintf' , $ descriptionParams ) ; } } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8"><div class="panel panel-default"><div class="panel-body">%s</div></div></div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } else { $ formContent = '<div class="form-content">' . $ formContent . '</div>' ; } $ markup = '<div id="form-%s" class="form-container">' . '%s' . '%s' . '</div>' ; if ( $ label = $ form -> getLabel ( ) ) { $ label = '<div class="form-headline"><h3>' . $ renderer -> translate ( $ label ) . '</h3></div>' ; } return sprintf ( $ markup , $ form -> getAttribute ( 'id' ) ? : $ form -> getName ( ) , $ label , $ formContent ) ; }
427	public static function setInstance ( $ instance ) { if ( $ instance === null ) { unset ( Yii :: $ app -> loadedModules [ get_called_class ( ) ] ) ; } else { Yii :: $ app -> loadedModules [ get_class ( $ instance ) ] = $ instance ; } }
8209	protected function parseArguments ( ) { $ this -> parseConnection ( $ this -> option ( 'connection' ) ) ; if ( $ this -> option ( 'host' ) ) { $ this -> host = $ this -> option ( 'host' ) ; } if ( $ this -> option ( 'port' ) ) { $ this -> port = ( int ) $ this -> option ( 'port' ) ; } $ this -> parseCommandArguments ( ) ; }
2958	public function confStopBits ( $ length ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set the length of a stop bit : the " . "device is either not set or opened" , E_USER_WARNING ) ; return false ; } if ( $ length != 1 and $ length != 2 and $ length != 1.5 and ! ( $ length == 1.5 and $ this -> _os === "linux" ) ) { trigger_error ( "Specified stop bit length is invalid" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . ( ( $ length == 1 ) ? "-" : "" ) . "cstopb" , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " STOP=" . $ length , $ out ) ; } if ( $ ret === 0 ) { return true ; } trigger_error ( "Unable to set stop bit length : " . $ out [ 1 ] , E_USER_WARNING ) ; return false ; }
2339	public function renderDropdown ( ) { $ objVersion = $ this -> Database -> prepare ( "SELECT tstamp, version, username, active FROM tl_version WHERE fromTable=? AND pid=? ORDER BY version DESC" ) -> execute ( $ this -> strTable , $ this -> intPid ) ; if ( $ objVersion -> numRows < 2 ) { return '' ; } $ versions = '' ; while ( $ objVersion -> next ( ) ) { $ versions .= ' <option value="' . $ objVersion -> version . '"' . ( $ objVersion -> active ? ' selected="selected"' : '' ) . '>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'version' ] . ' ' . $ objVersion -> version . ' (' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ objVersion -> tstamp ) . ') ' . $ objVersion -> username . '</option>' ; } return '<div class="tl_version_panel"><form action="' . ampersand ( Environment :: get ( 'request' ) , true ) . '" id="tl_version" class="tl_form" method="post" aria-label="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'versioning' ] ) . '"><div class="tl_formbody"><input type="hidden" name="FORM_SUBMIT" value="tl_version"><input type="hidden" name="REQUEST_TOKEN" value="' . REQUEST_TOKEN . '"><select name="version" class="tl_select">' . $ versions . '</select><button type="submit" name="showVersion" id="showVersion" class="tl_submit">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'restore' ] . '</button><a href="' . Backend :: addToUrl ( 'versions=1&amp;popup=1' ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . StringUtil :: specialchars ( str_replace ( "'" , "\\'" , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] , $ this -> intPid , $ this -> strTable ) ) ) . '\',\'url\':this.href});return false">' . Image :: getHtml ( 'diff.svg' ) . '</a></div></form></div>' ; }
2406	public static function generateStyleTag ( $ href , $ media = null , $ mtime = false ) { if ( $ mtime === null && ! preg_match ( '@^https?://@' , $ href ) ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( file_exists ( $ rootDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ href ) ; } else { $ webDir = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.web_dir' ) ) ; if ( file_exists ( $ rootDir . '/' . $ webDir . '/' . $ href ) ) { $ mtime = filemtime ( $ rootDir . '/' . $ webDir . '/' . $ href ) ; } } } if ( $ mtime ) { $ href .= '?v=' . substr ( md5 ( $ mtime ) , 0 , 8 ) ; } return '<link rel="stylesheet" href="' . $ href . '"' . ( ( $ media && $ media != 'all' ) ? ' media="' . $ media . '"' : '' ) . '>' ; }
6151	public function redirect ( string $ url ) : object { $ this -> addHeader ( "Location: " . $ url ) ; $ this -> body = null ; return $ this ; }
7016	private function format_g ( & $ str ) { if ( strstr ( $ str , '%g' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%g' , sprintf ( '%1d' , $ h ) , $ str ) ; } }
2901	public function addResponseInfo ( Mage_Core_Controller_Response_Http $ httpResponse ) { $ this -> responseCode = $ httpResponse -> getHttpResponseCode ( ) ; $ this -> responseHeaders = array ( ) ; $ headers = $ httpResponse -> getHeaders ( ) ; foreach ( $ headers as $ header ) { $ this -> responseHeaders [ $ header [ 'name' ] ] = $ header [ 'value' ] ; } }
8643	public function cancelReportRequests ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_CancelReportRequestsRequest ) { $ request = new MarketplaceWebService_Model_CancelReportRequestsRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertCancelReportRequests ( $ request ) ) ; $ response = MarketplaceWebService_Model_CancelReportRequestsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2243	public static function getForm ( $ varId , $ strColumn = 'main' , $ blnModule = false ) { if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( $ varId == '' ) { return '' ; } $ objRow = FormModel :: findByIdOrAlias ( $ varId ) ; if ( $ objRow === null ) { return '' ; } } $ strClass = $ blnModule ? Module :: findClass ( 'form' ) : ContentElement :: findClass ( 'form' ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Form class "' . $ strClass . '" does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = $ blnModule ? 'mod_' : 'ce_' ; $ objRow -> form = $ objRow -> id ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getForm' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } return $ strBuffer ; }
4937	protected function createNestedOptions ( $ className , $ options ) { $ class = new $ className ( ) ; foreach ( $ options as $ key => $ spec ) { if ( is_array ( $ spec ) && array_key_exists ( '__class__' , $ spec ) ) { $ nestedClassName = $ spec [ '__class__' ] ; unset ( $ spec [ '__class__' ] ) ; $ spec = $ this -> createNestedOptions ( $ nestedClassName , $ spec ) ; } $ class -> { $ key } = $ spec ; } return $ class ; }
1536	protected function fillRelationships ( $ record , Collection $ relationships , EncodingParametersInterface $ parameters ) { $ relationships -> filter ( function ( $ value , $ field ) use ( $ record ) { return $ this -> isFillableRelation ( $ field , $ record ) ; } ) -> each ( function ( $ value , $ field ) use ( $ record , $ parameters ) { $ this -> fillRelationship ( $ record , $ field , $ value , $ parameters ) ; } ) ; }
8003	public static function forCurrentSystem ( $ code = self :: CODE_FOR_SYSTEM , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . self :: MESSAGE_EXTENSION_FOR_SYSTEM ; return new static ( $ message , $ code , $ previous ) ; }
8857	private function _relativeSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir , true ) ; $ method = AssetsInstallCommand :: METHOD_RELATIVE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _absoluteSymlinkWithFallback ( $ originDir , $ targetDir ) ; } return $ method ; }
5502	protected function dieOnNoMethod ( $ method , $ task ) { if ( $ this -> is_strict && ! method_exists ( $ this , $ method ) ) { $ errormsg = sprintf ( 'Cannot %s. Method %s() not in class %s.' , $ task , $ method , get_class ( $ this ) ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
9848	public function createSignedRequest ( string $ method , string $ uri , string $ body , SigningSecretKey $ key , array $ headers = [ ] ) : RequestInterface { $ signature = \ ParagonIE_Sodium_Compat :: crypto_sign_detached ( $ body , $ key -> getString ( true ) ) ; if ( isset ( $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] ) ) { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] [ ] = Base64UrlSafe :: encode ( $ signature ) ; } else { $ headers [ Sapient :: HEADER_SIGNATURE_NAME ] = Base64UrlSafe :: encode ( $ signature ) ; } return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( $ body ) , [ ] ) ; }
2188	public function register ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; if ( ! \ is_array ( $ this -> arrAliases [ $ strTable ] ) ) { $ this -> arrAliases [ $ strTable ] = array ( ) ; } if ( ! \ is_array ( $ this -> arrRegistry [ $ strTable ] ) ) { $ this -> arrRegistry [ $ strTable ] = array ( ) ; } $ strPk = $ objModel -> getPk ( ) ; $ varPk = $ objModel -> $ strPk ; if ( $ varPk === null ) { throw new \ RuntimeException ( 'The primary key has not been set' ) ; } if ( isset ( $ this -> arrRegistry [ $ strTable ] [ $ varPk ] ) ) { throw new \ RuntimeException ( "The registry already contains an instance for $strTable::$strPk($varPk)" ) ; } $ this -> arrIdentities [ $ intObjectId ] = $ objModel ; $ this -> arrRegistry [ $ strTable ] [ $ varPk ] = $ objModel ; $ objModel -> onRegister ( $ this ) ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
7060	public function removeClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( false !== $ index = array_search ( $ class , $ classes ) ) { unset ( $ classes [ $ index ] ) ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
12169	private function createPropertyValuesTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP PROCEDURE IF EXISTS `property_value_validate`;" ) ; $ this -> database -> query ( "CREATE PROCEDURE `?property_value_validate`(IN _property_id INT, IN _value_data LONGTEXT) BEGIN DECLARE _validationFails CONDITION FOR SQLSTATE '99001'; DECLARE _dataTypeRegExp VARCHAR(255); DECLARE _signalText TEXT; SELECT r.datatype_validation FROM `?properties` AS d INNER JOIN `?property_datatypes` AS r WHERE `property_id`= _property_id AND d.property_datatype=r.datatype_name INTO _dataTypeRegExp; IF (_dataTypeRegExp IS NOT NULL) THEN IF (_value_data NOT REGEXP(_dataTypeRegExp)) THEN SET _signalText = CONCAT('The inserted/updated value fails the property data type validation'); SIGNAL _validationFails SET MESSAGE_TEXT=_signalText; END IF; END IF; END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_insert` BEFORE INSERT ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?property_value_validate_update` BEFORE UPDATE ON `?property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; }
7733	public function onKernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ result = $ event -> getControllerResult ( ) ; if ( ! $ request -> attributes -> get ( '__hydra_serialize' ) ) { return ; } if ( is_array ( $ result ) || ( $ result instanceof \ ArrayAccess ) || ( $ result instanceof \ Traversable ) ) { $ result = new Collection ( $ request -> getUri ( ) , $ result ) ; } elseif ( null === $ result ) { $ event -> setResponse ( new JsonLdResponse ( '' , 200 ) ) ; return ; } elseif ( ! is_object ( $ result ) ) { throw new \ Exception ( "A Hydra controller must return either an array or an object, got a(n) " . gettype ( $ result ) ) ; } $ serialized = $ this -> serializer -> serialize ( $ result , 'jsonld' ) ; $ event -> setResponse ( new JsonLdResponse ( $ serialized ) ) ; }
4567	public function resolve ( Form $ form ) { switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ resolve = function ( & $ component ) use ( & $ resolve , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as & $ subComponent ) { $ resolve ( $ subComponent ) ; } } break ; case property_exists ( $ component , 'defaultValue' ) : if ( null !== $ component -> defaultValue ) { try { $ component -> defaultValue = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ component -> defaultValue = null ; } catch ( UnmatchedException $ exception ) { } } break ; } } ; foreach ( $ components as & $ component ) { $ resolve ( $ component ) ; } $ form -> setSchema ( $ components ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ form ; }
5168	private function convertNonAscii ( string $ string ) : string { $ search = $ replace = [ ] ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 152 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 153 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 156 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 157 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 147 ) ; $ replace [ ] = '--' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 148 ) ; $ replace [ ] = '---' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 162 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 194 ) . chr ( 183 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 166 ) ; $ replace [ ] = '...' ; $ string = str_replace ( $ search , $ replace , $ string ) ; return preg_replace ( "/[^\x01-\x7F]/" , '' , $ string ) ; }
2744	public function execute ( \ Magento \ Framework \ Event \ Observer $ observer ) { if ( $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> isEnabled ( ) ) { $ this -> purgeCache -> sendPurgeRequest ( ) ; } }
1080	public static function parse ( $ source , array $ options = [ ] ) { $ sourceObj = $ source instanceof Source ? $ source : new Source ( $ source ) ; $ parser = new self ( $ sourceObj , $ options ) ; return $ parser -> parseDocument ( ) ; }
7196	public function handleReleasedChange ( OrderInterface $ order ) { if ( $ this -> persistenceHelper -> isChanged ( $ order , 'sample' ) ) { if ( $ order -> isReleased ( ) && ! $ order -> isSample ( ) ) { throw new IllegalOperationException ( "Can't turn 'sample' into false if order is released." ) ; } } if ( ! $ this -> persistenceHelper -> isChanged ( $ order , 'released' ) ) { return false ; } if ( ! $ order -> isSample ( ) && $ order -> isReleased ( ) ) { $ order -> setReleased ( false ) ; return true ; } if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } foreach ( $ order -> getItems ( ) as $ item ) { $ this -> applySaleItemRecursively ( $ item ) ; } return false ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
4091	public function createPayload ( ) { $ payloads = array ( ) ; foreach ( $ this -> operations as $ operation ) { foreach ( $ operation as $ partial ) { $ payloads [ ] = json_encode ( $ partial ) ; } } return join ( "\n" , $ payloads ) . "\n" ; }
1094	public function roots ( ) { return $ this -> node -> newQuery ( ) -> whereNull ( $ this -> node -> getQualifiedParentColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) -> get ( ) ; }
4368	public function & offsetGet ( $ key ) { if ( $ this -> hasValue ( $ key ) ) { return $ this -> values [ $ key ] ; } $ null = null ; return $ null ; }
2558	protected function loadPaymentModule ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> fopType , $ options -> payMerchant , $ options -> payments , $ options -> installmentsInfo , $ options -> mopPaymentType , $ options -> creditCardInfo , $ options -> fraudScreening , $ options -> payIds , $ options -> paySupData ) ) { if ( $ this instanceof MopDescription14 ) { $ this -> paymentModule = new PaymentModule14 ( $ options -> fopType ) ; } else { $ this -> paymentModule = new PaymentModule ( $ options -> fopType ) ; } $ this -> paymentModule -> loadPaymentData ( $ options ) ; $ this -> loadMopInformation ( $ options ) ; $ this -> loadPaymentSupplementaryData ( $ options ) ; } }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
9197	public function getTag ( ) { if ( null !== $ this -> tag ) { return $ this -> tag ; } $ categoryId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'categoryid' ) ; if ( is_numeric ( $ categoryId ) ) { return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ categoryId ) ; } $ topicId = $ this -> getEvent ( ) -> getRouteMatch ( ) -> getParam ( 'topicid' ) ; if ( is_numeric ( $ topicId ) ) { $ topic = $ this -> getDiscussService ( ) -> getTopicById ( $ topicId ) ; return $ this -> tag = $ this -> getDiscussService ( ) -> getCategoryById ( $ topic -> getforumCategoryId ( ) ) ; } return false ; }
12737	protected function translate ( ) { $ translatorOptions = $ this -> getTranslatorOptions ( ) ; if ( empty ( $ translatorOptions ) && ! array_key_exists ( "fields" , $ translatorOptions ) ) { return ; } $ params = array ( ) ; if ( array_key_exists ( "params" , $ translatorOptions ) ) { $ params = $ translatorOptions [ "params" ] ; } $ domain = "RedKiteCms" ; if ( array_key_exists ( "domain" , $ translatorOptions ) ) { $ domain = $ translatorOptions [ "domain" ] ; } foreach ( $ translatorOptions [ "fields" ] as $ field ) { $ field = ucfirst ( $ field ) ; $ method = 'get' . $ field ; $ value = Translator :: translate ( $ this -> $ method ( ) , $ params , $ domain ) ; $ method = 'set' . $ field ; $ this -> $ method ( $ value ) ; } }
2373	public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , '/ (cellpadding|cellspacing|border)="[^"]*"/' => '' , '/ rel="lightbox(\[([^\]]+)\])?"/' => ' data-lightbox="$2"' ) ; $ arrStrReplace = array ( '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' onclick="window.open(this.href); return false"' => ' target="_blank"' , ' onclick="window.open(this.href);return false"' => ' target="_blank"' , ' onclick="window.open(this.href); return false;"' => ' target="_blank"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
6456	public function selectable ( ) { $ this -> restrictElements ( [ 'select' => [ ] ] ) ; $ data = [ $ this -> value , $ this -> element -> find ( 'xpath' , "//option[@value='$this->value']" ) -> getText ( ) ] ; self :: debug ( [ 'Expected: %s' , 'Value: %s' , 'Tag: %s' , ] , [ $ this -> expected , implode ( ' => ' , $ data ) , $ this -> tag , ] ) ; $ this -> assert ( in_array ( $ this -> expected , $ data ) , 'selected' ) ; }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
3294	protected function buildLink ( $ provider , $ url ) { $ fontAwesomeVersion = config ( 'laravel-share.fontAwesomeVersion' , 4 ) ; $ this -> html .= trans ( "laravel-share::laravel-share-fa$fontAwesomeVersion.$provider" , [ 'url' => $ url , 'class' => key_exists ( 'class' , $ this -> options ) ? $ this -> options [ 'class' ] : '' , 'id' => key_exists ( 'id' , $ this -> options ) ? $ this -> options [ 'id' ] : '' , ] ) ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
8559	public function setError ( $ error ) { if ( ! $ this -> _isNumericArray ( $ error ) ) { $ error = array ( $ error ) ; } $ this -> fields [ 'Error' ] [ 'FieldValue' ] = $ error ; return $ this ; }
2394	public function addString ( $ strData , $ strName , $ intTime = 0 ) { ++ $ this -> intCount ; $ strName = strtr ( $ strName , '\\' , '/' ) ; $ arrFile [ 'file_signature' ] = self :: FILE_SIGNATURE ; $ arrFile [ 'version_needed_to_extract' ] = "\x14\x00" ; $ arrFile [ 'general_purpose_bit_flag' ] = "\x00\x00" ; $ arrFile [ 'compression_method' ] = "\x08\x00" ; $ arrFile [ 'last_mod_file_hex' ] = $ this -> unixToHex ( $ intTime ) ; $ arrFile [ 'crc-32' ] = pack ( 'V' , crc32 ( $ strData ) ) ; $ intUncompressed = \ strlen ( $ strData ) ; $ strData = gzcompress ( $ strData ) ; $ strData = substr ( substr ( $ strData , 0 , - 4 ) , 2 ) ; $ intCompressed = \ strlen ( $ strData ) ; $ arrFile [ 'compressed_size' ] = pack ( 'V' , $ intCompressed ) ; $ arrFile [ 'uncompressed_size' ] = pack ( 'V' , $ intUncompressed ) ; $ arrFile [ 'file_name_length' ] = pack ( 'v' , \ strlen ( $ strName ) ) ; $ arrFile [ 'extra_field_length' ] = "\x00\x00" ; $ arrFile [ 'file_name' ] = $ strName ; $ arrFile [ 'extra_field' ] = '' ; $ intOffset = @ ftell ( $ this -> resFile ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrFile ) ) ; fwrite ( $ this -> resFile , $ strData ) ; $ arrHeader [ 'header_signature' ] = self :: CENTRAL_DIR_START ; $ arrHeader [ 'version_made_by' ] = "\x00\x00" ; $ arrHeader [ 'version_needed_to_extract' ] = $ arrFile [ 'version_needed_to_extract' ] ; $ arrHeader [ 'general_purpose_bit_flag' ] = $ arrFile [ 'general_purpose_bit_flag' ] ; $ arrHeader [ 'compression_method' ] = $ arrFile [ 'compression_method' ] ; $ arrHeader [ 'last_mod_file_hex' ] = $ arrFile [ 'last_mod_file_hex' ] ; $ arrHeader [ 'crc-32' ] = $ arrFile [ 'crc-32' ] ; $ arrHeader [ 'compressed_size' ] = $ arrFile [ 'compressed_size' ] ; $ arrHeader [ 'uncompressed_size' ] = $ arrFile [ 'uncompressed_size' ] ; $ arrHeader [ 'file_name_length' ] = $ arrFile [ 'file_name_length' ] ; $ arrHeader [ 'extra_field_length' ] = $ arrFile [ 'extra_field_length' ] ; $ arrHeader [ 'file_comment_length' ] = "\x00\x00" ; $ arrHeader [ 'disk_number_start' ] = "\x00\x00" ; $ arrHeader [ 'internal_file_attributes' ] = "\x00\x00" ; $ arrHeader [ 'external_file_attributes' ] = pack ( 'V' , 32 ) ; $ arrHeader [ 'offset_of_local_header' ] = pack ( 'V' , $ intOffset ) ; $ arrHeader [ 'file_name' ] = $ arrFile [ 'file_name' ] ; $ arrHeader [ 'extra_field' ] = $ arrFile [ 'extra_field' ] ; $ arrHeader [ 'file_comment' ] = '' ; $ this -> strCentralDir .= implode ( '' , $ arrHeader ) ; }
3474	public function handle ( ) { if ( ! $ this -> token ) { $ this -> error ( 'You must paste your Discord token (App Bot User token) into your `services.php` config file.' ) ; $ this -> error ( 'View the README for more info: https://github.com/laravel-notification-channels/discord#installation' ) ; return - 1 ; } if ( ! $ this -> confirm ( 'Is the bot already added to your server?' ) ) { $ clientId = $ this -> ask ( 'What is your Discord app client ID?' ) ; $ this -> warn ( 'Add the bot to your server by visiting this link: https://discordapp.com/oauth2/authorize?&client_id=' . $ clientId . '&scope=bot&permissions=0' ) ; if ( ! $ this -> confirm ( 'Continue?' , true ) ) { return - 1 ; } } $ this -> warn ( "Attempting to identify the bot with Discord's websocket gateway..." ) ; $ this -> gateway = $ this -> getGateway ( ) ; $ this -> warn ( "Connecting to '$this->gateway'..." ) ; $ client = $ this -> getSocket ( $ this -> gateway ) ; $ client -> send ( json_encode ( [ 'op' => 2 , 'd' => [ 'token' => $ this -> token , 'v' => 3 , 'compress' => false , 'properties' => [ '$os' => PHP_OS , '$browser' => 'laravel-notification-channels-discord' , '$device' => 'laravel-notification-channels-discord' , '$referrer' => '' , '$referring_domain' => '' , ] , ] , ] ) ) ; $ response = $ client -> receive ( ) ; $ identified = Arr :: get ( json_decode ( $ response , true ) , 'op' ) === 10 ; if ( ! $ identified ) { $ this -> error ( "Discord responded with an error while trying to identify the bot: $response" ) ; return - 1 ; } $ this -> info ( 'Your bot has been identified by Discord and can now send API requests!' ) ; }
5613	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ node = new TreemapNode ( 'Assertion' , $ message , false ) ; $ current = $ this -> _stack -> peek ( ) ; $ current -> putChild ( $ node ) ; $ current -> fail ( ) ; }
11867	public function unlock ( string $ sessionIdentifier ) : void { $ index = array_search ( $ sessionIdentifier , self :: $ lockedIdentifiers ) ; if ( $ index !== false ) { unset ( self :: $ lockedIdentifiers [ $ index ] ) ; } }
11113	public function runPending ( array $ migrations , array $ options = [ ] ) { if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to migrate.</info>' ) ; return ; } $ batch = $ this -> repository -> getNextBatchNumber ( ) ; $ step = $ options [ 'step' ] ?? false ; $ this -> notify -> note ( '' ) ; foreach ( $ migrations as $ file ) { $ this -> runUp ( $ file , $ batch ) ; if ( $ step ) { $ batch ++ ; } } }
10127	private function writeWsbool ( ) { $ record = 0x0081 ; $ length = 0x0002 ; $ grbit = 0x0000 ; $ grbit |= 0x0001 ; if ( $ this -> outlineStyle ) { $ grbit |= 0x0020 ; } if ( $ this -> phpSheet -> getShowSummaryBelow ( ) ) { $ grbit |= 0x0040 ; } if ( $ this -> phpSheet -> getShowSummaryRight ( ) ) { $ grbit |= 0x0080 ; } if ( $ this -> phpSheet -> getPageSetup ( ) -> getFitToPage ( ) ) { $ grbit |= 0x0100 ; } if ( $ this -> outlineOn ) { $ grbit |= 0x0400 ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
11134	protected function calculateSELECT ( ) { $ this -> query .= 'SELECT ' ; if ( $ this -> distinct ) { $ this -> query .= ' DISTINCT ' ; } $ this -> queryStringFromArray ( 'selects' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'tables' , ' FROM ' , ', ' ) ; $ this -> joinStringFromArray ( 'joins' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'groupBys' , ' GROUP BY ' , ', ' ) ; $ this -> conditionStringFromArray ( 'havings' , ' HAVING ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } if ( $ this -> offset ) { $ this -> query .= ' OFFSET ' . $ this -> offset ; } }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
8494	public function createFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_CreateFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_CreateFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5673	protected function describeArrayDifference ( $ first , $ second , $ identical ) { if ( ! is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } if ( ! $ this -> isMatchingKeys ( $ first , $ second , $ identical ) ) { return sprintf ( 'as key list [%s] does not match key list [%s]' , implode ( ', ' , array_keys ( $ first ) ) , implode ( ', ' , array_keys ( $ second ) ) ) ; } foreach ( array_keys ( $ first ) as $ key ) { if ( $ identical && ( $ first [ $ key ] === $ second [ $ key ] ) ) { continue ; } if ( ! $ identical && ( $ first [ $ key ] == $ second [ $ key ] ) ) { continue ; } return sprintf ( 'with member [%s] %s' , $ key , $ this -> describeDifference ( $ first [ $ key ] , $ second [ $ key ] , $ identical ) ) ; } return '' ; }
3134	public function getItemData ( RunnerServiceContext $ context , $ itemRef ) { if ( $ context instanceof QtiRunnerServiceContext ) { return $ this -> loadItemData ( $ itemRef , QtiJsonItemCompiler :: ITEM_FILE_NAME ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getItemData' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
3664	private function getValueFromSource ( $ source , $ valueName , $ arguments ) { switch ( strtolower ( $ source ) ) { case 'get' : return $ this -> container -> get ( Input :: class ) -> get ( $ valueName ) ; case 'post' : return $ this -> container -> get ( Input :: class ) -> post ( $ valueName ) ; case 'cookie' : return $ this -> container -> get ( Input :: class ) -> cookie ( $ valueName ) ; case 'session' : return $ this -> container -> get ( Session :: class ) -> get ( $ valueName ) ; case 'filter' : if ( is_array ( $ this -> filterParameters ) ) { if ( array_key_exists ( $ valueName , $ this -> filterParameters ) ) { return $ this -> filterParameters [ $ valueName ] ; } return null ; } break ; case 'container' : @ trigger_error ( 'Getting filter values from the service container is deprecated, the container will get removed.' , E_USER_DEPRECATED ) ; return $ this -> getValueFromServiceContainer ( $ valueName , $ arguments ) ; default : } return null ; }
9066	public function persist ( MessageInterface $ message ) { if ( $ message -> getMessageId ( ) > 0 ) { $ this -> update ( $ message , null , null , new MessageHydrator ) ; } else { $ this -> insert ( $ message , null , new MessageHydrator ) ; } return $ message ; }
271	protected function renderSeparator ( $ spanLeft , $ spanMid , $ spanMidMid , $ spanRight ) { $ separator = $ spanLeft ; foreach ( $ this -> _columnWidths as $ index => $ rowSize ) { if ( $ index !== 0 ) { $ separator .= $ spanMid ; } $ separator .= str_repeat ( $ spanMidMid , $ rowSize ) ; } $ separator .= $ spanRight . "\n" ; return $ separator ; }
289	protected function isLanguageSupported ( $ requested , $ supported ) { $ supported = str_replace ( '_' , '-' , strtolower ( $ supported ) ) ; $ requested = str_replace ( '_' , '-' , strtolower ( $ requested ) ) ; return strpos ( $ requested . '-' , $ supported . '-' ) === 0 ; }
5950	public function addMediaResponse ( $ item ) { if ( ! ( $ item instanceof MediaResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new MediaResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MediaResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "MediaResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
7213	public function configure ( $ subject ) { if ( $ subject instanceof InvoiceInterface ) { $ this -> date = $ subject -> getCreatedAt ( ) -> format ( 'Y-m-d' ) ; } elseif ( $ subject instanceof PaymentInterface ) { $ this -> date = $ subject -> getCompletedAt ( ) -> format ( 'Y-m-d' ) ; } else { throw new InvalidArgumentException ( "Expected instance of " . InvoiceInterface :: class . " or " . PaymentInterface :: class ) ; } $ this -> number = $ subject -> getNumber ( ) ; $ sale = $ subject -> getSale ( ) ; if ( $ customer = $ sale -> getCustomer ( ) ) { $ this -> identity = $ customer -> getFirstName ( ) . ' ' . $ customer -> getLastName ( ) ; } else { $ this -> identity = $ sale -> getFirstName ( ) . ' ' . $ sale -> getLastName ( ) ; } }
3873	private function getBaseUrl ( $ pageDetails , $ path = null , $ ignoreSSL = false ) { $ url = new UrlBuilder ( ) ; if ( $ pageDetails [ 'domain' ] ) { $ url -> setHost ( $ pageDetails [ 'domain' ] ) ; } else { $ url -> setHost ( \ Environment :: get ( 'host' ) ) ; } if ( $ pageDetails [ 'rootUseSSL' ] && ! $ ignoreSSL ) { $ url -> setScheme ( 'https' ) ; } else { $ url -> setScheme ( 'http' ) ; } $ fullPath = array ( ) ; $ fullPath [ ] = TL_PATH ; if ( $ path === null ) { $ event = new GenerateFrontendUrlEvent ( $ pageDetails , null , $ pageDetails [ 'language' ] , true ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GENERATE_FRONTEND_URL , $ event ) ; $ fullPath [ ] = $ event -> getUrl ( ) ; } else { $ fullPath [ ] = $ path ; } $ url -> setPath ( implode ( '/' , $ fullPath ) ) ; return $ url ; }
11182	public function cacheActions ( DirectCollection $ collection ) { $ serializedCollection = serialize ( $ collection ) ; $ this -> set ( Keys :: EXT_ACTION , $ serializedCollection ) ; }
181	public function getConverter ( ) { if ( $ this -> _converter === null ) { $ this -> _converter = Yii :: createObject ( AssetConverter :: className ( ) ) ; } elseif ( is_array ( $ this -> _converter ) || is_string ( $ this -> _converter ) ) { if ( is_array ( $ this -> _converter ) && ! isset ( $ this -> _converter [ 'class' ] ) ) { $ this -> _converter [ 'class' ] = AssetConverter :: className ( ) ; } $ this -> _converter = Yii :: createObject ( $ this -> _converter ) ; } return $ this -> _converter ; }
6788	protected function getCustomerGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof CustomerGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . CustomerGroupInterface :: class ) ; } return $ resource ; }
6919	public function getAdjustments ( $ type = null ) { if ( null !== $ type ) { AdjustmentTypes :: isValidType ( $ type ) ; return $ this -> adjustments -> filter ( function ( AdjustmentInterface $ a ) use ( $ type ) { return $ a -> getType ( ) === $ type ; } ) ; } return $ this -> adjustments ; }
8139	public function load ( $ name ) { if ( $ name instanceof Twig_TemplateWrapper ) { return $ name ; } if ( $ name instanceof Twig_Template ) { return new Twig_TemplateWrapper ( $ this , $ name ) ; } return new Twig_TemplateWrapper ( $ this , $ this -> loadTemplate ( $ name ) ) ; }
6909	public function removeCopy ( Recipient $ copy ) { if ( $ this -> copies -> contains ( $ copy ) ) { $ this -> copies -> removeElement ( $ copy ) ; } return $ this ; }
5433	public function isAbstractMethodInParents ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ parent = $ interface -> getParentClass ( ) ; while ( $ parent ) { if ( ! $ parent -> hasMethod ( $ name ) ) { return false ; } if ( $ parent -> getMethod ( $ name ) -> isAbstract ( ) ) { return true ; } $ parent = $ parent -> getParentClass ( ) ; } return false ; }
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
9550	public function getPdo ( ) { if ( empty ( $ this -> pdo ) ) { $ this -> pdo = new PDO ( sprintf ( "mysql:host=%s;port=%d" , $ this -> host , $ this -> port ) ) ; $ this -> pdo -> setAttribute ( PDO :: ATTR_DEFAULT_FETCH_MODE , PDO :: FETCH_ASSOC ) ; } return $ this -> pdo ; }
8495	public function getFulfillmentOrder ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentOrderRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentOrder' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentOrderResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4084	public function getParentOf ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> childMap [ $ metaModelName ] ) ? $ this -> childMap [ $ metaModelName ] : null ; }
9615	public function addManagerRegistry ( ManagerRegistry $ registry ) { if ( ! in_array ( $ registry , $ this -> registries , true ) ) { $ this -> registries [ ] = $ registry ; } }
9440	protected function value ( $ name ) { $ object = isset ( $ this -> instances [ $ name ] ) ? $ this -> get ( $ name ) : null ; $ exists = ! $ object && $ this -> extra -> has ( $ name ) === true ; return $ exists === true ? $ this -> extra -> get ( $ name ) : $ object ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
9234	public function actionUpdate ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> tags = ! empty ( $ model -> tags ) ? explode ( "," , $ model -> tags ) : [ ] ; if ( Yii :: $ app -> request -> post ( ) ) { $ post = Yii :: $ app -> request -> post ( ) ; $ category = [ ] ; if ( isset ( $ post [ 'Post' ] [ 'category' ] ) ) { $ category = $ post [ 'Post' ] [ 'category' ] ; } if ( is_array ( $ post [ 'Post' ] [ 'tags' ] ) ) { $ post [ 'Post' ] [ 'tags' ] = implode ( "," , $ post [ 'Post' ] [ 'tags' ] ) ; } $ model -> load ( $ post ) ; $ transaction = Yii :: $ app -> db -> beginTransaction ( ) ; try { if ( $ model -> save ( ) ) { $ cs = BlogCatPos :: deleteAll ( "post_id = :id" , [ "id" => $ model -> id ] ) ; foreach ( $ category as $ d ) { $ c = new BlogCatPos ( ) ; $ c -> post_id = $ model -> id ; $ c -> category_id = $ d ; $ c -> isdel = 0 ; $ c -> save ( ) ; } $ transaction -> commit ( ) ; return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { $ transaction -> rollBack ( ) ; } } catch ( Exception $ e ) { $ transaction -> rollBack ( ) ; } } return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; }
7943	public function deleteSecondaryDnsDomains ( $ domain , $ domain2delete ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2delete = ( string ) $ domain2delete ; if ( ! $ domain2delete ) throw new BadMethodCallException ( 'Parameter $domain2getInfo is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains/' . $ domain2delete ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
5004	protected function createEventManager ( $ services , $ config ) { if ( $ services -> has ( $ config [ 'service' ] ) ) { $ events = $ services -> get ( $ config [ 'service' ] ) ; } else { if ( ! class_exists ( $ config [ 'service' ] , true ) ) { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create event manager instance.' , $ config [ 'service' ] ) ) ; } $ events = new $ config [ 'service' ] ( ) ; } if ( false === $ config [ 'configure' ] ) { return $ events ; } $ events -> setIdentifiers ( $ config [ 'identifiers' ] ) ; $ event = $ services -> has ( $ config [ 'event' ] ) ? $ services -> get ( $ config [ 'event' ] ) : new $ config [ 'event' ] ( ) ; $ events -> setEventPrototype ( $ event ) ; if ( 'EventManager' != $ config [ 'service' ] && method_exists ( $ events , 'setSharedManager' ) && $ services -> has ( 'SharedEventManager' ) ) { $ sharedEvents = $ services -> get ( 'SharedEventManager' ) ; $ events -> setSharedManager ( $ sharedEvents ) ; } return $ events ; }
7681	function TbsPrepareMergeCell ( & $ Txt , & $ Loc ) { if ( $ this -> ExtEquiv == 'docx' ) { $ xml = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'w:tcPr' , $ Loc -> PosBeg , false ) ; if ( $ xml ) { $ Txt = substr_replace ( $ Txt , '' , $ Loc -> PosBeg , $ Loc -> PosEnd - $ Loc -> PosBeg + 1 ) ; $ Loc -> PosBeg = $ xml -> PosEnd + 1 ; $ Loc -> PosEnd = $ xml -> PosEnd ; $ this -> PrevVals [ $ Loc -> FullName ] = '' ; $ Loc -> ConvStr = false ; } } }
9679	function fromXML ( $ xmlElement ) { $ this -> contact = new ReportContact ( ) ; $ this -> contact -> fromXML ( $ xmlElement -> contact ) ; if ( isset ( $ xmlElement -> mailing_id ) ) $ this -> mailingId = $ xmlElement -> mailing_id ; if ( isset ( $ xmlElement -> source ) ) $ this -> source = $ xmlElement -> source ; if ( isset ( $ xmlElement -> timestamp ) ) $ this -> timestamp = $ xmlElement -> timestamp ; }
279	private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; }
330	public function get ( $ key ) { $ key = $ this -> buildKey ( $ key ) ; $ value = $ this -> getValue ( $ key ) ; if ( $ value === false || $ this -> serializer === false ) { return $ value ; } elseif ( $ this -> serializer === null ) { $ value = unserialize ( $ value ) ; } else { $ value = call_user_func ( $ this -> serializer [ 1 ] , $ value ) ; } if ( is_array ( $ value ) && ! ( $ value [ 1 ] instanceof Dependency && $ value [ 1 ] -> isChanged ( $ this ) ) ) { return $ value [ 0 ] ; } return false ; }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
11439	public function getErrors ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> errors ) ; } else { return $ this -> errors ; } }
9286	public function create ( ) { $ adapter = $ this -> dbAdapter ; $ ddl = new Ddl \ CreateTable ( ) ; $ ddl -> setTable ( self :: TABLE_NAME ) -> addColumn ( new Column \ Integer ( 'id' , false , null , array ( 'autoincrement' => true ) ) ) -> addColumn ( new Column \ Varchar ( 'code' , 55 ) ) -> addColumn ( new Column \ Varchar ( 'status' , 55 ) ) -> addColumn ( new Column \ Text ( 'error_msg' ) ) -> addColumn ( new Column \ Text ( 'stack_trace' ) ) -> addColumn ( new Column \ Varchar ( 'created' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'scheduled' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'executed' , 255 ) ) -> addColumn ( new Column \ Varchar ( 'finished' , 255 ) ) -> addConstraint ( new Constraint \ PrimaryKey ( 'id' ) ) ; $ sql = ( new Sql ( $ adapter ) ) -> getSqlStringForSqlObject ( $ ddl ) ; $ adapter -> query ( $ sql , $ adapter :: QUERY_MODE_EXECUTE ) ; }
2022	public static function findFirstPublishedRootByHostAndLanguage ( $ strHost , $ varLanguage , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using PageModel::findFirstPublishedRootByHostAndLanguage() has been deprecated and will no longer work Contao 5.0.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; if ( \ is_array ( $ varLanguage ) ) { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='')" ) ; if ( ! empty ( $ varLanguage ) ) { $ arrColumns [ ] = "($t.language IN('" . implode ( "','" , $ varLanguage ) . "') OR $t.fallback='1')" ; } else { $ arrColumns [ ] = "$t.fallback='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC" . ( ! empty ( $ varLanguage ) ? ", " . $ objDatabase -> findInSet ( "$t.language" , array_reverse ( $ varLanguage ) ) . " DESC" : "" ) . ", $t.sorting" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ strHost , $ arrOptions ) ; } else { $ arrColumns = array ( "$t.type='root' AND ($t.dns=? OR $t.dns='') AND ($t.language=? OR $t.fallback='1')" ) ; $ arrValues = array ( $ strHost , $ varLanguage ) ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.dns DESC, $t.fallback" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; } }
7410	public function offsetSet ( $ k , $ v ) { if ( null === $ k || ! array_key_exists ( $ k , $ this -> _container ) ) { $ v = ( is_object ( $ v ) && get_class ( $ v ) === $ this -> _type ) ? $ v : new $ this -> _type ( $ v ) ; if ( null === $ k ) { $ this -> _container [ ] = $ v ; } else { $ this -> _container [ $ k ] = $ v ; } return ; } if ( is_a ( $ this -> _type , AtomicInterface :: class , true ) ) { $ this -> _container [ $ k ] -> set ( $ v ) ; return ; } if ( is_a ( $ this -> _type , TypedAbstract :: class , true ) ) { $ this -> _container [ $ k ] -> replace ( $ v ) ; return ; } $ this -> _container [ $ k ] = new $ this -> _type ( $ v ) ; }
9371	public function integrate ( $ integrations , ConfigurationInterface $ config = null ) { list ( $ config , $ container ) = array ( $ config ? : $ this -> config , static :: $ container ) ; foreach ( ( array ) $ integrations as $ item ) { $ integration = is_string ( $ item ) ? new $ item : $ item ; $ container = $ integration -> define ( $ container , $ config ) ; } static :: $ container = $ container ; return $ this ; }
4012	private function calculatePaginated ( ) { $ this -> calculatedTotal = $ this -> getTotalAmount ( ) ; if ( ( $ this -> calculatedLimit !== null ) && ( $ this -> calculatedTotal > $ this -> calculatedLimit ) ) { $ this -> calculatedTotal -= $ this -> calculatedLimit ; } $ this -> calculatedTotal -= $ this -> calculatedOffset ; $ page = $ this -> getCurrentPage ( ) ; if ( $ page > ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ) { $ page = ( int ) ceil ( $ this -> calculatedTotal / $ this -> getPerPage ( ) ) ; } $ pageOffset = ( ( max ( $ page , 1 ) - 1 ) * $ this -> getPerPage ( ) ) ; $ this -> calculatedOffset += $ pageOffset ; if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = $ this -> getPerPage ( ) ; } else { $ this -> calculatedLimit = min ( ( $ this -> calculatedLimit - $ this -> calculatedOffset ) , $ this -> getPerPage ( ) ) ; } }
12831	private function onTokenFound ( $ token ) { if ( is_array ( $ token ) ) $ token = array_pop ( $ token ) ; $ token = trim ( $ token ) ; $ tokenParts = explode ( ' ' , $ token ) ; $ tag = array_shift ( $ tokenParts ) ; $ params = implode ( ' ' , $ tokenParts ) ; if ( $ this -> _blocks -> has ( $ tag ) ) { if ( $ this -> _blocks -> getDeepValue ( $ tag . '/runtime' ) ) { $ res = '<?php $this->_compiler->invokeBlock(\'' . $ tag . '\', ' . $ this -> compileExpression ( $ params ) . '); ?>' ; } else { $ res = $ this -> onBlockTagOpen ( $ tag , $ params ) ; } } elseif ( substr ( $ tag , 0 , strlen ( $ this -> _config [ 'blockClose' ] ) ) == $ this -> _config [ 'blockClose' ] ) { $ tag = substr ( $ tag , strlen ( $ this -> _config [ 'blockClose' ] ) ) ; $ res = $ this -> onBlockTagClose ( $ tag , $ params ) ; } else { $ res = $ this -> onVarEchoToken ( $ token , $ params ) ; } return $ res ; }
6867	protected function getSaleFromInvoice ( InvoiceInterface $ invoice ) { if ( null === $ sale = $ invoice -> getSale ( ) ) { $ cs = $ this -> persistenceHelper -> getChangeSet ( $ invoice , $ this -> getSalePropertyPath ( ) ) ; if ( ! empty ( $ cs ) ) { $ sale = $ cs [ 0 ] ; } } if ( ! $ sale instanceof SaleInterface ) { throw new Exception \ RuntimeException ( "Failed to retrieve invoice's sale." ) ; } return $ sale ; }
3430	protected function rememberInCache ( $ key , $ minutes , Closure $ callback ) { $ minutes = ( double ) $ minutes ; if ( $ minutes <= 0 ) { return $ callback ( ) ; } $ cache = Cache :: createInstance ( ) ; if ( $ cache -> initCache ( $ minutes * 60 , $ key , '/bitrix-models' ) ) { $ vars = $ cache -> getVars ( ) ; return ! empty ( $ vars [ 'isCollection' ] ) ? new Collection ( $ vars [ 'cache' ] ) : $ vars [ 'cache' ] ; } $ cache -> startDataCache ( ) ; $ result = $ callback ( ) ; $ isCollection = $ result instanceof Collection ; if ( $ isCollection ) { $ result = $ result -> all ( ) ; } $ cache -> endDataCache ( [ 'cache' => $ result , 'isCollection' => $ isCollection ] ) ; return $ isCollection ? new Collection ( $ result ) : $ result ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
7066	public function getUserRights ( ) { if ( ! $ this -> _UserRights ) { if ( Configure :: load ( 'user_rights' ) === false ) { trigger_error ( 'UserRights: Could not load config/user_rights.php' , E_USER_WARNING ) ; } $ rightsConfig = Configure :: read ( 'user_rights' ) ; if ( ! is_array ( $ rightsConfig ) ) { $ rightsConfig = [ ] ; } $ this -> _UserRights = new UserRights ( $ rightsConfig ) ; } return $ this -> _UserRights ; }
6416	public static function skip ( IteratorAggregate $ iterable , int $ numberToSkip ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ numberToSkip ) { $ iterator = Iterators :: from ( $ iterable -> getIterator ( ) ) ; Iterators :: advance ( $ iterator , $ numberToSkip ) ; return $ iterator ; } ) ; }
1827	public function markModified ( $ strKey ) { if ( ! isset ( $ this -> arrModified [ $ strKey ] ) ) { $ this -> arrModified [ $ strKey ] = $ this -> arrData [ $ strKey ] ?? null ; } }
6760	static public function buildCacheKey ( $ columns = '*' , array $ conditionsAndOptions = [ ] ) { foreach ( $ conditionsAndOptions as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$conditionsAndOptions argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; if ( is_array ( $ columns ) ) { foreach ( $ columns as & $ value ) { if ( $ value instanceof DbExpr ) { $ value = $ value -> get ( ) ; } else if ( is_object ( $ value ) ) { throw new \ InvalidArgumentException ( '$columns argument may contain only strings and objects of class \PeskyORM\Core\DbExpr.' . ' Object of class ' . get_class ( $ value ) . ' detected' ) ; } } unset ( $ value ) ; } else if ( $ columns instanceof DbExpr ) { $ columns = $ columns -> get ( ) ; } return hash ( 'sha256' , json_encode ( array ( $ columns , $ conditionsAndOptions ) ) ) ; }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
2852	public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
11811	protected function loadLocalObject ( ) { if ( $ this -> _isLoadingLocalObject ) { throw new RecursionException ( 'Ran into recursion while loading local object' ) ; } $ this -> _isLoadingLocalObject = true ; if ( isset ( $ this -> foreignObject ) && ! isset ( $ this -> _localObject ) ) { $ keyTranslation = $ this -> dataSource -> getKeyTranslation ( $ this -> foreignObject ) ; if ( ! empty ( $ keyTranslation ) && ( $ localObject = $ keyTranslation -> object ) ) { $ this -> localObject = $ localObject ; } } $ this -> _isLoadingLocalObject = false ; }
6036	public function addCommand ( $ item ) { if ( ! ( $ item instanceof Command ) ) { if ( is_array ( $ item ) ) { try { $ item = new Command ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Command. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Command"!' , E_USER_WARNING ) ; } } $ this -> commands [ ] = $ item ; return $ this ; }
2794	public function setTempDirectory ( $ dir ) { $ dir = rtrim ( $ dir , ' \\/' ) ; if ( ! is_dir ( $ dir ) || ! is_readable ( $ dir ) ) { throw new InvalidArgumentException ( 'Invalid cache directory: "' . $ dir . '"' ) ; } $ this -> tempDirectory = $ dir ; return $ this ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
1036	private function completeAbstractValue ( AbstractType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ exeContext = $ this -> exeContext ; $ runtimeType = $ returnType -> resolveType ( $ result , $ exeContext -> contextValue , $ info ) ; if ( $ runtimeType === null ) { $ runtimeType = self :: defaultTypeResolver ( $ result , $ exeContext -> contextValue , $ info , $ returnType ) ; } $ promise = $ this -> getPromise ( $ runtimeType ) ; if ( $ promise ) { return $ promise -> then ( function ( $ resolvedRuntimeType ) use ( $ returnType , $ fieldNodes , $ info , $ path , & $ result ) { return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ resolvedRuntimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; } ) ; } return $ this -> completeObjectValue ( $ this -> ensureValidRuntimeType ( $ runtimeType , $ returnType , $ info , $ result ) , $ fieldNodes , $ info , $ path , $ result ) ; }
8399	public function display ( Environment $ environment , $ template , $ type = null , $ size = 'md' , $ object = null ) { $ tools = $ environment -> render ( $ template , array ( 'type' => $ type , 'object' => $ object , ) ) ; return $ environment -> render ( '@c975LToolbar/toolbar.html.twig' , array ( 'tools' => $ tools , 'size' => $ size , ) ) ; }
6224	public function removeDir ( ) : bool { if ( ! $ this -> isDir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to remove directory for path: "%s"' , $ this -> path -> raw ) , 500 ) ; } try { $ iterator = $ this -> getIterator ( true , \ RecursiveIteratorIterator :: CHILD_FIRST ) ; foreach ( $ iterator as $ splFile ) { if ( ! $ splFile -> isReadable ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to access file for path: "%s"' , $ splFile -> getPathname ( ) ) , 500 ) ; } switch ( $ splFile -> getType ( ) ) { case 'dir' : rmdir ( $ splFile -> getRealPath ( ) ) ; break ; case 'link' : unlink ( $ splFile -> getPathname ( ) ) ; break ; default : unlink ( $ splFile -> getRealPath ( ) ) ; } } return rmdir ( $ this -> path -> raw ) ; } finally { $ this -> selfdestruct = false ; $ this -> path -> reload ( ) ; } }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
2080	public function purgeRegistrations ( ) { $ objMember = MemberModel :: findExpiredRegistrations ( ) ; if ( $ objMember === null ) { return ; } while ( $ objMember -> next ( ) ) { $ objMember -> delete ( ) ; } $ this -> log ( 'Purged the unactivated member registrations' , __METHOD__ , TL_CRON ) ; }
4394	public function capture ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsCapture ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> capture ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; $ order -> setPaymentStatus ( $ status ) ; } }
11056	public function urlFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_URL ) ; }
8221	protected function getEntityId ( $ blockType , $ config , $ params = array ( ) ) { $ entityId = null ; if ( $ blockType === "account" && isset ( $ params [ "name" ] ) ) { $ entityId = md5 ( $ params [ "name" ] ) ; } elseif ( $ blockType === "email" && isset ( $ params [ "email" ] ) ) { $ entityId = md5 ( $ params [ "email" ] ) ; } elseif ( $ blockType === "ip" ) { $ entityId = $ this -> getIp ( $ config ) ; } return $ entityId ; }
471	public function down ( ) { $ transaction = $ this -> db -> beginTransaction ( ) ; try { if ( $ this -> safeDown ( ) === false ) { $ transaction -> rollBack ( ) ; return false ; } $ transaction -> commit ( ) ; } catch ( \ Exception $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } catch ( \ Throwable $ e ) { $ this -> printException ( $ e ) ; $ transaction -> rollBack ( ) ; return false ; } return null ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
8329	public function whereExists ( Closure $ callback , $ boolean = 'and' , $ not = false ) { $ type = $ not ? 'NotExists' : 'Exists' ; $ this -> wheres [ ] = compact ( 'type' , 'callback' , 'boolean' ) ; return $ this ; }
982	public function index ( Plan $ plan ) { if ( is_null ( $ plan ) || ( $ plan && ! $ plan -> exists ) ) { $ plan = Plan :: where ( 'on_install' , true ) -> first ( ) ; } $ bp = new BillingPlan ( ShopifyApp :: shop ( ) , $ plan ) ; $ url = $ bp -> confirmationUrl ( ) ; return View :: make ( 'shopify-app::billing.fullpage_redirect' , compact ( 'url' ) ) ; }
4500	public function matches ( string $ selectors ) : bool { $ matches = $ this -> getRootDocument ( ) -> querySelectorAll ( $ selectors ) ; $ i = $ matches -> length ; while ( -- $ i >= 0 && $ matches -> item ( $ i ) !== $ this ) { ; } return ( $ i >= 0 ) ; }
11960	public function reduce ( Closure $ fn , $ initial = null ) { return array_reduce ( $ this -> elements , $ fn , $ initial ) ; }
8482	public static function getOS ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Caption FROM Win32_OperatingSystem" ) as $ os ) { return $ os -> Caption ; } return "Windows" ; }
12264	public function addSource ( $ sourcePath , $ useStrict = true ) { if ( is_link ( $ sourcePath ) ) { return $ this -> addSource ( realpath ( $ sourcePath ) , $ useStrict ) ; } if ( is_dir ( $ sourcePath ) ) { $ this -> sourceDirs [ ] = $ sourcePath ; } elseif ( true === $ useStrict ) { throw new \ Exception ( sprintf ( 'Path {%s} is not a readable directory' , $ sourcePath ) ) ; } return $ this ; }
740	protected function saveRules ( ) { $ rules = [ ] ; foreach ( $ this -> rules as $ name => $ rule ) { $ rules [ $ name ] = serialize ( $ rule ) ; } $ this -> saveToFile ( $ rules , $ this -> ruleFile ) ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
7884	public function getShow ( $ date , $ level = null ) { $ logs = LogViewer :: logs ( ) ; if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ page = Input :: get ( 'page' ) ; if ( empty ( $ page ) ) { $ page = '1' ; } $ data = [ 'logs' => $ logs , 'date' => $ date , 'url' => 'logviewer' , 'data_url' => URL :: route ( 'logviewer.index' ) . '/data/' . $ date . '/' . $ level . '?page=' . $ page , 'levels' => LogViewer :: levels ( ) , 'current' => $ level , ] ; return View :: make ( 'logviewer::show' , $ data ) ; }
498	public function applyTo ( $ path ) { $ pathMap = $ this -> pathMap ; if ( empty ( $ pathMap ) ) { if ( ( $ basePath = $ this -> getBasePath ( ) ) === null ) { throw new InvalidConfigException ( 'The "basePath" property must be set.' ) ; } $ pathMap = [ Yii :: $ app -> getBasePath ( ) => [ $ basePath ] ] ; } $ path = FileHelper :: normalizePath ( $ path ) ; foreach ( $ pathMap as $ from => $ tos ) { $ from = FileHelper :: normalizePath ( Yii :: getAlias ( $ from ) ) . DIRECTORY_SEPARATOR ; if ( strpos ( $ path , $ from ) === 0 ) { $ n = strlen ( $ from ) ; foreach ( ( array ) $ tos as $ to ) { $ to = FileHelper :: normalizePath ( Yii :: getAlias ( $ to ) ) . DIRECTORY_SEPARATOR ; $ file = $ to . substr ( $ path , $ n ) ; if ( is_file ( $ file ) ) { return $ file ; } } } } return $ path ; }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
2991	private function encodeRecord ( $ record , $ childName , & $ xml ) { foreach ( $ record as $ key => $ value ) { if ( $ value instanceof \ DateTime ) { if ( $ value -> format ( 'His' ) === '000000' ) { $ value = $ value -> format ( 'm/d/Y' ) ; } else { $ value = $ value -> format ( 'Y-m-d H:i:s' ) ; } } $ keyValue = $ xml -> addChild ( $ childName ) ; $ keyValue -> addAttribute ( 'val' , $ key ) ; if ( is_array ( $ value ) ) { $ this -> parseNestedValues ( $ value , $ keyValue ) ; } else { $ keyValue [ 0 ] = $ value ; } } }
3779	protected function getParameterFilterOptions ( $ objAttribute , $ arrIds , & $ arrCount = null ) { $ arrOptions = $ objAttribute -> getFilterOptions ( $ this -> get ( 'onlypossible' ) ? $ arrIds : null , ( bool ) $ this -> get ( 'onlyused' ) , $ arrCount ) ; foreach ( $ arrOptions as $ mixOptionKey => $ mixOptions ) { $ mixOptions = strip_tags ( $ mixOptions ) ; $ mixOptions = trim ( $ mixOptions ) ; if ( $ mixOptions === '' || $ mixOptions === null ) { unset ( $ arrOptions [ $ mixOptionKey ] ) ; } } return $ arrOptions ; }
12608	public function getChild ( $ type ) { if ( isset ( $ this -> _children [ $ type ] ) ) { return $ this -> _children [ $ type ] ; } return false ; }
8027	public function killAllProcesses ( ) { foreach ( $ this -> processDetails as $ pid => $ processDetails ) { $ this -> remove ( $ processDetails ) ; posix_kill ( $ pid , SIGKILL ) ; } }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
1012	private function readDigits ( ) { [ $ char , $ code ] = $ this -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { $ value = '' ; do { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } while ( $ code >= 48 && $ code <= 57 ) ; return $ value ; } if ( $ this -> position > $ this -> source -> length - 1 ) { $ code = null ; } throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, expected digit but got: ' . Utils :: printCharCode ( $ code ) ) ; }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
3987	public function getCombination ( $ tableName ) { $ combinations = $ this -> getCombinations ( ) ; if ( isset ( $ combinations [ 'byName' ] [ $ tableName ] ) ) { return $ combinations [ 'byName' ] [ $ tableName ] ; } return null ; }
7301	static public function getTargetsForSale ( SaleInterface $ sale ) { if ( $ sale instanceof CartInterface ) { return [ static :: TARGET_ORDER , static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof OrderInterface ) { if ( $ sale -> getState ( ) !== OrderStates :: STATE_NEW ) { return [ ] ; } return [ static :: TARGET_QUOTE ] ; } elseif ( $ sale instanceof QuoteInterface ) { return [ static :: TARGET_ORDER ] ; } throw new InvalidArgumentException ( "Unexpected sale type." ) ; }
7519	function parse_doctype ( ) { $ start = $ this -> pos ; if ( $ this -> next_search ( '[>' , false ) === self :: TOK_UNKNOWN ) { if ( $ this -> doc [ $ this -> pos ] === '[' ) { if ( ( $ this -> next_pos ( ']' , false ) !== self :: TOK_UNKNOWN ) || ( $ this -> next_pos ( '>' , false ) !== self :: TOK_UNKNOWN ) ) { $ this -> addError ( 'Invalid doctype' ) ; return false ; } } $ this -> token_start = $ start ; $ this -> status [ 'dtd' ] = $ this -> getTokenString ( 2 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'Invalid doctype' ) ; return false ; } }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
2641	public function cleanBySurrogateKey ( $ keys ) { $ type = 'clean by key on ' ; $ uri = $ this -> _getApiServiceUri ( ) . 'purge' ; $ num = count ( $ keys ) ; $ result = false ; if ( $ num >= self :: FASTLY_MAX_HEADER_KEY_SIZE ) { $ parts = $ num / self :: FASTLY_MAX_HEADER_KEY_SIZE ; $ additional = ( $ parts > ( int ) $ parts ) ? 1 : 0 ; $ parts = ( int ) $ parts + ( int ) $ additional ; $ chunks = ceil ( $ num / $ parts ) ; $ collection = array_chunk ( $ keys , $ chunks ) ; } else { $ collection = [ $ keys ] ; } foreach ( $ collection as $ keys ) { $ payload = json_encode ( [ 'surrogate_keys' => $ keys ] ) ; $ result = $ this -> _purge ( $ uri , null , \ Zend_Http_Client :: POST , $ payload ) ; if ( $ result [ 'status' ] ) { foreach ( $ keys as $ key ) { $ this -> logger -> execute ( 'surrogate key: ' . $ key ) ; } } $ canPublishKeyUrlChanges = $ this -> config -> canPublishKeyUrlChanges ( ) ; $ canPublishPurgeChanges = $ this -> config -> canPublishPurgeChanges ( ) ; if ( $ this -> config -> areWebHooksEnabled ( ) && ( $ canPublishKeyUrlChanges || $ canPublishPurgeChanges ) ) { $ status = $ result [ 'status' ] ? '' : 'FAILED ' ; $ this -> sendWebHook ( $ status . '*clean by key on ' . join ( " " , $ keys ) . '*' ) ; $ canPublishPurgeByKeyDebugBacktrace = $ this -> config -> canPublishPurgeByKeyDebugBacktrace ( ) ; $ canPublishPurgeDebugBacktrace = $ this -> config -> canPublishPurgeDebugBacktrace ( ) ; if ( $ canPublishPurgeByKeyDebugBacktrace == false && $ canPublishPurgeDebugBacktrace == false ) { return $ result [ 'status' ] ; } $ this -> stackTrace ( $ type . join ( " " , $ keys ) ) ; } } return $ result [ 'status' ] ; }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
10546	public function setRequest ( Request $ request ) { $ this -> request = $ request ; $ this -> app = null ; $ this -> vhost = null ; $ this -> route = null ; $ this -> setVariable ( 'request' , $ request ) ; return $ this ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
5107	public function createConnector ( $ name ) { $ connector = new MySqlConnector ( $ name ) ; $ connector -> setConnection ( $ this -> getNewConnection ( $ name ) ) ; return $ connector ; }
8556	private function fromDOMElement ( DOMElement $ dom ) { $ xpath = new DOMXPath ( $ dom -> ownerDocument ) ; $ xpath -> registerNamespace ( 'a' , 'http://mws.amazonaws.com/doc/2009-01-01/' ) ; foreach ( $ this -> fields as $ fieldName => $ field ) { $ fieldType = $ field [ 'FieldType' ] ; if ( is_array ( $ fieldType ) ) { if ( $ this -> isComplexType ( $ fieldType [ 0 ] ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = new $ fieldType [ 0 ] ( $ element ) ; } } } else { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length >= 1 ) { foreach ( $ elements as $ element ) { $ text = $ xpath -> query ( './text()' , $ element ) ; $ this -> fields [ $ fieldName ] [ 'FieldValue' ] [ ] = $ text -> item ( 0 ) -> data ; } } } } else { if ( $ this -> isComplexType ( $ fieldType ) ) { $ elements = $ xpath -> query ( "./a:$fieldName" , $ dom ) ; if ( $ elements -> length == 1 ) { $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = new $ fieldType ( $ elements -> item ( 0 ) ) ; } } else { $ element = $ xpath -> query ( "./a:$fieldName/text()" , $ dom ) ; $ data = null ; if ( $ element -> length == 1 ) { switch ( $ this -> fields [ $ fieldName ] [ 'FieldType' ] ) { case 'DateTime' : $ data = new DateTime ( $ element -> item ( 0 ) -> data , new DateTimeZone ( 'UTC' ) ) ; break ; case 'bool' : $ value = $ element -> item ( 0 ) -> data ; $ data = $ value === 'true' ? true : false ; break ; default : $ data = $ element -> item ( 0 ) -> data ; break ; } $ this -> fields [ $ fieldName ] [ 'FieldValue' ] = $ data ; } } } } }
156	public function addSelect ( $ columns ) { if ( $ columns instanceof ExpressionInterface ) { $ columns = [ $ columns ] ; } elseif ( ! is_array ( $ columns ) ) { $ columns = preg_split ( '/\s*,\s*/' , trim ( $ columns ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } $ columns = $ this -> getUniqueColumns ( $ columns ) ; if ( $ this -> select === null ) { $ this -> select = $ columns ; } else { $ this -> select = array_merge ( $ this -> select , $ columns ) ; } return $ this ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
10723	public function raw ( $ sql , array $ params ) { $ stmt = $ this -> connect ( ) -> prepare ( $ sql ) ; $ stmt -> execute ( $ params ) ; if ( stripos ( $ sql , 'select' ) === 0 ) { return $ stmt -> fetchAll ( PDO :: FETCH_ASSOC ) ; } if ( stripos ( $ sql , 'insert' ) === 0 ) { return $ this -> connect ( ) -> lastInsertId ( ) ; } return $ stmt -> execute ( ) ; }
5342	private function getSoapClient ( $ service , $ method , array $ parameters ) { $ timestamp = time ( ) ; $ nonce = uniqid ( null , true ) ; $ soapClient = $ this -> client -> buildSoapClient ( $ service ) ; $ soapClient -> setTimestamp ( $ timestamp ) ; $ soapClient -> setNonce ( $ nonce ) ; $ soapClient -> setSignature ( array_merge ( $ parameters , [ '__method' => $ method ] ) , $ this -> client -> getPrivateKey ( ) , $ service , $ this -> client -> getEndpoint ( ) , $ timestamp , $ nonce ) ; return $ soapClient ; }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
3039	public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; }
11477	public function boot ( Plugin $ theme ) { $ this -> plugin = $ theme ; parent :: boot ( $ theme ) ; $ this -> initTemplates ( ) ; $ this -> initHomepageTemplate ( ) ; return $ this ; }
532	protected function resortChangelog ( $ changelog ) { foreach ( $ changelog as $ i => $ line ) { $ changelog [ $ i ] = rtrim ( $ line ) ; } $ changelog = array_filter ( $ changelog ) ; $ i = 0 ; ArrayHelper :: multisort ( $ changelog , function ( $ line ) use ( & $ i ) { if ( preg_match ( '/^- (Chg|Enh|Bug|New)( #\d+(, #\d+)*)?: .+/' , $ line , $ m ) ) { $ o = [ 'Bug' => 'C' , 'Enh' => 'D' , 'Chg' => 'E' , 'New' => 'F' ] ; return $ o [ $ m [ 1 ] ] . ' ' . ( ! empty ( $ m [ 2 ] ) ? $ m [ 2 ] : 'AAAA' . $ i ++ ) ; } return 'B' . $ i ++ ; } , SORT_ASC , SORT_NATURAL ) ; array_unshift ( $ changelog , '' ) ; $ changelog [ ] = '' ; $ changelog [ ] = '' ; return $ changelog ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
10304	public function resolve ( $ key ) { if ( ! ( $ this -> getAdapter ( ) instanceof ResolverInterface ) ) { throw new \ LogicException ( 'This adapter can not resolve keys' ) ; } return $ this -> getAdapter ( ) -> resolve ( $ key ) ; }
12102	public function setMaxSize ( $ maxSize ) { $ serverMaxSize = $ this -> getServerMaxSize ( ) ; if ( $ maxSize > $ serverMaxSize ) { throw new FileMaxSizeException ( $ serverMaxSize ) ; } $ this -> maxSize = $ maxSize ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'maxSize' , $ maxSize ) ; } }
9930	public function setFilterType ( $ pFilterType ) { if ( ! in_array ( $ pFilterType , self :: $ filterTypes ) ) { throw new PhpSpreadsheetException ( 'Invalid filter type for column AutoFilter.' ) ; } $ this -> filterType = $ pFilterType ; return $ this ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
295	public function getOldAttribute ( $ name ) { return isset ( $ this -> _oldAttributes [ $ name ] ) ? $ this -> _oldAttributes [ $ name ] : null ; }
6959	protected function updateExpiresAt ( CartInterface $ cart ) { $ date = new \ DateTime ( ) ; $ date -> modify ( $ this -> expirationDelay ) ; $ cart -> setExpiresAt ( $ date ) ; return true ; }
2661	public function deleteRequest ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/request_settings/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to delete the REQUEST object.' ) ) ; } }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
10596	protected function initViewPanelTableRow ( \ MvcCore \ IRoute & $ route , $ matched ) { $ route -> InitAll ( ) ; $ row = new \ stdClass ; $ row -> matched = $ matched ; $ row -> method = $ route -> GetMethod ( ) ; $ row -> method = $ row -> method === NULL ? '*' : $ row -> method ; $ row -> className = htmlSpecialChars ( '\\' . get_class ( $ route ) , ENT_QUOTES , 'UTF-8' ) ; $ routeMatch = $ this -> getRouteLocalizedRecord ( $ route , 'GetMatch' ) ; $ routeMatch = rtrim ( $ routeMatch , 'imsxeADSUXJu' ) ; $ routeReverse = $ this -> getRouteLocalizedRecord ( $ route , 'GetReverse' ) ; $ routeDefaults = $ this -> getRouteLocalizedRecord ( $ route , 'GetDefaults' ) ; $ row -> match = $ this -> completeFormatedPatternCharGroups ( $ routeMatch , [ '(' , ')' ] ) ; if ( $ routeReverse !== NULL ) { $ row -> reverse = $ this -> completeFormatedPatternCharGroups ( $ routeReverse , [ '<' , '>' ] ) ; } else { $ row -> reverse = NULL ; } $ row -> routeName = $ route -> GetName ( ) ; $ row -> ctrlActionName = $ route -> GetControllerAction ( ) ; if ( $ row -> ctrlActionName !== ':' ) { $ row -> ctrlActionLink = $ this -> completeCtrlActionLink ( $ route -> GetController ( ) , $ route -> GetAction ( ) ) ; } else { $ row -> ctrlActionName = NULL ; $ row -> ctrlActionLink = NULL ; } $ routeReverseParams = $ route -> GetReverseParams ( ) ? : [ ] ; $ paramsKeys = array_unique ( array_merge ( $ routeReverseParams , array_keys ( $ routeDefaults ) ) ) ; $ row -> defaults = $ this -> completeParams ( $ route , $ paramsKeys , TRUE ) ; $ row -> params = [ ] ; if ( $ matched ) { $ paramsAndReqestParams = array_merge ( $ routeDefaults , $ this -> requestParams ) ; $ row -> params = $ this -> completeParams ( $ route , array_keys ( $ paramsAndReqestParams ) , FALSE ) ; } return $ row ; }
5555	public function getUrls ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getUrls ( ) ; } $ urls = array ( ) ; foreach ( $ this -> frames as $ frame ) { $ urls = array_merge ( $ urls , $ frame -> getUrls ( ) ) ; } return array_values ( array_unique ( $ urls ) ) ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
4699	public function errorInfo ( ) { static $ statusStrings = array ( \ ZipArchive :: ER_OK => 'No error' , \ ZipArchive :: ER_MULTIDISK => 'Multi-disk zip archives not supported' , \ ZipArchive :: ER_RENAME => 'Renaming temporary file failed' , \ ZipArchive :: ER_CLOSE => 'Closing zip archive failed' , \ ZipArchive :: ER_SEEK => 'Seek error' , \ ZipArchive :: ER_READ => 'Read error' , \ ZipArchive :: ER_WRITE => 'Write error' , \ ZipArchive :: ER_CRC => 'CRC error' , \ ZipArchive :: ER_ZIPCLOSED => 'Containing zip archive was closed' , \ ZipArchive :: ER_NOENT => 'No such file' , \ ZipArchive :: ER_EXISTS => 'File already exists' , \ ZipArchive :: ER_OPEN => 'Can\'t open file' , \ ZipArchive :: ER_TMPOPEN => 'Failure to create temporary file' , \ ZipArchive :: ER_ZLIB => 'Zlib error' , \ ZipArchive :: ER_MEMORY => 'Malloc failure' , \ ZipArchive :: ER_CHANGED => 'Entry has been changed' , \ ZipArchive :: ER_COMPNOTSUPP => 'Compression method not supported' , \ ZipArchive :: ER_EOF => 'Premature EOF' , \ ZipArchive :: ER_INVAL => 'Invalid argument' , \ ZipArchive :: ER_NOZIP => 'Not a zip archive' , \ ZipArchive :: ER_INTERNAL => 'Internal error' , \ ZipArchive :: ER_INCONS => 'Zip archive inconsistent' , \ ZipArchive :: ER_REMOVE => 'Can\'t remove file' , \ ZipArchive :: ER_DELETED => 'Entry has been deleted' , ) ; if ( isset ( $ statusStrings [ $ this -> ziparchive -> status ] ) ) { $ statusString = $ statusStrings [ $ this -> ziparchive -> status ] ; } else { $ statusString = 'Unknown status' ; } return $ statusString . '(' . $ this -> ziparchive -> status . ')' ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
1310	public static function categoriesMenu ( $ categories ) { $ menu = '<ul class="nav nav-pills nav-stacked">' ; foreach ( $ categories as $ category ) { $ menu .= '<li>' ; $ menu .= '<a href="/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.category' ) . '/' . $ category [ 'slug' ] . '">' ; $ menu .= '<div class="chatter-box" style="background-color:' . $ category [ 'color' ] . '"></div>' ; $ menu .= $ category [ 'name' ] . '</a>' ; if ( count ( $ category [ 'parents' ] ) ) { $ menu .= static :: categoriesMenu ( $ category [ 'parents' ] ) ; } $ menu .= '</li>' ; } $ menu .= '</ul>' ; return $ menu ; }
9453	public function getCollection ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 , $ countableAttributes = null ) { $ result = $ this -> query ( $ index , $ filters , $ queries , $ fieldWeights , $ limit , $ offset ) ; if ( is_array ( $ result ) ) { $ i = 0 ; if ( $ countableAttributes ) { foreach ( $ countableAttributes as $ attributeName ) { $ i ++ ; $ result [ 0 ] [ 'attributes' ] [ 'countable' ] [ $ attributeName ] = new CountableCollection ( $ result [ $ i ] , $ attributeName ) ; } } for ( $ l = 1 ; $ l <= $ i ; $ l ++ ) { unset ( $ result [ $ l ] ) ; } $ collection = $ this -> factoryCollection ( $ result ) ; return $ collection ; } }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
9336	public function turn ( ) { if ( $ this -> original -> type == self :: TYPE_TURN ) { return $ this -> original -> value ; } return $ this -> float_rad / ( 2 * pi ( ) ) ; }
5495	public function findFirstSlot ( $ parameters ) { $ count = count ( $ this -> map ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { if ( $ this -> map [ $ i ] [ 'params' ] -> test ( $ parameters ) ) { return $ this -> map [ $ i ] ; } } return ; }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
11601	private static function getBaseUrl ( ) : ? string { $ serverName = filter_input ( \ INPUT_SERVER , 'SERVER_NAME' , \ FILTER_SANITIZE_STRING ) ; if ( ! empty ( $ serverName ) ) { $ https = filter_input ( \ INPUT_SERVER , 'HTTPS' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ https ) && strtolower ( $ https ) === 'on' ? 'https' : 'http' ; return $ protocol . '://' . $ serverName ; } return null ; }
9856	private function addContinue ( $ data ) { $ limit = $ this -> limit ; $ record = 0x003C ; $ tmp = substr ( $ data , 0 , 2 ) . pack ( 'v' , $ limit ) . substr ( $ data , 4 , $ limit ) ; $ header = pack ( 'vv' , $ record , $ limit ) ; $ data_length = strlen ( $ data ) ; for ( $ i = $ limit + 4 ; $ i < ( $ data_length - $ limit ) ; $ i += $ limit ) { $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i , $ limit ) ; } $ header = pack ( 'vv' , $ record , strlen ( $ data ) - $ i ) ; $ tmp .= $ header ; $ tmp .= substr ( $ data , $ i ) ; return $ tmp ; }
12827	protected function removeBlockFromSlotFile ( array $ options , $ targetDir = null ) { $ targetDir = $ this -> workDirectory ( $ targetDir ) ; $ slot = $ this -> getSlotDefinition ( $ targetDir ) ; $ blockName = $ options [ "blockname" ] ; $ tmp = array_flip ( $ slot [ "blocks" ] ) ; unset ( $ tmp [ $ blockName ] ) ; $ slot [ "blocks" ] = array_keys ( $ tmp ) ; $ this -> saveSlotDefinition ( $ targetDir , $ slot ) ; return $ blockName ; }
10787	public function onlineHelpAction ( Request $ request ) { $ template = $ this -> searchService -> getOnlineHelp ( $ request -> getLocale ( ) , $ this -> getDefaultLocale ( ) ) ; return $ this -> render ( $ template ? : 'StingerSoftEntitySearchBundle:Help:no_help.html.twig' ) ; }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
7245	private function buildSaleItemRemaining ( Common \ SaleItemInterface $ saleItem , Shipment \ RemainingList $ list , array $ shipments ) { if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ quantity = $ saleItem -> getTotalQuantity ( ) ; foreach ( $ shipments as $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( $ item -> getSaleItem ( ) === $ saleItem ) { $ quantity += $ shipment -> isReturn ( ) ? $ item -> getQuantity ( ) : - $ item -> getQuantity ( ) ; continue 2 ; } } } if ( 0 < $ quantity ) { $ entry = new Shipment \ RemainingEntry ( ) ; $ entry -> setSaleItem ( $ saleItem ) -> setQuantity ( $ quantity ) ; $ list -> addEntry ( $ entry ) ; } } foreach ( $ saleItem -> getChildren ( ) as $ child ) { $ this -> buildSaleItemRemaining ( $ child , $ list , $ shipments ) ; } }
8590	public function setGetMatchingProductResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMatchingProductResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2993	public function initSMTP ( ) { $ f3 = \ Base :: instance ( ) ; $ this -> smtp = new \ SMTP ( $ f3 -> get ( 'mailer.smtp.host' ) , $ f3 -> get ( 'mailer.smtp.port' ) , $ f3 -> get ( 'mailer.smtp.scheme' ) , $ f3 -> get ( 'mailer.smtp.user' ) , $ f3 -> get ( 'mailer.smtp.pw' ) ) ; if ( ! $ f3 -> devoid ( 'mailer.errors_to' , $ errors_to ) ) $ this -> setErrors ( $ errors_to ) ; if ( ! $ f3 -> devoid ( 'mailer.reply_to' , $ reply_to ) ) $ this -> setReply ( $ reply_to ) ; if ( ! $ f3 -> devoid ( 'mailer.from_mail' , $ from_mail ) ) { if ( $ f3 -> devoid ( 'mailer.from_name' , $ from_name ) ) $ from_name = NULL ; $ this -> setFrom ( $ from_mail , $ from_name ) ; } }
6649	public function uploadFile ( $ event ) { if ( ! array_key_exists ( $ this -> attribute , $ event -> sender -> attributes ) ) { throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Attribute {attribute} not found in model {model}' , [ 'attribute' => $ this -> attribute , 'model' => $ event -> sender -> className ( ) ] ) ) ; } $ oldFile = false ; if ( isset ( $ event -> sender -> oldAttributes [ $ this -> attribute ] ) ) { $ oldFile = $ event -> sender -> oldAttributes [ $ this -> attribute ] ; } $ uploadedFile = UploadedFile :: getInstance ( $ event -> sender , $ this -> attribute ) ; if ( null !== $ uploadedFile && $ uploadedFile -> size !== 0 ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ oldFile ) { $ this -> unlinkFiles ( $ oldFile ) ; } $ baseName = $ uploadedFile -> baseName ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; while ( @ file_exists ( $ folder . '/' . $ fileName ) ) { $ baseName .= '_' ; $ fileName = $ baseName . '.' . $ uploadedFile -> extension ; } FileHelper :: createDirectory ( $ folder , 0777 ) ; $ uploadedFile -> saveAs ( $ folder . '/' . $ fileName ) ; $ event -> sender -> { $ this -> attribute } = $ fileName ; } else { if ( Yii :: $ app -> request -> post ( $ this -> attribute . '_file_delete' ) ) { $ this -> unlinkFiles ( $ oldFile ) ; $ event -> sender -> { $ this -> attribute } = null ; } else { $ event -> sender -> { $ this -> attribute } = $ oldFile ; } } }
1747	public function getCalendars ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> calendars ) ) { return array ( ) ; } $ arrCalendars = array ( ) ; $ objCalendars = $ this -> Database -> execute ( "SELECT id, title FROM tl_calendar ORDER BY title" ) ; while ( $ objCalendars -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objCalendars -> id , 'calendars' ) ) { $ arrCalendars [ $ objCalendars -> id ] = $ objCalendars -> title ; } } return $ arrCalendars ; }
9100	private function bind ( ) { if ( ! @ socket_bind ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
8479	public function bootstrap ( $ app ) { $ app -> i18n -> translations [ 'devgroup.events-system' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@DevGroup/EventsSystem/messages' , ] ; $ error = [ ] ; try { foreach ( EventHelper :: getActiveHandlersList ( ) as $ handler ) { Event :: on ( $ handler [ 'class' ] , $ handler [ 'name' ] , $ handler [ 'callable' ] , $ handler [ 'data' ] ) ; } } catch ( \ yii \ db \ Exception $ e ) { $ error = [ 'message' => '`DevGroup\EventsSystem` extension is not fully installed yet.' , 'hint' => 'Please run the `./yii migrate --migrationPath=@DevGroup/EventsSystem/migrations` command from your application directory to finish the installation process.' , ] ; } catch ( \ Exception $ e ) { $ error = [ 'message' => $ e -> getCode ( ) , 'hint' => $ e -> getMessage ( ) , ] ; } if ( empty ( $ error ) === false ) { if ( $ app instanceof \ yii \ console \ Application ) { $ app -> on ( Application :: EVENT_BEFORE_ACTION , function ( $ event ) use ( $ app , $ error ) { $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL . PHP_EOL ) ; $ app -> controller -> stderr ( $ error [ 'message' ] . PHP_EOL ) ; $ app -> controller -> stdout ( $ error [ 'hint' ] . PHP_EOL ) ; $ app -> controller -> stdout ( PHP_EOL . str_repeat ( '=' , 80 ) . PHP_EOL ) ; } ) ; } elseif ( $ app instanceof \ yii \ web \ Application && YII_DEBUG === true ) { $ app -> session -> setFlash ( 'warning' , Html :: tag ( 'h4' , $ error [ 'message' ] ) . Html :: tag ( 'p' , $ error [ 'hint' ] ) ) ; } } }
5426	private function forceToExpectation ( $ exception ) { if ( $ exception === false ) { return new AnythingExpectation ( ) ; } if ( ! SimpleExpectation :: isExpectation ( $ exception ) ) { return new ExceptionExpectation ( $ exception ) ; } return $ exception ; }
10678	public function inflect ( $ text , $ zivotne = false , $ preferovanyRod = '' ) { $ aTxt = $ this -> _txtSplit ( $ text ) ; $ this -> PrefRod = '0' ; $ out = [ ] ; for ( $ i = \ count ( $ aTxt ) - 1 ; $ i >= 0 ; $ i -- ) { $ this -> _skl2 ( $ aTxt [ $ i ] , $ preferovanyRod , $ zivotne ) ; if ( $ i === \ count ( $ aTxt ) - 1 ) { $ this -> PrefRod = $ this -> astrTvar [ 0 ] ; } if ( $ i < \ count ( $ aTxt ) - 1 && mb_substr ( $ this -> PrefRod , 0 , 1 , 'UTF-8' ) !== '?' && mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { $ this -> astrTvar [ $ j ] = $ aTxt [ $ i ] ; } } if ( mb_substr ( $ this -> astrTvar [ 0 ] , 0 , 1 , 'UTF-8' ) === '?' ) { $ this -> astrTvar [ 0 ] = '' ; } if ( $ i < \ count ( $ aTxt ) ) { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] . ' ' . @ $ out [ $ j ] ; } } else { for ( $ j = 1 ; $ j < 15 ; $ j ++ ) { @ $ out [ $ j ] = $ this -> astrTvar [ $ j ] ; } } } return $ out ; }
9627	protected function matchParams ( Route $ route , array $ params ) : bool { $ matchers = $ route -> getMatchers ( ) ; foreach ( $ params as $ name => $ value ) { if ( ! isset ( $ matchers [ $ name ] ) ) { continue ; } $ valueMatchers = $ matchers [ $ name ] ; foreach ( $ valueMatchers as $ matcher ) { if ( ! $ matcher ( $ value ) ) { $ this -> logger -> debug ( sprintf ( 'Value "%s" for param "%s" did not match criteria of matcher "%s"' , $ value , $ name , get_class ( $ matcher ) ) ) ; return false ; } } } return true ; }
8489	public static function getCpuArchitecture ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Architecture FROM Win32_Processor" ) as $ cpu ) { switch ( $ cpu -> Architecture ) { case 0 : return "x86" ; case 1 : return "MIPS" ; case 2 : return "Alpha" ; case 3 : return "PowerPC" ; case 6 : return "Itanium-based systems" ; case 9 : return "x64" ; } } return "Unknown" ; }
8783	protected function publishes ( array $ paths , $ group = null ) { $ this -> ensurePublishArrayInitialized ( $ class = static :: class ) ; static :: $ publishes [ $ class ] = array_merge ( static :: $ publishes [ $ class ] , $ paths ) ; if ( $ group ) { $ this -> addPublishGroup ( $ group , $ paths ) ; } }
3114	public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; }
10736	public function compare ( $ x ) : int { if ( ! is_numeric ( $ x ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, x, to be a number" ) ; } if ( $ x < $ this -> lower || ( ! $ this -> isLowerInclusive && $ x == $ this -> lower ) ) { return - 1 ; } elseif ( $ x > $ this -> upper || ( ! $ this -> isUpperInclusive && $ x == $ this -> upper ) ) { return 1 ; } else { return 0 ; } }
12202	public function create ( int $ status = 200 , array $ headers = [ ] , $ body = null ) : ResponseInterface { return new Response ( $ status , $ headers , $ body ) ; }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
6494	private function rankAcceptMediaTypeHeaders ( array $ mediaTypeHeaders ) : array { usort ( $ mediaTypeHeaders , [ $ this , 'compareAcceptMediaTypeHeaders' ] ) ; $ rankedMediaTypeHeaders = array_filter ( $ mediaTypeHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedMediaTypeHeaders ) ; }
1470	public function createResolver ( $ apiName , array $ config ) { $ factoryName = isset ( $ config [ 'resolver' ] ) ? $ config [ 'resolver' ] : ResolverFactory :: class ; $ factory = $ this -> container -> make ( $ factoryName ) ; if ( $ factory instanceof ResolverInterface ) { return $ factory ; } if ( ! is_callable ( $ factory ) ) { throw new RuntimeException ( "Factory {$factoryName} cannot be invoked." ) ; } $ resolver = $ factory ( $ apiName , $ config ) ; if ( ! $ resolver instanceof ResolverInterface ) { throw new RuntimeException ( "Factory {$factoryName} did not create a resolver instance." ) ; } return $ resolver ; }
5209	public function convert ( array $ stmts , ClassMetadata $ metadata , ClassCollector $ classCollector , Logger $ logger ) { $ this -> metadata = $ metadata ; $ this -> classCollector = $ classCollector ; $ this -> logger = $ logger ; return ltrim ( str_replace ( "\n" . self :: noIndentToken , "\n" , $ this -> pStmts ( $ stmts , false ) ) ) ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
8402	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ namespaces = array ( ) ; self :: $ applications = array ( ) ; spl_autoload_register ( __CLASS__ . '::loadClass' ) ; self :: $ isInit = true ; Console :: init ( ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Console' ) ; Console :: route ( 'help' , 'help' , 'this screen' , 'Controller.help' ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Database' ) ; Console :: route ( 'db/list' , 'db/list' , 'list registered mappings' , 'Console.mappings' ) ; Console :: route ( 'db/build' , 'db/build mapping_name' , 'build data structures' , 'Console.build' ) ; Console :: route ( 'db/generate' , 'db/generate mapping_name' , 'generate base models' , 'Console.generate' ) ; Console :: route ( 'db/migration/create' , 'db/migration/create mapping_name migration_name' , 'create a new migration' , 'Migration.create' ) ; Console :: route ( 'db/migration/generate' , 'db/migration/generate mapping_name migration_name' , 'generate migration code' , 'Migration.generate' ) ; Console :: route ( 'db/migration/migrate' , 'db/migration/migrate mapping_name' , 'migrate' , 'Migration.migrate' ) ; Console :: route ( 'db/migration/rollback' , 'db/migration/rollback mapping_name' , 'rollback last migration' , 'Migration.rollback' ) ; Console :: prefix ( '\\RocknRoot\\StrayFw\\Http' ) ; Console :: route ( 'http/routing/list' , 'http/routing/list' , 'list registered routes' , 'Console.routes' ) ; Http :: init ( ) ; if ( defined ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_IS_HTTP' ) === true && constant ( 'STRAY_ENV' ) === 'development' ) { Debug \ ErrorPage :: init ( ) ; } } }
2054	protected function getConfigurationItem ( $ imageSize ) { $ configItem = new PictureConfigurationItem ( ) ; $ resizeConfig = new ResizeConfiguration ( ) ; $ mode = $ imageSize -> resizeMode ; if ( substr_count ( $ mode , '_' ) === 1 ) { $ importantPart = $ this -> image -> setImportantPart ( null ) -> getImportantPart ( ) ; $ mode = explode ( '_' , $ mode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } $ this -> image -> setImportantPart ( $ importantPart ) ; $ mode = ResizeConfiguration :: MODE_CROP ; } $ resizeConfig -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setZoomLevel ( $ imageSize -> zoom ) ; if ( $ mode ) { $ resizeConfig -> setMode ( $ mode ) ; } $ configItem -> setResizeConfig ( $ resizeConfig ) ; if ( isset ( $ imageSize -> sizes ) ) { $ configItem -> setSizes ( $ imageSize -> sizes ) ; } if ( isset ( $ imageSize -> densities ) ) { $ configItem -> setDensities ( $ imageSize -> densities ) ; } if ( isset ( $ imageSize -> media ) ) { $ configItem -> setMedia ( $ imageSize -> media ) ; } return $ configItem ; }
10445	protected function handleParam ( ) { if ( preg_match ( '/^@([0-9]+)=(.*)$/' , $ this -> getNextLine ( self :: LINE_TYPE_ANY ) , $ part ) ) { $ paramValue = trim ( $ part [ 2 ] , "'" ) ; return [ $ part [ 1 ] => $ paramValue ] ; } return null ; }
12668	public function setCacheOptions ( $ cacheOptions ) { if ( $ cacheOptions instanceof CacheOptionsInterface ) { $ this -> cacheOptions = $ cacheOptions ; } elseif ( is_array ( $ cacheOptions ) ) { $ this -> cacheOptions = new CacheOptions ( $ cacheOptions ) ; } else { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be array or an instance of HtSettingsModule\Options\CacheOptionsInterface, %s provided instead' , __METHOD__ , is_object ( $ cacheOptions ) ? get_class ( $ cacheOptions ) : gettype ( $ cacheOptions ) ) ) ; } return $ this ; }
10511	public function notify ( ) { $ observersToNotify = array ( ) ; foreach ( $ this -> _observers as $ observer ) { if ( $ this -> checkIfObserverMustBeUpdate ( $ observer ) ) { $ observersToNotify [ ] = $ observer ; } } usort ( $ observersToNotify , array ( $ this , 'orderObserversForPriority' ) ) ; foreach ( $ observersToNotify as $ observer ) { try { $ this -> updateObserverState ( $ observer ) ; } catch ( \ Exception $ e ) { if ( ( int ) $ e -> getCode ( ) === 600 ) { break 1 ; } } } }
10555	public static function findBestMatching ( URL $ url , array $ sites ) { $ vhosts = array ( ) ; foreach ( $ sites as $ site ) foreach ( $ site -> getVirtualHosts ( ) as $ vhost ) $ vhosts [ ] = $ vhost ; $ my_url = new URL ( $ url ) ; $ my_url -> set ( 'query' , null ) -> set ( 'fragment' , null ) -> toString ( ) ; $ best_percentage = 0 ; $ best_idx = null ; foreach ( $ vhosts as $ idx => $ vhost ) { $ host = $ vhost -> getHost ( ) -> toString ( ) ; similar_text ( $ my_url , $ host , $ percentage ) ; if ( $ best_idx === null || $ percentage > $ best_percentage ) { $ best_idx = $ idx ; $ best_percentage = $ percentage ; } } if ( $ best_idx === null ) return null ; return $ vhosts [ $ best_idx ] ; }
5412	public function read ( ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ raw = @ fread ( $ this -> handle , $ this -> block_size ) ; if ( $ raw === false ) { $ this -> setError ( 'Cannot read from socket' ) ; $ this -> close ( ) ; } return $ raw ; }
11896	protected function generateIV ( ) { $ sizeIV = $ this -> getSizeIV ( ) ; if ( $ sizeIV === 0 ) { return $ this ; } $ this -> setIV ( mcrypt_create_iv ( $ sizeIV , MCRYPT_RAND ) ) ; return $ this ; }
10058	public function save ( CacheItemInterface $ item ) { $ item -> setIsHit ( true ) ; $ this -> data [ $ item -> getKey ( ) ] = $ item ; return true ; }
7895	public function extend ( $ provider , Closure $ callback ) { if ( $ this -> isProviderAliasExists ( $ provider ) ) { throw new InvalidArgumentException ( "Alias provider is already reserved [{$provider}]" ) ; } $ this -> customProviders [ $ provider ] = $ callback ; return $ this ; }
4293	public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } }
1250	public function parse ( $ xml ) { $ parser = xml_parser_create_ns ( 'UTF-8' , '@' ) ; xml_parser_set_option ( $ parser , XML_OPTION_CASE_FOLDING , 0 ) ; xml_parser_set_option ( $ parser , XML_OPTION_SKIP_WHITE , 1 ) ; xml_set_object ( $ parser , $ this ) ; xml_set_element_handler ( $ parser , 'startElement' , 'endElement' ) ; xml_set_character_data_handler ( $ parser , 'cdata' ) ; xml_parse ( $ parser , $ xml , true ) ; xml_parser_free ( $ parser ) ; return $ this -> rootObject ; }
1044	private static function highlightSourceAtLocation ( Source $ source , SourceLocation $ location ) { $ line = $ location -> line ; $ lineOffset = $ source -> locationOffset -> line - 1 ; $ columnOffset = self :: getColumnOffset ( $ source , $ location ) ; $ contextLine = $ line + $ lineOffset ; $ contextColumn = $ location -> column + $ columnOffset ; $ prevLineNum = ( string ) ( $ contextLine - 1 ) ; $ lineNum = ( string ) $ contextLine ; $ nextLineNum = ( string ) ( $ contextLine + 1 ) ; $ padLen = strlen ( $ nextLineNum ) ; $ lines = preg_split ( '/\r\n|[\n\r]/' , $ source -> body ) ; $ lines [ 0 ] = self :: whitespace ( $ source -> locationOffset -> column - 1 ) . $ lines [ 0 ] ; $ outputLines = [ sprintf ( '%s (%s:%s)' , $ source -> name , $ contextLine , $ contextColumn ) , $ line >= 2 ? ( self :: lpad ( $ padLen , $ prevLineNum ) . ': ' . $ lines [ $ line - 2 ] ) : null , self :: lpad ( $ padLen , $ lineNum ) . ': ' . $ lines [ $ line - 1 ] , self :: whitespace ( 2 + $ padLen + $ contextColumn - 1 ) . '^' , $ line < count ( $ lines ) ? self :: lpad ( $ padLen , $ nextLineNum ) . ': ' . $ lines [ $ line ] : null , ] ; return implode ( "\n" , array_filter ( $ outputLines ) ) ; }
9874	private function writeLegacyDrawing ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getComments ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_comments_vml1' ) ; $ objWriter -> endElement ( ) ; } }
7383	public static function toValues ( $ input , array $ include = [ ] ) { if ( ! is_array ( $ input ) && ! is_object ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } $ sqlStrs = [ ] ; if ( count ( $ include ) ) { foreach ( $ include as $ i ) { if ( array_key_exists ( $ i , $ input ) ) { $ sqlStrs [ ] = '`' . $ i . '` = VALUES(`' . $ i . '`)' ; } } } else { foreach ( $ input as $ k => & $ v ) { $ sqlStrs [ ] = '`' . $ k . '` = VALUES(`' . $ k . '`)' ; } } return implode ( ",\n" , $ sqlStrs ) ; }
10014	public function getIndex ( Worksheet $ pSheet ) { foreach ( $ this -> workSheetCollection as $ key => $ value ) { if ( $ value -> getHashCode ( ) == $ pSheet -> getHashCode ( ) ) { return $ key ; } } throw new Exception ( 'Sheet does not exist.' ) ; }
172	private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { if ( isset ( $ pattern [ 0 ] ) && $ pattern [ 0 ] === '/' ) { $ pattern = StringHelper :: byteSubstr ( $ pattern , 1 , StringHelper :: byteLength ( $ pattern ) ) ; if ( $ firstWildcard !== false && $ firstWildcard !== 0 ) { $ firstWildcard -- ; } } $ namelen = StringHelper :: byteLength ( $ path ) - ( empty ( $ basePath ) ? 0 : StringHelper :: byteLength ( $ basePath ) + 1 ) ; $ name = StringHelper :: byteSubstr ( $ path , - $ namelen , $ namelen ) ; if ( $ firstWildcard !== 0 ) { if ( $ firstWildcard === false ) { $ firstWildcard = StringHelper :: byteLength ( $ pattern ) ; } if ( $ firstWildcard > $ namelen ) { return false ; } if ( strncmp ( $ pattern , $ name , $ firstWildcard ) ) { return false ; } $ pattern = StringHelper :: byteSubstr ( $ pattern , $ firstWildcard , StringHelper :: byteLength ( $ pattern ) ) ; $ name = StringHelper :: byteSubstr ( $ name , $ firstWildcard , $ namelen ) ; if ( empty ( $ pattern ) && empty ( $ name ) ) { return true ; } } $ matchOptions = [ 'filePath' => true ] ; if ( $ flags & self :: PATTERN_CASE_INSENSITIVE ) { $ matchOptions [ 'caseSensitive' ] = false ; } return StringHelper :: matchWildcard ( $ pattern , $ name , $ matchOptions ) ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
9710	private function writeWindow1 ( ) { $ record = 0x003D ; $ length = 0x0012 ; $ xWn = 0x0000 ; $ yWn = 0x0000 ; $ dxWn = 0x25BC ; $ dyWn = 0x1572 ; $ grbit = 0x0038 ; $ ctabsel = 1 ; $ wTabRatio = 0x0258 ; $ itabFirst = 0 ; $ itabCur = $ this -> spreadsheet -> getActiveSheetIndex ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvvvvv' , $ xWn , $ yWn , $ dxWn , $ dyWn , $ grbit , $ itabCur , $ itabFirst , $ ctabsel , $ wTabRatio ) ; $ this -> append ( $ header . $ data ) ; }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
3543	public function actionCreateExampleRole ( ) { $ auth = Yii :: $ app -> authManager ; $ displayDetailedAbout = $ auth -> createPermission ( 'permissionDisplayDetailedAbout' ) ; $ displayDetailedAbout -> description = 'Permission to display detailed about informations' ; $ auth -> add ( $ displayDetailedAbout ) ; $ useContactPage = $ auth -> createPermission ( 'permissionToUseContanctPage' ) ; $ useContactPage -> description = 'Permission to use the contanct page' ; $ auth -> add ( $ useContactPage ) ; $ yii2ExampleGroup = $ auth -> createRole ( 'yii2_example_group' ) ; $ auth -> add ( $ yii2ExampleGroup ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ displayDetailedAbout ) ; $ auth -> addChild ( $ yii2ExampleGroup , $ useContactPage ) ; $ useHomePage = $ auth -> createPermission ( 'permissionToSeeHome' ) ; $ useHomePage -> description = 'Permission to use the home page' ; $ auth -> add ( $ useHomePage ) ; $ yii2HomeGroup = $ auth -> createRole ( 'yii2_see_home_group' ) ; $ auth -> add ( $ yii2HomeGroup ) ; $ auth -> addChild ( $ yii2HomeGroup , $ useHomePage ) ; echo "\n\n!!!! TODO !!!!\nTow roles with the name yii2_example_group and yii2_see_home_group were created in yii2.\nPlease create the groups with the same name in Active Directory.\nAssign the user you are using for the login to this groups in Active Directory.\n" ; }
1768	public function listNewsArticles ( $ arrRow ) { return '<div class="tl_content_left">' . $ arrRow [ 'headline' ] . ' <span style="color:#999;padding-left:3px">[' . Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) . ']</span></div>' ; }
10881	public function checkPaths ( ) { if ( $ this -> path_checked ) return true ; foreach ( array ( 'root' , 'webroot' ) as $ type ) { $ path = $ this -> $ type ; if ( ! file_exists ( $ path ) || ! is_dir ( $ path ) ) throw new IOException ( "Path '$type' does not exist: " . $ path ) ; if ( ! is_readable ( $ path ) ) throw new PermissionError ( $ path , "Path '$type' cannot be read" ) ; } if ( ! is_dir ( $ this -> config ) || is_readable ( $ this -> config ) ) $ this -> config = null ; foreach ( array ( 'var' , 'cache' , 'log' , 'uploads' ) as $ write_dir ) { $ path = $ this -> $ write_dir ; if ( ! is_dir ( $ path ) ) { $ dn = dirname ( $ path ) ; if ( ! file_exists ( $ path ) && $ dn === $ this -> var ) { Path :: mkdir ( $ path ) ; } else { if ( file_exists ( $ path ) ) throw new IOException ( "Path '$write_dir' exists but is not a directory: " . $ path ) ; $ this -> $ write_dir = null ; continue ; } } if ( ! is_writable ( $ path ) ) { try { Path :: makeWritable ( $ path ) ; } catch ( PermissionError $ e ) { $ this -> $ write_dir = null ; if ( $ this -> cli ) WF :: debug ( "Failed to get write access to: %s" , $ e -> getMessage ( ) ) ; } } } $ this -> path_checked = true ; return true ; }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
9036	protected function insert ( $ entity , $ tableName = null , HydratorInterface $ hydrator = null ) { $ result = parent :: insert ( $ entity , $ tableName , $ hydrator ) ; $ entity -> setId ( $ result -> getGeneratedValue ( ) ) ; return $ result ; }
2934	public function save ( ) { if ( is_file ( $ this -> filePath ) && $ this -> autoBackup ) { $ this -> backup ( ) ; } $ this -> writer -> save ( $ this -> filePath ) ; return $ this ; }
9394	public function execute ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ command = $ this -> builder -> build ( $ this -> options ) ; exec ( $ command ) ; } }
679	protected function validateCondition ( $ condition ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidFilter' ) ) ; return ; } if ( empty ( $ condition ) ) { return ; } foreach ( $ condition as $ key => $ value ) { $ method = 'validateAttributeCondition' ; if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ controlKey = $ this -> filterControls [ $ key ] ; if ( isset ( $ this -> conditionValidators [ $ controlKey ] ) ) { $ method = $ this -> conditionValidators [ $ controlKey ] ; } } $ this -> $ method ( $ key , $ value ) ; } }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
11033	public function init ( ) { $ this -> _file = \ Yii :: getAlias ( $ this -> path . '/config/' . self :: FILENAME ) ; $ this -> loadFromFile ( ) ; }
9495	public function createService ( ) { $ host = $ this -> getParameters ( ) -> get ( 'host' ) ; $ port = $ this -> getParameters ( ) -> get ( 'port' ) ; $ timeout = $ this -> getParameters ( ) -> get ( 'timeout' ) ; if ( is_null ( $ host ) || is_null ( $ port ) ) { throw new \ Exception ( 'No sphinx server information found within the configuration!' ) ; } $ sphinxClient = new SphinxClient ( ) ; $ sphinxClient -> SetServer ( $ host , $ port ) ; $ sphinxClient -> SetConnectTimeout ( $ timeout ) ; $ sphinxClient -> SetArrayResult ( true ) ; $ sphinxClient -> setMatchModeByModeName ( 'any' ) ; $ sphinxClient -> SetSortMode ( SPH_SORT_RELEVANCE ) ; $ sphinxClient -> SetRankingMode ( SPH_RANK_PROXIMITY ) ; return $ sphinxClient ; }
12744	public function askSlotMap ( NodeConnectionInterface $ connection = null ) { if ( ! $ connection && ! $ connection = $ this -> getRandomConnection ( ) ) { return ; } $ this -> slotmap -> reset ( ) ; $ response = $ this -> queryClusterNodeForSlotMap ( $ connection ) ; foreach ( $ response as $ slots ) { list ( $ start , $ end , $ master ) = $ slots ; if ( $ master [ 0 ] === '' ) { $ this -> slotmap -> setSlots ( $ start , $ end , ( string ) $ connection ) ; } else { $ this -> slotmap -> setSlots ( $ start , $ end , "{$master[0]}:{$master[1]}" ) ; } } }
5086	public function startTransaction ( ) : bool { if ( $ this -> isInTransaction ) throw new AlreadyInTransactionException ( ) ; $ this -> isInTransaction = $ this -> executeDirect ( 'START TRANSACTION' ) ; return $ this -> isInTransaction ; }
9472	public function deleteSucceeded ( $ message = null ) { if ( is_null ( $ message ) ) $ message = $ this -> config [ 'success' ] [ 'delete' ] ; return $ this -> setStatusCode ( 200 ) -> setStatusText ( 'success' ) -> respondWithMessage ( $ message ) ; }
10174	public function delete ( $ pCoord ) { if ( $ pCoord === $ this -> currentCoordinate && $ this -> currentCell !== null ) { $ this -> currentCell -> detach ( ) ; $ this -> currentCoordinate = null ; $ this -> currentCell = null ; $ this -> currentCellIsDirty = false ; } unset ( $ this -> index [ $ pCoord ] ) ; $ this -> cache -> delete ( $ this -> cachePrefix . $ pCoord ) ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
10853	public function setLimit ( $ num , $ offset = 0 ) { $ this -> limit = ( int ) $ num ; $ this -> offset = ( int ) $ offset ; }
9385	public function getGroupedIcons ( ) { if ( $ icons = self :: cache ( ) -> get ( $ this -> getCacheKey ( ) ) ) { return $ icons ; } $ icons = [ ] ; $ data = Yaml :: parse ( $ this -> getSourceData ( ) ) ; if ( isset ( $ data [ 'icons' ] ) ) { foreach ( $ data [ 'icons' ] as $ icon ) { foreach ( $ icon [ 'categories' ] as $ category ) { if ( ! isset ( $ icons [ $ category ] ) ) { $ icons [ $ category ] = [ ] ; } $ icons [ $ category ] [ $ icon [ 'id' ] ] = [ 'name' => $ icon [ 'name' ] , 'unicode' => $ icon [ 'unicode' ] ] ; } } } ksort ( $ icons ) ; foreach ( $ icons as & $ group ) { uasort ( $ group , function ( $ a , $ b ) { return strcasecmp ( $ a [ 'name' ] , $ b [ 'name' ] ) ; } ) ; } self :: cache ( ) -> set ( $ this -> getCacheKey ( ) , $ icons ) ; return $ icons ; }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
8888	public function process ( ServerRequestInterface $ request , RequestHandlerInterface $ requestHandler ) : ResponseInterface { $ this -> container -> set ( ServerRequestInterface :: class , $ request ) ; $ result = $ this -> dispatch ( $ this -> route ( $ request ) ) ; if ( $ result instanceof ResponseInterface ) { return $ result ; } return $ response = ( new Response ( ) ) -> withProtocolVersion ( '1.1' ) -> withBody ( \ GuzzleHttp \ Psr7 \ stream_for ( $ result ) ) ; }
5615	public function paintGroupEnd ( $ message ) { $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ current ) { if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; } else { $ this -> _graph = $ node ; } parent :: paintGroupEnd ( $ message ) ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3994	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_langcode' , 'tl_metamodel_dcasetting' ) , $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'name_value' , 'tl_metamodel_dcasetting' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( 'legendtitle' ) , true ) ) ; }
12971	public function seek ( $ position ) { if ( ! array_key_exists ( $ position , $ this -> elements ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Position %s does not exist in collection' , $ position ) ) ; } reset ( $ this -> elements ) ; while ( key ( $ this -> elements ) !== $ position ) { next ( $ this -> elements ) ; } }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
275	protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return call_user_func ( $ this -> content , $ model , $ key , $ index , $ this ) ; } return $ this -> grid -> emptyCell ; }
1119	public function scopeLimitDepth ( $ query , $ limit ) { $ depth = $ this -> exists ? $ this -> getDepth ( ) : $ this -> getLevel ( ) ; $ max = $ depth + $ limit ; $ scopes = array ( $ depth , $ max ) ; return $ query -> whereBetween ( $ this -> getDepthColumnName ( ) , array ( min ( $ scopes ) , max ( $ scopes ) ) ) ; }
1378	protected function validateIdentifier ( $ value , string $ path , ? int $ index = null ) : bool { $ member = is_int ( $ index ) ? ( string ) $ index : 'data' ; if ( ! is_object ( $ value ) ) { $ this -> memberNotObject ( $ path , $ member ) ; return false ; } $ dataPath = sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) ; $ valid = true ; if ( ! property_exists ( $ value , 'type' ) ) { $ this -> memberRequired ( $ dataPath , 'type' ) ; $ valid = false ; } else if ( ! $ this -> validateTypeMember ( $ value -> type , $ dataPath ) ) { $ valid = false ; } if ( ! property_exists ( $ value , 'id' ) ) { $ this -> memberRequired ( $ dataPath , 'id' ) ; $ valid = false ; } else if ( ! $ this -> validateIdMember ( $ value -> id , $ dataPath ) ) { $ valid = false ; } if ( property_exists ( $ value , 'attributes' ) || property_exists ( $ value , 'relationships' ) ) { $ this -> memberNotIdentifier ( $ path , $ member ) ; $ valid = false ; } return $ valid ; }
457	public function dropUnique ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
4875	public function getMetaData ( $ key = null , $ default = null ) { if ( null === $ key ) { return $ this -> metaData ; } return $ this -> hasMetaData ( $ key ) ? $ this -> metaData [ $ key ] : $ default ; }
9135	public static function parseUrl ( $ url ) : Url { $ parts = parse_url ( $ url ) ; if ( false === $ parts || false === Arrays :: hasElement ( $ parts , 'host' ) || false === Arrays :: hasElement ( $ parts , 'scheme' ) ) { throw new InvalidUrlException ( 'The URL {url} does not contain necessary parts' , array ( 'url' => $ url ) ) ; } $ address = $ parts [ 'host' ] ; $ scheme = $ parts [ 'scheme' ] ; $ query = ( isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ) ; $ port = 0 ; $ path = "/" ; if ( isset ( $ parts [ 'port' ] ) ) { $ port = intval ( $ parts [ 'port' ] ) ; } if ( $ port == 0 ) { $ port = self :: getPortByScheme ( $ scheme ) ; } if ( isset ( $ parts [ 'path' ] ) ) { $ path = $ parts [ 'path' ] ; } return new Url ( $ address , $ port , $ path , $ scheme , $ query ) ; }
10008	public function disconnectWorksheets ( ) { $ worksheet = null ; foreach ( $ this -> workSheetCollection as $ k => & $ worksheet ) { $ worksheet -> disconnectCells ( ) ; $ this -> workSheetCollection [ $ k ] = null ; } unset ( $ worksheet ) ; $ this -> workSheetCollection = [ ] ; }
5659	private function indexWidgetById ( $ widget ) { $ id = $ widget -> getAttribute ( 'id' ) ; if ( ! $ id ) { return ; } if ( ! isset ( $ this -> widgets_by_id [ $ id ] ) ) { $ this -> widgets_by_id [ $ id ] = array ( ) ; } $ this -> widgets_by_id [ $ id ] [ ] = $ widget ; }
10142	private function readDefault ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ this -> pos += 4 + $ length ; }
11150	protected function setCacheState ( $ useCache ) { if ( is_bool ( $ useCache ) ) { $ this -> useCache = $ useCache ; } else { $ this -> useCache = true ; } }
10322	function getSubscribersCount ( $ fromDate = null , $ toDate = null , $ mailingIds = array ( ) , $ contactIds = array ( ) , $ contactEmails = array ( ) , $ contactExternalIds = array ( ) , $ excludeAnonymousContacts = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousContacts ) ) $ params [ 'exclude_anonymous_contacts' ] = ( $ excludeAnonymousContacts == true ) ? "true" : "false" ; return $ this -> get ( 'reports/subscribers/count' , $ params ) ; }
7064	protected function supports ( PaymentInterface $ payment ) { if ( null === $ method = $ payment -> getMethod ( ) ) { throw new RuntimeException ( "Payment method must be set." ) ; } if ( $ method -> isCredit ( ) || $ method -> isOutstanding ( ) ) { return true ; } return false ; }
9989	public function generateNavigation ( ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ sheets = [ ] ; if ( $ this -> sheetIndex === null ) { $ sheets = $ this -> spreadsheet -> getAllSheets ( ) ; } else { $ sheets [ ] = $ this -> spreadsheet -> getSheet ( $ this -> sheetIndex ) ; } $ html = '' ; if ( count ( $ sheets ) > 1 ) { $ sheetId = 0 ; $ html .= '<ul class="navigation">' . PHP_EOL ; foreach ( $ sheets as $ sheet ) { $ html .= ' <li class="sheet' . $ sheetId . '"><a href="#sheet' . $ sheetId . '">' . $ sheet -> getTitle ( ) . '</a></li>' . PHP_EOL ; ++ $ sheetId ; } $ html .= '</ul>' . PHP_EOL ; } return $ html ; }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
6404	public static function propagateIfInstanceOf ( Exception $ exception , string $ exceptionClass ) : void { if ( is_a ( $ exception , $ exceptionClass ) ) { throw $ exception ; } }
7466	public function moveUploadedFile ( ) { $ this -> dateCreated = new DateTime ( ) ; if ( null === $ this -> _uploadedFile ) { return ; } $ this -> _uploadedFile -> move ( dirname ( $ this -> path ) , basename ( $ this -> path ) ) ; $ this -> _uploadedFile = null ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
3573	protected function setInstance ( Attribute $ attribute ) { if ( $ this -> has ( $ attribute -> getMetaKey ( ) ) ) { $ this -> update ( $ attribute ) ; } else { $ this -> items [ $ attribute -> getMetaKey ( ) ] = $ attribute ; } return $ this ; }
1289	public function setType ( string $ type = null ) { $ validTypes = [ 'all' , 'Asset' , 'Entry' , 'Deletion' , 'DeletedAsset' , 'DeletedEntry' ] ; if ( ! \ in_array ( $ type , $ validTypes , true ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Unexpected type "%s".' , $ type ) ) ; } $ this -> type = $ type ; return $ this ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
5483	public function attachLabelBySelector ( SelectorInterface $ selector , $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ selector -> isMatch ( $ this -> widgets [ $ i ] ) ) { if ( method_exists ( $ this -> widgets [ $ i ] , 'setLabel' ) ) { $ this -> widgets [ $ i ] -> setLabel ( $ label ) ; return ; } } } }
5779	public function getOne ( ) : ? string { $ result = $ this -> execute ( ) ; if ( pg_num_rows ( $ result ) == 1 ) { if ( pg_num_fields ( $ result ) == 1 ) { return pg_fetch_array ( $ result ) [ 0 ] ; } else { throw new \ Exception ( "Too many result fields" ) ; } } else { if ( pg_num_rows ( $ result ) == 0 ) { return null ; } else { throw new \ Exception ( "Multiple results" ) ; } } }
6361	public function toDateInterval ( float $ duration ) : DateInterval { Preconditions :: checkState ( $ this -> dateIntervalFormat !== null , '[%s] does not support toDateInterval()' , $ this ) ; return new DateInterval ( sprintf ( $ this -> dateIntervalFormat , $ duration ) ) ; }
5817	public function getFusionTagTypes ( ) { $ types = array ( ) ; $ configuration = Config :: inst ( ) ; $ exclusions = $ configuration -> get ( 'FusionService' , 'tag_type_exclusions' ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'FusionTag' ] ) ; foreach ( $ classes as $ class ) { if ( ( strpos ( strrev ( $ class ) , strrev ( 'Tag' ) ) === 0 ) && ! in_array ( $ class , $ exclusions ) && ! ClassInfo :: classImplements ( $ class , 'TestOnly' ) ) { $ types [ $ class ] = 'Title' ; } } foreach ( $ configuration -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( in_array ( $ type , $ classes ) && ! in_array ( $ type , $ exclusions ) ) { $ types [ $ type ] = $ field ; } } return $ types ; }
11394	public static function setKindOfReportLog ( string $ sKindOfReportLog ) { if ( $ sKindOfReportLog === 'screen' || $ sKindOfReportLog === 'all' ) { self :: $ _sKindOfReportLog = $ sKindOfReportLog ; } else { self :: $ _sKindOfReportLog = 'error_log' ; } }
1557	protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; }
511	protected function formatOptionHelp ( $ name , $ required , $ type , $ defaultValue , $ comment ) { $ comment = trim ( $ comment ) ; $ type = trim ( $ type ) ; if ( strncmp ( $ type , 'bool' , 4 ) === 0 ) { $ type = 'boolean, 0 or 1' ; } if ( $ defaultValue !== null && ! is_array ( $ defaultValue ) ) { if ( $ type === null ) { $ type = gettype ( $ defaultValue ) ; } if ( is_bool ( $ defaultValue ) ) { $ defaultValue = ( int ) $ defaultValue ; } if ( is_string ( $ defaultValue ) ) { $ defaultValue = "'" . $ defaultValue . "'" ; } else { $ defaultValue = var_export ( $ defaultValue , true ) ; } $ doc = "$type (defaults to $defaultValue)" ; } else { $ doc = $ type ; } if ( $ doc === '' ) { $ doc = $ comment ; } elseif ( $ comment !== '' ) { $ doc .= "\n" . preg_replace ( '/^/m' , ' ' , $ comment ) ; } $ name = $ required ? "$name (required)" : $ name ; return $ doc === '' ? $ name : "$name: $doc" ; }
2117	public function getExcludedFields ( ) { $ processed = array ( ) ; $ files = Contao \ System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'dca' ) -> depth ( 0 ) -> files ( ) -> name ( '*.php' ) ; foreach ( $ files as $ file ) { if ( \ in_array ( $ file -> getBasename ( ) , $ processed ) ) { continue ; } $ processed [ ] = $ file -> getBasename ( ) ; $ strTable = $ file -> getBasename ( '.php' ) ; Contao \ System :: loadLanguageFile ( $ strTable ) ; $ this -> loadDataContainer ( $ strTable ) ; } $ arrReturn = array ( ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] as $ k => $ v ) { if ( \ is_array ( $ v [ 'fields' ] ) ) { foreach ( $ v [ 'fields' ] as $ kk => $ vv ) { if ( $ k == 'tl_user' && $ kk == 'admin' && ! $ this -> User -> isAdmin ) { continue ; } if ( $ vv [ 'exclude' ] || $ vv [ 'orig_exclude' ] ) { $ arrReturn [ $ k ] [ Contao \ StringUtil :: specialchars ( $ k . '::' . $ kk ) ] = isset ( $ vv [ 'label' ] [ 0 ] ) ? $ vv [ 'label' ] [ 0 ] . ' <span style="color:#999;padding-left:3px">[' . $ kk . ']</span>' : $ kk ; } } } } ksort ( $ arrReturn ) ; return $ arrReturn ; }
2189	public function unregister ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; if ( ! isset ( $ this -> arrIdentities [ $ intObjectId ] ) ) { return ; } $ strTable = $ objModel -> getTable ( ) ; $ strPk = $ objModel -> getPk ( ) ; $ intPk = $ objModel -> $ strPk ; unset ( $ this -> arrIdentities [ $ intObjectId ] ) ; unset ( $ this -> arrRegistry [ $ strTable ] [ $ intPk ] ) ; $ objModel -> onUnregister ( $ this ) ; }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
5870	protected static function getBasicMetadata ( $ fileName ) { $ extension = strtolower ( substr ( $ fileName , strrpos ( $ fileName , '.' ) + 1 ) ) ; $ metadata = [ ] ; if ( GeneralUtility :: inList ( 'jpg,jpeg,tif,tiff' , $ extension ) && function_exists ( 'exif_read_data' ) ) { $ exif = @ exif_read_data ( $ fileName ) ; if ( $ exif ) { $ metadata = $ exif ; $ metadata [ 'ImageDescription' ] = static :: safeUtf8Encode ( $ metadata [ 'ImageDescription' ] ) ; if ( isset ( $ metadata [ 'GPSLatitude' ] ) && is_array ( $ metadata [ 'GPSLatitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLatitudeRef' ] ) ? $ metadata [ 'GPSLatitudeRef' ] : 'N' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLatitude' ] ) ; $ decimal *= $ reference === 'N' ? 1 : - 1 ; $ metadata [ 'GPSLatitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSLongitude' ] ) && is_array ( $ metadata [ 'GPSLongitude' ] ) ) { $ reference = isset ( $ metadata [ 'GPSLongitudeRef' ] ) ? $ metadata [ 'GPSLongitudeRef' ] : 'E' ; $ decimal = static :: rationalToDecimal ( $ metadata [ 'GPSLongitude' ] ) ; $ decimal *= $ reference === 'E' ? 1 : - 1 ; $ metadata [ 'GPSLongitudeDecimal' ] = $ decimal ; } if ( isset ( $ metadata [ 'GPSAltitude' ] ) ) { $ rationalParts = explode ( '/' , $ metadata [ 'GPSAltitude' ] ) ; if ( ! empty ( $ rationalParts [ 1 ] ) ) { $ metadata [ 'GPSAltitudeDecimal' ] = $ rationalParts [ 0 ] / $ rationalParts [ 1 ] ; } else { $ metadata [ 'GPSAltitudeDecimal' ] = 0 ; } } } $ imageinfo = [ ] ; if ( function_exists ( 'iptcparse' ) && getimagesize ( $ fileName , $ imageinfo ) ) { if ( isset ( $ imageinfo [ 'APP13' ] ) ) { $ data = iptcparse ( $ imageinfo [ 'APP13' ] ) ; $ mapping = [ '2#005' => 'Title' , '2#025' => 'Keywords' , '2#040' => 'Instructions' , '2#080' => 'Creator' , '2#085' => 'CreatorFunction' , '2#090' => 'City' , '2#092' => 'Location' , '2#095' => 'Region' , '2#100' => 'CountryCode' , '2#101' => 'Country' , '2#103' => 'IdentifierWork' , '2#105' => 'CreatorTitle' , '2#110' => 'Credit' , '2#115' => 'Source' , '2#116' => 'Copyright' , '2#120' => 'Description' , '2#122' => 'DescriptionAuthor' , ] ; foreach ( $ mapping as $ iptcKey => $ metadataKey ) { if ( isset ( $ data [ $ iptcKey ] ) ) { $ metadata [ 'IPTC' . $ metadataKey ] = static :: safeUtf8Encode ( $ data [ $ iptcKey ] [ 0 ] ) ; } } } } } return $ metadata ; }
11558	public function save ( ) { $ this -> modifiedTime = new \ DateTime ( 'now' ) ; self :: set ( $ this -> namespace , base64_encode ( serialize ( $ this -> instance ) ) , $ this -> modifiedTime -> getTimestamp ( ) + $ this -> lifetime , $ this -> path , $ this -> domain , $ this -> secure ) ; return $ this ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
1579	public function withType ( string $ type ) : self { if ( empty ( $ type ) ) { throw new \ InvalidArgumentException ( 'Expecting a non-empty string.' ) ; } $ copy = clone $ this ; $ copy -> type = $ type ; $ copy -> normalize ( ) ; return $ copy ; }
1011	private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } if ( $ code === 48 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, unexpected digit after 0: ' . Utils :: printCharCode ( $ code ) ) ; } } else { $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 46 ) { $ isFloat = true ; $ this -> moveStringCursor ( 1 , 1 ) ; $ value .= $ char ; $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 69 || $ code === 101 ) { $ isFloat = true ; $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code === 43 || $ code === 45 ) { $ value .= $ char ; $ this -> moveStringCursor ( 1 , 1 ) ; } $ value .= $ this -> readDigits ( ) ; } return new Token ( $ isFloat ? Token :: FLOAT : Token :: INT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
4362	public static function ordUtf8 ( $ str , & $ offset = 0 , & $ char = null ) { $ code = \ ord ( $ str [ $ offset ] ) ; $ numBytes = 1 ; if ( $ code >= 0x80 ) { if ( $ code < 0xe0 ) { $ numBytes = 2 ; $ code -= 0xC0 ; } elseif ( $ code < 0xf0 ) { $ numBytes = 3 ; $ code -= 0xE0 ; } elseif ( $ code < 0xf8 ) { $ numBytes = 4 ; $ code -= 0xF0 ; } for ( $ i = 1 ; $ i < $ numBytes ; $ i ++ ) { $ code2 = \ ord ( $ str [ $ offset + $ i ] ) - 0x80 ; $ code = $ code * 64 + $ code2 ; } } $ char = \ substr ( $ str , $ offset , $ numBytes ) ; $ offset = $ offset + $ numBytes ; return $ code ; }
9317	public function perform ( $ src , $ dst ) { $ inClusterHandler = eZClusterFileHandler :: instance ( $ src ) ; $ inClusterHandler -> fetch ( ) ; try { $ this -> converter -> transform ( 'transformation' , $ src , $ dst ) ; } catch ( Exception $ e ) { $ inClusterHandler -> deleteLocal ( ) ; throw $ e ; } $ outClusterHandler = eZClusterFileHandler :: instance ( ) ; $ outClusterHandler -> fileStore ( $ dst , 'image' ) ; eZImageHandler :: changeFilePermissions ( $ dst ) ; }
2597	public function isNextTokenAny ( array $ tokens ) { return null !== $ this -> lookahead && in_array ( $ this -> lookahead [ 'type' ] , $ tokens , true ) ; }
517	public function actionFresh ( ) { if ( YII_ENV_PROD ) { $ this -> stdout ( "YII_ENV is set to 'prod'.\nRefreshing migrations is not possible on production systems.\n" ) ; return ExitCode :: OK ; } if ( $ this -> confirm ( "Are you sure you want to reset the database and start the migration from the beginning?\nAll data will be lost irreversibly!" ) ) { $ this -> truncateDatabase ( ) ; $ this -> actionUp ( ) ; } else { $ this -> stdout ( 'Action was cancelled by user. Nothing has been performed.' ) ; } }
10134	public function positionImage ( $ col_start , $ row_start , $ x1 , $ y1 , $ width , $ height ) { $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) ) { $ x1 = 0 ; } if ( $ y1 >= Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ) { $ width -= Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) ; ++ $ col_end ; } while ( $ height >= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ) { $ height -= Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) == 0 ) { return ; } if ( Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_start + 1 ) ) * 1024 ; $ y1 = $ y1 / Xls :: sizeRow ( $ this -> phpSheet , $ row_start + 1 ) * 256 ; $ x2 = $ width / Xls :: sizeCol ( $ this -> phpSheet , Coordinate :: stringFromColumnIndex ( $ col_end + 1 ) ) * 1024 ; $ y2 = $ height / Xls :: sizeRow ( $ this -> phpSheet , $ row_end + 1 ) * 256 ; $ this -> writeObjPicture ( $ col_start , $ x1 , $ row_start , $ y1 , $ col_end , $ x2 , $ row_end , $ y2 ) ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
9178	public function getDatabaseById ( $ id ) { foreach ( $ this -> databases as $ database ) { if ( $ database -> getId ( ) === $ id ) { return $ database ; } } throw new \ Exception ( sprintf ( 'Database with ID %s can not be found' , $ id ) ) ; }
10056	public function getItem ( $ key ) { if ( $ this -> hasItem ( $ key ) !== true ) { $ this -> data [ $ key ] = new CacheItem ( $ key , null , false ) ; } return $ this -> data [ $ key ] ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
1347	public function isReadProcesses ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isProcesses ( ) && $ this -> getRoute ( ) -> isNotProcess ( ) ; }
8243	public function loginAttempt ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; $ dummy = bin2hex ( \ random_bytes ( 32 ) ) ; $ dummyHash = $ encoder -> encode ( $ dummy ) ; if ( ! $ userData ) { $ encoder -> isValid ( $ dummyHash , $ password ) ; return false ; } return $ encoder -> isValid ( $ userData [ 'pwhash' ] , $ password -> get ( ) ) ; }
7133	protected function getSupplierOrderFromEvent ( ResourceEventInterface $ event ) { $ order = $ event -> getResource ( ) ; if ( ! $ order instanceof SupplierOrderInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderInterface." ) ; } return $ order ; }
11045	function read_content ( ) { if ( $ this -> external_source_read ) { $ fct = $ this -> source_read_name ; return $ fct ( $ this -> container ) ; } else { $ content = FALSE ; if ( $ handle = @ fopen ( $ this -> container , 'rb' ) ) { $ size = @ filesize ( $ this -> container ) ; $ content = @ fread ( $ handle , $ size ) ; fclose ( $ handle ) ; } return $ content ; } }
5899	public function listFunctionalities ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/functionalities' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Functionality ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
293	public function getAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) ? $ this -> _attributes [ $ name ] : null ; }
6889	protected function getAssignments ( $ item ) { if ( $ item instanceof ShipmentItemInterface ) { $ item = $ item -> getSaleItem ( ) ; } elseif ( $ item instanceof InvoiceLineInterface ) { if ( ! $ item = $ item -> getSaleItem ( ) ) { return null ; } } if ( ! $ this -> supportsAssignment ( $ item ) ) { return null ; } return $ item -> getStockAssignments ( ) -> toArray ( ) ; }
5158	public static function create ( array $ data ) : \ One \ Model \ Gallery { $ body = self :: validateString ( ( string ) self :: checkData ( $ data , 'body' , '' ) ) ; $ order = self :: validateInteger ( ( int ) self :: checkData ( $ data , 'order' , null ) ) ; $ photo = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'photo' , '' ) ) ; $ source = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'source' , '' ) ) ; $ lead = self :: validateString ( ( string ) self :: checkData ( $ data , 'lead' , '' ) ) ; return self :: createGallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
3145	public function pause ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> suspend ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'pause' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
8875	public function getMimeType ( $ attachment ) { $ attachment = explode ( '.' , basename ( $ attachment ) ) ; if ( ! isset ( $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ) ) { pines_error ( 'MIME Type not found.' ) ; return null ; } return $ this -> mimeTypes [ strtolower ( $ attachment [ count ( $ attachment ) - 1 ] ) ] ; }
2718	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; if ( $ read -> isExist ( $ snippetPath ) ) { $ explodeId = explode ( '.' , $ snippet , - 1 ) ; $ snippetParts = explode ( '_' , $ explodeId [ 0 ] , 3 ) ; $ type = $ snippetParts [ 0 ] ; $ priority = $ snippetParts [ 1 ] ; $ name = $ snippetParts [ 2 ] ; $ content = $ read -> readFile ( $ snippetPath ) ; } else { throw new LocalizedException ( __ ( 'Custom snippet not found.' ) ) ; } return $ result -> setData ( [ 'status' => true , 'type' => $ type , 'priority' => $ priority , 'name' => $ name , 'content' => $ content , 'original' => $ snippet ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12784	protected function isNoResultMask ( $ mask ) { foreach ( $ this -> noResultMasks as $ noresultMask ) { if ( $ mask === $ noresultMask ) { return TRUE ; } if ( ( $ mask & $ noresultMask ) === $ noresultMask ) { $ this -> noResultMasks [ ] = $ mask ; return TRUE ; } } return FALSE ; }
9412	public function getAuthority ( ) { $ authority = $ this -> host ; if ( $ this -> host !== '' && $ this -> user !== null ) { $ authority = $ this -> user . '@' . $ authority ; $ authority = $ authority . ':' . $ this -> port ; } return $ authority ; }
3756	public function createVariant ( ConfigInterface $ objConfig ) { $ objItem = $ this -> getMetaModel ( ) -> findById ( $ objConfig -> getId ( ) ) -> varCopy ( ) ; if ( ! $ objItem ) { return null ; } $ model = new Model ( $ objItem ) ; $ model -> setMeta ( $ model :: IS_CHANGED , true ) ; return $ model ; }
11610	public function connect ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , 'user_id' => \ Yii :: $ app -> user -> id , ] ) ; $ account -> save ( false ) ; \ Yii :: $ app -> session -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your account has been connected' ) ) ; } else if ( null == $ account -> user ) { $ account -> user_id = \ Yii :: $ app -> user -> id ; $ account -> save ( false ) ; } else { \ Yii :: $ app -> session -> setFlash ( 'error' , \ Yii :: t ( 'user' , 'This account has already been connected to another user' ) ) ; } $ this -> action -> successUrl = Url :: to ( [ '/user/settings/networks' ] ) ; }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
10240	public function calculateCellValue ( Cell $ pCell = null , $ resetLog = true ) { if ( $ pCell === null ) { return null ; } $ returnArrayAsType = self :: $ returnArrayAsType ; if ( $ resetLog ) { $ this -> formulaError = null ; $ this -> debugLog -> clearLog ( ) ; $ this -> cyclicReferenceStack -> clear ( ) ; $ this -> cyclicFormulaCounter = 1 ; self :: $ returnArrayAsType = self :: RETURN_ARRAY_AS_ARRAY ; } $ this -> cellStack [ ] = [ 'sheet' => $ pCell -> getWorksheet ( ) -> getTitle ( ) , 'cell' => $ pCell -> getCoordinate ( ) , ] ; try { $ result = self :: unwrapResult ( $ this -> _calculateFormulaValue ( $ pCell -> getValue ( ) , $ pCell -> getCoordinate ( ) , $ pCell ) ) ; $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; } catch ( \ Exception $ e ) { $ cellAddress = array_pop ( $ this -> cellStack ) ; $ this -> spreadsheet -> getSheetByName ( $ cellAddress [ 'sheet' ] ) -> getCell ( $ cellAddress [ 'cell' ] ) ; throw new Exception ( $ e -> getMessage ( ) ) ; } if ( ( is_array ( $ result ) ) && ( self :: $ returnArrayAsType != self :: RETURN_ARRAY_AS_ARRAY ) ) { self :: $ returnArrayAsType = $ returnArrayAsType ; $ testResult = Functions :: flattenArray ( $ result ) ; if ( self :: $ returnArrayAsType == self :: RETURN_ARRAY_AS_ERROR ) { return Functions :: VALUE ( ) ; } if ( count ( $ testResult ) != 1 ) { $ r = array_keys ( $ result ) ; $ r = array_shift ( $ r ) ; if ( ! is_numeric ( $ r ) ) { return Functions :: VALUE ( ) ; } if ( is_array ( $ result [ $ r ] ) ) { $ c = array_keys ( $ result [ $ r ] ) ; $ c = array_shift ( $ c ) ; if ( ! is_numeric ( $ c ) ) { return Functions :: VALUE ( ) ; } } } $ result = array_shift ( $ testResult ) ; } self :: $ returnArrayAsType = $ returnArrayAsType ; if ( $ result === null ) { return 0 ; } elseif ( ( is_float ( $ result ) ) && ( ( is_nan ( $ result ) ) || ( is_infinite ( $ result ) ) ) ) { return Functions :: NAN ( ) ; } return $ result ; }
7086	public function setOptionLabelColumnForDefaultOptionsLoader ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) && ! ( $ columnNameOrClosure instanceof \ Closure ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string, DbExpr or a Closure' ) ; } $ this -> optionLabelColumnForDefaultOptionsLoader = $ columnNameOrClosure ; return $ this ; }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
8184	public function getPeakMemoryUsage ( ) { return isset ( $ this -> ends [ 'pmu' ] ) && isset ( $ this -> starts [ 'pmu' ] ) ? $ this -> ends [ 'pmu' ] - $ this -> starts [ 'pmu' ] : 0 ; }
10734	public function setLower ( $ lower ) : self { if ( ! is_numeric ( $ lower ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, lower, to be a number" ) ; } $ this -> lower = + $ lower ; return $ this ; }
2288	public static function findUnactivatedByEmail ( $ strEmail , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE email=? AND disable='1' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn>? AND o.confirmedOn=0)" ) -> limit ( 1 ) -> execute ( $ strEmail , strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objMember = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objMember ; } return new static ( $ objResult ) ; }
6215	public function getParameters ( ) { $ parameters = $ this -> getUnfilteredParameters ( ) ; foreach ( $ this -> parameterFilters as $ filter ) { $ filter -> filter ( $ parameters ) ; } return $ parameters ; }
8206	protected function buryJob ( $ job , $ priority = null ) { if ( is_null ( $ priority ) ) { $ priority = Pheanstalk :: DEFAULT_PRIORITY ; } $ this -> getPheanstalk ( ) -> bury ( $ job , $ priority ) ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
7799	protected function getLine ( $ id , $ text , $ offset = 0 , & $ position = null , & $ length = null ) { $ pcre = '/(?:^|\r?\n)\:(' . $ id . ')\:' . '(.+)' . '(:?$|\r?\n\:[[:alnum:]]{2,3}\:)' . '/Us' ; if ( preg_match ( $ pcre , substr ( $ text , $ offset ) , $ match , PREG_OFFSET_CAPTURE ) ) { $ position = $ offset + $ match [ 1 ] [ 1 ] - 1 ; $ length = strlen ( $ match [ 2 ] [ 0 ] ) ; return rtrim ( $ match [ 2 ] [ 0 ] ) ; } return '' ; }
11739	public function getMd5Address ( $ scheme = true , $ www = true ) { return md5 ( $ this -> normalize ( $ scheme , $ www ) ) ; }
9432	protected static function random ( $ float_min , $ float_max ) { if ( $ float_max >= 0 ) { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_max * $ r -> get ( ) ; if ( $ float_prov >= $ float_min ) { return $ float_prov ; } } } else { $ r = new Random ( ) ; while ( true ) { $ float_prov = $ float_min * $ r -> get ( ) ; if ( $ float_prov <= $ float_max ) { return $ float_prov ; } } } }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
9338	public function isSupplementary ( Angle $ angle ) { $ out = new self ( $ this -> float_rad + $ angle -> rad ) ; return $ out -> isStraight ( ) ; }
4536	public function setTenantIdIn ( array $ tenantIdIn ) { $ this -> tenantIdIn = $ tenantIdIn ; $ this -> _tenantIdIn = null !== $ tenantIdIn ; return $ this ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
2341	protected function getUsername ( ) { if ( $ this -> strUsername !== null ) { return $ this -> strUsername ; } $ this -> import ( BackendUser :: class , 'User' ) ; return $ this -> User -> username ; }
5861	protected function compileRulesets ( array $ rulesets ) { $ out = [ ] ; $ elements = $ rulesets [ 'data' ] [ 'sDEF' ] [ 'lDEF' ] [ 'ruleset' ] [ 'el' ] ; foreach ( $ elements as $ container ) { if ( isset ( $ container [ 'container' ] [ 'el' ] ) ) { $ values = [ ] ; foreach ( $ container [ 'container' ] [ 'el' ] as $ key => $ value ) { if ( $ key === 'title' ) { continue ; } $ values [ $ key ] = $ value [ 'vDEF' ] ; } $ out [ ] = $ this -> expandValuesInRuleset ( $ values ) ; } } return $ out ; }
2153	public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; if ( TL_MODE == 'FE' ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ intUser = $ this -> User -> id ; } if ( ! $ intUser ) { return ; } if ( TL_MODE == 'FE' || Input :: get ( 'act' ) == 'edit' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email, disable FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ strEmail = Input :: post ( 'email' , true ) ; if ( ! empty ( $ _POST ) && $ strEmail != '' && $ strEmail != $ objUser -> email ) { $ objCount = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ strEmail ) ; if ( $ objCount -> count > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET email=? WHERE email=?" ) -> execute ( $ strEmail , $ objUser -> email ) ; } $ objUser -> email = $ strEmail ; } $ objSubscriptions = $ this -> Database -> prepare ( "SELECT pid FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; if ( $ objSubscriptions -> numRows ) { $ strNewsletters = serialize ( $ objSubscriptions -> fetchEach ( 'pid' ) ) ; } else { $ strNewsletters = '' ; } $ this -> Database -> prepare ( "UPDATE tl_member SET newsletter=? WHERE id=?" ) -> execute ( $ strNewsletters , $ intUser ) ; if ( TL_MODE == 'FE' ) { $ this -> User -> newsletter = $ strNewsletters ; } elseif ( ! empty ( $ _POST ) && Input :: post ( 'disable' ) != $ objUser -> disable ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active=? WHERE email=?" ) -> execute ( ( Input :: post ( 'disable' ) ? '' : 1 ) , $ objUser -> email ) ; $ objUser -> disable = Input :: post ( 'disable' ) ; } } } elseif ( Input :: get ( 'act' ) == 'delete' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } } }
12120	public function onViewCreate ( ContentfulViewEvent $ e ) { $ viewMeta = $ e -> getView ( ) -> cfMeta ; $ updated = $ viewMeta [ 'updatedAt' ] ; $ this -> itemIds [ $ viewMeta [ 'itemId' ] ] = true ; if ( $ this -> lastModifiedContent === null ) { $ this -> lastModifiedContent = $ updated ; } else { if ( $ this -> lastModifiedContent < $ updated ) { $ this -> lastModifiedContent = $ updated ; } } }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
10103	private function writeDimensions ( ) { $ record = 0x0200 ; $ length = 0x000E ; $ data = pack ( 'VVvvv' , $ this -> firstRowIndex , $ this -> lastRowIndex + 1 , $ this -> firstColumnIndex , $ this -> lastColumnIndex + 1 , 0x0000 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ data ) ; }
5103	public static function appendSet ( $ values , $ forceExist = false ) { if ( $ forceExist && ! $ values ) throw new SquidException ( 'SET clause must be present for this type of command!' ) ; return Assembly :: append ( 'SET' , $ values , ', ' ) ; }
12382	public static function lastMonth ( ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonth ( ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonth ( ) -> lastOfMonth ( ) ) ; return $ hits_count ; }
4838	public function new_limit_url ( $ type , $ params ) { $ request = array ( ) ; $ params [ 'merchant_id' ] = $ this -> account_details [ 'merchant_id' ] ; $ opt_params = array ( 'redirect_uri' , 'cancel_uri' , 'state' ) ; foreach ( $ opt_params as $ opt_param ) { if ( isset ( $ params [ $ opt_param ] ) ) { $ request [ $ opt_param ] = $ params [ $ opt_param ] ; unset ( $ params [ $ opt_param ] ) ; } } if ( ! isset ( $ request [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ request [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ payment_params = array ( $ type => $ params ) ; $ request = array_merge ( $ request , $ payment_params , $ this -> generate_mandatory_params ( ) ) ; $ request [ 'signature' ] = GoCardless_Utils :: generate_signature ( $ request , $ this -> account_details [ 'app_secret' ] ) ; $ query_string = GoCardless_Utils :: generate_query_string ( $ request ) ; return $ this -> base_url . '/connect/' . $ type . 's/new?' . $ query_string ; }
2747	public function getGeoIpMappingForCountry ( $ countryCode ) { if ( $ mapping = $ this -> _scopeConfig -> getValue ( self :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ) ) { return $ this -> extractMapping ( $ mapping , $ countryCode ) ; } return null ; }
2539	protected function executeMethodOnSoapClientForMsg ( $ msgName , $ method ) { $ result = null ; $ soapClient = $ this -> getSoapClient ( $ msgName ) ; if ( $ soapClient instanceof \ SoapClient ) { $ result = $ soapClient -> $ method ( ) ; } return $ result ; }
9887	static function init ( ) { if ( self :: $ initialized == false ) { self :: $ NONE = new Permission ( 1 , "none" ) ; self :: $ SOI = new Permission ( 2 , "soi" ) ; self :: $ COI = new Permission ( 3 , "coi" ) ; self :: $ DOI = new Permission ( 4 , "doi" ) ; self :: $ DOI_PLUS = new Permission ( 5 , "doi+" ) ; self :: $ OTHER = new Permission ( 6 , "other" ) ; self :: $ initialized = true ; } }
10364	public function offsetSet ( $ item , $ node ) { if ( $ item !== null ) { throw new ValueException ( $ item , 'null' ) ; } return $ this -> nodes [ ] = $ node ; }
9517	public function recreate ( $ file ) { if ( is_file ( $ file ) ) { return ; } $ virtual = $ tables = $ indexes = array ( ) ; if ( $ result = $ this -> query ( 'SELECT type, name, sql FROM sqlite_master' ) ) { while ( list ( $ type , $ name , $ sql ) = $ this -> fetch ( $ result ) ) { if ( ! empty ( $ sql ) ) { switch ( $ type ) { case 'table' : $ tables [ $ name ] = $ sql ; break ; case 'index' : $ indexes [ ] = $ sql ; break ; } } } $ this -> close ( $ result ) ; } foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ sql , 'VIRTUAL TABLE' ) ) { $ virtual [ ] = $ name ; } } foreach ( $ virtual as $ table ) { foreach ( $ tables as $ name => $ sql ) { if ( strpos ( $ name , "{$table}_" ) === 0 ) { unset ( $ tables [ $ name ] ) ; } } } $ db = new self ( $ file ) ; $ this -> exec ( 'ATTACH DATABASE ' . $ this -> dbEscape ( $ file ) . ' AS recreate' ) ; foreach ( $ tables as $ table => $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; if ( $ fields = $ this -> row ( 'SELECT * FROM ' . $ table . ' LIMIT 1' , '' , 'assoc' ) ) { $ fields = implode ( ', ' , array_keys ( $ fields ) ) ; $ this -> exec ( "INSERT INTO recreate.{$table} ({$fields}) SELECT * FROM {$table}" ) ; } } foreach ( $ indexes as $ sql ) { $ db -> connection ( ) -> exec ( $ sql ) ; } $ db -> connection ( ) -> close ( ) ; }
7462	public function getContent ( string $ name , array $ data = [ ] ) : string { $ cacheName = $ name ; if ( '' == $ name ) { $ this -> isRouteView = true ; $ stack = debug_backtrace ( ) ; foreach ( $ stack as $ item ) { if ( false !== stripos ( $ item [ 'file' ] , DIRECTORY_SEPARATOR . 'Route' . DIRECTORY_SEPARATOR ) ) { $ cacheName = pathinfo ( $ item [ 'file' ] , PATHINFO_DIRNAME ) . '/' . $ name ; $ cacheName = explode ( 'Route' . DIRECTORY_SEPARATOR , $ cacheName ) [ 1 ] ; $ cacheName = 'route_' . str_replace ( [ '/' , '\\' ] , '_' , $ cacheName ) ; break ; } } } $ cacheName .= '_' . $ this -> language . '.html.php' ; $ path = $ this -> packageRoot . '/view/_cache/' . str_replace ( '/' , '_' , $ cacheName ) ; $ exist = file_exists ( $ path ) ; if ( ! $ this -> cache || ! $ exist ) { $ code = $ this -> compile ( $ name . '/view.html.php' , true , true , true ) ; $ code = preg_replace ( [ '/\>[^\S ]+/s' , '/[^\S ]+\</s' , '/(\s)+/s' ] , [ '>' , '<' , '\\1' ] , $ code ) ; if ( $ exist ) { $ fh = fopen ( $ path , 'r+b' ) ; } else { $ fh = fopen ( $ path , 'wb' ) ; } if ( flock ( $ fh , LOCK_EX ) ) { ftruncate ( $ fh , 0 ) ; fwrite ( $ fh , $ code ) ; flock ( $ fh , LOCK_UN ) ; } fclose ( $ fh ) ; } $ fh = fopen ( $ path , 'rb' ) ; if ( flock ( $ fh , LOCK_SH ) ) { $ html = self :: renderTemplate ( $ path , $ data ) ; flock ( $ fh , LOCK_UN ) ; fclose ( $ fh ) ; return $ html ; } throw new \ RuntimeException ( 'Can\'t render template' ) ; }
959	public function cancel ( ) { if ( ! $ this -> isType ( self :: CHARGE_ONETIME ) && ! $ this -> isType ( self :: CHARGE_RECURRING ) ) { throw new Exception ( 'Cancel may only be called for single and recurring charges.' ) ; } $ this -> status = self :: STATUS_CANCELLED ; $ this -> cancelled_on = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return $ this -> save ( ) ; }
4282	public function stream_truncate ( $ size ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ ftruncate ( $ this -> handle , $ size ) ; self :: register ( ) ; return $ success ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
6040	public function download ( $ sessionId , array $ downloads ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'downloads' => $ downloads ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/download' , $ parameters , true ) ; return $ result ; }
815	private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } }
5698	public function baseTransform ( ) { parent :: baseTransform ( ) ; $ disabled = ( ! $ this -> gridFieldRequest -> getNextRecordID ( ) ) ; return $ this -> setDisabled ( $ disabled ) ; }
10444	protected function handleStatement ( $ line , $ type ) { if ( ! preg_match ( "/^{$type}$/" , $ line ) ) { throw new \ UnexpectedValueException ( "Expected a {$type} statement, got {$line}" ) ; } $ params = [ ] ; $ param = $ this -> handleParam ( ) ; while ( $ param !== null ) { $ params = $ params + $ param ; $ param = $ this -> handleParam ( ) ; } return $ params ; }
12385	public function permalinksByLanguage ( $ language = null ) { $ result = array ( ) ; if ( null === $ language ) { $ language = $ this -> currentLanguage ; } foreach ( $ this -> pages as $ page ) { foreach ( $ page [ "seo" ] as $ pageAttribute ) { if ( $ pageAttribute [ "language" ] != $ language ) { continue ; } $ result [ ] = $ pageAttribute [ "permalink" ] ; } } return $ result ; }
12515	public static function exists ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; return $ fs -> exists ( $ path ) ; }
8304	public function assertInteger ( $ config , $ key , $ lowest = null , $ highest = null ) { if ( array_key_exists ( $ key , $ config ) ) { if ( ! is_int ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be an integer." ) ; } if ( $ lowest !== null && $ config [ $ key ] < $ lowest ) { throw new ConfigurationException ( $ key . " cannot be lower than " . $ lowest ) ; } if ( $ highest !== null && $ config [ $ key ] > $ highest ) { throw new ConfigurationException ( $ key . " cannot be higher than " . $ highest ) ; } } return $ this ; }
613	protected function build ( $ class , $ params , $ config ) { list ( $ reflection , $ dependencies ) = $ this -> getDependencies ( $ class ) ; foreach ( $ params as $ index => $ param ) { $ dependencies [ $ index ] = $ param ; } $ dependencies = $ this -> resolveDependencies ( $ dependencies , $ reflection ) ; if ( ! $ reflection -> isInstantiable ( ) ) { throw new NotInstantiableException ( $ reflection -> name ) ; } if ( empty ( $ config ) ) { return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ config = $ this -> resolveDependencies ( $ config ) ; if ( ! empty ( $ dependencies ) && $ reflection -> implementsInterface ( 'yii\base\Configurable' ) ) { $ dependencies [ count ( $ dependencies ) - 1 ] = $ config ; return $ reflection -> newInstanceArgs ( $ dependencies ) ; } $ object = $ reflection -> newInstanceArgs ( $ dependencies ) ; foreach ( $ config as $ name => $ value ) { $ object -> $ name = $ value ; } return $ object ; }
3232	static function findError ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; $ matchResult = preg_match ( '%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBD] # excluding overlongs, FFFE, and FFFF | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates )*$%xs' , $ path ) ; if ( $ matchResult !== 1 ) { return "must be valid UTF-8; BMP only, no surrogates, no U+FFFE or U+FFFF" ; } if ( $ path [ 0 ] !== "/" ) return "must start with \"/\"" ; $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; if ( $ path [ $ l - 1 ] === "/" ) return "must not end with \"/\"" ; return null ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
5022	protected function copyArrayValues ( array $ source , array $ keys ) { $ target = [ ] ; foreach ( $ keys as $ key => $ spec ) { if ( is_int ( $ key ) ) { $ key = $ spec ; $ spec = null ; } if ( ! array_key_exists ( $ key , $ source ) ) { continue ; } if ( null === $ spec ) { $ target [ $ key ] = $ source [ $ key ] ; continue ; } if ( is_string ( $ spec ) ) { $ target [ $ spec ] [ $ key ] = $ source [ $ key ] ; continue ; } if ( isset ( $ spec [ 'if' ] ) && $ source [ $ key ] !== $ spec [ 'if' ] ) { continue ; } if ( isset ( $ spec [ 'key' ] ) ) { $ targetKeys = is_array ( $ spec [ 'key' ] ) ? $ spec [ 'key' ] : [ $ spec [ 'key' ] ] ; $ value = isset ( $ spec [ 'value' ] ) ? $ spec [ 'value' ] : $ source [ $ key ] ; } else { $ targetKeys = $ spec ; $ value = $ source [ $ key ] ; } $ tmpTarget = & $ target ; foreach ( $ targetKeys as $ targetKey ) { if ( '*' == $ targetKey ) { $ targetKey = $ key ; } if ( ! isset ( $ tmpTarget [ $ targetKey ] ) ) { $ tmpTarget [ $ targetKey ] = [ ] ; } $ tmpTarget = & $ tmpTarget [ $ targetKey ] ; } $ tmpTarget = $ value ; } return $ target ; }
3104	public function save ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ success = $ storage -> set ( $ this -> userId , $ this -> getStorageKey ( ) , json_encode ( $ this -> state ) ) ; } else { $ success = false ; } return $ success ; }
12873	protected function getElementValidatorChain ( \ Zend \ Form \ Element $ element ) { $ elementName = $ element -> getAttribute ( 'name' ) ; return $ this -> form -> getInputFilter ( ) -> get ( $ elementName ) -> getValidatorChain ( ) ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
6354	public static function setFakeTime ( $ fakeTime ) { if ( is_string ( $ fakeTime ) ) { $ fakeTime = ( int ) static :: convert ( TS_UNIX , $ fakeTime ) ; } if ( is_int ( $ fakeTime ) ) { $ fakeTime = function ( ) use ( $ fakeTime ) { return $ fakeTime ; } ; } $ old = static :: $ fakeTimeCallback ; static :: $ fakeTimeCallback = $ fakeTime ? $ fakeTime : null ; return $ old ; }
10685	public function get ( $ parameter ) { switch ( $ parameter ) { case "dev" : return $ this -> dev ?? true ; case "config" : return $ this -> config ; case "injector" : return $ this -> injector ; case "pathConfig" : return $ this -> path_config ; case "request" : return $ this -> request ; case "resolver" : return $ this -> resolver ; case "moduleManager" : return $ this -> module_manager ; case "auth" : return $ this -> injector -> getInstance ( Authentication :: class ) ; case "db" : return $ this -> injector -> getInstance ( DB :: class ) ; case "dispatcher" : return $ this -> injector -> getInstance ( Dispatcher :: class ) ; case "template" : return $ this -> injector -> getInstance ( Template :: class ) ; case "mailer" : return $ this -> injector -> getInstance ( SMTPSender :: class ) ; case "i18n" : return $ this -> injector -> getInstance ( I18n :: class ) ; case "processChain" : return $ this -> injector -> getInstance ( ProcessChain :: class ) ; } throw new InvalidArgumentException ( "No such object: $parameter" ) ; }
11081	public static function GUIDv4 ( ) { return sprintf ( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x' , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0x0fff ) | 0x4000 , mt_rand ( 0 , 0x3fff ) | 0x8000 , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) , mt_rand ( 0 , 0xffff ) ) ; }
11125	public function index ( Request $ request ) { $ this -> settingRepository -> pushCriteria ( new RequestCriteria ( $ request ) ) ; $ settings = $ this -> settingRepository -> all ( ) ; $ dateFormats = DateFormatter :: dropdownArray ( ) ; return view ( 'l5starter::admin.settings.index' ) -> with ( [ 'dateFormats' => $ dateFormats , 'settings' => $ settings , ] ) ; }
4624	public function pickNewNode ( ) { $ this -> getActiveNode ( ) -> setInactive ( true ) ; $ this -> attempts ++ ; $ this -> inactiveNodes [ $ this -> getActiveNodeIndex ( ) ] = $ this -> getActiveNode ( ) ; unset ( $ this -> nodes [ $ this -> getActiveNodeIndex ( ) ] ) ; $ this -> setActiveNodeIndex ( $ this -> pickNode ( ) ) ; return $ this ; }
5181	private function appendToArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] = [ $ this -> props [ $ key ] , $ value ] ; return $ this ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
6810	public function rates ( Adjustment ... $ adjustments ) : string { return implode ( ', ' , array_map ( function ( Adjustment $ adjustment ) { return $ this -> percent ( $ adjustment -> getRate ( ) ) ; } , $ adjustments ) ) ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
7300	public static function load_class ( $ class_name = NULL ) { if ( NULL === $ class_name ) { foreach ( glob ( dirname ( __FILE__ ) . '/*.php' ) as $ path ) { require_once $ path ; } } else { if ( 0 !== strpos ( $ class_name , 'Iac_' ) ) return FALSE ; $ path = dirname ( __FILE__ ) . '/class-' . $ class_name . '.php' ; if ( file_exists ( $ path ) ) { require_once $ path ; return TRUE ; } } return FALSE ; }
10641	public function andWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
8503	public function setGetCompetitivePricingForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
920	private function fixDescription ( DocBlock $ doc ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { break ; } if ( $ line -> containsUsefulContent ( ) ) { $ next = $ doc -> getLine ( $ index + 1 ) ; if ( $ next -> containsATag ( ) ) { $ line -> addBlank ( ) ; break ; } } } }
9891	protected function createHint ( ) { if ( $ this -> getElement ( ) -> getHint ( ) ) { $ this -> hint = $ this -> builder -> make ( 'hint' , $ this -> getElement ( ) -> getHintAttributes ( ) , $ this -> getElement ( ) -> getHint ( ) ) ; } }
10350	protected function validate ( ) { $ this -> validateArgSet ( $ this -> args ) ; if ( $ this -> success ) { $ this -> validateArgSet ( $ this -> successArgs ) ; } if ( ! $ this -> success ) { $ this -> validateArgSet ( $ this -> failureArgs ) ; } }
10097	private function writeBIFF8CellRangeAddressFixed ( $ range ) { $ explodes = explode ( ':' , $ range ) ; $ firstCell = $ explodes [ 0 ] ; if ( count ( $ explodes ) == 1 ) { $ lastCell = $ firstCell ; } else { $ lastCell = $ explodes [ 1 ] ; } $ firstCellCoordinates = Coordinate :: coordinateFromString ( $ firstCell ) ; $ lastCellCoordinates = Coordinate :: coordinateFromString ( $ lastCell ) ; return pack ( 'vvvv' , $ firstCellCoordinates [ 1 ] - 1 , $ lastCellCoordinates [ 1 ] - 1 , Coordinate :: columnIndexFromString ( $ firstCellCoordinates [ 0 ] ) - 1 , Coordinate :: columnIndexFromString ( $ lastCellCoordinates [ 0 ] ) - 1 ) ; }
5480	protected function addCheckbox ( $ tag ) { if ( ! isset ( $ this -> checkboxes [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = $ tag ; $ this -> checkboxes [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } else { $ index = $ this -> checkboxes [ $ tag -> getName ( ) ] ; if ( ! is_a ( $ this -> widgets [ $ index ] , 'SimpleCheckboxGroup' ) ) { $ previous = $ this -> widgets [ $ index ] ; $ this -> widgets [ $ index ] = new SimpleCheckboxGroup ( ) ; $ this -> widgets [ $ index ] -> addWidget ( $ previous ) ; } $ this -> widgets [ $ index ] -> addWidget ( $ tag ) ; } }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
3194	public function getExtraTime ( $ maxTime = 0 ) { if ( $ maxTime && $ this -> getExtendedTime ( ) ) { $ secondsNew = $ maxTime * $ this -> getExtendedTime ( ) ; $ extraTime = $ secondsNew - $ maxTime ; $ this -> setExtraTime ( $ extraTime ) ; return $ extraTime ; } return $ this -> extraTime ; }
5166	protected function filterUriInstance ( $ uri ) : string { if ( $ uri instanceof UriInterface ) { return ( string ) $ uri ; } if ( is_string ( $ uri ) ) { return ( string ) \ One \ createUriFromString ( $ uri ) ; } return '' ; }
1553	protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; }
6602	public function make ( $ key , $ secret ) { $ this -> credentials [ 'key' ] = $ key ; $ this -> credentials [ 'secret' ] = $ secret ; return $ this ; }
10200	private function writeXfStyles ( XMLWriter $ writer , Spreadsheet $ spreadsheet ) { foreach ( $ spreadsheet -> getCellXfCollection ( ) as $ style ) { $ writer -> startElement ( 'style:style' ) ; $ writer -> writeAttribute ( 'style:name' , self :: CELL_STYLE_PREFIX . $ style -> getIndex ( ) ) ; $ writer -> writeAttribute ( 'style:family' , 'table-cell' ) ; $ writer -> writeAttribute ( 'style:parent-style-name' , 'Default' ) ; $ writer -> startElement ( 'style:text-properties' ) ; $ font = $ style -> getFont ( ) ; if ( $ font -> getBold ( ) ) { $ writer -> writeAttribute ( 'fo:font-weight' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-complex' , 'bold' ) ; $ writer -> writeAttribute ( 'style:font-weight-asian' , 'bold' ) ; } if ( $ font -> getItalic ( ) ) { $ writer -> writeAttribute ( 'fo:font-style' , 'italic' ) ; } if ( $ color = $ font -> getColor ( ) ) { $ writer -> writeAttribute ( 'fo:color' , sprintf ( '#%s' , $ color -> getRGB ( ) ) ) ; } if ( $ family = $ font -> getName ( ) ) { $ writer -> writeAttribute ( 'fo:font-family' , $ family ) ; } if ( $ size = $ font -> getSize ( ) ) { $ writer -> writeAttribute ( 'fo:font-size' , sprintf ( '%.1fpt' , $ size ) ) ; } if ( $ font -> getUnderline ( ) && $ font -> getUnderline ( ) != Font :: UNDERLINE_NONE ) { $ writer -> writeAttribute ( 'style:text-underline-style' , 'solid' ) ; $ writer -> writeAttribute ( 'style:text-underline-width' , 'auto' ) ; $ writer -> writeAttribute ( 'style:text-underline-color' , 'font-color' ) ; switch ( $ font -> getUnderline ( ) ) { case Font :: UNDERLINE_DOUBLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'double' ) ; break ; case Font :: UNDERLINE_SINGLE : $ writer -> writeAttribute ( 'style:text-underline-type' , 'single' ) ; break ; } } $ writer -> endElement ( ) ; $ writer -> startElement ( 'style:table-cell-properties' ) ; $ writer -> writeAttribute ( 'style:rotation-align' , 'none' ) ; if ( $ fill = $ style -> getFill ( ) ) { switch ( $ fill -> getFillType ( ) ) { case Fill :: FILL_SOLID : $ writer -> writeAttribute ( 'fo:background-color' , sprintf ( '#%s' , strtolower ( $ fill -> getStartColor ( ) -> getRGB ( ) ) ) ) ; break ; case Fill :: FILL_GRADIENT_LINEAR : case Fill :: FILL_GRADIENT_PATH : break ; case Fill :: FILL_NONE : default : } } $ writer -> endElement ( ) ; $ writer -> endElement ( ) ; } }
5981	protected function buildBasepath ( $ url ) { if ( ! preg_match ( '#(\w+:)?//#' , $ url ) ) { $ url = '//' . $ url ; } $ urlParts = parse_url ( $ url ) ; if ( false === $ urlParts ) { throw new \ InvalidArgumentException ( 'Could not parse QBank URL.' ) ; } if ( empty ( $ urlParts [ 'scheme' ] ) ) { $ urlParts [ 'scheme' ] = 'http' ; } if ( ( empty ( $ urlParts [ 'path' ] ) || '/' == $ urlParts [ 'path' ] ) && 'qbank.se' == substr ( $ urlParts [ 'host' ] , - strlen ( 'qbank.se' ) ) ) { $ urlParts [ 'path' ] = '/api/' ; } if ( '/' != substr ( $ urlParts [ 'path' ] , - 1 ) ) { $ urlParts [ 'path' ] .= '/' ; } return $ urlParts [ 'scheme' ] . '://' . $ urlParts [ 'host' ] . ( ! empty ( $ urlParts [ 'port' ] ) ? ':' . $ urlParts [ 'port' ] : '' ) . $ urlParts [ 'path' ] ; }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
6997	public function getViewersForRelations ( ) { $ ret = [ ] ; foreach ( $ this -> getValueViewers ( ) as $ key => $ viewer ) { if ( $ viewer -> isLinkedToDbColumn ( ) && $ viewer -> hasRelation ( ) ) { $ ret [ $ key ] = $ viewer ; } } return $ ret ; }
4857	public function getParams ( $ namespace , $ defaults , $ params = null ) { $ session = new Container ( $ namespace ) ; $ sessionParams = $ session -> params ? : array ( ) ; $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; if ( $ params -> get ( 'clear' ) ) { $ sessionParams = array ( ) ; unset ( $ params [ 'clear' ] ) ; } $ changed = false ; foreach ( $ defaults as $ key => $ default ) { if ( is_numeric ( $ key ) ) { $ key = $ default ; $ default = null ; } $ value = $ params -> get ( $ key ) ; if ( null === $ value ) { if ( isset ( $ sessionParams [ $ key ] ) ) { $ params -> set ( $ key , $ sessionParams [ $ key ] ) ; } elseif ( null !== $ default ) { $ params -> set ( $ key , $ default ) ; $ sessionParams [ $ key ] = $ default ; $ changed = true ; } } else { if ( ! isset ( $ sessionParams [ $ key ] ) || $ sessionParams [ $ key ] != $ value ) { $ changed = true ; $ sessionParams [ $ key ] = $ value ; } } } if ( $ changed ) { unset ( $ session -> list ) ; $ session -> params = $ sessionParams ; } return $ params ; }
6370	public static function forMap ( array $ map ) : callable { return function ( $ index ) use ( $ map ) { Preconditions :: checkArgument ( array_key_exists ( $ index , $ map ) , "The given key '%s' does not exist in the map" , $ index ) ; return $ map [ $ index ] ; } ; }
12487	public static function enableLogging ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ enabled = true ; self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible d\'activer les logs dans le fichier ' . $ writePath . ' : celui ci n\'existe pas.' ) ; return false ; }
12210	private function saveTransLogs ( $ orders , $ transIds ) { $ bySaleId = [ ] ; foreach ( $ orders as $ custId => $ order ) { $ saleId = $ order [ QGetOrders :: A_SALE_ID ] ; $ bySaleId [ $ saleId ] = $ order ; } foreach ( $ transIds as $ tranId => $ one ) { $ pref = substr ( $ one , 0 , 2 ) ; $ orderId = str_replace ( $ pref , '' , $ one ) ; if ( $ pref == self :: PREFIX_PV ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_CUST_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; $ this -> daoLogSale -> create ( [ LogSales :: A_TRANS_ID => $ tranId , LogSales :: A_SALE_ORDER_ID => $ orderId ] ) ; } elseif ( $ pref == self :: PREFIX_BONUS_FATHER ) { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } else { $ custId = $ bySaleId [ $ orderId ] [ QGetOrders :: A_PARENT_GRAND_ID ] ; $ this -> daoLogCust -> create ( [ LogCust :: A_TRANS_ID => $ tranId , LogCust :: A_CUSTOMER_ID => $ custId ] ) ; } } }
4617	public function buildLocalhost ( array $ ports = [ 8087 ] ) { $ nodes = [ ] ; $ this -> atHost ( 'localhost' ) ; foreach ( $ ports as $ port ) { $ nodes [ ] = $ this -> onPort ( $ port ) -> build ( ) ; } return $ nodes ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
11680	public function setPath ( $ path ) { if ( $ path === null ) { throw new PathCanNotBeNull ( ) ; } $ this -> path = rtrim ( $ path , '\\/' ) . '/' ; return $ this ; }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
7443	public function newAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
9311	protected function query ( $ uri , $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> get ( $ this -> uri , [ 'query' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
5881	public function processUpload_postProcessAction ( & $ filename , DataHandler $ pObj ) { $ filename = static :: $ imageResizer -> processFile ( $ filename , '' , '' , null , $ GLOBALS [ 'BE_USER' ] , [ $ this , 'notify' ] ) ; }
3291	public function signal ( int $ signo ) { if ( ! $ this -> isRunning ( ) ) { throw new StatusError ( "Process is not running." ) ; } $ this -> processRunner -> signal ( $ this -> handle , $ signo ) ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
12955	public function getObject ( $ checkAccess = true ) { $ registryClass = Yii :: $ app -> classes [ 'Registry' ] ; $ return = $ registryClass :: getObject ( $ this -> registry_id , $ checkAccess ) ; if ( get_class ( $ return ) === 'cascade\models\Registry' ) { \ d ( $ this -> registry_id ) ; exit ; } return $ return ; }
1019	public static function createLocatedError ( $ error , $ nodes = null , $ path = null ) { if ( $ error instanceof self ) { if ( $ error -> path && $ error -> nodes ) { return $ error ; } $ nodes = $ nodes ? : $ error -> nodes ; $ path = $ path ? : $ error -> path ; } $ source = $ positions = $ originalError = null ; $ extensions = [ ] ; if ( $ error instanceof self ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; $ nodes = $ error -> nodes ? : $ nodes ; $ source = $ error -> source ; $ positions = $ error -> positions ; $ extensions = $ error -> extensions ; } elseif ( $ error instanceof Exception || $ error instanceof Throwable ) { $ message = $ error -> getMessage ( ) ; $ originalError = $ error ; } else { $ message = ( string ) $ error ; } return new static ( $ message ? : 'An unknown error occurred.' , $ nodes , $ source , $ positions , $ path , $ originalError , $ extensions ) ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
9305	public function setEmitEvents ( $ emitEvents ) { if ( ! is_bool ( $ emitEvents ) ) { throw new \ InvalidArgumentException ( '`emitEvents` expects boolean value!' ) ; } $ this -> options [ 'emitEvents' ] = ( bool ) $ emitEvents ; return $ this ; }
7442	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ group = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\Group' ) -> find ( $ id ) ; if ( ! $ group ) { throw $ this -> createNotFoundException ( 'Unable to locate Group' ) ; } return array ( 'group' => $ group , ) ; }
9598	protected function flashInput ( Request $ request = null ) { if ( $ request === null ) { $ request = $ this -> container -> resolve ( 'Symfony\Component\HttpFoundation\RequestStack' ) -> getCurrentRequest ( ) ; } $ this -> flash ( '_old_input' , $ request -> request -> all ( ) ) ; }
10360	public static function fatal ( ) { $ e = error_get_last ( ) ; if ( $ e !== null && ( error_reporting ( ) & $ e [ 'type' ] ) !== 0 ) { ErrorHandler :: exception ( new \ ErrorException ( $ e [ 'message' ] , $ e [ 'type' ] , 0 , $ e [ 'file' ] , $ e [ 'line' ] ) ) ; exit ( 1 ) ; } }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
3883	public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; }
6153	public function setPropertyType ( $ propertyType ) { if ( $ propertyType instanceof PropertyType ) { $ this -> propertyType = $ propertyType ; } elseif ( is_array ( $ propertyType ) ) { $ this -> propertyType = new PropertyType ( $ propertyType ) ; } else { $ this -> propertyType = null ; trigger_error ( 'Argument must be an object of class PropertyType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
4988	public function setForms ( array $ forms , $ enabled = true ) { foreach ( $ forms as $ key => $ spec ) { if ( is_array ( $ spec ) && isset ( $ spec [ 'enabled' ] ) ) { $ currentEnabled = $ spec [ 'enabled' ] ; unset ( $ spec [ 'enabled' ] ) ; } else { $ currentEnabled = $ enabled ; } $ this -> setForm ( $ key , $ spec , $ currentEnabled ) ; } return $ this ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
9979	public function writeComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ authors = [ ] ; $ authorId = 0 ; foreach ( $ comments as $ comment ) { if ( ! isset ( $ authors [ $ comment -> getAuthor ( ) ] ) ) { $ authors [ $ comment -> getAuthor ( ) ] = $ authorId ++ ; } } $ objWriter -> startElement ( 'comments' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> startElement ( 'authors' ) ; foreach ( $ authors as $ author => $ index ) { $ objWriter -> writeElement ( 'author' , $ author ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'commentList' ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeComment ( $ objWriter , $ key , $ value , $ authors ) ; } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
12595	protected function getMinifier ( SplFileInfo $ file , string $ source ) : Minifier { $ minifier = '\Gears\Asset\Minifiers\\' ; $ minifier .= ucfirst ( $ this -> destination -> getExtension ( ) ) ; if ( ! class_exists ( $ minifier ) ) { throw new RuntimeException ( 'Minification is not supported for type: ' . $ this -> destination -> getExtension ( ) ) ; } return new $ minifier ( $ file , $ source ) ; }
9097	public function onLoadModulesPostAddServices ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ sm -> setInvokableClass ( 'yimaTheme.ThemeObject' , 'yimaTheme\Theme\Theme' , false ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
5140	public function map ( array $ methods , string $ path , $ handler ) : void { if ( is_string ( $ handler ) ) { $ handler = $ this -> getContainer ( ) -> get ( $ handler ) ; } $ this -> router -> map ( $ methods , $ path , $ handler ) ; }
10855	public function getLocationString ( ) { $ normalized = '' ; if ( $ this -> city !== null ) { $ normalized .= $ this -> city -> name ; } if ( $ this -> region !== null ) { $ normalized .= ' ' . $ this -> region -> name ; } if ( $ this -> postal_code !== null ) { $ normalized .= ' ' . $ this -> postal_code ; } return $ normalized ; }
12860	public function getDispatcher ( ) : Dispatcher { if ( $ this -> forceReload || ! file_exists ( $ this -> cacheFile ) ) { $ dispatchData = $ this -> buildCache ( ) ; } else { $ dispatchData = require $ this -> cacheFile ; } return call_user_func ( $ this -> dispatcherFactory , $ dispatchData ) ; }
10246	public static function ascToUcs ( $ ascii ) { $ rawname = '' ; $ iMax = strlen ( $ ascii ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ rawname .= $ ascii [ $ i ] . "\x00" ; } return $ rawname ; }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
9177	public function mapBoolean ( $ value ) { if ( isset ( $ this -> booleanMapping [ $ value ] ) ) { return $ this -> booleanMapping [ $ value ] ; } throw new \ Exception ( sprintf ( 'Can\'t convert %s to boolean' , $ value ) ) ; }
4110	protected function arrayToTabList ( array $ array , array $ skipKeys = array ( ) , $ indentationLevel = 1 ) { $ output = '' ; foreach ( $ array as $ key => $ value ) { if ( in_array ( $ key , $ skipKeys , true ) ) { continue ; } $ output .= $ this -> tabsForIndentation ( $ indentationLevel ) ; if ( ! is_array ( $ value ) ) { if ( ! is_int ( $ key ) ) { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> tabsForIndentation ( $ indentationLevel + 1 ) ; } $ output .= $ value . "\n" ; } else { $ output .= ucfirst ( $ key ) . ":\n" ; $ output .= $ this -> arrayToTabList ( $ value , $ skipKeys , $ indentationLevel + 1 ) ; } } return $ output ; }
12493	public static function groupBy ( $ field ) { if ( ! ( gettype ( $ field ) == "string" || $ field instanceof Key || $ field instanceof Raw ) ) { throw new ClusterpointException ( "\"->group()\" function: passed field selector is not in valid format." , 9002 ) ; } if ( $ field instanceof Key ) { $ field = self :: field ( "{$field}" ) ; } return "{$field}" ; }
12345	public function editAction ( Request $ request , Post $ post ) { if ( is_object ( $ post -> getPublished ( ) ) && $ post -> getPublished ( ) -> format ( 'dmY' ) == '3011-0001' ) { $ post -> setPublished ( null ) ; } $ deleteForm = $ this -> createDeleteForm ( $ post ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.edited' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'entity' => $ post , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
4266	public static function register ( $ pathsExclude = array ( ) ) { $ result = \ stream_wrapper_unregister ( static :: PROTOCOL ) ; if ( $ result === false ) { throw new \ UnexpectedValueException ( 'Failed to unregister' ) ; } if ( $ pathsExclude ) { self :: $ pathsExclude = $ pathsExclude ; } \ stream_wrapper_register ( static :: PROTOCOL , \ get_called_class ( ) ) ; \ ini_set ( 'opcache.enable' , 0 ) ; }
4533	public function getList ( $ task , Parameters $ parameters = null ) { $ resource = str_replace ( '{id}' , $ task , static :: VARIABLE_LIST ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' ] , 'query' => ( array ) $ parameters -> toObject ( true ) ] ; $ objects = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ name => $ object ) { $ object -> name = $ name ; $ model = static :: toModel ( $ object ) ; $ list [ $ name ] = $ model ; } return $ list ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
1489	public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; }
2688	private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
12053	public function set ( $ name , AbstractModule $ module ) { $ this -> container [ ( string ) $ name ] = $ module ; return $ this ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
10900	public function validate ( string $ method = 'save' ) : array { $ errors = [ ] ; foreach ( $ this -> getValidators ( ) [ $ method ] ?? [ ] as $ field => $ validator ) { try { $ validator -> setName ( $ field ) -> assert ( $ this -> get ( $ field ) ) ; } catch ( NestedValidationException $ e ) { $ errors [ $ field ] = $ e -> getMessages ( ) ; } } return $ errors ; }
11325	public static function hasSuffix ( $ string , $ suffix ) { $ len = strlen ( $ suffix ) ; if ( $ len && substr ( $ string , - $ len ) === $ suffix ) { return true ; } return false ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
950	public function createHmac ( array $ opts ) { $ data = $ opts [ 'data' ] ; $ raw = $ opts [ 'raw' ] ?? false ; $ buildQuery = $ opts [ 'buildQuery' ] ?? false ; $ buildQueryWithJoin = $ opts [ 'buildQueryWithJoin' ] ?? false ; $ encode = $ opts [ 'encode' ] ?? false ; $ secret = $ opts [ 'secret' ] ?? Config :: get ( 'shopify-app.api_secret' ) ; if ( $ buildQuery ) { ksort ( $ data ) ; $ queryCompiled = [ ] ; foreach ( $ data as $ key => $ value ) { $ queryCompiled [ ] = "{$key}=" . ( is_array ( $ value ) ? implode ( $ value , ',' ) : $ value ) ; } $ data = implode ( $ queryCompiled , ( $ buildQueryWithJoin ? '&' : '' ) ) ; } $ hmac = hash_hmac ( 'sha256' , $ data , $ secret , $ raw ) ; return $ encode ? base64_encode ( $ hmac ) : $ hmac ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
4931	public function updateValues ( ) { $ values = [ ] ; foreach ( $ this -> getItems ( ) as $ item ) { if ( ! is_null ( $ item ) ) { $ values [ ] = $ item -> getValueWithParents ( ) ; } } $ this -> values = $ values ; }
3471	public function merge ( Config $ config ) : Config { $ this -> config = array_merge_recursive ( $ this -> config , $ config -> config ) ; return $ this ; }
6209	public function notifyOnError ( $ message , array $ backtrace = null , $ extraParams = null ) { if ( ! $ backtrace ) { $ backtrace = debug_backtrace ( ) ; if ( count ( $ backtrace ) > 1 ) { array_shift ( $ backtrace ) ; } } $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => 'PHP::Error' , 'backtrace' => $ backtrace , 'errorMessage' => $ message , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
2173	private function warmUpSymfonyCache ( ) : void { $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ cacheDir . '/contao/config/config.php' ) ) { return ; } $ warmer = $ this -> container -> get ( 'cache_warmer' ) ; if ( ! $ this -> getContainerParameter ( 'kernel.debug' ) ) { $ warmer -> enableOptionalWarmers ( ) ; } $ warmer -> warmUp ( $ cacheDir ) ; if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
6737	public function uninstallation ( ) { $ this -> model -> delete_post_meta ( ) ; $ this -> model -> delete_options ( ) ; $ this -> model -> remove_tables ( ) ; }
10141	private function loadOLE ( $ pFilename ) { $ ole = new OLERead ( ) ; $ ole -> read ( $ pFilename ) ; $ this -> data = $ ole -> getStream ( $ ole -> wrkbook ) ; $ this -> summaryInformation = $ ole -> getStream ( $ ole -> summaryInformation ) ; $ this -> documentSummaryInformation = $ ole -> getStream ( $ ole -> documentSummaryInformation ) ; }
9490	protected function getFileDataValue ( $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } $ sUploadFolder = Config :: get ( 'cms.storage.uploads.path' , '/storage/app/uploads' ) ; return [ 'full_path' => $ obFile -> getPath ( ) , 'path' => $ sUploadFolder . str_replace ( 'uploads' , '' , $ obFile -> getDiskPath ( ) ) , 'title' => $ obFile -> getAttribute ( 'title' ) , 'alt' => $ obFile -> getAttribute ( 'description' ) , ] ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
3102	public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; }
2501	private function getFacetParams ( array $ facetBuilders ) { $ facetSets = array_map ( function ( $ facetBuilder ) { return $ this -> facetBuilderVisitor -> visitBuilder ( $ facetBuilder , spl_object_hash ( $ facetBuilder ) ) ; } , $ facetBuilders ) ; $ facetParams = array ( ) ; foreach ( $ facetSets as $ facetSet ) { foreach ( $ facetSet as $ key => $ value ) { if ( isset ( $ facetParams [ $ key ] ) ) { if ( ! is_array ( $ facetParams [ $ key ] ) ) { $ facetParams [ $ key ] = array ( $ facetParams [ $ key ] ) ; } $ facetParams [ $ key ] [ ] = $ value ; } else { $ facetParams [ $ key ] = $ value ; } } } return $ facetParams ; }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
4775	private function loadUserConfig ( ) { if ( ! $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> entityManager -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> tokenStorage -> getToken ( ) -> getUser ( ) , ] ) ; if ( null !== $ this -> widgetConfig ) { $ this -> widgetConfig = $ this -> widgetConfig -> getConfig ( ) ; } } }
2960	public function sendMessage ( $ str , $ waitForReply = 0.1 ) { $ this -> _buffer .= $ str ; if ( $ this -> autoFlush === true ) { $ this -> serialflush ( ) ; } usleep ( ( int ) ( $ waitForReply * 1000000 ) ) ; }
9492	private function getApplicationSize ( ) { $ size = cache ( ) -> remember ( 'foundation.app.size' , 5 , function ( ) { return $ this -> getFolderSize ( base_path ( ) ) ; } ) ; return $ this -> formatSize ( $ size ) ; }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
7139	protected function getGroupsForStep ( $ step ) { $ groups = [ 'Default' ] ; if ( $ step === static :: CHECKOUT_STEP ) { $ groups [ ] = 'Checkout' ; $ groups [ ] = 'Identity' ; $ groups [ ] = 'Availability' ; } elseif ( $ step === static :: SHIPMENT_STEP ) { $ groups [ ] = 'Availability' ; } return $ groups ; }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
9433	protected static function checkOrder ( $ float_min , $ float_max ) { if ( ! is_numeric ( $ float_min ) && ! is_numeric ( $ float_max ) ) { throw new \ InvalidArgumentException ( 'Min and max values must be valid numbers.' ) ; } if ( $ float_min >= $ float_max ) { throw new \ InvalidArgumentException ( 'Max value must be greater than min value!' ) ; } }
9481	public function respondWithResult ( $ data = NULL ) { $ res [ 'status' ] = $ this -> getStatusText ( ) ; if ( $ this -> getErrorCode ( ) && $ this -> getStatusCode ( ) == 420 ) { $ res [ 'error' ] = $ this -> getErrorCode ( ) ; $ res [ 'message' ] = $ data ; } else { $ res [ 'result' ] = $ data ; } return $ this -> respond ( $ res ) ; }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
2603	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ dictionaryName = Config :: CONFIG_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ currActiveVersion , $ dictionaryName ) ; if ( ! $ dictionary ) { return $ result -> setData ( [ 'status' => false ] ) ; } $ dictionaryItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; foreach ( $ dictionaryItems as $ item ) { if ( $ item -> item_key == Config :: CONFIG_DICTIONARY_KEY && $ item -> item_value == 1 ) { return $ result -> setData ( [ 'status' => true ] ) ; } } return $ result -> setData ( [ 'status' => false ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11921	public static function arrayRecursiveDiff ( $ aArray1 , $ aArray2 ) { $ aReturn = array ( ) ; foreach ( $ aArray1 as $ mKey => $ mValue ) { if ( array_key_exists ( $ mKey , $ aArray2 ) ) { if ( is_array ( $ mValue ) ) { $ aRecursiveDiff = self :: arrayRecursiveDiff ( $ mValue , $ aArray2 [ $ mKey ] ) ; if ( count ( $ aRecursiveDiff ) ) { $ aReturn [ $ mKey ] = $ aRecursiveDiff ; } } else { if ( $ mValue != $ aArray2 [ $ mKey ] ) { $ aReturn [ $ mKey ] = $ mValue ; } } } else { $ aReturn [ $ mKey ] = $ mValue ; } } return $ aReturn ; }
886	private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } }
1882	protected function getMD5Folders ( $ strPath ) { $ arrFiles = array ( ) ; foreach ( scan ( $ this -> strRootDir . '/' . $ strPath ) as $ strFile ) { if ( ! is_dir ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) ) { continue ; } $ arrFiles [ substr ( md5 ( $ this -> strRootDir . '/' . $ strPath . '/' . $ strFile ) , 0 , 8 ) ] = 1 ; foreach ( $ this -> getMD5Folders ( $ strPath . '/' . $ strFile ) as $ k => $ v ) { $ arrFiles [ $ k ] = $ v ; } } return $ arrFiles ; }
1596	protected function validateAttributes ( ) : bool { if ( ! $ this -> dataHas ( 'attributes' ) ) { return true ; } $ attrs = $ this -> dataGet ( 'attributes' ) ; if ( ! is_object ( $ attrs ) ) { $ this -> memberNotObject ( '/data' , 'attributes' ) ; return false ; } $ disallowed = collect ( [ 'type' , 'id' ] ) -> filter ( function ( $ field ) use ( $ attrs ) { return property_exists ( $ attrs , $ field ) ; } ) ; $ this -> memberFieldsNotAllowed ( '/data' , 'attributes' , $ disallowed ) ; return $ disallowed -> isEmpty ( ) ; }
2401	public function route ( $ strName , $ arrParams = array ( ) ) { $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; return ampersand ( $ strUrl ) ; }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
2032	public static function findFirstActiveByMemberGroups ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ time = Date :: floorToMinute ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> prepare ( "SELECT p.* FROM tl_member_group g LEFT JOIN tl_page p ON g.jumpTo=p.id WHERE g.id IN(" . implode ( ',' , $ arrIds ) . ") AND g.jumpTo>0 AND g.redirect='1' AND g.disable!='1' AND (g.start='' OR g.start<='$time') AND (g.stop='' OR g.stop>'" . ( $ time + 60 ) . "') AND p.published='1' AND (p.start='' OR p.start<='$time') AND (p.stop='' OR p.stop>'" . ( $ time + 60 ) . "') ORDER BY " . $ objDatabase -> findInSet ( 'g.id' , $ arrIds ) ) -> limit ( 1 ) -> execute ( ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objPage = $ objRegistry -> fetch ( 'tl_page' , $ objResult -> id ) ) { return $ objPage ; } return new static ( $ objResult ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
6068	public function listVersions ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/versions' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MediaVersion ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1725	private static function canGenerateSecret ( array $ config ) : bool { if ( isset ( $ config [ 'file' ] ) ) { return ! is_file ( $ config [ 'file' ] ) ; } foreach ( $ config as $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'file' ] ) && is_file ( $ v [ 'file' ] ) ) { return false ; } } return ! empty ( $ config ) ; }
9213	public function getOptionParser ( ) { $ parser = parent :: getOptionParser ( ) ; $ parser -> description ( 'Provides a mechanism for loading data into any of Cake\'s configured databases.' ) -> addSubcommand ( 'init' , [ 'help' => 'Initialize a new, empty seed file. Respects both the --dev and --file options.' , ] ) -> addOption ( 'dev' , [ 'short' => 'd' , 'boolean' => true , 'default' => false , 'help' => 'Use the "dev" seed file instead of the default.' ] ) -> addOption ( 'file' , [ 'short' => 'f' , 'help' => 'Manually specify the file that should be used. When this option is present, its argument will always be used explicitly, overriding the --dev option if it is also present.' ] ) ; return $ parser ; }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
1331	public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
3375	public function open ( $ file ) { if ( strlen ( $ file ) >= 1 && $ file [ 0 ] == '@' ) { try { if ( $ this -> fileLocator instanceof FileLocatorInterface ) { $ file = $ this -> fileLocator -> locate ( $ file ) ; } else { $ this -> fileLocator -> locateResource ( $ file ) ; } } catch ( \ InvalidArgumentException $ exception ) { if ( $ this -> throwException || false == $ this -> fallbackImage ) { throw $ exception ; } $ file = $ this -> fallbackImage ; } } return $ this -> createInstance ( $ file ) ; }
2209	public function fetchRow ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = array_values ( $ this -> resultSet [ ++ $ this -> intIndex ] ) ; return $ this -> arrCache ; }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
4200	private function addMethods ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( ! $ abs [ 'collectMethods' ] ) { $ this -> addMethodsMin ( $ abs ) ; return ; } if ( $ this -> abstracter -> getCfg ( 'cacheMethods' ) && isset ( static :: $ methodCache [ $ abs [ 'className' ] ] ) ) { $ abs [ 'methods' ] = static :: $ methodCache [ $ abs [ 'className' ] ] ; } else { $ methodArray = array ( ) ; $ methods = $ abs [ 'reflector' ] -> getMethods ( ) ; $ interfaceMethods = array ( 'ArrayAccess' => array ( 'offsetExists' , 'offsetGet' , 'offsetSet' , 'offsetUnset' ) , 'Countable' => array ( 'count' ) , 'Iterator' => array ( 'current' , 'key' , 'next' , 'rewind' , 'void' ) , 'IteratorAggregate' => array ( 'getIterator' ) , ) ; $ interfacesHide = \ array_intersect ( $ abs [ 'implements' ] , \ array_keys ( $ interfaceMethods ) ) ; foreach ( $ methods as $ reflectionMethod ) { $ info = $ this -> methodInfo ( $ obj , $ reflectionMethod ) ; $ methodName = $ reflectionMethod -> getName ( ) ; if ( $ info [ 'visibility' ] === 'private' && $ info [ 'inheritedFrom' ] ) { continue ; } foreach ( $ interfacesHide as $ interface ) { if ( \ in_array ( $ methodName , $ interfaceMethods [ $ interface ] ) ) { $ info [ 'implements' ] = $ interface ; break ; } } $ methodArray [ $ methodName ] = $ info ; } $ abs [ 'methods' ] = $ methodArray ; $ this -> addMethodsPhpDoc ( $ abs ) ; static :: $ methodCache [ $ abs [ 'className' ] ] = $ abs [ 'methods' ] ; } if ( isset ( $ abs [ 'methods' ] [ '__toString' ] ) ) { $ abs [ 'methods' ] [ '__toString' ] [ 'returnValue' ] = $ obj -> __toString ( ) ; } return ; }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
6943	protected function localizedDayOfWeek ( $ dayOfWeek ) { if ( class_exists ( '\IntlDateFormatter' ) ) { $ date = new \ DateTime ( '2017-01-01' ) ; $ date -> modify ( '+' . $ dayOfWeek . ' days' ) ; $ formatter = \ IntlDateFormatter :: create ( $ this -> localeProvider -> getCurrentLocale ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , $ date -> getTimezone ( ) , null , 'eeee' ) ; return $ formatter -> format ( $ date -> getTimestamp ( ) ) ; } return [ 1 => 'Monday' , 2 => 'Tuesday' , 3 => 'Wednesday' , 4 => 'Thursday' , 5 => 'Friday' , 6 => 'Saturday' , 7 => 'Sunday' , ] [ $ dayOfWeek ] ; }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
12188	public function getRelatedObject ( $ baseObject , $ baseRole , $ primaryRelation = null ) { $ companionRole = $ this -> companionRole ( $ baseRole ) ; $ companionType = $ this -> companionRoleType ( $ baseRole ) ; $ companionModel = $ companionType -> primaryModel ; if ( ! isset ( $ primaryRelation ) || is_array ( $ primaryRelation ) ) { if ( ! is_array ( $ primaryRelation ) ) { $ primaryRelation = [ ] ; } $ primaryRelation = $ this -> getPrimaryRelation ( $ baseObject , $ baseRole , $ primaryRelation ) ; } if ( ! empty ( $ primaryRelation ) ) { if ( $ companionRole === 'child' ) { return $ primaryRelation -> childObject ; } else { return $ primaryRelation -> parentObject ; } } return false ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
5892	public static function logEntry ( $ entry ) { $ parts = explode ( "|" , $ entry , 5 ) ; $ array = array ( ) ; if ( count ( $ parts ) != 5 ) { $ array [ "timestamp" ] = 0 ; $ array [ "level" ] = TeamSpeak3 :: LOGLEVEL_ERROR ; $ array [ "channel" ] = "ParamParser" ; $ array [ "server_id" ] = "" ; $ array [ "msg" ] = StringHelper :: factory ( "convert error (" . trim ( $ entry ) . ")" ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = true ; } else { $ array [ "timestamp" ] = strtotime ( trim ( $ parts [ 0 ] ) ) ; $ array [ "level" ] = self :: logLevel ( trim ( $ parts [ 1 ] ) ) ; $ array [ "channel" ] = trim ( $ parts [ 2 ] ) ; $ array [ "server_id" ] = trim ( $ parts [ 3 ] ) ; $ array [ "msg" ] = StringHelper :: factory ( trim ( $ parts [ 4 ] ) ) ; $ array [ "msg_plain" ] = $ entry ; $ array [ "malformed" ] = false ; } return $ array ; }
7358	private function loadPriceMap ( ) { if ( null === $ this -> pricesMap ) { $ this -> pricesMap = $ this -> getPricesMapLoader ( ) -> load ( $ this -> currency ) ; } }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
5139	public function add ( $ middleware , string $ pathConstraint = null ) : void { if ( is_string ( $ middleware ) ) { $ middleware = $ this -> getContainer ( ) -> get ( $ middleware ) ; } if ( ! $ middleware instanceof MiddlewareInterface ) { throw new InvalidArgumentException ( 'Middleware must be an instance of ' . MiddlewareInterface :: class ) ; } $ this -> middleware [ ] = new Middleware ( $ middleware , $ pathConstraint ) ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
3359	public function preview ( $ width , $ height ) { if ( ! $ width || ! $ height ) { throw new \ Exception ( 'Please, provide both width and height for preview' ) ; } $ result = clone $ this ; $ result -> operations [ ] [ 'preview' ] = array ( 'width' => $ width , 'height' => $ height , ) ; return $ result ; }
11364	public static function headerTagger ( $ name = '' , $ value = '' , $ adds = array ( ) ) { $ str = $ name . ': ' . $ value ; if ( count ( $ adds ) ) { foreach ( $ adds as $ n => $ v ) { $ str .= Mailer :: $ HEADERS_SEPARATOR . ( $ n == 'boundary' ? "\n\t" : '' ) . $ n . "=\"" . $ v . "\"" ; } } return ( trim ( $ str , Mailer :: $ HEADERS_SEPARATOR ) ) ; }
4926	public function getRegions ( $ type = null ) { if ( null === $ type ) { return array_keys ( $ this -> matrix ) ; } $ regions = [ ] ; foreach ( $ this -> matrix as $ region => $ types ) { if ( in_array ( $ type , $ types ) ) { $ regions [ ] = $ region ; } } return $ regions ; }
10333	function fromXML ( $ xmlElement ) { parent :: fromXML ( $ xmlElement ) ; if ( isset ( $ xmlElement -> permissionType ) ) $ this -> permission = Permission :: getPermission ( $ xmlElement -> permissionType ) ; if ( isset ( $ xmlElement -> field_backups ) ) $ this -> fieldBackups = XMLDeserializer :: deserialize ( $ xmlElement -> field_backups ) ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
8660	private function convertGetReportList ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportList' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetMaxCount ( ) ) { $ parameters [ 'MaxCount' ] = $ request -> getMaxCount ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetAvailableFromDate ( ) ) { $ parameters [ 'AvailableFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableFromDate ( ) ) ; } if ( $ request -> isSetAvailableToDate ( ) ) { $ parameters [ 'AvailableToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getAvailableToDate ( ) ) ; } if ( $ request -> isSetReportRequestIdList ( ) ) { $ reportRequestIdList = $ request -> getReportRequestIdList ( ) ; foreach ( $ reportRequestIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportRequestIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6143	public function checkQuery ( $ query = null ) { if ( $ query === null ) { $ query = $ this -> query ; } if ( strlen ( $ query ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ query ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI query string validation failed" ) ; } return ( $ status == 1 ) ; }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
8613	public function setAdjustmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8090	static public function generate ( $ uid = 0 , $ hash = false ) { if ( $ uid ) { $ e_uid = self :: encode ( $ uid ) ; $ e_uid_length = strlen ( $ e_uid ) ; $ e_uid_length = str_pad ( $ e_uid_length , 2 , 0 , STR_PAD_LEFT ) ; $ e_uid_pos = rand ( 10 , 32 - $ e_uid_length - 1 ) ; if ( ! $ hash ) { $ hash = sha1 ( uniqid ( rand ( ) , true ) ) ; } $ code = $ e_uid_pos . $ e_uid_length ; $ code .= substr ( $ hash , 0 , $ e_uid_pos - strlen ( $ code ) ) ; $ code .= $ e_uid ; $ code .= substr ( $ hash , strlen ( $ code ) ) ; return $ code ; } else { return sha1 ( uniqid ( rand ( ) , true ) ) ; } }
4998	public static function decide ( ScheduledContentInterface $ object , array $ attributes = [ ] ) { $ now = new \ DateTimeImmutable ( ) ; $ vote = VoterInterface :: ACCESS_ABSTAIN ; $ from = $ object -> isScheduledFrom ( ) ; $ till = $ object -> isScheduledTill ( ) ; if ( ! $ object -> isPublic ( ) || false === self :: notEmpty ( $ from , $ till ) ) { return $ vote ; } switch ( true ) { case is_null ( $ from ) : $ vote = $ till >= $ now ? VoterInterface :: ACCESS_GRANTED : VoterInterface :: ACCESS_DENIED ; break ; case is_null ( $ till ) : switch ( true ) { case ( $ from <= $ now ) : $ vote = VoterInterface :: ACCESS_GRANTED ; break ; case ( $ from > $ now && self :: hasCmsAttribute ( $ attributes ) ) : $ vote = VoterInterface :: ACCESS_GRANTED ; break ; default : $ vote = VoterInterface :: ACCESS_DENIED ; } break ; default : switch ( true ) { case ( $ from <= $ now && $ till >= $ now ) : $ vote = VoterInterface :: ACCESS_GRANTED ; break ; case ( ( $ from > $ now && $ till >= $ now ) && self :: hasCmsAttribute ( $ attributes ) ) : $ vote = VoterInterface :: ACCESS_GRANTED ; break ; default : $ vote = VoterInterface :: ACCESS_DENIED ; } } return $ vote ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
3032	public function getSessionState ( AssessmentTestSession $ session ) { $ deliveryExecution = $ this -> getDeliveryExecution ( $ session ) ; return $ deliveryExecution -> getState ( ) -> getUri ( ) ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
9970	public function setDataValidation ( $ pCellCoordinate , DataValidation $ pDataValidation = null ) { if ( $ pDataValidation === null ) { unset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ; } else { $ this -> dataValidationCollection [ $ pCellCoordinate ] = $ pDataValidation ; } return $ this ; }
341	public static function validate ( $ model , $ attributes = null ) { $ result = [ ] ; if ( $ attributes instanceof Model ) { $ models = func_get_args ( ) ; $ attributes = null ; } else { $ models = [ $ model ] ; } foreach ( $ models as $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , $ attribute ) ] = $ errors ; } } return $ result ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
5617	public function getTotalSize ( ) { if ( ! isset ( $ this -> _size ) ) { $ size = $ this -> getSize ( ) ; if ( ! $ this -> isLeaf ( ) ) { foreach ( $ this -> getChildren ( ) as $ child ) { $ size += $ child -> getTotalSize ( ) ; } } $ this -> _size = $ size ; } return $ this -> _size ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
5383	public function isValue ( $ compare ) { $ compare = trim ( $ compare ) ; if ( trim ( $ this -> getValue ( ) ) == $ compare ) { return true ; } return trim ( strip_tags ( $ this -> getContent ( ) ) ) == $ compare ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
5914	public function updateLastLogin ( $ id , $ successful = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'successful' => $ successful ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/registerloginattempt' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
2015	public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ classes [ $ class ] ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_set' ] [ $ class ] = $ class ; } include $ rootDir . '/' . self :: $ classes [ $ class ] ; } elseif ( ( $ namespaced = self :: findClass ( $ class ) ) !== null ) { if ( ! class_exists ( $ namespaced , false ) && ! interface_exists ( $ namespaced , false ) && ! trait_exists ( $ namespaced , false ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_aliased' ] [ $ class ] = $ namespaced ; } include $ rootDir . '/' . self :: $ classes [ $ namespaced ] ; } class_alias ( $ namespaced , $ class ) ; } elseif ( strncmp ( $ class , 'Contao\\' , 7 ) !== 0 ) { $ namespaced = 'Contao\\' . $ class ; if ( class_exists ( $ namespaced ) || interface_exists ( $ namespaced ) || trait_exists ( $ namespaced ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_composerized' ] [ $ class ] = $ namespaced ; } if ( ! class_exists ( $ class , false ) && ! interface_exists ( $ class , false ) && ! trait_exists ( $ class , false ) ) { class_alias ( $ namespaced , $ class ) ; } } } }
7165	private function buildDiscountLine ( Model \ SaleAdjustmentInterface $ adjustment , $ level = 0 ) { if ( Model \ AdjustmentTypes :: TYPE_DISCOUNT !== $ adjustment -> getType ( ) ) { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'adjustment_' . ( $ lineNumber - 1 ) , 'adjustment_' . $ adjustment -> getId ( ) , $ lineNumber , $ level ) ; if ( empty ( $ designation = $ adjustment -> getDesignation ( ) ) ) { $ designation = 'Discount ' ; if ( $ adjustment -> getMode ( ) === Model \ AdjustmentModes :: MODE_PERCENT ) { $ designation .= $ this -> formatter -> percent ( $ adjustment -> getAmount ( ) ) ; } } $ result = $ adjustment -> getResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildAdjustmentView ( $ adjustment , $ view , $ this -> options ) ; } return $ view ; }
1327	public function toUrl ( ) { $ postData = $ this -> toPostdata ( ) ; $ out = $ this -> getNormalizedHttpUrl ( ) ; if ( $ postData ) { $ out .= '?' . $ postData ; } return $ out ; }
10838	protected function setRaw ( $ Key , $ Val , $ expire = 0 ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; return file_put_contents ( $ CacheFile , serialize ( $ Val ) ) > 0 ; }
4830	public static function find ( $ id ) { $ client = GoCardless :: $ client ; return new self ( $ client , $ client -> request ( 'get' , self :: $ endpoint . '/' . $ id ) ) ; }
10407	private function save ( Pair $ pair ) { $ this -> manager -> persist ( $ pair ) ; $ this -> manager -> commit ( ) ; $ this -> manager -> refresh ( ) ; }
12181	public function getPrimaryObject ( $ primaryObject , $ relatedObject , $ role ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( $ role === 'child' ) { $ primaryField = 'primary_child' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ primaryParent = $ primaryObject ; } else { $ primaryField = 'primary_parent' ; if ( ! $ relatedObject -> objectType -> getPrimaryAsParent ( $ this -> child ) ) { return false ; } $ primaryParent = $ relatedObject ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ primaryObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ primaryParent -> primaryKey , '`' . $ alias . '`.`' . $ primaryField . '`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ primaryObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1732	public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } $ objParent = PageModel :: findPublishedById ( $ objArticle -> pid ) ; if ( $ objParent === null ) { return '' ; } $ this -> objArticle = $ objArticle ; $ this -> objParent = $ objParent ; return parent :: generate ( ) ; }
11642	public function getTotalItems ( ) { if ( is_null ( $ this -> _totalItems ) ) { $ this -> _totalItems = $ this -> dataProvider -> totalItemCount ; } return $ this -> _totalItems ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
6444	protected function getClient ( $ redirecturl = '' ) { if ( is_object ( $ this -> linkedin ) ) { return $ this -> linkedin ; } if ( $ redirecturl == '' ) { $ redirecturl = $ this -> redirecturl ; } else { $ this -> redirecturl = $ redirecturl ; } $ this -> logQ ( 'redirect ' . $ redirecturl , 'linkedin' ) ; $ API_CONFIG = array ( 'api_key' => $ this -> options [ 'api_key' ] , 'api_secret' => $ this -> options [ 'api_secret' ] , 'callback_url' => $ redirecturl ) ; $ this -> linkedin = $ linkedin = new \ LinkedIn \ LinkedIn ( $ API_CONFIG ) ; return $ this -> linkedin ; }
4397	protected function getRedirectForm ( \ Omnipay \ Common \ Message \ RedirectResponseInterface $ response ) { $ list = [ ] ; foreach ( ( array ) $ response -> getRedirectData ( ) as $ key => $ value ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( array ( 'label' => $ key , 'code' => $ key , 'type' => 'string' , 'internalcode' => $ key , 'internaltype' => 'string' , 'default' => $ value , 'public' => false , ) ) ; } $ url = $ response -> getRedirectUrl ( ) ; $ method = $ response -> getRedirectMethod ( ) ; return new \ Aimeos \ MShop \ Common \ Helper \ Form \ Standard ( $ url , $ method , $ list ) ; }
12110	public function deletePage ( $ id ) { $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
109	public function getVersion ( ) { if ( isset ( self :: $ version ) ) { return self :: $ version ; } if ( 0 !== $ this -> process -> execute ( 'git --version' , $ output ) ) { return ; } if ( preg_match ( '/^git version (\d+(?:\.\d+)+)/m' , $ output , $ matches ) ) { return self :: $ version = $ matches [ 1 ] ; } }
6659	protected function getEndpoints ( ) { if ( ! $ this -> endpointsCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ endpoints = [ ] ; $ parts = [ ] ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ methods as $ method ) { if ( preg_match ( '/([a-z]+)([A-Z]\w+)Endpoint$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ httpVerb = strtolower ( $ parts [ 1 ] ) ; $ endpoint = $ this -> camelcaseToHyphenated ( $ parts [ 2 ] ) ; if ( ! array_key_exists ( $ httpVerb , $ endpoints ) ) { $ endpoints [ $ httpVerb ] = array ( ) ; } $ endpoints [ $ httpVerb ] [ $ endpoint ] = $ this -> documentation -> getMethodDocumentation ( $ method ) ; } } } $ this -> endpointsCache = $ endpoints ; } return $ this -> endpointsCache ; }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
10257	public function getAddress ( $ state_code = null , $ zip = null ) { $ address = new Entities \ Address ; if ( ! empty ( $ zip ) && ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ zip ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ result = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ address -> line_1 = $ this -> getStreet ( ) ; if ( $ this -> getBool ( true , false ) ) { $ address -> line_2 = $ this -> getApartment ( ) ; } else { $ address -> line_2 = null ; } $ address -> city = $ result -> city ; $ address -> zip = $ result -> zip ; $ address -> county = $ result -> county ; $ address -> state = new Entities \ State ; $ address -> state -> code = $ result -> state_code ; $ address -> state -> name = $ result -> state ; return $ address ; }
3636	public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
11347	public function renderField ( $ name ) { $ html = '' ; $ field = $ this -> getField ( $ name ) ; $ html .= $ this -> formatter -> renderField ( $ field ) ; return $ html ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
8679	public function sort ( $ order = SORT_ASC , $ flags = SORT_REGULAR , $ preserveKeys = false ) { $ this -> validateSortArgs ( $ order , $ flags ) ; $ items = $ this -> items ; if ( ! $ preserveKeys ) { if ( $ order === SORT_ASC ) { sort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { rsort ( $ items , $ flags ) ; } } else { if ( $ order === SORT_ASC ) { asort ( $ items , $ flags ) ; } elseif ( $ order === SORT_DESC ) { arsort ( $ items , $ flags ) ; } } return $ this -> createFrom ( $ items ) ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
9101	private function listen ( ) { if ( ! @ socket_listen ( $ this -> handle , 5 ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
1040	public function processPsrRequest ( ServerRequestInterface $ request , ResponseInterface $ response , StreamInterface $ writableBodyStream ) { $ result = $ this -> executePsrRequest ( $ request ) ; return $ this -> helper -> toPsrResponse ( $ result , $ response , $ writableBodyStream ) ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
1035	private function completeLeafValue ( LeafType $ returnType , & $ result ) { try { return $ returnType -> serialize ( $ result ) ; } catch ( Exception $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } catch ( Throwable $ error ) { throw new InvariantViolation ( 'Expected a value of type "' . Utils :: printSafe ( $ returnType ) . '" but received: ' . Utils :: printSafe ( $ result ) , 0 , $ error ) ; } }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6100	protected function delete ( $ endpoint , array $ parameters = [ ] , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_DELETE , null , $ fireAndForget ) ; }
5962	public function serverGroupPermList ( $ sgid , $ permsid = false ) { return $ this -> execute ( "servergrouppermlist" , array ( "sgid" => $ sgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
11750	public function relation ( ) { if ( is_null ( $ this -> relation ) ) { $ this -> relation = new Relation ( $ this -> accessToken ) ; } return $ this -> relation ; }
8017	public function fileExists ( $ name ) { $ http = new \ Guzzle \ Http \ Client ( ) ; try { $ response = $ http -> get ( $ this -> getUrl ( $ name ) ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { return false ; } return $ response -> isSuccessful ( ) ; }
12586	protected function createCtrl ( ) : AbstractCtrl { $ view = ViewFactory :: createView ( str_replace ( 'action' , '' , $ this -> actionName ) , $ this -> ctrlName ) ; $ componentsRootMap = AppHelper :: getInstance ( ) -> getConfig ( 'componentsRootMap' ) ; if ( ! isset ( $ componentsRootMap [ 'controllers' ] ) ) { throw new Exception ( "The field 'componentsRootMap.controllers' must be " . 'presented in the main configuration file.' ) ; } $ ctrlNamespace = str_replace ( \ DIRECTORY_SEPARATOR , '\\' , $ componentsRootMap [ 'controllers' ] ) ; $ ctrlFullName = $ ctrlNamespace . '\\' . $ this -> ctrlName ; if ( ! is_null ( $ view ) ) { $ layoutName = AppHelper :: getInstance ( ) -> getConfig ( 'defaultLayout' ) ; if ( ! is_null ( $ layoutName ) ) { $ layout = ViewFactory :: createLayout ( $ layoutName , $ view ) ; $ ctrl = new $ ctrlFullName ( $ this -> request , $ layout ) ; } else { $ ctrl = new $ ctrlFullName ( $ this -> request , $ view ) ; } } else { $ ctrl = new $ ctrlFullName ( $ this -> request ) ; } return $ ctrl ; }
10635	public function update ( \ SplSubject $ eventManager ) { $ this -> isUpdate = true ; if ( $ eventManager -> event -> function !== NULL ) { $ this -> { $ eventManager -> event -> function } ( $ eventManager ) ; } }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
10146	private function readStyle ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ ixfe = self :: getUInt2d ( $ recordData , 0 ) ; $ xfIndex = ( 0x0FFF & $ ixfe ) >> 0 ; $ isBuiltIn = ( bool ) ( ( 0x8000 & $ ixfe ) >> 15 ) ; if ( $ isBuiltIn ) { $ builtInId = ord ( $ recordData [ 2 ] ) ; switch ( $ builtInId ) { case 0x00 : break ; default : break ; } } } }
8789	public function image ( $ url , $ alt = null , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'alt' ] = $ alt ; return $ this -> toHtmlString ( '<img src="' . $ this -> uri -> assets ( $ url , $ secure ) . '"' . $ this -> attributes ( $ attributes ) . '>' ) ; }
11035	function check_level ( $ error_level , $ errno , $ message ) { if ( error_reporting ( ) & $ error_level ) { switch ( $ error_level ) { case E_NOTICE : $ type = 'notice' ; break ; case E_WARNING : $ type = 'warning' ; break ; case E_ERROR : $ type = 'error' ; break ; } echo "<b>ETS $type:</b> $message" ; } if ( $ error_level == E_ERROR ) { exit ; } }
3606	public function get ( $ name ) { if ( ! isset ( $ this -> httpHandlers [ $ name ] ) ) { throw new \ Exception ( "HttpHandler {$name} not found" ) ; } return $ this -> httpHandlers [ $ name ] ; }
9656	public function merge ( array $ routes ) { foreach ( $ routes as $ name => $ route ) { $ this -> override ( $ name , $ route ) ; } }
1972	public static function findByPath ( $ path , array $ arrOptions = array ( ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ path , $ rootDir . '/' , \ strlen ( $ rootDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ rootDir ) + 1 ) ; } return static :: findOneBy ( 'path' , $ path , $ arrOptions ) ; }
6305	public function getDistance ( Point $ point , DistanceInterface $ calculator = null ) { $ calculator = $ calculator ? : static :: getCalculator ( ) ; return $ calculator -> getDistance ( new Coordinate ( $ this -> latitude , $ this -> longitude ) , new Coordinate ( $ point -> latitude , $ point -> longitude ) ) ; }
4552	public function exists ( UserParameters $ parameters = null ) { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
8295	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for writing: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_EX ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire an exclusive lock for " . $ this -> filePath ) ; } if ( $ this -> options [ "backup" ] ) { $ this -> createBkFile ( ) ; } $ this -> writeErrors = false ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
3801	public function getCache ( ) { @ trigger_error ( '"' . __METHOD__ . '" is deprecated as the service container will get removed.' , E_USER_DEPRECATED ) ; if ( \ is_callable ( $ this -> cache ) ) { $ this -> cache = \ call_user_func ( $ this -> cache ) ; } return $ this -> cache ; }
4179	public function hasManagerFile ( ) { if ( app ( 'filesystem' ) -> exists ( $ this -> directory . 'manager.yml' ) ) { return true ; } $ this -> console -> warn ( "No manager.yml file found in {$this->name} package." ) ; return false ; }
4884	public function addDependencies ( $ name , $ entities = null , array $ options = null ) { return $ this -> dependencyResultCollection -> add ( $ name , $ entities , $ options ) ; }
10799	public function renderPageHistoricAction ( ) { $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ view = new ViewModel ( ) ; $ view -> idPage = $ idPage ; $ view -> melisKey = $ melisKey ; return $ view ; }
10416	protected function addStatusField ( Table $ table ) { if ( empty ( $ this -> shops ) ) { $ table -> addColumn ( 'status' , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ 'status' ] ) ; } else { foreach ( $ this -> shops as $ shop ) { $ fieldName = "status_{$shop}" ; $ table -> addColumn ( $ fieldName , 'boolean' , [ 'default' => 0 ] ) -> setComment ( '0-new,1-done' ) ; $ table -> addIndex ( [ $ fieldName ] ) ; } } }
1034	private function completeListValue ( ListOfType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ itemType = $ returnType -> getWrappedType ( ) ; Utils :: invariant ( is_array ( $ result ) || $ result instanceof Traversable , 'User Error: expected iterable, but did not find one for field ' . $ info -> parentType . '.' . $ info -> fieldName . '.' ) ; $ containsPromise = false ; $ i = 0 ; $ completedItems = [ ] ; foreach ( $ result as $ item ) { $ fieldPath = $ path ; $ fieldPath [ ] = $ i ++ ; $ completedItem = $ this -> completeValueCatchingError ( $ itemType , $ fieldNodes , $ info , $ fieldPath , $ item ) ; if ( ! $ containsPromise && $ this -> getPromise ( $ completedItem ) ) { $ containsPromise = true ; } $ completedItems [ ] = $ completedItem ; } return $ containsPromise ? $ this -> exeContext -> promises -> all ( $ completedItems ) : $ completedItems ; }
1239	private static function getActualType ( $ value ) { $ actualType = gettype ( $ value ) ; if ( 'object' === $ actualType ) { $ actualType = get_class ( $ value ) ; } return $ actualType ; }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
4769	public function run ( ) { if ( ! $ this -> is_debug ( ) || ! $ this -> is_debug_display ( ) ) { return ; } $ run = $ this [ 'run' ] ; $ run -> register ( ) ; ob_start ( ) ; }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
5601	public function paintPass ( $ message ) { if ( ! $ this -> pass ) { $ this -> message = self :: escapeVal ( $ message ) ; } $ this -> pass = true ; }
6949	private function getByCountryAndCustomerQuery ( ) { if ( null === $ this -> byCountryAndCustomerQuery ) { $ qb = $ this -> getBaseQueryBuilder ( ) ; $ this -> byCountryAndCustomerQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'r.customer' , ':customer' ) ) -> getQuery ( ) -> setParameter ( 'customer' , true ) -> setMaxResults ( 1 ) ; } return $ this -> byCountryAndCustomerQuery ; }
7785	public function setStatementClass ( $ statementClass ) { if ( ! is_callable ( $ statementClass ) && ! class_exists ( $ statementClass ) ) { throw new \ InvalidArgumentException ( '$statementClass must be a valid classname or a PHP callable' ) ; } $ this -> statementClass = $ statementClass ; return $ this ; }
12772	public function register ( $ email , $ hashedPassword = null , & $ user = null , $ valid = false ) { $ result = new EmailStatus ( 0 ) ; if ( ! dbQuery ( $ this -> dbTable ) -> cond ( $ this -> dbEmailField , $ email ) -> first ( $ user ) ) { if ( ! isset ( $ user ) ) { $ user = new $ this -> dbTable ( false ) ; } $ user [ $ this -> dbEmailField ] = $ email ; $ user [ $ this -> dbHashEmailField ] = $ this -> hash ( $ email ) ; if ( isset ( $ hashedPassword ) ) { $ user [ $ this -> dbHashPasswordField ] = $ hashedPassword ; } else { $ user [ $ this -> dbHashPasswordField ] = $ this -> generatePassword ( ) ; } if ( ! $ valid ) { $ user [ $ this -> dbConfirmField ] = $ this -> hash ( $ email . time ( ) ) ; } else { $ user [ $ this -> dbConfirmField ] = 1 ; } $ activeField = $ this -> dbActiveField ; $ createdField = $ this -> dbCreatedField ; $ user -> $ activeField = 1 ; $ user -> $ createdField = date ( 'Y-m-d H:i:s' ) ; $ user -> save ( ) ; $ this -> authorize ( $ user ) ; $ result = new EmailStatus ( EmailStatus :: SUCCESS_EMAIL_REGISTERED ) ; } else { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_FOUND ) ; } if ( is_callable ( $ this -> registerHandler ) ) { if ( ! call_user_func_array ( $ this -> registerHandler , array ( & $ user , & $ result ) ) ) { $ result = new EmailStatus ( EmailStatus :: ERROR_EMAIL_REGISTER_HANDLER ) ; } } return $ result ; }
11962	private function parseConfig ( $ connection ) { $ this -> debug = false ; $ allowed_keys = array_keys ( get_object_vars ( $ this ) ) ; foreach ( $ connection as $ key => $ value ) { if ( $ key === 'host' && substr ( $ value , - 1 ) === '/' ) { $ value = substr ( $ value , 0 , - 1 ) ; } $ this -> setParam ( $ this -> camelCase ( $ key ) , $ value , $ allowed_keys ) ; } $ this -> transactionId = null ; $ this -> query = null ; }
7476	public function getEntitiesByIds ( $ identifier , array $ values ) { $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; return array_filter ( is_array ( $ this -> entities ) ? $ this -> entities : $ this -> entities -> toArray ( ) , function ( $ entity ) use ( $ identifier , $ values , $ accessor ) { return in_array ( $ accessor -> getValue ( $ entity , $ identifier ) , $ values ) ; } ) ; }
6828	private function getSaleDeliveryAddress ( ShipmentInterface $ shipment ) { if ( null === $ sale = $ shipment -> getSale ( ) ) { throw new LogicException ( "Shipment's sale must be set at this point." ) ; } return $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
5335	protected function sha512Asn1 ( $ data ) { $ digest = hash ( 'sha512' , $ data , true ) ; $ asn1 = chr ( 0x30 ) . chr ( 0x51 ) ; $ asn1 .= chr ( 0x30 ) . chr ( 0x0d ) ; $ asn1 .= chr ( 0x06 ) . chr ( 0x09 ) ; $ asn1 .= chr ( 0x60 ) . chr ( 0x86 ) . chr ( 0x48 ) . chr ( 0x01 ) . chr ( 0x65 ) ; $ asn1 .= chr ( 0x03 ) . chr ( 0x04 ) ; $ asn1 .= chr ( 0x02 ) . chr ( 0x03 ) ; $ asn1 .= chr ( 0x05 ) . chr ( 0x00 ) ; $ asn1 .= chr ( 0x04 ) . chr ( 0x40 ) ; $ asn1 .= $ digest ; return $ asn1 ; }
3469	public function options ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: options ( $ route ) ) ; }
3409	public function setLockPath ( string $ path ) : Application { if ( ! is_dir ( $ path ) ) { ( new Filesystem ( ) ) -> mkdir ( $ path ) ; } if ( ! $ realpath = realpath ( $ path ) ) { throw new \ InvalidArgumentException ( "The directory (" . $ path . ") is unavailable" ) ; } $ this -> lockPath = $ realpath ; return $ this ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
4464	public function childPerform ( BaseJob $ job ) : void { $ loggerContext = [ 'job' => $ job -> jid , 'type' => $ this -> who ] ; try { if ( $ this -> jobPerformHandler ) { if ( $ this -> jobPerformHandler instanceof EventsManagerAwareInterface ) { $ this -> jobPerformHandler -> setEventsManager ( $ this -> client -> getEventsManager ( ) ) ; } if ( method_exists ( $ this -> jobPerformHandler , 'setUp' ) ) { $ this -> jobPerformHandler -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this -> jobPerformHandler , $ job ) ) ; $ this -> jobPerformHandler -> perform ( $ job ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this -> jobPerformHandler , $ job ) ) ; if ( method_exists ( $ this -> jobPerformHandler , 'tearDown' ) ) { $ this -> jobPerformHandler -> tearDown ( ) ; } } else { $ job -> perform ( ) ; } $ this -> logger -> notice ( '{type}: job {job} has finished' , $ loggerContext ) ; } catch ( \ Throwable $ e ) { $ loggerContext [ 'stack' ] = $ e -> getMessage ( ) ; $ this -> logger -> critical ( '{type}: job {job} has failed {stack}' , $ loggerContext ) ; $ job -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; } }
200	private function checkTargetRelationExistence ( $ model , $ attribute ) { $ exists = false ; $ relationQuery = $ model -> { 'get' . ucfirst ( $ this -> targetRelation ) } ( ) ; if ( $ this -> filter instanceof \ Closure ) { call_user_func ( $ this -> filter , $ relationQuery ) ; } elseif ( $ this -> filter !== null ) { $ relationQuery -> andWhere ( $ this -> filter ) ; } if ( $ this -> forceMasterDb && method_exists ( $ model :: getDb ( ) , 'useMaster' ) ) { $ model :: getDb ( ) -> useMaster ( function ( ) use ( $ relationQuery , & $ exists ) { $ exists = $ relationQuery -> exists ( ) ; } ) ; } else { $ exists = $ relationQuery -> exists ( ) ; } if ( ! $ exists ) { $ this -> addError ( $ model , $ attribute , $ this -> message ) ; } }
10707	public function applyCriteria ( $ criteria ) { $ query = $ this -> getQuery ( ) ; if ( $ criteria instanceof Criteria ) { $ criteria -> apply ( $ query ) ; return $ this ; } if ( $ criteria instanceof Closure ) { $ criteria ( $ query ) ; return $ this ; } throw new RepositoryException ( "Must be an instance of " . Criteria :: class . " or \\Closure" ) ; }
6739	public function set_options ( ) { $ slug = Module :: CustomRatingGrifus ( ) -> getOption ( 'slug' ) ; $ options = $ this -> model -> get_options ( ) ; foreach ( $ options as $ option => $ value ) { Module :: CustomRatingGrifus ( ) -> setOption ( $ option , $ value ) ; } }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
10496	public function exp ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , $ value ) ) ; }
500	protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
126	protected function createRemoveRule ( PackageInterface $ package , $ reason , $ job ) { return new GenericRule ( array ( - $ package -> id ) , $ reason , $ job [ 'packageName' ] , $ job ) ; }
11716	public static function entry ( $ argv ) : void { self :: initialize ( ) ; if ( isset ( $ argv [ 1 ] ) ) { $ command = $ argv [ 1 ] ; } else { return ; } if ( ! in_array ( $ command , array_keys ( self :: $ commands ) ) ) { return ; } $ arguments = [ ] ; $ options = [ ] ; for ( $ index = 2 ; $ index < count ( $ argv ) ; $ index ++ ) { list ( $ key , $ value ) = Service :: parse ( $ argv [ $ index ] ) ; if ( Service :: determineTypeOfWord ( $ argv [ $ index ] ) == Service :: OPTION_TYPE ) { if ( ! $ value ) { $ options [ $ key ] = true ; } else { $ options [ $ key ] = $ value ; } } else { $ arguments [ ] = $ key ; } } Service :: runCommand ( self :: $ commands [ $ command ] , $ arguments , $ options ) ; }
7097	public function normalizeStock ( StockSubjectInterface $ subject , $ format = null , array $ context = [ ] ) { $ translator = $ this -> constantHelper -> getTranslator ( ) ; $ formatter = $ this -> getFormatter ( ) ; if ( null !== $ eda = $ subject -> getEstimatedDateOfArrival ( ) ) { $ eda = $ formatter -> date ( $ eda ) ; } else { $ eda = $ translator -> trans ( 'ekyna_core.value.undefined' ) ; } $ stockUnits = $ this -> findStockUnits ( $ subject ) ; return [ 'mode_label' => $ this -> constantHelper -> renderStockSubjectModeLabel ( $ subject ) , 'mode_badge' => $ this -> constantHelper -> renderStockSubjectModeBadge ( $ subject ) , 'state_label' => $ this -> constantHelper -> renderStockSubjectStateLabel ( $ subject ) , 'state_badge' => $ this -> constantHelper -> renderStockSubjectStateBadge ( $ subject ) , 'in' => $ formatter -> number ( $ subject -> getInStock ( ) ) , 'available' => $ formatter -> number ( $ subject -> getAvailableStock ( ) ) , 'virtual' => $ formatter -> number ( $ subject -> getVirtualStock ( ) ) , 'floor' => $ formatter -> number ( $ subject -> getStockFloor ( ) ) , 'geocode' => $ subject -> getGeocode ( ) , 'replenishment' => $ formatter -> number ( $ subject -> getReplenishmentTime ( ) ) , 'eda' => $ eda , 'moq' => $ formatter -> number ( $ subject -> getMinimumOrderQuantity ( ) ) , 'quote_only' => $ subject -> isQuoteOnly ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'end_of_life' => $ subject -> isEndOfLife ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'stock_units' => $ this -> normalizer -> normalize ( $ stockUnits , $ format , $ context ) , ] ; }
243	protected function renderAttribute ( $ attribute , $ index ) { if ( is_string ( $ this -> template ) ) { $ captionOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'captionOptions' , [ ] ) ) ; $ contentOptions = Html :: renderTagAttributes ( ArrayHelper :: getValue ( $ attribute , 'contentOptions' , [ ] ) ) ; return strtr ( $ this -> template , [ '{label}' => $ attribute [ 'label' ] , '{value}' => $ this -> formatter -> format ( $ attribute [ 'value' ] , $ attribute [ 'format' ] ) , '{captionOptions}' => $ captionOptions , '{contentOptions}' => $ contentOptions , ] ) ; } return call_user_func ( $ this -> template , $ attribute , $ index , $ this ) ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
888	private function isStrictOrNullableReturnTypeFunction ( Tokens $ tokens , $ returnIndex ) { $ functionIndex = $ returnIndex ; do { $ functionIndex = $ tokens -> getPrevTokenOfKind ( $ functionIndex , [ [ T_FUNCTION ] ] ) ; if ( null === $ functionIndex ) { return false ; } $ openingCurlyBraceIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ '{' ] ) ; $ closingCurlyBraceIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ openingCurlyBraceIndex ) ; } while ( $ closingCurlyBraceIndex < $ returnIndex ) ; $ possibleVoidIndex = $ tokens -> getPrevMeaningfulToken ( $ openingCurlyBraceIndex ) ; $ isStrictReturnType = $ tokens [ $ possibleVoidIndex ] -> isGivenKind ( T_STRING ) && 'void' !== $ tokens [ $ possibleVoidIndex ] -> getContent ( ) ; $ nullableTypeIndex = $ tokens -> getNextTokenOfKind ( $ functionIndex , [ [ CT :: T_NULLABLE_TYPE ] ] ) ; $ isNullableReturnType = null !== $ nullableTypeIndex && $ nullableTypeIndex < $ openingCurlyBraceIndex ; return $ isStrictReturnType || $ isNullableReturnType ; }
9772	function property ( string $ name , $ value = null ) : self { $ isArray = is_array ( $ this -> target ) || $ this -> target instanceof \ ArrayAccess ; if ( ! $ isArray && ! is_object ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The target is not an array nor an object.' ) ; $ hasProperty = $ isArray ? array_key_exists ( $ name , $ this -> target ) : property_exists ( $ this -> target , $ name ) ; $ hasPropertyConstraint = $ isArray ? arrayHasKey ( $ name ) : objectHasAttribute ( $ name ) ; $ property = $ isArray ? ( $ this -> target [ $ name ] ?? null ) : ( $ this -> target -> $ name ?? null ) ; if ( ! $ hasProperty || $ value === null ) $ this -> expect ( $ this -> target , $ hasPropertyConstraint ) ; else { assertThat ( $ this -> target , $ hasPropertyConstraint ) ; $ this -> expect ( $ property , equalTo ( $ value ) ) ; } $ this -> target = $ property ; return $ this ; }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
6916	public function removeAttachment ( AttachmentInterface $ attachment ) { if ( $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> removeElement ( $ attachment ) ; } return $ this ; }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
1447	protected function dataForDelete ( $ record ) : array { $ schema = $ this -> container -> getSchema ( $ record ) ; return ResourceObject :: create ( [ 'type' => $ schema -> getResourceType ( ) , 'id' => $ schema -> getId ( $ record ) , 'attributes' => $ schema -> getAttributes ( $ record ) , 'relationships' => collect ( $ this -> existingRelationships ( $ record ) ) -> all ( ) , ] ) -> all ( ) ; }
7325	protected function cachingIsPossible ( ) { if ( static :: $ _cachingIsPossible === null ) { $ storeClass = '\AlternativeLaravelCache\Core\AlternativeCacheStore' ; $ poolInterface = '\Cache\Taggable\TaggablePoolInterface' ; $ cache = app ( 'cache.store' ) -> getStore ( ) ; static :: $ _cachingIsPossible = ( $ cache instanceof $ storeClass && $ cache -> getWrappedConnection ( ) instanceof $ poolInterface ) ; } return static :: $ _cachingIsPossible ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
9528	private function parseSingle ( & $ i , $ parameter , & $ results ) { if ( $ this -> prefixExists ( $ parameter ) ) { $ closure = $ this -> getClosure ( $ parameter ) ; if ( $ closure != null ) { $ prefix = $ this -> getPrefix ( $ parameter ) ; $ closure_arguments = [ ] ; $ rFunction = new ReflectionFunction ( $ closure ) ; if ( $ rFunction -> isVariadic ( ) ) { $ this -> parseVariadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter ) ; } else { $ this -> parseUniadicParameter ( $ i , $ results , $ closure , $ closure_arguments , $ prefix , $ parameter , $ rFunction ) ; } $ result_key = $ this -> getRealName ( $ parameter ) ; $ result = $ results [ $ result_key ] ; if ( ! $ result instanceof ParameterResult ) { if ( $ result == self :: HALT_PARSE ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; unset ( $ results [ $ result_key ] ) ; return false ; } } else { if ( $ result -> shouldHalt ( ) ) { $ this -> haltedBy = $ this -> getParameterClosure ( $ parameter ) ; if ( $ result -> isHaltOnly ( ) ) { unset ( $ results [ $ result_key ] ) ; } else { $ results [ $ result_key ] = $ result -> getValue ( ) ; } return false ; } } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } } else { $ this -> respondDefault ( $ i , $ results , $ parameter ) ; } return true ; }
635	public function renameTable ( $ table , $ newName ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> renameTable ( $ table , $ newName ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3712	public function generateClearAll ( $ strContent , $ strTemplate ) { if ( substr ( $ strTemplate , 0 , 3 ) === 'fe_' ) { if ( preg_match_all ( '#\[\[\[metamodelfrontendfilterclearall::(ce|mod)::([^\]]*)\]\]\]#' , $ strContent , $ arrMatches , PREG_SET_ORDER ) ) { foreach ( $ arrMatches as $ arrMatch ) { switch ( $ arrMatch [ 1 ] ) { case 'ce' : $ strContent = $ this -> generateContentElement ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; case 'mod' : $ strContent = $ this -> generateModule ( $ strContent , $ arrMatch [ 0 ] , $ arrMatch [ 2 ] ) ; break ; default : throw new \ RuntimeException ( 'Unexpected element determinator encountered: ' . $ arrMatch [ 1 ] ) ; } } } } return $ strContent ; }
10280	public static function absoluteReference ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } if ( ctype_digit ( $ pCoordinateString ) ) { return $ worksheet . '$' . $ pCoordinateString ; } elseif ( ctype_alpha ( $ pCoordinateString ) ) { return $ worksheet . '$' . strtoupper ( $ pCoordinateString ) ; } return $ worksheet . self :: absoluteCoordinate ( $ pCoordinateString ) ; }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
4299	public function countReset ( $ label = 'default' , $ flags = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = 'default' ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( 'default' , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ this -> data [ 'counts' ] [ $ label ] ) ) { $ this -> data [ 'counts' ] [ $ label ] = 0 ; $ args = array ( ( string ) $ label , 0 , ) ; } else { $ args = array ( 'Counter \'' . $ label . '\' doesn\'t exist.' ) ; } if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'countReset' , $ args , $ meta ) ; } }
139	public function uninstall ( RepositoryInterface $ repo , UninstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> uninstall ( $ repo , $ package ) ; }
3436	protected function fetchAllPropsForSelect ( ) { $ props = [ ] ; $ rsProps = static :: $ cIblockObject -> GetProperties ( $ this -> iblockId ) ; while ( $ prop = $ rsProps -> Fetch ( ) ) { $ props [ ] = 'PROPERTY_' . $ prop [ 'CODE' ] ; } return $ props ; }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
9932	public function addRule ( Column \ Rule $ pRule ) { $ pRule -> setParent ( $ this ) ; $ this -> ruleset [ ] = $ pRule ; return $ this ; }
6548	public function current ( ) { $ sheet = $ this -> iterator -> current ( ) ; return new \ Aimeos \ MW \ Container \ Content \ PHPExcel ( $ sheet , $ sheet -> getTitle ( ) , $ this -> getOptions ( ) ) ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
8967	public static function clean ( $ currencyCode ) { $ clean = trim ( strtoupper ( $ currencyCode ) ) ; if ( ! self :: exists ( $ clean ) ) { throw new UnknownCurrencyCodeException ( sprintf ( 'Unknown currency code "%s".' , $ currencyCode ) ) ; } return $ clean ; }
424	protected function adjustLabelFor ( $ options ) { if ( ! isset ( $ options [ 'id' ] ) ) { return ; } $ this -> _inputId = $ options [ 'id' ] ; if ( ! isset ( $ this -> labelOptions [ 'for' ] ) ) { $ this -> labelOptions [ 'for' ] = $ options [ 'id' ] ; } }
3088	public function isAssessmentSectionAdaptive ( AssessmentSection $ section ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; return count ( $ assessmentItemRefs ) === 1 && $ this -> isAdaptivePlaceholder ( $ assessmentItemRefs [ 0 ] ) ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
2340	protected function getEditUrl ( ) { if ( $ this -> strEditUrl !== null ) { return sprintf ( $ this -> strEditUrl , $ this -> intPid ) ; } $ strUrl = Environment :: get ( 'request' ) ; if ( preg_match ( '/&(amp;)?state=/' , $ strUrl ) ) { $ strUrl = preg_replace ( array ( '/&(amp;)?id=[^&]+/' , '/(&(amp;)?)t(id=[^&]+)/' , '/(&(amp;)?)state=[^&]*/' ) , array ( '' , '$1$3' , '$1act=edit' ) , $ strUrl ) ; } if ( preg_match ( '/do=login(&|$)/' , $ strUrl ) ) { $ strUrl = preg_replace ( '/do=login(&|$)/' , 'do=user$1' , $ strUrl ) ; $ strUrl .= '&amp;act=edit&amp;id=' . $ this -> User -> id . '&amp;rt=' . REQUEST_TOKEN ; } $ strUrl = preg_replace ( '/act=(edit|override)All/' , 'act=edit&id=' . $ this -> intPid , $ strUrl ) ; return $ strUrl ; }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
5539	protected function getPublicNameFromIndex ( $ subject ) { foreach ( $ this -> names as $ name => $ index ) { if ( $ subject == $ index ) { return $ name ; } } return $ subject + 1 ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
12590	public function getDataTablesI18nAction ( ) { $ locale = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getLocale ( ) ; $ format = $ this -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> getRequestFormat ( ) ; return $ this -> render ( 'AdminBundle:Default/DataTables_i18n:' . $ locale . '.txt.' . $ format ) ; }
1318	public function put ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'PUT' , self :: API_HOST , $ path , $ parameters , false ) ; }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
1906	protected function replaceWildcards ( $ arrValues ) { $ arrValues = $ this -> escapeParams ( $ arrValues ) ; $ this -> strQuery = preg_replace ( '/(?<!%)%([^bcdufosxX%])/' , '%%$1' , $ this -> strQuery ) ; if ( ! $ this -> strQuery = @ vsprintf ( $ this -> strQuery , $ arrValues ) ) { throw new \ Exception ( 'Too few arguments to build the query string' ) ; } }
7406	public function replace ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
12813	private static function getNullables ( string $ table ) : array { if ( self :: $ nullablesCache !== null && array_key_exists ( $ table , self :: $ nullablesCache ) ) return self :: $ nullablesCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT column_name, data_type, is_nullable, column_default FROM information_schema.columns WHERE table_name = '$table' AND is_nullable = 'YES' " ; self :: $ nullablesCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ nullablesCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ nullablesCache [ $ table ] ; }
6607	public static function getAll ( $ offset = null , $ limit = null ) { $ query = self :: find ( ) ; self :: addPaginationParameters ( $ query , $ offset , $ limit ) ; return $ query -> all ( ) ; }
10563	private function _buildActionName ( $ controllerName , $ actionName ) { $ actionName = $ actionName . 'Action' ; if ( ! method_exists ( $ controllerName , $ actionName ) ) { $ actionName = $ this -> defaultAction . 'Action' ; } return $ actionName ; }
6505	public function deserializeParameters ( $ type , $ data ) { $ jobType = $ this -> registry -> get ( $ type ) ; $ indices = $ jobType -> getIndicesOfSerializableParameters ( ) ; $ serializedParameters = json_decode ( $ data , 1 ) ; if ( false === $ serializedParameters ) { throw new \ RuntimeException ( sprintf ( 'Deserialization failed with error "%s"' , json_last_error_msg ( ) ) ) ; } if ( count ( $ indices ) < count ( $ serializedParameters ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The serialized data contains more parameters than defined for job "%s"' , $ type ) ) ; } $ parameters = array ( ) ; foreach ( $ serializedParameters as $ index => $ data ) { if ( null === $ data ) { $ parameters [ ] = null ; } else { $ parameters [ ] = $ this -> serializer -> deserialize ( $ data , $ jobType -> getParameterType ( $ indices [ $ index ] ) , 'json' , $ this -> getParamDeserializationContext ( $ jobType , $ indices [ $ index ] ) ) ; } } return $ parameters ; }
3285	public function getSourceContext ( $ name ) : Source { if ( ! $ this -> exists ( $ name ) ) { throw new LoaderError ( sprintf ( 'Unable to find template "%s" from template map' , $ name ) ) ; } if ( ! file_exists ( $ this -> map [ $ name ] ) ) { throw new LoaderError ( sprintf ( 'Unable to open file "%s" from template map' , $ this -> map [ $ name ] ) ) ; } $ content = file_get_contents ( $ this -> map [ $ name ] ) ; $ source = new Source ( $ content , $ name , $ this -> map [ $ name ] ) ; return $ source ; }
5391	public function getValue ( ) { $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ widgets [ $ i ] -> getValue ( ) !== false ) { return $ widgets [ $ i ] -> getValue ( ) ; } } return false ; }
10850	protected function getMapping ( string $ clazz ) : array { if ( isset ( $ this -> cachedMapping [ $ clazz ] ) ) { return $ this -> cachedMapping [ $ clazz ] ; } $ ref = new \ ReflectionClass ( $ clazz ) ; $ mapping = array ( ) ; foreach ( $ this -> mapping as $ className => $ config ) { if ( $ clazz === $ className || $ ref -> isSubclassOf ( $ className ) ) { $ mapping = \ array_merge ( $ mapping , $ config ) ; } } $ this -> cachedMapping [ $ clazz ] = $ mapping ; return $ mapping ; }
9633	public function onBeforeWrite ( ) { $ return = parent :: onBeforeWrite ( ) ; $ exists = self :: get ( ) -> filter ( 'Name' , $ this -> Name ) -> exclude ( 'ID' , $ this -> ID ) ; if ( $ exists -> count ( ) ) { throw new ValidationException ( _t ( 'Moo_EditableField.UNIQUENAME' , 'Field name "{name}" must be unique' , '' , [ 'name' => $ this -> Name ] ) ) ; } $ this -> Name = preg_replace ( '/[^a-zA-Z0-9_]+/' , '' , $ this -> Name ) ; $ customSettings = $ this -> getSettings ( ) ; if ( empty ( $ customSettings ) ) { $ customSettings = ( array ) Controller :: curr ( ) -> getRequest ( ) -> postVar ( 'CustomSettings' ) ; } if ( ! empty ( $ this -> customSettingsFields ) ) { $ customSettings = array_intersect_key ( $ customSettings , array_flip ( ( array ) $ this -> customSettingsFields ) ) ; } $ this -> setSettings ( $ customSettings ) ; return $ return ; }
5531	protected function chainThrowMethods ( ) { $ code = " function throwOn(\$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwOn(\$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwAt(\$timing, \$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorOn(\$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; $ code .= " function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; return $ code ; }
947	protected function scripttagExists ( array $ shopScripttags , array $ scripttag ) { foreach ( $ shopScripttags as $ shopScripttag ) { if ( $ shopScripttag -> src === $ scripttag [ 'src' ] ) { return true ; } } return false ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
6851	public static function fuzzySpan ( $ timestamp , $ local_timestamp = null ) { $ local_timestamp = ( $ local_timestamp === null ) ? time ( ) : ( int ) $ local_timestamp ; $ offset = abs ( $ local_timestamp - $ timestamp ) ; if ( $ offset <= static :: MINUTE ) { $ span = 'moments' ; } elseif ( $ offset < ( static :: MINUTE * 20 ) ) { $ span = 'a few minutes' ; } elseif ( $ offset < static :: HOUR ) { $ span = 'less than an hour' ; } elseif ( $ offset < ( static :: HOUR * 4 ) ) { $ span = 'a couple of hours' ; } elseif ( $ offset < static :: DAY ) { $ span = 'less than a day' ; } elseif ( $ offset < ( static :: DAY * 2 ) ) { $ span = 'about a day' ; } elseif ( $ offset < ( static :: DAY * 4 ) ) { $ span = 'a couple of days' ; } elseif ( $ offset < static :: WEEK ) { $ span = 'less than a week' ; } elseif ( $ offset < ( static :: WEEK * 2 ) ) { $ span = 'about a week' ; } elseif ( $ offset < static :: MONTH ) { $ span = 'less than a month' ; } elseif ( $ offset < ( static :: MONTH * 2 ) ) { $ span = 'about a month' ; } elseif ( $ offset < ( static :: MONTH * 4 ) ) { $ span = 'a couple of months' ; } elseif ( $ offset < static :: YEAR ) { $ span = 'less than a year' ; } elseif ( $ offset < ( static :: YEAR * 2 ) ) { $ span = 'about a year' ; } elseif ( $ offset < ( static :: YEAR * 4 ) ) { $ span = 'a couple of years' ; } elseif ( $ offset < ( static :: YEAR * 8 ) ) { $ span = 'a few years' ; } elseif ( $ offset < ( static :: YEAR * 12 ) ) { $ span = 'about a decade' ; } elseif ( $ offset < ( static :: YEAR * 24 ) ) { $ span = 'a couple of decades' ; } elseif ( $ offset < ( static :: YEAR * 64 ) ) { $ span = 'several decades' ; } else { $ span = 'a long time' ; } if ( $ timestamp <= $ local_timestamp ) { return $ span . ' ago' ; } else { return 'in ' . $ span ; } }
8913	protected function _set_where ( $ params ) { if ( count ( $ params ) == 1 ) { $ this -> _database -> where ( $ params [ 0 ] ) ; } else if ( count ( $ params ) == 2 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] ) ; } else if ( count ( $ params ) == 3 ) { $ this -> _database -> where ( $ params [ 0 ] , $ params [ 1 ] , $ params [ 2 ] ) ; } else { $ this -> _database -> where ( $ params ) ; } }
6706	public function beforeUpdate ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( is_array ( $ event -> sender -> { $ field } ) ) { $ event -> sender -> { $ field } = implode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
7267	public function has ( $ forClass , $ forColumn = null ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id " , [ "id" => $ this -> $ refColumn ] , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return null ; $ forModel = new $ forClass ; foreach ( $ rows [ 0 ] as $ col => $ val ) $ forModel -> $ col = $ forModel -> decodeValue ( $ val , $ col ) ; return $ forModel ; }
11662	public static function saveToString ( $ properties ) { $ xn = new \ SimpleXMLElement ( self :: XML_ROOT_OPEN . self :: XML_ROOT_CLOSE , LIBXML_NOXMLDECL ) ; foreach ( $ properties as $ key => $ value ) { $ xn -> addChild ( "entry" , htmlspecialchars ( $ value , ENT_XML1 ) ) -> addAttribute ( "key" , htmlspecialchars ( $ key , ENT_XML1 ) ) ; } return preg_replace ( '/\<\?.*\?\>/' , self :: XML_PRELUDE , $ xn -> asXML ( ) ) ; }
3675	private function collectAttributeFactories ( $ container ) { $ attributeFactory = $ container -> getDefinition ( 'metamodels.attribute_factory' ) ; foreach ( array_keys ( $ container -> findTaggedServiceIds ( self :: TAG_ATTRIBUTE_FACTORY ) ) as $ factory ) { $ attributeFactory -> addMethodCall ( 'addTypeFactory' , [ new Reference ( $ factory ) ] ) ; } }
7284	public function status ( $ status = NULL ) { if ( $ status === NULL ) { return $ this -> status ; } elseif ( array_key_exists ( $ status , Response :: $ messages ) ) { $ this -> status = ( int ) $ status ; $ this -> status_message = Response :: $ messages [ $ this -> status ] ; return $ this ; } else { throw new Exception ( __METHOD__ . ' unknown status value : :value' , array ( ':value' => $ status ) ) ; } }
9477	protected function getTopDownloads ( $ limit = 20 ) { $ arrTopDownloads = array ( ) ; $ objTopDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT `tstamp`, `filename`, `downloads`, `id` FROM `tl_dlstats` ORDER BY `downloads` DESC" ) -> limit ( $ limit ) -> execute ( ) ; $ intRows = $ objTopDownloads -> numRows ; if ( $ intRows > 0 ) { while ( $ objTopDownloads -> next ( ) ) { $ c4d = $ this -> check4details ( $ objTopDownloads -> id ) ; $ arrTopDownloads [ ] = array ( $ objTopDownloads -> filename , $ this -> getFormattedNumber ( $ objTopDownloads -> downloads , 0 ) , $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'datimFormat' ] , $ objTopDownloads -> tstamp ) , $ objTopDownloads -> id , $ c4d , $ objTopDownloads -> downloads , $ objTopDownloads -> tstamp ) ; } } return $ arrTopDownloads ; }
11009	public function addPluginType ( string $ mediaType ) : bool { if ( ! preg_match ( '#^[-\w]+/[-\w]+$#ui' , $ mediaType ) ) { throw new MiddlewareException ( $ this , sprintf ( "'%s' is not a valid media type and can not be used as a CSP plugin type" , $ mediaType ) ) ; } if ( ! in_array ( $ mediaType , $ this -> tags [ 'plugin-types' ] ) ) { $ this -> tags [ 'plugin-types' ] [ ] = $ mediaType ; return true ; } return false ; }
7407	public function serialize ( ) : string { return serialize ( [ '_type' => $ this -> _type , '_arrayOptions' => $ this -> _arrayOptions , '_jsonOptions' => $ this -> _jsonOptions , '_container' => $ this -> _container , ] ) ; }
8375	public function where ( $ where ) { $ this -> where = ( $ where instanceof Condition ? $ where : new Condition ( $ where ) ) ; return $ this ; }
5946	public function property ( $ systemName , $ preloadNames = false , $ categoryIds = null , $ deploymentSiteIds = null , $ isHierarchical = false , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'preloadNames' => $ preloadNames , 'categoryIds' => $ categoryIds , 'deploymentSiteIds' => $ deploymentSiteIds , 'isHierarchical' => $ isHierarchical , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/property/' . $ systemName . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
8289	protected function authRoutes ( ) { switch ( $ this -> requestUrl ) { case 'login' : if ( $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToPage ( $ this -> config [ "afterLogin" ] ) ; } break ; case 'logout' : if ( ! $ this -> user -> getAuthenticated ( ) ) { $ this -> redirectToLogin ( ) ; } $ this -> checkLogoutSubmission ( ) ; break ; } }
10371	public static function add_scripts ( ) { self :: look_if_process_files ( 'script' ) ; foreach ( self :: $ data [ 'script' ] as $ data ) { $ params = [ 'plugin_url' => defined ( 'WP_PLUGIN_URL' ) ? WP_PLUGIN_URL . '/' : '' , 'nonce' => wp_create_nonce ( $ data [ 'name' ] ) , ] ; $ data [ 'params' ] = array_merge ( $ data [ 'params' ] , $ params ) ; wp_register_script ( $ data [ 'name' ] , $ data [ 'url' ] , $ data [ 'deps' ] , $ data [ 'version' ] , $ data [ 'footer' ] ) ; wp_enqueue_script ( $ data [ 'name' ] ) ; wp_localize_script ( $ data [ 'name' ] , $ data [ 'name' ] , $ data [ 'params' ] ) ; } }
9391	public function getSortValAfterAll ( $ groupingId = null ) { if ( ! $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( $ this -> srtColumn ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( $ this -> srtColumn . ' DESC' ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result ) { $ result = array_values ( $ result ) ; $ sortVal = $ result [ 0 ] + $ this -> sortGap ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
10858	public function eachMarked ( callable $ callback , $ result = null ) { $ ref = new \ ReflectionFunction ( $ callback ) ; $ params = $ ref -> getParameters ( ) ; if ( \ count ( $ params ) < 2 ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Callback for marker processing must declare at least 2 arguments (object and marker)' ) ) ; } try { $ markerType = $ params [ 1 ] -> getClass ( ) ; } catch ( \ ReflectionException $ e ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker class not found: %s' , $ params [ 1 ] -> getType ( ) ) , 0 , $ e ) ; } if ( $ markerType === null ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Argument #2 of marker callback needs to declare a type-hint for the marker' ) ) ; } $ marker = $ markerType -> getName ( ) ; if ( ! $ markerType -> isSubclassOf ( Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } foreach ( $ this -> marked [ $ marker ] as list ( $ definition , $ registration ) ) { $ result = $ callback ( $ this -> shared [ $ definition -> typeName ] ?? $ this -> get ( $ definition -> typeName ) , clone $ registration , $ result ) ; } return $ result ; }
5355	protected function getClassFromOperation ( $ name , Operation $ operation = null , $ reference , $ registry ) { if ( $ operation === null ) { return ; } if ( $ operation -> getParameters ( ) ) { foreach ( $ operation -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ this -> chainGuesser -> guessClass ( $ parameter -> getSchema ( ) , $ name . 'Body' , $ reference . '/parameters/' . $ key , $ registry ) ; } } } if ( $ operation -> getResponses ( ) ) { foreach ( $ operation -> getResponses ( ) as $ status => $ response ) { if ( $ response instanceof Response ) { $ this -> chainGuesser -> guessClass ( $ response -> getSchema ( ) , $ name . 'Response' . $ status , $ reference . '/responses/' . $ status , $ registry ) ; } } } }
11279	public static function applyDataToView ( $ view , $ data ) { if ( ! empty ( $ data ) ) { foreach ( $ data as $ name => $ value ) { if ( is_string ( $ value ) ) { $ view = str_replace ( '{' . $ name . '}' , $ value , $ view ) ; } } } return $ view ; }
9275	public function onBootstrap ( MvcEvent $ event ) { $ eventManager = $ event -> getApplication ( ) -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
7988	public function deleteSnapshot ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> delete ( 'vps/' . $ domain . '/snapshot' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
1821	protected function getQuicknavPages ( $ pid , $ level = 1 , $ host = null ) { global $ objPage ; $ groups = array ( ) ; $ arrPages = array ( ) ; if ( FE_USER_LOGGED_IN ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ groups = $ this -> User -> groups ; } $ objSubpages = PageModel :: findPublishedRegularWithoutGuestsByPid ( $ pid ) ; if ( $ objSubpages === null ) { return array ( ) ; } ++ $ level ; foreach ( $ objSubpages as $ objSubpage ) { $ _groups = StringUtil :: deserialize ( $ objSubpage -> groups ) ; if ( $ host !== null ) { $ objSubpage -> domain = $ host ; } if ( ! $ objSubpage -> protected || $ this -> showProtected || ( \ is_array ( $ _groups ) && \ is_array ( $ groups ) && array_intersect ( $ _groups , $ groups ) ) ) { if ( ! $ objSubpage -> hide || $ this -> showHidden ) { $ arrPages [ ] = array ( 'level' => ( $ level - 2 ) , 'title' => StringUtil :: specialchars ( StringUtil :: stripInsertTags ( $ objSubpage -> pageTitle ? : $ objSubpage -> title ) ) , 'href' => $ objSubpage -> getFrontendUrl ( ) , 'link' => StringUtil :: stripInsertTags ( $ objSubpage -> title ) , 'active' => ( $ objPage -> id == $ objSubpage -> id || ( $ objSubpage -> type == 'forward' && $ objPage -> id == $ objSubpage -> jumpTo ) ) ) ; if ( ! $ this -> showLevel || $ this -> showLevel >= $ level || ( ! $ this -> hardLimit && ( $ objPage -> id == $ objSubpage -> id || \ in_array ( $ objPage -> id , $ this -> Database -> getChildRecords ( $ objSubpage -> id , 'tl_page' ) ) ) ) ) { $ subpages = $ this -> getQuicknavPages ( $ objSubpage -> id , $ level ) ; if ( \ is_array ( $ subpages ) ) { $ arrPages = array_merge ( $ arrPages , $ subpages ) ; } } } } } return $ arrPages ; }
8384	public function select ( $ select ) { if ( is_array ( $ select ) === true ) { $ this -> select = '' ; foreach ( $ select as $ key => $ elem ) { $ this -> select .= $ elem ; if ( is_numeric ( $ key ) === false ) { $ this -> select .= ' AS ' . $ key ; } $ this -> select .= ', ' ; } $ this -> select = substr ( $ this -> select , 0 , - 2 ) ; } elseif ( ! is_string ( $ select ) ) { throw new InvalidArgumentException ( sprintf ( 'Argument 1 passed to %s must be an array or string!' , __METHOD__ ) ) ; } else { $ this -> select = $ select ; } return $ this ; }
4398	protected function getTransactionReference ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ base ) { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ base -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; return $ service -> getAttribute ( 'TRANSACTIONID' , 'payment/omnipay' ) ; }
8033	public function loadView ( $ viewName , $ data = array ( ) , $ mergeData = array ( ) ) { $ this -> htmlContent = View :: make ( $ viewName , $ data , $ mergeData ) ; return $ this ; }
5889	public function getViewer ( IViewer $ viewer ) { $ html = $ viewer -> fetchObject ( $ this ) ; $ iterator = new \ RecursiveIteratorIterator ( $ this , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ iterator as $ node ) { $ siblings = array ( ) ; for ( $ level = 0 ; $ level < $ iterator -> getDepth ( ) ; $ level ++ ) { $ siblings [ ] = ( $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; } $ siblings [ ] = ( ! $ iterator -> getSubIterator ( $ level ) -> hasNext ( ) ) ? 1 : 0 ; $ html .= $ viewer -> fetchObject ( $ node , $ siblings ) ; } return $ html ; }
7666	function EncodeQP ( $ str ) { $ encoded = $ this -> FixEOL ( $ str ) ; if ( substr ( $ encoded , - ( strlen ( $ this -> LE ) ) ) != $ this -> LE ) $ encoded .= $ this -> LE ; $ encoded = preg_replace ( '/([\000-\010\013\014\016-\037\075\177-\377])/e' , "'='.sprintf('%02X', ord('\\1'))" , $ encoded ) ; $ encoded = preg_replace ( "/([\011\040])" . $ this -> LE . "/e" , "'='.sprintf('%02X', ord('\\1')).'" . $ this -> LE . "'" , $ encoded ) ; $ encoded = $ this -> WrapText ( $ encoded , 74 , true ) ; return $ encoded ; }
5319	public function isSuccessExit ( ) { $ this -> exitCode = pcntl_wexitstatus ( $ this -> status ) ; return ( pcntl_wifexited ( $ this -> status ) && ( $ this -> exitCode === 0 ) ) ; }
1727	public function findBy ( $ strColumn , $ varValue ) { $ objResult = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE " . Database :: quoteIdentifier ( $ strColumn ) . "=?" ) -> limit ( 1 ) -> execute ( $ varValue ) ; if ( $ objResult -> numRows > 0 ) { $ this -> arrData = $ objResult -> row ( ) ; return true ; } return false ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
3038	public function get ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { $ data = $ this -> getStorage ( ) -> get ( $ userId , $ callId ) ; $ state = is_null ( $ data ) ? self :: STATE_NOT_FOUND : self :: STATE_ALIGNED ; $ this -> putInCache ( $ key , $ userId , $ callId , $ data , $ state ) ; } return $ this -> getFromCache ( $ key ) ; }
1744	public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
12287	public function insetIf ( bool $ condition , string $ block , array $ vars = null ) : string { return $ condition ? trim ( $ this -> make ( $ block , $ vars ) ) . PHP_EOL : PHP_EOL ; }
6724	protected function validateTokenParams ( ) { if ( empty ( $ this -> tokenUrl ) || filter_var ( $ this -> tokenUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_TOKEN_URL , $ this -> tokenUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
7461	public function sendPasswordResetEmail ( UserInterface $ user , $ subject = 'Password reset request' ) { $ hashedEntity = $ this -> createHash ( $ user ) ; $ this -> emailHelper -> createAndSendMessageFromTemplate ( 'OrkestraApplicationBundle:Email:setPassword.html.twig' , array ( 'user' => $ user , 'hash' => $ hashedEntity -> getHash ( ) ) , $ subject , $ user -> getEmail ( ) ) ; return $ hashedEntity ; }
8241	protected function getDirFiles ( $ searchDir ) { $ files = @ scandir ( $ searchDir , SCANDIR_SORT_NONE ) ; if ( $ files === false ) { throw new \ RuntimeException ( "Cannot list directory contents: {$searchDir}." ) ; } return array_diff ( $ files , array ( '..' , '.' ) ) ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
9648	protected function getConstantValues ( string $ classIdentifier , string $ regex ) : array { $ reflectionClass = new \ ReflectionClass ( $ classIdentifier ) ; $ constants = $ reflectionClass -> getConstants ( ) ; $ validValues = array_filter ( $ constants , function ( $ constantName ) use ( $ regex ) { return preg_match ( $ regex , $ constantName ) ; } , ARRAY_FILTER_USE_KEY ) ; return $ validValues ; }
4401	protected function translateStatus ( $ status ) { if ( ! interface_exists ( '\Omnipay\Common\Message\NotificationInterface' ) ) { return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } switch ( $ status ) { case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_COMPLETED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_RECEIVED ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_PENDING : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_PENDING ; case \ Omnipay \ Common \ Message \ NotificationInterface :: STATUS_FAILED : return \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUSED ; } }
4460	private function fork ( & $ socket ) : int { $ pair = [ ] ; $ domain = ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ? AF_INET : AF_UNIX ) ; if ( \ socket_create_pair ( $ domain , SOCK_STREAM , 0 , $ pair ) === false ) { $ error = socket_strerror ( socket_last_error ( $ pair [ 0 ] ?? null ) ) ; $ this -> logger -> error ( '{type}: unable to create socket pair; ' . $ error , $ this -> logContext ) ; exit ( 0 ) ; } $ pid = pcntl_fork ( ) ; if ( $ pid === - 1 ) { throw new RuntimeException ( 'Unable to fork child worker.' ) ; } if ( $ pid !== 0 ) { $ this -> childProcesses ++ ; $ socket = $ pair [ 0 ] ; socket_close ( $ pair [ 1 ] ) ; socket_set_option ( $ socket , SOL_SOCKET , SO_RCVTIMEO , [ 'sec' => 0 , 'usec' => 10000 ] ) ; return $ pid ; } $ socket = $ pair [ 1 ] ; socket_close ( $ pair [ 0 ] ) ; register_shutdown_function ( $ this -> handleChildErrors ( $ socket ) ) ; return $ pid ; }
1461	protected function orderAsc ( ) { $ this -> query -> orderBy ( $ this -> column ) ; if ( $ this -> isNotPagingOnKey ( ) ) { $ this -> query -> orderBy ( $ this -> key ) ; } return $ this ; }
9145	private static function resetLocaleTo ( $ localeSaved ) { $ localeData = explode ( ';' , $ localeSaved ) ; foreach ( $ localeData as $ identifier ) { if ( ! strchr ( $ identifier , '=' ) ) { continue ; } $ type = $ value = null ; sscanf ( $ identifier , "%s=%s" , $ type , $ value ) ; switch ( $ type ) { case 'LC_ALL' : setlocale ( LC_ALL , $ value ) ; break ; case 'LC_COLLATE' : setlocale ( LC_COLLATE , $ value ) ; break ; case 'LC_CTYPE' : setlocale ( LC_CTYPE , $ value ) ; break ; case 'LC_MONETARY' : setlocale ( LC_MONETARY , $ value ) ; break ; case 'LC_NUMERIC' : setlocale ( LC_NUMERIC , $ value ) ; break ; case 'LC_TIME' : setlocale ( LC_TIME , $ value ) ; break ; case 'LC_MESSAGES' : setlocale ( LC_MESSAGES , $ value ) ; break ; default : ; break ; } } }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
9034	protected function init ( $ key ) { if ( ! isset ( $ this -> files [ $ key ] ) ) { $ this -> files [ $ key ] = fopen ( $ this -> dir . $ key . '.lockfile' , 'w+' ) ; $ this -> owns [ $ key ] = false ; } }
763	private function updateCollectionOffsets ( ) { if ( ! empty ( $ this -> _children ) ) { $ this -> startOffset = reset ( $ this -> _children ) -> startOffset ; $ this -> endOffset = end ( $ this -> _children ) -> endOffset ; } if ( $ this -> parent !== null ) { $ this -> parent -> updateCollectionOffsets ( ) ; } }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
5284	public function limit ( $ limit , $ offset = 0 ) { global $ wpdb ; $ limit = \ absint ( $ limit ) ; $ offset = \ absint ( $ offset ) ; $ this -> limit = $ wpdb -> prepare ( 'limit %d, %d' , $ offset , $ limit ) ; return $ this ; }
7279	public function file ( $ name = null ) { return ! $ name ? $ this -> files : ( $ this -> files [ $ name ] ?? null ) ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
8838	private function getStatus ( ) : array { $ status = proc_get_status ( $ this -> process ) ; if ( ! $ status [ 'running' ] && is_null ( $ this -> exitCode ) ) { $ this -> exitCode = $ status [ 'exitcode' ] ; } return $ status ; }
898	private function isOfLowerPrecedence ( Token $ token ) { static $ tokens ; if ( null === $ tokens ) { $ tokens = [ T_AND_EQUAL , T_BOOLEAN_AND , T_BOOLEAN_OR , T_CASE , T_CONCAT_EQUAL , T_DIV_EQUAL , T_DOUBLE_ARROW , T_GOTO , T_LOGICAL_AND , T_LOGICAL_OR , T_LOGICAL_XOR , T_MINUS_EQUAL , T_MUL_EQUAL , T_OR_EQUAL , T_PLUS_EQUAL , T_RETURN , T_SL_EQUAL , T_SR_EQUAL , T_THROW , T_XOR_EQUAL , T_ECHO , T_PRINT , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO , ] ; if ( \ defined ( 'T_POW_EQUAL' ) ) { $ tokens [ ] = T_POW_EQUAL ; } if ( \ defined ( 'T_COALESCE' ) ) { $ tokens [ ] = T_COALESCE ; } } static $ otherTokens = [ '&' , '|' , '^' , '?' , ':' , '=' , ',' , ';' , ] ; return $ token -> isGivenKind ( $ tokens ) || $ token -> equalsAny ( $ otherTokens ) ; }
4049	public function fetchInputScreens ( $ idList ) : array { $ idList = array_filter ( $ idList ) ; $ builder = $ this -> connection -> createQueryBuilder ( ) ; $ screens = $ builder -> select ( 'd.*' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel' , 'm' , 'm.id=d.pid' ) -> where ( $ builder -> expr ( ) -> in ( 'd.id' , ':idList' ) ) -> setParameter ( 'idList' , $ idList , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'm.sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ keys = array_flip ( $ idList ) ; foreach ( $ screens as $ screen ) { $ metaModelName = $ keys [ $ screen [ 'id' ] ] ; $ result [ $ metaModelName ] = $ this -> prepareInputScreen ( $ metaModelName , $ screen ) ; } return $ result ; }
512	protected function addValues ( $ data , $ duration ) { $ result = $ this -> useApcu ? apcu_add ( $ data , null , $ duration ) : apc_add ( $ data , null , $ duration ) ; return is_array ( $ result ) ? array_keys ( $ result ) : [ ] ; }
3420	public function delete ( ) { if ( $ this -> onBeforeDelete ( ) === false ) { return false ; } $ result = static :: $ bxObject -> delete ( $ this -> id ) ; $ this -> setEventErrorsOnFail ( $ result , static :: $ bxObject ) ; $ this -> onAfterDelete ( $ result ) ; $ this -> resetEventErrors ( ) ; $ this -> throwExceptionOnFail ( $ result , static :: $ bxObject ) ; return $ result ; }
1477	public function update ( $ resourceType , $ id , array $ queryParams = [ ] ) { return $ this -> resource ( RouteName :: update ( $ resourceType ) , $ id , $ queryParams ) ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
6532	protected function buildParams ( SmsGatewayMessage $ message , $ to ) { $ optionalFields = array_filter ( [ 'expires_at' => data_get ( $ message , 'expiresAt' ) , 'send_at' => data_get ( $ message , 'sendAt' ) , ] ) ; return array_merge ( [ 'number' => $ to , 'message' => trim ( $ message -> content ) , ] , $ optionalFields ) ; }
6511	public function onPreDeserialize ( PreDeserializeEvent $ event ) { $ type = $ event -> getType ( ) ; if ( isset ( $ type [ 'name' ] ) && ( $ type [ 'name' ] == Job :: class || is_subclass_of ( $ type [ 'name' ] , Job :: class ) ) ) { $ data = $ event -> getData ( ) ; if ( isset ( $ data [ 'type' ] ) && isset ( $ data [ 'parameters' ] ) && is_array ( $ data [ 'parameters' ] ) && count ( $ data [ 'parameters' ] ) > 0 ) { array_push ( $ data [ 'parameters' ] , [ 'abc.job.type' => $ data [ 'type' ] ] ) ; $ event -> setData ( $ data ) ; } } }
6000	public function setImagetemplates ( array $ imagetemplates ) { $ this -> imagetemplates = [ ] ; foreach ( $ imagetemplates as $ item ) { $ this -> addImageTemplate ( $ item ) ; } return $ this ; }
5413	protected function createSocket ( $ scheme , $ host , $ port , $ timeout ) { if ( in_array ( $ scheme , array ( 'file' ) ) ) { return new SimpleFileSocket ( $ this -> url ) ; } elseif ( in_array ( $ scheme , array ( 'https' ) ) ) { return new SimpleSecureSocket ( $ host , $ port , $ timeout ) ; } else { return new SimpleSocket ( $ host , $ port , $ timeout ) ; } }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
11525	private function getDom ( $ url ) { $ ch = curl_init ( ) ; $ timeout = 5 ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ timeout ) ; $ dom = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ dom ; }
3223	function createTemporaryDirectLink ( $ path ) { Path :: checkArgNonRoot ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/media" , $ path ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; $ url = self :: getField ( $ j , "url" ) ; $ expires = self :: parseDateTime ( self :: getField ( $ j , "expires" ) ) ; return array ( $ url , $ expires ) ; }
9736	public function setWorksheet ( Worksheet $ pValue = null , $ pOverrideOld = false ) { if ( $ this -> worksheet === null ) { $ this -> worksheet = $ pValue ; $ this -> worksheet -> getCell ( $ this -> coordinates ) ; $ this -> worksheet -> getDrawingCollection ( ) -> append ( $ this ) ; } else { if ( $ pOverrideOld ) { $ iterator = $ this -> worksheet -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { if ( $ iterator -> current ( ) -> getHashCode ( ) == $ this -> getHashCode ( ) ) { $ this -> worksheet -> getDrawingCollection ( ) -> offsetUnset ( $ iterator -> key ( ) ) ; $ this -> worksheet = null ; break ; } } $ this -> setWorksheet ( $ pValue ) ; } else { throw new PhpSpreadsheetException ( 'A Worksheet has already been assigned. Drawings can only exist on one \\PhpOffice\\PhpSpreadsheet\\Worksheet.' ) ; } } return $ this ; }
8898	public function update ( $ primary_value , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where ( $ this -> primary_key , $ primary_value ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } else { return FALSE ; } }
2293	public static function getThemes ( ) { $ arrReturn = array ( ) ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrThemes = scan ( $ rootDir . '/system/themes' ) ; foreach ( $ arrThemes as $ strTheme ) { if ( strncmp ( $ strTheme , '.' , 1 ) === 0 || ! is_dir ( $ rootDir . '/system/themes/' . $ strTheme ) ) { continue ; } $ arrReturn [ $ strTheme ] = $ strTheme ; } return $ arrReturn ; }
10658	private function _uxsortmRec ( ArrayObject $ a , array $ sortFuncs , $ depth = 0 , $ sortMode = '' ) { $ goOn = ( count ( $ sortFuncs ) > $ depth + 1 ) ; $ it = $ a -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( null !== $ sortFuncs [ $ depth ] ) { if ( $ sortMode == 'a' ) { $ it -> current ( ) -> uasort ( $ sortFuncs [ $ depth ] ) ; } else if ( $ sortMode == 'k' ) { $ it -> current ( ) -> uksort ( $ sortFuncs [ $ depth ] ) ; } else { $ it -> current ( ) -> usort ( $ sortFuncs [ $ depth ] ) ; } } if ( $ goOn ) { $ this -> _uxsortmRec ( $ it -> current ( ) , $ sortFuncs , $ depth + 1 , $ sortMode ) ; } $ it -> next ( ) ; } }
5714	protected function filterFieldList ( Form $ form , FieldList $ actions ) { $ list = FieldList :: create ( ) ; foreach ( $ actions as $ a ) { if ( ! $ a instanceof BetterButtonInterface ) { throw new Exception ( "{$buttonObj->class} must implement BetterButtonInterface" ) ; } $ a -> bindGridField ( $ form , $ this -> owner ) ; if ( ! $ a -> shouldDisplay ( ) ) { continue ; } if ( ( $ a instanceof BetterButton_Versioned ) && ! $ this -> owner -> record -> checkVersioned ( ) ) { continue ; } $ list -> push ( $ a ) ; } return $ list ; }
5955	public function channelPermList ( $ cid , $ permsid = false ) { return $ this -> execute ( "channelpermlist" , array ( "cid" => $ cid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
8420	public function renderWidget ( $ config = [ ] ) { $ widgetHtml = $ this -> render ( $ this -> template , [ 'name' => $ this -> getModelName ( ) , 'attribute' => $ this -> attribute , 'label' => $ this -> label , 'texture' => $ this -> getTexture ( ) , 'disabled' => $ this -> disabled ] ) ; if ( $ this -> wrap ) { return Html :: tag ( $ this -> wrapper , $ widgetHtml , $ this -> options ) ; } return $ widgetHtml ; }
10668	public static function build ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ options ) ) { $ options = [ 'return' => ( string ) $ options ] ; } $ defaults = [ 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; if ( is_array ( $ input ) || is_object ( $ input ) ) { return self :: fromArray ( ( array ) $ input , $ options ) ; } if ( strpos ( $ input , '<' ) !== false ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> loadXML ( $ input ) ; return $ dom ; } if ( file_exists ( $ input ) || strpos ( $ input , 'http://' ) === 0 || strpos ( $ input , 'https://' ) === 0 ) { if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ input , LIBXML_NOCDATA , true ) ; } $ dom = new \ DOMDocument ( ) ; $ dom -> load ( $ input ) ; return $ dom ; } if ( ! \ is_string ( $ input ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'XML cannot be read.' ) ) ; }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
667	public static function startsWith ( $ string , $ with , $ caseSensitive = true ) { if ( ! $ bytes = static :: byteLength ( $ with ) ) { return true ; } if ( $ caseSensitive ) { return strncmp ( $ string , $ with , $ bytes ) === 0 ; } $ encoding = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; return mb_strtolower ( mb_substr ( $ string , 0 , $ bytes , '8bit' ) , $ encoding ) === mb_strtolower ( $ with , $ encoding ) ; }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
7638	public function generateSharedAccessUrl ( $ containerName = '' , $ blobName = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; return $ this -> getBaseUrl ( ) . '/' . $ resourceName . '?' . $ this -> sharedAccessSignatureCredentials -> createSignedQueryString ( $ resourceName , '' , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ; }
676	public function setPage ( $ value , $ validatePage = false ) { if ( $ value === null ) { $ this -> _page = null ; } else { $ value = ( int ) $ value ; if ( $ validatePage && $ this -> validatePage ) { $ pageCount = $ this -> getPageCount ( ) ; if ( $ value >= $ pageCount ) { $ value = $ pageCount - 1 ; } } if ( $ value < 0 ) { $ value = 0 ; } $ this -> _page = $ value ; } }
6967	protected function calculateGoodLines ( Model \ DocumentInterface $ document ) : Amount { $ gross = new Amount ( $ document -> getCurrency ( ) ) ; foreach ( $ document -> getLinesByType ( Model \ DocumentLineTypes :: TYPE_GOOD ) as $ line ) { if ( null !== $ result = $ this -> calculateGoodLine ( $ line ) ) { $ gross -> merge ( $ result ) ; } } $ gross -> copyGrossToUnit ( ) ; return $ gross ; }
445	public function getBehavior ( $ name ) { $ this -> ensureBehaviors ( ) ; return isset ( $ this -> _behaviors [ $ name ] ) ? $ this -> _behaviors [ $ name ] : null ; }
3211	static function checkArg ( $ argName , $ argValue ) { if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
10676	private function _rightStr ( $ n , $ txt ) { $ rv = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ i = $ n ; $ i < $ length ; $ i ++ ) { $ rv .= mb_substr ( $ txt , $ i , 1 , 'UTF-8' ) ; } return $ rv ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
2944	public function assignRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> attach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> attach ( $ role ) ; }
4320	public static function arrayMergeDeep ( $ arrayDef , $ array2 ) { if ( ! \ is_array ( $ arrayDef ) || self :: isCallable ( $ arrayDef ) ) { return $ array2 ; } if ( ! \ is_array ( $ array2 ) || self :: isCallable ( $ array2 ) ) { return $ array2 ; } foreach ( $ array2 as $ k2 => $ v2 ) { if ( \ is_int ( $ k2 ) ) { if ( ! \ in_array ( $ v2 , $ arrayDef ) ) { $ arrayDef [ ] = $ v2 ; } } elseif ( ! isset ( $ arrayDef [ $ k2 ] ) ) { $ arrayDef [ $ k2 ] = $ v2 ; } else { $ arrayDef [ $ k2 ] = self :: arrayMergeDeep ( $ arrayDef [ $ k2 ] , $ v2 ) ; } } return $ arrayDef ; }
8518	public function setSelectionRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SelectionRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
9798	public function setHyperlink ( Hyperlink $ pHyperlink = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set hyperlink for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setHyperlink ( $ this -> getCoordinate ( ) , $ pHyperlink ) ; return $ this -> updateInCollection ( ) ; }
2615	public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; }
4768	public static function convertPhpObjToDom ( $ arr , $ node , $ dom ) { if ( is_array ( $ arr ) ) { $ arrayParam = array ( ) ; foreach ( $ arr as $ k => $ v ) { if ( is_integer ( $ k ) ) { $ arrayParam [ ] = $ v ; } } if ( 0 < count ( $ arrayParam ) ) { $ node -> appendChild ( $ arrayDom = $ dom -> createElement ( "array" ) ) ; foreach ( $ arrayParam as $ key => $ val ) { $ new = $ arrayDom -> appendChild ( $ dom -> createElement ( 'item' ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } else { foreach ( $ arr as $ key => $ val ) { $ new = $ node -> appendChild ( $ dom -> createElement ( self :: encode ( $ key ) ) ) ; self :: convertPhpObjToDom ( $ val , $ new , $ dom ) ; } } } elseif ( ! is_object ( $ arr ) ) { $ node -> appendChild ( $ dom -> createTextNode ( self :: encode ( $ arr ) ) ) ; } }
8071	public function retrieveByCredentials ( array $ credentials ) { $ username = $ credentials [ 'username' ] ; $ result = $ this -> ldap -> find ( $ username ) ; if ( ! is_null ( $ result ) ) { $ user = new $ this -> model ; $ user -> build ( $ result ) ; return $ user ; } return null ; }
1149	protected function setDefaults ( $ options ) { $ this -> selector = empty ( $ options [ 'selector' ] ) ? 'form' : $ options [ 'selector' ] ; $ this -> view = empty ( $ options [ 'view' ] ) ? 'jsvalidation::bootstrap' : $ options [ 'view' ] ; $ this -> remote = isset ( $ options [ 'remote' ] ) ? $ options [ 'remote' ] : true ; }
8248	public function checkPasswordPolicy ( Password $ password ) { $ result = true ; $ policy = $ this -> picoAuth -> getContainer ( ) -> get ( "PasswordPolicy" ) ; $ maxAllowedLen = $ this -> getPasswordEncoder ( ) -> getMaxAllowedLen ( ) ; if ( is_int ( $ maxAllowedLen ) && strlen ( $ password ) > $ maxAllowedLen ) { $ this -> session -> addFlash ( "error" , "Maximum length is {$maxAllowedLen}." ) ; $ result = false ; } if ( ! $ policy -> check ( $ password ) ) { $ errors = $ policy -> getErrors ( ) ; foreach ( $ errors as $ error ) { $ this -> session -> addFlash ( "error" , $ error ) ; } return false ; } return $ result ; }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
3206	private function parse_response_headers ( $ headers ) { $ head = array ( ) ; foreach ( $ headers as $ key => $ value ) { $ tag = explode ( ':' , $ value , 2 ) ; if ( isset ( $ tag [ 1 ] ) ) { $ head [ trim ( $ tag [ 0 ] ) ] = trim ( $ tag [ 1 ] ) ; } else { $ head [ ] = $ value ; if ( preg_match ( '`HTTP/[0-9\.]+\s+([0-9]+)`' , $ value , $ out ) ) { $ head [ 'response_code' ] = intval ( $ out [ 1 ] ) ; } } } return $ head ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
7474	public function updateAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'Your changes have been saved.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
7556	function getChildrenByAttribute ( $ attribute , $ value , $ mode = 'equals' , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ mode = explode ( ' ' , strtolower ( $ mode ) ) ; $ match = ( ( isset ( $ mode [ 1 ] ) && ( $ mode [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'attributes' => array ( $ attribute => array ( 'operator_value' => $ mode [ 0 ] , 'value' => $ value , 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
9655	public function override ( $ name , array $ routeData ) { if ( ! isset ( $ this -> routes [ $ name ] ) ) { throw new \ InvalidArgumentException ( "No route for name $name defined" ) ; } $ this -> routes [ $ name ] = $ routeData + $ this -> routes [ $ name ] ; }
1854	public static function findCurrentByPid ( $ intPid , $ intStart , $ intEnd , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ intStart = ( int ) $ intStart ; $ intEnd = ( int ) $ intEnd ; $ arrColumns = array ( "$t.pid=? AND (($t.startTime>=$intStart AND $t.startTime<=$intEnd) OR ($t.endTime>=$intStart AND $t.endTime<=$intEnd) OR ($t.startTime<=$intStart AND $t.endTime>=$intEnd) OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$intStart) AND $t.startTime<=$intEnd))" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
8006	public static function forReasonCode ( $ code = 0 , Exception $ previous = null ) { switch ( $ code ) { case self :: CODE_FOR_ENCRYPTION_FAILURE : $ message = self :: MESSAGE_FOR_ENCRYPTION_FAILURE ; break ; case self :: CODE_FOR_RANDOM_DATA_GENERATION_FAILURE : $ message = self :: MESSAGE_FOR_RANDOM_DATA_GENERATION_FAILURE ; break ; default : $ message = self :: DEFAULT_MESSAGE ; } return new static ( $ message , $ code , $ previous ) ; }
10957	public function iLikeToMoveItMoveItBack ( ) { $ moveCommand = $ this -> popCommandFromList ( ) ; $ moveCommand -> reverseFromToDirs ( ) ; $ this -> direction = self :: DIRECTION_BACK ; $ this -> init ( $ moveCommand ) ; $ this -> processFiles ( ) ; }
8155	public function addGlobal ( $ name , $ value ) { if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { if ( null === $ this -> globals ) { $ this -> globals = $ this -> initGlobals ( ) ; } if ( ! array_key_exists ( $ name , $ this -> globals ) ) { @ trigger_error ( sprintf ( 'Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.' , $ name ) , E_USER_DEPRECATED ) ; } } if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { $ this -> globals [ $ name ] = $ value ; } else { $ this -> staging -> addGlobal ( $ name , $ value ) ; } }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
11338	public function getPrimaryKeyLocation ( $ table ) { $ count = 0 ; foreach ( $ table -> columns as $ column ) { if ( $ column -> isPrimaryKey ) { $ count ++ ; } if ( $ count > 1 ) { return 'index' ; } } return 'table_build' ; }
4609	protected function registerPlugin ( ) { $ view = $ this -> getView ( ) ; MultiSelectAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = $ this -> clientOptions !== false && ! empty ( $ this -> clientOptions ) ? Json :: encode ( $ this -> clientOptions ) : '' ; $ js = "jQuery('#$id').multiselect($options);" ; $ view -> registerJs ( $ js ) ; }
11565	private function getApp ( ) { if ( is_null ( $ this -> app ) ) { $ this -> app = \ Concrete \ Core \ Support \ Facade \ Application :: getFacadeApplication ( ) ; } return $ this -> app ; }
12722	protected function turnIntoResolvableClosure ( $ abstract , $ concrete ) { return function ( Container $ container , $ parameters = [ ] ) use ( $ abstract , $ concrete ) { return ( $ abstract == $ concrete ? $ container -> resolve ( $ abstract ) : $ container -> resolve ( $ concrete , $ parameters ) ) ; } ; }
12536	public function authenticate ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , ] ) ; $ account -> save ( false ) ; } if ( null === ( $ user = $ account -> user ) ) { $ this -> action -> successUrl = Url :: to ( [ '/user/registration/connect' , 'account_id' => $ account -> id ] ) ; } else { \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; } }
3674	private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } }
12357	public function updateEntryName ( ContentfulEntry $ entry ) { $ displayField = $ this -> getDisplayField ( ) ; $ values = array_values ( ( array ) $ entry -> { $ displayField } ) ; $ entry -> setName ( isset ( $ values [ 0 ] ) ? $ values [ 0 ] : 'Untitled' ) ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
8578	public function setItemFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8373	protected function configure ( ) { $ this -> setName ( 'worker/process' ) -> setHidden ( true ) -> setDescription ( 'Runs a given worker' ) -> setDefinition ( new InputDefinition ( [ new InputOption ( 'config' , 'c' , InputOption :: VALUE_REQUIRED , 'A YAML configuration file' ) , new InputOption ( 'jobId' , null , InputOption :: VALUE_REQUIRED , 'A Job UUID' ) , new InputOption ( 'name' , null , InputOption :: VALUE_REQUIRED , 'The queue name to work with. Defaults to `default`.' ) , ] ) ) ; }
12399	public function orderBy ( $ field , $ order = null ) { $ this -> scope -> orderBy [ ] = Parser :: orderBy ( $ field , $ order ) ; return $ this ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
2489	public function hasMultipleEndpoints ( ) { if ( $ this -> hasMultiple !== null ) { return $ this -> hasMultiple ; } $ endpointSet = array_flip ( $ this -> endpointMap ) ; if ( isset ( $ this -> defaultEndpoint ) ) { $ endpointSet [ $ this -> defaultEndpoint ] = true ; } if ( isset ( $ this -> mainLanguagesEndpoint ) ) { $ endpointSet [ $ this -> mainLanguagesEndpoint ] = true ; } return $ this -> hasMultiple = count ( $ endpointSet ) > 1 ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
4236	public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; }
8162	public function unblock ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
11295	public function getAttributeValue ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } return null ; }
8696	public function handle ( ) { $ config = $ this -> option ( 'config' ) ; if ( ! $ config ) { throw new Exception ( 'Config option is required.' ) ; } $ configPath = realpath ( $ config ) ; if ( ! file_exists ( $ configPath ) ) { throw new Exception ( 'Configuration file not found.' ) ; } $ config = require ( $ configPath ) ; $ this -> info ( sprintf ( 'Configuring with file "%s".' , $ configPath ) ) ; $ this -> getRbacService ( ) -> configure ( $ config ) ; $ this -> info ( 'Configuration done.' ) ; }
11630	private function getTransactions ( $ turnover , $ dsEnd ) { $ dateApplied = $ this -> hlpPeriod -> getTimestampUpTo ( $ dsEnd ) ; $ result = $ this -> aPrepareTrans -> exec ( $ turnover , $ dateApplied ) ; return $ result ; }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
7310	public static function solsticeSummer ( $ year ) { $ jd = static :: solsticeJune ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
8854	public function getArchiveYear ( ) { $ year = $ this -> request -> param ( "Year" ) ; if ( preg_match ( "/^[0-9]{4}$/" , $ year ) ) { return ( int ) $ year ; } return null ; }
1685	public function checkAdminDisable ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == 1 && $ this -> User -> id == $ dc -> id ) { $ varValue = '' ; } return $ varValue ; }
6538	public function init ( ) { Html :: addCssClass ( $ this -> options , [ 'panel' , 'sx-panel' , $ this -> color ] ) ; $ options = ArrayHelper :: merge ( $ this -> options , [ 'id' => $ this -> id , ] ) ; echo Html :: beginTag ( 'div' , $ options ) ; echo Html :: beginTag ( 'div' , $ this -> headingOptions ) ; echo <<<HTML <div class="pull-left"> <h2> {$this->name} </h2> </div> <div class="panel-actions panel-hidden-actions"> {$this->actions} </div>HTML ; echo Html :: endTag ( 'div' ) ; echo Html :: beginTag ( 'div' , $ this -> bodyOptions ) ; echo $ this -> content ; }
1934	protected function getDateString ( ) { return 'Locale.define("en-US","Date",{' . 'months:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] ) . '"],' . 'days:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] ) . '"],' . 'months_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] ) . '"],' . 'days_abbr:["' . implode ( '","' , $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] ) . '"]' . '});' . 'Locale.define("en-US","DatePicker",{' . 'select_a_time:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'select_a_time' ] . '",' . 'use_mouse_wheel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'use_mouse_wheel' ] . '",' . 'time_confirm_button:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'time_confirm_button' ] . '",' . 'apply_range:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'apply_range' ] . '",' . 'cancel:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'cancel' ] . '",' . 'week:"' . $ GLOBALS [ 'TL_LANG' ] [ 'DP' ] [ 'week' ] . '"' . '});' ; }
1365	protected function bootMiddleware ( Router $ router ) { $ router -> aliasMiddleware ( 'json-api' , BootJsonApi :: class ) ; $ router -> aliasMiddleware ( 'json-api.content' , NegotiateContent :: class ) ; $ router -> aliasMiddleware ( 'json-api.auth' , Authorize :: class ) ; }
3325	public function renderOption ( Option $ opt ) { $ c1 = '' ; if ( $ opt -> short && $ opt -> long ) { $ c1 = sprintf ( '-%s, --%s' , $ opt -> short , $ opt -> long ) ; } else if ( $ opt -> short ) { $ c1 = sprintf ( '-%s' , $ opt -> short ) ; } else if ( $ opt -> long ) { $ c1 = sprintf ( '--%s' , $ opt -> long ) ; } $ c1 .= $ opt -> renderValueHint ( ) ; return $ c1 ; }
997	public function offsetUnset ( $ offset ) { if ( $ offset === true ) { $ this -> trueValue = null ; $ this -> trueValueIsSet = false ; } elseif ( $ offset === false ) { $ this -> falseValue = null ; $ this -> falseValueIsSet = false ; } elseif ( is_int ( $ offset ) || is_string ( $ offset ) ) { unset ( $ this -> standardStore [ $ offset ] ) ; } elseif ( is_float ( $ offset ) ) { unset ( $ this -> floatStore [ ( string ) $ offset ] ) ; } elseif ( is_object ( $ offset ) ) { $ this -> objectStore -> offsetUnset ( $ offset ) ; } elseif ( is_array ( $ offset ) ) { $ index = array_search ( $ offset , $ this -> arrayKeys , true ) ; if ( $ index !== false ) { array_splice ( $ this -> arrayKeys , $ index , 1 ) ; array_splice ( $ this -> arrayValues , $ index , 1 ) ; } } elseif ( $ offset === null ) { $ this -> nullValue = null ; $ this -> nullValueIsSet = false ; } }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
9482	private function prepare ( array $ folders ) { return collect ( $ folders ) -> mapWithKeys ( function ( $ folder ) { $ path = base_path ( $ folder ) ; return [ $ folder => [ 'chmod' => ( int ) substr ( sprintf ( '%o' , fileperms ( $ path ) ) , - 4 ) , 'writable' => is_writable ( $ path ) , ] , ] ; } ) ; }
11451	public function getParentKeyName ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; $ relat = $ this -> $ func ( ) ; $ field = $ relat -> getForeignKey ( ) ; return $ field ; } return 'id' ; }
6346	public static function concat ( Iterator $ a , Iterator $ b ) : Iterator { return self :: concatIterators ( new ArrayIterator ( [ $ a , $ b ] ) ) ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
4019	protected function handleSaveCallback ( $ field , $ widget , $ value ) { $ newValue = $ value ; if ( isset ( $ field [ 'save_callback' ] ) && is_array ( $ field [ 'save_callback' ] ) ) { foreach ( $ field [ 'save_callback' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; try { $ newValue = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ newValue , $ this ) ; } catch ( Exception $ e ) { $ widget -> addError ( $ e -> getMessage ( ) ) ; $ this -> blnSubmitInput = false ; return $ value ; } } } return $ newValue ; }
6513	public function copyJob ( JobInterface $ from , \ Abc \ Bundle \ JobBundle \ Model \ JobInterface $ to ) { $ to -> setType ( $ from -> getType ( ) ) ; $ to -> setResponse ( $ from -> getResponse ( ) ) ; $ to -> setParameters ( $ from -> getParameters ( ) ) ; if ( null != $ from -> getStatus ( ) ) { $ to -> setStatus ( $ from -> getStatus ( ) ) ; } foreach ( $ from -> getSchedules ( ) as $ schedule ) { $ to -> addSchedule ( $ schedule ) ; } return $ to ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
3109	public function getCatValue ( $ assessmentSectionId , $ key ) { return ( isset ( $ this -> state [ self :: VAR_CAT ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] ) && isset ( $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] ) ) ? $ this -> state [ self :: VAR_CAT ] [ $ assessmentSectionId ] [ $ key ] : null ; }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
2211	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ arrReturn = array ( ) ; while ( ( $ arrRow = $ this -> fetchAssoc ( ) ) !== false ) { if ( $ strKey != 'id' && isset ( $ arrRow [ 'id' ] ) ) { $ arrReturn [ $ arrRow [ 'id' ] ] = $ arrRow [ $ strKey ] ; } else { $ arrReturn [ ] = $ arrRow [ $ strKey ] ; } } return $ arrReturn ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
11331	public function setModel ( $ value ) { $ this -> _model = $ value ; if ( is_object ( $ value ) && $ this -> _attributes ) { $ this -> _model -> attributes = $ this -> _attributes ; } return true ; }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
4527	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Identitiable ) { return ; } $ this -> identityService -> generateIdentity ( $ entity ) ; }
8561	public function cancelShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CancelShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CancelShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CancelShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CancelShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CancelShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3364	public function flush ( $ args , $ assoc_args ) { self :: apache_modules ( ) ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) && is_multisite ( ) ) { WP_CLI :: warning ( "WordPress can't generate .htaccess file for a multisite install." ) ; } self :: check_skip_plugins_themes ( ) ; flush_rewrite_rules ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) ; if ( ! get_option ( 'rewrite_rules' ) ) { WP_CLI :: warning ( "Rewrite rules are empty, possibly because of a missing permalink_structure option. Use 'wp rewrite list' to verify, or 'wp rewrite structure' to update permalink_structure." ) ; } else { WP_CLI :: success ( 'Rewrite rules flushed.' ) ; } }
2130	protected function markModified ( ) { if ( $ this -> blnIsModified === true ) { return ; } $ this -> blnIsModified = true ; $ this -> strTop = '' ; $ this -> strBottom = '' ; $ this -> Files = Files :: getInstance ( ) ; if ( static :: $ blnHasLcf ) { $ strMode = 'top' ; $ resFile = fopen ( $ this -> strRootDir . '/system/config/localconfig.php' , 'rb' ) ; while ( ! feof ( $ resFile ) ) { $ strLine = fgets ( $ resFile ) ; $ strTrim = trim ( $ strLine ) ; if ( $ strTrim == '?>' ) { continue ; } if ( $ strTrim == '### INSTALL SCRIPT START ###' ) { $ strMode = 'data' ; continue ; } if ( $ strTrim == '### INSTALL SCRIPT STOP ###' ) { $ strMode = 'bottom' ; continue ; } if ( $ strMode == 'top' ) { $ this -> strTop .= $ strLine ; } elseif ( $ strMode == 'bottom' ) { $ this -> strBottom .= $ strLine ; } elseif ( $ strTrim != '' ) { $ arrChunks = array_map ( 'trim' , explode ( '=' , $ strLine , 2 ) ) ; $ this -> arrData [ $ arrChunks [ 0 ] ] = $ arrChunks [ 1 ] ; } } fclose ( $ resFile ) ; } }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
12862	public function parseBehaviour ( \ stdClass $ block , $ search ) { if ( ! isset ( $ block -> behaviour ) ) { return false ; } $ behaviours = array ( ) ; foreach ( explode ( ' ' , trim ( $ block -> behaviour ) ) as $ b ) { if ( strstr ( $ b , ':' ) ) { list ( $ name , $ prop ) = explode ( ':' , $ b , 2 ) ; $ behaviours [ $ name ] = $ prop ; } else { $ behaviours [ $ b ] = true ; } } return isset ( $ behaviours [ $ search ] ) ? $ behaviours [ $ search ] : false ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
12299	public function getPivotFields ( $ obj , $ prop ) { $ reflection = new \ ReflectionClass ( $ obj ) ; $ property = $ reflection -> getProperty ( $ prop ) ; $ property -> setAccessible ( true ) ; $ value = $ property -> getValue ( $ obj ) ; $ property -> setAccessible ( false ) ; return array_diff ( $ value , [ 'deleted_at' , 'created_at' , 'updated_at' ] ) ; }
11884	public function getModuleHandler ( ) { if ( is_null ( $ this -> _moduleHandler ) ) { $ stem = $ this -> field ; if ( ! isset ( self :: $ _moduleHandlers [ $ stem ] ) ) { self :: $ _moduleHandlers [ $ stem ] = [ ] ; } $ n = count ( self :: $ _moduleHandlers [ $ stem ] ) ; $ this -> _moduleHandler = $ this -> field . ':_' . $ n ; self :: $ _moduleHandlers [ $ stem ] [ ] = $ this -> _moduleHandler ; } return $ this -> _moduleHandler ; }
10342	protected function isValidDate ( $ year , $ month , $ day ) { if ( $ month <= 0 || $ month > 12 || $ day <= 0 || $ day > 31 ) { return false ; } if ( ( $ month == 4 || $ month == 6 || $ month == 9 || $ month == 11 ) && ( $ day == 31 ) ) { return false ; } if ( $ month == 2 ) { if ( $ day > 29 ) { return false ; } $ leap = date ( 'L' , strtotime ( $ year . '-01-01' ) ) ; if ( $ leap === '0' && $ day > 28 ) { return false ; } } return true ; }
3897	public function pagePicker ( ManipulateWidgetEvent $ event ) { if ( ! $ this -> scopeDeterminator -> currentScopeIsBackend ( ) || ! ( 'tl_metamodel_rendersettings' === $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ! ( ( 0 === strpos ( $ event -> getProperty ( ) -> getName ( ) , 'jumpTo' ) ) && ( '[value]' === substr ( $ event -> getProperty ( ) -> getName ( ) , - \ strlen ( '[value]' ) ) ) ) ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ pickerUrl = $ this -> pickerBuilder -> getUrl ( 'cca_link' ) ; $ urlEvent = new GenerateHtmlEvent ( 'pickpage.svg' , $ environment -> getTranslator ( ) -> translate ( 'MSC.pagepicker' ) , 'style="vertical-middle:top;cursor:pointer"' ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ urlEvent ) ; $ template = new ContaoBackendViewTemplate ( 'dc_general_wizard_link_url_picker' ) ; $ template -> set ( 'name' , $ event -> getWidget ( ) -> name ) -> set ( 'popupUrl' , $ pickerUrl ) -> set ( 'html' , ' ' . $ urlEvent -> getHtml ( ) ) -> set ( 'label' , $ event -> getProperty ( ) -> getLabel ( ) [ 1 ] ) -> set ( 'id' , $ event -> getWidget ( ) -> id ) ; $ event -> getWidget ( ) -> wizard = $ template -> parse ( ) ; }
2767	public function pushTag ( string $ tag , string $ repository = 'origin' , array $ options = [ ] ) : string { return $ this -> push ( $ repository , 'tag' , $ tag , $ options ) ; }
12791	public static function createLayout ( string $ layoutName , View $ view ) : ? Layout { $ layoutsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'layouts' ) ; $ layoutFile = $ layoutsRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ layoutName ) . '.php' ; if ( is_readable ( $ layoutFile ) ) { return new Layout ( $ layoutFile , $ view ) ; } return null ; }
12354	public function setFilePath ( string $ viewFilePath ) : void { if ( ! is_readable ( $ viewFilePath ) ) { throw new Exception ( "The View file {$viewFilePath} isn't readable." ) ; } $ this -> filePath = $ viewFilePath ; }
12020	function addSetAPIMethod ( ) { $ methodGenerator = new MethodGenerator ( 'setAPI' ) ; $ methodGenerator -> setBody ( '$this->api = $api;' ) ; $ parameterGenerator = new ParameterGenerator ( 'api' , $ this -> apiClassname ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
8082	public function report ( $ message ) { $ channel = $ this -> currentChannel ; if ( $ message ) { $ reports = & $ this -> getReports ( $ channel ) ; $ reports [ ] = $ message ; } return $ this ; }
2194	protected function activateAcount ( ) { $ this -> strTemplate = 'mod_message' ; $ this -> Template = new FrontendTemplate ( $ this -> strTemplate ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_member' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objMember = MemberModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objMember -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objMember -> disable = '' ; $ objMember -> save ( ) ; $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateAccount' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objMember , $ this ) ; } } $ this -> log ( 'User account ID ' . $ objMember -> id . ' (' . Idna :: decodeEmail ( $ objMember -> email ) . ') has been activated' , __METHOD__ , TL_ACCESS ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'reg_jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } $ this -> Template -> type = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'accountActivated' ] ; }
10324	private function createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source ) { $ queryParameters = array ( ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
12121	public function getLastModified ( Request $ request ) { $ minModified = $ this -> getLastMinModifiedDate ( ) ; $ optionalLastModified = Option :: fromValue ( $ this -> cache -> fetch ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) ) , false ) ; if ( $ optionalLastModified -> isEmpty ( ) ) { return $ minModified ; } return max ( $ minModified , new \ DateTime ( $ optionalLastModified -> get ( ) ) ) ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
2268	public function isUniqueValue ( $ strTable , $ strField , $ varValue , $ intId = null ) { $ strQuery = "SELECT * FROM $strTable WHERE " . static :: quoteIdentifier ( $ strField ) . "=?" ; if ( $ intId !== null ) { $ strQuery .= " AND id!=?" ; } $ objUnique = $ this -> prepare ( $ strQuery ) -> limit ( 1 ) -> execute ( $ varValue , $ intId ) ; return $ objUnique -> numRows ? false : true ; }
11806	public function chunk ( $ count , callable $ callback ) { return $ this -> buildQuery ( $ this -> getQueryColumns ( ) ) -> chunk ( $ count , $ callback ) ; }
7411	public function combine ( array $ keys ) : self { if ( count ( $ keys ) !== count ( $ this -> _container ) ) { throw new LengthException ( 'array counts do not match' ) ; } $ this -> _container = array_combine ( $ keys , $ this -> _container ) ; return $ this ; }
5421	protected function parse ( $ raw ) { if ( ! $ raw ) { $ this -> setError ( 'Nothing fetched' ) ; $ this -> headers = new SimpleHttpHeaders ( '' ) ; } elseif ( 'file' === $ this -> url -> getScheme ( ) ) { $ this -> headers = new SimpleHttpHeaders ( '' ) ; $ this -> content = $ raw ; } elseif ( ! strstr ( $ raw , "\r\n\r\n" ) ) { $ this -> setError ( 'Could not split headers from content' ) ; $ this -> headers = new SimpleHttpHeaders ( $ raw ) ; } else { list ( $ headers , $ this -> content ) = explode ( "\r\n\r\n" , $ raw , 2 ) ; $ this -> headers = new SimpleHttpHeaders ( $ headers ) ; } }
5634	protected function handle ( & $ test , $ filename ) { if ( preg_match ( $ this -> pattern , $ filename ) ) { parent :: handle ( $ test , $ filename ) ; } }
12223	public function get ( $ keys = [ ] ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> get ( ) ; } return $ this -> builder -> withColumns ( $ keys ) -> get ( $ keys ) ; }
3739	private function saveBaseColumns ( IItem $ item , $ timestamp ) { $ isNew = false ; $ item -> set ( 'tstamp' , $ timestamp ) ; if ( ! $ item -> get ( 'id' ) ) { $ isNew = true ; $ this -> createNewItem ( $ item ) ; } if ( null !== $ item -> get ( 'pid' ) ) { $ this -> saveSimpleColumn ( 'pid' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'pid' ) ) ; } if ( null !== $ item -> get ( 'sorting' ) ) { $ this -> saveSimpleColumn ( 'sorting' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'sorting' ) ) ; } $ this -> saveSimpleColumn ( 'tstamp' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'tstamp' ) ) ; return $ isNew ; }
3428	public function paginate ( $ perPage = 15 , $ pageName = 'page' ) { $ page = Paginator :: resolveCurrentPage ( $ pageName ) ; $ total = $ this -> count ( ) ; $ results = $ this -> forPage ( $ page , $ perPage ) -> getList ( ) ; return new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page , [ 'path' => Paginator :: resolveCurrentPath ( ) , 'pageName' => $ pageName , ] ) ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
8608	public function registerDestination ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_RegisterDestinationInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationInput.php' ) ; $ request = new MWSSubscriptionsService_Model_RegisterDestinationInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/RegisterDestinationResponse.php' ) ; $ response = MWSSubscriptionsService_Model_RegisterDestinationResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
5911	public function createUser ( User $ user , $ password = null , $ redirectTo = null , $ sendNotificationEmail = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password , 'redirectTo' => $ redirectTo , 'sendNotificationEmail' => $ sendNotificationEmail ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
12581	public function previewCardByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_CARD , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
7887	protected function parse ( ) { $ log = [ ] ; $ pattern = "/\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\].*/" ; preg_match_all ( $ pattern , $ this -> raw , $ headings ) ; $ data = preg_split ( $ pattern , $ this -> raw ) ; if ( $ data [ 0 ] < 1 ) { $ trash = array_shift ( $ data ) ; unset ( $ trash ) ; } foreach ( $ headings as $ heading ) { for ( $ i = 0 , $ j = count ( $ heading ) ; $ i < $ j ; $ i ++ ) { foreach ( $ this -> levels as $ level ) { if ( $ this -> level == $ level || $ this -> level == 'all' ) { if ( strpos ( strtolower ( $ heading [ $ i ] ) , strtolower ( '.' . $ level ) ) ) { $ log [ ] = [ 'level' => $ level , 'header' => $ heading [ $ i ] , 'stack' => $ data [ $ i ] ] ; } } } } } unset ( $ headings ) ; unset ( $ data ) ; return array_reverse ( $ log ) ; }
11966	public function renderSlots ( Page $ page , array $ slots , array $ options = array ( ) ) { $ renderedSlots = array ( ) ; $ slots = $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERING , $ page , $ slots ) ; foreach ( $ slots as $ slotName => $ slot ) { if ( is_string ( $ slot ) ) { $ renderedSlots [ $ slotName ] = $ slot ; continue ; } if ( ! $ slot instanceof Slot ) { continue ; } $ renderedSlots [ $ slotName ] = implode ( "" , $ this -> renderSlot ( $ slot ) ) ; } $ this -> mediaFiles = array_unique ( $ this -> mediaFiles ) ; return $ this -> dispatchSlotsEvent ( RenderEvents :: SLOTS_RENDERED , $ page , $ renderedSlots ) ; }
4659	public function getChainStrategy ( ) { $ strategy = new ChainBuildStrategy ( ) ; $ strategy -> pushStrategy ( $ this -> getTravisCiStrategy ( ) ) ; $ strategy -> pushStrategy ( $ this -> getJoliCiStrategy ( ) ) ; return $ strategy ; }
3400	protected function makeRequest ( $ arguments = [ ] ) { $ defaults = $ this -> getDefaultOptions ( ) ; $ arguments = array_merge ( $ defaults , $ arguments ) ; $ client = $ this -> resource -> getGuzzle ( ) ; $ request = $ client -> createRequest ( $ this -> getMethod ( ) , $ this -> url , $ arguments ) ; $ response = $ client -> send ( $ request ) ; $ this -> setResponse ( $ response ) ; $ this -> setContent ( ( string ) $ response -> getBody ( ) ) ; }
10047	protected function copyRecursive ( $ src , $ dst , $ depth , Logger $ logger ) { if ( $ depth == 0 ) { return ; } if ( ! is_file ( $ src ) && ! is_dir ( $ src ) ) { $ logger -> log ( "$src is not a valid source." , Logger :: WARNING ) ; return ; } if ( ! is_readable ( $ src ) ) { $ logger -> log ( "$src is not readable, skipping." , Logger :: WARNING ) ; return ; } if ( is_file ( $ dst ) || is_dir ( $ dst ) ) { $ logger -> log ( "$dst already exists, and cannot be overwritten." , Logger :: WARNING ) ; return ; } if ( is_dir ( $ src ) ) { mkdir ( $ dst ) ; } elseif ( is_file ( $ src ) ) { copy ( $ src , $ dst ) ; return ; } $ dh = opendir ( $ src ) ; while ( ( $ file = readdir ( $ dh ) ) !== false ) { if ( ( $ file === '.' ) || ( $ file === '..' ) ) { continue ; } $ this -> copyRecursive ( $ src . '/' . $ file , $ dst . '/' . $ file , $ depth - 1 , $ logger ) ; } }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
6409	public static function concat ( IteratorAggregate $ a , IteratorAggregate $ b ) : IteratorAggregate { return self :: from ( Iterators :: concat ( Iterators :: from ( $ a -> getIterator ( ) ) , Iterators :: from ( $ b -> getIterator ( ) ) ) ) ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
5931	public function setDefinition ( $ definition ) { if ( is_array ( $ definition ) ) { $ this -> definition = $ definition ; return $ this ; } $ this -> definition = json_decode ( $ definition , true ) ; if ( null === $ this -> definition ) { $ this -> definition = $ definition ; } return $ this ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
11736	public function setAddress ( $ address ) { $ address = trim ( $ address , self :: SEPARATOR ) ; if ( ! filter_var ( $ address , FILTER_VALIDATE_URL ) ) { throw new \ InvalidArgumentException ( "$address is not valid format of url address." ) ; } $ this -> address = $ address ; $ this -> parse = parse_url ( $ address ) ; return $ this ; }
6512	public function updateJob ( EntityJobInterface $ job , Status $ status , $ processingTime = 0 , $ response = null ) { $ job -> setStatus ( $ status ) ; $ job -> setProcessingTime ( $ job -> getProcessingTime ( ) + ( $ processingTime === null ? 0 : $ processingTime ) ) ; $ job -> setResponse ( $ response ) ; if ( Status :: isTerminated ( $ status ) ) { $ job -> setTerminatedAt ( new \ DateTime ( ) ) ; } if ( $ job -> hasSchedules ( ) && Status :: isTerminated ( $ status ) ) { foreach ( $ job -> getSchedules ( ) as $ schedule ) { if ( method_exists ( $ schedule , 'setIsActive' ) ) { $ schedule -> setIsActive ( false ) ; } } } }
6368	private function parseWithMode ( $ raw_taf , $ strict ) { $ clean_taf = trim ( $ raw_taf ) ; $ clean_taf = preg_replace ( "#\n+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( "#\r+#" , ' ' , $ clean_taf ) ; $ clean_taf = preg_replace ( '#[ ]{2,}#' , ' ' , $ clean_taf ) . ' ' ; $ clean_taf = strtoupper ( $ clean_taf ) ; if ( strpos ( $ clean_taf , 'CNL' ) === false ) { $ remaining_taf = trim ( $ clean_taf ) . ' END' ; } else { $ remaining_taf = $ clean_taf ; } $ decoded_taf = new DecodedTaf ( $ clean_taf ) ; $ with_cavok = false ; foreach ( $ this -> decoder_chain as $ chunk_decoder ) { try { $ decoded = $ chunk_decoder -> parse ( $ remaining_taf , $ with_cavok ) ; $ result = $ decoded [ 'result' ] ; if ( $ result != null ) { foreach ( $ result as $ key => $ value ) { if ( $ value !== null ) { $ setter_name = 'set' . ucfirst ( $ key ) ; $ decoded_taf -> $ setter_name ( $ value ) ; } } } $ remaining_taf = $ decoded [ 'remaining_taf' ] ; } catch ( ChunkDecoderException $ cde ) { $ decoded_taf -> addDecodingException ( $ cde ) ; if ( $ strict ) { break ; } $ remaining_taf = $ cde -> getRemainingTaf ( ) ; } if ( $ chunk_decoder instanceof VisibilityChunkDecoder ) { $ with_cavok = $ decoded_taf -> getCavok ( ) ; } } $ evolutionDecoder = new EvolutionChunkDecoder ( $ strict , $ with_cavok ) ; while ( $ remaining_taf != null && trim ( $ remaining_taf ) != 'END' ) { $ evolutionDecoder -> parse ( $ remaining_taf , $ decoded_taf ) ; $ remaining_taf = $ evolutionDecoder -> getRemaining ( ) ; } return $ decoded_taf ; }
3689	public function createButton ( GetOperationButtonEvent $ event ) { if ( 'createvariant' !== $ event -> getCommand ( ) -> getName ( ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metamodel = $ model -> getItem ( ) -> getMetaModel ( ) ; if ( ! $ metamodel -> hasVariants ( ) || $ model -> getProperty ( 'varbase' ) === '0' ) { $ event -> setHtml ( '' ) ; } }
3155	public function storeOutcomeVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getOutcomeVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
4188	public function boot ( Factory $ validator ) { $ passwordStrength = app ( 'passwordStrength' ) ; $ translator = app ( 'passwordStrength.translationProvider' ) -> get ( $ validator ) ; foreach ( [ 'letters' , 'numbers' , 'caseDiff' , 'symbols' ] as $ rule ) { $ snakeCasedRule = snake_case ( $ rule ) ; $ validator -> extend ( $ rule , function ( $ _ , $ value , $ __ ) use ( $ passwordStrength , $ rule ) { $ capitalizedRule = ucfirst ( $ rule ) ; return call_user_func ( [ $ passwordStrength , "validate{$capitalizedRule}" ] , $ value ) ; } , $ translator -> get ( "password-strength::validation.{$snakeCasedRule}" ) ) ; } }
2694	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
9542	public function runSyncAction ( $ syncActionBaseUrl , $ component , $ action , array $ configData ) { $ uriParts = [ ] ; if ( $ this -> super ) { $ uriParts [ ] = $ this -> super ; } $ uriParts [ ] = $ component ; $ uriParts [ ] = 'action' ; $ uriParts [ ] = $ action ; $ uri = rtrim ( $ syncActionBaseUrl , '/' ) . '/' . implode ( '/' , $ uriParts ) ; $ body = [ 'configData' => $ configData , ] ; try { $ request = new Request ( 'POST' , $ uri , [ ] , json_encode ( $ body ) ) ; $ response = $ this -> guzzle -> send ( $ request ) ; } catch ( RequestException $ e ) { throw new ClientException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return $ this -> decodeResponse ( $ response ) ; }
2240	public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; foreach ( TemplateLoader :: getPrefixedFiles ( $ strPrefix ) as $ strTemplate ) { $ arrTemplates [ $ strTemplate ] [ ] = 'root' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrCustomized = self :: braceGlob ( $ rootDir . '/templates/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrCustomized ) ) { foreach ( $ arrCustomized as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'global' ] ; } } if ( $ strPrefix != 'be_' && $ strPrefix != 'mail_' ) { try { $ objTheme = ThemeModel :: findAll ( array ( 'order' => 'name' ) ) ; } catch ( \ Exception $ e ) { $ objTheme = null ; } if ( $ objTheme !== null ) { while ( $ objTheme -> next ( ) ) { if ( $ objTheme -> templates != '' ) { $ arrThemeTemplates = self :: braceGlob ( $ rootDir . '/' . $ objTheme -> templates . '/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrThemeTemplates ) ) { foreach ( $ arrThemeTemplates as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ objTheme -> name ; } } } } } } foreach ( $ arrTemplates as $ k => $ v ) { $ v = array_filter ( $ v , function ( $ a ) { return $ a != 'root' ; } ) ; if ( empty ( $ v ) ) { $ arrTemplates [ $ k ] = $ k ; } else { $ arrTemplates [ $ k ] = $ k . ' (' . implode ( ', ' , $ v ) . ')' ; } } ksort ( $ arrTemplates ) ; return $ arrTemplates ; }
7130	public function getNotifications ( $ type = null ) { if ( null !== $ type ) { NotificationTypes :: isValidType ( $ type ) ; return $ this -> notifications -> filter ( function ( NotificationInterface $ n ) use ( $ type ) { return $ n -> getType ( ) === $ type ; } ) ; } return $ this -> notifications ; }
4109	public function toOptionArray ( ) { $ options = array ( ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_comment' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Comments' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_opentip' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups' ) ) ; $ options [ ] = array ( 'value' => 'aoe_templatehints/renderer_tipOnly' , 'label' => Mage :: helper ( 'aoe_templatehints' ) -> __ ( 'Popups (border initially invisible)' ) ) ; Mage :: dispatchEvent ( 'aoetemplatehints_hintrenderer_options' , array ( 'options' => & $ options ) ) ; return $ options ; }
8944	public function getDetails ( ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/details' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'GET' , $ parameters ) ; return $ response -> body ; }
7487	public function lastIndexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strrpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
4474	public function perform ( ) : bool { try { $ instance = $ this -> getInstance ( ) ; if ( method_exists ( $ instance , 'setUp' ) ) { $ instance -> setUp ( ) ; } $ this -> getEventsManager ( ) -> fire ( new JobEvent \ BeforePerform ( $ this , $ this ) ) ; $ performMethod = $ this -> getPerformMethod ( ) ; $ instance -> $ performMethod ( $ this ) ; $ this -> getEventsManager ( ) -> fire ( new JobEvent \ AfterPerform ( $ this , $ this ) ) ; if ( method_exists ( $ instance , 'tearDown' ) ) { $ instance -> tearDown ( ) ; } } catch ( \ Throwable $ e ) { $ this -> fail ( 'system:fatal' , sprintf ( '%s: %s in %s on line %d' , get_class ( $ e ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) ) ) ; return false ; } return true ; }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
6445	public function getLoginStartUrl ( $ redirecturl ) { $ linkedin = $ this -> getClient ( $ redirecturl ) ; $ url = $ linkedin -> getLoginUrl ( array ( \ LinkedIn \ LinkedIn :: SCOPE_BASIC_PROFILE , \ LinkedIn \ LinkedIn :: SCOPE_EMAIL_ADDRESS ) ) ; return $ url ; }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
1282	public function getField ( string $ fieldId , bool $ tryCaseInsensitive = false ) { if ( isset ( $ this -> fields [ $ fieldId ] ) ) { return $ this -> fields [ $ fieldId ] ; } if ( $ tryCaseInsensitive ) { foreach ( $ this -> fields as $ name => $ field ) { if ( \ mb_strtolower ( $ name ) === \ mb_strtolower ( $ fieldId ) ) { return $ field ; } } } return null ; }
1143	protected function bootstrapViews ( ) { $ viewPath = realpath ( __DIR__ . '/../resources/views' ) ; $ this -> loadViewsFrom ( $ viewPath , 'jsvalidation' ) ; $ this -> publishes ( [ $ viewPath => $ this -> app [ 'path.base' ] . '/resources/views/vendor/jsvalidation' , ] , 'views' ) ; }
5151	protected function textAfterString ( $ haystack , $ needle ) { $ result = "" ; $ needleLength = strlen ( $ needle ) ; if ( $ needleLength > 0 && preg_match ( "#$needle([^\r\n]+)#i" , $ haystack , $ match ) ) { $ result = trim ( substr ( $ match [ 0 ] , - ( strlen ( $ match [ 0 ] ) - $ needleLength ) ) ) ; } return $ result ; }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
9880	private function writeWorkbookProtection ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { if ( $ spreadsheet -> getSecurity ( ) -> isSecurityEnabled ( ) ) { $ objWriter -> startElement ( 'workbookProtection' ) ; $ objWriter -> writeAttribute ( 'lockRevision' , ( $ spreadsheet -> getSecurity ( ) -> getLockRevision ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockStructure' , ( $ spreadsheet -> getSecurity ( ) -> getLockStructure ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockWindows' , ( $ spreadsheet -> getSecurity ( ) -> getLockWindows ( ) ? 'true' : 'false' ) ) ; if ( $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'revisionsPassword' , $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) ) ; } if ( $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'workbookPassword' , $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) ) ; } $ objWriter -> endElement ( ) ; } }
12166	private function createMenutable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu` ( `menu_id` int(11) NOT NULL AUTO_INCREMENT, `menu_parent_id` int(11) NOT NULL DEFAULT '0', `menu_title` varchar(45) NOT NULL, `menu_url` varchar(100) NOT NULL, `menu_classes` varchar(45) DEFAULT NULL, `menu_order` int(11) NOT NULL DEFAULT '0', `menu_group_id` int(11) NOT NULL, `menu_type` varchar(45) NOT NULL DEFAULT 'link', `menu_callback` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, `menu_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=99 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu` (`menu_id`, `menu_parent_id`, `menu_title`, `menu_url`, `menu_classes`, `menu_order`, `menu_group_id`, `menu_type`, `menu_callback`, `lft`, `rgt`, `menu_iscore`) VALUES (85, 0, 'Photos', '/photo/gallery', NULL, 0, 1, 'link', NULL, 3, 12, 1), (86, 0, 'Audio', '/audio/gallery', NULL, 0, 1, 'link', NULL, 4, 11, 1), (87, 0, 'Videos', '/video/gallery', NULL, 0, 1, 'link', NULL, 5, 10, 1), (88, 0, 'Text', '/text/gallery', '', 23, 1, 'link', '', 6, 9, 1), (73, 0, 'Dashboard', '/member/dashboard', '', 0, 2, 'link', NULL, 1, 2, 1), (74, 0, 'Settings', '/member/settings', NULL, 0, 2, 'link', NULL, 3, 4, 1), (75, 0, 'Inbox', '/member/messages', NULL, 0, 3, 'link', NULL, 2, 3, 1), (25, 80, 'Maintenance', '/admin/settings/maintenance', '', 20, 3, 'link', '', 12, 13, 1), (30, 80, 'Emails', '/admin/settings/emails', '', 20, 3, 'link', '', 10, 11, 1), (32, 80, 'Localization', '/admin/settings/localization', '', 20, 3, 'link', '', 8, 9, 1), (33, 80, 'Input', '/admin/settings/input', '', 20, 3, 'link', '', 6, 7, 1), (34, 80, 'Server', '/admin/settings/server', '', 20, 3, 'link', '', 4, 5, 1), (56, 0, 'Dashboard', '/member/dashboard', NULL, 0, 3, 'link', NULL, 1, 2, 1), (78, 80, 'Permissions', '/admin/settings/permissions', '', 20, 3, 'link', '', 14, 15, 1), (80, 0, 'Configuration', '/admin/settings/configuration', '', 20, 3, 'link', '', 3, 16, 1), (98, 0, 'Appearance', '/admin/settings/appearance', NULL, 0, 3, 'link', NULL, 17, 18, 1), (99, 0, 'Pages', '/admin/pages', NULL , 0, 3, 'link', NULL, 3, 4, 1), (101,0, 'Navigation', '/admin/settings/navigation', NULL, 0, 3, 'link', NULL, 17, 18, 1), (102,0, 'Extensions', '/admin/settings/extensions', NULL, 0, 3, 'link', NULL, 17, 18, 1), (103,0, 'Users', '/admin/users', NULL, 0, 3, 'link', NULL, 17, 18, 1);" ) ; }
894	public function getArguments ( Tokens $ tokens , $ openParenthesis , $ closeParenthesis ) { $ arguments = [ ] ; $ firstSensibleToken = $ tokens -> getNextMeaningfulToken ( $ openParenthesis ) ; if ( $ tokens [ $ firstSensibleToken ] -> equals ( ')' ) ) { return $ arguments ; } $ paramContentIndex = $ openParenthesis + 1 ; $ argumentsStart = $ paramContentIndex ; for ( ; $ paramContentIndex < $ closeParenthesis ; ++ $ paramContentIndex ) { $ token = $ tokens [ $ paramContentIndex ] ; $ blockDefinitionProbe = Tokens :: detectBlockType ( $ token ) ; if ( null !== $ blockDefinitionProbe && true === $ blockDefinitionProbe [ 'isStart' ] ) { $ paramContentIndex = $ tokens -> findBlockEnd ( $ blockDefinitionProbe [ 'type' ] , $ paramContentIndex ) ; continue ; } if ( $ token -> equals ( ',' ) ) { if ( $ tokens -> getNextMeaningfulToken ( $ paramContentIndex ) === $ closeParenthesis ) { break ; } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; $ argumentsStart = $ paramContentIndex + 1 ; } } $ arguments [ $ argumentsStart ] = $ paramContentIndex - 1 ; return $ arguments ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
12152	public function setup ( ) { $ results = [ true ] ; if ( ! empty ( $ this -> primaryModel ) && ! empty ( $ this -> collectorItem -> parents ) ) { $ groups = [ 'top' ] ; foreach ( $ groups as $ groupName ) { $ group = Group :: getBySystemName ( $ groupName , false ) ; if ( empty ( $ group ) ) { continue ; } if ( $ this -> inheritParentAccess ) { $ results [ ] = $ this -> objectTypeModel -> parentAccess ( null , $ group ) ; } } } return min ( $ results ) ; }
368	public function renderTableBody ( ) { $ models = array_values ( $ this -> dataProvider -> getModels ( ) ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( $ models as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( $ this -> beforeRow !== null ) { $ row = call_user_func ( $ this -> beforeRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } $ rows [ ] = $ this -> renderTableRow ( $ model , $ key , $ index ) ; if ( $ this -> afterRow !== null ) { $ row = call_user_func ( $ this -> afterRow , $ model , $ key , $ index , $ this ) ; if ( ! empty ( $ row ) ) { $ rows [ ] = $ row ; } } } if ( empty ( $ rows ) && $ this -> emptyText !== false ) { $ colspan = count ( $ this -> columns ) ; return "<tbody>\n<tr><td colspan=\"$colspan\">" . $ this -> renderEmpty ( ) . "</td></tr>\n</tbody>" ; } return "<tbody>\n" . implode ( "\n" , $ rows ) . "\n</tbody>" ; }
1114	protected static function boot ( ) { parent :: boot ( ) ; static :: creating ( function ( $ node ) { $ node -> setDefaultLeftAndRight ( ) ; } ) ; static :: saving ( function ( $ node ) { $ node -> storeNewParent ( ) ; } ) ; static :: saved ( function ( $ node ) { $ node -> moveToNewParent ( ) ; $ node -> setDepth ( ) ; } ) ; static :: deleting ( function ( $ node ) { $ node -> destroyDescendants ( ) ; } ) ; if ( static :: softDeletesEnabled ( ) ) { static :: restoring ( function ( $ node ) { $ node -> shiftSiblingsForRestore ( ) ; } ) ; static :: restored ( function ( $ node ) { $ node -> restoreDescendants ( ) ; } ) ; } }
7930	public function setCollection ( array $ collection ) { list ( $ collection ) = $ this -> fireEvent ( 'collection.set' , [ $ collection ] ) ; $ this -> collection = [ ] ; foreach ( $ collection as $ asset ) { $ this -> appendToCollection ( $ asset ) ; } return $ this ; }
4244	private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; }
12295	public function findBy ( array $ criteria , array $ orderBy = null , $ limit = null , $ offset = null , $ include = null , $ fields = null ) { $ this -> builder = $ this -> model ; if ( count ( $ criteria ) == count ( $ criteria , COUNT_RECURSIVE ) ) { if ( count ( $ criteria ) > 0 ) { $ this -> builder = $ this -> builder -> where ( $ criteria [ 0 ] , $ criteria [ 1 ] , $ criteria [ 2 ] ) ; } } else { foreach ( $ criteria as $ c ) { if ( $ c [ 1 ] == 'between' ) { $ this -> builder = $ this -> builder -> whereBetween ( $ c [ 0 ] , explode ( ',' , $ c [ 2 ] ) ) ; continue ; } $ this -> builder = $ this -> builder -> where ( $ c [ 0 ] , $ c [ 1 ] , $ c [ 2 ] ) ; } } if ( $ orderBy !== null ) { foreach ( $ orderBy as $ order ) { $ this -> builder = $ this -> builder -> orderBy ( $ order [ 0 ] , $ order [ 1 ] ) ; } } if ( $ limit !== null ) { $ this -> builder = $ this -> builder -> take ( ( int ) $ limit ) ; } if ( $ offset !== null ) { $ this -> builder = $ this -> builder -> skip ( ( int ) $ offset ) ; } if ( $ include !== null ) { $ this -> builder = $ this -> builder -> with ( $ include ) ; } if ( $ fields !== null ) { $ this -> builder = $ this -> builder -> select ( $ fields ) ; } return $ this -> builder -> get ( ) ; }
12448	static function run_update_ezinfo ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( 'ezinfo.php' ) -> maxdepth ( 0 ) ; pake_replace_regexp ( $ files , $ destdir , array ( '/^([\s]{1,25}\x27Version\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '/^([\s]{1,25}\x27License\x27[\s]+=>[\s]+[\x27\x22])(.*)([\x27\x22],?\r?\n?)/m' => '${1}' . $ opts [ 'version' ] [ 'license' ] . '$3' ) , 1 ) ; $ files = pakeFinder :: type ( 'file' ) -> maxdepth ( 0 ) -> name ( 'extension.xml' ) ; pake_replace_regexp ( $ files , $ destdir , array ( '#^([\s]{1,8}<version>)([^<]*)(</version>\r?\n?)#m' => '${1}' . $ opts [ 'version' ] [ 'alias' ] . $ opts [ 'releasenr' ] [ 'separator' ] . $ opts [ 'version' ] [ 'release' ] . '$3' , '#^([\s]{1,8}<license>)([^<]*)(</license>\r?\n?)#m' => '${1}' . htmlspecialchars ( $ opts [ 'version' ] [ 'license' ] ) . '$3' , '#^([\s]{1,8}<copyright>)Copyright \(C\) 1999-[\d]{4} eZ Systems AS(</copyright>\r?\n?)#m' => '${1}' . 'Copyright (C) 1999-' . strftime ( '%Y' ) . ' eZ Systems AS' . '$2' ) , 1 ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_EX , $ opts ) ; }
3052	public function getItemIndexValue ( $ id , $ name ) { return $ this -> itemIndex -> getItemValue ( $ id , \ common_session_SessionManager :: getSession ( ) -> getInterfaceLanguage ( ) , $ name ) ; }
1591	protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; }
11410	public function update ( $ tagId , $ name ) { $ params = [ 'tag' => [ 'id' => $ tagId , 'name' => $ name , ] , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
10235	private function getImageMimeType ( $ pFile ) { if ( File :: fileExists ( $ pFile ) ) { $ image = getimagesize ( $ pFile ) ; return image_type_to_mime_type ( $ image [ 2 ] ) ; } throw new WriterException ( "File $pFile does not exist" ) ; }
1253	private function newPhpObject ( \ stdClass $ meta ) { $ phpTypes = explode ( '|' , $ meta -> phpType ) ; foreach ( $ phpTypes as $ phpType ) { switch ( $ phpType ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'DateTime' : continue ; default : return $ meta -> phpType !== '' ? new $ phpType ( ) : null ; } } return null ; }
1818	public function setSingleSrcFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord ) { switch ( $ dc -> activeRecord -> type ) { case 'text' : case 'hyperlink' : case 'image' : case 'accordionSingle' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'validImageTypes' ) ; break ; case 'download' : $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'extensions' ] = Contao \ Config :: get ( 'allowedDownload' ) ; break ; } } return $ varValue ; }
5581	public function getLink ( $ label , $ index = 0 ) { $ urls = $ this -> page -> getUrlsByLabel ( $ label ) ; if ( count ( $ urls ) == 0 ) { return false ; } if ( count ( $ urls ) < $ index + 1 ) { return false ; } return $ urls [ $ index ] ; }
9558	public function getUsage ( $ showRequiredFirst = true , $ customBinary = null , $ customScript = null ) { $ fullUsage = '' ; if ( $ customBinary == null ) { $ fullUsage = 'php ' ; } else { $ fullUsage = $ customBinary . ' ' ; } if ( $ customScript == null ) { $ fullUsage .= basename ( $ _SERVER [ 'SCRIPT_NAME' ] ) . ' ' ; } else { $ fullUsage .= $ customScript . ' ' ; } foreach ( $ this -> prefixes as $ prefix => $ parameters ) { if ( $ showRequiredFirst ) { usort ( $ parameters , function ( $ p1 , $ p2 ) { if ( $ p1 -> required && $ p2 -> required ) { return 0 ; } if ( $ p1 -> required && ! $ p2 -> required ) { return - 1 ; } if ( $ p2 -> required && ! $ p1 -> required ) { return 1 ; } } ) ; } foreach ( $ parameters as $ parameter ) { if ( $ parameter -> parent == null ) { $ fullUsage .= $ parameter -> getUsage ( ) . ' ' ; } } } return $ fullUsage ; }
501	protected function getHeaderCheckBoxName ( ) { $ name = $ this -> name ; if ( substr_compare ( $ name , '[]' , - 2 , 2 ) === 0 ) { $ name = substr ( $ name , 0 , - 2 ) ; } if ( substr_compare ( $ name , ']' , - 1 , 1 ) === 0 ) { $ name = substr ( $ name , 0 , - 1 ) . '_all]' ; } else { $ name .= '_all' ; } return $ name ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
4984	public function setParams ( array $ params ) { $ this -> params = array_merge ( $ this -> params , $ params ) ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParams' ) ) { $ form [ '__instance__' ] -> setParams ( $ params ) ; } } return $ this ; }
2295	public static function getTinyTemplates ( ) { $ strDir = Config :: get ( 'uploadPath' ) . '/tiny_templates' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strDir ) ) { return '' ; } $ arrFiles = array ( ) ; $ arrTemplates = scan ( $ rootDir . '/' . $ strDir ) ; foreach ( $ arrTemplates as $ strFile ) { if ( strncmp ( '.' , $ strFile , 1 ) !== 0 && is_file ( $ rootDir . '/' . $ strDir . '/' . $ strFile ) ) { $ arrFiles [ ] = '{ title: "' . $ strFile . '", url: "' . $ strDir . '/' . $ strFile . '" }' ; } } return implode ( ",\n" , $ arrFiles ) . "\n" ; }
12945	public function getTagValues ( $ asString = false ) { if ( $ this -> _tagsList === null && ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> _tagsList = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsList = array_unique ( $ relation -> select ( 'text' ) -> column ( ) ) ; } } return $ asString === true ? implode ( ',' , $ this -> _tagsList ) : $ this -> _tagsList ; }
7313	public function setDate ( $ year , $ month , $ day ) { $ status = IAU :: Cal2jd ( ( int ) $ year , ( int ) $ month , ( int ) $ day , $ djm0 , $ djm ) ; $ this -> checkDate ( $ status ) ; $ this -> jd = $ djm0 + $ djm ; return $ this ; }
9330	static function filter ( $ width , $ height ) { return array ( new ezcImageFilter ( 'scale' , array ( 'width' => intval ( $ width ) , 'height' => intval ( $ height ) , 'direction' => ezcImageGeometryFilters :: SCALE_BOTH ) ) ) ; }
12764	public function add ( string $ header ) : self { foreach ( $ this -> getAll ( ) as $ tmp ) { if ( $ tmp === $ header ) { throw new Exception ( "The '{$header}' header has already been added." ) ; } } $ this -> headerList [ ] = $ header ; return self :: $ instance ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
1813	public function setRteSyntax ( $ varValue , Contao \ DataContainer $ dc ) { switch ( $ dc -> activeRecord -> highlight ) { case 'C' : case 'CSharp' : $ syntax = 'c_cpp' ; break ; case 'CSS' : case 'Diff' : case 'Groovy' : case 'HTML' : case 'Java' : case 'JavaScript' : case 'Perl' : case 'PHP' : case 'PowerShell' : case 'Python' : case 'Ruby' : case 'Scala' : case 'SQL' : case 'Text' : case 'YAML' : $ syntax = strtolower ( $ dc -> activeRecord -> highlight ) ; break ; case 'VB' : $ syntax = 'vbscript' ; break ; case 'XML' : case 'XHTML' : $ syntax = 'xml' ; break ; default : $ syntax = 'text' ; break ; } if ( $ dc -> activeRecord -> type == 'markdown' ) { $ syntax = 'markdown' ; } $ GLOBALS [ 'TL_DCA' ] [ 'tl_content' ] [ 'fields' ] [ 'code' ] [ 'eval' ] [ 'rte' ] = 'ace|' . $ syntax ; return $ varValue ; }
7816	public function event ( string $ event ) : self { $ events = [ 'MESSAGE_RECEIVED' , 'MESSAGE_SENT' , 'MESSAGE_FAILED' , ] ; if ( ! in_array ( $ event , $ events ) ) { abort ( 500 , sprintf ( 'Event %s not available.' , $ event ) ) ; } $ this -> event = $ event ; return $ this ; }
2699	private function upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) { foreach ( $ oldConfigPaths as $ key => $ value ) { $ oldValue = $ this -> scopeConfig -> getValue ( $ value ) ; if ( $ oldValue != null ) { $ this -> configWriter -> save ( $ newConfigPaths [ $ key ] , $ oldValue ) ; } } }
12835	private function generateFactoryCreatorMethod ( FactoredService $ service ) : string { $ factoryMethod = $ service -> getFactoryMethod ( ) ; $ taggedAs = implode ( ', ' , $ service -> getTags ( ) ) ; $ classNormalized = $ this -> normalizeFqcn ( $ service -> getClass ( ) ) ; $ optional = $ service -> getFactoryMethod ( ) -> isOptional ( ) ? '?' : '' ; if ( $ service -> isSingleton ( ) ) { return <<<PHP /** * Get the factored service "{$service->getId()}" (Singleton) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : {$optional}{$classNormalized} { if (isset(\$this->singletons['{$service->getId()}'])) { return \$this->singletons['{$service->getId()}']; } /** @noinspection OneTimeUseVariablesInspection */ \$service = \$this->singletons['{$service->getId()}'] = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; } return <<<PHP /** * Get a fresh instance of service "{$service->getId()}" (Prototype) * * It is tagged as: {$taggedAs} * * @return {$this->normalizeFqcn($service->getClass())} */ public function {$this->mapIdToServiceGetter($service->getId())} () : $classNormalized { \$this->prototypes['{$service->getId()}'] = (\$this->prototypes['{$service->getId()}'] ?? 0) + 1; /** @noinspection OneTimeUseVariablesInspection */ \$service = {$this->generateCreatorByServiceId($factoryMethod->getFactoryId())}->{$factoryMethod->getMethodName()}({$this->buildInjectionParameters($this->container, $factoryMethod->getInjection())} );{$this->generateSetterInjectionsCode($service)} return \$service; }PHP ; }
8477	public function run ( $ id ) { $ model = $ this -> controller -> findModel ( $ id ) ; if ( $ model -> is_system ) { \ Yii :: $ app -> session -> setFlash ( 'warning' , \ Yii :: t ( 'app' , 'You cannot update or delete system handlers' ) ) ; } else { $ model -> delete ( ) ; } return $ this -> controller -> redirect ( [ 'index' ] ) ; }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
8569	public function setSKUPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SKUPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9201	private function createBearerCredentials ( ) { $ consumerKey = rawurlencode ( $ this -> credentials -> getConsumerKey ( ) ) ; $ consumerSecret = rawurlencode ( $ this -> credentials -> getConsumerSecret ( ) ) ; $ bearerTokenCredentials = $ consumerKey . ':' . $ consumerSecret ; return base64_encode ( $ bearerTokenCredentials ) ; }
374	public function getPassedOptionValues ( ) { $ properties = [ ] ; foreach ( $ this -> _passedOptions as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
11387	private function hydrate ( ) { if ( true === $ this -> hydrated ) { return ; } $ this -> filesystem -> get ( $ this -> file ) ; $ this -> hydrated = true ; }
8202	protected function registerCommand ( $ command ) { $ abstract = "command.artisan.beans.$command" ; $ commandClass = "\\Pvm\\ArtisanBeans\\Console\\{$command}Command" ; $ this -> app -> singleton ( $ abstract , function ( $ app ) use ( $ commandClass ) { return new $ commandClass ( ) ; } ) ; $ this -> commands ( $ abstract ) ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
10062	public function update ( $ key , $ value ) { try { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> firstOrFail ( ) ; } catch ( \ Exception $ e ) { $ message = "Can't update meta (key: $key). " ; $ message .= "Meta doesn't exist" ; throw new \ Exception ( $ message ) ; } $ meta -> value = $ value ; $ meta -> save ( ) ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
5666	private function attachLabels ( $ widgets_by_id , $ labels ) { foreach ( $ labels as $ label ) { $ for = $ label -> getFor ( ) ; if ( $ for and isset ( $ widgets_by_id [ $ for ] ) ) { $ text = $ label -> getText ( ) ; foreach ( $ widgets_by_id [ $ for ] as $ widget ) { $ widget -> setLabel ( $ text ) ; } } } }
5827	public function buildUrl ( $ url , array $ query ) { if ( ! empty ( $ query ) ) { $ queryString = http_build_query ( $ query ) ; $ url .= '?' . $ queryString ; } return $ url ; }
12615	public function addAttribute ( AttributeInterface $ attribute ) { if ( isset ( $ this -> attributes [ $ attribute -> getName ( ) ] ) ) trigger_error ( "Attribute " . $ attribute -> getName ( ) . " already exists" , E_USER_NOTICE ) ; $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; }
24	public function copy ( $ originUrl , $ fileUrl , $ fileName , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , $ fileName , $ progress ) ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
745	public function unsigned ( ) { switch ( $ this -> type ) { case Schema :: TYPE_PK : $ this -> type = Schema :: TYPE_UPK ; break ; case Schema :: TYPE_BIGPK : $ this -> type = Schema :: TYPE_UBIGPK ; break ; } $ this -> isUnsigned = true ; return $ this ; }
2436	public function getData ( ) { $ data = $ this -> sessionBag -> all ( ) ; foreach ( $ this -> mappedKeys as $ strKey ) { unset ( $ data [ $ strKey ] ) ; if ( $ this -> session -> has ( $ strKey ) ) { $ data [ $ strKey ] = $ this -> session -> get ( $ strKey ) ; } } return $ data ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
11788	private function updateTv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ tv = $ one -> getTv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setTv ( $ tv ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
10434	protected function prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) { return array_merge ( $ serviceConfig , $ typeConfig [ 'config' ] , [ 'entity_class' => $ typeConfig [ 'entity_class' ] , 'document_class' => $ typeConfig [ 'document_class' ] , 'document_type' => $ type , ] ) ; }
6423	public function isConfigured ( ) { if ( empty ( $ this -> options [ 'application_name' ] ) || empty ( $ this -> options [ 'client_id' ] ) || empty ( $ this -> options [ 'client_secret' ] ) ) { return false ; } return true ; }
5907	public function retrieveSetting ( $ key , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings/' . $ key . '' , $ parameters , $ cachePolicy ) ; return $ result ; }
1070	private function collectConflictsBetweenFragments ( ValidationContext $ context , array & $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentName2 ) { if ( $ fragmentName1 === $ fragmentName2 ) { return ; } if ( $ this -> comparedFragmentPairs -> has ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ) { return ; } $ this -> comparedFragmentPairs -> add ( $ fragmentName1 , $ fragmentName2 , $ areMutuallyExclusive ) ; $ fragment1 = $ context -> getFragment ( $ fragmentName1 ) ; $ fragment2 = $ context -> getFragment ( $ fragmentName2 ) ; if ( ! $ fragment1 || ! $ fragment2 ) { return ; } [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentName1 , $ fragmentNames2 [ $ j ] ) ; } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentName2 ) ; } }
4194	private function magicMethodInfo ( $ methods ) { if ( ! $ methods ) { return '' ; } foreach ( $ methods as $ i => $ method ) { $ methods [ $ i ] = '<code>' . $ method . '</code>' ; } $ methods = $ i == 0 ? 'a ' . $ methods [ 0 ] . ' method' : \ implode ( ' and ' , $ methods ) . ' methods' ; return '<dd class="magic info">This object has ' . $ methods . '</dd>' . "\n" ; }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
11233	public function run ( $ argument , Message $ message , ApiClient $ apiClient ) { $ this -> setApiClient ( $ apiClient ) ; $ this -> execute ( $ argument , $ message ) ; }
10254	public function getStreet ( ) { $ number = rand ( 100 , 9999 ) ; $ street_name = Street :: orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; return $ number . ' ' . $ street_name ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
6373	public function filterBy ( string $ className ) : FluentIterable { return self :: from ( Iterables :: filterBy ( $ this , $ className ) ) ; }
2150	public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='1' WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ objUser -> email ) ; } }
1353	protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
11514	public function getNamedParams ( string $ category = null ) : array { switch ( $ category ) { case 'attribute' : return $ this -> request -> getAttributes ( ) ; case 'query' : return $ this -> request -> getQueryParams ( ) ; case 'uploaded_files' : return $ this -> request -> getUploadedFiles ( ) ; case 'parsed_body' : { $ body = $ this -> request -> getParsedBody ( ) ; if ( ! $ body ) { return [ ] ; } if ( is_array ( $ body ) ) { return $ body ; } if ( is_object ( $ body ) ) { return get_object_vars ( $ body ) ; } } return [ ] ; case 'server' : return $ this -> request -> getServerParams ( ) ; case 'cookie' : return $ this -> request -> getCookieParams ( ) ; } return [ ] ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
8728	public function changeFolder ( HTTPRequest $ request ) { $ token = $ this -> getForm ( ) -> getSecurityToken ( ) ; if ( ! $ token -> checkRequest ( $ request ) ) { return $ this -> httpError ( 400 ) ; } $ folderID = $ request -> postVar ( 'FolderID' ) ; if ( $ folderID ) { $ this -> FolderSelector ( ) -> setLastFolderID ( $ folderID ) ; } }
603	protected function startsWithAnyLongest ( array & $ with , $ caseSensitive , & $ length = null , & $ content = null ) { if ( empty ( $ with ) ) { return false ; } if ( ! is_array ( reset ( $ with ) ) ) { usort ( $ with , function ( $ string1 , $ string2 ) { return mb_strlen ( $ string2 , 'UTF-8' ) - mb_strlen ( $ string1 , 'UTF-8' ) ; } ) ; $ map = [ ] ; foreach ( $ with as $ string ) { $ map [ mb_strlen ( $ string , 'UTF-8' ) ] [ $ caseSensitive ? $ string : mb_strtoupper ( $ string , 'UTF-8' ) ] = true ; } $ with = $ map ; } foreach ( $ with as $ testLength => $ testValues ) { $ content = $ this -> substring ( $ testLength , $ caseSensitive ) ; if ( isset ( $ testValues [ $ content ] ) ) { $ length = $ testLength ; return true ; } } return false ; }
12383	public static function perMonth ( $ months = 1 , $ date_format = "Y-m" ) { $ hits_per_month = [ ] ; for ( $ i = 1 ; $ i <= $ months ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subMonths ( $ i ) -> firstOfMonth ( ) , Carbon :: now ( ) -> subMonths ( $ i ) -> lastOfMonth ( ) ) ; $ hits_per_month [ Carbon :: now ( ) -> subMonths ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_month ; }
2494	protected function escapeExpressions ( $ string , $ allowWildcard = false ) { if ( $ allowWildcard ) { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~?:\\ ' ) ; } else { $ reservedCharacters = preg_quote ( '+-&|!(){}[]^"~*?:\\ ' ) ; } return preg_replace_callback ( '/([' . $ reservedCharacters . '])/' , function ( $ matches ) { return '\\' . $ matches [ 0 ] ; } , $ string ) ; }
1569	public function getResourceIdentifier ( ) : ? ResourceIdentifierInterface { if ( ! $ resourceId = $ this -> getResourceId ( ) ) { return null ; } return ResourceIdentifier :: create ( $ this -> getResourceType ( ) , $ resourceId ) ; }
7004	public function format ( $ format ) { $ this -> format = $ format ; $ format = preg_replace ( '/([a-zA-Z])/' , '%$1' , $ format ) ; $ format = preg_replace ( '/\\\\%(.)/' , '\\\\$1' , $ format ) ; $ this -> format_d ( $ format ) ; $ this -> formatD ( $ format ) ; $ this -> format_j ( $ format ) ; $ this -> format_l ( $ format ) ; $ this -> formatL ( $ format ) ; $ this -> formatN ( $ format ) ; $ this -> formatS ( $ format ) ; $ this -> format_w ( $ format ) ; $ this -> format_z ( $ format ) ; $ this -> formatW ( $ format ) ; $ this -> formatF ( $ format ) ; $ this -> format_m ( $ format ) ; $ this -> formatM ( $ format ) ; $ this -> format_n ( $ format ) ; $ this -> format_t ( $ format ) ; $ this -> formatY ( $ format ) ; $ this -> format_y ( $ format ) ; $ this -> format_a ( $ format ) ; $ this -> formatA ( $ format ) ; $ this -> format_g ( $ format ) ; $ this -> formatG ( $ format ) ; $ this -> format_h ( $ format ) ; $ this -> formatH ( $ format ) ; $ this -> format_i ( $ format ) ; $ this -> format_s ( $ format ) ; $ this -> format_u ( $ format ) ; $ this -> format_e ( $ format ) ; $ this -> formatO ( $ format ) ; $ this -> formatP ( $ format ) ; $ this -> formatZ ( $ format ) ; $ this -> format_r ( $ format ) ; $ this -> format_c ( $ format ) ; $ this -> formatC ( $ format ) ; return str_replace ( '\\' , '' , $ format ) ; }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
8560	public function setProduct ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Product' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5813	public function getCMSFields ( ) { $ fields = parent :: getCMSFields ( ) ; $ types = array ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } if ( count ( $ types ) ) { $ fields -> replaceField ( 'TagTypes' , $ list = ListboxField :: create ( 'Types' , 'Tag Types' , $ types ) -> setMultiple ( true ) ) ; $ items = is_string ( $ this -> TagTypes ) ? array_keys ( unserialize ( $ this -> TagTypes ) ) : array ( ) ; $ list -> setValue ( $ items ) ; $ list -> setDisabledItems ( $ items ) ; } else { $ fields -> removeByName ( 'TagTypes' ) ; } $ this -> extend ( 'updateFusionTagCMSFields' , $ fields ) ; return $ fields ; }
9484	public function fromArray ( array $ array ) { foreach ( $ array as $ k => $ v ) { if ( ! is_null ( $ v ) && property_exists ( get_class ( $ this ) , $ k ) ) { $ meta = new \ ReflectionProperty ( get_class ( $ this ) , $ k ) ; $ info = $ this -> parsePropertyDocComment ( $ meta -> getDocComment ( ) ) ; $ type = $ info [ 'type' ] ; if ( strtolower ( $ type ) == "array" && $ elementType = $ info [ 'array_element' ] ) { if ( class_exists ( $ elementType ) ) { $ children = array ( ) ; foreach ( $ v as $ subV ) { $ newElement = new $ elementType ( ) ; $ children [ ] = $ newElement -> fromArray ( $ subV ) ; } $ this -> $ k = $ children ; } else { throw new \ Exception ( '@element Class Not Found:' . $ elementType ) ; } } else if ( class_exists ( $ type ) ) { $ typeObject = new $ type ( ) ; $ this -> $ k = $ typeObject -> fromArray ( $ v ) ; } else { $ this -> $ k = $ v ; } } } return $ this ; }
12632	public function query ( $ orderNo , $ type = self :: OUT_TRADE_NO ) { $ params = [ $ type => $ orderNo , ] ; return $ this -> request ( $ this -> wrapApi ( self :: API_QUERY ) , $ params ) ; }
9231	public function actionIndex ( $ format = false , $ arraymap = false , $ term = false , $ category = false , $ time = false ) { $ searchModel = new PostSearch ( ) ; $ req = Yii :: $ app -> request -> queryParams ; if ( $ term ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "term" ] = $ term ; } if ( $ category ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "category" ] = $ category ; } if ( $ time ) { $ req [ basename ( str_replace ( "\\" , "/" , get_class ( $ searchModel ) ) ) ] [ "time" ] = $ time ; } $ dataProvider = $ searchModel -> search ( $ req ) ; $ query = $ dataProvider -> query ; $ query -> andWhere ( [ 'status' => [ 1 ] ] ) ; if ( $ format == 'json' ) { $ model = [ ] ; foreach ( $ dataProvider -> getModels ( ) as $ d ) { $ obj = $ d -> attributes ; if ( $ arraymap ) { $ map = explode ( "," , $ arraymap ) ; if ( count ( $ map ) == 1 ) { $ obj = ( isset ( $ d [ $ arraymap ] ) ? $ d [ $ arraymap ] : null ) ; } else { $ obj = [ ] ; foreach ( $ map as $ a ) { $ k = explode ( ":" , $ a ) ; $ v = ( count ( $ k ) > 1 ? $ k [ 1 ] : $ k [ 0 ] ) ; $ obj [ $ k [ 0 ] ] = ( $ v == "Obj" ? json_encode ( $ d -> attributes ) : ( isset ( $ d -> $ v ) ? $ d -> $ v : null ) ) ; } } } if ( $ term ) { if ( ! in_array ( $ obj , $ model ) ) { array_push ( $ model , $ obj ) ; } } else { array_push ( $ model , $ obj ) ; } } header ( "Access-Control-Allow-Origin: *" ) ; header ( "Access-Control-Expose-Headers: X-Pagination-Per-Page,X-Pagination-Current-Page,X-Pagination-Page-Count,X-Pagination-Total-Count,Content-Type,Location" ) ; return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , ] ) ; } }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
12567	public function sendCard ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_CARD , $ message , $ to ) ; }
818	private function fixNewline ( Tokens $ tokens , $ index , $ indentation , $ override = true ) { if ( $ tokens [ $ index + 1 ] -> isComment ( ) ) { return ; } if ( $ tokens [ $ index + 2 ] -> isComment ( ) ) { $ nextMeaningfulTokenIndex = $ tokens -> getNextMeaningfulToken ( $ index + 2 ) ; if ( ! $ this -> isNewline ( $ tokens [ $ nextMeaningfulTokenIndex - 1 ] ) ) { $ tokens -> ensureWhitespaceAtIndex ( $ nextMeaningfulTokenIndex , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; } return ; } $ tokens -> ensureWhitespaceAtIndex ( $ index + 1 , 0 , $ this -> whitespacesConfig -> getLineEnding ( ) . $ indentation ) ; }
7146	public function save_custom_profile_fields ( $ user_id ) { if ( 'POST' !== $ _SERVER [ 'REQUEST_METHOD' ] || ! isset ( $ _POST [ 'iac_nonce' ] ) ) { return ; } if ( ! wp_verify_nonce ( $ _POST [ 'iac_nonce' ] , 'iac_user_settings' ) ) { return ; } do_action ( 'iac_save_user_settings' , $ user_id , isset ( $ _POST [ 'post_subscription' ] ) ? $ _POST [ 'post_subscription' ] : NULL , isset ( $ _POST [ 'comment_subscription' ] ) ? $ _POST [ 'comment_subscription' ] : NULL ) ; }
4935	private function triggerEvent ( $ name , EntityInterface $ entity ) { $ params = $ this -> options ; $ params [ 'entity' ] = $ entity ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> entityEraserEvents -> getEvent ( $ name , $ this , $ params ) ; $ this -> entityEraserEvents -> triggerEvent ( $ event ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; return $ dependencies ; }
5125	public function serve ( ) { foreach ( $ this -> dispatchers as $ dispatcher ) { if ( $ dispatcher -> canServe ( ) ) { ContainerScope :: runScope ( $ this -> container , [ $ dispatcher , 'serve' ] ) ; return ; } } throw new BootException ( "Unable to locate active dispatcher." ) ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
10031	function synchronizeContacts ( $ contacts , $ permission = null , $ syncMode = null , $ useExternalId = false , $ ignoreInvalidContacts = false , $ reimportUnsubscribedContacts = true , $ overridePermission = true , $ updateOnly = false , $ preferMaileonId = false ) { $ queryParameters = array ( 'permission' => ( $ permission == null ) ? 1 : $ permission -> getCode ( ) , 'sync_mode' => ( $ syncMode == null ) ? 2 : $ syncMode -> getCode ( ) , 'use_external_id' => ( $ useExternalId == TRUE ) ? "true" : "false" , 'ignore_invalid_contacts' => ( $ ignoreInvalidContacts == TRUE ) ? "true" : "false" , 'reimport_unsubscribed_contacts' => ( $ reimportUnsubscribedContacts == TRUE ) ? "true" : "false" , 'override_permission' => ( $ overridePermission == TRUE ) ? "true" : "false" , 'update_only' => ( $ updateOnly == TRUE ) ? "true" : "false" , 'prefer_maileon_id' => ( $ preferMaileonId == TRUE ) ? "true" : "false" ) ; $ cleanedContacts = new Contacts ( ) ; foreach ( $ contacts as $ contact ) { $ cleanedContact = new Contact ( $ contact -> id , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; $ cleanedContacts -> addContact ( $ cleanedContact ) ; } return $ this -> post ( "contacts" , $ cleanedContacts -> toXMLString ( ) , $ queryParameters ) ; }
9534	private function parseQuote ( & $ argv , $ argument , $ quoteType ) { if ( substr ( $ argument , strlen ( $ argument ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ ] = substr ( $ argument , 1 ) ; while ( ( $ argument_part = array_shift ( $ argv ) ) != null && substr ( $ argument_part , strlen ( $ argument_part ) - 1 , 1 ) !== $ quoteType ) { $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . $ argument_part ; } $ this -> argv [ count ( $ this -> argv ) - 1 ] .= ' ' . substr ( $ argument_part , 0 , strlen ( $ argument_part ) - 1 ) ; } else { $ this -> argv [ ] = substr ( substr ( $ argument , 1 ) , 0 , strlen ( $ argument ) - 2 ) ; } }
2920	public function deleteSetter ( $ key ) { $ pattern = "/^(export\h)?\h*{$key}=.*\n/m" ; $ this -> buffer = preg_replace ( $ pattern , null , $ this -> buffer ) ; return $ this ; }
1316	public function post ( $ path , array $ parameters = [ ] , $ json = false ) { return $ this -> http ( 'POST' , self :: API_HOST , $ path , $ parameters , $ json ) ; }
9168	public static function parseUrl ( $ url ) : Endpoint { $ url = UrlParser :: parseUrl ( $ url ) ; return new Endpoint ( $ url -> getAddress ( ) , $ url -> getPort ( ) ) ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
9780	private function getLength ( $ value ) : int { if ( is_array ( $ value ) || $ value instanceof \ Countable ) return count ( $ value ) ; if ( $ value instanceof \ Traversable ) return iterator_count ( $ value ) ; if ( is_string ( $ value ) ) return mb_strlen ( $ value ) ; throw new \ InvalidArgumentException ( "The specified value is not iterable: $value" ) ; }
7333	private function getStockUnitMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> stockUnitMapper ) { $ this -> stockUnitMapper = new DiscriminatorMapper ( $ em , AbstractStockUnit :: class ) ; } return $ this -> stockUnitMapper ; }
1523	protected function doSearch ( StoreInterface $ store , FetchResources $ request ) { if ( $ result = $ this -> invoke ( 'searching' , $ request ) ) { return $ result ; } $ found = $ store -> queryRecords ( $ request -> getResourceType ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ found instanceof PageInterface ) ? $ found -> getData ( ) : $ found ; if ( $ result = $ this -> invoke ( 'searched' , $ records , $ request ) ) { return $ result ; } return $ found ; }
4610	public function geo ( $ sLat , $ sLon , $ iHeight ) { $ this -> sData .= 'GEO:' . $ sLat . ',' . $ sLon . ',' . $ iHeight . "\n" ; return $ this ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6999	public function getCssClassesForContainer ( ) { $ colsXl = $ this -> getWidth ( ) >= 100 ? 12 : ceil ( 12 * ( $ this -> getWidth ( ) / 100 ) ) ; $ colsXlLeft = floor ( ( 12 - $ colsXl ) / 2 ) ; $ colsLg = $ colsXl >= 10 ? 12 : $ colsXl + 2 ; $ colsLgLeft = floor ( ( 12 - $ colsLg ) / 2 ) ; return "col-xs-12 col-xl-{$colsXl} col-lg-{$colsLg} col-xl-offset-{$colsXlLeft} col-lg-offset-{$colsLgLeft}" ; }
7331	private function configureStockSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Stock \ StockSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> stockClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getStockSubjectMappings ( ) ) ; $ this -> stockClassCache [ ] = $ class ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
11136	protected function calculateINSERT ( ) { $ this -> query .= 'INSERT INTO ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; if ( ! empty ( $ this -> inserts ) ) { $ this -> query .= ' (' ; $ this -> queryStringFromArray ( 'inserts' , '' , ', ' ) ; $ this -> query .= ')' ; } $ this -> valueStringFromArray ( 'values' , ' VALUES ' , ', ' ) ; }
12363	public function initialize ( ) { parent :: initialize ( ) ; $ this -> addClauses ( [ self :: DEFERRABLE => 'DEFERRABLE %s' , self :: EITHER => 'OR %s' , self :: MATCH => 'MATCH %s' , self :: NOT_DEFERRABLE => 'NOT DEFERRABLE %s' , self :: UNIQUE_KEY => 'UNIQUE (%2$s)' ] ) ; $ this -> addKeywords ( [ self :: ABORT => 'ABORT' , self :: BINARY => 'BINARY' , self :: AUTO_INCREMENT => 'AUTOINCREMENT' , self :: FAIL => 'FAIL' , self :: IGNORE => 'IGNORE' , self :: INIT_DEFERRED => 'INITIALLY DEFERRED' , self :: INIT_IMMEDIATE => 'INITIALLY IMMEDIATE' , self :: NOCASE => 'NOCASE' , self :: PRIMARY_KEY => 'PRIMARY KEY' , self :: REPLACE => 'REPLACE' , self :: ROLLBACK => 'ROLLBACK' , self :: RTRIM => 'RTRIM' , self :: UNIQUE => 'UNIQUE' ] ) ; $ this -> addStatements ( [ Query :: INSERT => new Statement ( 'INSERT {or} INTO {table} {fields} VALUES {values}' ) , Query :: SELECT => new Statement ( 'SELECT {distinct} {fields} FROM {table} {joins} {where} {groupBy} {having} {compounds} {orderBy} {limit}' ) , Query :: UPDATE => new Statement ( 'UPDATE {or} {table} SET {fields} {where}' ) , Query :: DELETE => new Statement ( 'DELETE FROM {table} {where}' ) , Query :: CREATE_TABLE => new Statement ( "CREATE {temporary} TABLE IF NOT EXISTS {table} (\n{columns}{keys}\n)" ) , Query :: CREATE_INDEX => new Statement ( 'CREATE {type} INDEX IF NOT EXISTS {index} ON {table} ({fields})' ) , Query :: DROP_TABLE => new Statement ( 'DROP TABLE IF EXISTS {table}' ) , Query :: DROP_INDEX => new Statement ( 'DROP INDEX IF EXISTS {index}' ) ] ) ; unset ( $ this -> _statements [ Query :: TRUNCATE ] ) ; }
1927	public function isSemitransparent ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return false ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ alpha = ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ; if ( $ alpha > 0 && $ alpha < 127 ) { return true ; } } } return false ; }
8587	public function setLowestOfferListing ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'LowestOfferListing' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12830	public function compileSource ( $ source ) { $ source = $ this -> stripComments ( $ source ) ; $ source = $ this -> saveLiterals ( $ source ) ; $ result = preg_replace_callback ( '#' . $ this -> _config [ 'tokenStart' ] . '(.*)' . $ this -> _config [ 'tokenEnd' ] . '#smU' , array ( $ this , 'onTokenFound' ) , $ source ) ; $ result = $ this -> restoreLiterals ( $ result ) ; return $ result ; }
6419	public function start ( ) : Stopwatch { Preconditions :: checkState ( ! $ this -> isRunning , 'This stopwatch is already running.' ) ; $ this -> isRunning = true ; $ this -> startTick = $ this -> ticker -> read ( ) ; return $ this ; }
7413	public function getResponse ( string & $ packageRoot , Request & $ request ) : Response { $ packageRoot = rtrim ( $ packageRoot , '/' ) ; $ route = preg_replace ( '/\/\d+/u' , '/D' , $ request -> route ( ) ) ; $ path = $ packageRoot . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ controllerClass = $ request -> package ( ) . '\\Route_' . str_replace ( '/' , '_' , $ route ) . '\\' . $ request -> method ( ) ; if ( class_exists ( $ controllerClass ) ) { $ controller = new $ controllerClass ( $ packageRoot , $ request ) ; } else { throw new RouteException ( sprintf ( 'Route: the class "%s" does not exist' , $ controllerClass ) ) ; } $ handler = filter_input_array ( INPUT_POST ) [ 'handler' ] ?? filter_input_array ( INPUT_GET ) [ 'handler' ] ?? 'index' ; if ( method_exists ( $ controllerClass , $ handler ) ) { $ controller -> invoke ( $ handler ) ; return $ controller -> getResponse ( ) ; } else { throw new RouteException ( sprintf ( 'Route: the method "%s" does not exist' , $ handler ) ) ; } } else { throw new RouteException ( sprintf ( 'Route: path "%s" does not exist' , $ request -> package ( ) . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ) ) ; } }
12706	public static function getAllCommands ( ) : array { $ commands = [ ] ; foreach ( get_declared_classes ( ) as $ class ) { if ( is_subclass_of ( $ class , 'Senhung\CLI\Command' ) ) { $ commandObject = new $ class ; $ command = $ commandObject -> getCommand ( ) ; $ commands [ $ command ] = $ class ; } } return $ commands ; }
10836	private function compileUsing ( array $ join ) { $ sql = array ( ) ; list ( $ using , $ table , $ type , $ column ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "USING({$column})" ) ; return join ( ' ' , $ sql ) ; }
4489	public function registerDevice ( string $ deviceId , string $ platform , ? string $ userData = null ) : string { if ( ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } try { $ args = [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , 'Token' => $ deviceId , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ; if ( $ userData ) { $ args [ 'CustomUserData' ] = $ userData ; } $ res = $ this -> sns -> createPlatformEndpoint ( $ args ) ; } catch ( SnsException $ e ) { preg_match ( '/Endpoint (.+?) already/' , $ e -> getMessage ( ) , $ matches ) ; if ( isset ( $ matches [ 1 ] ) ) { $ this -> sns -> setEndpointAttributes ( [ 'EndpointArn' => $ matches [ 1 ] , 'Attributes' => [ 'Enabled' => 'true' , ] , ] ) ; return $ matches [ 1 ] ; } else { throw $ e ; } } return $ res [ 'EndpointArn' ] ; }
4324	public static function getBytes ( $ size ) { if ( \ is_string ( $ size ) && \ preg_match ( '/^([\d,.]+)\s?([kmgtp])b?$/i' , $ size , $ matches ) ) { $ size = \ str_replace ( ',' , '' , $ matches [ 1 ] ) ; switch ( \ strtolower ( $ matches [ 2 ] ) ) { case 'p' : $ size *= 1024 ; case 't' : $ size *= 1024 ; case 'g' : $ size *= 1024 ; case 'm' : $ size *= 1024 ; case 'k' : $ size *= 1024 ; } } $ units = array ( 'B' , 'kB' , 'MB' , 'GB' , 'TB' , 'PB' ) ; $ pow = \ pow ( 1024 , ( $ i = \ floor ( \ log ( $ size , 1024 ) ) ) ) ; $ size = $ pow == 0 ? '0 B' : \ round ( $ size / $ pow , 2 ) . ' ' . $ units [ $ i ] ; return $ size ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4946	public function build ( ) { $ view = $ change = array ( ) ; foreach ( $ this -> assigned as $ resourceId => $ spec ) { if ( isset ( $ spec [ 'permission' ] ) ) { $ spec = array ( $ spec [ 'permission' ] => $ spec [ 'users' ] ) ; $ this -> assigned [ $ resourceId ] = $ spec ; } foreach ( $ spec as $ perm => $ userIds ) { if ( self :: PERMISSION_ALL == $ perm || self :: PERMISSION_CHANGE == $ perm ) { $ change = array_merge ( $ change , $ userIds ) ; } $ view = array_merge ( $ view , $ userIds ) ; } } $ this -> change = array_unique ( $ change ) ; $ this -> view = array_unique ( $ view ) ; return $ this ; }
6733	public function run ( Request $ request ) { $ this -> stopwatch = microtime ( true ) ; $ starttime = $ request -> server -> get ( 'REQUEST_TIME_FLOAT' ) ; $ this -> log ( "Router: ->run() called. Starting clock at REQUEST_TIME+%.2fms" , microtime ( true ) - $ starttime ) ; try { $ response = $ this -> process ( $ request ) ; } catch ( \ Throwable $ e ) { $ this -> log ( "Router: Exception" ) ; $ response = $ this -> handleException ( $ e , $ request ) ; } $ this -> log ( "Router: Preparing to send response" ) ; $ response -> prepare ( $ request ) ; $ response -> send ( ) ; $ this -> log ( "Router: Response sent" ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
4143	public function getHeaders ( $ key = null ) { if ( $ key === null ) { return $ this -> headers ; } if ( isset ( $ this -> headers [ $ key ] ) ) { return $ this -> headers [ $ key ] ; } return false ; }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
4973	private function prepareHydrateData ( array $ data ) { $ items = $ data [ 'items' ] ; $ tree = [ '__root__' => array_shift ( $ items ) ] ; foreach ( $ items as $ item ) { $ parent = substr ( $ item [ 'current' ] , 0 , strrpos ( $ item [ 'current' ] , '-' ) ) ; $ tree [ $ parent ] [ ] = $ item ; } $ this -> hydrateData = $ tree ; }
1539	protected function isExpectingContent ( $ request ) : bool { $ methods = $ this -> route -> isNotRelationship ( ) ? [ 'POST' , 'PATCH' ] : [ 'POST' , 'PATCH' , 'DELETE' ] ; return \ in_array ( $ request -> getMethod ( ) , $ methods ) ; }
7289	protected function watch ( OrderInterface $ order ) { if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( $ order -> hasNotifications ( NotificationTypes :: ORDER_ACCEPTED ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ order , OrderStates :: STATE_ACCEPTED ) ) { return ; } $ this -> notify ( NotificationTypes :: ORDER_ACCEPTED , $ order ) ; }
1870	private function isCorsRequest ( Request $ request ) : bool { return $ request -> headers -> has ( 'Origin' ) && $ request -> headers -> get ( 'Origin' ) !== $ request -> getSchemeAndHttpHost ( ) ; }
10070	public function make ( $ tag , $ props = null , $ content = null ) { $ tag = parent :: make ( $ tag , $ props , $ content ) ; $ tag = $ this -> decorators -> apply ( $ tag , $ this ) ; return $ tag ; }
4708	public function initialize ( Text $ text , array $ options = array ( ) ) { $ text -> replace ( '{ ^[ ]{0,' . $ options [ 'tabWidth' ] . '}\[(.+)\]: # id = $1 [ \t]* \n? # maybe *one* newline [ \t]* <?(\S+?)>? # url = $2 [ \t]* \n? # maybe one newline [ \t]* (?: (?<=\s) # lookbehind for whitespace ["\'(] (.+?) # title = $3 ["\')] [ \t]* )? # title is optional (?:\n+|\Z) }xm' , function ( Text $ whole , Text $ id , Text $ url , Text $ title = null ) { $ id -> lower ( ) ; $ this -> markdown -> emit ( 'escape.special_chars' , [ $ url -> replace ( '/(?<!\\\\)_/' , '\\\\_' ) ] ) ; $ this -> markdown -> getUrlRegistry ( ) -> set ( $ id , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' , false ) ) ; if ( $ title ) { $ this -> markdown -> getTitleRegistry ( ) -> set ( $ id , preg_replace ( '/"/' , '&quot;' , $ title ) ) ; } return '' ; } ) ; }
12162	public function getForm ( $ primaryModel = false , $ settings = [ ] ) { if ( ! $ primaryModel ) { return false ; } $ formSegments = [ $ this -> getFormSegment ( $ primaryModel , $ settings ) ] ; $ config = [ 'class' => $ this -> formGeneratorClass , 'models' => $ primaryModel -> collectModels ( ) , 'items' => $ formSegments ] ; return Yii :: createObject ( $ config ) ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
10149	private function readPrintGridlines ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( $ this -> version == self :: XLS_BIFF8 && ! $ this -> readDataOnly ) { $ printGridlines = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> setPrintGridlines ( $ printGridlines ) ; } }
5866	protected function getIndexer ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceStorage $ storage ) { return GeneralUtility :: makeInstance ( Indexer :: class , $ storage ) ; }
12792	public static function createSnippet ( string $ snptName ) : ? Snippet { $ snptRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'snippets' ) ; $ snptFile = $ snptRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ snptName ) . '.php' ; if ( is_readable ( $ snptFile ) ) { return new Snippet ( $ snptFile ) ; } return null ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
9758	function closeTo ( $ value , float $ delta ) : self { return $ this -> expect ( $ this -> target , equalTo ( $ value , $ delta ) ) ; }
9126	private function requestImpl ( string $ requestType ) { if ( $ requestType == 'HEAD' ) { $ this -> setTimeout ( 1 ) ; } $ ms = $ this -> prepareRequest ( $ requestType ) ; $ ms = $ this -> appendPayloadToRequest ( $ ms ) ; if ( ! $ this -> isConnected ( ) ) { $ this -> connect ( ) ; } while ( $ ms -> ready ( ) ) { $ this -> write ( $ ms -> read ( 1024 ) ) ; } $ this -> retrieveAndParseResponse ( $ requestType ) ; if ( $ this -> getHeader ( 'Connection' ) == 'close' ) { $ this -> disconnect ( ) ; } }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
6217	public static function thumbnailToId ( string $ thumbnailUrl ) : string { if ( 1 !== \ preg_match ( '/\/([\d]+)\/([\d]+)(\-avatar\.jpg)$/' , $ thumbnailUrl , $ match ) ) { throw new \ RuntimeException ( \ vsprintf ( 'Invalid thumbnail URL "%s"' , [ $ thumbnailUrl , ] ) ) ; } return ltrim ( $ match [ 1 ] . $ match [ 2 ] , '0' ) ; }
5811	public function updateCMSFields ( FieldList $ fields ) { $ fields -> removeByName ( 'FusionTags' ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ fields -> addFieldToTab ( 'Root.Tagging' , ListboxField :: create ( 'FusionTags' , 'Tags' , FusionTag :: get ( ) -> map ( ) -> toArray ( ) ) -> setMultiple ( true ) ) ; } $ this -> owner -> extend ( 'updateTaggingExtensionCMSFields' , $ fields ) ; }
5530	protected function chainMockExpectations ( ) { $ code = " function expect(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expect(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAt(\$timing, \$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAt(\$timing, \$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectCallCount(\$method, \$count) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMaximumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMaximumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectMinimumCallCount(\$method, \$count, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectMinimumCallCount(\$method, \$count, \$msg = '%s');\n" ; $ code .= " }\n" ; $ code .= " function expectNever(\$method) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectNever(\$method);\n" ; $ code .= " }\n" ; $ code .= " function expectOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; $ code .= " function expectAtLeastOnce(\$method, \$args = false, \$msg = '%s') {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->expectAtLeastOnce(\$method, \$args, \$msg);\n" ; $ code .= " }\n" ; return $ code ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
5771	public function hasOneRole ( array $ roleIds ) : bool { foreach ( $ roleIds as $ roleId ) { if ( $ this -> hasRole ( ( int ) $ roleId ) ) { return true ; } } return false ; }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
4505	public function getList ( Parameters $ parameters = null ) : array { $ options = [ ] ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; if ( array_key_exists ( 'organizationUuid' , $ options [ 'query' ] ) ) { $ options [ 'query' ] [ 'organization.uuid' ] = $ options [ 'query' ] [ 'organizationUuid' ] ; unset ( $ options [ 'query' ] [ 'organizationUuid' ] ) ; } } $ objects = $ this -> execute ( 'GET' , static :: RESOURCE_LIST , $ options ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
10425	private function headers ( ResponseInterface $ response ) : void { if ( ! headers_sent ( ) ) { foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { $ cookie = stripos ( $ name , 'Set-Cookie' ) === 0 ? false : true ; foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , $ cookie ) ; $ cookie = false ; } } header ( sprintf ( 'HTTP/%s %s %s' , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) , true , $ response -> getStatusCode ( ) ) ; } }
7583	protected function extractInfo ( ) { $ this -> info = curl_getinfo ( $ this -> CurlRequest ) ; $ this -> status = $ this -> info [ 'http_code' ] ; if ( curl_errno ( $ this -> CurlRequest ) !== CURLE_OK ) { $ this -> error = curl_error ( $ this -> CurlRequest ) ; } else { $ this -> error = false ; } }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
7434	private function getDirContents ( $ dir , & $ results = [ ] ) { $ files = scandir ( $ dir ) ; foreach ( $ files as $ value ) { $ path = realpath ( $ dir . DIRECTORY_SEPARATOR . $ value ) ; if ( ! is_dir ( $ path ) ) { $ results [ ] = $ path ; continue ; } if ( $ value != '.' && $ value != '..' ) { $ this -> getDirContents ( $ path , $ results ) ; $ results [ ] = $ path ; } } return $ results ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
547	protected function addServers ( $ cache , $ servers ) { if ( empty ( $ servers ) ) { $ servers = [ new MemCacheServer ( [ 'host' => '127.0.0.1' , 'port' => 11211 , ] ) ] ; } else { foreach ( $ servers as $ server ) { if ( $ server -> host === null ) { throw new InvalidConfigException ( "The 'host' property must be specified for every memcache server." ) ; } } } if ( $ this -> useMemcached ) { $ this -> addMemcachedServers ( $ cache , $ servers ) ; } else { $ this -> addMemcacheServers ( $ cache , $ servers ) ; } }
8178	protected function sendMail ( $ to , $ subject , $ view , $ params = [ ] ) { $ mailer = Yii :: $ app -> mailer ; $ mailer -> viewPath = '@abhimanyu/user/views/mail' ; return $ mailer -> compose ( [ 'html' => $ view , 'text' => 'text/' . $ view ] , $ params ) -> setTo ( $ to ) -> setFrom ( Yii :: $ app -> config -> get ( 'mail.username' ) , 'no@reply.com' ) -> setSubject ( $ subject ) -> send ( ) ; }
1697	public function removeFrontendAuthentication ( ) : bool { if ( ! $ this -> session -> isStarted ( ) || ! $ this -> session -> has ( FrontendUser :: SECURITY_SESSION_KEY ) ) { return false ; } $ this -> session -> remove ( FrontendUser :: SECURITY_SESSION_KEY ) ; return true ; }
9665	public function setHeader ( $ header , $ value ) { if ( strlen ( $ header ) < 1 ) { throw new Exception ( 'Header must be a string.' ) ; } $ this -> customHeaders [ $ header ] = $ value ; return $ this ; }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
1980	public static function generateUnwrapped ( $ strScope = TL_MODE , $ blnRaw = false ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return '' ; } $ strMessages = '' ; $ flashBag = $ session -> getFlashBag ( ) ; foreach ( static :: getTypes ( ) as $ strType ) { $ strClass = strtolower ( $ strType ) ; $ arrMessages = $ flashBag -> get ( static :: getFlashBagKey ( $ strType , $ strScope ) ) ; foreach ( array_unique ( $ arrMessages ) as $ strMessage ) { if ( $ strType == 'TL_RAW' || $ blnRaw ) { $ strMessages .= $ strMessage ; } else { $ strMessages .= '<p class="' . $ strClass . '">' . $ strMessage . '</p>' ; } } } return trim ( $ strMessages ) ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
3460	public function find ( string $ method , string $ path ) : Route { $ matcher = new UrlMatcher ( $ this -> routeCollection , new RequestContext ( '/' , $ method ) ) ; try { $ route = $ matcher -> match ( $ path ) ; } catch ( ResourceNotFoundException $ exception ) { throw RouterException :: noRouteMatchesRequestedUri ( $ path , $ method ) ; } catch ( SymfonyMethodNotAllowedException $ exception ) { throw RouterException :: methodNotAllowed ( $ path , $ exception -> getAllowedMethods ( ) ) ; } $ routeName = $ route [ '_route' ] ; unset ( $ route [ '_route' ] ) ; return $ this -> routes [ $ routeName ] -> withAttributes ( $ route ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
5639	public function paintGroupStart ( $ test_name , $ size ) { if ( ! isset ( $ this -> size ) ) { $ this -> size = $ size ; } if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintHeader ( $ test_name ) ; } $ this -> test_stack [ ] = $ test_name ; }
9130	public static function create ( $ name , SymfonyRoute $ route , $ method , $ description = '' ) { return new static ( $ name , $ route , $ method , $ description ) ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
521	protected function migrateDown ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** reverting $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> down ( ) !== false ) { $ this -> removeMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** reverted $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to revert $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
8876	public function send ( ) { if ( ! preg_match ( '/^.+@.+$/' , $ this -> sender ) ) { return false ; } if ( ! preg_match ( '/^.+@.+$/' , $ this -> recipient ) ) { return false ; } if ( ! $ this -> subject || strlen ( $ this -> subject ) > 255 ) { return false ; } $ required_headers = [ ] ; if ( Mail :: $ config [ 'testing_mode' ] ) { if ( empty ( Mail :: $ config [ 'testing_email' ] ) ) { return true ; } $ required_headers [ 'X-Testing-Original-To' ] = $ this -> recipient ; foreach ( $ this -> headers as $ name => $ value ) { switch ( strtolower ( $ name ) ) { case 'cc' : $ this -> headers [ 'X-Testing-Original-Cc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; case 'bcc' : $ this -> headers [ 'X-Testing-Original-Bcc' ] = $ value ; $ required_headers [ $ name ] = '' ; break ; } } $ to = Mail :: $ config [ 'testing_email' ] ; $ subject = '*Test* ' . $ this -> subject ; } else { $ to = $ this -> recipient ; $ subject = $ this -> subject ; } $ required_headers [ 'From' ] = $ this -> sender ; $ required_headers [ 'Return-Path' ] = $ this -> sender ; $ required_headers [ 'Reply-To' ] = $ this -> sender ; $ required_headers [ 'X-Sender' ] = $ this -> sender ; $ headers = $ this -> buildHeaders ( $ required_headers ) ; $ message = $ this -> buildTextPart ( ) . $ this -> buildAttachmentPart ( ) . "--MIME_BOUNDRY--\n" ; return mail ( $ to , $ subject , $ message , $ headers , Mail :: $ config [ 'additional_parameters' ] ) ; }
5047	public function getResult ( $ paginatorAlias = null , $ formAlias = null ) { if ( null === $ paginatorAlias ) { $ paginatorAlias = isset ( $ this -> stack [ 'paginator' ] [ 'as' ] ) ? $ this -> stack [ 'paginator' ] [ 'as' ] : 'paginator' ; } if ( null === $ formAlias ) { $ formAlias = isset ( $ this -> stack [ 'form' ] [ 'as' ] ) ? $ this -> stack [ 'form' ] [ 'as' ] : 'searchform' ; } $ result = [ ] ; $ controller = $ this -> getController ( ) ; $ request = $ controller -> getRequest ( ) ; $ this -> setParameters ( $ request -> getQuery ( ) ) ; if ( isset ( $ this -> stack [ 'params' ] ) ) { $ this -> callPlugin ( 'paginationParams' , $ this -> stack [ 'params' ] ) ; } if ( isset ( $ this -> stack [ 'form' ] ) ) { $ form = $ this -> callPlugin ( 'searchform' , $ this -> stack [ 'form' ] ) ; if ( ! $ request -> isXmlHttpRequest ( ) ) { $ result [ $ formAlias ] = $ form ; } } if ( isset ( $ this -> stack [ 'paginator' ] ) ) { $ result [ $ paginatorAlias ] = $ this -> callPlugin ( 'paginator' , $ this -> stack [ 'paginator' ] ) ; } return $ result ; }
12869	public function bind ( $ sUser , $ sPassword ) : Ldap { return $ this -> _bConnected = ldap_bind ( $ this -> _rConnect , $ sUser , $ sPassword ) ; return $ this ; }
4103	public function search ( $ query , array $ options = array ( ) ) { $ start = microtime ( true ) ; $ result = $ this -> transport -> search ( $ query , $ options ) ; $ result [ 'time' ] = microtime ( true ) - $ start ; return $ result ; }
12503	public static function beginTransaction ( $ connection ) { $ connection -> query = 'BEGIN_TRANSACTION' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
12177	public function addArgument ( ArgumentInterface $ argument ) { $ this -> argumentPositions [ $ argument -> getPosition ( ) ] = $ argument ; $ this -> argumentNames [ $ argument -> getName ( ) ] = $ argument ; if ( $ argument -> isClass ( ) ) { $ this -> argumentClasses [ $ argument -> getClass ( ) ] = $ argument ; } return $ argument ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
7326	private function configureTaxableMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ TaxableInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> taxableClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'taxGroup' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'taxGroup' , 'targetEntity' => Pricing \ Entity \ TaxGroup :: class , 'joinColumns' => [ [ 'name' => 'tax_group_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> taxableClassCache [ ] = $ class ; }
5227	public function bindList ( $ name ) { if ( ! isset ( $ this -> listBindings [ $ name ] ) ) { $ this -> listBindings [ $ name ] = $ this -> addBinding ( new ListBinding ( $ name ) ) ; } return $ this -> listBindings [ $ name ] ; }
3921	private function processFile ( $ fileName ) { $ file = new File ( $ fileName ) ; $ meta = $ this -> metaInformation [ dirname ( $ fileName ) ] [ $ file -> basename ] ; $ title = strlen ( $ meta [ 'title' ] ) ? $ meta [ 'title' ] : StringUtil :: specialchars ( $ file -> basename ) ; if ( strlen ( $ meta [ 'caption' ] ) ) { $ altText = $ meta [ 'caption' ] ; } else { $ altText = ucfirst ( str_replace ( '_' , ' ' , preg_replace ( '/^[0-9]+_/' , '' , $ file -> filename ) ) ) ; } $ information = [ 'file' => $ fileName , 'mtime' => $ file -> mtime , 'alt' => $ altText , 'caption' => ( ! empty ( $ meta [ 'caption' ] ) ? $ meta [ 'caption' ] : '' ) , 'title' => $ title , 'metafile' => $ meta , 'icon' => 'assets/contao/images/' . $ file -> icon , 'extension' => $ file -> extension , 'size' => $ file -> filesize , 'sizetext' => sprintf ( '(%s)' , Controller :: getReadableSize ( $ file -> filesize , 2 ) ) , 'url' => StringUtil :: specialchars ( $ this -> getDownloadLink ( $ fileName ) ) ] ; if ( $ information [ 'isGdImage' ] = $ file -> isGdImage ) { $ information [ 'src' ] = urldecode ( $ this -> resizeImage ( $ fileName ) ) ; if ( file_exists ( TL_ROOT . '/' . $ information [ 'src' ] ) ) { $ size = getimagesize ( TL_ROOT . '/' . $ information [ 'src' ] ) ; $ information [ 'lb' ] = 'lb' . $ this -> getLightboxId ( ) ; $ information [ 'w' ] = $ size [ 0 ] ; $ information [ 'h' ] = $ size [ 1 ] ; $ information [ 'wh' ] = $ size [ 3 ] ; } } if ( $ information [ 'isSvgImage' ] = $ file -> isSvgImage ) { $ information [ 'src' ] = $ fileName ; } if ( $ information [ 'isPicture' ] = ( int ) $ this -> resizeImages [ 2 ] ) { $ picture = Picture :: create ( $ file , $ this -> getResizeImages ( ) ) -> getTemplateData ( ) ; $ picture [ 'alt' ] = $ altText ; $ picture [ 'title' ] = $ title ; $ information [ 'picture' ] = $ picture ; } $ this -> modifiedTime [ ] = $ file -> mtime ; $ this -> outputBuffer [ ] = $ information ; }
2981	private function findLastImportedPath ( $ yamlContents ) { $ data = Yaml :: parse ( $ yamlContents ) ; if ( ! isset ( $ data [ 'imports' ] ) ) { return false ; } $ lastImport = end ( $ data [ 'imports' ] ) ; if ( ! isset ( $ lastImport [ 'resource' ] ) ) { return false ; } return $ lastImport [ 'resource' ] ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
244	public function export ( ) { openlog ( $ this -> identity , $ this -> options , $ this -> facility ) ; foreach ( $ this -> messages as $ message ) { if ( syslog ( $ this -> _syslogLevels [ $ message [ 1 ] ] , $ this -> formatMessage ( $ message ) ) === false ) { throw new LogRuntimeException ( 'Unable to export log through system log!' ) ; } } closelog ( ) ; }
4359	public static function addSpecial ( $ special ) { $ special = ( array ) $ special ; foreach ( $ special as $ char ) { self :: $ special [ ] = $ char ; } }
7812	public static function toJalaliStr ( $ g_date , $ curSep = '-' , $ newSep = '/' ) { $ arr = explode ( $ curSep , $ g_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 2 ] ) == 0 ) return "" ; else $ j_date = jDateTime :: toJalali ( $ arr [ 0 ] , $ arr [ 1 ] , $ arr [ 2 ] ) ; $ j_date_rev = array ( $ j_date [ 2 ] , $ j_date [ 1 ] , $ j_date [ 0 ] ) ; return implode ( $ newSep , $ j_date_rev ) ; }
4663	public function smtp ( array $ params ) { if ( ! array_key_exists ( 'username' , $ params ) ) { throw new Exception ( 'We need a username' ) ; } if ( ! array_key_exists ( 'password' , $ params ) ) { throw new Exception ( 'We need a password' ) ; } $ this -> smtp = $ params ; $ this -> auth = true ; return $ this ; }
8474	public function notice ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'notice' , $ scope , $ message , $ context , $ config ) ; }
5037	public function setImages ( array $ images , PermissionsInterface $ permissions = null ) { $ this -> clear ( ) ; foreach ( $ images as $ prop => $ image ) { $ this -> set ( $ prop , $ image , false ) ; } if ( $ permissions ) { $ this -> setPermissions ( $ permissions ) ; } return $ this ; }
9429	public function getFontIconClassNames ( ) { $ classes = [ ] ; if ( $ this -> owner -> FontIcon ) { if ( $ this -> owner -> FontIconListItem ) { $ classes [ ] = $ this -> backend -> getClassName ( 'list-item' ) ; } if ( $ this -> owner -> FontIconFixedWidth ) { $ classes [ ] = $ this -> backend -> getClassName ( 'fixed-width' ) ; } $ classes [ ] = $ this -> backend -> getClassName ( 'icon' , [ $ this -> owner -> FontIcon ] ) ; } return $ classes ; }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
5609	public function paintGroupStart ( $ message , $ size ) { parent :: paintGroupStart ( $ message , $ size ) ; $ node = new TreemapNode ( 'Group' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
11621	public function view ( ) : \ TheCMSThread \ Core \ Main \ View { static $ view ; if ( $ view === null ) { $ view = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\View" ) ; } $ view -> __construct ( $ this -> auth ( ) ) ; return $ view ; }
10674	private function _cmpFrm ( $ txt ) { $ CmpFrmRV = '' ; $ length = mb_strlen ( $ txt , 'UTF-8' ) ; for ( $ CmpFrmI = 0 ; $ CmpFrmI < $ length ; $ CmpFrmI ++ ) { if ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '0' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 0 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '1' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 1 ] ; } elseif ( mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) === '2' ) { $ CmpFrmRV .= $ this -> aCmpReg [ 2 ] ; } else { $ CmpFrmRV .= mb_substr ( $ txt , $ CmpFrmI , 1 , 'UTF-8' ) ; } } return $ CmpFrmRV ; }
4604	protected function parse ( $ path ) : array { $ fixtures = array_key_exists ( 'FIXTURES' , $ _ENV ) ? $ _ENV [ 'FIXTURES' ] : 'dev' ; $ files = glob ( str_replace ( '{fixtures}' , $ fixtures , $ path ) ) ; if ( ! $ files ) { throw new LogicException ( 'Fixtures path "' . $ path . '" yields no files.' ) ; } $ objects = [ ] ; foreach ( $ files as $ file ) { foreach ( Objects :: parseFile ( $ file ) as $ object ) { $ objects [ ] = $ object ; } } return $ objects ; }
8881	private function isValidRelativePath ( string $ relativePath , string $ cwd ) : bool { $ valid = false ; if ( './' === substr ( $ relativePath , 0 , 2 ) ) { $ tmpPath = $ cwd . DIRECTORY_SEPARATOR . substr ( $ relativePath , 2 , strlen ( $ relativePath ) ) ; $ valid = $ this -> isValidFullPath ( $ tmpPath ) ; } return $ valid ; }
5936	public function addGroup ( $ item ) { if ( ! ( $ item instanceof Group ) ) { if ( is_array ( $ item ) ) { try { $ item = new Group ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Group. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Group"!' , E_USER_WARNING ) ; } } $ this -> groups [ ] = $ item ; return $ this ; }
8286	protected function loadDefaultConfig ( array $ config ) { $ configurator = new PluginConfigurator ; $ validConfig = $ configurator -> validate ( isset ( $ config [ self :: PLUGIN_NAME ] ) ? $ config [ self :: PLUGIN_NAME ] : null ) ; return $ validConfig ; }
6651	private function appendExtraFields ( array $ extra ) { foreach ( $ this -> extraData as $ key => $ value ) { $ extra [ $ key ] = $ value ; } return $ extra ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
4917	public function setParams ( array $ params ) { foreach ( $ params as $ key => $ value ) { $ this -> setParam ( $ key , $ value ) ; } return $ this ; }
9616	public function registerCommands ( array $ commands , callable $ handler ) { foreach ( $ commands as $ command ) { $ handler_id = "app.handler." . join ( '' , array_slice ( explode ( "\\" , $ command ) , - 1 ) ) ; $ this [ $ handler_id ] = $ handler ; } }
8690	protected function validateElementValues ( ) { foreach ( self :: $ mandatoryFields as $ field ) { if ( array_key_exists ( $ field , $ this -> attributes ) ) { $ value = ( int ) $ this -> attributes [ $ field ] ; if ( $ value < 0 ) { throw new \ SVGCreator \ SVGException ( "The " . $ field . " value is lesser than 0, in element " . self :: TYPE , 1 ) ; } } } }
2636	public function getLastVersion ( ) { try { $ url = self :: CHECK_VERSION_URL ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> write ( \ Zend_Http_Client :: GET , $ url , '1.1' ) ; $ responseBody = $ client -> read ( ) ; $ client -> close ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; if ( $ responseCode !== 200 ) { return false ; } $ body = \ Zend_Http_Response :: extractBody ( $ responseBody ) ; $ json = json_decode ( $ body ) ; $ version = ! empty ( $ json -> version ) ? $ json -> version : false ; return $ version ; } catch ( \ Exception $ e ) { $ this -> _logger -> log ( 100 , $ e -> getMessage ( ) . $ url ) ; return false ; } }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
2259	protected function createInitialVersion ( $ strTable , $ intId ) { @ trigger_error ( 'Using Controller::createInitialVersion() has been deprecated and will no longer work in Contao 5.0. Use Versions->initialize() instead.' , E_USER_DEPRECATED ) ; $ objVersions = new Versions ( $ strTable , $ intId ) ; $ objVersions -> initialize ( ) ; }
443	public function off ( $ name , $ handler = null ) { $ this -> ensureBehaviors ( ) ; if ( empty ( $ this -> _events [ $ name ] ) && empty ( $ this -> _eventWildcards [ $ name ] ) ) { return false ; } if ( $ handler === null ) { unset ( $ this -> _events [ $ name ] , $ this -> _eventWildcards [ $ name ] ) ; return true ; } $ removed = false ; if ( isset ( $ this -> _events [ $ name ] ) ) { foreach ( $ this -> _events [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _events [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _events [ $ name ] = array_values ( $ this -> _events [ $ name ] ) ; return $ removed ; } } if ( isset ( $ this -> _eventWildcards [ $ name ] ) ) { foreach ( $ this -> _eventWildcards [ $ name ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( $ this -> _eventWildcards [ $ name ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { $ this -> _eventWildcards [ $ name ] = array_values ( $ this -> _eventWildcards [ $ name ] ) ; if ( empty ( $ this -> _eventWildcards [ $ name ] ) ) { unset ( $ this -> _eventWildcards [ $ name ] ) ; } } } return $ removed ; }
1141	public function setValue ( $ value ) { if ( \ is_bool ( $ value ) ) { if ( 'checkbox' !== $ this -> type ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Invalid argument of type "%s"' , \ gettype ( $ value ) ) ) ; } if ( $ value ) { if ( ! $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } } elseif ( $ this -> element -> isSelected ( ) ) { $ this -> element -> click ( ) ; } return ; } foreach ( ( array ) $ value as $ v ) { $ this -> selector -> selectByValue ( $ v ) ; } }
5630	public function getIdentity ( ) { if ( $ this -> username && $ this -> password ) { return $ this -> username . ':' . $ this -> password ; } return false ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
9700	protected function generate ( ) { $ params = array_keys ( $ this -> params ) ; if ( $ this -> paragraphs ) { $ params [ ] = $ this -> paragraphs ; } $ url = self :: API_URL . implode ( '/' , $ params ) ; return $ this -> conn -> request ( $ url ) ; }
12129	public function failed ( $ fail = true ) { if ( ! func_num_args ( ) ) { return $ this -> _failed ; } $ this -> _failed = $ fail ; return $ this ; }
8691	public static function symlinkJQueryFileUpload ( Event $ event ) { $ IO = $ event -> getIO ( ) ; $ composer = $ event -> getComposer ( ) ; $ cmanager = new ComposerPathFinder ( $ composer ) ; $ ds = DIRECTORY_SEPARATOR ; $ options = [ 'targetSuffix' => self :: getTargetSuffix ( 'jquery-file-upload' ) , 'sourcePrefix' => "..{$ds}..{$ds}..{$ds}" , ] ; list ( $ symlinkTarget , $ symlinkName ) = $ cmanager -> getSymlinkFromComposer ( 'sidus/file-upload-bundle' , 'blueimp/jquery-file-upload' , $ options ) ; $ IO -> write ( 'Checking Symlink' , false ) ; if ( false === self :: checkSymlink ( $ symlinkTarget , $ symlinkName , true ) ) { $ IO -> write ( 'Creating Symlink: ' . $ symlinkName , false ) ; self :: createSymlink ( $ symlinkTarget , $ symlinkName ) ; } $ IO -> write ( '<info>OK</info>' ) ; }
484	public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
4815	public function getAsDom ( ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromStr ( "<anydataset></anydataset>" ) ; $ nodeRoot = $ anyDataSet -> getElementsByTagName ( "anydataset" ) -> item ( 0 ) ; foreach ( $ this -> collection as $ sr ) { $ row = $ sr -> getAsDom ( ) ; $ nodeRow = $ row -> getElementsByTagName ( "row" ) -> item ( 0 ) ; $ newRow = XmlUtil :: createChild ( $ nodeRoot , "row" ) ; XmlUtil :: addNodeFromNode ( $ newRow , $ nodeRow ) ; } return $ anyDataSet ; }
10096	protected function processSize ( $ size ) { if ( $ size === null ) { return $ size ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new InvalidArgumentException ( 'Size has to be larger than 0' ) ; } return ( int ) $ size ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
8942	public function queryChangeset ( $ param ) { $ base = 'changesets/' . $ param ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ xmlString = $ this -> sendRequest ( $ path ) ; return $ xmlString -> osm ; }
10414	public function createTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return null ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ schemaManager -> createTable ( $ table ) ; return true ; }
5419	protected function parseHeaderLine ( $ header_line ) { if ( preg_match ( '/HTTP\/(\d+\.\d+)\s+(\d+)/i' , $ header_line , $ matches ) ) { $ this -> http_version = $ matches [ 1 ] ; $ this -> response_code = $ matches [ 2 ] ; } if ( preg_match ( '/Content-type:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> mime_type = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Location:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> location = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Set-cookie:(.*)/i' , $ header_line , $ matches ) ) { $ this -> cookies [ ] = $ this -> parseCookie ( $ matches [ 1 ] ) ; } if ( preg_match ( '/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i' , $ header_line , $ matches ) ) { $ this -> authentication = $ matches [ 1 ] ; $ this -> realm = trim ( $ matches [ 2 ] ) ; } }
12614	public function have_required_properties ( ) { return ( ! empty ( $ this -> handle ) && ! empty ( $ this -> relative_path ) && ! empty ( $ this -> filename ) ) ; }
6956	private function calculatePaymentBase ( SupplierOrderInterface $ order ) { $ base = $ this -> calculateItemsTotal ( $ order ) + $ order -> getShippingCost ( ) - $ order -> getDiscountTotal ( ) ; $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; return Money :: round ( $ base , $ currency ) ; }
3861	public function prepare ( ) { if ( $ this -> objItems ) { return $ this ; } if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } if ( $ this -> objFilterSettings ) { $ this -> objFilterSettings -> addRules ( $ this -> objFilter , $ this -> arrParam ) ; } $ this -> modifyFilter ( ) ; $ intTotal = $ this -> objMetaModel -> getCount ( $ this -> objFilter ) ; $ calculator = $ this -> paginationLimitCalculator ; $ calculator -> setTotalAmount ( $ intTotal ) ; $ curPage = ( int ) \ Input :: get ( 'page' ) ; if ( $ curPage > 1 ) { $ calculator -> setCurrentPage ( $ curPage ) ; } $ this -> objTemplate -> total = $ intTotal ; $ this -> objItems = $ this -> objMetaModel -> findByFilter ( $ this -> objFilter , $ this -> strSortBy , $ calculator -> getCalculatedOffset ( ) , $ calculator -> getCalculatedLimit ( ) , $ this -> strSortDirection , $ this -> getAttributeNames ( ) ) ; return $ this ; }
998	public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
6741	public function to ( $ target ) { if ( is_null ( $ this -> request ) ) { throw new \ LogicException ( 'Missing request instance.' ) ; } $ target = new Uri ( $ target ) ; $ uri = $ this -> request -> getUri ( ) -> withScheme ( $ target -> getScheme ( ) ) -> withHost ( $ target -> getHost ( ) ) ; if ( $ port = $ target -> getPort ( ) ) { $ uri = $ uri -> withPort ( $ port ) ; } if ( $ path = $ target -> getPath ( ) ) { $ uri = $ uri -> withPath ( rtrim ( $ path , '/' ) . '/' . ltrim ( $ uri -> getPath ( ) , '/' ) ) ; } if ( ! empty ( $ this -> request -> getQueryParams ( ) ) ) { $ queryParams = $ this -> request -> getQueryParams ( ) ; if ( count ( $ queryParams ) == 1 && empty ( array_shift ( $ queryParams ) ) ) { $ queryKeys = array_keys ( $ this -> request -> getQueryParams ( ) ) ; $ uri = $ uri -> withQuery ( $ queryKeys [ 0 ] ) ; } else { $ uri = $ uri -> withQuery ( http_build_query ( $ this -> request -> getQueryParams ( ) ) ) ; } } $ request = $ this -> request -> withUri ( $ uri ) ; foreach ( $ request -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( empty ( $ headerValue [ 0 ] ) ) { $ request = $ request -> withoutHeader ( $ headerName ) ; } } return $ this -> client -> send ( $ request ) ; }
6601	protected function buildUrl ( $ url , $ params = [ ] ) { if ( $ this -> useOauth ) { $ params [ 'access_token' ] = $ this -> getAccessToken ( ) ; } $ params = http_build_query ( $ params ) ; return $ this -> baseUrl . $ url . '?' . $ params ; }
8879	private function isValidHomeDirectory ( string $ path ) : bool { $ valid = false ; if ( '~/' === substr ( $ path , 0 , 2 ) ) { $ valid = $ this -> isValidFullPath ( $ this -> expandHomeDirectory ( $ path ) ) ; } return $ valid ; }
6784	public function buildQueryString ( $ options ) { $ options = $ this -> resolve ( $ options ) ; foreach ( $ this -> formParameters as $ key => $ isFormParameter ) { if ( $ isFormParameter && isset ( $ options [ $ key ] ) ) { unset ( $ options [ $ key ] ) ; } } foreach ( $ this -> headerParameters as $ key => $ isHeaderParameter ) { if ( $ isHeaderParameter && isset ( $ options [ $ key ] ) ) { unset ( $ options [ $ key ] ) ; } } return http_build_query ( $ options ) ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
12697	static function getOpts ( $ extname = '' , $ version = '' , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; if ( $ version == '' && self :: isValidVersion ( $ extname ) ) { $ version = $ extname ; $ extname = '' ; } if ( $ version != '' && ! self :: isValidVersion ( $ version ) ) { throw new PakeException ( "'$version' is not a valid version number" ) ; } if ( $ extname == '' ) { $ extname = self :: getDefaultExtName ( ) ; } if ( ! isset ( self :: $ options [ $ extname ] ) || ! is_array ( self :: $ options [ $ extname ] ) ) { if ( isset ( $ cliopts [ 'config-file' ] ) ) { $ cfgfile = $ cliopts [ 'config-file' ] ; } else { $ cfgfile = self :: getOptionsDir ( ) . "/options-$extname.yaml" ; } if ( isset ( $ cliopts [ 'user-config-file' ] ) ) { $ usercfgfile = $ cliopts [ 'user-config-file' ] ; if ( ! is_file ( $ cliopts [ 'user-config-file' ] ) ) { throw new PakeException ( "Could not find user-configuration-file {$cliopts['user-config-file']}" ) ; } } else { $ usercfgfile = self :: getOptionsDir ( ) . "/options-user.yaml" ; } foreach ( $ cliopts as $ opt => $ val ) { if ( substr ( $ opt , 0 , 7 ) == 'option.' ) { unset ( $ cliopts [ $ opt ] ) ; $ work = array_reverse ( explode ( '.' , substr ( $ opt , 7 ) ) ) ; $ built = array ( array_shift ( $ work ) => $ val ) ; foreach ( $ work as $ key ) { $ built = array ( $ key => $ built ) ; } self :: recursivemerge ( $ cliopts , $ built ) ; } } self :: loadConfiguration ( $ cfgfile , $ extname , $ version , $ usercfgfile , $ cliopts ) ; } pake_echo ( "Building extension $extname ( " . self :: $ options [ $ extname ] [ 'extension' ] [ 'name' ] . " ) version " . self :: $ options [ $ extname ] [ 'version' ] [ 'alias' ] . self :: $ options [ $ extname ] [ 'releasenr' ] [ 'separator' ] . self :: $ options [ $ extname ] [ 'version' ] [ 'release' ] ) ; return self :: $ options [ $ extname ] ; }
9878	private function writeWorkbookPr ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'workbookPr' ) ; if ( Date :: getExcelCalendar ( ) == Date :: CALENDAR_MAC_1904 ) { $ objWriter -> writeAttribute ( 'date1904' , '1' ) ; } $ objWriter -> writeAttribute ( 'codeName' , 'ThisWorkbook' ) ; $ objWriter -> endElement ( ) ; }
11663	public static function saveToFile ( $ file , $ properties ) { $ prop_string = self :: saveToString ( $ properties ) ; $ real_file = File :: asFile ( $ file ) ; if ( ! $ real_file -> exists ( ) ) { $ real_file -> touch ( ) ; } $ real_file -> setContent ( $ prop_string ) ; }
11527	public function registerPackageHelpers ( ) { foreach ( $ this -> packageHelpers as $ helper ) { $ dashName = last ( explode ( '/' , $ helper ) ) ; $ underscoreName = str_replace ( '-' , '_' , $ dashName ) ; if ( in_array ( '*' , $ this -> packageInclude ) || in_array ( $ dashName , $ this -> packageInclude ) || in_array ( $ underscoreName , $ this -> packageInclude ) ) { require_once $ this -> replaceVariables ( $ this -> packageHelperPattern , compact ( 'dashName' , 'underscoreName' ) ) ; } } }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
6975	private function throwIllegalOperationIfAdjustmentIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ adjustment = $ this -> getAdjustmentFromEvent ( $ event ) ; if ( $ adjustment -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
3030	public function pauseSession ( AssessmentTestSession $ session ) { $ session -> updateDuration ( ) ; return $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_PAUSED ) ; }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
6629	public function authenticate ( ) { $ state = $ this -> makeState ( ) ; $ this -> store -> put ( $ state , $ this -> settings ) ; return $ this -> redirect -> to ( $ this -> authURL ( $ state ) ) ; }
159	public function having ( $ condition , $ params = [ ] ) { $ this -> having = $ condition ; $ this -> addParams ( $ params ) ; return $ this ; }
9007	public function sort ( ) { $ this -> uasort ( function ( $ a , $ b ) { $ priority_a = ( int ) $ a -> get ( 'priority' ) ? : 500 ; $ priority_b = ( int ) $ b -> get ( 'priority' ) ? : 500 ; if ( $ priority_a == $ priority_b ) { return 0 ; } return ( $ priority_a < $ priority_b ) ? - 1 : 1 ; } ) ; return $ this ; }
10147	private function readPalette ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ nm = self :: getUInt2d ( $ recordData , 0 ) ; for ( $ i = 0 ; $ i < $ nm ; ++ $ i ) { $ rgb = substr ( $ recordData , 2 + 4 * $ i , 4 ) ; $ this -> palette [ ] = self :: readRGB ( $ rgb ) ; } } }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
1260	protected function createAccess ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ accessRequest = $ xml -> appendChild ( $ xml -> createElement ( 'AccessRequest' ) ) ; $ accessRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'AccessLicenseNumber' , $ this -> accessKey ) ) ; $ accessRequest -> appendChild ( $ xml -> createElement ( 'UserId' , $ this -> userId ) ) ; $ p = $ accessRequest -> appendChild ( $ xml -> createElement ( 'Password' ) ) ; $ p -> appendChild ( $ xml -> createTextNode ( $ this -> password ) ) ; return $ xml -> saveXML ( ) ; }
4487	public function send ( $ message , string $ endpointArn ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $endpointArn" , [ 'Message' => $ message , ] ) ; return ; } if ( ! ( $ message instanceof Message ) ) { $ message = new Message ( $ message ) ; } $ this -> sns -> publish ( [ 'TargetArn' => $ endpointArn , 'Message' => $ this -> encodeMessage ( $ message ) , 'MessageStructure' => 'json' , ] ) ; }
2757	public function permissions ( ) { $ permissions = [ ] ; foreach ( $ this -> entityTypeManager -> getStorage ( 'taxonomy_vocabulary' ) -> loadMultiple ( ) as $ vocabulary ) { $ permissions += [ 'view published terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View published terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , 'view unpublished terms in ' . $ vocabulary -> id ( ) => [ 'title' => $ this -> t ( 'View unpublished terms in %vocabulary' , [ '%vocabulary' => $ vocabulary -> label ( ) ] ) , ] , ] ; } return $ permissions ; }
8191	public function actionConfirm ( $ id , $ code ) { $ user = UserIdentity :: findByActivationToken ( $ id , $ code ) ; if ( $ user == NULL ) throw new NotFoundHttpException ; if ( ! empty ( $ user ) ) { $ user -> activation_token = NULL ; $ user -> status = User :: STATUS_ACTIVE ; $ user -> save ( FALSE ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' has successfully been activated' ) ) ; } else Yii :: $ app -> session -> setFlash ( 'error' , Yii :: t ( 'user' , 'Account ' . $ user -> email . ' could not been activated. Please contact the Administrator' ) ) ; return $ this -> render ( 'confirm' , [ 'user' => $ user ] ) ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
11300	protected function _fetchData ( $ name ) { $ gateway = new \ Cora \ Gateway ( $ this -> getDbAdaptor ( ) , $ this -> getTableName ( ) , $ this -> getPrimaryKey ( ) ) ; return $ gateway -> fetchData ( $ this -> getFieldName ( $ name ) , $ this ) ; }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
10746	protected function sendJson ( Response $ response , $ payload ) : Response { $ response -> getBody ( ) -> write ( json_encode ( $ payload ) ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json' ) ; }
10588	public function buildChargeFromTransaction ( $ sTxnID ) { $ oCharge = new Freeagent \ DataWrapper \ ChargeVO ( ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sTxnID ) ; $ oCharge -> setId ( $ sTxnID ) -> setGateway ( 'paypalexpress' ) -> setPaymentTerms ( 1 ) -> setAmount_Gross ( $ oDets -> GrossAmount -> value ) -> setAmount_Fee ( $ oDets -> FeeAmount -> value ) -> setAmount_Net ( $ oDets -> GrossAmount -> value - $ oDets -> FeeAmount -> value ) -> setDate ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; } catch ( \ Exception $ oE ) { } return $ oCharge ; }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
11954	public function resetAllPropertiesExcept ( $ properties = array ( ) ) { foreach ( $ this -> obj_to_db_trans as $ obj_prop => $ db_field ) { if ( ! in_array ( $ obj_prop , $ this -> key_properties ) && ! in_array ( $ obj_prop , $ properties ) ) { $ this -> { $ obj_prop } = null ; } } }
1015	public function setValidationRules ( $ validationRules ) { if ( ! is_callable ( $ validationRules ) && ! is_array ( $ validationRules ) && $ validationRules !== null ) { throw new InvariantViolation ( 'Server config expects array of validation rules or callable returning such array, but got ' . Utils :: printSafe ( $ validationRules ) ) ; } $ this -> validationRules = $ validationRules ; return $ this ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
10382	protected static function save_external_file ( $ url , $ path ) { $ data = file_get_contents ( $ url ) ; return ( $ data && self :: save_file ( $ path , $ data ) ) ? $ data : '' ; }
5591	public function fetchResponse ( $ url , $ encoding ) { if ( ! in_array ( $ encoding -> getMethod ( ) , array ( 'POST' , 'PUT' ) ) ) { $ url -> addRequestParameters ( $ encoding ) ; $ encoding -> clear ( ) ; } $ response = $ this -> fetchWhileRedirected ( $ url , $ encoding ) ; if ( $ headers = $ response -> getHeaders ( ) ) { if ( $ headers -> isChallenge ( ) ) { $ this -> authenticator -> addRealm ( $ url , $ headers -> getAuthentication ( ) , $ headers -> getRealm ( ) ) ; } } return $ response ; }
5230	public static function forValue ( $ value ) { $ enumClass = new \ ReflectionClass ( get_called_class ( ) ) ; foreach ( $ enumClass -> getStaticProperties ( ) as $ instance ) { if ( $ instance -> value ( ) === $ value ) { return $ instance ; } } throw new \ InvalidArgumentException ( 'Enum ' . $ enumClass -> getName ( ) . ' for value ' . $ value . ' does not exist.' ) ; }
865	private function skipNonArrayElements ( $ index , Tokens $ tokens ) { if ( $ tokens [ $ index ] -> equals ( '}' ) ) { return $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; } if ( $ tokens [ $ index ] -> equals ( ')' ) ) { $ startIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ startIndex = $ tokens -> getPrevMeaningfulToken ( $ startIndex ) ; if ( ! $ tokens [ $ startIndex ] -> isGivenKind ( [ T_ARRAY , CT :: T_ARRAY_SQUARE_BRACE_OPEN ] ) ) { return $ startIndex ; } } return $ index ; }
4851	protected function applyId ( & $ row , $ id , $ identifierField ) { $ ids = ( array ) $ id ; $ findId = function ( $ row ) use ( $ ids , $ identifierField ) { foreach ( $ ids as $ id ) { $ bool = true ; $ identifierField = $ this -> flatten ( $ identifierField ) ; foreach ( $ identifierField as $ identifier ) { $ bool = $ bool && ( mb_strtolower ( $ id [ $ identifier ] ) === mb_strtolower ( $ row [ $ identifier ] ) ) ; } if ( $ bool ) { return $ id [ 'id' ] ; } } return 0 ; } ; $ isDeep = $ this -> isDeep ( $ row ) ; if ( $ isDeep ) { foreach ( $ row as $ i => & $ r ) { $ r [ 'id' ] = $ findId ( $ r ) ; } } else { $ row [ 'id' ] = $ findId ( $ row ) ; } }
5785	public function addColumn ( string $ name , $ value ) { $ this -> args [ ] = $ value ; if ( mb_strlen ( $ this -> columns ) > 0 ) { $ this -> columns .= ", " ; } $ this -> columns .= $ name ; if ( mb_strlen ( $ this -> values ) > 0 ) { $ this -> values .= ", " ; } $ argNum = count ( $ this -> args ) ; $ this -> values .= "$" . $ argNum ; }
3592	protected function loadMetaAttributes ( ) { if ( ! array_key_exists ( 'metaAttributes' , $ this -> relations ) ) { $ this -> reloadMetaAttributes ( ) ; } $ attributes = $ this -> getRelation ( 'metaAttributes' ) ; if ( ! $ attributes instanceof AttributeBag ) { $ this -> setRelation ( 'metaAttributes' , ( new Attribute ) -> newBag ( $ attributes -> all ( ) ) ) ; } }
11671	public function executeRaw ( array $ arguments , & $ error = null ) { $ error = false ; $ commandID = array_shift ( $ arguments ) ; $ response = $ this -> connection -> executeCommand ( new RawCommand ( $ commandID , $ arguments ) ) ; if ( $ response instanceof ResponseInterface ) { if ( $ response instanceof ErrorResponseInterface ) { $ error = true ; } return ( string ) $ response ; } return $ response ; }
11513	public function actionReset ( $ id , $ code ) { if ( ! $ this -> module -> enablePasswordRecovery ) { throw new NotFoundHttpException ; } $ token = $ this -> finder -> findToken ( [ 'user_id' => $ id , 'code' => $ code , 'type' => Token :: TYPE_RECOVERY ] ) -> one ( ) ; if ( $ token === null || $ token -> isExpired || $ token -> user === null ) { \ Yii :: $ app -> session -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'Recovery link is invalid or expired. Please try requesting a new one.' ) ) ; return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Invalid or expired link' ) , 'module' => $ this -> module , ] ) ; } $ model = \ Yii :: createObject ( [ 'class' => RecoveryForm :: className ( ) , 'scenario' => 'reset' , ] ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> getRequest ( ) -> post ( ) ) && $ model -> resetPassword ( $ token ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Password has been changed' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'reset' , [ 'model' => $ model , ] ) ; }
9621	protected function qsencode ( array $ data = array ( ) ) { $ req = '' ; if ( $ data ) { foreach ( $ data as $ key => $ value ) { $ req .= $ key . '=' . urlencode ( stripslashes ( $ value ) ) . '&' ; } $ req = substr ( $ req , 0 , strlen ( $ req ) - 1 ) ; } return $ req ; }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
10167	private function readBIFF8CellRangeAddressB ( $ subData , $ baseCell = 'A1' ) { list ( $ baseCol , $ baseRow ) = Coordinate :: coordinateFromString ( $ baseCell ) ; $ baseCol = Coordinate :: columnIndexFromString ( $ baseCol ) - 1 ; $ frIndex = self :: getUInt2d ( $ subData , 0 ) ; $ lrIndex = self :: getUInt2d ( $ subData , 2 ) ; if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fcIndex = 0x00FF & self :: getUInt2d ( $ subData , 4 ) ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; $ fc = '$' . $ fc ; } else { $ relativeFcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ fcIndex = $ baseCol + $ relativeFcIndex ; $ fcIndex = ( $ fcIndex < 256 ) ? $ fcIndex : $ fcIndex - 256 ; $ fcIndex = ( $ fcIndex >= 0 ) ? $ fcIndex : $ fcIndex + 256 ; $ fc = Coordinate :: stringFromColumnIndex ( $ fcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 4 ) ) ) { $ fr = $ frIndex + 1 ; $ fr = '$' . $ fr ; } else { $ frIndex = ( $ frIndex <= 32767 ) ? $ frIndex : $ frIndex - 65536 ; $ fr = $ baseRow + $ frIndex ; } if ( ! ( 0x4000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lcIndex = 0x00FF & self :: getUInt2d ( $ subData , 6 ) ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; $ lc = '$' . $ lc ; } else { $ relativeLcIndex = 0x00FF & self :: getInt2d ( $ subData , 4 ) ; $ lcIndex = $ baseCol + $ relativeLcIndex ; $ lcIndex = ( $ lcIndex < 256 ) ? $ lcIndex : $ lcIndex - 256 ; $ lcIndex = ( $ lcIndex >= 0 ) ? $ lcIndex : $ lcIndex + 256 ; $ lc = Coordinate :: stringFromColumnIndex ( $ lcIndex + 1 ) ; } if ( ! ( 0x8000 & self :: getUInt2d ( $ subData , 6 ) ) ) { $ lr = $ lrIndex + 1 ; $ lr = '$' . $ lr ; } else { $ lrIndex = ( $ lrIndex <= 32767 ) ? $ lrIndex : $ lrIndex - 65536 ; $ lr = $ baseRow + $ lrIndex ; } return "$fc$fr:$lc$lr" ; }
2305	protected function doCreatePageList ( $ intId = 0 , $ level = - 1 ) { $ objPages = $ this -> Database -> prepare ( "SELECT id, title, type, dns FROM tl_page WHERE pid=? ORDER BY sorting" ) -> execute ( $ intId ) ; if ( $ objPages -> numRows < 1 ) { return '' ; } ++ $ level ; $ strOptions = '' ; while ( $ objPages -> next ( ) ) { if ( $ objPages -> type == 'root' ) { if ( $ objPages -> dns && $ objPages -> dns != Environment :: get ( 'host' ) ) { continue ; } $ strOptions .= '<optgroup label="' . $ objPages -> title . '">' ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , - 1 ) ; $ strOptions .= '</optgroup>' ; } else { $ strOptions .= sprintf ( '<option value="{{link_url::%s}}"%s>%s%s</option>' , $ objPages -> id , ( ( '{{link_url::' . $ objPages -> id . '}}' == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; &nbsp; ' , $ level ) , StringUtil :: specialchars ( $ objPages -> title ) ) ; $ strOptions .= $ this -> doCreatePageList ( $ objPages -> id , $ level ) ; } } return $ strOptions ; }
9751	public function set_images ( $ post_id ) { if ( ! $ post_id || is_null ( $ post_id ) ) { return 0 ; } update_post_meta ( $ post_id , 'custom_images_grifus' , 'true' ) ; $ count = 0 ; $ tmdb = 'image.tmdb.org' ; $ poster = get_post_meta ( $ post_id , 'poster_url' , true ) ; if ( filter_var ( $ poster , FILTER_VALIDATE_URL ) && strpos ( $ poster , $ tmdb ) ) { $ count ++ ; $ poster = WP_Image :: save ( $ poster , $ post_id , true ) ; update_post_meta ( $ post_id , 'poster_url' , $ poster ) ; } $ main = get_post_meta ( $ post_id , 'fondo_player' , true ) ; if ( filter_var ( $ main , FILTER_VALIDATE_URL ) && strpos ( $ main , $ tmdb ) ) { $ count ++ ; $ main = WP_Image :: save ( $ main , $ post_id ) ; update_post_meta ( $ post_id , 'fondo_player' , $ main ) ; } $ images = get_post_meta ( $ post_id , 'imagenes' , true ) ; $ images_array = explode ( "\n" , $ images ) ; $ new_images = '' ; foreach ( $ images_array as $ image ) { $ image = trim ( $ image ) ; if ( filter_var ( $ image , FILTER_VALIDATE_URL ) && strpos ( $ image , $ tmdb ) ) { $ count ++ ; $ url = WP_Image :: save ( $ image , $ post_id ) ; $ new_images .= $ url . "\n" ; } } if ( ! empty ( $ new_images ) ) { update_post_meta ( $ post_id , 'imagenes' , $ new_images ) ; } return $ count ; }
6676	public function render_meta_boxes ( $ post ) { App :: setCurrentID ( 'EFG' ) ; wp_nonce_field ( '_rating_movie_nonce' , 'rating_movie_nonce' ) ; $ meta_boxes = Module :: CustomRatingGrifus ( ) -> getOption ( 'path' , 'meta-boxes' ) ; $ data = [ 'votes' => $ this -> model -> get_movie_votes ( $ post -> ID ) ] ; $ this -> view -> renderizate ( $ meta_boxes , 'wp-insert-post' , $ data ) ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
12422	public function getAll ( $ domain ) { $ messages = [ ] ; $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { $ messages = $ messages + ( array ) $ object -> getMessages ( $ domain , $ locale ) ; } return $ messages ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
10044	private function createSelectAssociationFormItem ( Model $ model , Column $ column , $ item ) { $ result = new SelectFormItem ( ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ relatedModel = null ; foreach ( $ relations as $ relation ) { $ rightModel = $ relation -> getRight ( ) ; if ( starts_with ( $ column -> getName ( ) , camel_case ( $ rightModel -> getName ( ) ) ) ) { $ relatedModel = $ rightModel ; } } if ( $ relatedModel != null ) { $ displayName = $ this -> aujaConfigurator -> getDisplayName ( $ relatedModel ) ; $ result -> setName ( $ displayName ) ; $ result -> setValue ( $ item -> id ) ; $ items = call_user_func ( array ( $ relatedModel -> getName ( ) , 'all' ) ) ; $ displayField = $ this -> aujaConfigurator -> getDisplayField ( $ relatedModel ) ; foreach ( $ items as $ item ) { $ label = isset ( $ item -> $ displayField ) ? $ item -> $ displayField : '' ; $ value = $ item -> id ; $ option = new SelectOption ( $ label , $ value ) ; $ result -> addOption ( $ option ) ; } } return $ result ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
688	protected function removeAllItems ( $ type ) { if ( ! $ this -> supportsCascadeUpdate ( ) ) { $ names = ( new Query ( ) ) -> select ( [ 'name' ] ) -> from ( $ this -> itemTable ) -> where ( [ 'type' => $ type ] ) -> column ( $ this -> db ) ; if ( empty ( $ names ) ) { return ; } $ key = $ type == Item :: TYPE_PERMISSION ? 'child' : 'parent' ; $ this -> db -> createCommand ( ) -> delete ( $ this -> itemChildTable , [ $ key => $ names ] ) -> execute ( ) ; $ this -> db -> createCommand ( ) -> delete ( $ this -> assignmentTable , [ 'item_name' => $ names ] ) -> execute ( ) ; } $ this -> db -> createCommand ( ) -> delete ( $ this -> itemTable , [ 'type' => $ type ] ) -> execute ( ) ; $ this -> invalidateCache ( ) ; }
7510	function addError ( $ error ) { $ this -> errors [ ] = htmlentities ( $ error . ' at ' . ( $ this -> line_pos [ 0 ] + 1 ) . ', ' . ( $ this -> pos - $ this -> line_pos [ 1 ] + 1 ) . '!' ) ; }
7512	function next ( ) { $ this -> token_start = null ; if ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { return ( $ this -> token = self :: TOK_NULL ) ; } }
9619	public function checkAnswer ( $ extraParams = array ( ) ) { $ remoteIp = $ _SERVER [ "REMOTE_ADDR" ] ; $ challenge = $ _POST [ "recaptcha_challenge_field" ] ; $ response = $ _POST [ "recaptcha_response_field" ] ; if ( ! $ this -> getPrivateKey ( ) ) { throw new \ Exception ( "To use reCAPTCHA you must get an API key from <a href='https://www.google.com/recaptcha/admin/create'>https://www.google.com/recaptcha/admin/create</a>" ) ; } if ( ! $ remoteIp ) { throw new \ Exception ( "For security reasons, you must pass the remote ip to reCAPTCHA" ) ; } if ( ! $ challenge ) { $ this -> valid = false ; $ this -> error = 'incorrect-captcha-sol' ; } else { $ response = $ this -> httpPost ( self :: RECAPTCHA_VERIFY_SERVER , '/recaptcha/api/verify' , array ( 'privatekey' => $ this -> getPrivateKey ( ) , 'remoteip' => $ remoteIp , 'challenge' => $ challenge , 'response' => $ response , ) + $ extraParams ) ; $ answers = explode ( "\n" , $ response [ 1 ] ) ; if ( trim ( $ answers [ 0 ] ) == 'true' ) { $ this -> valid = true ; } else { $ this -> valid = false ; $ this -> error = $ answers [ 1 ] ; } } return $ this ; }
2863	public function getLogging ( ) { $ logging = array ( ) ; foreach ( $ this -> files as $ logFile ) { $ logging [ $ logFile ] = $ this -> getLoggedContent ( $ logFile ) ; } return $ logging ; }
559	protected function buildAttributeCondition ( $ attribute , $ condition ) { if ( is_array ( $ condition ) ) { $ parts = [ ] ; foreach ( $ condition as $ operator => $ value ) { if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { if ( isset ( $ this -> conditionBuilders [ $ operator ] ) ) { $ method = $ this -> conditionBuilders [ $ operator ] ; if ( is_string ( $ method ) ) { $ callback = [ $ this , $ method ] ; } else { $ callback = $ method ; } $ parts [ ] = $ callback ( $ operator , $ value , $ attribute ) ; } else { $ parts [ ] = $ this -> buildOperatorCondition ( $ operator , $ value , $ attribute ) ; } } } if ( ! empty ( $ parts ) ) { if ( count ( $ parts ) > 1 ) { return array_merge ( [ 'AND' ] , $ parts ) ; } return array_shift ( $ parts ) ; } } return [ $ attribute => $ this -> filterAttributeValue ( $ attribute , $ condition ) ] ; }
11258	private function invoker ( ContainerInterface $ container ) { $ resolvers = new ResolverChain ( [ new ParameterNameContainerResolver ( $ container ) , new DefaultValueResolver ( ) , ] ) ; $ invoker = new Invoker ( $ resolvers , $ container ) ; return $ invoker ; }
12340	protected function print ( string $ msg , bool $ withTime = true ) : void { $ preMsg = '' ; if ( $ withTime ) { $ preMsg = ( new \ DateTime ( 'now' ) ) -> format ( 'H:i:s' ) . "\t" ; } echo "{$preMsg}{$msg}" . \ PHP_EOL ; }
7221	protected function createLabel ( $ content , $ type , $ format , $ size ) { $ label = new OrderShipmentLabel ( ) ; $ label -> setContent ( $ content ) -> setType ( $ type ) -> setFormat ( $ format ) -> setSize ( $ size ) ; return $ label ; }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
1197	private function htmlAttributesCallback ( $ name , $ value ) { if ( false === $ value || null === $ value ) { return '' ; } return ' ' . $ this -> renderHtmlAttribute ( $ name , $ value ) ; }
10803	public function deletePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = $ responseData [ 0 ] [ 'idPage' ] ; $ response = array ( 'idPage' => $ idPage ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_start' , $ this , $ response ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => 'Delete' , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => 'tr_melispagehistoric_action_text_Delete' ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_delete_end' , $ this , $ responseData ) ; }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
3680	private function injectChildTables ( & $ localMenu ) { $ parented = $ this -> viewCombination -> getParented ( ) ; $ lastCount = count ( $ parented ) ; while ( $ parented ) { foreach ( $ parented as $ metaModelName => $ child ) { foreach ( $ localMenu as $ groupName => $ modules ) { foreach ( $ modules as $ moduleName => $ module ) { if ( isset ( $ module [ 'tables' ] ) && in_array ( $ child [ 'meta' ] [ 'ptable' ] , $ module [ 'tables' ] ) ) { $ localMenu [ $ groupName ] [ $ moduleName ] [ 'tables' ] [ ] = $ metaModelName ; unset ( $ parented [ $ metaModelName ] ) ; break ; } } } } if ( count ( $ parented ) == $ lastCount ) { break ; } $ lastCount = count ( $ parented ) ; } }
10681	public function onBeforeWrite ( ) { if ( $ this -> owner -> Title ) { $ this -> owner -> URLSegment = $ this -> generateURLSegment ( $ this -> owner -> Title ) ; } parent :: onBeforeWrite ( ) ; }
6493	private function compareAcceptMediaTypeHeaders ( AcceptMediaTypeHeaderValue $ a , AcceptMediaTypeHeaderValue $ b ) : int { $ aQuality = $ a -> getQuality ( ) ; $ bQuality = $ b -> getQuality ( ) ; if ( $ aQuality < $ bQuality ) { return 1 ; } if ( $ aQuality > $ bQuality ) { return - 1 ; } $ aType = $ a -> getType ( ) ; $ bType = $ b -> getType ( ) ; $ aSubType = $ a -> getSubType ( ) ; $ bSubType = $ b -> getSubType ( ) ; if ( $ aType === '*' ) { if ( $ bType === '*' ) { return 0 ; } return 1 ; } if ( $ aSubType === '*' ) { if ( $ bSubType === '*' ) { return 0 ; } return 1 ; } if ( $ bType === '*' || $ bSubType === '*' ) { return - 1 ; } return 0 ; }
9594	public function makeSessionHandler ( ) { $ handler = $ this -> dic -> resolve ( 'Autarky\Http\SessionHandlerFactory' ) -> makeHandler ( $ this -> config -> get ( 'session.handler' ) ) ; if ( $ this -> config -> get ( 'session.write_check' ) === true ) { $ handler = new WriteCheckSessionHandler ( $ handler ) ; } return $ handler ; }
3914	protected function sortByName ( $ blnAscending = true ) { $ arrFiles = $ this -> foundFiles ; if ( ! $ arrFiles ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } \ uasort ( $ arrFiles , ( $ blnAscending ) ? '\basename_natcasecmp' : '\basename_natcasercmp' ) ; return $ this -> remapSorting ( $ arrFiles , $ this -> outputBuffer ) ; }
7153	public function add_rule ( $ access , $ role , $ action ) : void { $ roles = ( array ) $ role ; foreach ( $ roles as $ r ) { $ action = ( array ) $ action ; foreach ( $ action as $ a ) { $ this -> _rules [ $ r ] [ $ a ] = $ access ; } } }
5302	public static function unicodeToHex ( $ char ) { if ( ! is_string ( $ char ) || mb_strlen ( $ char , 'utf-8' ) !== 1 ) { throw new \ InvalidArgumentException ( '$char must be one single character' ) ; } $ unicode = unpack ( 'N' , mb_convert_encoding ( $ char , 'UCS-4BE' , 'UTF-8' ) ) ; return dechex ( $ unicode [ 1 ] ) ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
3273	public function get ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { if ( $ cache -> contains ( $ key ) ) { return $ cache -> get ( $ key ) ; } } $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; $ data = false ; foreach ( $ file as $ line ) { if ( $ line -> getKey ( ) == $ key ) { $ data = $ this -> decodeData ( $ line -> getData ( ) ) ; break ; } } if ( $ cache && $ data !== false ) { $ cache -> set ( $ key , $ data ) ; } return $ data ; }
5478	protected function setWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'radio' ) { $ this -> addRadioButton ( $ tag ) ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'checkbox' ) { $ this -> addCheckbox ( $ tag ) ; } else { $ this -> widgets [ ] = $ tag ; } }
8703	protected function registerViewComposers ( ) { $ core = $ this -> getCore ( ) ; view ( ) -> composer ( $ core -> config ( 'views.menu' ) , MenuComposer :: class ) ; view ( ) -> composer ( $ core -> config ( 'views.top' ) , TopComposer :: class ) ; return $ this ; }
4833	public function authorize_url ( $ options = null ) { if ( ! isset ( $ options [ 'redirect_uri' ] ) ) { throw new GoCardless_ArgumentsException ( 'redirect_uri required' ) ; } $ required_options = array ( "client_id" => $ this -> account_details [ 'app_id' ] , "scope" => "manage_merchant" , "response_type" => "code" ) ; $ params = array_merge ( $ required_options , $ options ) ; $ request = GoCardless_Utils :: generate_query_string ( $ params ) ; return $ this -> base_url . "/oauth/authorize/?" . $ request ; }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
5687	public function getFormBySubmit ( $ selector ) { for ( $ i = 0 ; $ i < count ( $ this -> forms ) ; $ i ++ ) { if ( $ this -> forms [ $ i ] -> hasSubmit ( $ selector ) ) { return $ this -> forms [ $ i ] ; } } return ; }
10872	public function existEmail ( string $ email ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'email' => $ email ] ) -> fetchSingle ( ) ; }
6126	public function addRole ( $ item ) { if ( ! ( $ item instanceof Role ) ) { if ( is_array ( $ item ) ) { try { $ item = new Role ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Role. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Role"!' , E_USER_WARNING ) ; } } $ this -> roles [ ] = $ item ; return $ this ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
9174	private function hierarchyToFlatArray ( $ items ) { $ flatArray = [ ] ; foreach ( $ items as $ item ) { $ flatArray [ ] = $ item -> getId ( ) ; if ( $ items -> getChildren ( ) -> count ( ) > 0 ) { $ flatArray = array_merge ( $ flatArray , $ this -> hierarchyToFlatArray ( $ items -> getChildren ( ) ) ) ; } } return $ flatArray ; }
10228	private function resolveModelName ( $ model ) { if ( $ model instanceof Controller ) { $ exploded = explode ( '\\' , get_class ( $ model ) ) ; $ controllerName = array_pop ( $ exploded ) ; return str_singular ( str_replace ( 'Controller' , '' , $ controllerName ) ) ; } else if ( $ model instanceof Eloquent ) { return get_class ( $ model ) ; } else { return $ model ; } }
11682	public function init ( ) { $ request = $ this -> getRequest ( ) ; if ( $ request -> isGet ( ) ) { $ action = $ this -> getParam ( 'id' ) ? 'get' : 'index' ; } else { $ action = $ this -> getParam ( 'x-method' , $ request -> getMethod ( ) ) ; } $ request -> setActionName ( $ action ) -> setDispatched ( false ) -> setParam ( 'action' , $ action ) ; }
8483	public static function getKernelVersion ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT WindowsVersion FROM Win32_Process WHERE Handle = 0" ) as $ process ) { return $ process -> WindowsVersion ; } return "Unknown" ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
4207	private function getPropCommentInfo ( \ ReflectionProperty $ reflectionProperty ) { $ name = $ reflectionProperty -> name ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionProperty ) ; $ info = array ( 'type' => null , 'desc' => $ phpDoc [ 'summary' ] ? $ phpDoc [ 'summary' ] : null , ) ; if ( isset ( $ phpDoc [ 'var' ] ) ) { if ( \ count ( $ phpDoc [ 'var' ] ) == 1 ) { $ var = $ phpDoc [ 'var' ] [ 0 ] ; } else { foreach ( $ phpDoc [ 'var' ] as $ var ) { if ( $ var [ 'name' ] == $ name ) { break ; } } } $ info [ 'type' ] = $ var [ 'type' ] ; if ( ! $ info [ 'desc' ] ) { $ info [ 'desc' ] = $ var [ 'desc' ] ; } elseif ( $ var [ 'desc' ] ) { $ info [ 'desc' ] = $ info [ 'desc' ] . ': ' . $ var [ 'desc' ] ; } } return $ info ; }
802	public static function shouldBeTogether ( Tag $ first , Tag $ second ) { $ firstName = $ first -> getName ( ) ; $ secondName = $ second -> getName ( ) ; if ( $ firstName === $ secondName ) { return true ; } foreach ( self :: $ groups as $ group ) { if ( \ in_array ( $ firstName , $ group , true ) && \ in_array ( $ secondName , $ group , true ) ) { return true ; } } return false ; }
9316	public static function filter ( $ region ) { $ r = array ( 'x' => intval ( $ region [ 'x' ] ) , 'y' => intval ( $ region [ 'y' ] ) , 'width' => intval ( $ region [ 'w' ] ) , 'height' => intval ( $ region [ 'h' ] ) ) ; return array ( new ezcImageFilter ( 'crop' , $ r ) ) ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
1607	public function save ( $ uri , $ to , $ type , $ siteId = null , $ id = null ) { if ( $ siteId === 'null' ) $ siteId = null ; if ( $ id ) { $ record = RedirectRecord :: findOne ( compact ( 'id' ) ) ; if ( ! $ record ) return 'Unable to find redirect with ID: ' . $ id ; } else { $ existing = RedirectRecord :: findOne ( compact ( 'uri' , 'siteId' ) ) ; if ( $ existing ) return 'A redirect with that URI already exists!' ; $ record = new RedirectRecord ( ) ; } $ record -> uri = $ uri ; $ record -> to = $ to ; $ record -> type = $ type ; if ( $ siteId !== false ) $ record -> siteId = $ siteId ; if ( ! $ record -> save ( ) ) return $ record -> getErrors ( ) ; return $ record -> id ; }
4502	public function after ( DOMNode $ node ) : void { $ this -> parentNode -> insertBefore ( $ node , $ this -> nextSibling ) ; }
9376	protected function check ( array $ files , $ path , $ source , $ template ) { $ file = null ; foreach ( ( array ) $ files as $ key => $ value ) { $ filepath = ( string ) str_replace ( $ path , $ source , $ value ) ; $ filepath = str_replace ( '\\' , '/' , ( string ) $ filepath ) ; $ filepath = ( string ) preg_replace ( '/^\d\//i' , '' , $ filepath ) ; $ exists = ( string ) $ filepath === $ template ; $ lowercase = strtolower ( $ filepath ) === $ template ; ( $ exists || $ lowercase ) && $ file = $ value ; } return $ file ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
1638	protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; }
12273	public static function cast ( $ date ) { return $ date instanceof self ? $ date : new self ( $ date -> format ( self :: ISO8601 ) , $ date -> getTimezone ( ) ) ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
5683	public function getUrls ( ) { $ all = array ( ) ; foreach ( $ this -> links as $ link ) { $ url = $ this -> getUrlFromLink ( $ link ) ; $ all [ ] = $ url -> asString ( ) ; } return $ all ; }
3709	protected function getFrontendFilterOptions ( ) { $ objFrontendFilterOptions = new FrontendFilterOptions ( ) ; $ objFrontendFilterOptions -> setAutoSubmit ( $ this -> objFilterConfig -> metamodel_fef_autosubmit ? true : false ) ; $ objFrontendFilterOptions -> setHideClearFilter ( $ this -> objFilterConfig -> metamodel_fef_hideclearfilter ? true : false ) ; $ objFrontendFilterOptions -> setShowCountValues ( $ this -> objFilterConfig -> metamodel_available_values ? true : false ) ; return $ objFrontendFilterOptions ; }
2258	protected function prepareForWidget ( $ arrData , $ strName , $ varValue = null , $ strField = '' , $ strTable = '' ) { @ trigger_error ( 'Using Controller::prepareForWidget() has been deprecated and will no longer work in Contao 5.0. Use Widget::getAttributesFromDca() instead.' , E_USER_DEPRECATED ) ; return Widget :: getAttributesFromDca ( $ arrData , $ strName , $ varValue , $ strField , $ strTable ) ; }
455	public function dropColumn ( $ table , $ column ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP COLUMN ' . $ this -> db -> quoteColumnName ( $ column ) ; }
389	public function link ( $ attribute , $ options = [ ] ) { if ( ( $ direction = $ this -> getAttributeOrder ( $ attribute ) ) !== null ) { $ class = $ direction === SORT_DESC ? 'desc' : 'asc' ; if ( isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] .= ' ' . $ class ; } else { $ options [ 'class' ] = $ class ; } } $ url = $ this -> createUrl ( $ attribute ) ; $ options [ 'data-sort' ] = $ this -> createSortParam ( $ attribute ) ; if ( isset ( $ options [ 'label' ] ) ) { $ label = $ options [ 'label' ] ; unset ( $ options [ 'label' ] ) ; } else { if ( isset ( $ this -> attributes [ $ attribute ] [ 'label' ] ) ) { $ label = $ this -> attributes [ $ attribute ] [ 'label' ] ; } else { $ label = Inflector :: camel2words ( $ attribute ) ; } } return Html :: a ( $ label , $ url , $ options ) ; }
6688	public function isPostCheck ( $ redirectUrl = null ) { if ( $ this -> getRequest ( ) -> isPost ) { return true ; } if ( is_null ( $ redirectUrl ) ) { return false ; } $ this -> sendTerminalResponse ( $ redirectUrl ) ; }
11096	public static function sendHipChatMessage ( $ room , $ token , $ text , $ notify = true , $ format = 'text' ) { $ session = curl_init ( ) ; curl_setopt ( $ session , CURLOPT_URL , 'https://api.hipchat.com/v2/room/' . $ room . '/notification?auth_token=' . $ token ) ; curl_setopt ( $ session , CURLOPT_POST , 1 ) ; curl_setopt ( $ session , CURLOPT_POSTFIELDS , http_build_query ( [ 'message' => $ text , 'message_format' => $ format , 'notify' => $ notify , ] ) ) ; curl_setopt ( $ session , CURLOPT_RETURNTRANSFER , true ) ; curl_exec ( $ session ) ; curl_close ( $ session ) ; }
8044	public static function setProcessTitle ( $ title , array $ replacements = array ( ) ) { if ( trim ( $ title ) == '' || PHP_OS == 'Darwin' ) { return ; } $ title = preg_replace_callback ( '/\%([a-z0-9]+)\%/i' , function ( $ match ) use ( $ replacements ) { if ( isset ( $ replacements [ $ match [ 1 ] ] ) ) { return $ replacements [ $ match [ 1 ] ] ; } return $ match [ 0 ] ; } , $ title ) ; $ title = preg_replace ( '/[^a-z0-9-_.: \\\\\\]\\[]/i' , '' , $ title ) ; if ( function_exists ( 'cli_set_process_title' ) ) { cli_set_process_title ( $ title ) ; } elseif ( function_exists ( 'setproctitle' ) ) { setproctitle ( $ title ) ; } }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
10663	public function setParamType ( $ type ) { if ( ! is_string ( $ type ) || ! in_array ( $ type , [ self :: PARAM_MULTIPART , self :: PARAM_FORM ] ) ) { throw new InvalidArgumentException ( sprintf ( "Invalid parameter form type, form type only allowed $1s and $2s" , self :: PARAM_FORM , self :: PARAM_MULTIPART ) , E_USER_ERROR ) ; } $ this -> currentParamType = $ type ; $ reverse_params = $ type == self :: PARAM_FORM ? self :: PARAM_MULTIPART : self :: PARAM_FORM ; $ reverse_params_value = isset ( $ this -> configs [ $ reverse_params ] ) ? $ this -> configs [ $ reverse_params ] : null ; $ params_value = isset ( $ this -> configs [ $ type ] ) ? $ this -> configs [ $ type ] : null ; unset ( $ this -> configs [ self :: PARAM_FORM ] , $ this -> configs [ self :: PARAM_MULTIPART ] ) ; $ this -> configs [ $ type ] = is_array ( $ reverse_params_value ) ? $ reverse_params_value : ( is_array ( $ params_value ) ? $ params_value : [ ] ) ; return $ this -> buildConfigClient ( ) ; }
5655	public function parse ( $ response ) { $ this -> page = new SimplePage ( $ response ) ; $ tidied = tidy_parse_string ( $ input = $ this -> insertGuards ( $ response -> getContent ( ) ) , array ( 'output-xml' => false , 'wrap' => '0' , 'indent' => 'no' ) , 'latin1' ) ; $ this -> walkTree ( $ tidied -> html ( ) ) ; $ this -> attachLabels ( $ this -> widgets_by_id , $ this -> labels ) ; $ this -> page -> setForms ( $ this -> forms ) ; $ page = $ this -> page ; $ this -> free ( ) ; return $ page ; }
2541	protected function analyzeWithErrCodeCategoryMsgQuery ( SendResult $ response , $ qErr , $ qCat , $ qMsg , $ errLevel = null ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ errorCatNode = $ domXpath -> query ( $ qCat ) -> item ( 0 ) ; if ( $ errorCatNode instanceof \ DOMNode ) { $ analyzeResponse -> status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ errLevel ) ; } return $ analyzeResponse ; }
8087	public function getConnection ( ) { if ( ! ( $ this -> log instanceof Log ) ) { $ this -> log = new Log ( 'DB' ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } $ this -> log -> report ( 'Connecting to database...' ) ; try { $ this -> connection = new \ PDO ( $ this -> generateDSN ( ) , $ this -> user , $ this -> password ) ; $ this -> log -> report ( 'Connected to database.' ) ; } catch ( \ PDOException $ e ) { $ this -> log -> error ( 'Failed to connect to database, [SQLSTATE] ' . $ e -> getCode ( ) ) ; } if ( $ this -> connection instanceof \ PDO ) { return $ this -> connection ; } else { return false ; } }
2486	public function commit ( $ flush = false ) { $ payload = $ flush ? '<commit/>' : '<commit softCommit="true"/>' ; foreach ( $ this -> endpointResolver -> getEndpoints ( ) as $ endpointName ) { $ result = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) , '/update' , new Message ( array ( 'Content-Type' => 'text/xml' , ) , $ payload ) ) ; if ( $ result -> headers [ 'status' ] !== 200 ) { throw new RuntimeException ( 'Wrong HTTP status received from Solr: ' . $ result -> headers [ 'status' ] . var_export ( $ result , true ) ) ; } } }
12425	public function getAuthorizerToken ( $ appId , $ refreshToken ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ appId , 'authorizer_refresh_token' => $ refreshToken , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_TOKEN , $ params ] ) ; }
4117	public function isWithinCachedBlock ( Mage_Core_Block_Abstract $ block ) { $ step = $ block ; $ i = 0 ; while ( $ i ++ < 20 && $ step instanceof Mage_Core_Block_Abstract ) { if ( ! is_null ( $ step -> getCacheLifetime ( ) ) ) { return true ; } $ step = $ step -> getParentBlock ( ) ; } return false ; }
5715	public function doSaveAndAdd ( $ data , $ form ) { return $ this -> saveAndRedirect ( $ data , $ form , $ this -> owner -> Link ( "addnew" ) ) ; }
8830	protected function getSelectedValue ( $ value , $ selected ) { if ( is_array ( $ selected ) ) { return in_array ( $ value , $ selected , true ) ? 'selected' : null ; } return ( ( string ) $ value == ( string ) $ selected ) ? 'selected' : null ; }
11286	protected function _getQueryObjectForRelation ( $ attribute ) { $ def = $ this -> model_attributes [ $ attribute ] ; if ( ! isset ( $ def [ 'model' ] ) && ! isset ( $ def [ 'models' ] ) ) { return $ this -> getDbAdaptor ( ) ; } $ relatedObj = isset ( $ def [ 'models' ] ) ? $ this -> fetchRelatedObj ( $ def [ 'models' ] ) : $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ query = $ relatedObj -> getDbAdaptor ( ) ; if ( ! isset ( $ def [ 'via' ] ) && ! isset ( $ def [ 'using' ] ) ) { $ relTable = $ this -> getRelationTableName ( $ relatedObj , $ attribute , $ this -> model_attributes [ $ attribute ] ) ; if ( ! $ query -> tableExists ( $ relTable ) ) { $ query = $ this -> getDbAdaptor ( ) ; } } return $ query ; }
8158	public function register ( $ isSuperAdmin = FALSE , $ status = 1 ) { if ( $ this -> getIsNewRecord ( ) == FALSE ) { throw new RuntimeException ( 'Calling "' . __CLASS__ . '::' . __METHOD__ . '" on existing user' ) ; } $ this -> super_admin = $ isSuperAdmin ? 1 : 0 ; $ this -> status = $ status ; if ( $ this -> save ( ) ) { return TRUE ; } return FALSE ; }
4574	public function getProperties ( Localizable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Locale :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
7576	protected function configureData ( $ data ) { if ( is_string ( $ data ) ) { if ( ! empty ( $ this -> Options ) ) { $ fileField = end ( $ this -> Options ) ; $ data = array ( $ fileField => $ data ) ; } else { throw new RequiredOptionsException ( get_called_class ( ) , "Options are required, when passing String for data." ) ; } } if ( is_array ( $ data ) ) { foreach ( $ data as $ key => $ value ) { if ( ! array_key_exists ( $ key , $ this -> _REQUIRED_DATA ) ) { $ data [ $ key ] = $ this -> setFileFieldValue ( $ value ) ; } } } parent :: configureData ( $ data ) ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
4367	protected function emailErr ( Event $ error ) { $ dateTimeFmt = 'Y-m-d H:i:s (T)' ; $ errMsg = $ error [ 'message' ] ; if ( $ error [ 'isHtml' ] ) { $ errMsg = \ strip_tags ( $ errMsg ) ; $ errMsg = \ htmlspecialchars_decode ( $ errMsg ) ; } $ countSince = $ error [ 'stats' ] [ 'countSince' ] ; $ isCli = $ this -> isCli ( ) ; $ subject = $ isCli ? 'Error: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Website Error: ' . $ _SERVER [ 'SERVER_NAME' ] ; $ subject .= ': ' . $ errMsg . ( $ countSince ? ' (' . $ countSince . 'x)' : '' ) ; $ emailBody = '' ; if ( ! empty ( $ countSince ) ) { $ dateTimePrev = \ date ( $ dateTimeFmt , $ error [ 'stats' ] [ 'tsEmailed' ] ) ; $ emailBody .= 'Error has occurred ' . $ countSince . ' times since last email (' . $ dateTimePrev . ').' . "\n\n" ; } $ emailBody .= '' . 'datetime: ' . \ date ( $ dateTimeFmt ) . "\n" . 'errormsg: ' . $ errMsg . "\n" . 'errortype: ' . $ error [ 'type' ] . ' (' . $ error [ 'typeStr' ] . ')' . "\n" . 'file: ' . $ error [ 'file' ] . "\n" . 'line: ' . $ error [ 'line' ] . "\n" . '' ; if ( ! $ isCli ) { $ emailBody .= '' . 'remote_addr: ' . $ _SERVER [ 'REMOTE_ADDR' ] . "\n" . 'http_host: ' . $ _SERVER [ 'HTTP_HOST' ] . "\n" . 'referer: ' . ( isset ( $ _SERVER [ 'HTTP_REFERER' ] ) ? $ _SERVER [ 'HTTP_REFERER' ] : 'null' ) . "\n" . 'request_uri: ' . $ _SERVER [ 'REQUEST_URI' ] . "\n" . '' ; } if ( ! empty ( $ _POST ) ) { $ emailBody .= 'post params: ' . \ var_export ( $ _POST , true ) . "\n" ; } if ( $ error [ 'type' ] & $ this -> cfg [ 'emailTraceMask' ] ) { $ backtraceStr = $ this -> backtraceStr ( $ error ) ; $ emailBody .= "\n" . ( $ backtraceStr ? 'backtrace: ' . $ backtraceStr : 'no backtrace' ) ; } $ this -> email ( $ this -> cfg [ 'emailTo' ] , $ subject , $ emailBody ) ; return ; }
12241	public function addClass ( $ class ) { if ( ! $ this -> hasClass ( $ class ) ) { $ current = ( string ) $ this [ 'class' ] ; if ( $ current !== '' && substr ( $ current , - 1 ) !== ' ' ) { $ this [ 'class' ] .= ' ' ; } $ this [ 'class' ] .= $ class ; } return $ this ; }
3589	protected function saveMeta ( ) { foreach ( $ this -> getMetaAttributes ( ) as $ attribute ) { if ( is_null ( $ attribute -> getValue ( ) ) ) { $ attribute -> delete ( ) ; } else { $ this -> metaAttributes ( ) -> save ( $ attribute ) ; } } }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
7206	public function addTaxAdjustment ( Adjustment $ tax ) : void { foreach ( $ this -> taxes as $ t ) { if ( $ t -> isSameAs ( $ tax ) ) { $ t -> addAmount ( $ tax -> getAmount ( ) ) ; return ; } } $ this -> taxes [ ] = clone $ tax ; }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
1010	private function readName ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; while ( $ code && ( $ code === 95 || $ code >= 48 && $ code <= 57 || $ code >= 65 && $ code <= 90 || $ code >= 97 && $ code <= 122 ) ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } return new Token ( Token :: NAME , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
9088	public function slurp ( ) : string { $ str = "" ; while ( $ this -> ready ( ) ) { $ str .= $ this -> read ( $ this -> count ( ) ) ; } return $ str ; }
4304	public function profileEnd ( $ name = null ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'name' => null ) , array ( 'name' ) ) ; if ( $ meta [ 'name' ] === null ) { \ end ( $ this -> data [ 'profileInstances' ] ) ; $ meta [ 'name' ] = \ key ( $ this -> data [ 'profileInstances' ] ) ; } $ name = $ meta [ 'name' ] ; if ( isset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ) { $ instance = $ this -> data [ 'profileInstances' ] [ $ name ] ; $ data = $ instance -> end ( ) ; $ caption = 'Profile \'' . $ name . '\' Results' ; if ( $ data ) { $ args = array ( $ data ) ; $ meta [ 'sortable' ] = true ; $ meta [ 'caption' ] = $ caption ; $ meta [ 'totalCols' ] = array ( 'ownTime' ) ; $ meta [ 'columns' ] = array ( ) ; } else { $ args = array ( $ caption , 'no data' ) ; } unset ( $ this -> data [ 'profileInstances' ] [ $ name ] ) ; } else { $ args = array ( $ name !== null ? 'profileEnd: No such Profile: ' . $ name : 'profileEnd: Not currently profiling' ) ; } $ this -> appendLog ( __FUNCTION__ , $ args , $ meta ) ; }
10154	private function readPageSetup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paperSize = self :: getUInt2d ( $ recordData , 0 ) ; $ scale = self :: getUInt2d ( $ recordData , 2 ) ; $ fitToWidth = self :: getUInt2d ( $ recordData , 6 ) ; $ fitToHeight = self :: getUInt2d ( $ recordData , 8 ) ; $ isPortrait = ( 0x0002 & self :: getUInt2d ( $ recordData , 10 ) ) >> 1 ; $ isNotInit = ( 0x0004 & self :: getUInt2d ( $ recordData , 10 ) ) >> 2 ; if ( ! $ isNotInit ) { $ this -> phpSheet -> getPageSetup ( ) -> setPaperSize ( $ paperSize ) ; switch ( $ isPortrait ) { case 0 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_LANDSCAPE ) ; break ; case 1 : $ this -> phpSheet -> getPageSetup ( ) -> setOrientation ( PageSetup :: ORIENTATION_PORTRAIT ) ; break ; } $ this -> phpSheet -> getPageSetup ( ) -> setScale ( $ scale , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToPage ( ( bool ) $ this -> isFitToPages ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToWidth ( $ fitToWidth , false ) ; $ this -> phpSheet -> getPageSetup ( ) -> setFitToHeight ( $ fitToHeight , false ) ; } $ marginHeader = self :: extractNumber ( substr ( $ recordData , 16 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setHeader ( $ marginHeader ) ; $ marginFooter = self :: extractNumber ( substr ( $ recordData , 24 , 8 ) ) ; $ this -> phpSheet -> getPageMargins ( ) -> setFooter ( $ marginFooter ) ; } }
11695	protected function bustCacheBalls ( string $ asset_contents ) { $ asset_ext = $ this -> destination -> getExtension ( ) ; $ asset_name = $ this -> destination -> getBasename ( '.' . $ asset_ext ) ; $ asset_name_quoted = preg_quote ( $ asset_name , '/' ) ; $ search_for = '/' . $ asset_name_quoted . '\..*?\.' . $ asset_ext . '|' . $ asset_name_quoted . '\..*?\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.min\.' . $ asset_ext . '|' . $ asset_name_quoted . '\.' . $ asset_ext . '/' ; $ replace_with = $ asset_name . '.' . md5 ( $ asset_contents ) . '.' . $ asset_ext ; foreach ( $ this -> template as $ templateFile ) { $ this -> printTaskInfo ( 'Updating template file - <info>' . $ templateFile . '</info>' ) ; $ this -> collectionBuilder ( ) -> taskReplaceInFile ( $ templateFile ) -> regex ( $ search_for ) -> to ( $ replace_with ) -> run ( ) ; } $ asset_base_dir = $ this -> destination -> getPath ( ) ; $ this -> destination = new SplFileInfo ( $ asset_base_dir . '/' . $ replace_with ) ; $ files_to_delete = new Finder ( ) ; $ files_to_delete -> files ( ) ; $ files_to_delete -> name ( $ asset_name . '.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext ) ; $ files_to_delete -> name ( $ asset_name . '.*.' . $ asset_ext . '.gz' ) ; $ files_to_delete -> in ( $ asset_base_dir ) ; $ files_to_delete -> depth ( '== 0' ) ; foreach ( $ files_to_delete as $ file_to_delete ) { unlink ( $ file_to_delete -> getPathname ( ) ) ; } }
7910	public function init ( ) { parent :: init ( ) ; Html :: addCssClass ( $ this -> options , 'ui' ) ; if ( ! isset ( $ this -> options [ 'id' ] ) ) { $ this -> options [ 'id' ] = $ this -> getId ( ) ; } $ this -> registerTranslations ( ) ; }
6169	protected function writeException ( $ exception ) { $ this -> writeNewLine ( ) ; do { $ exceptionStack [ ] = $ exception ; } while ( $ exception = $ exception -> getPreviousWrapped ( ) ) ; foreach ( explode ( "\n" , $ exception = array_shift ( $ exceptionStack ) ) as $ line ) { if ( $ exception && false !== $ pos = strpos ( $ line , $ exception -> getClassName ( ) . ': ' ) ) { $ whitespace = str_repeat ( ' ' , ( $ pos += strlen ( $ exception -> getClassName ( ) ) ) + 2 ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , sprintf ( ' %s ' , substr ( $ line , 0 , $ pos ) ) , false ) ; $ this -> writeWithColor ( 'fg-red' , substr ( $ line , $ pos + 1 ) ) ; $ this -> writeWithColor ( 'bg-red,fg-white' , $ whitespace ) ; $ exception = array_shift ( $ exceptionStack ) ; continue ; } $ this -> writeWithColor ( 'fg-red' , $ line ) ; } }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
5091	private function asScalarSubQuery ( $ callback , $ default = false ) { $ sql = $ this -> sql ; $ this -> sql = $ callback ( $ sql ) ; $ result = $ this -> queryScalar ( null ) ; $ this -> sql = $ sql ; return ( is_null ( $ result ) ? $ default : $ result ) ; }
9070	protected static function parseEachPart ( array $ parts , $ format ) { $ lastPartKey = count ( $ parts ) - 1 ; for ( $ p = 0 ; $ p <= $ lastPartKey ; $ p ++ ) { $ parsedPart = static :: parse ( $ parts [ $ p ] , $ format ) ; $ numNewParts = count ( $ parsedPart ) ; if ( $ numNewParts > 1 ) { array_splice ( $ parts , $ p , 1 , $ parsedPart ) ; $ p += $ numNewParts ; $ lastPartKey += $ numNewParts - 1 ; } } return $ parts ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
12938	public function setMin ( $ value ) { $ this -> setTag ( 'min' , $ value ) ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'min' , $ value ) ; } }
9569	public function setContainer ( ContainerInterface $ container ) { $ this -> container = $ container ; $ container -> instance ( 'Autarky\Application' , $ this ) ; $ container -> instance ( 'Symfony\Component\HttpFoundation\RequestStack' , $ this -> requests ) ; }
8369	public function archiveAction ( string $ production_slug , AuthorizationCheckerInterface $ auth , PaginatorInterface $ paginator , Request $ request ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_EDITOR' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ query = $ this -> em -> getRepository ( Post :: class ) -> getAllInactiveQuery ( $ production ) ; $ posts = $ paginator -> paginate ( $ query , $ request -> query -> getInt ( 'page' , 1 ) ) ; return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Board/archive.html.twig' , [ 'production' => $ production , 'posts' => $ posts , ] ) ) ; }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
9898	private function convertFunction ( $ token , $ num_args ) { $ args = $ this -> functions [ $ token ] [ 1 ] ; if ( $ args >= 0 ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgFuncV' ] , $ this -> functions [ $ token ] [ 0 ] ) ; } if ( $ args == - 1 ) { return pack ( 'CCv' , $ this -> ptg [ 'ptgFuncVarV' ] , $ num_args , $ this -> functions [ $ token ] [ 0 ] ) ; } }
977	protected function getUrlFromName ( string $ name ) { if ( Str :: endsWith ( $ name , 'Job' ) ) { $ name = substr ( $ name , 0 , - 3 ) ; } return strtolower ( preg_replace ( '/(?<!^)[A-Z]/' , '-$0' , $ name ) ) ; }
1469	public static function httpErrorStatus ( $ errors , int $ default = SymfonyResponse :: HTTP_BAD_REQUEST ) : int { if ( $ errors instanceof ErrorInterface ) { $ errors = [ $ errors ] ; } $ statuses = collect ( $ errors ) -> reject ( function ( ErrorInterface $ error ) { return is_null ( $ error -> getStatus ( ) ) ; } ) -> map ( function ( ErrorInterface $ error ) { return ( int ) $ error -> getStatus ( ) ; } ) -> unique ( ) ; if ( 2 > count ( $ statuses ) ) { return $ statuses -> first ( ) ? : $ default ; } $ only4xx = $ statuses -> every ( function ( int $ status ) { return 400 <= $ status && 499 >= $ status ; } ) ; return $ only4xx ? SymfonyResponse :: HTTP_BAD_REQUEST : SymfonyResponse :: HTTP_INTERNAL_SERVER_ERROR ; }
1741	public function checkFilename ( $ varValue , Contao \ DataContainer $ dc ) { $ varValue = str_replace ( '"' , '' , $ varValue ) ; if ( strpos ( $ varValue , '/' ) !== false || preg_match ( '/\.$/' , $ varValue ) ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidName' ] ) ; } if ( $ dc -> activeRecord && $ varValue != '' ) { $ intMaxlength = $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'maxlength' ] ; if ( $ dc -> activeRecord -> type == 'file' ) { $ intMaxlength -= ( \ strlen ( $ dc -> activeRecord -> extension ) + 1 ) ; } if ( $ intMaxlength && Patchwork \ Utf8 :: strlen ( $ varValue ) > $ intMaxlength ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'maxlength' ] , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'label' ] [ 0 ] , $ intMaxlength ) ) ; } } return $ varValue ; }
5199	public function validateOptions ( array $ options ) { foreach ( $ options as $ option => $ value ) { if ( ! in_array ( $ option , $ this -> allowedOptions ) ) throw new InvalidOptionException ( "Option [$option] is not valid" ) ; } return $ this ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
685	public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
11661	public static function readFromFile ( $ file ) { $ real_file = File :: asFile ( $ file ) ; if ( $ real_file -> exists ( ) ) return self :: readFromString ( $ file -> getContent ( ) ) ; else return array ( ) ; }
5685	protected function getUrlFromLink ( $ link ) { $ url = $ this -> expandUrl ( $ link -> getHref ( ) ) ; if ( $ link -> getAttribute ( 'target' ) ) { $ url -> setTarget ( $ link -> getAttribute ( 'target' ) ) ; } return $ url ; }
4315	protected function getGroupDepth ( ) { $ depth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] as $ stack ) { $ depth += \ count ( $ stack ) ; } $ depth += \ count ( $ this -> data [ 'groupPriorityStack' ] ) ; return $ depth ; }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
10366	public function logout ( ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'logout' ) ) -> dispatchNow ( new LogoutJob ) ; return redirect ( ) -> route ( config ( '_auth.logout.redirect' ) ) ; }
4205	private function getParams ( \ ReflectionMethod $ reflectionMethod , $ phpDoc = array ( ) ) { $ paramArray = array ( ) ; $ params = $ reflectionMethod -> getParameters ( ) ; if ( empty ( $ phpDoc ) ) { $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; } foreach ( $ params as $ i => $ reflectionParameter ) { $ nameNoPrefix = $ reflectionParameter -> getName ( ) ; $ name = '$' . $ nameNoPrefix ; if ( \ method_exists ( $ reflectionParameter , 'isVariadic' ) && $ reflectionParameter -> isVariadic ( ) ) { $ name = '...' . $ name ; } if ( $ reflectionParameter -> isPassedByReference ( ) ) { $ name = '&' . $ name ; } $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( $ reflectionParameter -> isDefaultValueAvailable ( ) ) { $ defaultValue = $ reflectionParameter -> getDefaultValue ( ) ; if ( \ version_compare ( PHP_VERSION , '5.4.6' , '>=' ) && $ reflectionParameter -> isDefaultValueConstant ( ) ) { $ constantName = $ reflectionParameter -> getDefaultValueConstantName ( ) ; } } $ paramInfo = array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , 'desc' => null , 'isOptional' => $ reflectionParameter -> isOptional ( ) , 'name' => $ name , 'type' => $ this -> getParamTypeHint ( $ reflectionParameter ) , ) ; if ( isset ( $ phpDoc [ 'param' ] [ $ i ] ) ) { $ paramInfo [ 'desc' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'desc' ] ; if ( ! isset ( $ paramInfo [ 'type' ] ) ) { $ paramInfo [ 'type' ] = $ phpDoc [ 'param' ] [ $ i ] [ 'type' ] ; } } $ paramArray [ $ nameNoPrefix ] = $ paramInfo ; } return $ paramArray ; }
3365	public function structure ( $ args , $ assoc_args ) { global $ wp_rewrite ; $ blog_prefix = '' ; $ prefix = $ blog_prefix ; if ( is_multisite ( ) && ! is_subdomain_install ( ) && is_main_site ( ) ) { $ blog_prefix = '/blog' ; } $ permalink_structure = ( 'default' === $ args [ 0 ] ) ? '' : $ args [ 0 ] ; if ( ! empty ( $ permalink_structure ) ) { $ permalink_structure = preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ permalink_structure ) ) ; if ( $ prefix && $ blog_prefix ) { $ permalink_structure = $ prefix . preg_replace ( '#^/?index\.php#' , '' , $ permalink_structure ) ; } else { $ permalink_structure = $ blog_prefix . $ permalink_structure ; } } $ wp_rewrite -> set_permalink_structure ( $ permalink_structure ) ; if ( isset ( $ assoc_args [ 'category-base' ] ) ) { $ category_base = $ assoc_args [ 'category-base' ] ; if ( ! empty ( $ category_base ) ) { $ category_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ category_base ) ) ; } $ wp_rewrite -> set_category_base ( $ category_base ) ; } if ( isset ( $ assoc_args [ 'tag-base' ] ) ) { $ tag_base = $ assoc_args [ 'tag-base' ] ; if ( ! empty ( $ tag_base ) ) { $ tag_base = $ blog_prefix . preg_replace ( '#/+#' , '/' , '/' . str_replace ( '#' , '' , $ tag_base ) ) ; } $ wp_rewrite -> set_tag_base ( $ tag_base ) ; } self :: apache_modules ( ) ; WP_CLI :: success ( 'Rewrite structure set.' ) ; $ new_assoc_args = [ ] ; $ cmd = 'rewrite flush' ; if ( Utils \ get_flag_value ( $ assoc_args , 'hard' ) ) { $ cmd .= ' --hard' ; $ new_assoc_args [ 'hard' ] = true ; if ( ! in_array ( 'mod_rewrite' , ( array ) WP_CLI :: get_config ( 'apache_modules' ) , true ) ) { WP_CLI :: warning ( 'Regenerating a .htaccess file requires special configuration. See usage docs.' ) ; } } $ process_run = WP_CLI :: runcommand ( $ cmd ) ; if ( ! empty ( $ process_run -> stderr ) ) { WP_CLI :: warning ( substr ( $ process_run -> stderr , 9 ) ) ; } }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
9303	public function setSuccessLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`successLogLifetime` expects integer value!' ) ; } $ this -> options [ 'successLogLifetime' ] = ( int ) $ time ; return $ this ; }
6395	public function init ( ) { parent :: init ( ) ; $ this -> path = Yii :: getAlias ( $ this -> path ) ; FileHelper :: createDirectory ( $ this -> path , $ this -> dirMode , true ) ; }
8844	private function log ( string $ message , array $ context = [ ] ) : void { $ this -> logger -> log ( $ this -> logLevel , $ message , $ context ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
8858	private function _absoluteSymlinkWithFallback ( string $ originDir , string $ targetDir ) : string { try { $ this -> _symlink ( $ originDir , $ targetDir ) ; $ method = AssetsInstallCommand :: METHOD_ABSOLUTE_SYMLINK ; } catch ( IOException $ e ) { $ method = $ this -> _hardCopy ( $ originDir , $ targetDir ) ; } return $ method ; }
11381	public function render ( FormInterface $ form ) { if ( method_exists ( $ form , 'prepare' ) ) { $ form -> prepare ( ) ; } if ( ! $ form -> getAttribute ( 'role' ) ) { $ form -> setAttribute ( 'role' , 'form' ) ; } $ formContent = '' ; foreach ( $ form as $ element ) { if ( $ element instanceof FieldsetInterface ) { $ formContent .= $ this -> getView ( ) -> formCollection ( $ element ) ; } else { $ element -> setOption ( '_form' , $ form ) ; $ formContent .= $ this -> getView ( ) -> formRow ( $ element ) ; } } return $ this -> openTag ( $ form ) . $ formContent . $ this -> closeTag ( ) ; }
8271	protected function getKeyEncoder ( $ lockData ) { if ( isset ( $ lockData [ 'encoder' ] ) && is_string ( $ lockData [ 'encoder' ] ) ) { $ name = $ lockData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } try { $ instance = $ this -> picoAuth -> getContainer ( ) -> get ( $ name ) ; } catch ( \ Exception $ e ) { throw new \ RuntimeException ( "Specified PageLock encoder not resolvable." ) ; } return $ instance ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
1977	public function onPreviewUrlCreate ( PreviewUrlCreateEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || 'news' !== $ event -> getKey ( ) ) { return ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_news' === $ request -> query -> get ( 'table' ) && ! $ request -> query -> has ( 'act' ) ) { return ; } if ( null === ( $ newsModel = $ this -> getNewsModel ( $ this -> getId ( $ event , $ request ) ) ) ) { return ; } $ event -> setQuery ( 'news=' . $ newsModel -> id ) ; }
2678	public function updateAclItem ( $ aclId , $ aclItemId , $ itemValue , $ negated , $ comment = '' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PATCH , json_encode ( $ body ) ) ; return $ result ; }
6899	public function regenerate ( $ delete_old = false ) { if ( $ this -> is_active ( ) ) { @ session_regenerate_id ( $ delete_old ) ; } else { $ this -> open ( ) ; } return session_id ( ) ; }
5386	public function isLabel ( $ label ) { for ( $ i = 0 , $ count = count ( $ this -> widgets ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> widgets [ $ i ] -> isLabel ( $ label ) ) { return true ; } } return false ; }
2273	public function getModules ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'FE_MOD' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
1275	private function sendRequest ( $ request , $ endpoint , $ operation , $ wsdl ) { $ endpointurl = $ this -> compileEndpointUrl ( $ endpoint ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ this -> createAccess ( ) , $ request , $ endpointurl , $ operation , $ wsdl ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } return $ this -> formatResponse ( $ response ) ; }
9159	protected function redirect ( $ controller = null , $ action = null ) { if ( null === $ controller ) { $ controller = Application :: getInstance ( ) -> getDefaultController ( ) ; } if ( null === $ action ) { $ action = Application :: getInstance ( ) -> getDefaultAction ( ) ; } $ destination = sprintf ( "Location: %s%s/%s" , $ this -> request -> getContextPrefix ( ) , $ controller , $ action ) ; header ( $ destination ) ; exit ( ) ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
11175	public static function verify ( $ real , $ hash ) { $ hash = base64_decode ( $ hash ) ; return crypt ( $ real , $ hash ) == $ hash ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
11306	public static function getDataFromId ( $ id ) { $ db = Neuron_Core_Database :: __getInstance ( ) ; $ id = intval ( $ id ) ; $ r = $ db -> getDataFromQuery ( $ db -> customQuery ( " SELECT * FROM n_players WHERE n_players.plid = '" . $ id . "' " ) ) ; if ( count ( $ r ) == 1 ) { return $ r [ 0 ] ; } return null ; }
9834	public static function pixelsToCellDimension ( $ pValue , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ pDefaultFont ) { $ name = $ pDefaultFont -> getName ( ) ; $ size = $ pDefaultFont -> getSize ( ) ; if ( isset ( Font :: $ defaultColumnWidths [ $ name ] [ $ size ] ) ) { $ colWidth = $ pValue * Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'width' ] / Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'px' ] ; } else { $ colWidth = $ pValue * 11 * Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'width' ] / Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'px' ] / $ size ; } return $ colWidth ; }
9000	private function fixDirectorySeparator ( $ path ) : string { $ path = str_replace ( "\\" , DIRECTORY_SEPARATOR , $ path ) ; $ path = str_replace ( "/" , DIRECTORY_SEPARATOR , $ path ) ; return $ path ; }
9154	private function parseParameters ( \ ReflectionMethod $ action ) { $ params = $ action -> getParameters ( ) ; if ( count ( $ params ) < 1 ) { return false ; } $ param = $ params [ 0 ] ; assert ( $ param instanceof \ ReflectionParameter ) ; if ( ! ( $ class = $ param -> getClass ( ) ) || $ class -> getName ( ) != 'Nkey\Caribu\Mvc\Controller\Request' ) { return false ; } return true ; }
7378	public function fetchBool ( string $ key , bool $ default = false ) : bool { return $ this -> fetchFilter ( $ key , $ default , FILTER_VALIDATE_BOOLEAN ) ; }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
8161	public function block ( ) { $ this -> status = User :: STATUS_BLOCKED ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
12687	public function init ( $ confPath , $ useCache = true ) { $ this -> confPath = $ confPath ; if ( $ useCache ) { $ cachedConfig = new PhpConfiguration ( ) ; $ this -> cache = $ cachedConfig -> get ( ) ; unset ( $ cachedConfig ) ; } }
8773	public function registerCoreContainerAliases ( ) { Facade :: clearResolvedInstances ( ) ; Facade :: setApplication ( $ this ) ; foreach ( $ this -> registerCoreAliases as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
3321	public function getSuggestions ( ) { if ( $ this -> suggestions ) { if ( is_callable ( $ this -> suggestions ) ) { return call_user_func ( $ this -> suggestions ) ; } return $ this -> suggestions ; } return ; }
185	protected function renderInputHtml ( $ type ) { if ( $ this -> hasModel ( ) ) { return Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ this -> options ) ; } return Html :: input ( $ type , $ this -> name , $ this -> value , $ this -> options ) ; }
4705	public function slice ( $ offset , $ length = null ) { return new Collection ( array_slice ( $ this -> objects , $ offset , $ length ) ) ; }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
3778	protected function getLabel ( ) { if ( null === ( $ attribute = $ this -> getFilteredAttribute ( ) ) ) { return null ; } if ( $ label = $ this -> get ( 'label' ) ) { return $ label ; } return $ attribute -> getName ( ) ; }
2574	protected function loadSessionHandlerParams ( $ params ) { if ( isset ( $ params [ 'sessionHandlerParams' ] ) ) { if ( $ params [ 'sessionHandlerParams' ] instanceof SessionHandlerParams ) { $ this -> sessionHandlerParams = $ params [ 'sessionHandlerParams' ] ; } elseif ( is_array ( $ params [ 'sessionHandlerParams' ] ) ) { $ this -> sessionHandlerParams = new SessionHandlerParams ( $ params [ 'sessionHandlerParams' ] ) ; } } }
12312	private function writeToWebDir ( $ file , $ contents ) { if ( ! $ this -> webDir ) { return ; } if ( ! is_writable ( $ this -> webDir ) ) { trigger_error ( sprintf ( 'Directory %s is not writeable' , $ this -> webDir ) ) ; return ; } $ destFile = $ this -> webDir . $ file ; $ destDir = dirname ( $ destFile ) ; if ( ! is_dir ( $ destDir ) ) { mkdir ( $ destDir , 0777 , true ) ; } file_put_contents ( $ destFile , $ contents ) ; }
2239	private function addDefaultServerVersion ( array $ extensionConfigs , ContainerBuilder $ container ) : array { $ params = [ ] ; foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ) ) { $ params [ ] = $ extensionConfig [ 'dbal' ] [ 'connections' ] [ 'default' ] ; } } if ( ! empty ( $ params ) ) { $ params = array_merge ( ... $ params ) ; } $ parameterBag = $ container -> getParameterBag ( ) ; foreach ( $ params as $ key => $ value ) { $ params [ $ key ] = $ parameterBag -> resolveValue ( $ value ) ; } try { $ connection = DriverManager :: getConnection ( $ params ) ; $ connection -> connect ( ) ; $ connection -> close ( ) ; } catch ( DriverException $ e ) { $ extensionConfigs [ ] = [ 'dbal' => [ 'connections' => [ 'default' => [ 'server_version' => '5.5' , ] , ] , ] , ] ; } return $ extensionConfigs ; }
10642	public function orWhere ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "OR" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
8326	public function sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ this -> getLogger ( ) -> info ( "Try send google key (recaptcha) on {$this->serverBaseUri}/in.php" ) ; if ( $ this -> softId && ! isset ( $ extra [ Extra :: SOFT_ID ] ) ) { $ extra [ Extra :: SOFT_ID ] = $ this -> softId ; } $ response = $ this -> getHttpClient ( ) -> request ( 'POST' , "/in.php" , [ RequestOptions :: QUERY => array_merge ( $ extra , [ 'method' => 'userrecaptcha' , 'key' => $ this -> apiKey , 'googlekey' => $ googleKey , 'pageurl' => $ pageUrl ] ) ] ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ this -> lastCaptchaId = explode ( "|" , $ responseText ) [ 1 ] ; $ this -> getLogger ( ) -> info ( "Sending success. Got captcha id `{$this->lastCaptchaId}`." ) ; return $ this -> lastCaptchaId ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : "Unknown error: `{$responseText}`." ) ; }
1047	public static function create ( array $ params , bool $ readonly = false ) : OperationParams { $ instance = new static ( ) ; $ params = array_change_key_case ( $ params , CASE_LOWER ) ; $ instance -> originalInput = $ params ; $ params += [ 'query' => null , 'queryid' => null , 'documentid' => null , 'id' => null , 'operationname' => null , 'variables' => null , 'extensions' => null , ] ; if ( $ params [ 'variables' ] === '' ) { $ params [ 'variables' ] = null ; } foreach ( [ 'extensions' , 'variables' ] as $ param ) { if ( ! is_string ( $ params [ $ param ] ) ) { continue ; } $ tmp = json_decode ( $ params [ $ param ] , true ) ; if ( json_last_error ( ) ) { continue ; } $ params [ $ param ] = $ tmp ; } $ instance -> query = $ params [ 'query' ] ; $ instance -> queryId = $ params [ 'queryid' ] ? : $ params [ 'documentid' ] ? : $ params [ 'id' ] ; $ instance -> operation = $ params [ 'operationname' ] ; $ instance -> variables = $ params [ 'variables' ] ; $ instance -> extensions = $ params [ 'extensions' ] ; $ instance -> readOnly = $ readonly ; if ( isset ( $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ) && empty ( $ instance -> query ) && empty ( $ instance -> queryId ) ) { $ instance -> queryId = $ instance -> extensions [ 'persistedQuery' ] [ 'sha256Hash' ] ; } return $ instance ; }
9026	public function hasEmail ( $ string ) { $ result = false ; $ tokenizer = new General ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; foreach ( $ words as $ word ) { if ( filter_var ( $ word , FILTER_VALIDATE_EMAIL ) ) { $ result = true ; } } return $ result ; }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
8142	public function clearCacheFiles ( ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( is_string ( $ this -> originalCache ) ) { foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ this -> originalCache ) , RecursiveIteratorIterator :: LEAVES_ONLY ) as $ file ) { if ( $ file -> isFile ( ) ) { @ unlink ( $ file -> getPathname ( ) ) ; } } } }
7098	private function findStockUnits ( StockSubjectInterface $ subject ) { $ repository = $ this -> entityManager -> getRepository ( $ subject :: getStockUnitClass ( ) ) ; $ stockUnits = array_merge ( $ repository -> findNotClosedBySubject ( $ subject ) , $ repository -> findLatestClosedBySubject ( $ subject ) ) ; usort ( $ stockUnits , function ( StockUnitInterface $ a , StockUnitInterface $ b ) { if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) !== StockUnitStates :: STATE_CLOSED ) { return 1 ; } if ( $ a -> getState ( ) !== StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { return - 1 ; } if ( $ a -> getState ( ) === StockUnitStates :: STATE_CLOSED && $ b -> getState ( ) === StockUnitStates :: STATE_CLOSED ) { $ aDate = $ a -> getClosedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getClosedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } } $ aDate = $ a -> getCreatedAt ( ) -> getTimestamp ( ) ; $ bDate = $ b -> getCreatedAt ( ) -> getTimestamp ( ) ; if ( $ aDate > $ bDate ) { return - 1 ; } if ( $ aDate < $ bDate ) { return 1 ; } return 0 ; } ) ; return $ stockUnits ; }
4046	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'jumpTo' ) ) { return ; } $ value = StringUtil :: deserialize ( $ event -> getValue ( ) , true ) ; foreach ( $ value as $ k => $ v ) { $ value [ $ k ] [ 'value' ] = str_replace ( [ '{{link_url::' , '}}' ] , [ '' , '' ] , $ v [ 'value' ] ) ; } $ event -> setValue ( serialize ( $ value ) ) ; }
2677	public function deleteAclItem ( $ aclId , $ aclItemId ) { $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry/' . $ aclItemId ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: DELETE ) ; return $ result ; }
4118	public static function getType ( $ name ) { if ( ! isset ( self :: $ _typeObjects [ $ name ] ) ) { if ( ! isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: unknownType ( $ name ) ; } self :: $ _typeObjects [ $ name ] = new self :: $ _typesMap [ $ name ] ( ) ; } return self :: $ _typeObjects [ $ name ] ; }
6940	private function pop ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( false !== $ index = $ this -> find ( $ list , $ oid , $ unit ) ) { unset ( $ list [ $ oid ] [ $ index ] ) ; if ( empty ( $ list [ $ oid ] ) ) { unset ( $ list [ $ oid ] ) ; } } }
6780	protected function updateExchangeRate ( SaleInterface $ sale ) { if ( null !== $ sale -> getExchangeRate ( ) ) { return false ; } $ date = $ sale -> getExchangeDate ( ) ?? new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ sale -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ sale -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
1181	protected function createFormRequest ( $ class ) { list ( $ class , $ params ) = $ this -> parseFormRequestName ( $ class ) ; $ request = $ this -> app -> __get ( 'request' ) ; $ formRequest = $ this -> app -> build ( $ class , $ params ) ; if ( $ session = $ request -> getSession ( ) ) { $ formRequest -> setLaravelSession ( $ session ) ; } $ formRequest -> setUserResolver ( $ request -> getUserResolver ( ) ) ; $ formRequest -> setRouteResolver ( $ request -> getRouteResolver ( ) ) ; $ formRequest -> setContainer ( $ this -> app ) ; $ formRequest -> query = $ request -> query ; return $ formRequest ; }
11760	public static function getArray ( ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ properties = $ object -> getProperties ( \ ReflectionProperty :: IS_PUBLIC ) ; $ array = array ( ) ; foreach ( $ properties as $ property ) { $ value = $ property -> getValue ( ) ; if ( ! empty ( $ value ) ) { $ array [ $ property -> getName ( ) ] = $ value ; } } return $ array ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
5574	public function clickSubmit ( $ label = 'Submit' , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectByLabel ( $ label ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
4323	public static function buildTag ( $ tagName , $ attribs = array ( ) , $ innerhtml = '' ) { $ tagName = \ strtolower ( $ tagName ) ; $ attribStr = self :: buildAttribString ( $ attribs ) ; return \ in_array ( $ tagName , self :: $ htmlEmptyTags ) ? '<' . $ tagName . $ attribStr . ' />' : '<' . $ tagName . $ attribStr . '>' . $ innerhtml . '</' . $ tagName . '>' ; }
12609	public function getParent ( $ type ) { if ( isset ( $ this -> _parents [ $ type ] ) ) { return $ this -> _parents [ $ type ] ; } return false ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
805	private function hasVoidReturn ( Tokens $ tokens , $ startIndex , $ endIndex ) { $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; for ( $ i = $ startIndex ; $ i < $ endIndex ; ++ $ i ) { if ( ( $ tokens [ $ i ] -> isGivenKind ( T_CLASS ) && $ tokensAnalyzer -> isAnonymousClass ( $ i ) ) || ( $ tokens [ $ i ] -> isGivenKind ( T_FUNCTION ) && $ tokensAnalyzer -> isLambda ( $ i ) ) ) { $ i = $ tokens -> getNextTokenOfKind ( $ i , [ '{' ] ) ; $ i = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ i ) ; continue ; } if ( $ tokens [ $ i ] -> isGivenKind ( [ T_YIELD , T_YIELD_FROM ] ) ) { return false ; } if ( ! $ tokens [ $ i ] -> isGivenKind ( T_RETURN ) ) { continue ; } $ i = $ tokens -> getNextMeaningfulToken ( $ i ) ; if ( ! $ tokens [ $ i ] -> equals ( ';' ) ) { return false ; } } return true ; }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
8230	public static function writeFile ( $ fileName , $ data , $ options = [ ] ) { $ writer = new File \ FileWriter ( $ fileName , $ options ) ; $ isSuccess = true ; $ written = 0 ; try { $ writer -> open ( ) ; $ written = $ writer -> write ( $ data ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } try { $ writer -> close ( ) ; } catch ( \ RuntimeException $ e ) { self :: $ lastError = $ e -> getMessage ( ) ; $ isSuccess = false ; } return $ isSuccess ; }
8727	public function getDirty ( ) { $ dirty = parent :: getDirty ( ) ; if ( ! $ this -> localeChanged ) { return $ dirty ; } foreach ( $ this -> translatableAttributes ( ) as $ key ) { if ( isset ( $ this -> attributes [ $ key ] ) ) { $ dirty [ $ key ] = $ this -> attributes [ $ key ] ; } } return $ dirty ; }
1499	public function when ( bool $ test , $ encodings ) : self { if ( ! $ test || is_null ( $ encodings ) ) { return $ this ; } if ( $ encodings instanceof \ Closure ) { return $ encodings ( $ this ) ; } if ( is_string ( $ encodings ) ) { $ encodings = Encoding :: custom ( $ encodings ) ; } $ encodings = $ encodings instanceof Encoding ? [ $ encodings ] : $ encodings ; return $ this -> push ( ... $ encodings ) ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
11101	public static function countryCodeTwoToThree ( $ code ) { $ codes = array_flip ( self :: $ _countryCodes ) ; if ( ! array_key_exists ( $ code , $ codes ) ) { return false ; } return $ codes [ $ code ] ; }
10816	public static function write ( $ messages , $ style = '' , $ length = 0 , $ suffix = '' ) { if ( self :: $ silent ) { return ; } if ( ! is_array ( $ messages ) ) { $ messages = [ ( string ) $ messages ] ; } if ( count ( $ messages ) > 0 ) { foreach ( $ messages as $ message ) { if ( $ length > 0 ) { $ message = str_pad ( $ message , $ length , ' ' , STR_PAD_RIGHT ) ; } print ( Style :: applyStyle ( $ message , $ style ) ) ; if ( $ suffix != '' ) { print ( $ suffix ) ; } } } }
9046	public function registerType ( $ type , $ classname , $ options = array ( ) ) { if ( ! class_exists ( $ classname ) || ! is_callable ( array ( $ classname , 'getDataType' ) ) ) { return ; } $ data_type = call_user_func ( array ( $ classname , 'getDataType' ) ) ; $ options = ( array ) $ options ; $ options [ 'type' ] = $ type ; $ options [ 'class_name' ] = $ classname ; $ options [ 'data_type' ] = $ data_type ; $ this -> types [ $ data_type ] [ $ type ] = $ options ; }
2404	public function asset ( $ path , $ packageName = null ) { $ url = System :: getContainer ( ) -> get ( 'assets.packages' ) -> getUrl ( $ path , $ packageName ) ; return ltrim ( $ url , '/' ) ; }
7031	private function findMatchingShipmentItem ( InvoiceLineInterface $ line , ShipmentInterface $ shipment ) { $ saleItem = $ line -> getSaleItem ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { if ( $ saleItem === $ shipmentItem -> getSaleItem ( ) ) { return $ shipmentItem ; } } return null ; }
3250	public function scopeWhereCurrent ( $ query ) { if ( Auth :: guest ( ) ) return $ query ; return $ query -> whereUser ( Auth :: user ( ) -> shopId ) ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
10039	public function trySimpleXMLLoadString ( $ pFilename ) { try { $ xml = simplexml_load_string ( $ this -> securityScan ( file_get_contents ( $ pFilename ) ) , 'SimpleXMLElement' , Settings :: getLibXmlLoaderOptions ( ) ) ; } catch ( \ Exception $ e ) { throw new Exception ( 'Cannot load invalid XML file: ' . $ pFilename , 0 , $ e ) ; } return $ xml ; }
12844	protected function loadAnswerMatching ( ) { if ( $ this -> input -> hasOption ( 'load-choice-matching' ) ) { $ fs = new Filesystem ( ) ; $ filename = $ this -> input -> getOption ( 'load-choice-matching' ) ; if ( ! $ fs -> exists ( $ filename ) ) { $ this -> logger -> warning ( "The file $filename is not found. Choice matching not loaded" ) ; } else { $ this -> logger -> debug ( "Loading $filename as choice matching" ) ; $ this -> cacheAnswersMapping = \ json_decode ( \ file_get_contents ( $ filename ) , true ) ; } } }
7334	private function getSubjectIdentityMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> subjectIdentityMapper ) { $ this -> subjectIdentityMapper = new EmbeddableMapper ( $ em , SubjectIdentity :: class ) ; } return $ this -> subjectIdentityMapper ; }
10176	public function getHighestRow ( $ column = null ) { if ( $ column == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'row' ] ; } $ rowList = [ 0 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c != $ column ) { continue ; } $ rowList [ ] = $ r ; } return max ( $ rowList ) ; }
3665	private function convertParameterAggregate ( $ var , $ arguments ) { $ var = ( array ) $ var ; if ( ! empty ( $ arguments [ 'recursive' ] ) ) { $ var = iterator_to_array ( new \ RecursiveIteratorIterator ( new \ RecursiveArrayIterator ( $ var ) ) ) ; } if ( ! $ var ) { return 'NULL' ; } if ( ! empty ( $ arguments [ 'key' ] ) ) { $ var = array_keys ( $ var ) ; } else { $ var = array_values ( $ var ) ; } if ( $ arguments [ 'aggregate' ] == 'set' ) { $ this -> addParameter ( implode ( ',' , $ var ) ) ; return '?' ; } $ this -> addParameters ( $ var ) ; return rtrim ( str_repeat ( '?,' , count ( $ var ) ) , ',' ) ; }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
1986	private function loadOptions ( ) : void { if ( null !== $ this -> options ) { return ; } $ this -> framework -> initialize ( ) ; $ this -> options = $ GLOBALS [ 'TL_CROP' ] ; $ rows = $ this -> connection -> fetchAll ( 'SELECT id, name, width, height FROM tl_image_size ORDER BY pid, name' ) ; foreach ( $ rows as $ imageSize ) { $ this -> options [ 'image_sizes' ] [ $ imageSize [ 'id' ] ] = sprintf ( '%s (%sx%s)' , $ imageSize [ 'name' ] , $ imageSize [ 'width' ] , $ imageSize [ 'height' ] ) ; } }
6885	public function lookupPostcodeAddresses ( $ postcode ) { $ path = self :: PATH_LOOKUP_POSTCODE ; $ response = $ this -> httpGet ( $ path , [ 'postcode' => $ postcode ] ) ; return Response \ AddressList :: buildFromResponse ( $ response ) ; }
1724	public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; }
4559	protected function execute ( LifecycleEventArgs $ args , $ action ) { $ this -> tokenStorage = $ this -> container -> get ( 'security.token_storage' ) ; $ this -> configService = $ this -> container -> get ( 'ds_config.service.config' ) ; $ this -> auditService = $ this -> container -> get ( 'ds_audit.service.audit' ) ; $ entity = $ args -> getEntity ( ) ; if ( $ entity instanceof Audit ) { return ; } if ( ! $ entity instanceof Auditable ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token ) { return ; } $ user = $ token -> getUser ( ) ; $ edits = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getEntityChangeSet ( $ entity ) ; $ properties = $ this -> auditService -> getProperties ( $ entity ) ; foreach ( array_keys ( $ edits ) as $ key ) { if ( ! in_array ( $ key , $ properties ) ) { unset ( $ edits [ $ key ] ) ; } } $ audit = $ this -> auditService -> createInstance ( ) ; $ audit -> setOwner ( $ this -> configService -> get ( 'ds_audit.audit.owner' ) ) -> setOwnerUuid ( $ this -> configService -> get ( 'ds_audit.audit.owner_uuid' ) ) -> setUserUuid ( $ user -> getUuid ( ) ) -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) -> setAction ( $ action ) -> setData ( [ 'entity' => basename ( str_replace ( '\\' , '/' , get_class ( $ entity ) ) ) , 'entityUuid' => $ entity -> getUuid ( ) , 'edits' => $ edits ] ) ; $ manager = $ this -> auditService -> getManager ( ) ; $ manager -> persist ( $ audit ) ; $ manager -> flush ( ) ; }
9468	public function map ( ) { $ this -> namespace ( 'System' ) -> prefix ( 'system' ) -> name ( 'system.' ) -> group ( function ( ) { $ this -> registerSystemInformationRoutes ( ) ; $ this -> registerLogViewerRoutes ( ) ; $ this -> registerRouteViewerRoutes ( ) ; } ) ; }
12573	public function previewVideo ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , $ by ) ; }
2226	private function renderErrorScreenByException ( GetResponseForExceptionEvent $ event ) : void { $ exception = $ event -> getException ( ) ; $ statusCode = $ this -> getStatusCodeForException ( $ exception ) ; $ template = null ; $ this -> logException ( $ exception ) ; do { if ( $ exception instanceof \ Exception ) { $ template = $ this -> getTemplateForException ( $ exception ) ; } } while ( null === $ template && null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; $ this -> renderTemplate ( $ template ? : 'error' , $ statusCode , $ event ) ; }
1955	public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; }
2279	public static function get ( $ strKey ) { if ( isset ( static :: $ arrCache [ $ strKey ] ) ) { return static :: $ arrCache [ $ strKey ] ; } if ( \ in_array ( $ strKey , get_class_methods ( __CLASS__ ) ) ) { static :: $ arrCache [ $ strKey ] = static :: $ strKey ( ) ; } else { $ arrChunks = preg_split ( '/([A-Z][a-z]*)/' , $ strKey , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; $ strServerKey = strtoupper ( implode ( '_' , $ arrChunks ) ) ; static :: $ arrCache [ $ strKey ] = $ _SERVER [ $ strServerKey ] ; } return static :: $ arrCache [ $ strKey ] ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
8649	private function calculateStringToSignV2 ( array $ parameters , $ queuepath = null ) { $ parsedUrl = parse_url ( $ this -> config [ 'ServiceURL' ] ) ; $ endpoint = $ parsedUrl [ 'host' ] ; if ( isset ( $ parsedUrl [ 'port' ] ) && ! is_null ( $ parsedUrl [ 'port' ] ) ) { $ endpoint .= ':' . $ parsedUrl [ 'port' ] ; } $ data = 'POST' ; $ data .= "\n" ; $ data .= $ endpoint ; $ data .= "\n" ; if ( $ queuepath ) { $ uri = $ queuepath ; } else { $ uri = "/" ; } $ uriencoded = implode ( "/" , array_map ( array ( $ this , "urlencode" ) , explode ( "/" , $ uri ) ) ) ; $ data .= $ uriencoded ; $ data .= "\n" ; uksort ( $ parameters , 'strcmp' ) ; $ data .= $ this -> getParametersAsString ( $ parameters ) ; return $ data ; }
4146	protected function getUrl ( ) { $ domain = $ this -> urls [ 'domain' ] ; $ apiVersion = $ this -> urls [ 'api' ] ; $ jsonExt = '.json' ; if ( isset ( $ this -> withMedia ) && $ this -> withMedia === true ) { $ domain = $ this -> urls [ 'upload' ] ; } if ( $ this -> call === 'oauth/request_token' || $ this -> call === 'oauth/access_token' ) { $ apiVersion = '' ; $ jsonExt = '' ; } return $ domain . $ apiVersion . $ this -> call . $ jsonExt ; }
6388	public function readSite ( ) { $ model = $ this -> readCourse ( 1 ) ; $ model -> url = $ this -> cfg -> wwwroot ; $ model -> type = "site" ; return $ model ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
12419	static function run_php_pdepend_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ pdepend = self :: getTool ( 'pdepend' , $ opts , true ) ; pake_mkdirs ( $ destdir ) ; $ out = pake_sh ( $ pdepend . " --jdepend-chart=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/jdependchart.svg' ) . " --overview-pyramid=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/overview-pyramid.svg' ) . " --summary-xml=" . escapeshellarg ( self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] . '/summary.xml' ) . " " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
12119	private function getCustomersMap ( ) { $ customers = $ this -> daoCustDwnl -> get ( ) ; $ result = $ this -> hlpTree -> mapById ( $ customers , ECustomer :: A_CUSTOMER_REF ) ; return $ result ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
6262	public function getPrefixMap ( ) { $ prefixMap = ( array ) Configure :: read ( 'SimpleRbac.prefixMap' ) ; if ( empty ( $ prefixMap ) && $ this -> _config [ 'allowEmptyPrefixMap' ] === false ) { throw new \ RuntimeException ( 'SimpleRbac.prefixMap configuration is empty!' ) ; } return $ prefixMap ; }
567	private function parseDateValueFormat ( $ value , $ format ) { if ( is_array ( $ value ) ) { return false ; } if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { if ( extension_loaded ( 'intl' ) ) { return $ this -> parseDateValueIntl ( $ value , $ format ) ; } $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } return $ this -> parseDateValuePHP ( $ value , $ format ) ; }
12956	public function remove ( $ id ) { if ( ! $ this -> has ( $ id ) ) { throw new NotFoundException ( sprintf ( '%s not found in %s' , $ id , __CLASS__ ) ) ; } unset ( $ this -> objects [ $ id ] ) ; }
655	protected function reset ( ) { $ this -> _sql = null ; $ this -> _pendingParams = [ ] ; $ this -> params = [ ] ; $ this -> _refreshTableName = null ; $ this -> _isolationLevel = false ; $ this -> _retryHandler = null ; }
10518	protected function getProductPhoto ( MediaInterface $ media , ProductInterface $ modelData , $ values ) { $ mainPhoto = $ this -> isMainPhoto ( $ media , $ values [ 'main' ] ) ; $ productPhoto = new ProductPhoto ( ) ; $ productPhoto -> setPhoto ( $ media ) ; $ productPhoto -> setMainPhoto ( $ mainPhoto ) ; $ productPhoto -> setProduct ( $ modelData ) ; if ( $ mainPhoto ) { $ modelData -> setPhoto ( $ media ) ; } return $ productPhoto ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
7615	private function encodeBearer ( $ consumer_key , $ consumer_secret ) { $ consumer_key = rawurlencode ( $ consumer_key ) ; $ consumer_secret = rawurlencode ( $ consumer_secret ) ; return base64_encode ( $ consumer_key . ':' . $ consumer_secret ) ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
7166	private function buildShipmentLine ( Model \ SaleInterface $ sale ) { if ( null === $ sale -> getShipmentMethod ( ) && ! $ this -> options [ 'private' ] ) { return ; } $ lineNumber = $ this -> lineNumber ++ ; $ view = new LineView ( 'shipment' , 'shipment' , $ lineNumber , 0 ) ; $ designation = 'Shipping cost' ; if ( null !== $ method = $ sale -> getShipmentMethod ( ) ) { $ designation = $ method -> getTitle ( ) ; } $ designation .= ' (' . $ this -> formatter -> number ( $ sale -> getWeightTotal ( ) ) . ' kg)' ; $ result = $ sale -> getShipmentResult ( ) ; $ view -> setDesignation ( $ designation ) -> setBase ( $ this -> formatter -> currency ( $ result -> getBase ( ) ) ) -> setTaxRates ( $ this -> formatter -> rates ( ... $ result -> getTaxAdjustments ( ) ) ) -> setTaxAmount ( $ this -> formatter -> currency ( $ result -> getTax ( ) ) ) -> setTotal ( $ this -> formatter -> currency ( $ result -> getTotal ( ) ) ) ; foreach ( $ this -> types as $ type ) { $ type -> buildShipmentView ( $ sale , $ view , $ this -> options ) ; } $ this -> view -> setShipment ( $ view ) ; }
11990	public function toggleFiltrable ( $ entityName , $ id ) { $ entity = $ this -> entityManager -> getRepository ( $ entityName ) -> find ( $ id ) ; if ( ! $ entity ) { throw new NotFoundHttpException ( ) ; } $ entity -> toggleFiltrable ( ) ; $ this -> entityManager -> persist ( $ entity ) ; $ this -> entityManager -> flush ( ) ; return $ entity -> isFiltrable ( ) ; }
6870	protected function buildPaymentList ( PM \ PaymentSubjectInterface $ subject ) { $ payments = array_filter ( $ subject -> getPayments ( ) -> toArray ( ) , function ( PM \ PaymentInterface $ p ) { if ( $ p -> getMethod ( ) -> isOutstanding ( ) ) { return false ; } if ( ! PM \ PaymentStates :: isPaidState ( $ p -> getState ( ) ) ) { return false ; } return true ; } ) ; usort ( $ payments , function ( PM \ PaymentInterface $ a , PM \ PaymentInterface $ b ) { return $ a -> getCompletedAt ( ) -> getTimestamp ( ) - $ b -> getCompletedAt ( ) -> getTimestamp ( ) ; } ) ; return array_map ( function ( PM \ PaymentInterface $ payment ) { return [ 'payment' => $ payment , 'amount' => $ payment -> getAmount ( ) , ] ; } , $ payments ) ; }
12032	function addDispatchMethod ( ) { $ methodGenerator = new MethodGenerator ( 'dispatch' ) ; $ body = '' ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= $ this -> generateResponseFragment ( ) ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Dispatch the request for this operation and process the response. Allows you to modify the request before it is sent.' ) ; $ parameter = new ParameterGenerator ( 'request' , 'Amp\Artax\Request' ) ; $ methodGenerator -> setParameter ( $ parameter ) ; $ tag = createParamTag ( $ parameter , 'The request to be processed' ) ; $ docBlock -> setTag ( $ tag ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
4867	public function fail ( JobInterface $ job , array $ options = [ ] ) { $ envelope = $ this -> createEnvelope ( $ job , $ options ) ; unset ( $ envelope [ 'created' ] ) ; unset ( $ envelope [ 'scheduled' ] ) ; $ envelope [ 'status' ] = self :: STATUS_FAILED ; $ this -> mongoCollection -> findOneAndUpdate ( [ '_id' => new \ MongoDB \ BSON \ ObjectId ( $ job -> getId ( ) ) ] , [ '$set' => $ envelope ] ) ; }
2915	public function getLayoutUpdatesFiles ( $ storeId , $ designArea ) { $ updatesRoot = $ this -> getConfig ( ) -> getNode ( $ designArea . '/layout/updates' ) ; $ updateFiles = array ( ) ; foreach ( $ updatesRoot -> children ( ) as $ updateNode ) { if ( $ updateNode -> file ) { $ module = $ updateNode -> getAttribute ( 'module' ) ; if ( $ module && Mage :: getStoreConfigFlag ( 'advanced/modules_disable_output/' . $ module , $ storeId ) ) { continue ; } $ updateFiles [ ] = ( string ) $ updateNode -> file ; } } $ updateFiles [ ] = 'local.xml' ; return $ updateFiles ; }
2651	public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
4766	protected function validateInvoiceAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_invoiceaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeInvAddress' ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinInvoiceAddress' ) && ( 1 == $ changeExistigAddress ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
5095	protected function getDefaultParts ( ) { if ( ! isset ( CmdUpsert :: $ DEFAULT ) ) { CmdUpsert :: $ DEFAULT = parent :: getDefaultParts ( ) ; CmdUpsert :: $ PART_SET = count ( CmdUpsert :: $ DEFAULT ) ; CmdUpsert :: $ DEFAULT [ CmdUpsert :: $ PART_SET ] = false ; } return CmdUpsert :: $ DEFAULT ; }
3533	public static function findByAttribute ( $ attribute , $ searchValue ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> select ( 'samaccountname' ) -> where ( $ attribute , '=' , $ searchValue ) -> get ( ) ; $ userObjectReturn = null ; if ( count ( $ userObjectsFound ) == 1 ) { $ userObjectReturn = static :: findByUsername ( $ userObjectsFound [ 0 ] [ 'samaccountname' ] [ 0 ] ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'Attribute: ' . $ attribute . '; Value: ' . $ searchValue , static :: YII2_PROFILE_NAME . 'findByAttribute' ) ; } return $ userObjectReturn ; }
8624	public function setShippingServiceList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShippingServiceList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
4064	private static function calculateDiff ( $ expected , $ actual , $ strict ) { if ( $ expected === $ actual ) { return ; } if ( gettype ( $ expected ) !== gettype ( $ actual ) ) { if ( ! $ strict && self :: isEmptyArrayEquivalent ( $ expected , $ actual ) ) { return ; } throw new \ LogicException ( sprintf ( 'Encountered type %s expected %s (Found %s, expected %s)' , gettype ( $ actual ) , gettype ( $ expected ) , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: TYPE_MISMATCH ) ; } if ( is_array ( $ expected ) ) { self :: calculateArrayDiff ( $ expected , $ actual , $ strict ) ; } throw new \ LogicException ( sprintf ( 'Found %s expected %s' , var_export ( $ actual , true ) , var_export ( $ expected , true ) ) , self :: VALUE_MISMATCH ) ; }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
5620	protected function chompCoordinates ( & $ url ) { if ( preg_match ( '/(.*)\?(\d+),(\d+)$/' , $ url , $ matches ) ) { $ url = $ matches [ 1 ] ; return array ( ( integer ) $ matches [ 2 ] , ( integer ) $ matches [ 3 ] ) ; } return array ( false , false ) ; }
1692	protected function shortenHexColor ( $ color ) { if ( $ color [ 0 ] == $ color [ 1 ] && $ color [ 2 ] == $ color [ 3 ] && $ color [ 4 ] == $ color [ 5 ] ) { return $ color [ 0 ] . $ color [ 2 ] . $ color [ 4 ] ; } return $ color ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
11850	public static function createFault ( $ code , $ message ) { $ response = new \ SimpleXMLElement ( "<methodResponse></methodResponse>" ) ; $ struct = $ response -> addChild ( "fault" ) -> addChild ( "value" ) -> addChild ( "struct" ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultCode" ) ; $ member -> addChild ( "value" ) -> addChild ( "int" , $ code ) ; $ member = $ struct -> addChild ( "member" ) ; $ member -> addChild ( "name" , "faultString" ) ; $ member -> addChild ( "value" , $ message ) ; return $ response -> asXML ( ) ; }
4157	function cron ( $ expression , Job $ job ) { $ expression = new CronExpression ( $ expression ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
6466	private static function createDefaultBoundary ( ) : string { try { $ string = random_bytes ( 16 ) ; $ string [ 6 ] = chr ( ord ( $ string [ 6 ] ) & 0x0f | 0x40 ) ; $ string [ 8 ] = chr ( ord ( $ string [ 8 ] ) & 0x3f | 0x80 ) ; return vsprintf ( '%s%s-%s-%s-%s-%s%s%s' , str_split ( bin2hex ( $ string ) , 4 ) ) ; } catch ( Exception $ ex ) { throw new RuntimeException ( 'Failed to generate random bytes' , 0 , $ ex ) ; } }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
882	private function normalizeType ( $ type ) { if ( '[]' === substr ( $ type , - 2 ) ) { return $ this -> normalize ( substr ( $ type , 0 , - 2 ) ) . '[]' ; } return $ this -> normalize ( $ type ) ; }
5545	public function getText ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getText ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= ' ' . $ this -> frames [ $ i ] -> getText ( ) ; } return trim ( $ raw ) ; }
12582	public function setTranslator ( $ translator , $ translatorDomain = null , $ translatorLocale = null ) { $ this -> translator = $ translator ; $ this -> setTranslatorDomain ( $ translatorDomain ) ; $ this -> setTranslatorLocale ( $ translatorLocale ) ; $ this -> setCaption ( $ this -> translate ( $ this -> getCaption ( ) ) ) ; }
4318	private function setLogDest ( $ where = 'auto' ) { if ( $ where == 'auto' ) { $ where = $ this -> data [ 'groupPriorityStack' ] ? 'summary' : 'log' ; } if ( $ where == 'log' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'log' ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ 'main' ] ; } elseif ( $ where == 'alerts' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'alerts' ] ; } else { $ priority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; if ( ! isset ( $ this -> data [ 'logSummary' ] [ $ priority ] ) ) { $ this -> data [ 'logSummary' ] [ $ priority ] = array ( ) ; $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'logSummary' ] [ $ priority ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ $ priority ] ; } }
2400	public function output ( ) { @ trigger_error ( 'Using Template::output() has been deprecated and will no longer work in Contao 5.0. Use Template::getResponse() instead.' , E_USER_DEPRECATED ) ; $ this -> compile ( ) ; header ( 'Content-Type: ' . $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; echo $ this -> strBuffer ; $ this -> flushAllData ( ) ; }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
2972	protected function determineContext ( array & $ data ) { $ refs = 0 ; $ vars = array_map ( function ( $ node ) use ( & $ refs ) { if ( $ node -> byRef ) { $ refs ++ ; } if ( $ node -> var instanceof VariableNode ) { return $ node -> var -> name ; } else { return $ node -> var ; } } , $ data [ 'ast' ] -> uses ) ; $ data [ 'hasRefs' ] = ( $ refs > 0 ) ; $ values = $ data [ 'reflection' ] -> getStaticVariables ( ) ; foreach ( $ vars as $ name ) { if ( isset ( $ values [ $ name ] ) ) { $ data [ 'context' ] [ $ name ] = $ values [ $ name ] ; } } }
12894	public function close ( $ account , $ openId ) { $ params = [ 'kf_account' => $ account , 'openid' => $ openId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE , $ params ] ) ; }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
845	public function ensureWhitespaceAtIndex ( $ index , $ indexOffset , $ whitespace ) { $ removeLastCommentLine = static function ( self $ tokens , $ index , $ indexOffset , $ whitespace ) { $ token = $ tokens [ $ index ] ; if ( 1 === $ indexOffset && $ token -> isGivenKind ( T_OPEN_TAG ) ) { if ( 0 === strpos ( $ whitespace , "\r\n" ) ) { $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . "\r\n" ] ) ; return \ strlen ( $ whitespace ) > 2 ? substr ( $ whitespace , 2 ) : '' ; } $ tokens [ $ index ] = new Token ( [ T_OPEN_TAG , rtrim ( $ token -> getContent ( ) ) . $ whitespace [ 0 ] ] ) ; return \ strlen ( $ whitespace ) > 1 ? substr ( $ whitespace , 1 ) : '' ; } return $ whitespace ; } ; if ( $ this [ $ index ] -> isWhitespace ( ) ) { $ whitespace = $ removeLastCommentLine ( $ this , $ index - 1 , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { $ this -> clearAt ( $ index ) ; } else { $ this [ $ index ] = new Token ( [ T_WHITESPACE , $ whitespace ] ) ; } return false ; } $ whitespace = $ removeLastCommentLine ( $ this , $ index , $ indexOffset , $ whitespace ) ; if ( '' === $ whitespace ) { return false ; } $ this -> insertAt ( $ index + $ indexOffset , [ new Token ( [ T_WHITESPACE , $ whitespace ] ) , ] ) ; return true ; }
9643	public static function getDriver ( MappingDriver $ originalDriver , $ namespace ) { if ( $ originalDriver instanceof MappingDriverChain ) { $ driver = new Driver \ Chain ( ) ; foreach ( $ originalDriver -> getDrivers ( ) as $ nestedNamespace => $ nestedDriver ) { $ driver -> addDriver ( static :: getDriver ( $ nestedDriver , $ namespace ) , $ nestedNamespace ) ; } if ( $ originalDriver -> getDefaultDriver ( ) !== null ) { $ driver -> setDefaultDriver ( static :: getDriver ( $ originalDriver -> getDefaultDriver ( ) , $ namespace ) ) ; } return $ driver ; } preg_match ( '/(?P<type>Xml|Yaml|Annotation)Driver$/' , get_class ( $ originalDriver ) , $ m ) ; $ type = isset ( $ m [ 'type' ] ) ? $ m [ 'type' ] : null ; $ driverClass = sprintf ( '%s\Mapping\Driver\%s' , $ namespace , $ type ) ; if ( ! $ type || ! class_exists ( $ driverClass ) ) { $ driverClass = sprintf ( '%s\Mapping\Driver\Annotation' , $ namespace ) ; if ( ! class_exists ( $ driverClass ) ) { throw new \ RuntimeException ( sprintf ( 'Failed to fallback to annotation driver: (%s), extension driver was not found.' , $ driverClass ) ) ; } } $ driver = new $ driverClass ( ) ; $ driver -> setOriginalDriver ( $ originalDriver ) ; if ( $ driver instanceof Driver \ File ) { $ driver -> setLocator ( $ originalDriver -> getLocator ( ) ) ; } elseif ( $ driver instanceof AnnotationDriverInterface ) { $ reader = static :: getAnnotationReader ( ) ; $ driver -> setAnnotationReader ( $ reader ) ; } return $ driver ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
11197	public function add ( $ item , $ key = false , $ dataKey = false ) { $ keyPrefix = '' ; if ( is_array ( $ dataKey ) ) { $ keyPrefix = $ dataKey [ 1 ] ; $ dataKey = $ dataKey [ 0 ] ; } if ( is_object ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item -> $ dataKey ) ) { $ key = $ item -> $ dataKey ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else if ( is_array ( $ item ) ) { if ( $ key ) { if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else if ( $ dataKey && isset ( $ item [ $ dataKey ] ) ) { $ key = $ item [ $ dataKey ] ; if ( ! isset ( $ this -> key ) ) { $ this -> size += 1 ; } $ this -> singleton -> { $ keyPrefix . $ key } = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } else { if ( $ key ) { if ( ! $ this -> __isset ( $ key ) ) { $ this -> size += 1 ; } $ this -> singleton -> $ key = $ item ; } else { $ offset = '_item' . $ this -> size ; $ this -> size += 1 ; $ this -> singleton -> { "$offset" } = $ item ; } } $ this -> contentModified = true ; return $ this ; }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
12168	public function createPropertyValuesProxyTable ( $ group , $ dropExisting = true ) { $ group = strtolower ( $ group ) ; if ( ! empty ( $ group ) ) : $ this -> database -> query ( "DROP TABLE IF EXISTS `?{$group}_property_values`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?{$group}_property_values` ( `value_id` mediumint(11) NOT NULL AUTO_INCREMENT, `value_data` text NOT NULL, `value_updated_on` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `property_id` int(11) NOT NULL, `object_id` int(11) NOT NULL, PRIMARY KEY (`value_id`), UNIQUE KEY `object_property_uid` (`object_id`,`property_id`), KEY `property_id_idxfk` (`property_id`), KEY `object_id_idxfk` (`object_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_insert`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_insert` BEFORE INSERT ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "DROP TRIGGER IF EXISTS `?{$group}_property_value_validate_update`;" ) ; $ this -> database -> query ( "CREATE TRIGGER `?{$group}_property_value_validate_update` BEFORE UPDATE ON `?{$group}_property_values` FOR EACH ROW BEGIN CALL ?property_value_validate(NEW.property_id, NEW.value_data); END;" ) ; $ this -> database -> query ( "ALTER TABLE `?{$group}_property_values` ADD CONSTRAINT `{$group}_property_values_ibfk_1` FOREIGN KEY (`object_id`) REFERENCES `?objects` (`object_id`), ADD CONSTRAINT `{$group}_property_values_ibfk_2` FOREIGN KEY (`property_id`) REFERENCES `?properties` (`property_id`) ON DELETE CASCADE;" ) ; endif ; }
7998	private function getOpenSslEncryptionOptions ( ) { $ options = self :: DEFAULT_OPENSSL_OPTIONS ; if ( $ this -> zero_pad ) { $ options = $ options | OPENSSL_ZERO_PADDING ; } return $ options ; }
3048	public function init ( ) { $ sessionStateService = $ this -> getServiceManager ( ) -> get ( SessionStateService :: SERVICE_ID ) ; $ sessionStateService -> resumeSession ( $ this -> getTestSession ( ) ) ; $ this -> retrieveItemIndex ( ) ; }
12817	public function fetchAll ( ) { $ list = [ ] ; foreach ( $ this -> cache as $ domain => $ values ) { foreach ( $ values as $ key => $ value ) $ list [ sprintf ( "%s.%s" , $ domain != '<NULL>' ? $ domain : '' , $ key ) ] = $ value ; } return $ list ; }
5783	private function enterEventAndNotice ( string $ action , $ primaryKeyValue = null ) { if ( $ action != 'insert' && $ action != 'update' ) { throw new \ InvalidArgumentException ( "Action must be either insert or update" ) ; } $ actionPastTense = ( $ action == 'insert' ) ? 'inserted' : 'updated' ; $ tableNameSingular = $ this -> tableMapper -> getFormalTableName ( false ) ; $ noteStart = "$actionPastTense $tableNameSingular" ; $ eventTitle = @ constant ( "EVENT_" . strtoupper ( $ tableNameSingular ) . "_" . strtoupper ( $ action ) ) ?? $ noteStart ; $ adminNotification = $ noteStart ; $ eventPayload = [ ] ; if ( null !== $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ) { $ adminNotification .= " $primaryKeyValue" ; $ eventPayload = [ $ primaryKeyColumnName => $ primaryKeyValue ] ; } $ eventPayload = array_merge ( $ eventPayload , $ this -> requestInput ) ; $ this -> events -> insertInfo ( $ eventTitle , $ eventPayload ) ; SlimPostgres :: setAdminNotice ( $ adminNotification ) ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1635	protected function setupEvents ( Dispatcher $ events , array $ config ) { if ( isset ( $ config [ 'auto_capture_sessions' ] ) && $ config [ 'auto_capture_sessions' ] ) { $ events -> listen ( RouteMatched :: class , function ( $ event ) { $ this -> app -> bugsnag -> getSessionTracker ( ) -> startSession ( ) ; } ) ; } if ( isset ( $ config [ 'query' ] ) && ! $ config [ 'query' ] ) { return ; } $ show = isset ( $ config [ 'bindings' ] ) && $ config [ 'bindings' ] ; if ( class_exists ( QueryExecuted :: class ) ) { $ events -> listen ( QueryExecuted :: class , function ( QueryExecuted $ query ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ query -> sql , $ show ? $ query -> bindings : [ ] , $ query -> time , $ query -> connectionName ) ) ; } ) ; } else { $ events -> listen ( 'illuminate.query' , function ( $ sql , array $ bindings , $ time , $ connection ) use ( $ show ) { $ this -> app -> bugsnag -> leaveBreadcrumb ( 'Query executed' , Breadcrumb :: PROCESS_TYPE , $ this -> formatQuery ( $ sql , $ show ? $ bindings : [ ] , $ time , $ connection ) ) ; } ) ; } }
1749	protected function import ( $ strClass , $ strKey = null , $ blnForce = false ) { $ strKey = $ strKey ? : $ strClass ; if ( \ is_object ( $ strKey ) ) { $ strKey = \ get_class ( $ strClass ) ; } if ( $ blnForce || ! isset ( $ this -> arrObjects [ $ strKey ] ) ) { $ container = static :: getContainer ( ) ; if ( \ is_object ( $ strClass ) ) { $ this -> arrObjects [ $ strKey ] = $ strClass ; } elseif ( $ container -> has ( $ strClass ) && ( strpos ( $ strClass , '\\' ) !== false || ! class_exists ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = $ container -> get ( $ strClass ) ; } elseif ( $ container instanceof Container && isset ( $ container -> getRemovedIds ( ) [ $ strClass ] ) ) { throw new ServiceNotFoundException ( $ strClass , null , null , array ( ) , sprintf ( 'The "%s" service or alias has been removed or inlined when the container was compiled. You should either make it public, or stop using the container directly and use dependency injection instead.' , $ strClass ) ) ; } elseif ( \ in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) { $ this -> arrObjects [ $ strKey ] = \ call_user_func ( array ( $ strClass , 'getInstance' ) ) ; } else { $ this -> arrObjects [ $ strKey ] = new $ strClass ( ) ; } } }
11149	protected function process ( array $ requestParams ) { $ request = new ExtDirectRequest ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; $ response = new ExtDirectResponse ( ) ; $ requestParameters = new Parameters ( ) ; try { $ request -> setApplicationPath ( $ this -> getApplicationPath ( ) ) ; $ requestParameters -> setParameters ( $ requestParams ) ; $ request -> injectParameters ( $ requestParameters ) ; $ response -> injectParameters ( $ requestParameters ) ; $ request -> injectResponse ( $ response ) ; $ request -> setParamMethod ( $ this -> getParamMethod ( ) ) ; $ request -> setMethodCalls ( $ this -> getMethodsToCall ( ) ) ; $ request -> run ( ) ; } catch ( ExtDirectApplicationException $ e ) { $ result = $ e -> getResponse ( ) ; if ( ! empty ( $ result ) ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) , "actions" => $ result ) ) ; } else { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } } catch ( \ Exception $ e ) { $ response -> setResult ( array ( "success" => false , "message" => $ e -> getMessage ( ) ) ) ; } return $ response ; }
9253	protected function getContainerInitializer ( ) { $ initializer = new DefaultInitializer ( $ this -> getConfigurationProvider ( ) ) ; if ( $ this -> cache ) { $ initializer = new CachedInitializer ( $ initializer , $ this -> getCacheDir ( ) ) ; } return $ initializer ; }
7348	protected function watch ( OrderShipmentInterface $ shipment ) { $ order = $ shipment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) ) { return ; } if ( $ shipment -> isReturn ( ) ) { if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_PENDING ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_PENDING ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_PENDING , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_PENDING , $ shipment ) ; return ; } if ( $ shipment -> getState ( ) === ShipmentStates :: STATE_RETURNED ) { if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_RETURNED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: RETURN_RECEIVED , $ shipment -> getNumber ( ) ) ) { return ; } $ this -> notify ( NotificationTypes :: RETURN_RECEIVED , $ shipment ) ; } return ; } if ( ! $ this -> didStateChangeTo ( $ shipment , ShipmentStates :: STATE_SHIPPED ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } if ( $ this -> hasNotification ( $ order , NotificationTypes :: SHIPMENT_SHIPPED , $ shipment -> getNumber ( ) ) ) { return ; } $ type = NotificationTypes :: SHIPMENT_SHIPPED ; if ( $ order -> getShipmentState ( ) !== ShipmentStates :: STATE_COMPLETED ) { $ type = NotificationTypes :: SHIPMENT_PARTIAL ; } $ this -> notify ( $ type , $ shipment ) ; }
5267	public function esc_value ( $ value ) { global $ wpdb ; if ( is_int ( $ value ) ) { return $ wpdb -> prepare ( '%d' , $ value ) ; } if ( is_float ( $ value ) ) { return $ wpdb -> prepare ( '%f' , $ value ) ; } if ( is_string ( $ value ) ) { return 'null' === $ value ? $ value : $ wpdb -> prepare ( '%s' , $ value ) ; } return $ value ; }
11928	public function getDataInterface ( ) { if ( ! $ this -> started ) { return $ this -> _interface ; } if ( is_null ( $ this -> _interface ) ) { $ interfaces = ArrayHelper :: map ( Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getAll ( ) , 'systemId' , 'object.name' ) ; $ this -> dataInterface = $ this -> select ( "Choose interface" , $ interfaces ) ; } return $ this -> _interface ; }
7099	private function ceilComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } >= $ quantity && $ b -> { $ property } < $ quantity ) { return - 1 ; } if ( $ a -> { $ property } < $ quantity && $ b -> { $ property } >= $ quantity ) { return 1 ; } return false ; }
9480	public function setErrorCode ( $ errorCode ) { $ this -> error = $ this -> config [ $ errorCode ] ; $ this -> errorCode = $ errorCode ; return $ this ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
3498	private function createChainVisitor ( ) : HttpProtocolChainVisitor { $ chainVisitors = new HttpProtocolChainVisitor ( ) ; $ visitors = clone $ this -> visitors ; $ priority = 0 ; foreach ( $ visitors as $ visitor ) { $ chainVisitors -> add ( $ visitor , ++ $ priority ) ; } return $ chainVisitors ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
261	protected function typecastValue ( $ value , $ type ) { if ( is_scalar ( $ type ) ) { if ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) { $ value = $ value -> __toString ( ) ; } switch ( $ type ) { case self :: TYPE_INTEGER : return ( int ) $ value ; case self :: TYPE_FLOAT : return ( float ) $ value ; case self :: TYPE_BOOLEAN : return ( bool ) $ value ; case self :: TYPE_STRING : if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; default : throw new InvalidArgumentException ( "Unsupported type '{$type}'" ) ; } } return call_user_func ( $ type , $ value ) ; }
12305	public function getAdminListHeader ( ) { return [ 'language_family' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.language_family' ) , ] , 'language' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.language' ) , ] , 'native_name' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.native_name' ) , ] , 'iso_639_1' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.iso_639_1' ) , ] , 'iso_639_2' => [ "type" => "text" , "label" => trans ( 'HCLanguages::languages.iso_639_2' ) , ] , 'front_end' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.front_end' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , 'back_end' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.back_end' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , 'content' => [ "type" => "checkbox" , "label" => trans ( 'HCLanguages::languages.content' ) , "url" => route ( 'admin.api.languages.update.strict' , 'id' ) ] , ] ; }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
12807	public static function where ( string $ column , string $ operator , $ value ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ column = self :: getColumnName ( $ column ) ; if ( $ column === null ) throw new ModelMissingPropertyException ( "Could not find a property '$column' of class '$class'. " . "Are you missing a '@ColumnNameAnnotation' on a property?" ) ; $ sql = "SELECT * FROM \"$tableName\" WHERE \"$column\" $operator " . ( gettype ( $ value ) === "string" ? "'$value'" : "$value" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
7100	private function equalComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } == $ quantity && $ b -> { $ property } != $ quantity ) { return - 1 ; } if ( $ a -> { $ property } != $ quantity && $ b -> { $ property } == $ quantity ) { return 1 ; } return false ; }
4514	public static function parse ( string $ string , array $ data = [ ] ) : array { if ( $ data ) { $ string = Parameters :: replace ( $ string , $ data ) ; } $ data = Yaml :: parse ( $ string , Yaml :: PARSE_OBJECT_FOR_MAP ) ; if ( ! property_exists ( $ data , 'objects' ) ) { throw new LogicException ( 'Property "objects" does not exist.' ) ; } if ( ! is_array ( $ data -> objects ) ) { throw new LogicException ( 'Property "objects" is not an array.' ) ; } $ prototype = [ ] ; if ( property_exists ( $ data , 'prototype' ) ) { if ( ! is_object ( $ data -> prototype ) ) { throw new LogicException ( 'Property "prototype" is not an object.' ) ; } $ prototype = $ data -> prototype ; } $ objects = [ ] ; foreach ( $ data -> objects as $ object ) { $ objects [ ] = ( object ) array_merge ( ( array ) $ prototype , ( array ) $ object ) ; } return $ objects ; }
11752	public function open ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_OPEN_COMMENT , $ params ] ) ; }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
9716	private function writeCountry ( ) { $ record = 0x008C ; $ length = 4 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> countryCode , $ this -> countryCode ) ; return $ this -> writeData ( $ header . $ data ) ; }
8341	public static function init ( ) { if ( self :: $ isInit === false ) { self :: $ prettyPageHandler = new PrettyPageHandler ( ) ; self :: $ prettyPageHandler -> setPageTitle ( 'I just broke a string... - strayFw' ) ; $ whoops = new Run ( ) ; $ whoops -> pushHandler ( new JsonResponseHandler ( ) ) ; $ whoops -> pushHandler ( self :: $ prettyPageHandler ) ; $ whoops -> register ( ) ; self :: $ isInit = true ; } }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
1764	private function canRunDbQuery ( ) : bool { try { return $ this -> connection -> isConnected ( ) && $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ 'tl_cron' ] ) ; } catch ( DriverException $ e ) { return false ; } }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
5484	public function hasSubmit ( SelectorInterface $ selector ) { foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { return true ; } } return false ; }
7118	protected function getGetAvailableSumBySubjectQuery ( ) { if ( null !== $ this -> getAvailableSumBySubjectQuery ) { return $ this -> getAvailableSumBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) -> select ( 'SUM(' . $ as . '.availableStock) as available' ) ; return $ this -> getAvailableSumBySubjectQuery = $ qb -> getQuery ( ) ; }
10498	public function root ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( pow ( $ this -> value , 1 / $ value ) ) ; }
3979	private function createCommand ( CommandCollectionInterface $ collection , $ operationName , $ queryParameters , $ icon , $ extraValues = [ ] ) { $ command = $ this -> getCommandInstance ( $ collection , $ operationName ) ; $ parameters = $ command -> getParameters ( ) ; foreach ( $ queryParameters as $ name => $ value ) { if ( ! isset ( $ parameters [ $ name ] ) ) { $ parameters [ $ name ] = $ value ; } } if ( ! $ command -> getLabel ( ) ) { $ command -> setLabel ( $ operationName . '.0' ) ; if ( isset ( $ extraValues [ 'label' ] ) ) { $ command -> setLabel ( $ extraValues [ 'label' ] ) ; } } if ( ! $ command -> getDescription ( ) ) { $ command -> setDescription ( $ operationName . '.1' ) ; if ( isset ( $ extraValues [ 'description' ] ) ) { $ command -> setDescription ( $ extraValues [ 'description' ] ) ; } } $ extra = $ command -> getExtra ( ) ; $ extra [ 'icon' ] = $ icon ; foreach ( $ extraValues as $ name => $ value ) { if ( ! isset ( $ extra [ $ name ] ) ) { $ extra [ $ name ] = $ value ; } } }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
10456	protected function setItem ( ItemPipelineEvent $ event ) { $ tempItem = $ event -> getItem ( ) ; if ( ! $ tempItem instanceof $ this -> importItemClass ) { $ this -> log ( "Item provided is not an {$this->importItemClass}" , LogLevel :: ERROR ) ; return false ; } $ this -> importItem = $ tempItem ; return true ; }
10750	protected function sendVerb ( string $ verb , Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { $ send = array_merge ( [ ] , $ extra ) ; $ send [ 'success' ] = true ; $ send [ 'message' ] = "Objects $verb successfully" ; $ send [ 'objects' ] = array_map ( function ( $ id ) use ( $ type ) { return [ 'type' => $ type , 'id' => $ id ] ; } , $ ids ) ; return $ this -> sendJson ( $ response , $ send ) ; }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
7548	function childCount ( $ ignore_text_comments = false ) { if ( ! $ ignore_text_comments ) { return count ( $ this -> children ) ; } else { $ count = 0 ; foreach ( array_keys ( $ this -> children ) as $ k ) { if ( ! $ this -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ count ; } } return $ count ; } }
7710	function UpdateParent ( $ Cascading = false ) { if ( $ this -> Parent ) { $ this -> Parent -> ReplaceSrc ( $ this -> Txt ) ; if ( $ Cascading ) $ this -> Parent -> UpdateParent ( $ Cascading ) ; } }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
1051	public static function getArgumentValues ( $ def , $ node , $ variableValues = null ) { if ( empty ( $ def -> args ) ) { return [ ] ; } $ argumentNodes = $ node -> arguments ; if ( empty ( $ argumentNodes ) ) { return [ ] ; } $ argumentValueMap = [ ] ; foreach ( $ argumentNodes as $ argumentNode ) { $ argumentValueMap [ $ argumentNode -> name -> value ] = $ argumentNode -> value ; } return static :: getArgumentValuesForMap ( $ def , $ argumentValueMap , $ variableValues , $ node ) ; }
11711	public function actionBlock ( $ id , $ back = 'index' ) { if ( $ id == \ Yii :: $ app -> user -> getId ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'danger' , \ Yii :: t ( 'user' , 'You can not block your own account' ) ) ; } else { $ user = $ this -> findModel ( $ id ) ; if ( $ user -> getIsBlocked ( ) ) { $ user -> unblock ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been unblocked' ) ) ; } else { $ user -> block ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been blocked' ) ) ; } } $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
1851	public function generate ( $ rootPageId , $ blnReturn = false , $ blnPreferAlias = false ) { if ( ! $ blnReturn ) { $ this -> redirect ( $ this -> getRedirectUrl ( $ rootPageId ) , 302 ) ; } $ objNextPage = $ this -> getNextPage ( $ rootPageId ) ; return ( $ blnPreferAlias && $ objNextPage -> alias != '' ) ? $ objNextPage -> alias : $ objNextPage -> id ; }
5479	protected function addRadioButton ( $ tag ) { if ( ! isset ( $ this -> radios [ $ tag -> getName ( ) ] ) ) { $ this -> widgets [ ] = new SimpleRadioGroup ( ) ; $ this -> radios [ $ tag -> getName ( ) ] = count ( $ this -> widgets ) - 1 ; } $ this -> widgets [ $ this -> radios [ $ tag -> getName ( ) ] ] -> addWidget ( $ tag ) ; }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
4301	public function groupSummary ( $ priority = 0 ) { array ( $ priority ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'priority' => 0 ) , array ( 'priority' ) ) ; $ this -> data [ 'groupPriorityStack' ] [ ] = $ meta [ 'priority' ] ; $ this -> setLogDest ( 'summary' ) ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; }
10077	public static function sanitizeUTF8 ( $ value ) { if ( self :: getIsIconvEnabled ( ) ) { $ value = @ iconv ( 'UTF-8' , 'UTF-8' , $ value ) ; return $ value ; } $ value = mb_convert_encoding ( $ value , 'UTF-8' , 'UTF-8' ) ; return $ value ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
7543	function getSibling ( $ offset = 1 ) { $ index = $ this -> index ( ) + $ offset ; if ( ( $ index >= 0 ) && ( $ index < $ this -> parent -> childCount ( ) ) ) { return $ this -> parent -> getChild ( $ index ) ; } else { return null ; } }
1220	private function validateSeq ( $ from , array $ types , $ a , $ b ) { $ ta = Utils :: type ( $ a ) ; $ tb = Utils :: type ( $ b ) ; if ( $ ta !== $ tb ) { $ msg = "encountered a type mismatch in sequence: {$ta}, {$tb}" ; $ this -> typeError ( $ from , $ msg ) ; } $ typeMatch = ( $ types && $ types [ 0 ] == 'any' ) || in_array ( $ ta , $ types ) ; if ( ! $ typeMatch ) { $ msg = 'encountered a type error in sequence. The argument must be ' . 'an array of ' . implode ( '|' , $ types ) . ' types. ' . "Found {$ta}, {$tb}." ; $ this -> typeError ( $ from , $ msg ) ; } }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
4927	public function setListeners ( array $ specs ) { foreach ( $ specs as $ spec ) { if ( ! isset ( $ spec [ 'event' ] ) || ! isset ( $ spec [ 'service' ] ) ) { throw new \ DomainException ( 'Listener specification must be an array with the keys "event" and "service".' ) ; } $ method = isset ( $ spec [ 'method' ] ) ? $ spec [ 'method' ] : null ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ this -> setListener ( $ spec [ 'event' ] , $ spec [ 'service' ] , $ method , $ priority ) ; } return $ this ; }
10696	public function toArray ( ) : array { if ( empty ( $ this -> output ) ) { $ problem = [ 'type' => $ this -> type ? ( string ) $ this -> type : 'about:blank' ] ; if ( $ this -> title ) { $ problem [ 'title' ] = $ this -> title ; } if ( $ this -> status ) { $ problem [ 'status' ] = $ this -> status ; } if ( $ this -> detail ) { $ problem [ 'detail' ] = $ this -> detail ; } if ( $ this -> instance ) { $ problem [ 'instance' ] = ( string ) $ this -> instance ; } $ this -> output = array_merge ( $ problem , $ this -> extensions ) ; } return $ this -> output ; }
10655	public function groupBy ( $ func ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( is_object ( $ it -> current ( ) ) ) { $ key = call_user_func ( $ func , $ it -> current ( ) ) ; } else { $ value = $ it -> current ( ) ; $ key = call_user_func_array ( $ func , array ( & $ value ) ) ; $ it -> offsetSet ( $ it -> key ( ) , $ value ) ; unset ( $ value ) ; } if ( is_array ( $ key ) ) { $ ref = & $ ret ; foreach ( $ key as $ subkey ) { if ( ! array_key_exists ( $ subkey , $ ref ) ) { $ ref [ $ subkey ] = array ( ) ; } $ ref = & $ ref [ $ subkey ] ; } $ ref [ ] = $ it -> current ( ) ; } else { $ ret [ $ key ] [ ] = $ it -> current ( ) ; } $ it -> next ( ) ; } unset ( $ ref ) ; $ ret = new self ( $ ret ) ; $ this -> exchangeArray ( $ ret -> getArrayCopy ( ) ) ; return $ this ; }
1100	protected function guardAgainstImpossibleMove ( ) { if ( ! $ this -> node -> exists ) throw new MoveNotPossibleException ( 'A new node cannot be moved.' ) ; if ( array_search ( $ this -> position , array ( 'child' , 'left' , 'right' , 'root' ) ) === FALSE ) throw new MoveNotPossibleException ( "Position should be one of ['child', 'left', 'right'] but is {$this->position}." ) ; if ( ! $ this -> promotingToRoot ( ) ) { if ( is_null ( $ this -> target ) ) { if ( $ this -> position === 'left' || $ this -> position === 'right' ) throw new MoveNotPossibleException ( "Could not resolve target node. This node cannot move any further to the {$this->position}." ) ; else throw new MoveNotPossibleException ( 'Could not resolve target node.' ) ; } if ( $ this -> node -> equals ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to itself.' ) ; if ( $ this -> target -> insideSubtree ( $ this -> node ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a descendant of itself (inside moved tree).' ) ; if ( ! $ this -> node -> inSameScope ( $ this -> target ) ) throw new MoveNotPossibleException ( 'A node cannot be moved to a different scope.' ) ; } }
4300	public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { $ priorityClosing = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; unset ( $ this -> data [ 'groupStacks' ] [ $ priorityClosing ] ) ; $ this -> setLogDest ( 'auto' ) ; $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } }
2438	public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { if ( \ in_array ( $ k , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ k , $ v ) ; } else { $ this -> sessionBag -> set ( $ k , $ v ) ; } } }
5828	public function newRequest ( $ method , $ url , $ data = array ( ) , $ encoding = Request :: ENCODING_QUERY ) { $ class = $ this -> requestClass ; $ request = new $ class ( $ this ) ; $ request -> setMethod ( $ method ) ; $ request -> setUrl ( $ url ) ; $ request -> setData ( $ data ) ; $ request -> setEncoding ( $ encoding ) ; return $ request ; }
8231	public static function getItemByUrl ( $ items , $ url ) { if ( ! isset ( $ items ) ) { return null ; } if ( array_key_exists ( "/" . $ url , $ items ) ) { return $ items [ "/" . $ url ] ; } $ urlParts = explode ( "/" , trim ( $ url , "/" ) ) ; $ urlPartsLen = count ( $ urlParts ) ; while ( $ urlPartsLen > 0 ) { unset ( $ urlParts [ -- $ urlPartsLen ] ) ; $ subUrl = "/" . join ( "/" , $ urlParts ) ; if ( array_key_exists ( $ subUrl , $ items ) && ( ! isset ( $ items [ $ subUrl ] [ "recursive" ] ) || $ items [ $ subUrl ] [ "recursive" ] === true ) ) { return $ items [ $ subUrl ] ; } } return null ; }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
6087	public function retrieveTemplate ( $ templateId , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates/' . $ templateId . '' , $ parameters , $ cachePolicy ) ; $ result = new MoodboardTemplateResponse ( $ result ) ; return $ result ; }
1069	private function collectConflictsBetweenFieldsAndFragment ( ValidationContext $ context , array & $ conflicts , array & $ comparedFragments , $ areMutuallyExclusive , array $ fieldMap , $ fragmentName ) { if ( isset ( $ comparedFragments [ $ fragmentName ] ) ) { return ; } $ comparedFragments [ $ fragmentName ] = true ; $ fragment = $ context -> getFragment ( $ fragmentName ) ; if ( ! $ fragment ) { return ; } [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getReferencedFieldsAndFragmentNames ( $ context , $ fragment ) ; if ( $ fieldMap === $ fieldMap2 ) { return ; } $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; for ( $ i = 0 ; $ i < $ fragmentNames2Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap , $ fragmentNames2 [ $ i ] ) ; } }
719	public function time ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIME , $ precision ) ; }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
7598	public function render ( $ sGlyphicon , array $ aGlyphiconAttributes = null ) { if ( ! is_scalar ( $ sGlyphicon ) ) { throw new InvalidArgumentException ( 'Glyphicon expects a scalar value, "' . gettype ( $ sGlyphicon ) . '" given' ) ; } if ( empty ( $ aGlyphiconAttributes ) ) { $ aGlyphiconAttributes = array ( 'class' => 'glyphicon' ) ; } else { if ( empty ( $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] = 'glyphicon' ; } elseif ( ! preg_match ( '/(\s|^)glyphicon(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' glyphicon' ; } } if ( strpos ( 'glyphicon-' , $ sGlyphicon ) !== 0 ) { $ sGlyphicon = 'glyphicon-' . $ sGlyphicon ; } if ( ! preg_match ( '/(\s|^)' . preg_quote ( $ sGlyphicon , '/' ) . '(\s|$)/' , $ aGlyphiconAttributes [ 'class' ] ) ) { $ aGlyphiconAttributes [ 'class' ] .= ' ' . $ sGlyphicon ; } return sprintf ( static :: $ glyphiconFormat , $ this -> createAttributesString ( $ aGlyphiconAttributes ) ) ; }
8607	private function _convertListSubscriptions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } return $ parameters ; }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
11314	public static function getNormalizedUrl ( Url $ url ) { $ scheme = $ url -> getScheme ( ) ; $ host = $ url -> getHost ( ) ; $ port = $ url -> getPort ( ) ; $ path = $ url -> getPath ( ) ; if ( ( ( $ port == 80 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'http' ) == 0 ) || ( ( $ port == 443 || empty ( $ port ) ) && strcasecmp ( $ scheme , 'https' ) == 0 ) ) { $ normalizedUrl = $ scheme . '://' . $ host . $ path ; } else { if ( ! empty ( $ port ) ) { $ normalizedUrl = $ scheme . '://' . $ host . ':' . $ port . $ path ; } else { throw new RuntimeException ( 'No port specified' ) ; } } return strtolower ( $ normalizedUrl ) ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
2045	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . htmlspecialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
7980	public function getSessionFiles ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFiles ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
6093	public function section ( $ separator , $ first = 0 , $ last = 0 ) { $ sections = explode ( $ separator , $ this -> string ) ; $ total = count ( $ sections ) ; $ first = intval ( $ first ) ; $ last = intval ( $ last ) ; if ( $ first > $ total ) { return null ; } if ( $ first > $ last ) { $ last = $ first ; } for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { if ( $ i < $ first || $ i > $ last ) { unset ( $ sections [ $ i ] ) ; } } $ string = implode ( $ separator , $ sections ) ; return new self ( $ string ) ; }
12230	public function deleteNodes ( $ xpath ) { if ( ! is_string ( $ xpath ) ) { throw new InvalidArgumentException ( 'Argument 1 passed to deleteNodes() must be a string, ' . gettype ( $ xpath ) . ' given' ) ; } $ nodes = $ this -> _xpath ( $ xpath ) ; if ( isset ( $ nodes [ 0 ] ) ) { $ tmp = dom_import_simplexml ( $ nodes [ 0 ] ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { unset ( $ nodes [ 0 ] ) ; } } foreach ( $ nodes as $ node ) { $ node -> deleteSelf ( ) ; } return count ( $ nodes ) ; }
3011	public function follow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/follow' , $ options , false ) ; }
5120	private function requestGate ( string $ method , string $ path , array $ header = [ ] , array $ body = [ ] , array $ options = [ ] ) : string { if ( empty ( $ this -> accessToken ) ) { $ this -> renewAuthToken ( ) ; } $ request = new \ GuzzleHttp \ Psr7 \ Request ( $ method , $ path , array_merge ( $ this -> options -> get ( 'default_headers' ) , $ header ) , $ this -> createBodyForRequest ( $ this -> prepareMultipartData ( $ body ) ) ) ; return ( string ) $ this -> sendRequest ( $ request ) ; }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
2434	public function set ( $ strKey , $ varValue ) { if ( \ in_array ( $ strKey , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ strKey , $ varValue ) ; } else { $ this -> sessionBag -> set ( $ strKey , $ varValue ) ; } }
694	public function sendMultiple ( array $ messages ) { $ successCount = 0 ; foreach ( $ messages as $ message ) { if ( $ this -> send ( $ message ) ) { $ successCount ++ ; } } return $ successCount ; }
964	public function dispatchWebhooks ( ) { $ webhooks = Config :: get ( 'shopify-app.webhooks' ) ; if ( count ( $ webhooks ) > 0 ) { WebhookInstaller :: dispatch ( $ this -> shop ) -> onQueue ( Config :: get ( 'shopify-app.job_queues.webhooks' ) ) ; } }
7868	private function replaceUtf8 ( & $ original , $ replacement , $ position ) { $ start = mb_substr ( $ original , 0 , $ position , "UTF-8" ) ; $ end = mb_substr ( $ original , $ position + 1 , mb_strlen ( $ original , 'UTF-8' ) , "UTF-8" ) ; $ original = $ start . $ replacement . $ end ; }
1549	protected function authorizeRelationship ( AuthorizerInterface $ authorizer , $ request , $ record , string $ field ) : void { if ( $ this -> isModifyRelationship ( $ request ) ) { $ authorizer -> modifyRelationship ( $ record , $ field , $ request ) ; return ; } $ authorizer -> readRelationship ( $ record , $ field , $ request ) ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
3730	protected function getMatchingIds ( $ objFilter ) { if ( $ objFilter ) { $ arrFilteredIds = $ objFilter -> getMatchingIds ( ) ; if ( $ arrFilteredIds !== null ) { return $ arrFilteredIds ; } } return $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'id' ) -> from ( $ this -> getTableName ( ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; }
2047	public function onSchemaIndexDefinition ( SchemaIndexDefinitionEventArgs $ event ) : void { if ( method_exists ( AbstractPlatform :: class , 'supportsColumnLengthIndexes' ) ) { return ; } $ connection = $ event -> getConnection ( ) ; if ( ! $ connection -> getDatabasePlatform ( ) instanceof MySqlPlatform ) { return ; } $ data = $ event -> getTableIndex ( ) ; if ( 'PRIMARY' === $ data [ 'name' ] ) { return ; } $ columns = [ ] ; $ query = sprintf ( "SHOW INDEX FROM %s WHERE Key_name='%s'" , $ event -> getTable ( ) , $ data [ 'name' ] ) ; $ result = $ connection -> executeQuery ( $ query ) ; while ( $ row = $ result -> fetch ( ) ) { if ( null !== $ row [ 'Sub_part' ] ) { $ columns [ ] = sprintf ( '%s(%s)' , $ row [ 'Column_name' ] , $ row [ 'Sub_part' ] ) ; } else { $ columns [ ] = $ row [ 'Column_name' ] ; } } $ event -> setIndex ( new Index ( $ data [ 'name' ] , $ columns , $ data [ 'unique' ] , $ data [ 'primary' ] , $ data [ 'flags' ] , $ data [ 'options' ] ) ) ; $ event -> preventDefault ( ) ; }
4551	public function getList ( $ form ) : array { $ objects = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c3c86110000f8016df7de' ) ; $ list = [ ] ; foreach ( $ objects as $ object ) { $ model = static :: toModel ( $ object ) ; $ list [ ] = $ model ; } return $ list ; }
4739	public static function clearTmp ( $ clearFolderPath = '' ) { $ folderPath = self :: _getFolderToClear ( $ clearFolderPath ) ; $ directoryHandler = opendir ( $ folderPath ) ; if ( ! empty ( $ directoryHandler ) ) { while ( false !== ( $ fileName = readdir ( $ directoryHandler ) ) ) { $ filePath = $ folderPath . DIRECTORY_SEPARATOR . $ fileName ; self :: _clear ( $ fileName , $ filePath ) ; } closedir ( $ directoryHandler ) ; } return true ; }
2758	protected function getNewRatio ( $ key , $ limit , $ milliseconds ) { $ lastRequest = $ this -> getLastRequest ( $ key ) ? : 0 ; $ lastRatio = $ this -> getLastRatio ( $ key ) ? : 0 ; $ diff = ( microtime ( 1 ) - $ lastRequest ) * 1000 ; $ newRatio = $ lastRatio - $ diff ; $ newRatio = $ newRatio < 0 ? 0 : $ newRatio ; $ newRatio += $ milliseconds / $ limit ; return $ newRatio ; }
12386	public function parse ( ) { $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> sortByName ( ) -> in ( $ this -> pagesDir ) ; $ languages = $ this -> configurationHandler -> languages ( ) ; $ homepage = $ this -> configurationHandler -> homepage ( ) ; foreach ( $ pages as $ page ) { $ pageDir = ( string ) $ page ; $ pageName = basename ( $ pageDir ) ; $ pageDefinitionFile = $ pageDir . '/' . $ this -> pageFile ; if ( ! file_exists ( $ pageDefinitionFile ) ) { continue ; } $ seoDefinition = $ this -> fetchSeoDefinition ( $ this -> pagesDir . '/' . $ pageName , $ this -> seoFile , $ languages ) ; $ pageDefinition = json_decode ( file_get_contents ( $ pageDefinitionFile ) , true ) ; $ pageDefinition [ "seo" ] = $ seoDefinition ; $ pageDefinition [ "isHome" ] = $ homepage == $ pageName ; $ this -> pages [ $ pageName ] = $ pageDefinition ; } return $ this ; }
298	public function updateAttributes ( $ attributes ) { $ attrs = [ ] ; foreach ( $ attributes as $ name => $ value ) { if ( is_int ( $ name ) ) { $ attrs [ ] = $ value ; } else { $ this -> $ name = $ value ; $ attrs [ ] = $ name ; } } $ values = $ this -> getDirtyAttributes ( $ attrs ) ; if ( empty ( $ values ) || $ this -> getIsNewRecord ( ) ) { return 0 ; } $ rows = static :: updateAll ( $ values , $ this -> getOldPrimaryKey ( true ) ) ; foreach ( $ values as $ name => $ value ) { $ this -> _oldAttributes [ $ name ] = $ this -> _attributes [ $ name ] ; } return $ rows ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
7484	public function endsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( $ this -> length ( ) - mb_strlen ( $ string , $ this -> encoding ) ) -> __toString ( ) ; }
1157	protected function ruleConfirmed ( $ attribute , array $ parameters ) { $ parameters [ 0 ] = $ this -> getAttributeName ( $ attribute ) ; $ attribute = "{$attribute}_confirmation" ; return [ $ attribute , $ parameters ] ; }
2109	public function getRelatedRecords ( ) { $ arrRelated = array ( ) ; $ objDatabase = Database :: getInstance ( ) ; $ objRelated = $ objDatabase -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ this -> id ) ; while ( $ objRelated -> next ( ) ) { $ arrRelated [ $ objRelated -> relTable ] [ ] = $ objRelated -> relId ; } return $ arrRelated ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
12453	static function run_generate_sample_package_xml ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_copy ( self :: getResourceDir ( ) . '/package_master.xml' , 'package.xml' ) ; $ tokens = array ( '$summary' => '[Summary]' , '$description' => '[Description]' , '$vendor' => '' , '$maintainers' => '' , '$documents' => '' , '$changelog' => '' , '$simple-files' => '' , '$state' => '[State]' , '$requires' => '' ) ; pake_replace_tokens ( 'package.xml' , '.' , '{' , '}' , $ tokens ) ; pake_echo ( "File package.xml generated. Please replace all tokens in square brackets in it (but do not replace values in curly brackets) then commit it to sources in the top dir of the extension" ) ; }
404	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] , true ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } if ( in_array ( '*' , $ this -> cors [ 'Origin' ] , true ) ) { if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) && $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) { if ( YII_DEBUG ) { throw new InvalidConfigException ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." ) ; } else { Yii :: error ( "Allowing credentials for wildcard origins is insecure. Please specify more restrictive origins or set 'credentials' to false in your CORS configuration." , __METHOD__ ) ; } } else { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = '*' ; } } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && $ this -> request -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Allow-Headers' ] ) ; } return $ responseHeaders ; }
8012	public static function forChallengeMessage ( $ challenge_message , $ code = 0 , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE ; $ reason_messages = [ ] ; if ( ( self :: CODE_FOR_INVALID_SIGNATURE & $ code ) === self :: CODE_FOR_INVALID_SIGNATURE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_SIGNATURE ; } if ( ( self :: CODE_FOR_INVALID_MESSAGE_TYPE & $ code ) === self :: CODE_FOR_INVALID_MESSAGE_TYPE ) { $ reason_messages [ ] = self :: MESSAGE_FOR_INVALID_MESSAGE_TYPE ; } $ message .= sprintf ( self :: MESSAGE_EXTENSION_FOR_REASONS_FORMAT , implode ( self :: MESSAGE_REASON_GLUE , $ reason_messages ) ) ; $ instance = new static ( $ message , $ code , $ previous ) ; $ instance -> challenge_message = $ challenge_message ; return $ instance ; }
10727	public function getYear ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'year' ] ; } }
7587	protected function extractFileName ( ) { foreach ( explode ( "\r\n" , $ this -> headers ) as $ header ) { if ( strpos ( $ header , 'filename' ) !== false && strpos ( $ header , 'Content-Disposition' ) !== false ) { $ fileName = substr ( $ header , ( strpos ( $ header , "=" ) + 1 ) ) ; $ this -> setFileName ( $ fileName ) ; break ; } } }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
11730	public function validatePassword ( ) { $ user = User :: findByEmail ( $ this -> email ) ; if ( ! $ user || ! $ user -> validatePassword ( $ this -> password ) ) { $ this -> addError ( 'password' , 'Incorrect username or password.' ) ; } }
11916	public function response ( array $ data , $ http_code ) { if ( config ( 'odin.queryRequest' ) ) { $ data [ 'queries' ] = $ this -> getQueries ( ) ; } return response ( ) -> json ( $ data , $ http_code ) ; }
9354	public function subMatrix ( $ int_m , $ int_n ) { $ sm = new self ( $ this -> size -> rows - 1 , $ this -> size -> cols - 1 ) ; foreach ( $ this -> arr as $ m => $ row ) { if ( $ m != $ int_m ) { $ arr_row = array ( ) ; foreach ( $ row as $ n => $ v ) { if ( $ n != $ int_n ) { $ arr_row [ ] = $ v ; } } $ sm -> addRow ( $ arr_row ) ; } } return $ sm ; }
12338	public function changeSecurityQuestionAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-security-question' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangeSecurityQuestionForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post ) { $ identity = $ this -> getUserService ( ) -> changeSecurityQuestion ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-security-question-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
2790	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( float ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1.0 ; } elseif ( $ num == 1 ) { $ replace = 0.0 ; } elseif ( $ num < 2 ) { $ replace = $ num + 1 ; } else { $ replace = 1.0 ; } $ tokens [ $ index ] = [ T_DNUMBER , sprintf ( "%.2f" , $ replace ) ] ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
5354	public function getAuthenticationData ( $ method ) { if ( ! $ this -> supportsAuthentication ( $ method ) ) { return null ; } $ authentication = $ this -> getSupportedAuthentication ( ) ; return $ authentication [ $ method ] ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
10527	public function getValue ( ) { static $ ip = null ; if ( is_null ( $ ip ) ) { $ ip = $ this -> getIpAddressFromProxy ( ) ; if ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ) { $ ip = $ _SERVER [ 'REMOTE_ADDR' ] ; } } return $ ip ; }
1398	public function error ( $ error , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( is_string ( $ error ) ) { $ error = $ this -> api -> getErrors ( ) -> error ( $ error ) ; } else if ( is_array ( $ error ) ) { $ error = Error :: create ( $ error ) ; } if ( ! $ error instanceof ErrorInterface ) { throw new \ InvalidArgumentException ( 'Expecting a string, array or error object.' ) ; } return $ this -> errors ( $ error , $ defaultStatusCode , $ headers ) ; }
2493	protected function getRange ( $ operator , $ start , $ end ) { $ startBrace = '[' ; $ startValue = '*' ; $ endValue = '*' ; $ endBrace = ']' ; $ start = '"' . $ this -> escapeQuote ( $ this -> toString ( $ start ) , true ) . '"' ; $ end = '"' . $ this -> escapeQuote ( $ this -> toString ( $ end ) , true ) . '"' ; switch ( $ operator ) { case Operator :: GT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: GTE : $ startValue = $ start ; break ; case Operator :: LT : $ startBrace = '{' ; $ endBrace = '}' ; case Operator :: LTE : $ endValue = $ end ; break ; case Operator :: BETWEEN : $ startValue = $ start ; $ endValue = $ end ; break ; default : throw new \ RuntimeException ( "Unknown operator: $operator" ) ; } return "$startBrace$startValue TO $endValue$endBrace" ; }
12311	private function detectMimeType ( $ file ) { $ fileParts = explode ( '.' , $ file ) ; $ extension = array_pop ( $ fileParts ) ; $ extension = strtolower ( $ extension ) ; if ( array_key_exists ( $ extension , $ this -> mimeTypes ) ) { return $ this -> mimeTypes [ $ extension ] ; } if ( function_exists ( 'finfo_open' ) ) { $ finfo = finfo_open ( FILEINFO_MIME_TYPE ) ; $ mimeType = finfo_file ( $ finfo , $ file ) ; finfo_close ( $ finfo ) ; return $ mimeType ; } return 'application/octet-stream' ; }
5832	protected function createResponseObject ( $ response ) { $ info = curl_getinfo ( $ this -> ch ) ; $ headerSize = curl_getinfo ( $ this -> ch , CURLINFO_HEADER_SIZE ) ; $ headerText = substr ( $ response , 0 , $ headerSize ) ; $ headers = $ this -> headerToArray ( $ headerText ) ; $ body = substr ( $ response , $ headerSize ) ; $ class = $ this -> responseClass ; $ obj = new $ class ( $ body , $ headers , $ info ) ; return $ obj ; }
7764	private function documentOperations ( $ operations ) { if ( null === $ operations ) { return null ; } $ result = array ( ) ; foreach ( $ operations as $ operation ) { $ statusCodes = array ( ) ; foreach ( $ operation -> getStatusCodes ( ) as $ code => $ description ) { $ statusCodes [ ] = array ( 'code' => $ code , 'description' => $ description ) ; } $ result [ ] = array ( '@id' => '_:' . $ operation -> getName ( ) , '@type' => $ operation -> getType ( ) ? : 'hydra:Operation' , 'method' => $ operation -> getMethod ( ) , 'label' => ( $ operation -> getTitle ( ) ) ? : $ operation -> getDescription ( ) , 'description' => ( null === $ operation -> getTitle ( ) ) ? null : $ operation -> getDescription ( ) , 'expects' => $ this -> getTypeReferenceIri ( $ operation -> getExpects ( ) ) , 'returns' => $ this -> getTypeReferenceIri ( $ operation -> getReturns ( ) ) , 'statusCodes' => $ statusCodes ) ; } return $ result ; }
6830	protected function moveAssignment ( Stock \ StockAssignmentInterface $ assignment , Stock \ StockUnitInterface $ targetUnit , $ quantity ) { $ quantity = min ( $ quantity , $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippedQuantity ( ) ) ; if ( 0 >= $ quantity ) { return 0 ; } $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ saleItem = $ assignment -> getSaleItem ( ) ; $ this -> logger -> unitSold ( $ sourceUnit , - $ quantity ) ; $ sourceUnit -> setSoldQuantity ( $ sourceUnit -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ sourceUnit ) ; $ this -> logger -> unitSold ( $ targetUnit , $ quantity ) ; $ targetUnit -> setSoldQuantity ( $ targetUnit -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ targetUnit ) ; $ merge = null ; foreach ( $ targetUnit -> getStockAssignments ( ) as $ m ) { if ( $ m -> getSaleItem ( ) === $ saleItem ) { $ merge = $ m ; break ; } } if ( $ quantity == $ assignment -> getSoldQuantity ( ) ) { if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; $ this -> logger -> assignmentSold ( $ assignment , 0 , false ) ; $ assignment -> setSoldQuantity ( 0 ) -> setSaleItem ( null ) -> setStockUnit ( null ) ; $ this -> manager -> remove ( $ assignment ) ; } else { $ this -> logger -> assignmentUnit ( $ assignment , $ targetUnit ) ; $ assignment -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ assignment ) ; } } else { $ this -> logger -> assignmentSold ( $ assignment , - $ quantity ) ; $ assignment -> setSoldQuantity ( $ assignment -> getSoldQuantity ( ) - $ quantity ) ; $ this -> manager -> persist ( $ assignment ) ; if ( null !== $ merge ) { $ this -> logger -> assignmentSold ( $ merge , $ quantity ) ; $ merge -> setSoldQuantity ( $ merge -> getSoldQuantity ( ) + $ quantity ) ; $ this -> manager -> persist ( $ merge ) ; } else { $ create = $ this -> saleFactory -> createStockAssignmentForItem ( $ saleItem ) ; $ this -> logger -> assignmentSold ( $ create , $ quantity , false ) ; $ create -> setSoldQuantity ( $ quantity ) -> setSaleItem ( $ saleItem ) -> setStockUnit ( $ targetUnit ) ; $ this -> manager -> persist ( $ create ) ; } } return $ quantity ; }
8571	public function listRecommendations ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4898	private static function checkCache ( array $ configuration ) { $ config = $ configuration [ 'module_listener_options' ] ; $ options = new ListenerOptions ( $ config ) ; $ cache = new ClearCacheService ( $ options ) ; $ cache -> checkCache ( ) ; }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
6527	public static function resolveCurie ( $ curie ) : string { $ key = ( string ) $ curie ; if ( isset ( self :: $ curies [ $ key ] ) ) { return self :: $ classes [ self :: $ curies [ $ key ] ] ; } throw new NoMessageForCurie ( SchemaCurie :: fromString ( $ key ) ) ; }
1302	public function getDefaultLocale ( ) : Locale { foreach ( $ this -> locales as $ locale ) { if ( $ locale -> isDefault ( ) ) { return $ locale ; } } throw new \ RuntimeException ( 'No locale marked as default exists in this environment.' ) ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
4872	protected function triggerListeners ( EventInterface $ event , callable $ callback = null ) { if ( ! $ event instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } $ results = parent :: triggerListeners ( $ event , $ callback ) ; $ dependencies = $ event -> getDependencyResultCollection ( ) ; foreach ( $ results as $ result ) { if ( null !== $ result ) { try { $ dependencies -> add ( $ result ) ; } catch ( \ UnexpectedValueException $ e ) { } catch ( \ InvalidArgumentException $ e ) { } } } return $ results ; }
9320	protected function getEchoMethods ( ) { $ methods = [ 'compileRawEchos' => strlen ( stripcslashes ( $ this -> rawTags [ 0 ] ) ) , 'compileEscapedEchos' => strlen ( stripcslashes ( $ this -> escapedTags [ 0 ] ) ) , 'compileMarkdownEchos' => strlen ( stripcslashes ( $ this -> markdownTags [ 0 ] ) ) , 'compileRegularEchos' => strlen ( stripcslashes ( $ this -> contentTags [ 0 ] ) ) , ] ; uksort ( $ methods , function ( $ method1 , $ method2 ) use ( $ methods ) { if ( $ methods [ $ method1 ] > $ methods [ $ method2 ] ) { return - 1 ; } if ( $ methods [ $ method1 ] < $ methods [ $ method2 ] ) { return 1 ; } if ( $ method1 === 'compileRawEchos' ) { return - 1 ; } if ( $ method2 === 'compileRawEchos' ) { return 1 ; } if ( $ method1 === 'compileEscapedEchos' ) { return - 1 ; } if ( $ method2 === 'compileEscapedEchos' ) { return 1 ; } if ( $ method1 === 'compileMarkdownEchos' ) { return - 1 ; } if ( $ method2 === 'compileMarkdownEchos' ) { return 1 ; } } ) ; return $ methods ; }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
10519	public static function getBrowserUserAgentGenerated ( ) { static $ ua ; if ( isset ( $ ua ) ) { return $ ua ; } $ year = abs ( @ date ( 'Y' ) ) ; if ( $ year <= 2017 ) { return $ ua = self :: DEFAULT_USER_AGENT ; } $ user_agent = 'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:[version].0) Gecko/20100101 Firefox/[version].0' ; $ month = abs ( @ date ( 'm' ) ) ; $ version = 51 ; $ currentYear = ( $ year - 2017 ) ; $ currentVersion = is_int ( $ month / 2 ) ? $ month / 2 : abs ( $ month / 2 + 0.5 ) ; $ version += $ currentYear + $ currentVersion ; return $ ua = str_replace ( '[version]' , $ version , $ user_agent ) ; }
9526	private function checkValidityAndContinueParse ( ) { $ valid = $ this -> validateRequiredParameters ( ) ; if ( $ valid !== true ) { $ this -> errorHandler -> call ( $ this , $ valid , 'Missing required argument: ' . $ valid -> parameterName ) ; $ this -> valid = false ; return [ ] ; } return $ this -> parseEvery ( ) ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
3121	public function filter ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ subset = new static ( ) ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ subset -> add ( $ point ) ; } } return $ subset ; }
4072	private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; }
6845	public static function seconds ( $ step = 1 , $ start = 0 , $ end = 60 ) { $ step = ( int ) $ step ; $ seconds = array ( ) ; for ( $ i = $ start ; $ i < $ end ; $ i += $ step ) { $ seconds [ $ i ] = sprintf ( '%02d' , $ i ) ; } return $ seconds ; }
10782	public function andHaving ( $ column , $ op , $ value , $ isParam = true ) { $ this -> clauses [ ] = array ( "AND" , $ column , $ op , $ value , $ isParam ) ; return $ this ; }
3459	public function add ( Route $ route ) : void { if ( $ route instanceof Route ) { $ name = $ route -> getName ( ) ; } else { $ name = Route :: generateNameFromPath ( $ route -> getPath ( ) ) ; } $ baseRoute = new SymfonyRoute ( $ route -> getPath ( ) ) ; $ baseRoute -> setMethods ( $ route -> getMethods ( ) ) ; $ this -> routeCollection -> add ( $ name , $ baseRoute ) ; $ this -> routes [ $ name ] = $ route ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
8617	public function setInvalidSKU ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InvalidSKU' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5586	public function restart ( $ date = false ) { $ this -> cookie_jar -> restartSession ( $ date ) ; $ this -> authenticator -> restartSession ( ) ; $ this -> http_referer = null ; }
6075	public function setStatus ( $ id , $ status ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'status' => $ status ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/status' , $ parameters ) ; return $ result ; }
3892	public function getFilterParameterNames ( \ DC_Table $ objDc ) { $ return = array ( ) ; $ filter = $ objDc -> activeRecord -> metamodel_filtering ; if ( ! $ filter ) { return $ return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filter ) ; return $ collection -> getParameterFilterNames ( ) ; }
2437	public function setData ( $ arrData ) { if ( ! \ is_array ( $ arrData ) ) { throw new \ Exception ( 'Array required to set session data' ) ; } foreach ( $ this -> mappedKeys as $ strKey ) { if ( isset ( $ arrData [ $ strKey ] ) ) { $ this -> session -> set ( $ strKey , $ arrData [ $ strKey ] ) ; unset ( $ arrData [ $ strKey ] ) ; } } $ this -> sessionBag -> replace ( $ arrData ) ; }
5525	protected function createCodeForClass ( $ methods ) { $ implements = '' ; $ interfaces = $ this -> reflection -> getInterfaces ( ) ; $ interfaces = array_diff ( $ interfaces , [ 'Traversable' , 'Throwable' ] ) ; if ( count ( $ interfaces ) > 0 ) { $ implements = 'implements ' . implode ( ', ' , $ interfaces ) ; } $ code = 'class ' . $ this -> mock_class . ' extends ' . $ this -> mock_base . ' ' . $ implements . " {\n" ; $ code .= " function __construct() {\n" ; $ code .= " parent::__construct();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> createCodeForMethods ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
3327	private function correctProductAssignment ( $ variationModel , $ productIdentitiy ) { if ( null === $ variationModel ) { return ; } if ( ( int ) $ productIdentitiy -> getAdapterIdentifier ( ) === $ variationModel -> getArticle ( ) -> getId ( ) ) { return ; } $ this -> entityManager -> getConnection ( ) -> update ( 's_articles_details' , [ 'articleID' => $ productIdentitiy -> getAdapterIdentifier ( ) ] , [ 'id' => $ variationModel -> getId ( ) ] ) ; $ this -> logger -> notice ( 'migrated variation from existing product to connector handeled product.' , [ 'variation' => $ variationModel -> getNumber ( ) , 'old shopware product id' => $ variationModel -> getArticle ( ) -> getId ( ) , 'new shopware product id' => $ productIdentitiy -> getAdapterIdentifier ( ) , ] ) ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
9360	protected function middleware ( FinalCallback $ callback , ServerRequestInterface $ request ) { $ response = $ this -> container -> get ( self :: RESPONSE ) ; if ( interface_exists ( Application :: MIDDLEWARE ) === true ) { $ middleware = new Dispatcher ( $ this -> middlewares , $ response ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
1112	public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
9350	public function transpose ( ) { $ out = new self ( $ this -> size -> cols , $ this -> size -> rows ) ; foreach ( $ this -> arr as $ row ) { $ out -> addCol ( $ row ) ; } return $ out ; }
8038	public function find ( $ identifier , array $ fields = [ ] ) { $ results = $ this -> ldap -> search ( $ this -> base_dn , $ this -> search_filter . '=' . $ identifier , ( $ fields ? : $ this -> search_fields ) ) ; if ( count ( $ results ) > 0 ) { $ entry = $ this -> ldap -> entry ( $ results ) ; if ( isset ( $ entry [ 0 ] ) && ! empty ( $ entry [ 0 ] ) ) { return $ entry [ 0 ] ; } } throw new EmptySearchResultException ; }
314	public function getVendorPath ( ) { if ( $ this -> _vendorPath === null ) { $ this -> setVendorPath ( $ this -> getBasePath ( ) . DIRECTORY_SEPARATOR . 'vendor' ) ; } return $ this -> _vendorPath ; }
1194	public function setRequest ( Request $ request ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass a RequestStack in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ this -> request = $ request ; }
10609	public function classifiedAnswerAction ( ) { $ request = $ this -> getRequest ( ) ; $ response = $ this -> getResponse ( ) ; if ( ! $ request -> isPost ( ) ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; return new JsonModel ( array ( 'status' => 'danger' , 'message' => 'Invalid method call' ) ) ; } $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ data = array_merge_recursive ( $ this -> params ( ) -> fromPost ( ) , Json :: decode ( $ request -> getContent ( ) , Json :: TYPE_ARRAY ) ) ; try { $ response -> setStatusCode ( Response :: STATUS_CODE_200 ) ; $ userService -> classifiedAnswer ( $ data ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'La tua risposta è stata inviata!' ) ; } catch ( \ Exception $ e ) { $ response -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
4050	private function prepareInputScreen ( $ modelName , $ screen ) : array { if ( null === $ metaModel = $ this -> factory -> getMetaModel ( $ modelName ) ) { throw new \ InvalidArgumentException ( 'Could not retrieve MetaModel ' . $ modelName ) ; } $ caption = [ '' => $ metaModel -> getName ( ) ] ; $ description = [ '' => $ metaModel -> getName ( ) ] ; foreach ( StringUtil :: deserialize ( $ screen [ 'backendcaption' ] , true ) as $ languageEntry ) { $ langCode = $ languageEntry [ 'langcode' ] ; $ caption [ $ langCode ] = ! empty ( $ label = $ languageEntry [ 'label' ] ) ? $ label : $ caption [ '' ] ; $ description [ $ langCode ] = ! empty ( $ title = $ languageEntry [ 'description' ] ) ? $ title : $ description [ '' ] ; if ( $ metaModel -> getFallbackLanguage ( ) === $ langCode ) { $ caption [ '' ] = $ label ; $ description [ '' ] = $ title ; } } $ result = [ 'meta' => $ screen , 'properties' => $ this -> fetchPropertiesFor ( $ screen [ 'id' ] , $ metaModel ) , 'conditions' => $ this -> fetchConditions ( $ screen [ 'id' ] ) , 'groupSort' => $ this -> fetchGroupSort ( $ screen [ 'id' ] , $ metaModel ) , 'label' => $ caption , 'description' => $ description ] ; $ bySetting = $ this -> buildConditionTree ( $ result [ 'conditions' ] ) ; $ result [ 'legends' ] = $ this -> convertLegends ( $ result [ 'properties' ] , $ metaModel , $ bySetting ) ; return $ result ; }
7014	private function format_n ( & $ str ) { if ( strstr ( $ str , '%n' ) ) $ str = str_replace ( '%n' , sprintf ( '%01d' , $ this -> month ) , $ str ) ; }
11079	public static function getMonthName ( $ month ) { if ( $ month < 1 || $ month > 12 ) { return '' ; } $ monthNames = [ 1 => self :: poorManTranslate ( 'fts-shared' , 'January' ) , 2 => self :: poorManTranslate ( 'fts-shared' , 'February' ) , 3 => self :: poorManTranslate ( 'fts-shared' , 'March' ) , 4 => self :: poorManTranslate ( 'fts-shared' , 'April' ) , 5 => self :: poorManTranslate ( 'fts-shared' , 'May' ) , 6 => self :: poorManTranslate ( 'fts-shared' , 'June' ) , 7 => self :: poorManTranslate ( 'fts-shared' , 'July' ) , 8 => self :: poorManTranslate ( 'fts-shared' , 'August' ) , 9 => self :: poorManTranslate ( 'fts-shared' , 'September' ) , 10 => self :: poorManTranslate ( 'fts-shared' , 'October' ) , 11 => self :: poorManTranslate ( 'fts-shared' , 'November' ) , 12 => self :: poorManTranslate ( 'fts-shared' , 'December' ) , ] ; return $ monthNames [ $ month ] ; }
9952	public function setBreak ( $ pCoordinate , $ pBreak ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( $ pCoordinate != '' ) { if ( $ pBreak == self :: BREAK_NONE ) { if ( isset ( $ this -> breaks [ $ pCoordinate ] ) ) { unset ( $ this -> breaks [ $ pCoordinate ] ) ; } } else { $ this -> breaks [ $ pCoordinate ] = $ pBreak ; } } else { throw new Exception ( 'No cell coordinate specified.' ) ; } return $ this ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
5709	public function getButtonName ( ) { $ raw = $ this -> buttonName ? : $ this -> getButtonText ( ) ; return preg_replace ( '/[^a-z0-9-_]/' , '' , strtolower ( $ this -> getButtonText ( ) ) ) ; }
11102	public static function countryCodeThreeToTwo ( $ code ) { if ( ! array_key_exists ( $ code , self :: $ _countryCodes ) ) { return false ; } return self :: $ _countryCodes [ $ code ] ; }
10959	private function processSplFileInfo ( \ SplFileInfo $ file ) { if ( $ this -> getCurrentCommand ( ) -> isUsePathReplace ( ) ) { $ this -> getCurrentCommand ( ) -> setToDirectory ( NULL ) ; } $ filePathFrom = $ this -> prepareFilePathFrom ( $ file ) ; $ filePathTo = $ this -> prepareFilePathTo ( $ file ) ; $ this -> currentFilePathFrom = $ filePathFrom ; $ this -> currentFilePathTo = $ filePathTo ; $ this -> validateFileFrom ( $ filePathFrom ) ; $ this -> validateFileTo ( $ filePathTo ) ; if ( ! $ this -> isMoveIt ( ) ) { return null ; } $ result = $ this -> doSystemCommand ( $ filePathFrom , $ filePathTo ) ; return $ result ; }
8750	public static function dumpValue ( $ value , $ containerVariable , array $ usedVariables ) : InlineEntryInterface { if ( is_array ( $ value ) ) { return self :: dumpArray ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof ReferenceInterface ) { return self :: dumpReference ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( $ value instanceof DumpableInterface ) { return self :: dumpDefinition ( $ value , $ containerVariable , $ usedVariables ) ; } elseif ( is_object ( $ value ) || is_resource ( $ value ) ) { throw new \ RuntimeException ( 'Unable to dump a container if a parameter is an object or a resource.' ) ; } else { return new InlineEntry ( var_export ( $ value , true ) , null , $ usedVariables , false ) ; } }
11994	public function pipe ( $ data , $ index , $ isHeader = false ) { $ this -> lastIndex ++ ; $ this -> data [ $ this -> lastIndex ] = $ data ; }
10334	public function setName ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = 'Calibri' ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'name' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> name = $ pValue ; } return $ this ; }
1707	private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; }
4792	function select ( $ columns ) { $ this -> __destruct ( ) ; if ( $ columns != "" ) { foreach ( func_get_args ( ) as $ columns ) { $ this -> select [ ] = $ columns ; } } else { $ this -> select = array ( ) ; } return $ this ; }
1393	protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; }
6012	public function addCommentResponse ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CommentResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CommentResponse"!' , E_USER_WARNING ) ; } } $ this -> replies [ ] = $ item ; return $ this ; }
12912	public function join ( BaseManager $ manager , $ type = null , $ column = null , $ column_right = null ) { $ this -> joins [ $ manager -> table ] = array ( 'manager' => $ manager , 'type' => $ type , 'column' => $ column , 'column_right' => $ column_right ) ; return $ this ; }
2472	public function findSingle ( Criterion $ filter , array $ languageFilter = array ( ) ) { $ query = new Query ( ) ; $ query -> filter = $ filter ; $ query -> query = new Criterion \ MatchAll ( ) ; $ query -> offset = 0 ; $ query -> limit = 1 ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; $ result = $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) ) ; if ( ! $ result -> totalCount ) { throw new NotFoundException ( 'Content' , 'findSingle() found no content for given $filter' ) ; } elseif ( $ result -> totalCount > 1 ) { throw new InvalidArgumentException ( 'totalCount' , 'findSingle() found more then one item for given $filter' ) ; } $ first = reset ( $ result -> searchHits ) ; return $ first -> valueObject ; }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
5098	private function appendByPosition ( $ values ) { $ this -> setPart ( CmdInsert :: PART_AS , false ) ; if ( ! $ this -> placeholder ) $ this -> placeholder = Assembly :: placeholder ( count ( $ values ) , true ) ; return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ this -> placeholder , $ values ) ; }
5282	public function getVar ( ) { $ row = $ this -> one ( \ ARRAY_A ) ; return is_null ( $ row ) ? false : current ( $ row ) ; }
2074	public function purgeSearchTables ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search" ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_search_index" ) ; $ strCachePath = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCachePath . '/contao/search' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the search tables' , __METHOD__ , TL_CRON ) ; }
3526	private function parseStatItem ( $ stat ) : array { $ result = [ ] ; $ pieces = explode ( "_" , $ stat -> name ) ; $ result [ $ pieces [ 2 ] ] [ $ pieces [ 4 ] ] [ $ pieces [ 1 ] ] = $ stat -> value ; return $ result ; }
4035	public function getTemplatesForBase ( $ templateBaseName ) { $ allTemplates = array_replace_recursive ( $ this -> fetchTemplatesFromThemes ( $ templateBaseName ) , $ this -> fetchRootTemplates ( $ templateBaseName ) , $ this -> fetchTemplatesFromResourceDirectories ( $ templateBaseName ) ) ; $ templateList = array ( ) ; foreach ( $ allTemplates as $ template => $ themeList ) { $ templateList [ $ template ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'template_in_theme' ] , $ template , implode ( ', ' , $ themeList ) ) ; } ksort ( $ templateList ) ; return array_unique ( $ templateList ) ; }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
7502	private function getOrCreateGroup ( string $ namespace ) : Group { $ group = $ this -> em -> find ( Group :: getClass ( ) , $ namespace ) ; if ( null !== $ group ) { return $ group ; } $ group = new Group ( $ namespace ) ; $ t = $ this -> tm -> createTransaction ( ) ; $ this -> em -> persist ( $ group ) ; $ t -> commit ( ) ; return $ group ; }
12822	protected function resolveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'blockname' , ) ) ; parent :: resolveOptions ( $ options ) ; $ this -> optionsResolved = true ; }
6122	public function permissionGetNameById ( $ permid ) { foreach ( $ this -> permissionList ( ) as $ name => $ perm ) { if ( $ perm [ "permid" ] == $ permid ) { return new Ts3Exception ( $ name ) ; } } throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; }
6593	protected function parseTags ( array $ bustersOfThisType , $ type ) { $ busterStrings = array ( ) ; foreach ( $ bustersOfThisType as $ fileName => $ hash ) { $ template = $ this -> config [ $ type . 'Template' ] ; $ rootPath = $ this -> config [ 'rootPath' ] ; $ pathInfo = pathInfo ( $ fileName ) ; $ fileBasePath = $ pathInfo [ 'dirname' ] ; $ fileBaseName = $ pathInfo [ 'filename' ] ; $ template = str_replace ( '{{ROOT_PATH}}' , $ rootPath , $ template ) ; $ template = str_replace ( '{{HASH}}' , $ hash , $ template ) ; $ template = str_replace ( '{{FILE_PATH}}' , $ fileBasePath , $ template ) ; $ template = str_replace ( '{{FILE_NAME}}' , $ fileBaseName , $ template ) ; $ busterStrings [ ] = $ template ; } return $ busterStrings ; }
3679	private function buildBackendModules ( & $ localMenu ) { foreach ( $ this -> viewCombination -> getStandalone ( ) as $ metaModelName => $ screen ) { $ section = $ screen [ 'meta' ] [ 'backendsection' ] ; if ( ! isset ( $ localMenu [ $ section ] ) ) { $ localMenu [ $ section ] = [ ] ; } if ( ! isset ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] ) ) { $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] = [ 'tables' => [ ] ] ; } $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'callback' ] = Module :: class ; array_unshift ( $ localMenu [ $ section ] [ 'metamodel_' . $ metaModelName ] [ 'tables' ] , $ metaModelName ) ; } }
814	private function getNewLineIndex ( $ index , Tokens $ tokens ) { $ lineEnding = $ this -> whitespacesConfig -> getLineEnding ( ) ; for ( $ index , $ count = \ count ( $ tokens ) ; $ index < $ count ; ++ $ index ) { if ( false !== strstr ( $ tokens [ $ index ] -> getContent ( ) , $ lineEnding ) ) { return $ index ; } } return $ index ; }
11375	public function upload ( string $ sFile ) { if ( $ _FILES [ $ sFile ] [ 'error' ] > 0 ) { $ this -> _sError = "Error while the upload" ; return false ; } if ( $ _FILES [ $ sFile ] [ 'size' ] > $ this -> _iMaxFile ) { $ this -> _sError = "The file is too big" ; return false ; } $ sExtension = strtolower ( substr ( strrchr ( $ _FILES [ $ sFile ] [ 'name' ] , '.' ) , 1 ) ) ; if ( count ( $ this -> _aAllowExtension ) > 0 && ! in_array ( $ sExtension , $ this -> _aAllowExtension ) ) { $ this -> _sError = "The extension is not good" ; return false ; } $ sPath = str_replace ( 'bundles' . DIRECTORY_SEPARATOR . 'lib' , 'data' . DIRECTORY_SEPARATOR . 'upload' . DIRECTORY_SEPARATOR , __DIR__ ) ; if ( $ this -> _sExtension === null ) { $ this -> setExtension ( $ sExtension ) ; } if ( $ this -> _sName ) { $ sName = $ sPath . $ this -> _sName . '.' . $ this -> _sExtension ; } else { $ sName = $ sPath . md5 ( uniqid ( rand ( ) , true ) ) . '.' . $ this -> _sExtension ; } if ( $ this -> _bProportion === true && ( $ this -> _iWidth || $ this -> _iHeight ) ) { $ aImageSizes = getimagesize ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ fRatio = min ( $ aImageSizes [ 0 ] / $ this -> _iWidth , $ aImageSizes [ 1 ] / $ this -> _iHeight ) ; $ iHeight = $ aImageSizes [ 1 ] / $ fRatio ; $ iWidth = $ aImageSizes [ 0 ] / $ fRatio ; $ fY = ( $ iHeight - $ this -> _iHeight ) / 2 * $ fRatio ; $ fX = ( $ iWidth - $ this -> _iWidth ) / 2 * $ fRatio ; $ rNewImage = imagecreatefromjpeg ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ rNewImgTrueColor = imagecreatetruecolor ( $ this -> _iWidth , $ this -> _iHeight ) ; imagecopyresampled ( $ rNewImgTrueColor , $ rNewImage , 0 , 0 , $ fX , $ fY , $ this -> _iWidth , $ this -> _iHeight , $ iWidth * $ fRatio - $ fX * 2 , $ iHeight * $ fRatio - $ fY * 2 ) ; imagejpeg ( $ rNewImgTrueColor , $ sName , 100 ) ; } else { $ bResultat = move_uploaded_file ( $ _FILES [ $ sFile ] [ 'tmp_name' ] , $ sName ) ; if ( $ bResultat ) { return true ; } } }
9522	public function upsertDoc ( string $ collectionName , string $ docId , array $ docOrSubset ) : void { $ doc = $ this -> getDoc ( $ collectionName , $ docId ) ; if ( $ doc ) { $ this -> updateDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } else { $ this -> addDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
1731	public static function triggerImportUserHook ( $ username , $ password , $ strTable ) { $ self = new static ( ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) || ! \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] ) ) { return false ; } @ trigger_error ( 'Using the "importUser" hook has been deprecated and will no longer work in Contao 5.0. Use the contao.import_user event instead.' , E_USER_DEPRECATED ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'importUser' ] as $ callback ) { $ self -> import ( $ callback [ 0 ] , 'objImport' , true ) ; $ blnLoaded = $ self -> objImport -> { $ callback [ 1 ] } ( $ username , $ password , $ strTable ) ; if ( $ blnLoaded === true ) { return true ; } } return false ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
7185	public static function build ( StockUnitInterface $ unit , SaleInterface $ sale ) { $ releasable = 0 ; $ map = [ ] ; foreach ( $ unit -> getStockAssignments ( ) as $ a ) { if ( $ sale === $ s = $ a -> getSaleItem ( ) -> getSale ( ) ) { continue ; } if ( $ s -> getShipmentState ( ) === ShipmentStates :: STATE_PREPARATION ) { continue ; } if ( 0 < $ d = $ a -> getSoldQuantity ( ) - $ a -> getShippedQuantity ( ) ) { $ releasable += $ d ; $ map [ $ a -> getId ( ) ] = $ d ; } } arsort ( $ map , \ SORT_NUMERIC ) ; $ candidate = new static ; $ candidate -> unit = $ unit ; $ candidate -> shippable = $ unit -> getShippableQuantity ( ) ; $ candidate -> reservable = $ unit -> getReservableQuantity ( ) ; $ candidate -> releasable = $ releasable ; $ candidate -> map = $ map ; return $ candidate ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
12621	public function set ( $ key , $ value ) { ArrayDot :: set ( $ _SESSION [ $ this -> root ] , $ key , $ value ) ; }
11985	function scanf ( $ format ) { $ spec_pattern = "/%[+-]?('.)?[-]?(\d)*(\..\d)?[%bcdeEfFgGosuxX]/" ; $ source = substr ( $ this -> data , $ this -> pos ) ; $ result = sscanf ( $ source , $ format ) ; if ( $ result == - 1 ) return ; else { $ l = 0 ; foreach ( $ result as $ v ) { $ l += strlen ( "" . $ v ) ; } } $ no_patterns_format = preg_replace ( $ spec_pattern , "" , $ format ) ; $ l += strlen ( $ no_patterns_format ) ; $ this -> pos += $ l ; return $ result ; }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
8425	public function getAllActiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isNull ( 'p.expiry' ) , $ qb -> expr ( ) -> gt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , true ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> orderBy ( 'p.pinned' , 'DESC' ) -> addOrderBy ( 'p.created' , 'DESC' ) -> getQuery ( ) ; }
2663	public function configureBackend ( $ params , $ version , $ old_name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend/' . str_replace ( ' ' , '%20' , $ old_name ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ params ) ; return $ result ; }
12861	private function buildCache ( ) : array { $ dispatchData = $ this -> routeCollector -> getData ( ) ; file_put_contents ( $ this -> cacheFile , '<?php return ' . var_export ( $ dispatchData , true ) . ';' ) ; return $ dispatchData ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
4543	public function addFilterConstraint ( ClassMetadata $ targetEntity , $ targetTableAlias ) { if ( ! $ targetEntity -> reflClass -> implementsInterface ( Tenantable :: class ) ) { return '' ; } $ tenant = trim ( $ this -> getParameter ( 'tenant' ) , '\'' ) ; if ( '' === $ tenant ) { $ constraint = sprintf ( '%s.tenant is NULL' , $ targetTableAlias ) ; } else { $ constraint = sprintf ( '%s.tenant = \'%s\'' , $ targetTableAlias , $ tenant ) ; } return $ constraint ; }
8268	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } if ( ! file_exists ( $ this -> filePath ) ) { throw new \ RuntimeException ( $ this -> filePath . " does not exist" ) ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for reading: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_SH ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire a shared lock for " . $ this -> filePath ) ; } }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
3138	public function emptyResponse ( RunnerServiceContext $ context , $ responses ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ similar = 0 ; foreach ( $ responses as $ responseVariable ) { $ value = $ responseVariable -> getValue ( ) ; $ default = $ responseVariable -> getDefaultValue ( ) ; if ( TestRunnerUtils :: isQtiValueNull ( $ value ) === true ) { if ( TestRunnerUtils :: isQtiValueNull ( $ default ) === true ) { $ similar ++ ; } } elseif ( $ value -> equals ( $ default ) === true ) { $ similar ++ ; } } $ respCount = count ( $ responses ) ; return $ respCount > 0 && $ similar == $ respCount ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
6015	public function retrieveSite ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/sites/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
6129	protected function getCorpusTitle ( ) { if ( $ this -> currObj instanceof Server ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Clients: " . $ this -> currObj -> clientCount ( ) . "/" . $ this -> currObj [ "virtualserver_maxclients" ] . " | Uptime: " . Convert :: seconds ( $ this -> currObj [ "virtualserver_uptime" ] ) ; } elseif ( $ this -> currObj instanceof Channel && ! $ this -> currObj -> isSpacer ( ) ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Codec: " . Convert :: codec ( $ this -> currObj [ "channel_codec" ] ) . " | Quality: " . $ this -> currObj [ "channel_codec_quality" ] ; } elseif ( $ this -> currObj instanceof Client ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Version: " . Convert :: versionShort ( $ this -> currObj [ "client_version" ] ) . " | Platform: " . $ this -> currObj [ "client_platform" ] ; } elseif ( $ this -> currObj instanceof Servergroup || $ this -> currObj instanceof Channelgroup ) { return "ID: " . $ this -> currObj -> getId ( ) . " | Type: " . Convert :: groupType ( $ this -> currObj [ "type" ] ) . " (" . ( $ this -> currObj [ "savedb" ] ? "Permanent" : "Temporary" ) . ")" ; } return "" ; }
1708	public static function removeEntry ( $ strUrl ) { $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT id FROM tl_search WHERE url=?" ) -> execute ( $ strUrl ) ; while ( $ objResult -> next ( ) ) { $ objDatabase -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ objDatabase -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
8739	private function updateBase ( array $ values , array $ ids ) { $ query = $ this -> model -> newQuery ( ) -> whereIn ( $ this -> model -> getKeyName ( ) , $ ids ) -> getQuery ( ) ; return $ query -> update ( $ values ) ; }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
6212	protected function array2Node ( $ parentNode , $ key , $ params ) { if ( count ( $ params ) == 0 ) { return ; } $ node = $ parentNode -> addChild ( $ key ) ; foreach ( $ params as $ key => $ value ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ value = json_encode ( ( array ) $ value ) ; } $ node -> addChild ( 'var' , htmlspecialchars ( $ value ) ) -> addAttribute ( 'key' , $ key ) ; } }
10901	public function loadAll ( array $ where = [ ] , bool $ assoc = false , array $ fields = null ) : Collection { $ allData = $ this -> medoo -> select ( $ this -> getTable ( ) , $ fields ? $ fields : '*' , $ where ) ; $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::loadAll(' . \ print_r ( $ where , true ) . ', ' . $ assoc . ', ' . \ print_r ( $ fields , true ) . ')' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; $ items = [ ] ; foreach ( $ allData as $ data ) { $ items [ ] = ( $ assoc ) ? $ data : $ this -> container [ 'entity' ] ( $ this -> __getEntityName ( ) ) -> setData ( $ data ) ; } return new Collection ( $ items ) ; }
4016	protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; }
7274	protected function decodeValue ( $ val , $ column = "" ) { if ( $ column === static :: $ idColumn ) $ val = ( int ) $ val ; else if ( isset ( static :: $ casts [ $ column ] ) ) { switch ( static :: $ casts [ $ column ] ) { case "object" : $ val = from_json ( $ val , false ) ; break ; case "array" : $ val = from_json ( $ val , true ) ; break ; default : settype ( $ val , static :: $ casts [ $ column ] ) ; } } else if ( in_array ( $ column , static :: $ jsons ) && is_string ( $ val ) ) $ val = from_json ( $ val ) ; return $ val ; }
8317	protected function sendResetMail ( $ userData ) { if ( ! $ this -> mailer ) { $ this -> getLogger ( ) -> critical ( "Sending mail but no mailer is set!" ) ; return ; } $ url = $ this -> createResetToken ( $ userData [ 'name' ] ) ; $ message = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailMessage" ] ) ; $ subject = $ this -> picoAuth -> getPico ( ) -> substituteFileContent ( $ this -> config [ "emailSubject" ] ) ; $ message = str_replace ( "%url%" , $ url , $ message ) ; $ message = str_replace ( "%username%" , $ userData [ 'name' ] , $ message ) ; $ this -> mailer -> setup ( ) ; $ this -> mailer -> setTo ( $ userData [ 'email' ] ) ; $ this -> mailer -> setSubject ( $ subject ) ; $ this -> mailer -> setBody ( $ message ) ; if ( ! $ this -> mailer -> send ( ) ) { $ this -> getLogger ( ) -> critical ( "Mailer error: {e}" , [ "e" => $ this -> mailer -> getError ( ) ] ) ; } else { $ this -> getLogger ( ) -> info ( "PwReset email sent to {email}" , [ "email" => $ userData [ 'email' ] ] ) ; } }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
193	public function clear ( ) { $ this -> _headers = null ; $ this -> _cookies = null ; $ this -> _statusCode = 200 ; $ this -> statusText = 'OK' ; $ this -> data = null ; $ this -> stream = null ; $ this -> content = null ; $ this -> isSent = false ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
9617	public function registerSubscriber ( $ class , callable $ callback ) { $ service_id = "event." . strtolower ( str_replace ( "\\" , "." , $ class ) ) ; $ this [ $ service_id ] = $ callback ; $ this [ "dispatcher" ] -> addSubscriberService ( $ service_id , $ class ) ; }
11993	public function orderBy ( $ key , $ direction = 'asc' ) { return $ this -> sort ( function ( $ a , $ b ) use ( $ key , $ direction ) { $ valueA = is_object ( $ a ) ? $ a -> { $ key } : $ a [ $ key ] ; $ valueB = is_object ( $ b ) ? $ b -> { $ key } : $ b [ $ key ] ; if ( $ valueA == $ valueB ) return 0 ; $ result = ( $ valueA < $ valueB ) ? - 1 : 1 ; return $ direction === 'desc' ? - ( $ result ) : $ result ; } ) ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
11545	public function changeEmail ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeEmailForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setEmailConfirmed ( false ) ; $ viewModel = new ViewModel ( compact ( 'user' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-confirm-email' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Please, confirm your email!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
1342	public function getParameters ( ) : EncodingParametersInterface { if ( $ this -> parameters ) { return $ this -> parameters ; } return $ this -> parameters = $ this -> container -> make ( EncodingParametersInterface :: class ) ; }
976	public function deleteWebhooks ( ) { $ shopWebhooks = $ this -> shopWebhooks ( ) ; $ deleted = [ ] ; foreach ( $ shopWebhooks as $ webhook ) { $ this -> api -> rest ( 'DELETE' , "/admin/webhooks/{$webhook->id}.json" ) ; $ deleted [ ] = $ webhook ; } $ this -> shopWebhooks = null ; return $ deleted ; }
1670	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFolder ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFolder = $ strNewName ; } return $ return ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
3133	public function getRubrics ( RunnerServiceContext $ context , AssessmentItemRef $ itemRef = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ rubricHelper = $ this -> getServiceLocator ( ) -> get ( QtiRunnerRubric :: SERVICE_ID ) ; return $ rubricHelper -> getRubrics ( $ context , $ itemRef ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'getRubrics' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
8651	private function convertGetReport ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReport' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportId ( ) ) { $ parameters [ 'ReportId' ] = $ request -> getReportId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
9729	function toDateTime ( ) { return $ this -> date . " " . str_pad ( $ this -> hours , 2 , '0' , STR_PAD_LEFT ) . ":" . str_pad ( $ this -> minutes , 2 , '0' , STR_PAD_LEFT ) ; }
6807	public function createFromContext ( ContextInterface $ context ) { return $ this -> create ( $ context -> getLocale ( ) , $ context -> getCurrency ( ) -> getCode ( ) ) ; }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
2207	protected function compileYearlyMenu ( ) { $ arrData = array ( ) ; $ arrAllEvents = $ this -> getAllEvents ( $ this -> cal_calendar , 0 , 2145913200 ) ; foreach ( $ arrAllEvents as $ intDay => $ arrDay ) { foreach ( $ arrDay as $ arrEvents ) { $ arrData [ substr ( $ intDay , 0 , 4 ) ] += \ count ( $ arrEvents ) ; } } ( $ this -> cal_order == 'ascending' ) ? ksort ( $ arrData ) : krsort ( $ arrData ) ; $ arrItems = array ( ) ; $ count = 0 ; $ limit = \ count ( $ arrData ) ; foreach ( $ arrData as $ intYear => $ intCount ) { $ intDate = $ intYear ; $ quantity = sprintf ( ( ( $ intCount < 2 ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entry' ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'entries' ] ) , $ intCount ) ; $ arrItems [ $ intYear ] [ 'date' ] = $ intDate ; $ arrItems [ $ intYear ] [ 'link' ] = $ intYear ; $ arrItems [ $ intYear ] [ 'href' ] = $ this -> strLink . '?year=' . $ intDate ; $ arrItems [ $ intYear ] [ 'title' ] = StringUtil :: specialchars ( $ intYear . ' (' . $ quantity . ')' ) ; $ arrItems [ $ intYear ] [ 'class' ] = trim ( ( ( ++ $ count == 1 ) ? 'first ' : '' ) . ( ( $ count == $ limit ) ? 'last' : '' ) ) ; $ arrItems [ $ intYear ] [ 'isActive' ] = ( Input :: get ( 'year' ) == $ intDate ) ; $ arrItems [ $ intYear ] [ 'quantity' ] = $ quantity ; } $ this -> Template -> yearly = true ; $ this -> Template -> items = $ arrItems ; $ this -> Template -> showQuantity = ( $ this -> cal_showQuantity != '' ) ? true : false ; }
1711	public function setEmptyEndTime ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue === null ) { $ varValue = $ dc -> activeRecord -> startTime ; } return $ varValue ; }
6034	public function setMimeType ( $ mimeType ) { if ( $ mimeType instanceof MimeType ) { $ this -> mimeType = $ mimeType ; } elseif ( is_array ( $ mimeType ) ) { $ this -> mimeType = new MimeType ( $ mimeType ) ; } else { $ this -> mimeType = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
3846	protected static function changeSubPalettesToConditions ( ) { $ objDB = self :: DB ( ) ; if ( ! $ objDB -> tableExists ( 'tl_metamodel_dcasetting_condition' ) ) { $ objDB -> execute ( 'CREATE TABLE `tl_metamodel_dcasetting_condition` ( `id` int(10) unsigned NOT NULL auto_increment, `pid` int(10) unsigned NOT NULL default \'0\', `settingId` int(10) unsigned NOT NULL default \'0\', `sorting` int(10) unsigned NOT NULL default \'0\', `tstamp` int(10) unsigned NOT NULL default \'0\', `enabled` char(1) NOT NULL default \'\', `type` varchar(255) NOT NULL default \'\', `attr_id` int(10) unsigned NOT NULL default \'0\', `comment` varchar(255) NOT NULL default \'\', `value` blob NULL, PRIMARY KEY (`id`) )ENGINE=MyISAM DEFAULT CHARSET=utf8;' ) ; } if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && $ objDB -> fieldExists ( 'subpalette' , 'tl_metamodel_dcasetting' , true ) ) { $ subpalettes = $ objDB -> execute ( 'SELECT * FROM tl_metamodel_dcasetting WHERE subpalette!=0' ) ; if ( $ subpalettes -> numRows ) { $ attributes = $ objDB -> execute ( ' SELECT attr_id, colName FROM tl_metamodel_dcasetting AS setting LEFT JOIN tl_metamodel_attribute AS attribute ON (setting.attr_id=attribute.id) WHERE dcatype=\'attribute\' ' ) ; $ attr = array ( ) ; while ( $ attributes -> next ( ) ) { $ attr [ $ attributes -> attr_id ] = $ attributes -> colName ; } $ checkboxes = $ objDB -> execute ( ' SELECT * FROM tl_metamodel_dcasetting WHERE subpalette=0 AND dcatype=\'attribute\' ' ) ; $ check = array ( ) ; while ( $ checkboxes -> next ( ) ) { $ check [ $ checkboxes -> id ] = $ checkboxes -> attr_id ; } while ( $ subpalettes -> next ( ) ) { $ data = array ( 'pid' => 0 , 'settingId' => $ subpalettes -> id , 'sorting' => '128' , 'tstamp' => time ( ) , 'enabled' => '1' , 'type' => 'conditionpropertyvalueis' , 'attr_id' => $ check [ $ subpalettes -> subpalette ] , 'comment' => sprintf ( 'Only show when checkbox "%s" is checked' , $ attr [ $ check [ $ subpalettes -> subpalette ] ] ) , 'value' => '1' , ) ; $ objDB -> prepare ( 'INSERT INTO tl_metamodel_dcasetting_condition %s' ) -> set ( $ data ) -> execute ( ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET subpalette=0 WHERE id=?' ) -> execute ( $ subpalettes -> id ) ; $ objDB -> prepare ( 'UPDATE tl_metamodel_dcasetting SET submitOnChange=1 WHERE id=?' ) -> execute ( $ subpalettes -> subpalette ) ; } } TableManipulation :: dropColumn ( 'tl_metamodel_dcasetting' , 'subpalette' , true ) ; } }
5382	public function setValue ( $ desired ) { $ achieved = array ( ) ; foreach ( $ desired as $ value ) { $ success = false ; for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ achieved [ ] = $ this -> options [ $ i ] -> getValue ( ) ; $ success = true ; break ; } } if ( ! $ success ) { return false ; } } $ this -> values = $ achieved ; return true ; }
12885	public function getReverseKeyTranslation ( $ localObject ) { $ key = is_object ( $ localObject ) ? $ localObject -> primaryKey : $ localObject ; if ( $ this -> settings [ 'universalKey' ] ) { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key ] ) -> one ( ) ; } else { return KeyTranslation :: find ( ) -> where ( [ 'registry_id' => $ key , 'data_interface_id' => $ this -> module -> collectorItem -> interfaceObject -> primaryKey ] ) -> one ( ) ; } }
1961	public static function encodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: encode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
8984	public function isEqual ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were equivalent: ' , [ 'ignoreColumnSequence' => TRUE ] , $ expected , $ actual , $ message ) ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
3797	private function checkForModel ( $ containedModel , $ action ) { if ( ! $ this -> circularReference ) { if ( $ this -> hasVariants ( ) ) { $ this -> checkModelWithVariants ( $ containedModel ) ; } $ this -> checkModelWithoutVariants ( $ containedModel ) ; } elseif ( $ this -> currentModel == null && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePA = true ; } else { $ this -> disablePA = false ; $ this -> disablePI = ( $ this -> hasVariants ( ) && $ containedModel -> getProperty ( 'varbase' ) == 1 ) || ( $ action != 'create' && $ containedModel -> getId ( ) == $ this -> currentModel -> getId ( ) ) ; } }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
9246	private function replaceOnce ( $ search , $ replace , $ subject ) { $ pos = strpos ( $ subject , $ search ) ; if ( $ pos !== false ) { $ subject = substr_replace ( $ subject , $ replace , $ pos , strlen ( $ search ) ) ; } return $ subject ; }
354	private static function tokenizePattern ( $ pattern ) { $ charset = Yii :: $ app ? Yii :: $ app -> charset : 'UTF-8' ; $ depth = 1 ; if ( ( $ start = $ pos = mb_strpos ( $ pattern , '{' , 0 , $ charset ) ) === false ) { return [ $ pattern ] ; } $ tokens = [ mb_substr ( $ pattern , 0 , $ pos , $ charset ) ] ; while ( true ) { $ open = mb_strpos ( $ pattern , '{' , $ pos + 1 , $ charset ) ; $ close = mb_strpos ( $ pattern , '}' , $ pos + 1 , $ charset ) ; if ( $ open === false && $ close === false ) { break ; } if ( $ open === false ) { $ open = mb_strlen ( $ pattern , $ charset ) ; } if ( $ close > $ open ) { $ depth ++ ; $ pos = $ open ; } else { $ depth -- ; $ pos = $ close ; } if ( $ depth === 0 ) { $ tokens [ ] = explode ( ',' , mb_substr ( $ pattern , $ start + 1 , $ pos - $ start - 1 , $ charset ) , 3 ) ; $ start = $ pos + 1 ; $ tokens [ ] = mb_substr ( $ pattern , $ start , $ open - $ start , $ charset ) ; $ start = $ open ; } if ( $ depth !== 0 && ( $ open === false || $ close === false ) ) { break ; } } if ( $ depth !== 0 ) { return false ; } return $ tokens ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
1686	public function updateCurrentUser ( Contao \ DataContainer $ dc ) { if ( $ this -> User -> id == $ dc -> id ) { $ this -> User -> findBy ( 'id' , $ this -> User -> id ) ; } }
3585	protected function getMetaOperator ( $ method , ArgumentBag $ args ) { if ( $ not = $ args -> get ( 'not' ) ) { $ args -> set ( 'not' , false ) ; } return ( $ not ^ $ this -> isWhereNull ( $ method , $ args ) ) ? '<' : '>=' ; }
10485	protected function getTableMapping ( $ table ) { if ( array_key_exists ( $ table , $ this -> mappings ) ) { return $ this -> mappings [ $ table ] ; } $ mapping = $ this -> retrieveMapping ( $ table ) ; if ( empty ( $ mapping ) ) { throw new \ UnderflowException ( "Table with name {$table} not found." ) ; } $ this -> mappings [ $ table ] = $ mapping ; return $ mapping ; }
67	private function resolveSymlinkedDirectorySymlink ( $ pathname ) { if ( ! is_dir ( $ pathname ) ) { return $ pathname ; } $ resolved = rtrim ( $ pathname , '/' ) ; if ( ! strlen ( $ resolved ) ) { return $ pathname ; } return $ resolved ; }
7702	function OpenDoc_GetDraw ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { return $ this -> XML_BlockAlias_Prefix ( 'draw:' , $ Txt , $ Pos , $ Forward , $ LevelStop ) ; }
9290	public function applySerializeMetadataToArray ( array $ array , $ className ) { $ classMetadata = $ this -> documentManager -> getClassMetadata ( $ className ) ; $ fieldList = $ this -> fieldListForSerialize ( $ classMetadata ) ; $ return = array_merge ( $ array , $ this -> serializeClassNameAndDiscriminator ( $ classMetadata ) ) ; foreach ( $ classMetadata -> fieldMappings as $ field => $ mapping ) { if ( ! in_array ( $ field , $ fieldList ) ) { if ( isset ( $ return [ $ field ] ) ) { unset ( $ return [ $ field ] ) ; } continue ; } if ( isset ( $ mapping [ 'id' ] ) && $ mapping [ 'id' ] && isset ( $ array [ '_id' ] ) ) { $ return [ $ field ] = $ array [ '_id' ] ; unset ( $ return [ '_id' ] ) ; } if ( ! isset ( $ return [ $ field ] ) ) { continue ; } $ return [ $ field ] = $ this -> applySerializeMetadataToField ( $ return [ $ field ] , $ field , $ className ) ; } return $ return ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
9122	private function prepareRequest ( $ requestType ) : MemoryStream { $ ms = new MemoryStream ( ) ; $ ms -> interpolate ( "{rqtype} {path}{query} {proto}\r\n" , array ( 'rqtype' => $ requestType , 'path' => $ this -> path , 'proto' => $ this -> protocol , 'query' => ( strlen ( $ this -> queryString ) ? '?' . $ this -> queryString : '' ) ) ) ; $ ms -> interpolate ( "Host: {host}\r\n" , array ( 'host' => $ this -> getEndpoint ( ) -> getAddress ( ) ) ) ; $ this -> adjustHeaders ( $ requestType ) ; foreach ( $ this -> getHeaders ( ) as $ headerName => $ headerValue ) { if ( isset ( $ headerValue ) && strlen ( $ headerValue ) > 0 ) { $ ms -> interpolate ( "{headerName}: {headerValue}\r\n" , array ( 'headerName' => $ headerName , 'headerValue' => $ headerValue ) ) ; } } $ ms -> write ( "\r\n" ) ; return $ ms ; }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
9719	private function writeMsoDrawingGroup ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ record = 0x00EB ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ this -> writeData ( $ header . $ data ) ; } return '' ; }
5051	public function triggerUntil ( callable $ callback , $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event , $ callback ) ; }
4855	public function log ( $ level , $ message , array $ context = [ ] ) { static $ counter = [ ] ; ! $ this -> logger || $ this -> logger -> log ( $ level , $ message , $ context ) ; $ message = is_object ( $ message ) ? $ message -> __toString ( ) : $ message ; if ( isset ( $ this -> messages [ $ level ] [ $ hash = md5 ( $ message ) ] ) ) { $ this -> messages [ $ level ] [ $ hash ] = '(' . ++ $ counter [ $ hash ] . ') ' . $ message ; } else { $ counter [ $ hash ] = 1 ; $ this -> messages [ $ level ] [ $ hash ] = $ message ; } }
9281	public function getPending ( array $ options = array ( ) ) { $ where = new Where ( ) ; $ where -> equalTo ( "{$this->tableName}.status" , JobEntity :: STATUS_PENDING ) ; return $ this -> fetchByWhere ( $ where , $ options ) ; }
9523	private function getConfig ( ) { $ yaml = new Parser ( ) ; $ configFile = getenv ( 'TRAVIS_BUILD_DIR' ) . '/.travis.yml' ; $ config = $ yaml -> parse ( file_get_contents ( $ configFile ) ) ; $ config = $ config [ 'travisdeployer' ] ; $ this -> branches = $ config [ 'branches' ] ; if ( count ( $ this -> branches ) === 0 ) { die ( 'No branches are configured to deploy to.' . PHP_EOL ) ; } $ this -> verbose = filter_input ( FILTER_VALIDATE_BOOLEAN , $ config [ 'verbose' ] ) ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
3838	protected function build ( IMetaModelDataDefinition $ container ) { $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( $ container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; } else { return ; } $ panelLayout = $ this -> inputScreen [ 'meta' ] [ 'panelLayout' ] ; if ( empty ( $ panelLayout ) ) { return ; } $ arrRows = StringUtil :: trimsplit ( ';' , $ panelLayout ) ; $ panel = $ view -> getPanelLayout ( ) ; $ panelRows = $ panel -> getRows ( ) ; foreach ( $ arrRows as $ rowNo => $ rowElements ) { if ( $ panelRows -> getRowCount ( ) < ( $ rowNo + 1 ) ) { $ panelRow = $ panelRows -> addRow ( ) ; } else { $ panelRow = $ panelRows -> getRow ( $ rowNo ) ; } $ fields = StringUtil :: trimsplit ( ',' , $ rowElements ) ; $ fields = array_reverse ( $ fields ) ; $ this -> parsePanelRow ( $ fields , $ panelRow ) ; if ( $ panelRow -> getCount ( ) == 0 ) { $ panelRows -> deleteRow ( $ rowNo ) ; } } $ this -> ensureSubmitElement ( $ panelRows ) ; $ this -> inputScreen = null ; }
4406	public function matches ( Request $ request ) { return in_array ( $ request -> attributes -> get ( '_route' ) , array ( FallbackRouter :: ROUTE_NAME , UrlAliasRouter :: URL_ALIAS_ROUTE_NAME ) , true ) ; }
5191	private function handleString ( $ str ) : string { return is_string ( $ str ) && strlen ( $ str ) > 0 && $ str !== null ? $ str : '' ; }
9326	protected function registerEngines ( ) { $ app = $ this -> app ; $ config = $ app [ 'config' ] ; $ resolver = $ app [ 'view.engine.resolver' ] ; if ( $ config [ 'markdown.tags' ] ) { $ this -> registerBladeEngine ( $ resolver ) ; } if ( $ config [ 'markdown.views' ] ) { $ this -> registerMarkdownEngine ( $ resolver ) ; $ this -> registerMarkdownPhpEngine ( $ resolver ) ; $ this -> registerMarkdownBladeEngine ( $ resolver ) ; } }
91	public static function parseJson ( $ json , $ file = null ) { if ( null === $ json ) { return ; } $ data = json_decode ( $ json , true ) ; if ( null === $ data && JSON_ERROR_NONE !== json_last_error ( ) ) { self :: validateSyntax ( $ json , $ file ) ; } return $ data ; }
1383	protected function dataGet ( $ key , $ default = null ) { if ( ! isset ( $ this -> document -> data ) ) { return $ default ; } return data_get ( $ this -> document -> data , $ key , $ default ) ; }
6883	static public function getTypes ( ) { return [ static :: MANUAL , static :: CART_REMIND , static :: ORDER_ACCEPTED , static :: QUOTE_REMIND , static :: PAYMENT_CAPTURED , static :: PAYMENT_EXPIRED , static :: SHIPMENT_SHIPPED , static :: SHIPMENT_PARTIAL , static :: RETURN_PENDING , static :: RETURN_RECEIVED , ] ; }
10399	protected function start ( InputInterface $ input , OutputInterface $ output , $ serviceClass , $ prefix ) { $ benchmark = new CommandBenchmark ( $ output ) ; $ benchmark -> start ( ) ; $ service = $ this -> getContainer ( ) -> get ( $ serviceClass ) ; $ factory = $ service -> getPipelineFactory ( ) ; $ factory -> setProgressBar ( new ProgressBar ( $ output ) ) ; $ service -> startPipeline ( $ prefix , $ input -> getArgument ( 'target' ) ) ; $ benchmark -> finish ( ) ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
4653	public function getJobsToRemove ( $ projectPath , $ keep = 1 ) { $ currentJobs = $ this -> strategy -> getJobs ( $ projectPath ) ; $ existingJobs = $ this -> getJobs ( $ projectPath ) ; $ uniqList = array ( ) ; $ removes = array ( ) ; $ ordered = array ( ) ; foreach ( $ currentJobs as $ job ) { $ uniqList [ ] = $ job -> getUniq ( ) ; } foreach ( $ existingJobs as $ job ) { if ( ! in_array ( $ job -> getUniq ( ) , $ uniqList ) ) { $ removes [ ] = $ job ; } else { $ ordered [ $ job -> getUniq ( ) ] [ $ job -> getCreated ( ) -> format ( 'U' ) ] = $ job ; } } foreach ( $ ordered as $ jobs ) { ksort ( $ jobs ) ; $ keeped = count ( $ jobs ) ; while ( $ keeped > $ keep ) { $ removes [ ] = array_shift ( $ jobs ) ; $ keeped -- ; } } return $ removes ; }
9796	public function hasHyperlink ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot check for hyperlink when cell is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> hyperlinkExists ( $ this -> getCoordinate ( ) ) ; }
10636	protected function resolvePaths ( array $ fixPaths ) { $ this -> rootDir = \ realpath ( isset ( $ fixPaths [ 'rootDir' ] ) ? $ fixPaths [ 'rootDir' ] : __DIR__ . '/../../../../' ) ; $ this -> packageDir = \ realpath ( isset ( $ fixPaths [ 'packageDir' ] ) ? $ fixPaths [ 'packageDir' ] : __DIR__ . '/../' ) ; $ this -> configPath = Utils :: fixPath ( isset ( $ fixPaths [ 'configPath' ] ) ? $ fixPaths [ 'configPath' ] : '/app/' ) ; if ( $ this -> rootDir === false || $ this -> packageDir === false ) throw new \ InvalidArgumentException ( 'Bootstrap directories do not exists or are not accessible' ) ; if ( $ this [ 'minion.usePropel' ] ) { $ this -> propelConfigPath = \ realpath ( isset ( $ fixPaths [ 'propelConfigPath' ] ) ? $ fixPaths [ 'propelConfigPath' ] : Utils :: fixPath ( $ this -> packageDir . '/propel.php' ) ) ; if ( $ this -> propelConfigPath === false ) throw new \ InvalidArgumentException ( 'Propel configuration file in vendor Minion not found' ) ; } }
1222	private function wrapExpression ( $ from , callable $ expr , array $ types ) { list ( $ fn , $ pos ) = explode ( ':' , $ from ) ; $ from = "The expression return value of argument {$pos} of {$fn}" ; return function ( $ value ) use ( $ from , $ expr , $ types ) { $ value = $ expr ( $ value ) ; $ this -> validateType ( $ from , $ value , $ types ) ; return $ value ; } ; }
11205	public function merge ( $ data , $ key = false , $ dataKey = false ) { if ( $ data != false && ( is_array ( $ data ) || is_object ( $ data ) ) ) { foreach ( $ data as $ item ) { $ this -> add ( $ item , $ key , $ dataKey , true ) ; } } else { $ this -> add ( $ data , $ key , $ dataKey ) ; } return $ this ; }
8167	public function addIndentation ( ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is deprecated since version 1.27 and will be removed in 2.0. Use write(\'\') instead.' , E_USER_DEPRECATED ) ; $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) ; return $ this ; }
2696	public function afterGetType ( Config $ config , $ result ) { if ( ! ( $ config instanceof \ Fastly \ Cdn \ Model \ Config ) ) { if ( $ result == \ Fastly \ Cdn \ Model \ Config :: FASTLY ) { return Config :: VARNISH ; } } return $ result ; }
8779	public function segment ( $ num = null ) { if ( is_null ( http ( ) -> server ( 'REQUEST_URI' ) ) || is_null ( http ( ) -> server ( 'SCRIPT_NAME' ) ) ) { return null ; } if ( ! is_null ( $ num ) ) { $ uri = $ this -> replace ( str_replace ( $ this -> base , '' , http ( ) -> server ( 'REQUEST_URI' ) ) ) ; $ uriA = explode ( '/' , $ uri ) ; return ( isset ( $ uriA [ $ num ] ) ? reset ( explode ( '?' , $ uriA [ $ num ] ) ) : null ) ; } return null ; }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
12786	public function getConfig ( ) { return [ 'form_elements' => [ 'aliases' => [ 'checkbox' => Element \ Checkbox :: class , 'Checkbox' => Element \ Checkbox :: class , 'ckeditor' => Element \ CkEditor :: class , 'ckEditor' => Element \ CkEditor :: class , 'CkEditor' => Element \ CkEditor :: class , 'csrf' => Element \ Csrf :: class , 'Csrf' => Element \ Csrf :: class , 'date' => Element \ Date :: class , 'Date' => Element \ Date :: class , 'datetime' => Element \ DateTime :: class , 'dateTime' => Element \ DateTime :: class , 'DateTime' => Element \ DateTime :: class , 'email' => Element \ Email :: class , 'Email' => Element \ Email :: class , 'multipleinput' => Element \ MultipleInput :: class , 'multipleInput' => Element \ MultipleInput :: class , 'MultipleInput' => Element \ MultipleInput :: class , 'password' => Element \ Password :: class , 'Password' => Element \ Password :: class , 'rangefilter' => Element \ RangeFilter :: class , 'rangeFilter' => Element \ RangeFilter :: class , 'RangeFilter' => Element \ RangeFilter :: class , 'time' => Element \ Time :: class , 'Time' => Element \ Time :: class , 'timezoneselect' => Element \ TimeZoneSelect :: class , 'timezoneSelect' => Element \ TimeZoneSelect :: class , 'TimezoneSelect' => Element \ TimeZoneSelect :: class , 'username' => Element \ Username :: class , 'Username' => Element \ Username :: class , 'yesnoselect' => Element \ YesNoSelect :: class , 'yesNoSelect' => Element \ YesNoSelect :: class , 'YesNoSelect' => Element \ YesNoSelect :: class ] , 'factories' => [ Element \ Checkbox :: class => ElementFactory :: class , Element \ CkEditor :: class => ElementFactory :: class , Element \ Csrf :: class => ElementFactory :: class , Element \ Date :: class => ElementFactory :: class , Element \ DateTime :: class => ElementFactory :: class , Element \ Email :: class => ElementFactory :: class , Element \ MultipleInput :: class => ElementFactory :: class , Element \ Password :: class => ElementFactory :: class , Element \ RangeFilter :: class => ElementFactory :: class , Element \ Time :: class => ElementFactory :: class , Element \ TimeZoneSelect :: class => ElementFactory :: class , Element \ Username :: class => ElementFactory :: class , Element \ YesNoSelect :: class => ElementFactory :: class ] ] ] ; }
8517	public function setInventoryRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InventoryRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
5389	public function setValue ( $ value ) { if ( ! $ this -> valueIsPossible ( $ value ) ) { return false ; } $ index = false ; $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( ! $ widgets [ $ i ] -> setValue ( $ value ) ) { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
4763	public function createUser ( ) { if ( false == $ this -> validateRegistrationOptin ( ) ) { if ( $ this -> getRequestParameter ( 'stoken' ) ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true ) ; \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true , 'oegdproptin_userregistration' ) ; } } else { return parent :: createUser ( ) ; } }
5299	public function getGlyphs ( ) { if ( ! isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) || ! count ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph ) ) { return array ( ) ; } $ glyphs = array ( ) ; foreach ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> glyph as $ xmlGlyph ) { if ( isset ( $ xmlGlyph [ 'unicode' ] ) && isset ( $ xmlGlyph [ 'd' ] ) ) { $ glyph = array ( 'char' => ( string ) $ xmlGlyph [ 'unicode' ] , 'path' => ( string ) $ xmlGlyph [ 'd' ] , ) ; if ( isset ( $ xmlGlyph [ 'glyph-name' ] ) ) { $ glyph [ 'name' ] = ( string ) $ xmlGlyph [ 'glyph-name' ] ; } if ( isset ( $ xmlGlyph [ 'horiz-adv-x' ] ) ) { $ glyph [ 'width' ] = ( string ) $ xmlGlyph [ 'horiz-adv-x' ] ; } $ glyphs [ ] = $ glyph ; } } return $ glyphs ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
3219	function getDelta ( $ cursor = null , $ pathPrefix = null ) { Checker :: argStringNonEmptyOrNull ( "cursor" , $ cursor ) ; Path :: checkArgOrNull ( "pathPrefix" , $ pathPrefix ) ; $ response = $ this -> doPost ( $ this -> apiHost , "1/delta" , array ( "cursor" => $ cursor , "path_prefix" => $ pathPrefix ) ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
4848	public function destinationsFor ( string $ filePath ) : array { $ filePath = Path :: canonicalize ( $ filePath ) ; $ source = $ this -> matchingSource ( $ filePath ) ; return $ this -> resolveDestinations ( $ filePath , $ source ) ; }
3346	public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
943	private function computeConfigFiles ( ) { $ configFile = $ this -> options [ 'config' ] ; if ( null !== $ configFile ) { if ( false === file_exists ( $ configFile ) || false === is_readable ( $ configFile ) ) { throw new InvalidConfigurationException ( sprintf ( 'Cannot read config file "%s".' , $ configFile ) ) ; } return [ $ configFile ] ; } $ path = $ this -> getPath ( ) ; if ( $ this -> isStdIn ( ) || 0 === \ count ( $ path ) ) { $ configDir = $ this -> cwd ; } elseif ( 1 < \ count ( $ path ) ) { throw new InvalidConfigurationException ( 'For multiple paths config parameter is required.' ) ; } elseif ( is_file ( $ path [ 0 ] ) && $ dirName = pathinfo ( $ path [ 0 ] , PATHINFO_DIRNAME ) ) { $ configDir = $ dirName ; } else { $ configDir = $ path [ 0 ] ; } $ candidates = [ $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs' , $ configDir . \ DIRECTORY_SEPARATOR . '.php_cs.dist' , ] ; if ( $ configDir !== $ this -> cwd ) { $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs' ; $ candidates [ ] = $ this -> cwd . \ DIRECTORY_SEPARATOR . '.php_cs.dist' ; } return $ candidates ; }
10	private function getCurrentPackages ( $ installedRepo ) { if ( $ this -> locker -> isLocked ( ) ) { try { return $ this -> locker -> getLockedRepository ( true ) -> getPackages ( ) ; } catch ( \ RuntimeException $ e ) { return $ this -> locker -> getLockedRepository ( ) -> getPackages ( ) ; } } return $ installedRepo -> getPackages ( ) ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
6266	public function reject ( Exception $ exception ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: REJECTED ; $ this -> exception = $ exception ; $ this -> doReject ( $ exception ) ; }
5920	public function setUpdated ( $ updated ) { if ( $ updated instanceof DateTime ) { $ this -> updated = $ updated ; } else { try { $ this -> updated = new DateTime ( $ updated ) ; } catch ( \ Exception $ e ) { $ this -> updated = null ; } } return $ this ; }
9754	public static function assertFile ( $ filename ) { if ( ! is_file ( $ filename ) ) { throw new InvalidArgumentException ( 'File "' . $ filename . '" does not exist.' ) ; } if ( ! is_readable ( $ filename ) ) { throw new InvalidArgumentException ( 'Could not open "' . $ filename . '" for reading.' ) ; } }
6577	public function getList ( $ sort = null ) { $ countries = $ this -> getCountries ( ) ; $ validSorts = array ( 'name' , 'fullname' , 'iso_3166_2' , 'iso_3166_3' , 'capital' , 'citizenship' , 'currency' , 'currency_code' , 'calling_code' ) ; if ( ! is_null ( $ sort ) && in_array ( $ sort , $ validSorts ) ) { uasort ( $ countries , function ( $ a , $ b ) use ( $ sort ) { if ( ! isset ( $ a [ $ sort ] ) && ! isset ( $ b [ $ sort ] ) ) { return 0 ; } elseif ( ! isset ( $ a [ $ sort ] ) ) { return - 1 ; } elseif ( ! isset ( $ b [ $ sort ] ) ) { return 1 ; } else { return strcasecmp ( $ a [ $ sort ] , $ b [ $ sort ] ) ; } } ) ; } return $ countries ; }
10148	private function readMsoDrawingGroup ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ splicedRecordData = $ this -> getSplicedRecordData ( ) ; $ recordData = $ splicedRecordData [ 'recordData' ] ; $ this -> drawingGroupData .= $ recordData ; }
7806	protected function getNearestDateTimeFromDayAndMonth ( \ DateTime $ target , $ day , $ month ) { $ initialGuess = new \ DateTime ( ) ; $ initialGuess -> setDate ( $ target -> format ( 'Y' ) , $ month , $ day ) ; $ initialGuess -> setTime ( 0 , 0 , 0 ) ; $ initialGuessDiff = $ target -> diff ( $ initialGuess ) ; $ yearEarlier = clone $ initialGuess ; $ yearEarlier -> modify ( '-1 year' ) ; $ yearEarlierDiff = $ target -> diff ( $ yearEarlier ) ; if ( $ yearEarlierDiff -> days < $ initialGuessDiff -> days ) { return $ yearEarlier ; } $ yearLater = clone $ initialGuess ; $ yearLater -> modify ( '+1 year' ) ; $ yearLaterDiff = $ target -> diff ( $ yearLater ) ; if ( $ yearLaterDiff -> days < $ initialGuessDiff -> days ) { return $ yearLater ; } return $ initialGuess ; }
5169	public static function getTypeByValue ( $ value ) { if ( is_int ( $ value ) ) { return self :: TYPE_INT ; } elseif ( is_string ( $ value ) ) { return self :: TYPE_QSTRING ; } elseif ( is_bool ( $ value ) ) { return self :: TYPE_BOOL ; } elseif ( self :: isList ( $ value ) ) { return self :: TYPE_QVARIANT_LIST ; } elseif ( self :: isMap ( $ value ) ) { return self :: TYPE_QVARIANT_MAP ; } elseif ( $ value instanceof \ DateTime ) { return self :: TYPE_QDATETIME ; } else { throw new \ InvalidArgumentException ( 'Can not guess variant type for type "' . gettype ( $ value ) . '"' ) ; } }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
7492	public function trim ( $ characters = null ) { $ this -> string = trim ( $ this -> string , $ characters ) ; return $ this ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
4014	protected function getHelpWizard ( $ key , $ field ) { if ( empty ( $ field [ 'eval' ] [ 'helpwizard' ] ) ) { return '' ; } $ event = new GenerateHtmlEvent ( 'about.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] , 'style="vertical-align:text-bottom;"' ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ event ) ; return sprintf ( ' <a href="%shelp.php?table=%s&amp;field=%s_%s" title="%s" rel="lightbox[help 610 80%]">%s</a>' , TL_PATH . 'contao/' , $ this -> strTable , $ this -> strName , $ key , StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] ) , $ event -> getHtml ( ) ) ; }
6632	public function requestAccessToken ( $ code ) { if ( ! $ code || empty ( $ code ) ) { throw new InvalidFacebookCodeException ( ) ; } $ request = [ 'url' => $ this -> settings [ 'token_url' ] , 'params' => [ 'client_id' => $ this -> settings [ 'api_key' ] , 'redirect_uri' => $ this -> settings [ 'redirect_uri' ] , 'client_secret' => $ this -> settings [ 'secret' ] , 'code' => $ code , 'format' => 'json' , ] , ] ; return $ this -> access_token -> make ( $ this -> http -> get ( $ request ) ) ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
3243	public function getShopUrlAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> shopUrl ; if ( ! property_exists ( $ this , 'itemRouteName' ) && ! property_exists ( $ this , 'itemRouteParams' ) ) return '#' ; $ params = [ ] ; foreach ( array_keys ( $ this -> attributes ) as $ attribute ) { if ( in_array ( $ attribute , $ this -> itemRouteParams ) ) $ params [ $ attribute ] = $ this -> attributes [ $ attribute ] ; } return empty ( $ this -> itemRouteName ) ? '#' : \ route ( $ this -> itemRouteName , $ params ) ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
2530	protected function makeSoapClientOptions ( ) { $ options = $ this -> soapClientOptions ; $ options [ 'classmap' ] = array_merge ( Classmap :: $ soapheader4map , Classmap :: $ map ) ; if ( ! empty ( $ this -> params -> soapClientOptions ) ) { $ options = array_merge ( $ options , $ this -> params -> soapClientOptions ) ; } return $ options ; }
5758	protected function getFromClause ( ) : string { return "FROM " . self :: TABLE_NAME . " JOIN " . self :: ROLES_JOIN_TABLE_NAME . " ON " . self :: TABLE_NAME . ".id = " . self :: ROLES_JOIN_TABLE_NAME . ".permission_id JOIN " . self :: ROLES_TABLE_NAME . " ON " . self :: ROLES_JOIN_TABLE_NAME . ".role_id=" . self :: ROLES_TABLE_NAME . ".id" ; }
7623	public function signRequestHeaders ( $ httpVerb = 'GET' , $ path = '/' , $ query = array ( ) , $ headers = null , $ forTableStorage = false , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ , $ rawData = null ) { return $ headers ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
6762	public function expand ( $ edges = [ ] , $ force = false ) { if ( $ force ) foreach ( $ this -> models as $ i => $ model ) $ this -> models [ $ i ] -> expand ( $ edges ) ; else foreach ( $ this -> models as $ i => $ model ) if ( is_a ( $ model , "SnooPHP\Model\Node" ) ) $ this -> models [ $ i ] -> expand ( $ edges ) ; return $ this ; }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
8902	public function delete ( $ id , $ time = 'NOW()' ) { $ this -> _database -> where ( $ this -> primary_key , $ id ) ; return $ this -> _delete ( $ id , $ time ) ; }
2231	protected function hasUser ( ) : bool { $ user = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ user ) { return false ; } return ! ( $ user instanceof AnonymousToken ) ; }
6304	protected function process ( array $ nav ) { foreach ( $ nav as $ key => $ value ) { if ( ! isset ( $ value [ 'url' ] ) ) { $ nav [ $ key ] [ 'url' ] = $ this -> url -> to ( $ value [ 'slug' ] ) ; } unset ( $ nav [ $ key ] [ 'slug' ] ) ; } return $ nav ; }
8701	public function getString ( ) { $ this -> validateElement ( ) ; $ elementStringData = '' ; $ elementStringData = '<' . static :: TYPE ; foreach ( $ this -> attributes as $ key => $ data ) { $ elementStringData .= ' ' . $ key . '="' . $ data . '"' ; } $ elementStringData .= '>' ; if ( $ this -> text !== null ) { $ elementStringData .= $ this -> text ; } if ( count ( $ this -> childElements ) > 0 ) { if ( static :: TYPE == 'svg' ) { foreach ( $ this -> childElements as $ childElement ) { $ this -> defs = array_merge ( $ this -> defs , $ childElement -> getDefs ( ) ) ; } if ( count ( $ this -> defs ) > 0 ) { $ defArea = new \ SVGCreator \ Elements \ Defs ( ) ; foreach ( $ this -> defs as $ def ) { $ defArea -> append ( $ def ) ; } $ elementStringData .= $ defArea -> getString ( ) ; } } foreach ( $ this -> childElements as $ childElement ) { $ elementStringData .= $ childElement -> getString ( ) ; } } $ elementStringData .= '</' . static :: TYPE . '>' ; $ this -> elementString = $ elementStringData ; return $ this -> elementString ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
12012	private function addDoctrineSection ( ArrayNodeDefinition $ rootNode ) { $ rootNode -> children ( ) -> arrayNode ( 'doctrine' ) -> info ( 'doctrine configuration' ) -> canBeEnabled ( ) -> children ( ) -> booleanNode ( 'enabled' ) -> defaultTrue ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
3201	public function getItems ( \ core_kernel_classes_Class $ itemClass , array $ propertyFilters = [ ] , $ offset = 0 , $ limit = 30 ) { $ result = $ this -> getListResourceLookupService ( ) -> getResources ( $ itemClass , [ ] , $ propertyFilters , $ offset , $ limit ) ; array_map ( function ( $ item ) { return array_merge ( $ item , [ 'categories' => $ this -> getCategoryService ( ) -> getItemCategories ( $ this -> getResource ( $ item [ 'uri' ] ) ) ] ) ; } , $ result [ 'nodes' ] ) ; return $ result ; }
11029	protected function geolocation ( ) { $ this -> parts [ '{geolocation}' ] = $ this -> form -> field ( $ this -> model , 'latitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'latitude' ) , 'id' => $ this -> fieldIds [ 'latitude' ] ] ) . "\n" . $ this -> form -> field ( $ this -> model , 'longitude' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'longitude' ) , 'id' => $ this -> fieldIds [ 'longitude' ] ] ) ; }
2978	public function getLicenseByIdentifier ( $ identifier ) { $ key = strtolower ( $ identifier ) ; if ( ! isset ( $ this -> licenses [ $ key ] ) ) { return ; } list ( $ identifier , $ name , $ isOsiApproved , $ isDeprecatedLicenseId ) = $ this -> licenses [ $ key ] ; return array ( $ name , $ isOsiApproved , 'https://spdx.org/licenses/' . $ identifier . '.html#licenseText' , $ isDeprecatedLicenseId , ) ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
10433	protected function prepareServiceConfigs ( ContainerBuilder $ container , $ pipelineConfig , $ pipelineName ) { return array_merge ( $ pipelineConfig [ 'config' ] , [ 'doctrineManager' => $ pipelineConfig [ 'doctrineManager' ] , 'elasticsearchManager' => $ pipelineConfig [ 'elasticsearchManager' ] , 'sync_storage' => $ pipelineConfig [ 'sync_storage' ] , 'diff_provider' => $ pipelineConfig [ 'diff_provider' ] , 'extractor' => $ pipelineConfig [ 'extractor' ] , 'chunk_size' => $ pipelineConfig [ 'chunk_size' ] , 'shop' => $ pipelineConfig [ 'shop' ] , 'shop_id' => $ this -> getShopId ( $ container , $ pipelineConfig [ 'shop' ] , $ pipelineName ) , ] ) ; }
11274	public function install ( ) : Migrate { Whois :: print ( $ this -> getNotify ( ) ) ; $ this -> exists ( ) || $ this -> migrationRepository -> createRepository ( ) ; return $ this ; }
12942	public function create ( $ className , $ username ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( $ this -> configurationHandler -> language ( ) . '_' . $ this -> configurationHandler -> country ( ) ) ; $ permalinksForSelect = ( ! empty ( $ permalinks ) ) ? array_combine ( $ permalinks , $ permalinks ) : array ( ) ; $ params = array ( $ permalinksForSelect ) ; $ form = $ this -> formFactory -> create ( $ reflectionClass -> newInstanceArgs ( $ params ) ) ; return $ form -> createView ( ) ; }
12294	public function delete ( $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } return $ resource -> delete ( ) ; }
7156	private function setSubjectData ( StockSubjectInterface $ subject , $ inStock = .0 , $ availableStock = .0 , $ virtualStock = .0 , \ DateTime $ eda = null ) { $ changed = false ; if ( $ inStock != $ subject -> getInStock ( ) ) { $ subject -> setInStock ( $ inStock ) ; $ changed = true ; } if ( $ availableStock != $ subject -> getAvailableStock ( ) ) { $ subject -> setAvailableStock ( $ availableStock ) ; $ changed = true ; } if ( $ virtualStock != $ subject -> getVirtualStock ( ) ) { $ subject -> setVirtualStock ( $ virtualStock ) ; $ changed = true ; } if ( $ eda !== $ subject -> getEstimatedDateOfArrival ( ) ) { $ subject -> setEstimatedDateOfArrival ( $ eda ) ; $ changed = true ; } return $ changed ; }
11539	public function add ( $ sourceDir , array $ options , $ username ) { $ this -> resolveAddOptions ( $ options ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ this -> addBlockToSlot ( $ dir , $ options ) ; $ blockContent = $ this -> addBlock ( $ dir , $ options , $ blockName ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been added to the "%s" slot on page "%s" for the "%s_%s" language' , $ blockName , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; return $ blockContent ; }
2721	private function getMessageInStoreLocale ( StoreInterface $ emulatedStore ) { $ currentStore = $ this -> storeManager -> getStore ( ) ; $ this -> localeResolver -> emulate ( $ emulatedStore -> getId ( ) ) ; $ this -> storeManager -> setCurrentStore ( $ emulatedStore -> getId ( ) ) ; $ message = __ ( 'You are in the wrong store. Click OK to visit the %1 store.' , [ $ emulatedStore -> getName ( ) ] ) -> __toString ( ) ; $ this -> localeResolver -> revert ( ) ; $ this -> storeManager -> setCurrentStore ( $ currentStore -> getId ( ) ) ; return $ message ; }
7919	protected function renderInput ( $ options = [ ] , $ resultsOptions = [ ] ) { Html :: addCssClass ( $ options , 'prompt' ) ; $ lines = [ ] ; $ input = $ this -> hasModel ( ) ? Html :: activeTextInput ( $ this -> model , $ this -> attribute , $ options ) : Html :: textInput ( $ this -> name , $ this -> value , $ options ) ; if ( ! empty ( $ this -> displayIcon ) ) { $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon input' ] ) ; $ lines [ ] = $ input ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'icon search' ] ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; } else { $ lines [ ] = $ input ; } $ lines [ ] = Html :: tag ( 'div' , '' , $ resultsOptions ) ; return implode ( "\n" , $ lines ) ; }
4020	protected function validateWidget ( & $ arrField , $ strRow , $ strKey , & $ varInput ) { $ varValue = $ varInput [ $ strRow ] [ $ strKey ] ; $ objWidget = $ this -> initializeWidget ( $ arrField , $ strRow , $ strKey , $ varValue ) ; if ( ! is_object ( $ objWidget ) ) { return false ; } if ( ( $ arrField [ 'inputType' ] == 'checkbox' ) && isset ( $ varInput [ $ strRow ] [ $ strKey ] ) ) { $ _POST [ $ objWidget -> name ] = $ varValue ; } $ objWidget -> validate ( ) ; $ varValue = $ objWidget -> value ; $ rgxp = $ arrField [ 'eval' ] [ 'rgxp' ] ; if ( ( $ rgxp == 'date' || $ rgxp == 'time' || $ rgxp == 'datim' ) && $ varValue != '' ) { $ objDate = new Date ( $ varValue , $ GLOBALS [ 'TL_CONFIG' ] [ $ rgxp . 'Format' ] ) ; $ varValue = $ objDate -> tstamp ; } $ varValue = $ this -> handleSaveCallback ( $ arrField , $ objWidget , $ varValue ) ; $ varInput [ $ strRow ] [ $ strKey ] = $ varValue ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } return true ; }
12094	public function getMd5Url ( $ address , $ scheme = true , $ www = true ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getMd5Address ( $ scheme , $ www ) ; }
1498	public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; }
11678	protected function load ( $ locale , $ fileName ) { if ( $ this -> isFileLoaded ( $ locale , $ fileName ) === true ) { return true ; } $ startTime = microtime ( true ) ; $ file = $ this -> getPath ( ) . '/' . $ locale . '/' . $ fileName . '.php' ; if ( file_exists ( $ file ) === false ) { throw new FileNotFound ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } $ translationKeys = include $ file ; if ( $ translationKeys === null || is_array ( $ translationKeys ) === false ) { throw new InvalidTranslationFile ( $ this -> getPath ( ) , $ locale , $ fileName ) ; } if ( array_key_exists ( $ locale , $ this -> translations ) === false ) { $ this -> translations [ $ locale ] = [ ] ; } $ this -> translations [ $ locale ] [ $ fileName ] = $ translationKeys ; $ this -> log ( 'Language loaded: ' . $ locale . '/' . $ fileName . ' (' . number_format ( microtime ( true ) - $ startTime , 2 , ',' , '.' ) . ')' ) ; return true ; }
8630	public function setGetLowestOfferListingsForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetLowestOfferListingsForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6121	public function permissionGetIdByName ( $ name ) { if ( ! array_key_exists ( ( string ) $ name , $ this -> permissionList ( ) ) ) { throw new Ts3Exception ( "invalid permission ID" , 0xA02 ) ; } return $ this -> permissionList [ ( string ) $ name ] [ "permid" ] ; }
3718	protected function getMetaModelFromModel ( ModelInterface $ model ) { if ( ! ( ( $ model -> getProviderName ( ) == 'tl_metamodel_dca_sortgroup' ) && $ model -> getProperty ( 'pid' ) ) ) { throw new DcGeneralInvalidArgumentException ( sprintf ( 'Model must originate from tl_metamodel_dca_sortgroup and be saved, this one originates from %s ' . 'and has pid %s' , $ model -> getProviderName ( ) , $ model -> getProperty ( 'pid' ) ) ) ; } $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'pid' ) -> from ( 'tl_metamodel_dca' ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchColumn ( ) ; $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; return $ this -> factory -> getMetaModel ( $ tableName ) ; }
12604	public static function upload ( $ src , $ dest ) { $ dest = Path :: clean ( $ dest ) ; $ baseDir = dirname ( $ dest ) ; try { if ( ! Folder :: exists ( $ baseDir ) ) { Folder :: create ( $ baseDir ) ; } } catch ( Exception $ e ) { throw $ e ; } if ( is_writeable ( $ baseDir ) && move_uploaded_file ( $ src , $ dest ) ) { if ( Path :: setPermissions ( $ dest ) ) { return true ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_CHMOD' ) ) ; } throw new Exception ( Helper :: getTranslation ( 'FAILED_MOVE_UPLOAD' ) ) ; }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
11467	public function init ( array $ viewDirs , array $ params ) { $ this -> viewDirs = $ viewDirs ; $ this -> params = $ params ; $ this -> parts = new ClearViewPartsCollection ( ) ; }
6180	protected function write ( array $ record ) { $ severity = $ this -> getSeverity ( $ record [ 'level' ] ) ; if ( isset ( $ record [ 'context' ] [ 'exception' ] ) ) { $ this -> client -> notifyException ( $ record [ 'context' ] [ 'exception' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } else { $ this -> client -> notifyError ( ( string ) $ record [ 'message' ] , ( string ) $ record [ 'formatted' ] , function ( \ Bugsnag \ Report $ report ) use ( $ record , $ severity ) { $ report -> setSeverity ( $ severity ) ; if ( isset ( $ record [ 'extra' ] ) ) { $ report -> setMetaData ( $ record [ 'extra' ] ) ; } } ) ; } }
2135	public static function preload ( ) { include __DIR__ . '/../../config/default.php' ; include __DIR__ . '/../../config/agents.php' ; include __DIR__ . '/../../config/mimetypes.php' ; $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ( $ blnHasLcf = file_exists ( $ rootDir . '/system/config/localconfig.php' ) ) === true ) { include $ rootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; static :: $ blnHasLcf = $ blnHasLcf ; }
5137	public static function handleError ( $ code , $ message , $ filename = '' , $ line = 0 ) { throw new \ ErrorException ( $ message , $ code , 0 , $ filename , $ line ) ; }
1683	public function getModules ( ) { $ arrModules = array ( ) ; foreach ( $ GLOBALS [ 'BE_MOD' ] as $ k => $ v ) { if ( ! empty ( $ v ) ) { if ( $ k == 'accounts' ) { unset ( $ v [ 'login' ] ) ; } if ( $ k == 'system' ) { unset ( $ v [ 'undo' ] ) ; } $ arrModules [ $ k ] = array_keys ( $ v ) ; } } return $ arrModules ; }
7962	public function canChangeLns ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canChangeLns ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
5062	public function output ( ) : string { if ( is_null ( $ this -> buffer ) ) { $ this -> exec ( ) ; } curl_close ( $ this -> ch ) ; if ( strlen ( $ this -> buffer ) === 0 ) { throw new NoOutputException ( ) ; } return $ this -> buffer ; }
8904	public function delete_many ( $ primary_values , $ time = 'NOW()' ) { $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) ; return $ this -> _delete ( $ primary_values , $ time ) ; }
12466	private function createEditForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_update' , array ( 'id' => $ entity -> getId ( ) ) ) , 'method' => 'PUT' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Update' ) ) ; return $ form ; }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
2848	public function setModuleStatus ( $ moduleName , $ isActive ) { $ moduleConfigFile = $ this -> getModuleConfigFilePath ( $ moduleName ) ; $ configXml = $ this -> loadXmlFile ( $ moduleConfigFile ) ; if ( $ configXml === false ) { throw new Exception ( "Unable to parse module configuration file {$moduleConfigFile}" ) ; } $ configXml -> modules -> { $ moduleName } -> active = $ isActive ? 'true' : 'false' ; if ( $ this -> saveXml ( $ configXml , $ moduleConfigFile ) === false ) { throw new Exception ( "Unable to save module configuration file {$moduleConfigFile}. Check to see if web server user has write permissions." ) ; } }
9683	public function getCountryName ( $ code ) { $ name = Intl :: getRegionBundle ( ) -> getCountryName ( strtoupper ( $ code ) , $ this -> getRequest ( ) -> getLanguageCode ( ) ? : 'en' ) ; if ( $ name ) { return $ name ; } return $ code ; }
10829	public static function dir ( string $ path ) : fs \ entity \ DirEntity { return ( new fs \ entity \ DirEntity ( $ path ) ) -> normalize ( ) ; }
9947	public function getRowDimension ( $ pRow , $ create = true ) { $ found = null ; if ( ! isset ( $ this -> rowDimensions [ $ pRow ] ) ) { if ( ! $ create ) { return null ; } $ this -> rowDimensions [ $ pRow ] = new RowDimension ( $ pRow ) ; $ this -> cachedHighestRow = max ( $ this -> cachedHighestRow , $ pRow ) ; } return $ this -> rowDimensions [ $ pRow ] ; }
11160	public function resolve ( $ url , \ GuzzleHttp \ Message \ Response $ data , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ json = json_decode ( $ data -> getBody ( ) ) ; $ logger -> info ( 'resolve' , array ( 'url' => $ url , 'json' => $ json ) ) ; if ( isset ( $ json -> error ) ) { return $ logger -> warning ( 'Query response contained an error' , array ( 'url' => $ url , 'error' => $ json -> error , ) ) ; } $ entries = $ json -> items ; if ( ! is_array ( $ entries ) || ! $ entries ) { return $ logger -> warning ( 'Query returned no results' , array ( 'url' => $ url ) ) ; } $ entry = reset ( $ entries ) ; $ replacements = $ this -> getReplacements ( $ entry ) ; $ message = str_replace ( array_keys ( $ replacements ) , array_values ( $ replacements ) , $ this -> responseFormat ) ; $ queue -> ircPrivmsg ( $ event -> getSource ( ) , $ message ) ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
2018	private function setImagineService ( array $ config , ContainerBuilder $ container ) : void { $ imagineServiceId = $ config [ 'image' ] [ 'imagine_service' ] ; if ( null === $ imagineServiceId ) { $ class = $ this -> getImagineImplementation ( ) ; $ imagineServiceId = 'contao.image.imagine.' . ContainerBuilder :: hash ( $ class ) ; $ container -> setDefinition ( $ imagineServiceId , new Definition ( $ class ) ) ; } $ container -> setAlias ( 'contao.image.imagine' , $ imagineServiceId ) -> setPublic ( true ) ; }
11339	public function getModuleSetModules ( ) { if ( empty ( $ this -> moduleSet ) || ! isset ( Yii :: $ app -> extensions [ $ this -> moduleSet ] ) ) { return '' ; } $ bsClass = Yii :: $ app -> extensions [ $ this -> moduleSet ] [ 'bootstrap' ] ; $ p = [ ] ; $ bs = new $ bsClass ( ) ; $ modules = $ bs -> getModules ( ) ; $ modules [ $ this -> moduleID ] = [ 'class' => $ this -> moduleClass ] ; foreach ( $ modules as $ id => $ module ) { $ e = '$m[\'' . $ id . '\'] = [' ; if ( ! is_array ( $ module ) ) { $ module = [ 'class' => $ module ] ; } $ n = 0 ; foreach ( $ module as $ k => $ v ) { $ e .= "\n\t\t\t'{$k}' => " ; if ( is_string ( $ v ) ) { $ e .= "'" . addslashes ( $ v ) . "'" ; } elseif ( is_numeric ( $ v ) ) { $ e .= $ v ; } $ n ++ ; if ( $ n !== count ( $ module ) ) { $ e .= ',' ; } } $ e .= "\n\t\t];" ; $ p [ ] = $ e ; } return implode ( "\n\t\t" , $ p ) ; }
6023	private function curlRequest ( $ url , $ httpVerb , array $ data = array ( ) , $ curlTimeout = 15 ) { if ( function_exists ( 'curl_init' ) && function_exists ( 'curl_setopt' ) ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type: application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_USERAGENT , 'VPS/MC-API:3.0' ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , $ curlTimeout ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ ch , CURLOPT_USERPWD , "user:" . $ this -> apiKey ) ; curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , $ httpVerb ) ; if ( ! empty ( $ data ) ) { $ jsonData = json_encode ( $ data ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ jsonData ) ; } curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ? json_decode ( $ result , true ) : false ; } throw new \ Exception ( 'curl extension is missing!' ) ; }
3604	public function handleJsonRequest ( $ jsonRequest ) { if ( \ is_array ( $ jsonRequest ) ) { $ jsonResponse = [ ] ; foreach ( $ jsonRequest as $ request ) { $ jsonResponse [ ] = $ this -> handleJsonRequest ( $ request ) ; } return $ jsonResponse ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> start ( 'rpc.execute' ) ; } try { $ this -> dispatch ( Event \ JsonRequestEvent :: EVENT , new Event \ JsonRequestEvent ( $ jsonRequest ) ) ; $ metadata = $ this -> getMethod ( $ jsonRequest ) ; $ isCache = $ this -> isCacheSupport ( $ jsonRequest ) ; $ cacheId = $ jsonRequest -> getHash ( ) ; $ jsonResponse = new JsonResponse ( $ jsonRequest ) ; if ( true === $ isCache && true === $ this -> getCache ( ) -> contains ( $ cacheId ) ) { $ jsonResponse -> setResult ( $ this -> getCache ( ) -> fetch ( $ cacheId ) ) ; $ isCache = false ; } $ result = $ jsonResponse -> getResult ( ) ; if ( null === $ result ) { $ result = $ this -> executeJsonRequest ( $ metadata , $ jsonRequest ) ; } if ( $ result instanceof JsonResponse ) { $ jsonResponse = $ result ; $ jsonResponse -> setRequest ( $ jsonRequest ) ; } else { $ jsonResponse -> setResult ( $ this -> serialize ( $ result ) ) ; } $ isCache && $ this -> cache -> save ( $ cacheId , $ jsonResponse -> getResult ( ) , $ metadata -> getCache ( ) ) ; $ this -> dispatch ( Event \ JsonResponseEvent :: EVENT , new Event \ JsonResponseEvent ( $ jsonResponse ) ) ; } catch ( \ Exception $ exception ) { $ jsonResponse = $ this -> createJsonResponseFromException ( $ exception , $ jsonRequest ) ; } if ( $ this -> stopwatch ) { $ this -> stopwatch -> stop ( 'rpc.execute' ) ; } return $ jsonResponse ; }
5928	public function createCategory ( Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
2867	public function getContent ( $ filePath , $ startPosition , $ endPosition ) { if ( ! file_exists ( $ filePath ) ) { return '' ; } if ( ! $ endPosition ) { return trim ( file_get_contents ( $ filePath , null , null , $ startPosition ) ) ; } if ( $ endPosition <= $ startPosition ) { return '' ; } return trim ( file_get_contents ( $ filePath , null , null , $ startPosition , $ endPosition - $ startPosition ) ) ; }
9103	protected function parse_message ( ) { if ( empty ( $ this -> args [ 'message' ] ) ) { return null ; } $ like = esc_sql ( $ this -> args [ 'message' ] ) ; return new Where ( 'message' , 'LIKE' , "%{$like}%" ) ; }
5585	public function isClickable ( $ label ) { return $ this -> isSubmit ( $ label ) || ( $ this -> getLink ( $ label ) !== false ) || $ this -> isImage ( $ label ) ; }
1245	public static function chain ( ) { $ providers = func_get_args ( ) ; if ( empty ( $ providers ) ) { throw new \ InvalidArgumentException ( 'No providers in chain' ) ; } return function ( ) use ( $ providers ) { $ provider = array_shift ( $ providers ) ; $ credentials = $ provider ( ) ; while ( ( $ provider = array_shift ( $ providers ) ) && ! ( $ credentials instanceof Credentials ) ) { $ credentials = $ provider ( ) ; } return $ credentials ; } ; }
12925	public function setSearch ( $ value ) { if ( ! is_object ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> searchClass ; } $ value = Yii :: createObject ( $ value ) ; } $ value -> dataSource = $ this ; $ this -> _search = $ value ; }
8983	public function isSame ( TableNode $ expected , TableNode $ actual , $ message = NULL ) { $ this -> doAssert ( 'Failed asserting that two tables were identical: ' , [ ] , $ expected , $ actual , $ message ) ; }
2251	public static function convertRelativeUrls ( $ strContent , $ strBase = '' , $ blnHrefOnly = false ) { if ( $ strBase == '' ) { $ strBase = Environment :: get ( 'base' ) ; } $ search = $ blnHrefOnly ? 'href' : 'href|src' ; $ arrUrls = preg_split ( '/((' . $ search . ')="([^"]+)")/i' , $ strContent , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; $ strContent = '' ; for ( $ i = 0 , $ c = \ count ( $ arrUrls ) ; $ i < $ c ; $ i += 4 ) { $ strContent .= $ arrUrls [ $ i ] ; if ( ! isset ( $ arrUrls [ $ i + 2 ] ) ) { continue ; } $ strAttribute = $ arrUrls [ $ i + 2 ] ; $ strUrl = $ arrUrls [ $ i + 3 ] ; if ( ! preg_match ( '@^(?:[a-z0-9]+:|#)@i' , $ strUrl ) ) { $ strUrl = $ strBase . ( ( $ strUrl != '/' ) ? $ strUrl : '' ) ; } $ strContent .= $ strAttribute . '="' . $ strUrl . '"' ; } return $ strContent ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
12209	private function getAccSys ( $ assetTypeCode ) { $ req = new \ Praxigento \ Accounting \ Api \ Service \ Account \ Get \ Request ( ) ; $ req -> setIsSystem ( TRUE ) ; $ req -> setAssetTypeCode ( $ assetTypeCode ) ; $ resp = $ this -> servAccount -> exec ( $ req ) ; $ result = $ resp -> getId ( ) ; return $ result ; }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
12906	public function show ( $ id , FilterRequest $ request ) { $ id = $ this -> getRealId ( $ id ) ; $ request -> criteria [ ] = 'id,=,' . $ id ; $ resource = $ this -> repository -> filter ( $ request ) -> first ( ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
5043	public function addMessage ( $ message , $ namespace = self :: NAMESPACE_INFO ) { if ( ! $ message instanceof NotificationEntityInterface ) { $ messageText = $ this -> isTranslatorEnabled ( ) ? $ this -> getTranslator ( ) -> translate ( $ message , $ this -> getTranslatorTextDomain ( ) ) : $ message ; $ message = new NotificationEntity ( ) ; $ message -> setNotification ( $ messageText ) ; $ message -> setPriority ( $ this -> namespace2priority [ $ namespace ] ) ; } $ nEvent = new NotificationEvent ( ) ; $ nEvent -> setNotification ( $ message ) ; $ this -> notificationListener -> trigger ( NotificationEvent :: EVENT_NOTIFICATION_ADD , $ nEvent ) ; return $ this ; }
788	public function getAttributeHint ( $ attribute ) { $ hints = $ this -> attributeHints ( ) ; return isset ( $ hints [ $ attribute ] ) ? $ hints [ $ attribute ] : '' ; }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
8692	public static function checkSymlink ( $ symlinkTarget , $ symlinkName , $ forceSymlink = false ) { if ( $ forceSymlink && file_exists ( $ symlinkName ) && ! is_link ( $ symlinkName ) ) { if ( 'link' !== filetype ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "{$symlinkName} exists and is not a link" ) ; } } elseif ( is_link ( $ symlinkName ) ) { $ linkTarget = readlink ( $ symlinkName ) ; if ( $ linkTarget !== $ symlinkTarget ) { if ( ! $ forceSymlink ) { throw new \ UnexpectedValueException ( "Symlink '{$symlinkName}' points to '{$linkTarget}' instead of '{$symlinkTarget}'" ) ; } unlink ( $ symlinkName ) ; return false ; } return true ; } return false ; }
9803	public function setCreated ( $ time ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( is_string ( $ time ) ) { if ( is_numeric ( $ time ) ) { $ time = ( int ) $ time ; } else { $ time = strtotime ( $ time ) ; } } $ this -> created = $ time ; return $ this ; }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
11414	public function decryptData ( $ sessionKey , $ iv , $ encrypted ) { try { $ decrypted = openssl_decrypt ( base64_decode ( $ encrypted , true ) , 'aes-128-cbc' , base64_decode ( $ sessionKey , true ) , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , base64_decode ( $ iv , true ) ) ; } catch ( Exception $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } if ( is_null ( $ result = json_decode ( $ this -> decode ( $ decrypted ) , true ) ) ) { throw new EncryptionException ( 'ILLEGAL_BUFFER' , EncryptionException :: ILLEGAL_BUFFER ) ; } return $ result ; }
380	public function renderCallStack ( $ exception ) { $ out = '<ul>' ; $ out .= $ this -> renderCallStackItem ( $ exception -> getFile ( ) , $ exception -> getLine ( ) , null , null , [ ] , 1 ) ; for ( $ i = 0 , $ trace = $ exception -> getTrace ( ) , $ length = count ( $ trace ) ; $ i < $ length ; ++ $ i ) { $ file = ! empty ( $ trace [ $ i ] [ 'file' ] ) ? $ trace [ $ i ] [ 'file' ] : null ; $ line = ! empty ( $ trace [ $ i ] [ 'line' ] ) ? $ trace [ $ i ] [ 'line' ] : null ; $ class = ! empty ( $ trace [ $ i ] [ 'class' ] ) ? $ trace [ $ i ] [ 'class' ] : null ; $ function = null ; if ( ! empty ( $ trace [ $ i ] [ 'function' ] ) && $ trace [ $ i ] [ 'function' ] !== 'unknown' ) { $ function = $ trace [ $ i ] [ 'function' ] ; } $ args = ! empty ( $ trace [ $ i ] [ 'args' ] ) ? $ trace [ $ i ] [ 'args' ] : [ ] ; $ out .= $ this -> renderCallStackItem ( $ file , $ line , $ class , $ function , $ args , $ i + 2 ) ; } $ out .= '</ul>' ; return $ out ; }
4286	public function processLogEntry ( $ method , $ args = array ( ) , $ meta = array ( ) ) { if ( $ method === 'alert' ) { list ( $ method , $ args ) = $ this -> methodAlert ( $ args , $ meta ) ; } elseif ( $ method == 'assert' ) { \ array_unshift ( $ args , false ) ; } elseif ( \ in_array ( $ method , array ( 'count' , 'time' ) ) ) { $ method = 'log' ; } elseif ( \ in_array ( $ method , array ( 'profileEnd' , 'table' ) ) ) { $ method = 'log' ; if ( \ is_array ( $ args [ 0 ] ) ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , $ meta [ 'columns' ] ) ) ; } elseif ( $ meta [ 'caption' ] ) { \ array_unshift ( $ args , $ meta [ 'caption' ] ) ; } } elseif ( $ method === 'trace' ) { $ method = 'table' ; $ args = array ( $ this -> methodTable ( $ args [ 0 ] , array ( 'function' , 'file' , 'line' ) ) ) ; } if ( ! \ in_array ( $ method , $ this -> consoleMethods ) ) { $ method = 'log' ; } foreach ( $ args as $ i => $ arg ) { $ args [ $ i ] = $ this -> dump ( $ arg ) ; } $ this -> json [ 'rows' ] [ ] = array ( $ args , isset ( $ meta [ 'file' ] ) ? $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] : null , $ method === 'log' ? '' : $ method , ) ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
12406	public function exists ( $ key ) { $ filenameCache = $ this -> location . DS . $ key ; if ( file_exists ( $ filenameCache ) ) { return true ; } return false ; }
4476	public function track ( ) : void { if ( $ this -> client -> call ( 'track' , 'track' , $ this -> jid ) ) { $ this -> tracked = true ; } }
9483	public function toArray ( $ changedOnly = false , $ extraData = null ) { $ vars = get_object_vars ( $ this ) ; $ object = array ( ) ; if ( ! is_array ( $ this -> _changes ) ) { $ this -> _changes = array ( ) ; } if ( is_array ( $ extraData ) ) { $ vars = array_merge ( $ vars , $ extraData ) ; } foreach ( $ vars as $ k => $ v ) { if ( strpos ( $ k , '_' ) !== 0 && $ v !== null && ( ! $ changedOnly || array_key_exists ( $ k , $ this -> _changes ) || array_key_exists ( $ k , $ extraData ) ) ) { if ( is_array ( $ v ) ) { $ subV = array ( ) ; foreach ( $ v as $ sub ) { if ( is_a ( $ sub , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ subV [ ] = $ sub -> toArray ( ) ; } else { $ subV [ ] = $ sub ; } } $ object [ $ k ] = $ subV ; } else if ( is_a ( $ v , 'Dlin\Zendesk\Entity\BaseEntity' ) ) { $ object [ $ k ] = $ v -> toArray ( ) ; } else { $ object [ $ k ] = $ v ; } } } return $ object ; }
4953	public function call ( $ method , $ args = [ ] , $ expect = self :: EXPECT_SELF ) { if ( ! is_array ( $ args ) ) { $ expect = $ args ; $ args = [ ] ; } if ( ! $ this -> helper ) { return $ this -> expected ( $ expect ) ; } return call_user_func_array ( [ $ this -> helper , $ method ] , $ args ) ; }
9039	public function getByHash ( $ columns , string $ hash ) : ? IEntity { if ( $ this -> manager -> hasher === null ) { throw new MissingServiceException ( 'Hasher is missing' ) ; } return $ this -> toEntity ( $ this -> manager -> hasher -> hashSQL ( $ this -> builder ( ) , $ columns , $ hash ) ) ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
12654	public function getText ( $ name , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { return $ allTexts [ $ name ] ; } else { return null ; } }
7727	public function login ( $ text , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'account_link' , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
2223	protected function doGetTemplateFolders ( $ path , $ level = 0 ) { $ return = array ( ) ; $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ rootDir . '/' . $ path ) as $ file ) { if ( is_dir ( $ rootDir . '/' . $ path . '/' . $ file ) ) { $ return [ $ path . '/' . $ file ] = str_repeat ( ' &nbsp; &nbsp; ' , $ level ) . $ file ; $ return = array_merge ( $ return , $ this -> doGetTemplateFolders ( $ path . '/' . $ file , $ level + 1 ) ) ; } } return $ return ; }
12964	private function getPerMonth ( $ months ) { $ per_month = [ ] ; $ log = $ this -> logger -> perMonth ( $ months ) ; foreach ( $ log as $ date => $ hits ) { array_push ( $ per_month , [ $ date , $ hits ] ) ; } return $ per_month ; }
1600	public function serialize ( $ record , $ meta = null , array $ links = [ ] ) { $ serializer = clone $ this -> serializer ; $ serializer -> withMeta ( $ meta ) -> withLinks ( $ links ) ; $ serialized = $ serializer -> serializeData ( $ record , $ this -> createEncodingParameters ( ) ) ; $ resourceLinks = null ; if ( empty ( $ serialized [ 'data' ] [ 'id' ] ) ) { unset ( $ serialized [ 'data' ] [ 'id' ] ) ; $ resourceLinks = false ; } $ resource = $ this -> parsePrimaryResource ( $ serialized [ 'data' ] , $ resourceLinks ) ; $ document = [ 'data' => $ resource ] ; if ( isset ( $ serialized [ 'included' ] ) && $ this -> doesSerializeCompoundDocuments ( ) ) { $ document [ 'included' ] = $ this -> parseIncludedResources ( $ serialized [ 'included' ] ) ; } return $ document ; }
10629	public static function hdd ( ) { $ hdd = new \ StdClass ( ) ; $ hdd -> total = @ disk_total_space ( "." ) ; $ hdd -> free = @ disk_free_space ( "." ) ; return $ hdd ; }
1859	public function copy ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return copy ( $ this -> strRootDir . '/' . $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
10335	public function setSuperscript ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'superscript' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> superscript = $ pValue ; $ this -> subscript = ! $ pValue ; } return $ this ; }
4331	public static function unserializeLog ( $ str ) { $ strStart = 'START DEBUG' ; $ strEnd = 'END DEBUG' ; if ( \ preg_match ( '/' . $ strStart . '[\r\n]+(.+)[\r\n]+' . $ strEnd . '/s' , $ str , $ matches ) ) { $ str = $ matches [ 1 ] ; } $ str = self :: isBase64Encoded ( $ str ) ? \ base64_decode ( $ str ) : false ; if ( $ str && \ function_exists ( 'gzinflate' ) ) { $ strInflated = \ gzinflate ( $ str ) ; if ( $ strInflated ) { $ str = $ strInflated ; } } $ data = \ unserialize ( $ str ) ; return $ data ; }
3998	protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { $ objMM = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( null === $ objMM ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'raw' ; } $ objMetaModelItem = $ objMM -> findById ( $ intDataId ) ; if ( null === $ objMetaModelItem ) { throw new \ RuntimeException ( 'MetaModel item not found: ' . $ intDataId ) ; } $ arrAttr = $ objMetaModelItem -> parseAttribute ( $ strAttributeName ) ; return $ arrAttr [ $ strOutput ] ; }
6803	public function installTaxRules ( $ codes = [ 'US' ] ) { $ codes = ( array ) $ codes ; if ( empty ( $ codes ) ) { return ; } $ countryRepository = $ this -> manager -> getRepository ( Country :: class ) ; $ taxRepository = $ this -> manager -> getRepository ( Tax :: class ) ; $ taxRuleRepository = $ this -> manager -> getRepository ( TaxRule :: class ) ; foreach ( $ codes as $ code ) { $ path = __DIR__ . '/data/' . $ code . '_tax_rules.yml' ; if ( ! ( file_exists ( $ path ) && is_readable ( $ path ) ) ) { call_user_func ( $ this -> log , 'Tax rules data' , 'not found' ) ; continue ; } $ data = Yaml :: parse ( file_get_contents ( $ path ) ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { continue ; } foreach ( $ data as $ datum ) { $ name = $ datum [ 'name' ] ; $ result = 'already exists' ; if ( null === $ taxRuleRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ taxRule = new TaxRule ( ) ; $ taxRule -> setName ( $ name ) -> setPriority ( $ datum [ 'priority' ] ) -> setCustomer ( $ datum [ 'customer' ] ) -> setBusiness ( $ datum [ 'business' ] ) -> setNotices ( $ datum [ 'notices' ] ) ; if ( ! empty ( $ countryCodes = $ datum [ 'countries' ] ) ) { $ taxRule -> setCountries ( $ countryRepository -> findBy ( [ 'code' => $ countryCodes ] ) ) ; } if ( ! empty ( $ taxNames = $ datum [ 'taxes' ] ) ) { $ taxRule -> setTaxes ( $ taxRepository -> findBy ( [ 'name' => $ taxNames ] ) ) ; } $ this -> manager -> persist ( $ taxRule ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } } $ this -> manager -> flush ( ) ; }
10645	public function bindInstance ( object $ object ) : Binding { return $ this -> bind ( \ get_class ( $ object ) ) -> instance ( $ object ) ; }
12026	private function generateExecuteDocBlock ( $ methodDescription ) { $ responseClass = $ this -> operationDefinition -> getResponseClass ( ) ; $ docBlock = new DocBlockGenerator ( $ methodDescription , null ) ; if ( $ responseClass ) { $ tags [ ] = new GenericTag ( 'return' , '\\' . $ responseClass ) ; } else { $ tags [ ] = new GenericTag ( 'return' , 'mixed' ) ; } $ docBlock -> setTags ( $ tags ) ; return $ docBlock ; }
10411	public function invalidate ( ) { $ script = escapeshellcmd ( $ this -> rootDir . "/../{$this->cacheScript}" ) ; $ urlsFile = escapeshellarg ( $ this -> createUrlsTempFile ( ) ) ; $ curlTimeout = escapeshellarg ( $ this -> curlTimeout ) ; $ process = new Process ( sprintf ( '%s %s %s' , $ script , $ urlsFile , $ curlTimeout ) ) ; $ process -> start ( ) ; $ this -> resetCache ( ) ; return $ urlsFile ; }
10408	public function addDocumentParameter ( $ field , $ value ) { $ this -> documentParamCache [ md5 ( $ value . $ field ) ] = [ $ field , $ value ] ; }
1655	public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { if ( ! $ error instanceof RuntimeException ) { $ error = new RuntimeException ( 'Connection to ' . $ uri . ' failed because proxy returned invalid response (EBADMSG)' , defined ( 'SOCKET_EBADMSG' ) ? SOCKET_EBADMSG : 71 , $ error ) ; } $ deferred -> reject ( $ error ) ; $ stream -> close ( ) ; } ) ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
11833	public function doRestore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ data = $ cache -> get ( 'config' ) ; if ( $ data ) { $ services = $ this -> getServices ( ) ; $ services -> set ( 'Config' , $ data ) ; $ event -> stopPropagation ( true ) ; } }
2144	public function onBadCredentials ( User $ user , AuthenticationException $ exception ) : AuthenticationException { -- $ user -> loginCount ; if ( $ user -> loginCount > 0 ) { $ user -> save ( ) ; return new BadCredentialsException ( sprintf ( 'Invalid password submitted for username "%s"' , $ user -> username ) , $ exception -> getCode ( ) , $ exception ) ; } $ user -> locked = time ( ) + $ this -> options [ 'lock_period' ] ; $ user -> loginCount = $ this -> options [ 'login_attempts' ] ; $ user -> save ( ) ; $ lockedSeconds = $ user -> locked - time ( ) ; $ lockedMinutes = ( int ) ceil ( $ lockedSeconds / 60 ) ; $ exception = new LockedException ( $ lockedSeconds , sprintf ( 'User "%s" has been locked for %s minutes' , $ user -> username , $ lockedMinutes ) , 0 , $ exception ) ; $ exception -> setUser ( $ user ) ; return $ exception ; }
456	public function dropForeignKey ( $ name , $ table ) { return 'ALTER TABLE ' . $ this -> db -> quoteTableName ( $ table ) . ' DROP CONSTRAINT ' . $ this -> db -> quoteColumnName ( $ name ) ; }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
3520	public function choice ( $ key , $ number , array $ replace = array ( ) , $ locale = null , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { return $ this -> get ( $ key , $ replace , $ locale , true , $ useDB ) ; } else { if ( $ useDB !== null ) { $ oldUseDB = $ this -> useDB ; $ this -> useDB = $ useDB ; $ retVal = parent :: choice ( $ key , $ number , $ replace , $ locale ) ; $ this -> useDB = $ oldUseDB ; return $ retVal ; } else { return parent :: choice ( $ key , $ number , $ replace , $ locale ) ; } } }
5060	public static function fromURI ( $ URI ) { $ regex = '/^(([^-]|--)+)-(([^-]|--)+)-(([^-]|--)+)\.(svg|png|gif|jpg)$/' ; $ match = array ( ) ; if ( 1 != preg_match ( $ regex , $ URI , $ match ) && ( 7 != count ( $ match ) ) ) { throw new \ InvalidArgumentException ( 'The URI given is not a valid URI' . $ URI ) ; } $ subject = $ match [ 1 ] ; $ status = $ match [ 3 ] ; $ color = $ match [ 5 ] ; $ format = $ match [ 7 ] ; return new self ( $ subject , $ status , $ color , $ format ) ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
3339	public function getGroupsChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'group_list' , 'GET' , $ options ) ; $ groups_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ groups_raw as $ group_raw ) { $ resultArr [ ] = new Group ( $ group_raw -> id , $ this ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
6793	protected function getTagSortSourceColumn ( $ prefix = null ) { $ column = $ this -> get ( 'tag_srcsorting' ) ; if ( ! $ column ) { return null ; } if ( null !== $ prefix ) { return $ prefix . '.' . $ column ; } return $ column ; }
2513	protected function isWorseStatus ( $ newStatus , $ currentStatus ) { $ levels = [ self :: STATUS_UNKNOWN => - 1 , self :: STATUS_OK => 0 , self :: STATUS_INFO => 2 , self :: STATUS_WARN => 5 , self :: STATUS_ERROR => 10 , self :: STATUS_FATAL => 20 , ] ; return ( $ currentStatus === null || $ levels [ $ newStatus ] > $ levels [ $ currentStatus ] ) ; }
1278	public static function addLocationInformation ( stdClass $ location , DOMNode $ locationNode ) { self :: appendChild ( $ location , 'CompanyName' , $ locationNode ) ; self :: appendChild ( $ location , 'AttentionName' , $ locationNode ) ; if ( isset ( $ location -> Address ) ) { self :: addAddressNode ( $ location -> Address , $ locationNode ) ; } }
1525	protected function doCreate ( StoreInterface $ store , CreateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> createRecord ( $ request -> getResourceType ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , false ) ? : $ record ; }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
616	public function setDefinitions ( array $ definitions ) { foreach ( $ definitions as $ class => $ definition ) { if ( is_array ( $ definition ) && count ( $ definition ) === 2 && array_values ( $ definition ) === $ definition ) { $ this -> set ( $ class , $ definition [ 0 ] , $ definition [ 1 ] ) ; continue ; } $ this -> set ( $ class , $ definition ) ; } }
6276	protected function readInt31 ( $ pos = 0 ) { $ uint31 = $ this -> readInt32 ( $ pos ) ; if ( $ uint31 > 0x7fffffff ) { throw new Exception ( 'Error in CDB file "' . $ this -> fileName . '", integer too big.' ) ; } return $ uint31 ; }
6610	public static function getByCreatedDateRange ( $ startDate , $ endDate , $ createdAtColumn = 'created_at' ) { $ model = get_called_class ( ) ; $ model = new $ model ; return self :: find ( ) -> andWhere ( $ model :: tableName ( ) . '.' . $ createdAtColumn . ' BETWEEN :start_date AND :end_date' , [ 'start_date' => $ startDate , 'end_date' => $ endDate ] ) ; }
12718	protected function markAsResolved ( $ abstract , $ resolvedInstance , $ flag = [ ] ) { if ( ! is_array ( $ flag ) ) { $ flag = array_slice ( func_get_args ( ) , 2 ) ; } if ( $ this -> isAbstractExists ( $ abstract ) ) { $ this -> resolved [ $ abstract ] = [ 'concrete' => $ resolvedInstance , 'resolved' => true , 'flag' => join ( '|' , $ flag ) ] ; } }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
12250	public function getAttribute ( $ strName , $ varDefault = false ) { if ( isset ( $ this -> attributes ( ) -> $ strName ) && ( ( ( string ) $ this -> attributes ( ) -> $ strName ) !== '' ) ) { return ( string ) $ this -> attributes ( ) -> $ strName ; } else { return $ varDefault ; } }
6771	protected function isDiscountUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'autoDiscount' ] ) ) { return true ; } if ( ( 0 == $ sale -> getPaidTotal ( ) ) && $ this -> persistenceHelper -> isChanged ( $ sale , [ 'customerGroup' , 'customer' ] ) ) { return true ; } return $ this -> didInvoiceCountryChanged ( $ sale ) ; }
9080	private static function parseElement ( Request & $ req , $ serverVars , $ elementName , $ paramName ) { if ( isset ( $ serverVars [ $ elementName ] ) ) { $ req -> setParam ( $ paramName , $ serverVars [ $ elementName ] ) ; } }
7250	protected function validateDeliveryAddress ( SaleInterface $ sale , Constraint $ constraint ) { if ( ! $ sale -> isSameAddress ( ) && null === $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_is_required ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } elseif ( $ sale -> isSameAddress ( ) && null !== $ sale -> getDeliveryAddress ( ) ) { $ this -> context -> buildViolation ( $ constraint -> delivery_address_should_be_null ) -> atPath ( 'deliveryAddress' ) -> addViolation ( ) ; } }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
2169	private function acceptLicense ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( 'tl_license' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'license.html.twig' ) ; } $ this -> container -> get ( 'contao.install_tool' ) -> persistConfig ( 'licenseAccepted' , true ) ; return $ this -> getRedirectResponse ( ) ; }
2383	public function onKernelRequest ( GetResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isBackendMasterRequest ( $ event ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( null === $ this -> token ) { $ this -> token = $ this -> tokenManager -> refreshToken ( 'contao_referer_id' ) ; } $ request -> attributes -> set ( '_contao_referer_id' , $ this -> token -> getValue ( ) ) ; }
3452	public function getAggregateRoot ( string $ aggregateId ) { if ( ! $ this -> disableIdentityMap && isset ( $ this -> identityMap [ $ aggregateId ] ) ) { return $ this -> identityMap [ $ aggregateId ] ; } if ( $ this -> snapshotStore ) { $ eventSourcedAggregateRoot = $ this -> loadFromSnapshotStore ( $ aggregateId ) ; if ( $ eventSourcedAggregateRoot && ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; } $ streamName = $ this -> determineStreamName ( $ aggregateId ) ; if ( $ this -> oneStreamPerAggregate ) { try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 ) ; } catch ( StreamNotFound $ e ) { return null ; } } else { $ metadataMatcher = new MetadataMatcher ( ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_type' , Operator :: EQUALS ( ) , $ this -> aggregateType -> toString ( ) ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_id' , Operator :: EQUALS ( ) , $ aggregateId ) ; try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 , null , $ metadataMatcher ) ; } catch ( StreamNotFound $ e ) { return null ; } } if ( ! $ streamEvents -> valid ( ) ) { return null ; } $ eventSourcedAggregateRoot = $ this -> aggregateTranslator -> reconstituteAggregateFromHistory ( $ this -> aggregateType , $ streamEvents ) ; if ( ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
4722	public function setText ( $ text ) { $ this -> text = $ text ; if ( ! $ this -> text instanceof Text ) { $ this -> text = new Text ( $ this -> text ) ; } return $ this ; }
1551	protected function requiresInverseAdapter ( $ record , EncodingParametersInterface $ parameters ) { return ! empty ( $ parameters -> getFilteringParameters ( ) ) || ! empty ( $ parameters -> getSortParameters ( ) ) || ! empty ( $ parameters -> getPaginationParameters ( ) ) || ! empty ( $ parameters -> getIncludePaths ( ) ) ; }
12412	public function getDetails ( $ groupId , $ begin , $ count ) { $ params = [ 'group_id' => intval ( $ groupId ) , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_DETAIL , $ params ] ) ; }
11051	function build_all ( $ datatree , $ entry ) { if ( ! isset ( $ this -> masktree [ $ entry ] ) ) { $ this -> error ( 8 , 57 , $ entry ) ; } $ this -> datatree = $ datatree ; if ( is_array ( $ this -> datatree ) ) { $ this -> datatree [ '_parent' ] = NULL ; } elseif ( is_object ( $ this -> datatree ) ) { $ this -> datatree -> _parent = NULL ; } elseif ( isset ( $ this -> datatree ) ) { $ this -> error ( 9 , 58 ) ; $ this -> datatree = NULL ; } $ built = $ this -> build_mask ( $ this -> datatree , $ this -> masktree [ $ entry ] ) ; if ( ! isset ( $ this -> masktree [ '0reduce' ] ) ) { $ this -> masktree [ '0reduce' ] = _ETS_REDUCE_OFF ; } switch ( $ this -> masktree [ '0reduce' ] ) { case _ETS_REDUCE_OFF : break ; case _ETS_REDUCE_SPACES : $ built = preg_replace ( '/(\r\n|\r|\n)+/sm' , "\n" , preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , "\n" , $ built ) ) ; break ; case _ETS_REDUCE_ALL : $ built = preg_replace ( '/[ \t]*?(\r\n|\r|\n)+[\t ]*/sm' , '' , $ built ) ; break ; } $ built = str_replace ( "\1n\1" , "\n" , $ built ) ; $ built = str_replace ( "\1r\1" , "\r" , $ built ) ; $ built = str_replace ( "\1t\1" , "\t" , $ built ) ; $ built = str_replace ( "\1s\1" , " " , $ built ) ; return $ built ; }
790	public function getErrorSummary ( $ showAllErrors ) { $ lines = [ ] ; $ errors = $ showAllErrors ? $ this -> getErrors ( ) : $ this -> getFirstErrors ( ) ; foreach ( $ errors as $ es ) { $ lines = array_merge ( ( array ) $ es , $ lines ) ; } return $ lines ; }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
6474	private function rankAcceptCharsetHeaders ( array $ charsetHeaders ) : array { usort ( $ charsetHeaders , [ $ this , 'compareAcceptCharsetHeaders' ] ) ; $ rankedCharsetHeaders = array_filter ( $ charsetHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedCharsetHeaders ) ; }
10986	public static function getMaxUploadSize ( $ max_size = 0 ) { $ post_max_size = Tools :: unformatBytes ( ini_get ( 'post_max_size' ) ) ; $ upload_max_filesize = Tools :: unformatBytes ( ini_get ( 'upload_max_filesize' ) ) ; if ( $ max_size > 0 ) { $ result = min ( $ post_max_size , $ upload_max_filesize , $ max_size ) ; } else { $ result = min ( $ post_max_size , $ upload_max_filesize ) ; } return $ result ; }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
4215	private static function keys ( $ val ) { if ( Abstracter :: isAbstraction ( $ val ) ) { if ( $ val [ 'type' ] == 'object' ) { if ( $ val [ 'traverseValues' ] ) { $ val = $ val [ 'traverseValues' ] ; } elseif ( $ val [ 'stringified' ] ) { $ val = null ; } elseif ( isset ( $ val [ 'methods' ] [ '__toString' ] [ 'returnValue' ] ) ) { $ val = null ; } else { $ val = \ array_filter ( $ val [ 'properties' ] , function ( $ prop ) { return $ prop [ 'visibility' ] === 'public' ; } ) ; \ ksort ( $ val , SORT_NATURAL | SORT_FLAG_CASE ) ; } } else { $ val = null ; } } return \ is_array ( $ val ) ? \ array_keys ( $ val ) : array ( self :: SCALAR ) ; }
3418	public static function registerEloquent ( ) { $ capsule = self :: bootstrapIlluminateDatabase ( ) ; class_alias ( Capsule :: class , 'DB' ) ; if ( $ _COOKIE [ "show_sql_stat" ] == "Y" ) { Capsule :: enableQueryLog ( ) ; $ em = \ Bitrix \ Main \ EventManager :: getInstance ( ) ; $ em -> addEventHandler ( 'main' , 'OnAfterEpilog' , [ IlluminateQueryDebugger :: class , 'onAfterEpilogHandler' ] ) ; } static :: addEventListenersForHelpersHighloadblockTables ( $ capsule ) ; }
10380	protected static function is_modified_hash ( $ url , $ path ) { if ( self :: is_external_url ( $ url ) ) { if ( sha1_file ( $ url ) !== sha1_file ( $ path ) ) { self :: $ changes = true ; return self :: $ changes ; } } return false ; }
10687	private function setCreatePermissions ( ) { if ( $ this -> config -> has ( 'io' , 'group' ) ) Path :: setDefaultFileGroup ( $ this -> config -> get ( 'io' , 'group' ) ) ; $ file_mode = ( int ) $ this -> config -> get ( 'io' , 'file_mode' ) ; if ( $ file_mode ) { $ of = $ file_mode ; $ file_mode = octdec ( sprintf ( "%04d" , $ file_mode ) ) ; Path :: setDefaultFileMode ( $ file_mode ) ; } $ dir_mode = ( int ) $ this -> config -> get ( 'io' , 'dir_mode' ) ; if ( $ dir_mode ) { $ of = $ dir_mode ; $ dir_mode = octdec ( sprintf ( "%04d" , $ dir_mode ) ) ; Path :: setDefaultDirMode ( $ dir_mode ) ; } }
8507	public function getPackageLabels ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPackageLabelsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPackageLabelsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageLabels' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPackageLabelsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
3613	public function setTargetTemperature ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temperature = $ this -> temperatureInCelsius ( $ temperature , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature' => $ temperature ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
11673	public function offsetExists ( $ offset ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( array_key_exists ( $ offset , $ this -> result ) ) { return true ; } else { return false ; } }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
7307	public static function create ( $ year = null , $ month = null , $ day = null , $ hour = null , $ min = null , $ sec = null , $ timezone = null , $ timescale = null ) { return new static ( $ year , $ month , $ day , $ hour , $ min , $ sec , $ timezone , $ timescale ) ; }
6310	private function getCommand ( DatabaseObjectInterface $ databaseObject , $ isCreate = true ) { if ( $ databaseObject instanceof Column ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_column' : 'rentgen.drop_column' ) -> setColumn ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof ConstraintInterface ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.add_constraint' : 'rentgen.drop_constraint' ) -> setConstraint ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Index ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_index' : 'rentgen.drop_index' ) -> setIndex ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Schema ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_schema' : 'rentgen.drop_schema' ) -> setSchema ( $ databaseObject ) ; } elseif ( $ databaseObject instanceof Table ) { $ command = $ this -> container -> get ( $ isCreate ? 'rentgen.create_table' : 'rentgen.drop_table' ) -> setTable ( $ databaseObject ) ; } else { throw new \ Exception ( sprintf ( "Class %s is not supported" , get_class ( $ databaseObject ) ) ) ; } return $ command ; }
944	private function parseRules ( ) { if ( null === $ this -> options [ 'rules' ] ) { return $ this -> getConfig ( ) -> getRules ( ) ; } $ rules = trim ( $ this -> options [ 'rules' ] ) ; if ( '' === $ rules ) { throw new InvalidConfigurationException ( 'Empty rules value is not allowed.' ) ; } if ( '{' === $ rules [ 0 ] ) { $ rules = json_decode ( $ rules , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidConfigurationException ( sprintf ( 'Invalid JSON rules input: %s.' , json_last_error_msg ( ) ) ) ; } return $ rules ; } $ rules = [ ] ; foreach ( explode ( ',' , $ this -> options [ 'rules' ] ) as $ rule ) { $ rule = trim ( $ rule ) ; if ( '' === $ rule ) { throw new InvalidConfigurationException ( 'Empty rule name is not allowed.' ) ; } if ( '-' === $ rule [ 0 ] ) { $ rules [ substr ( $ rule , 1 ) ] = false ; } else { $ rules [ $ rule ] = true ; } } return $ rules ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
5432	protected function isAbstractMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isAbstract ( ) ; }
9730	public function setMaxParcelDimensions ( $ value = null ) { if ( is_array ( $ value ) ) { $ value = new ParcelDimensions ( $ value ) ; } elseif ( ! ( $ value instanceof ParcelDimensions ) ) { $ value = null ; } return $ this -> setParameter ( 'max_parcel_dimensions' , $ value ) ; }
1237	private function set ( $ class , $ name , $ value ) { self :: ensurePropertyExists ( $ class , $ name ) ; self :: ensurePropertyType ( $ class , $ name , $ value ) ; $ this -> setValue ( $ class , $ name , $ value ) ; }
2739	private function uploadVcl ( $ activate ) { try { $ service = $ this -> api -> checkServiceDetails ( ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'priority' => 50 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_pass' , 'statement' => 'req.http.x-pass' , 'type' => 'REQUEST' , 'priority' => 90 ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ request = [ 'action' => 'pass' , 'max_stale_age' => 3600 , 'name' => Config :: FASTLY_MAGENTO_MODULE . '_request' , 'request_condition' => $ createCondition -> name , 'service_id' => $ service -> id , 'version' => $ currActiveVersion ] ; $ this -> api -> createRequest ( $ clone -> number , $ request ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; $ msg = 'Successfully uploaded VCL. ' ; if ( $ activate ) { $ this -> api -> activateVersion ( $ clone -> number ) ; $ msg .= 'Activated Version ' . $ clone -> number ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Upload VCL has been initiated and activated in version ' . $ clone -> number . '*' ) ; } $ this -> output -> writeln ( '<info>' . $ msg . '</info>' , OutputInterface :: OUTPUT_NORMAL ) ; } catch ( \ Exception $ e ) { $ msg = $ e -> getMessage ( ) ; $ this -> output -> writeln ( "<error>$msg</error>" , OutputInterface :: OUTPUT_NORMAL ) ; return ; } }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
5427	public function getInterfaces ( ) { $ reflection = new ReflectionClass ( $ this -> interface ) ; if ( $ reflection -> isInterface ( ) ) { return array ( $ this -> interface ) ; } return $ this -> onlyParents ( $ reflection -> getInterfaces ( ) ) ; }
1951	public function resendButton ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( ! $ row [ 'confirmedOn' ] && ! $ row [ 'invalidatedThrough' ] && $ row [ 'emailSubject' ] && $ row [ 'emailText' ] && $ row [ 'createdOn' ] > strtotime ( '-24 hours' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : '' ; }
6453	private function createBody ( IHttpRequestMessage $ request , $ rawBody , ContentNegotiationResult & $ contentNegotiationResult = null ) : ? IHttpBody { if ( $ rawBody === null || $ rawBody instanceof IHttpBody ) { return $ rawBody ; } if ( $ rawBody instanceof IStream ) { return new StreamBody ( $ rawBody ) ; } if ( is_scalar ( $ rawBody ) ) { return new StringBody ( ( string ) $ rawBody ) ; } if ( ( ! is_object ( $ rawBody ) && ! is_array ( $ rawBody ) ) || is_callable ( $ rawBody ) ) { throw new InvalidArgumentException ( 'Unsupported body type ' . gettype ( $ rawBody ) ) ; } $ type = TypeResolver :: resolveType ( $ rawBody ) ; $ contentNegotiationResult = $ this -> contentNegotiator -> negotiateResponseContent ( $ type , $ request ) ; $ mediaTypeFormatter = $ contentNegotiationResult -> getFormatter ( ) ; if ( $ mediaTypeFormatter === null ) { throw $ this -> createNotAcceptableException ( $ type ) ; } $ bodyStream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; try { $ mediaTypeFormatter -> writeToStream ( $ rawBody , $ bodyStream , $ contentNegotiationResult -> getEncoding ( ) ) ; } catch ( SerializationException $ ex ) { throw new HttpException ( HttpStatusCodes :: HTTP_INTERNAL_SERVER_ERROR , 'Failed to serialize response body' , 0 , $ ex ) ; } return new StreamBody ( $ bodyStream ) ; }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
9893	protected function getInputProps ( ) { $ props = ( array ) $ this -> getElement ( ) -> getAttributes ( ) ; $ props [ 'name' ] = $ this -> get ( '_element' ) -> get ( 'name' ) ; $ props [ '_form' ] = $ this -> getForm ( ) ; $ props [ '_element' ] = $ this -> getElement ( ) ; return $ props ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
3252	public function placeOrder ( $ statusCode = null ) { if ( empty ( $ statusCode ) ) $ statusCode = Config :: get ( 'shop.order_status_placement' ) ; $ order = call_user_func ( Config :: get ( 'shop.order' ) . '::create' , [ 'user_id' => $ this -> user_id , 'statusCode' => $ statusCode ] ) ; for ( $ i = count ( $ this -> items ) - 1 ; $ i >= 0 ; -- $ i ) { $ this -> items [ $ i ] -> order_id = $ order -> id ; $ this -> items [ $ i ] -> cart_id = null ; $ this -> items [ $ i ] -> save ( ) ; } $ this -> resetCalculations ( ) ; return $ order ; }
5216	public static function createInstance ( $ className , $ projectPath ) { Runtime :: reset ( ) ; self :: $ projectPath = $ projectPath ; $ binder = new Binder ( ) ; foreach ( static :: getBindingsForApp ( $ className ) as $ bindingModule ) { if ( is_string ( $ bindingModule ) ) { $ bindingModule = new $ bindingModule ( ) ; } if ( $ bindingModule instanceof BindingModule ) { $ bindingModule -> configure ( $ binder , $ projectPath ) ; } elseif ( $ bindingModule instanceof \ Closure ) { $ bindingModule ( $ binder , $ projectPath ) ; } else { throw new \ InvalidArgumentException ( 'Given module class ' . get_class ( $ bindingModule ) . ' is not an instance of stubbles\ioc\module\BindingModule' ) ; } } return $ binder -> getInjector ( ) -> getInstance ( $ className ) ; }
3482	public function withContentAvailable ( bool $ contentAvailable ) : Aps { $ cloned = clone $ this ; $ cloned -> contentAvailable = $ contentAvailable ; return $ cloned ; }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
12542	public function get ( ) : \ TheCMSThread \ Core \ Main \ View { if ( $ this -> getLink ( ) == '/' ) { $ this -> details = Model \ Page :: find ( 1 ) ; } else { $ this -> details = Model \ Page :: where ( 'link' , $ this -> getLink ( ) ) ; if ( $ this -> auth -> allow ( [ "min" => 3 , "max" => 1 ] ) === false ) { $ this -> details -> where ( 'status' , true ) ; } $ this -> details = $ this -> details -> first ( ) ; } if ( $ this -> details === null ) { $ this -> details = false ; } return $ this ; }
10652	protected function _unsetMany ( $ keys ) { $ keys = $ this -> _normalizeIterable ( $ keys ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnsetMany ( $ store , $ keys ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
6667	public function prepareResponse ( ) { if ( ! $ this -> writer ) { $ this -> writer = $ this -> writerFactory -> getWriterFor ( $ this -> request -> getFormats ( ) ) ; } $ this -> preparedResponse = $ this -> writer -> format ( $ this -> getBody ( ) , $ this -> responseName ) ; return $ this ; }
3251	public function scopeFindByUser ( $ query , $ userId ) { if ( empty ( $ userId ) ) return ; $ cart = $ query -> whereUser ( $ userId ) -> first ( ) ; if ( empty ( $ cart ) ) { $ cart = call_user_func ( Config :: get ( 'shop.cart' ) . '::create' , [ 'user_id' => $ userId ] ) ; } return $ cart ; }
5446	protected function addInTagTokens ( ) { $ this -> mapHandler ( 'tag' , 'acceptStartToken' ) ; $ this -> addSpecialPattern ( '\s+' , 'tag' , 'ignore' ) ; $ this -> addAttributeTokens ( ) ; $ this -> addExitPattern ( '/>' , 'tag' ) ; $ this -> addExitPattern ( '>' , 'tag' ) ; }
12890	public function createView ( ) : \ stdClass { $ oView = new \ stdClass ; $ oView -> form = $ this -> _sView ; $ oView -> form_start = $ this -> _oForm -> getFormInObject ( ) -> start ; $ oView -> form_end = $ this -> _oForm -> getFormInObject ( ) -> end ; $ oView -> form_row = array ( ) ; foreach ( $ this -> _oForm -> getFormInObject ( ) -> form as $ sKey => $ mValue ) { if ( $ mValue instanceof Container ) { $ oNewForm = $ mValue -> createView ( ) ; $ oView -> form_row [ $ sKey ] = $ oNewForm -> form_row ; } else { $ oView -> form_row [ $ sKey ] = $ mValue ; } } return $ oView ; }
10673	protected function _getCached ( $ key , $ default = null , $ ttl = null ) { try { return $ this -> _get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { if ( is_callable ( $ default ) ) { try { $ args = $ this -> _normalizeArray ( $ this -> _getGeneratorArgs ( $ key , $ default , $ ttl ) ) ; $ default = $ this -> _invokeCallable ( $ default , $ args ) ; } catch ( RootException $ e ) { throw $ this -> _createRuntimeException ( $ this -> __ ( 'Could not generate value' ) , null , $ e ) ; } } $ this -> _set ( $ key , $ default , $ ttl ) ; return $ default ; } }
2810	public function initLogging ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ this -> logging = Mage :: getModel ( 'sheep_debug/logging' ) ; $ this -> logging -> addFile ( $ helper -> getLogFilename ( $ this -> getStoreId ( ) ) ) ; $ this -> logging -> addFile ( $ helper -> getExceptionLogFilename ( $ this -> getStoreId ( ) ) ) ; Mage :: dispatchEvent ( 'sheep_debug_init_logging' , array ( 'logging' => $ this -> logging ) ) ; $ this -> logging -> startRequest ( ) ; }
9715	private function writeNumberFormat ( $ format , $ ifmt ) { $ record = 0x041E ; $ numberFormatString = StringHelper :: UTF8toBIFF8UnicodeLong ( $ format ) ; $ length = 2 + strlen ( $ numberFormatString ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ ifmt ) . $ numberFormatString ; $ this -> append ( $ header . $ data ) ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
10793	public function delete ( $ idOrUser , $ forceLogout = true ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ em = $ main -> getEntityManager ( ) ; $ user = $ this -> getEntity ( $ idOrUser ) ; $ classifiedService = $ this -> getServiceLocator ( ) -> get ( 'document.service.classified' ) ; if ( ! $ this -> checkIfOwnerOrAdmin ( $ user ) ) { throw new \ Exception ( 'Non possiedi i permessi per agire su questo documento' ) ; } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ , $ this , array ( 'user' => $ user ) ) ; $ user -> setState ( UserEntity :: USER_STATE_DELETED ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ documents = $ user -> getDocument ( ) ; foreach ( $ documents as $ document ) { try { $ classifiedService -> delete ( $ document ) ; } catch ( \ Exception $ e ) { } } $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , array ( 'user' => $ user ) ) ; if ( $ forceLogout ) { $ this -> logout ( ) ; } return $ user ; }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
10661	public function withoutCookie ( $ cookieName = null ) { $ object = clone $ this ; if ( ! $ this -> configs [ 'cookies' ] instanceof CookieJarInterface ) { return $ object ; } if ( ! $ cookieName ) { unset ( $ object -> configs [ 'cookies' ] ) ; } else { if ( ! is_array ( $ cookieName ) ) { $ cookieName = [ $ cookieName ] ; } $ cookies = $ this -> configs [ 'cookies' ] -> toArray ( ) ; foreach ( $ cookieName as $ cookie ) { if ( ! is_string ( $ cookie ) || ! $ cookie ) { continue ; } unset ( $ cookies [ $ cookie ] ) ; } $ this -> configs [ 'cookies' ] = new CookieJar ( $ cookies ) ; } return $ object -> buildConfigClient ( ) ; }
11851	public function show ( ) { $ response = new \ Venus \ lib \ Response ( ) ; $ response -> setContent ( '<html><body><h1>Hello world!</h1></body></html>' ) ; $ response -> setStatusCode ( \ Venus \ lib \ Response :: HTTP_OK ) ; $ response -> headers -> set ( 'Content-Type' , 'text/html' ) ; $ response -> send ( ) ; }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
12708	public static function runCommand ( string $ command , array $ arguments = null , array $ options = null ) : void { $ commandObject = new $ command ( $ arguments , $ options ) ; $ commandObject -> update ( $ arguments , $ options ) ; $ commandObject -> handle ( ) ; }
5927	public function retrieveCategory ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
10413	public function loadUrlsByType ( $ type ) { foreach ( $ this -> urlCollectors as $ collector ) { $ this -> addUrls ( $ collector -> getUrlsByType ( $ type , $ this -> router ) ) ; } }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
8249	protected function needsPasswordRehash ( array $ userData ) { if ( $ this -> config [ "login" ] [ "passwordRehash" ] !== true ) { return false ; } if ( isset ( $ userData [ 'encoder' ] ) && $ userData [ 'encoder' ] !== $ this -> config [ "encoder" ] ) { return true ; } $ encoder = $ this -> getPasswordEncoder ( $ userData ) ; return $ encoder -> needsRehash ( $ userData [ 'pwhash' ] ) ; }
1468	public static function wantsJsonApi ( $ request ) { $ acceptable = $ request -> getAcceptableContentTypes ( ) ; return isset ( $ acceptable [ 0 ] ) && IlluminateStr :: contains ( $ acceptable [ 0 ] , MediaType :: JSON_API_SUB_TYPE ) ; }
11267	public function view ( $ pathname = '' , $ data = false , $ return = false ) { if ( is_array ( $ data ) || is_object ( $ data ) ) { foreach ( $ data as $ key => $ value ) { $ $ key = $ value ; } } if ( $ pathname == '' ) { $ pathname = $ this -> config [ 'template' ] ; } $ fullPath = $ this -> config [ 'pathToViews' ] . $ this -> getPath ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; $ this -> debug ( 'Full Path: ' . $ fullPath ) ; $ fileName = $ this -> config [ 'viewsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'viewsPostfix' ] . '.php' ; $ filePath = $ this -> _getFilePath ( $ pathname , $ fileName ) ; $ this -> debug ( '' ) ; $ this -> debug ( 'Searching for View: ' ) ; $ this -> debug ( 'View Name: ' . $ this -> getName ( $ pathname ) ) ; $ this -> debug ( 'View Path: ' . $ this -> getPath ( $ pathname ) ) ; $ this -> debug ( 'File Path: ' . $ filePath ) ; $ this -> debug ( '' ) ; if ( $ return || $ this -> neverOutput ) { ob_start ( ) ; $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } return ob_get_clean ( ) ; } else { $ inc = include ( $ filePath ) ; if ( $ inc == false && $ this -> config [ 'mode' ] == 'development' ) { throw new \ Exception ( "Can't find file '$fileName' using path '$filePath'" ) ; } } }
3993	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModelFromModel ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
6979	private function getClient ( ) { if ( null !== $ this -> client ) { return $ this -> client ; } try { return $ this -> client = new \ SoapClient ( static :: ENDPOINT ) ; } catch ( \ SoapFault $ oExcept ) { if ( $ this -> debug ) { @ trigger_error ( 'Failed to connect to the europa web service: ' . $ oExcept -> getMessage ( ) ) ; } } return $ this -> client = null ; }
10581	public function handleRequest ( ServerRequestInterface $ serverRequest , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withProtocolVersion ( $ serverRequest -> getProtocolVersion ( ) ) ; try { try { $ APIRequest = $ this -> requestFactory -> create ( $ serverRequest ) ; } catch ( UnableToCreateRequestException $ exception ) { return $ this -> handleRequestFactoryException ( $ exception , $ response ) ; } try { $ APIResponse = $ this -> server -> handleRequest ( $ APIRequest ) ; } catch ( UnableToHandleRequestException $ exception ) { return $ this -> handleServerException ( $ exception , $ response ) ; } return $ this -> buildResponse ( $ APIResponse , $ response ) ; } catch ( \ Throwable $ e ) { $ this -> logCaughtThrowableResultingInHTTPCode ( 500 , $ e , LogLevel :: CRITICAL ) ; return $ response -> withStatus ( 500 , "Internal Server Error" ) ; } }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
5664	private function collectFrames ( $ node ) { $ frames = array ( ) ; if ( $ node -> name === 'frame' ) { $ frames = array ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) ) ; } elseif ( $ node -> hasChildren ( ) ) { $ frames = array ( ) ; foreach ( $ node -> child as $ child ) { $ frames = array_merge ( $ frames , $ this -> collectFrames ( $ child ) ) ; } } return $ frames ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
7775	protected function handleError ( $ field , $ value , $ rule , array $ args ) { $ this -> errors [ $ rule ] [ ] = [ 'field' => $ field , 'value' => $ value , 'args' => $ args , ] ; }
11926	public function setAutoloadDir ( $ dir ) { if ( ! is_string ( $ dir ) || empty ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'Invalid directory for autoload of configuration provided; ' . 'must be a non-empty string, "%s" received.' , is_object ( $ dir ) ? get_class ( $ dir ) : gettype ( $ dir ) ) ) ; } $ dir = Normalizer :: path ( $ dir ) ; if ( ! file_exists ( $ dir ) || ! is_dir ( $ dir ) ) { throw new InvalidArgumentException ( sprintf ( 'The directory "%s", specified for autoload of configurations, ' . 'does not exists.' , $ dir ) ) ; } $ this -> autoloadDir = $ dir ; }
9892	protected function createError ( ) { $ error = $ this -> getForm ( ) -> getValidator ( ) -> getMessages ( $ this -> getElement ( ) -> getName ( ) ) ; if ( $ error ) { $ this -> error = $ this -> builder -> make ( 'error' , [ ] , $ error ) ; } }
10997	public function read ( int $ offset = 0 ) { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE ) === false ) { $ this -> error = "failed to read file; {$this->error}" ; return false ; } return $ this -> readFile ( $ offset ) ; }
1960	public static function decode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> decode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
10790	protected function quote ( $ str ) { return $ this -> getDialect ( ) -> quote ( $ str , $ this -> getSettings ( ) [ 'autoQuote' ] ? DialectInterface :: QUOTE_YES : DialectInterface :: QUOTE_NO ) ; }
5901	public function listGroups ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new Group ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5366	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ this -> results [ ] = new SimpleResultOfFail ( parent :: getTestList ( ) , $ message ) ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
12519	public function getByCalcId ( $ calcId ) { $ where = Entity :: A_CALC_REF . '=' . ( int ) $ calcId ; $ result = $ this -> get ( $ where ) ; return $ result ; }
1131	public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
4674	public function addCallback ( $ callback , $ data = [ ] , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( [ "callback" => $ callback ] , $ data , $ sort , "callback" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
665	protected function openFromPoolSequentially ( array $ pool , array $ sharedConfig ) { if ( empty ( $ pool ) ) { return null ; } if ( ! isset ( $ sharedConfig [ 'class' ] ) ) { $ sharedConfig [ 'class' ] = get_class ( $ this ) ; } $ cache = is_string ( $ this -> serverStatusCache ) ? Yii :: $ app -> get ( $ this -> serverStatusCache , false ) : $ this -> serverStatusCache ; foreach ( $ pool as $ config ) { $ config = array_merge ( $ sharedConfig , $ config ) ; if ( empty ( $ config [ 'dsn' ] ) ) { throw new InvalidConfigException ( 'The "dsn" option must be specified.' ) ; } $ key = [ __METHOD__ , $ config [ 'dsn' ] ] ; if ( $ cache instanceof CacheInterface && $ cache -> get ( $ key ) ) { continue ; } $ db = Yii :: createObject ( $ config ) ; try { $ db -> open ( ) ; return $ db ; } catch ( \ Exception $ e ) { Yii :: warning ( "Connection ({$config['dsn']}) failed: " . $ e -> getMessage ( ) , __METHOD__ ) ; if ( $ cache instanceof CacheInterface ) { $ cache -> set ( $ key , 1 , $ this -> serverRetryInterval ) ; } } } return null ; }
5403	protected function fixPath ( $ path ) { if ( substr ( $ path , 0 , 1 ) != '/' ) { $ path = '/' . $ path ; } if ( substr ( $ path , - 1 , 1 ) != '/' ) { $ path .= '/' ; } return $ path ; }
2729	public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; foreach ( $ pixelRatiosArray as $ pr ) { $ ratio = 'dpr=' . $ pr . ' ' . $ pr . 'x' ; $ srcSet [ ] = $ imageUrl . $ glue . $ ratio ; } $ subject -> setData ( 'custom_attributes' , 'srcset="' . implode ( ',' , $ srcSet ) . '"' ) ; }
4550	public function setAssigneeLike ( ? string $ assigneeLike ) { $ this -> assigneeLike = $ assigneeLike ; $ this -> _assigneeLike = null !== $ assigneeLike ; return $ this ; }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
12658	private function getFileName ( $ language ) { if ( $ language === $ this -> baseLang ) { return $ this -> baseDir . $ this -> pageName . '.js' ; } else { return $ this -> baseDir . $ language . '/' . $ this -> pageName . '.js' ; } }
3657	private function tryDispatch ( $ eventName , MetaModelsBootEvent $ event ) { $ dispatcher = System :: getContainer ( ) -> get ( 'event_dispatcher' ) ; if ( $ dispatcher -> hasListeners ( $ eventName ) ) { @ trigger_error ( 'Event "' . $ eventName . '" has been deprecated - Use registered services.' , E_USER_DEPRECATED ) ; $ dispatcher -> dispatch ( $ eventName , $ event ) ; } }
12833	private function generateConfigCreatorMethod ( ConfigService $ config ) { $ configClass = Util :: normalizeFqcn ( $ config -> getClass ( ) ) ; $ configData = var_export ( $ config -> getData ( ) , true ) ; return <<<PHP public function getAppConfig() : {$configClass} { if (isset(\$this->singletons['{$config->getId()}}'])) { return \$this->singletons['{$config->getId()}']; } \$data = {$configData}; return \$this->singletons['{$config->getId()}'] = new {$configClass}(\$data); }PHP ; }
1548	private function registerProcesses ( ) : void { $ this -> routeForProcess ( 'get' , $ this -> baseProcessUrl ( ) , $ this -> actionForRoute ( 'processes' ) ) ; $ this -> routeForProcess ( 'get' , $ this -> processUrl ( ) , $ this -> actionForRoute ( 'process' ) ) ; }
9222	public function serialize ( ) { $ this -> requestAllPages ( ) ; return serialize ( array ( 'page' => $ this -> page , 'key' => $ this -> key , 'data' => $ this -> data ) ) ; }
7394	public function replace ( $ in ) : void { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { return ; } foreach ( $ in as $ k => $ v ) { if ( $ this -> _keyExists ( $ k ) ) { if ( $ this -> { $ k } instanceof TypedAbstract ) { $ this -> { $ k } -> replace ( $ v ) ; } else { $ this -> _setByName ( $ k , $ v ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
593	public function combineCssFiles ( $ inputFiles , $ outputFile ) { $ content = '' ; $ outputFilePath = dirname ( $ this -> findRealPath ( $ outputFile ) ) ; foreach ( $ inputFiles as $ file ) { $ content .= "/*** BEGIN FILE: $file ***/\n" . $ this -> adjustCssUrl ( file_get_contents ( $ file ) , dirname ( $ this -> findRealPath ( $ file ) ) , $ outputFilePath ) . "/*** END FILE: $file ***/\n" ; } if ( ! file_put_contents ( $ outputFile , $ content ) ) { throw new Exception ( "Unable to write output CSS file '{$outputFile}'." ) ; } }
12296	public function filter ( FilterRequest $ filters ) { $ search = new Search ( $ this -> model , $ filters ) ; $ this -> builder = $ search -> getBuilder ( ) ; return $ this ; }
215	public function resolve ( ) { $ rawParams = $ this -> getParams ( ) ; $ endOfOptionsFound = false ; if ( isset ( $ rawParams [ 0 ] ) ) { $ route = array_shift ( $ rawParams ) ; if ( $ route === '--' ) { $ endOfOptionsFound = true ; $ route = array_shift ( $ rawParams ) ; } } else { $ route = '' ; } $ params = [ ] ; $ prevOption = null ; foreach ( $ rawParams as $ param ) { if ( $ endOfOptionsFound ) { $ params [ ] = $ param ; } elseif ( $ param === '--' ) { $ endOfOptionsFound = true ; } elseif ( preg_match ( '/^--([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( substr ( $ name , 0 , 1 ) ) ) { throw new Exception ( 'Parameter "' . $ name . '" is not valid' ) ; } if ( $ name !== Application :: OPTION_APPCONFIG ) { $ params [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ $ name ] ; } } elseif ( preg_match ( '/^-([\w-]+)(?:=(.*))?$/' , $ param , $ matches ) ) { $ name = $ matches [ 1 ] ; if ( is_numeric ( $ name ) ) { $ params [ ] = $ param ; } else { $ params [ '_aliases' ] [ $ name ] = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : true ; $ prevOption = & $ params [ '_aliases' ] [ $ name ] ; } } elseif ( $ prevOption === true ) { $ prevOption = $ param ; } else { $ params [ ] = $ param ; } } return [ $ route , $ params ] ; }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
8915	public function encode ( $ value , $ b = 62 ) { $ r = ( int ) $ value % $ b ; $ result = $ this -> base [ $ r ] ; $ q = floor ( ( int ) $ value / $ b ) ; while ( $ q ) { $ r = $ q % $ b ; $ q = floor ( $ q / $ b ) ; $ result = $ this -> base [ $ r ] . $ result ; } return $ result ; }
12829	public function setConfig ( $ name , $ value ) { if ( is_null ( $ name ) ) { $ this -> _config = new ArrayStorage ( $ value ) ; } else { $ this -> _config -> setDeepValue ( $ name , $ value ) ; } return $ this ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
10800	public function renderPageHistoricTableAction ( ) { $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ melisKey = $ this -> params ( ) -> fromRoute ( 'melisKey' , '' ) ; $ melisTool = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreTool' ) ; $ melisTool -> setMelisToolKey ( self :: PLUGIN_INDEX , self :: TOOL_KEY ) ; $ columns = $ melisTool -> getColumns ( ) ; $ idPage = $ this -> params ( ) -> fromRoute ( 'idPage' , $ this -> params ( ) -> fromQuery ( 'idPage' , '' ) ) ; $ container = new Container ( 'meliscore' ) ; $ locale = $ container [ 'melis-lang-locale' ] ; $ view = new ViewModel ( ) ; $ view -> melisKey = $ melisKey ; $ view -> tableColumns = $ columns ; $ view -> getToolDataTableConfig = $ melisTool -> getDataTableConfiguration ( '#tableHistoricPageId' . $ idPage , true ) ; $ view -> idPage = $ idPage ; $ view -> tableId = 'tableHistoricPageId' . $ idPage ; return $ view ; }
11749	public function material ( ) { if ( is_null ( $ this -> material ) ) { $ this -> material = new Material ( $ this -> accessToken ) ; } return $ this -> material ; }
9444	public function getName ( ) { static $ names = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ names [ $ me ] ) ) { $ names [ $ me ] = $ this -> getReflector ( ) -> getShortName ( ) ; $ suffix = defined ( 'static::PACK_SUFFIX' ) ? static :: PACK_SUFFIX : 'Pack' ; if ( strrpos ( $ names [ $ me ] , $ suffix ) == ( strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ) { $ names [ $ me ] = substr ( $ names [ $ me ] , 0 , strlen ( $ names [ $ me ] ) - strlen ( $ suffix ) ) ; } } return $ names [ $ me ] ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
8319	public function matches ( $ regexp , $ message ) { if ( ! is_string ( $ regexp ) || ! is_string ( $ message ) ) { throw new \ InvalidArgumentException ( "Both arguments must be string." ) ; } $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ regexp , $ message ) { if ( ! preg_match ( $ regexp , $ str ) ) { return $ message ; } else { return true ; } } ) ; return $ this ; }
12543	public function getLink ( ) : string { if ( $ this -> link === null ) { return str_replace ( "?" . $ _SERVER [ "QUERY_STRING" ] , "" , $ _SERVER [ "REQUEST_URI" ] ) ; } else { return $ this -> link ; } }
11122	public function getEndLocation ( ) { $ lastLocation = $ this -> getLocation ( ) ; $ lastDate = NOW ; foreach ( $ this -> movements as $ v ) { if ( $ v -> getEndTime ( ) > $ lastDate ) { $ lastDate = $ v -> getEndTime ( ) ; $ lastLocation = $ v -> getEndLocation ( ) ; } } return $ lastLocation ; }
776	private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; }
2974	public function analyze ( \ Closure $ closure ) { $ data = [ 'reflection' => new \ ReflectionFunction ( $ closure ) , 'code' => null , 'hasThis' => false , 'context' => [ ] , 'hasRefs' => false , 'binding' => null , 'scope' => null , 'isStatic' => $ this -> isClosureStatic ( $ closure ) , ] ; $ this -> determineCode ( $ data ) ; $ this -> determineContext ( $ data ) ; $ this -> determineBinding ( $ data ) ; return $ data ; }
2495	protected function addEndpointsSection ( ArrayNodeDefinition $ node ) { $ node -> children ( ) -> arrayNode ( 'endpoints' ) -> info ( 'Solr Search Engine endpoint configuration' ) -> useAttributeAsKey ( 'endpoint_name' ) -> performNoDeepMerging ( ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'dsn' ) -> defaultNull ( ) -> end ( ) -> scalarNode ( 'scheme' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'scheme' ] ) -> end ( ) -> scalarNode ( 'host' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'host' ] ) -> end ( ) -> scalarNode ( 'port' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'port' ] ) -> end ( ) -> scalarNode ( 'user' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'user' ] ) -> end ( ) -> scalarNode ( 'pass' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'pass' ] ) -> end ( ) -> scalarNode ( 'path' ) -> defaultValue ( $ this -> defaultEndpointValues [ 'path' ] ) -> end ( ) -> scalarNode ( 'core' ) -> isRequired ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) -> end ( ) ; }
8063	protected function reaper ( $ pid = - 1 ) { if ( ! is_int ( $ pid ) ) { $ pid = - 1 ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; while ( $ childpid > 0 ) { $ stopSignal = pcntl_wstopsig ( $ status ) ; if ( pcntl_wifexited ( $ stopSignal ) === FALSE ) { array_push ( $ this -> results , array ( 'pid' => $ childpid , 'abnormalChildReturnCode' => $ stopSignal ) ) ; } $ processDetails = $ this -> workerProcesses -> getProcessDetails ( $ childpid ) ; if ( $ processDetails !== NULL ) { $ this -> workerPoolSize -- ; $ this -> workerProcesses -> remove ( $ processDetails ) ; unset ( $ processDetails ) ; } $ childpid = pcntl_waitpid ( $ pid , $ status , WNOHANG ) ; } }
1649	public function getLats ( ) : array { $ lats = [ ] ; foreach ( $ this -> points as $ point ) { $ lats [ ] = $ point -> getLat ( ) ; } return $ lats ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
8551	public function setPerformanceBondRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PerformanceBondRefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
4298	public function count ( $ label = null , $ flags = 0 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; if ( \ count ( $ args ) == 1 && \ is_int ( $ args [ 0 ] ) ) { $ label = null ; $ flags = $ args [ 0 ] ; } else { $ args = \ array_combine ( array ( 'label' , 'flags' ) , \ array_replace ( array ( null , 0 ) , $ args ) ) ; \ extract ( $ args ) ; } if ( isset ( $ label ) ) { $ dataLabel = ( string ) $ label ; } else { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ meta = \ array_merge ( array ( 'file' => $ callerInfo [ 'file' ] , 'line' => $ callerInfo [ 'line' ] , ) , $ meta ) ; $ label = 'count' ; $ dataLabel = $ meta [ 'file' ] . ': ' . $ meta [ 'line' ] ; } if ( ! isset ( $ this -> data [ 'counts' ] [ $ dataLabel ] ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] = 0 ; } if ( ! ( $ flags & self :: COUNT_NO_INC ) ) { $ this -> data [ 'counts' ] [ $ dataLabel ] ++ ; } $ count = $ this -> data [ 'counts' ] [ $ dataLabel ] ; if ( ! ( $ flags & self :: COUNT_NO_OUT ) ) { $ this -> appendLog ( 'count' , array ( ( string ) $ label , $ count , ) , $ meta ) ; } return $ count ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
10539	protected function _setMany ( $ data ) { $ data = $ this -> _normalizeIterable ( $ data ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSetMany ( $ store , $ data ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
5804	public function check ( $ value ) { foreach ( $ this -> _definitions as $ definition ) if ( $ definition -> match ( $ value ) ) return true ; return false ; }
8705	public function extend ( EloquentBuilder $ builder ) { $ builder -> macro ( 'onlyTranslated' , function ( EloquentBuilder $ builder , $ locale = null ) { $ builder -> getModel ( ) -> setOnlyTranslated ( true ) ; if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withUntranslated' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setOnlyTranslated ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'withFallback' , function ( EloquentBuilder $ builder , $ fallbackLocale = null ) { $ builder -> getModel ( ) -> setWithFallback ( true ) ; if ( $ fallbackLocale ) { $ builder -> getModel ( ) -> setFallbackLocale ( $ fallbackLocale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutFallback' , function ( EloquentBuilder $ builder ) { $ builder -> getModel ( ) -> setWithFallback ( false ) ; return $ builder ; } ) ; $ builder -> macro ( 'translateInto' , function ( EloquentBuilder $ builder , $ locale ) { if ( $ locale ) { $ builder -> getModel ( ) -> setLocale ( $ locale ) ; } return $ builder ; } ) ; $ builder -> macro ( 'withoutTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) ; return $ builder ; } ) ; $ builder -> macro ( 'withAllTranslations' , function ( EloquentBuilder $ builder ) { $ builder -> withoutGlobalScope ( static :: class ) -> with ( 'translations' ) ; return $ builder ; } ) ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
10583	public static function dumpResponse ( ResponseInterface $ response ) { $ statusLine = sprintf ( "HTTP/%s %d %s" , $ response -> getProtocolVersion ( ) , $ response -> getStatusCode ( ) , $ response -> getReasonPhrase ( ) ) ; header ( $ statusLine , true , $ response -> getStatusCode ( ) ) ; foreach ( $ response -> getHeaders ( ) as $ name => $ values ) { foreach ( $ values as $ value ) { header ( sprintf ( '%s: %s' , $ name , $ value ) , false ) ; } } $ body = $ response -> getBody ( ) ; while ( ! $ body -> eof ( ) ) { echo $ body -> read ( 1024 ) ; } }
9693	public function getToken ( $ pId = 0 ) { if ( isset ( $ this -> tokens [ $ pId ] ) ) { return $ this -> tokens [ $ pId ] ; } throw new Exception ( "Token with id $pId does not exist." ) ; }
7259	protected function getRealGrossBase ( Model \ SaleInterface $ sale ) : float { $ cache = $ this -> cache ; $ this -> cache = false ; $ base = $ this -> calculateSaleItems ( $ sale ) -> getBase ( ) ; $ this -> cache = $ cache ; return $ base ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
12039	public function sendHeaders ( ) { if ( count ( $ this -> _headersRaw ) || count ( $ this -> _headers ) || ( 200 !== $ this -> _httpResponseCode ) ) { $ this -> canSendHeaders ( true ) ; } elseif ( 200 === $ this -> _httpResponseCode ) { return $ this ; } $ httpCodeSent = false ; foreach ( $ this -> _headersRaw as $ header ) { if ( ! $ httpCodeSent && $ this -> _httpResponseCode ) { header ( $ header , true , $ this -> _httpResponseCode ) ; $ httpCodeSent = true ; } else { header ( $ header ) ; } } foreach ( $ this -> _headers as $ header ) { header ( "{$header['name']}: {$header['value']}" , $ header [ 'replace' ] ) ; } if ( ! $ httpCodeSent ) { $ message = array_key_exists ( $ this -> _httpResponseCode , self :: $ _messages ) ? self :: $ _messages [ $ this -> _httpResponseCode ] : 'No Reason Phrase' ; header ( "HTTP/1.1 {$this->_httpResponseCode} {$message}" , true ) ; $ httpCodeSent = true ; } return $ this ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
8204	protected function reserveJob ( $ tube ) { try { return $ this -> getPheanstalk ( ) -> reserveFromTube ( $ tube , 0 ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
12116	public static function getShortName ( $ fqn ) { $ fqn_parts = explode ( '\\' , $ fqn ) ; $ final = array_pop ( $ fqn_parts ) ; if ( empty ( $ fqn_parts ) ) { return $ final ; } $ fqn_caps = preg_replace ( '/[a-z]+/' , '' , $ fqn_parts ) ; return implode ( '\\' , $ fqn_caps ) . '\\' . $ final ; }
12978	protected function detectMetadataDriver ( $ dir , $ configPath ) { foreach ( ( array ) $ configPath as $ cPath ) { $ path = $ dir . DS . $ cPath . DS ; if ( ( $ files = glob ( $ path . '*.dcm.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.xml' ) ) && count ( $ files ) ) { return 'simplified_xml' ; } elseif ( ( $ files = glob ( $ path . '*.dcm.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ path . '*.orm.yml' ) ) && count ( $ files ) ) { return 'simplified_yml' ; } elseif ( ( $ files = glob ( $ path . '*.php' ) ) && count ( $ files ) ) { return 'php' ; } } if ( is_dir ( $ dir . DS . $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ) ) { return 'annotation' ; } return false ; }
7675	function TbsStoreGet ( $ idx , $ caller ) { $ this -> LastReadNotStored = false ; if ( $ idx === $ this -> TbsCurrIdx ) { return $ this -> TBS -> Source ; } elseif ( isset ( $ this -> TbsStoreLst [ $ idx ] ) ) { $ txt = $ this -> TbsStoreLst [ $ idx ] [ 'src' ] ; if ( $ caller === false ) $ this -> TbsStoreLst [ $ idx ] [ 'src' ] = '' ; return $ txt ; } else { $ this -> LastReadNotStored = true ; $ txt = $ this -> FileRead ( $ idx , true ) ; if ( $ this -> LastReadComp > 0 ) { if ( $ caller === false ) { return $ txt ; } else { return $ this -> RaiseError ( "(" . $ caller . ") unable to uncompress '" . $ this -> TbsGetFileName ( $ idx ) . "'." ) ; } } else { return $ txt ; } } }
8791	public function meta ( $ name , $ content , array $ attributes = [ ] ) { $ defaults = compact ( 'name' , 'content' ) ; $ attributes = array_merge ( $ defaults , $ attributes ) ; return $ this -> toHtmlString ( '<meta' . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL ) ; }
545	protected function rotateFiles ( ) { $ file = $ this -> logFile ; for ( $ i = $ this -> maxLogFiles ; $ i >= 0 ; -- $ i ) { $ rotateFile = $ file . ( $ i === 0 ? '' : '.' . $ i ) ; if ( is_file ( $ rotateFile ) ) { if ( $ i === $ this -> maxLogFiles ) { @ unlink ( $ rotateFile ) ; continue ; } $ newFile = $ this -> logFile . '.' . ( $ i + 1 ) ; $ this -> rotateByCopy ? $ this -> rotateByCopy ( $ rotateFile , $ newFile ) : $ this -> rotateByRename ( $ rotateFile , $ newFile ) ; if ( $ i === 0 ) { $ this -> clearLogFile ( $ rotateFile ) ; } } } }
5184	private function lookUp ( array $ articleConstant ) : array { $ copyListAttributes = $ this -> listAttributes ; return array_map ( function ( $ singleConst ) use ( $ copyListAttributes ) { $ res = $ copyListAttributes [ $ singleConst ] ; return array_map ( function ( $ str ) use ( $ singleConst ) { return $ singleConst . $ str ; } , $ res ) ; } , $ articleConstant ) ; }
11977	public function getInterfaceObject ( ) { if ( is_null ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = DataInterface :: find ( ) -> where ( [ 'system_id' => $ this -> object -> systemId ] ) -> one ( ) ; if ( empty ( $ this -> _interfaceObject ) ) { $ this -> _interfaceObject = new DataInterface ( ) ; $ this -> _interfaceObject -> name = $ this -> object -> name ; $ this -> _interfaceObject -> system_id = $ this -> object -> systemId ; if ( ! $ this -> _interfaceObject -> save ( ) ) { var_dump ( $ this -> _interfaceObject -> errors ) ; throw new Exception ( "Unable to save interface object!" ) ; } } } return $ this -> _interfaceObject ; }
1912	public function pickerAction ( Request $ request ) : RedirectResponse { $ extras = [ ] ; if ( $ request -> query -> has ( 'extras' ) ) { $ extras = $ request -> query -> get ( 'extras' ) ; if ( ! \ is_array ( $ extras ) ) { throw new BadRequestHttpException ( 'Invalid picker extras' ) ; } } $ config = new PickerConfig ( $ request -> query -> get ( 'context' ) , $ extras , $ request -> query -> get ( 'value' ) ) ; $ picker = $ this -> get ( 'contao.picker.builder' ) -> create ( $ config ) ; if ( null === $ picker ) { throw new BadRequestHttpException ( 'Unsupported picker context' ) ; } return new RedirectResponse ( $ picker -> getCurrentUrl ( ) ) ; }
11751	public function stats ( ) { if ( is_null ( $ this -> stats ) ) { $ this -> stats = new Stats ( $ this -> accessToken ) ; } return $ this -> stats ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
5012	public function injectLogger ( bool $ flag = null ) : bool { if ( null === $ flag ) { return $ this -> injectLogger ; } $ this -> injectLogger = $ flag ; return $ flag ; }
6874	private function findOrCreateItem ( ShipmentInterface $ shipment , SaleItemInterface $ saleItem , $ expected , $ available = null ) { $ item = null ; if ( 0 >= $ expected ) { return $ item ; } foreach ( $ shipment -> getItems ( ) as $ i ) { if ( $ i -> getSaleItem ( ) === $ saleItem ) { $ item = $ i ; break ; } } if ( null === $ item ) { $ item = $ this -> factory -> createItemForShipment ( $ shipment ) ; $ item -> setShipment ( $ shipment ) ; $ item -> setSaleItem ( $ saleItem ) ; } $ item -> setExpected ( $ expected ) ; if ( $ shipment -> isReturn ( ) ) { $ item -> setAvailable ( $ expected ) ; } else { if ( null === $ available ) { $ available = $ this -> calculator -> calculateAvailableQuantity ( $ saleItem , $ shipment ) ; } $ item -> setAvailable ( $ available ) ; if ( null === $ shipment -> getId ( ) ) { $ item -> setQuantity ( min ( $ expected , $ available ) ) ; } } return $ item ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
5167	protected function filterDateInstance ( $ date ) : string { if ( empty ( $ date ) ) { $ date = new \ DateTime ( 'now' , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } if ( is_string ( $ date ) || is_int ( $ date ) ) { $ date = new \ DateTime ( $ date , new \ DateTimeZone ( 'Asia/Jakarta' ) ) ; } return $ this -> formatDate ( $ date ) ; }
4073	public function getUser ( ) { static $ authenticated ; if ( ! isset ( $ authenticated ) ) { $ authenticated = true ; $ this -> authenticateUser ( ) ; } return $ this -> user ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
8338	public function returning ( $ returning ) { if ( is_array ( $ returning ) === true ) { $ this -> returning = implode ( ', ' , $ returning ) ; } else { $ this -> returning = $ returning ; } return $ this ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
9698	public function html ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; unset ( $ this -> params [ 'plaintext' ] ) ; return $ this -> generate ( ) ; }
9270	public function load ( ContainerBuilder $ container ) { $ loader = $ this -> getContainerLoader ( $ container ) ; $ loader -> load ( $ this -> configFile ) ; }
12775	protected function read ( $ namespace ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { return [ ] ; } return $ this -> adapter -> onRead ( $ this -> fileSystem -> read ( $ file ) ) ; }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
5208	public function p ( ) { $ args = func_get_args ( ) ; $ node = $ args [ 0 ] ; if ( null === $ node ) { return ; } $ this -> logger -> trace ( 'p' . $ node -> getType ( ) , $ node , $ this -> getMetadata ( ) -> getFullQualifiedNameClass ( ) ) ; $ class = $ this -> getClass ( 'p' . $ node -> getType ( ) ) ; return call_user_func_array ( array ( $ class , "convert" ) , $ args ) ; }
12326	public function uploadImage ( $ path , $ type = 'icon' ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) { throw new InvalidArgumentException ( "File does not exist, or the file is unreadable: '$path'" ) ; } $ type = strtolower ( $ type ) ; return $ this -> parseJSON ( 'upload' , [ self :: API_MATERIAL_ADD , [ 'media' => $ path ] , [ ] , [ 'type' => $ type ] ] ) ; }
11639	public function getColumnSettings ( ) { if ( is_null ( $ this -> _columnSettings ) ) { $ this -> _columnSettings = [ ] ; foreach ( $ this -> columns as $ key => $ c ) { if ( ! $ c -> visible ) { continue ; } $ this -> _columnSettings [ $ key ] = [ 'label' => $ c -> getDataLabel ( ) ] ; if ( ! isset ( $ c -> htmlOptions ) ) { $ c -> htmlOptions = [ ] ; } $ this -> _columnSettings [ $ key ] [ 'htmlOptions' ] = $ c -> htmlOptions ; $ sortableResolve = $ this -> dataProvider -> sort -> resolveAttribute ( $ c -> name ) ; $ this -> _columnSettings [ $ key ] [ 'sortable' ] = ! empty ( $ sortableResolve ) ; } } return $ this -> _columnSettings ; }
999	public function getType ( $ name ) { if ( ! isset ( $ this -> resolvedTypes [ $ name ] ) ) { $ type = $ this -> loadType ( $ name ) ; if ( ! $ type ) { return null ; } $ this -> resolvedTypes [ $ name ] = $ type ; } return $ this -> resolvedTypes [ $ name ] ; }
3934	private function setExcluded ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'exclude' ] ) ) { return ; } $ property -> setExcluded ( ( bool ) $ propInfo [ 'exclude' ] ) ; }
5693	public function Form ( ) { $ formAction = $ this -> getFormActionFromRequest ( $ this -> request ) ; $ fields = $ formAction -> getFields ( ) ; $ fields -> push ( HiddenField :: create ( 'action' , '' , $ formAction -> getButtonName ( ) ) ) ; $ form = Form :: create ( $ this , 'Form' , $ fields , FieldList :: create ( FormAction :: create ( 'nestedFormSave' , 'Save' ) ) ) ; return $ form ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
11172	public static function encrypt ( $ data , $ key , $ cipher = MCRYPT_RIJNDAEL_128 , $ mode = MCRYPT_MODE_CBC ) { $ data = serialize ( $ data ) ; $ key = hash ( 'sha256' , $ key , true ) ; $ iv_size = mcrypt_get_iv_size ( $ cipher , $ mode ) ; $ iv = mcrypt_create_iv ( $ iv_size , MCRYPT_RAND ) ; return base64_encode ( serialize ( array ( $ iv , mcrypt_encrypt ( $ cipher , $ key , $ data , $ mode , $ iv ) ) ) ) ; }
5297	protected function getOptionsFromXML ( ) { $ options = array ( ) ; foreach ( array ( 'id' , 'horiz-adv-x' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ $ key ] ; } } foreach ( array ( 'units-per-em' , 'ascent' , 'descent' , 'x-height' , 'cap-height' ) as $ key ) { if ( isset ( $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ) ) { $ options [ $ key ] = ( string ) $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ $ key ] ; } } return $ options ; }
2563	protected function loadBusinessId ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAnyNotEmpty ( $ params -> businessCategory , $ params -> businessForeignKey ) ) { $ this -> porFndQryParams -> businessId = new BusinessId ( $ params -> businessCategory , $ params -> businessForeignKey ) ; } }
775	public function resetSequence ( $ tableName , $ value = null ) { $ table = $ this -> db -> getTableSchema ( $ tableName ) ; if ( $ table !== null && $ table -> sequenceName !== null ) { $ tableName = $ this -> db -> quoteTableName ( $ tableName ) ; if ( $ value === null ) { $ key = reset ( $ table -> primaryKey ) ; $ value = $ this -> db -> createCommand ( "SELECT MAX(`$key`) FROM $tableName" ) -> queryScalar ( ) + 1 ; } else { $ value = ( int ) $ value ; } return "ALTER TABLE $tableName AUTO_INCREMENT=$value" ; } elseif ( $ table === null ) { throw new InvalidArgumentException ( "Table not found: $tableName" ) ; } throw new InvalidArgumentException ( "There is no sequence associated with table '$tableName'." ) ; }
2431	public function checkCategory ( $ varValue ) { if ( \ strlen ( $ varValue ) || Contao \ Input :: post ( 'FORM_SUBMIT' ) == 'tl_style' ) { return $ varValue ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ key = 'tl_style_' . CURRENT_ID ; $ filter = $ objSessionBag -> get ( 'filter' ) ; if ( \ strlen ( $ filter [ $ key ] [ 'category' ] ) ) { return $ filter [ $ key ] [ 'category' ] ; } return '' ; }
10395	protected function getShopIds ( ) { $ shopIds = [ ] ; try { $ shops = $ this -> container -> getParameter ( 'ongr_connections.shops' ) ; } catch ( InvalidArgumentException $ e ) { $ shops = [ ] ; } foreach ( $ shops as $ shop ) { $ shopIds [ ] = $ shop [ 'shop_id' ] ; } return $ shopIds ; }
8508	public function getPrepInstructionsForASIN ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetPrepInstructionsForASINRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPrepInstructionsForASIN' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetPrepInstructionsForASINResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10117	private function writeVcenter ( ) { $ record = 0x0084 ; $ length = 0x0002 ; $ fVCenter = $ this -> phpSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fVCenter ) ; $ this -> append ( $ header . $ data ) ; }
2941	public static function getUnit ( $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ key = static :: buildUnitCacheKey ( $ unit ) ; if ( isset ( self :: $ unitCache [ $ key ] ) ) { return self :: $ unitCache [ $ key ] ; } foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { if ( $ unit === $ unitOfMeasure -> getName ( ) || $ unitOfMeasure -> isAliasOf ( $ unit ) ) { return self :: $ unitCache [ $ key ] = $ unitOfMeasure ; } } throw new Exception \ UnknownUnitOfMeasure ( [ ':unit' => $ unit ] ) ; }
3642	public function only ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = [ ] ; foreach ( ( array ) $ keys as $ key ) { $ values [ $ key ] = $ this -> get ( $ key , null , $ trim , $ clean ) ; } return $ values ; }
967	protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
9254	public function handle ( Request $ request , $ type = self :: MASTER_REQUEST , $ catch = true ) { if ( ! $ this -> booted ) { $ this -> boot ( ) ; } $ request -> attributes -> set ( 'app' , $ this ) ; return $ this -> kernel -> handle ( $ request , $ type , $ catch ) ; }
7294	public function inform_about_posts ( $ post_id = FALSE ) { if ( ! $ post_id ) { return $ post_id ; } if ( ! isset ( $ this -> transit_posts [ $ post_id ] ) ) { return $ post_id ; } $ transit = $ this -> transit_posts [ $ post_id ] ; if ( 'publish' != $ transit [ 'new_status' ] || 'publish' == $ transit [ 'old_status' ] ) { return $ post_id ; } $ post_data = get_post ( $ post_id ) ; $ user = get_userdata ( $ post_data -> post_author ) ; $ to = $ this -> get_members ( $ user -> data -> user_email , 'post' ) ; if ( empty ( $ to ) ) { return $ post_id ; } $ subject = get_option ( 'blogname' ) . ': ' . get_the_title ( $ post_data -> ID ) ; $ message = $ post_data -> post_content ; $ headers = array ( ) ; $ headers [ 'From' ] = get_the_author_meta ( 'display_name' , $ user -> ID ) . ' (' . get_bloginfo ( 'name' ) . ')' . ' <' . $ user -> data -> user_email . '>' ; if ( $ this -> options [ 'send_by_bcc' ] ) { $ bcc = $ to ; $ to = empty ( $ this -> options [ 'bcc_to_recipient' ] ) ? get_bloginfo ( 'admin_email' ) : $ this -> options [ 'bcc_to_recipient' ] ; $ headers [ 'Bcc' ] = $ bcc ; } $ to = apply_filters ( 'iac_post_to' , $ to , $ this -> options , $ post_id ) ; $ subject = apply_filters ( 'iac_post_subject' , $ subject , $ this -> options , $ post_id ) ; $ message = apply_filters ( 'iac_post_message' , $ message , $ this -> options , $ post_id ) ; $ headers = apply_filters ( 'iac_post_headers' , $ headers , $ this -> options , $ post_id ) ; $ attachments = apply_filters ( 'iac_post_attachments' , array ( ) , $ this -> options , $ post_id ) ; $ signature = apply_filters ( 'iac_post_signature' , '' , $ this -> options , $ post_id ) ; $ this -> options [ 'static_options' ] [ 'object' ] = array ( 'id' => $ post_id , 'type' => 'post' ) ; $ this -> send_mail ( $ to , $ subject , $ this -> append_signature ( $ message , $ signature ) , $ headers , $ attachments ) ; return $ post_id ; }
7724	public function setQuickReplies ( $ quickReplie ) { $ model = new QuickReplie ( ) ; $ type = ! empty ( $ quickReplie [ 'type' ] ) ? $ quickReplie [ 'type' ] : 'text' ; $ model -> setContentType ( $ type ) ; if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setPayload ( $ quickReplie [ 'payload' ] ) ; } if ( ! empty ( $ quickReplie [ 'title' ] ) ) { $ model -> setTitle ( $ quickReplie [ 'title' ] ) ; } if ( ! empty ( $ quickReplie [ 'image' ] ) ) { $ model -> setImageUrl ( $ quickReplie [ 'image' ] ) ; } $ this -> quickReplies [ ] = $ model ; }
9364	public function substract ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return $ this -> add ( $ z -> negative ( ) ) ; }
9158	protected function addControls ( Response & $ response , Request $ request , View $ view ) { $ matches = array ( ) ; while ( preg_match ( "/\{(\w+)=(\w+)\}/" , $ response -> getBody ( ) , $ matches ) ) { $ controlIdentifier = $ matches [ 1 ] ; $ controlName = $ matches [ 2 ] ; $ currentBody = $ response -> getBody ( ) ; if ( ! isset ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) || ! $ view -> hasControl ( $ controlIdentifier ) ) { $ response -> setBody ( str_replace ( $ matches [ 0 ] , '' , $ currentBody ) ) ; continue ; } if ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] instanceof Control ) { $ repl = $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] -> render ( $ request ) ; } else { $ control = $ view -> createControl ( $ controlIdentifier ) ; $ repl = $ control -> render ( $ request , $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) ; } $ response -> setBody ( str_replace ( $ matches [ 0 ] , $ repl , $ currentBody ) ) ; } }
7350	protected function initializePaymentSubject ( ) { $ this -> depositTotal = 0 ; $ this -> grandTotal = 0 ; $ this -> paidTotal = 0 ; $ this -> pendingTotal = 0 ; $ this -> outstandingAccepted = 0 ; $ this -> outstandingExpired = 0 ; $ this -> outstandingLimit = 0 ; $ this -> paymentState = PaymentStates :: STATE_NEW ; $ this -> payments = new ArrayCollection ( ) ; }
253	protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } }
1745	public function showFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { if ( Contao \ Input :: get ( 'popup' ) ) { return '' ; } else { return '<a href="contao/popup.php?src=' . base64_encode ( $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . ' onclick="Backend.openModalIframe({\'title\':\'' . str_replace ( "'" , "\\'" , Contao \ StringUtil :: specialchars ( $ row [ 'fileNameEncoded' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' ; } }
11105	public function join ( $ table , $ type = null ) { $ this -> join -> addJoin ( $ table , $ type ) ; return $ this ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
5850	protected function buildForm ( array $ row ) { $ record = [ 'uid' => static :: virtualRecordId , 'pid' => 0 , ] ; $ record = array_merge ( $ record , $ row ) ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ formDataGroup = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataGroup \ TcaDatabaseRecord :: class ) ; $ formDataCompiler = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ FormDataCompiler :: class , $ formDataGroup ) ; $ nodeFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Backend \ Form \ NodeFactory :: class ) ; $ formDataCompilerInput = [ 'tableName' => static :: virtualTable , 'vanillaUid' => $ record [ 'uid' ] , 'command' => 'edit' , 'returnUrl' => '' , ] ; $ this -> loadVirtualTca ( ) ; $ formData = $ formDataCompiler -> compile ( $ formDataCompilerInput ) ; $ formData [ 'renderType' ] = 'outerWrapContainer' ; $ formResult = $ nodeFactory -> create ( $ formData ) -> render ( ) ; $ html = preg_replace ( '/<h1>.*<\/h1>/' , '' , $ formResult [ 'html' ] ) ; $ startFooter = strrpos ( $ html , '<div class="help-block text-right">' ) ; $ endTag = '</div>' ; if ( $ startFooter !== false ) { $ endFooter = strpos ( $ html , $ endTag , $ startFooter ) ; $ html = substr ( $ html , 0 , $ startFooter ) . substr ( $ html , $ endFooter + strlen ( $ endTag ) ) ; } $ formResult [ 'html' ] = '' ; $ formResult [ 'doSaveFieldName' ] = 'doSave' ; $ this -> formResultCompiler -> mergeResult ( $ formResult ) ; $ formContent = ' <!-- EDITING FORM . $ html . ' <input type="hidden" name="returnUrl" value="' . htmlspecialchars ( $ this -> retUrl ) . '" /> <input type="hidden" name="closeDoc" value="0" /> <input type="hidden" name="doSave" value="0" /> <input type="hidden" name="_serialNumber" value="' . md5 ( microtime ( ) ) . '" /> <input type="hidden" name="_scrollPosition" value="" />' ; $ overriddenAjaxUrl = GeneralUtility :: quoteJSvalue ( BackendUtility :: getModuleUrl ( 'TxImageAutoresize::record_flex_container_add' ) ) ; $ formContent .= <<<HTML<script type="text/javascript"> TYPO3.settings.ajaxUrls['record_flex_container_add'] = $overriddenAjaxUrl;</script>HTML ; return $ formContent ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
9108	protected function attainThemeName ( ) { $ themeName = $ this -> getResolverObject ( 'resolver_adapter_service' ) -> getName ( ) ; return ( empty ( $ themeName ) && ! ( $ themeName === '0' ) ) ? false : $ themeName ; }
2439	public function cloneForCurrent ( string $ current ) : self { return new self ( $ this -> context , $ this -> extras , $ this -> value , $ current ) ; }
12974	protected function autoLoadMappingInfo ( ) { $ mappings = array ( ) ; foreach ( \ Package :: loaded ( ) as $ package => $ path ) { $ mappings [ ] = $ package . '::package' ; } foreach ( \ Module :: loaded ( ) as $ module => $ path ) { $ mappings [ ] = $ module . '::module' ; } $ mappings [ ] = 'app' ; $ mappings = array_fill_keys ( $ mappings , array ( 'is_component' => true ) ) ; $ this -> setMappings ( $ mappings ) ; }
8101	public function getRow ( $ arguments ) { $ sql = 'SELECT * FROM _table_ WHERE _arguments_ LIMIT 1' ; if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt -> fetch ( ) ; } }
11931	protected function generateField ( $ fieldType , $ fieldId , array $ labels ) { $ field = new FieldType ( ) ; $ field -> setType ( $ fieldType ) ; $ field -> setFieldId ( $ fieldId ) ; $ field -> setDefaultValue ( null ) ; $ field -> setSearchable ( true ) ; $ field -> setLabels ( $ labels ) ; return $ field ; }
7041	protected function setState ( PaymentSubjectInterface $ subject , $ state ) { if ( $ state !== $ subject -> getPaymentState ( ) ) { $ subject -> setPaymentState ( $ state ) ; return true ; } return false ; }
2753	protected function getRequestForPath ( $ path , array $ exclude ) { if ( ! empty ( $ exclude [ $ path ] ) ) { return NULL ; } $ request = Request :: create ( $ path ) ; $ request -> headers -> set ( 'Accept' , 'text/html' ) ; $ processed = $ this -> pathProcessor -> processInbound ( $ path , $ request ) ; if ( empty ( $ processed ) || ! empty ( $ exclude [ $ processed ] ) ) { return NULL ; } $ this -> currentPath -> setPath ( $ processed , $ request ) ; try { $ request -> attributes -> add ( $ this -> router -> matchRequest ( $ request ) ) ; return $ request ; } catch ( ParamNotConvertedException $ e ) { return NULL ; } catch ( ResourceNotFoundException $ e ) { return NULL ; } catch ( MethodNotAllowedException $ e ) { return NULL ; } catch ( AccessDeniedHttpException $ e ) { return NULL ; } }
1788	public function editArticle ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLES , $ objPage -> row ( ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
11699	public function addService ( Service $ service ) { if ( array_key_exists ( $ service -> getName ( ) , $ this -> services ) ) { throw new KeyTakenInSetException ( $ service -> getName ( ) , 'services' ) ; } $ this -> services [ $ service -> getName ( ) ] = $ service ; return $ this ; }
9470	protected function loadingGroups ( ) : void { foreach ( $ this -> groups as $ group ) { $ this -> addPattern ( $ group -> toArray ( ) ) ; } }
10130	private function writeScenProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) ) { return ; } $ record = 0x00DD ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
3546	public function create ( $ request ) { $ data = $ request -> all ( ) ; $ user = $ this -> repository -> create ( $ data ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ user ) ) ; return $ user ; }
1677	protected function getHash ( ) { @ trigger_error ( 'Using Folder::getHash() has been deprecated and will no longer work in Contao 5.0. Use Dbafs::getFolderHash() instead.' , E_USER_DEPRECATED ) ; $ arrFiles = array ( ) ; $ it = new \ RecursiveIteratorIterator ( new \ RecursiveDirectoryIterator ( $ this -> strRootDir . '/' . $ this -> strFolder , \ FilesystemIterator :: UNIX_PATHS | \ FilesystemIterator :: FOLLOW_SYMLINKS | \ FilesystemIterator :: SKIP_DOTS ) , \ RecursiveIteratorIterator :: SELF_FIRST ) ; foreach ( $ it as $ i ) { if ( strncmp ( $ i -> getFilename ( ) , '.' , 1 ) !== 0 ) { $ arrFiles [ ] = substr ( $ i -> getPathname ( ) , \ strlen ( $ this -> strRootDir . '/' . $ this -> strFolder . '/' ) ) ; } } return md5 ( implode ( '-' , $ arrFiles ) ) ; }
3523	public function id ( $ id ) { foreach ( $ this -> items as $ item ) { if ( $ item -> itemId == $ id ) return $ item ; } return null ; }
552	public function actionFlushAll ( ) { $ caches = $ this -> findCaches ( ) ; $ cachesInfo = [ ] ; if ( empty ( $ caches ) ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
6876	private function findRevenues ( $ type , \ DateTime $ from , \ DateTime $ to = null , $ detailed = false ) { if ( $ type === OrderStat :: TYPE_DAY ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of this month' ) ; $ to = ( clone $ from ) -> modify ( 'last day of this month' ) ; } $ interval = new \ DateInterval ( 'P1D' ) ; $ format = 'Y-m-d' ; } elseif ( $ type === OrderStat :: TYPE_MONTH ) { if ( null === $ to ) { $ from = ( clone $ from ) -> modify ( 'first day of january ' . $ from -> format ( 'Y' ) ) ; $ to = ( clone $ from ) -> modify ( 'last day of december ' . $ from -> format ( 'Y' ) ) ; } $ interval = new \ DateInterval ( 'P1M' ) ; $ format = 'Y-m' ; } else { throw new InvalidArgumentException ( "Unexpected order stat type." ) ; } $ result = $ this -> getRevenueQuery ( ) -> setParameters ( [ 'type' => $ type , 'from' => $ from -> format ( $ format ) , 'to' => $ to -> format ( $ format ) , ] ) -> getScalarResult ( ) ; $ data = $ this -> buildRevenueData ( $ result , $ detailed ) ; $ period = new \ DatePeriod ( $ from , $ interval , $ to ) ; $ defaults = $ detailed ? [ ] : 0 ; if ( $ detailed ) { foreach ( SaleSources :: getSources ( ) as $ source ) { $ defaults [ $ source ] = 0 ; } } foreach ( $ period as $ d ) { $ index = $ d -> format ( $ format ) ; if ( ! isset ( $ data [ $ index ] ) ) { $ data [ $ index ] = $ defaults ; } ; } ksort ( $ data ) ; return $ data ; }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
11378	public function postAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ name = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> addTextContainer ( $ name , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
5882	protected static function read_1_byte ( $ handle ) { $ c = fgetc ( $ handle ) ; if ( $ c === false ) { throw new \ RuntimeException ( 'Premature EOF in JPEG file' , 1363533326 ) ; } return ord ( $ c ) ; }
2914	public function formatStacktrace ( array $ trace , $ stripFilepath = '' , $ trimPath = '' ) { $ out = '' ; foreach ( $ trace as $ index => $ row ) { if ( $ stripFilepath && isset ( $ row [ 'file' ] ) && strpos ( $ row [ 'file' ] , $ stripFilepath ) !== false ) { continue ; } if ( $ trimPath && isset ( $ row [ 'file' ] ) ) { $ row [ 'file' ] = str_replace ( $ trimPath , '' , $ row [ 'file' ] ) ; } if ( isset ( $ row [ 'file' ] ) ) { $ out .= "[$index] {$row['file']}:{$row['line']}\n" ; } else { $ out .= "[$index] (?) {$row['class']}:{$row['function']}\n" ; } } return $ out ; }
760	public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
11719	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , 'security' => $ app [ "security" ] , "queue_manager" => $ app [ "red_kite_cms.queue_manager" ] , ) ; $ response = parent :: save ( $ options ) ; if ( $ app [ "red_kite_cms.queue_manager" ] -> hasQueue ( ) && $ response -> getContent ( ) == "Queue saved" ) { $ lastRoute = $ request -> getSession ( ) -> get ( 'last_uri' ) ; return $ app -> redirect ( $ lastRoute ) ; } return $ response ; }
3131	public function persist ( QtiRunnerServiceContext $ context ) { $ testSession = $ context -> getTestSession ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; \ common_Logger :: d ( "Persisting QTI Assessment Test Session '${sessionId}'..." ) ; $ context -> getStorage ( ) -> persist ( $ testSession ) ; if ( $ this -> isTerminated ( $ context ) ) { $ userId = \ common_session_SessionManager :: getSession ( ) -> getUser ( ) -> getIdentifier ( ) ; $ eventManager = $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) ; $ eventManager -> trigger ( new AfterAssessmentTestSessionClosedEvent ( $ testSession , $ userId ) ) ; } }
12263	public function renderCustomField ( array $ fields , $ classOrCustomField , $ documentType = 'html' , $ slug = null , $ showIfEmpty = true ) { $ customField = ( $ classOrCustomField instanceof CustomField ) ? $ classOrCustomField : $ this -> getCustomField ( $ classOrCustomField , $ slug ) ; $ slug = $ customField -> getSlug ( ) ; $ rawValue = ( isset ( $ fields [ $ slug ] ) ) ? $ fields [ $ slug ] : null ; $ customFieldType = $ this -> provider -> getCustomFieldByType ( $ customField -> getType ( ) ) ; return $ customFieldType -> render ( $ rawValue , $ customField , $ documentType ) ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
6268	public function isAcademic ( $ text ) { if ( empty ( $ text ) ) { return false ; } $ domain = $ this -> getDomain ( $ text ) ; if ( $ domain === null ) { return false ; } foreach ( $ this -> getBlacklistedTopLevelDomains ( ) as $ blacklistedDomain ) { $ name = ( string ) $ domain [ 'host' ] ; if ( preg_match ( '/' . preg_quote ( $ blacklistedDomain ) . '$/' , $ name ) ) { return false ; } } if ( in_array ( $ domain [ 'tld' ] , $ this -> getAcademicTopLevelDomains ( ) ) ) { return true ; } if ( $ this -> matchesAcademicDomain ( $ domain ) ) { return true ; } return false ; }
6125	public function setRoles ( array $ roles ) { $ this -> roles = [ ] ; foreach ( $ roles as $ item ) { $ this -> addRole ( $ item ) ; } return $ this ; }
2092	protected function initializeSession ( $ formId ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ formId ) { return ; } $ arrMessageBox = array ( 'TL_ERROR' , 'TL_CONFIRM' , 'TL_INFO' ) ; $ _SESSION [ 'FORM_DATA' ] = \ is_array ( $ _SESSION [ 'FORM_DATA' ] ) ? $ _SESSION [ 'FORM_DATA' ] : array ( ) ; foreach ( $ arrMessageBox as $ tl ) { if ( \ is_array ( $ _SESSION [ $ formId ] [ $ tl ] ) ) { $ _SESSION [ $ formId ] [ $ tl ] = array_unique ( $ _SESSION [ $ formId ] [ $ tl ] ) ; foreach ( $ _SESSION [ $ formId ] [ $ tl ] as $ message ) { $ objTemplate = new FrontendTemplate ( 'form_message' ) ; $ objTemplate -> message = $ message ; $ objTemplate -> class = strtolower ( $ tl ) ; $ this -> Template -> fields .= $ objTemplate -> parse ( ) . "\n" ; } $ _SESSION [ $ formId ] [ $ tl ] = array ( ) ; } } }
4312	public function setErrorCaller ( $ caller = null ) { if ( $ caller === null ) { $ caller = $ this -> utilities -> getCallerInfo ( 1 ) ; $ caller = array ( 'file' => $ caller [ 'file' ] , 'line' => $ caller [ 'line' ] , ) ; } if ( $ caller ) { $ caller [ 'groupDepth' ] = $ this -> getGroupDepth ( ) ; } $ this -> errorHandler -> setErrorCaller ( $ caller ) ; }
8943	public function diffUploadChangeset ( $ xml , $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/upload' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> diffResult ; }
10256	public function getState ( $ state_code = null ) { if ( ! empty ( $ state_code ) ) { $ res = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ res = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ State = new Entities \ State ; $ State -> code = $ res -> state_code ; $ State -> name = $ res -> state ; return $ State ; }
1037	private function completeObjectValue ( ObjectType $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , & $ result ) { $ isTypeOf = $ returnType -> isTypeOf ( $ result , $ this -> exeContext -> contextValue , $ info ) ; if ( $ isTypeOf !== null ) { $ promise = $ this -> getPromise ( $ isTypeOf ) ; if ( $ promise ) { return $ promise -> then ( function ( $ isTypeOfResult ) use ( $ returnType , $ fieldNodes , $ path , & $ result ) { if ( ! $ isTypeOfResult ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; } ) ; } if ( ! $ isTypeOf ) { throw $ this -> invalidReturnTypeError ( $ returnType , $ result , $ fieldNodes ) ; } } return $ this -> collectAndExecuteSubfields ( $ returnType , $ fieldNodes , $ path , $ result ) ; }
2733	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ html = $ this -> getRequest ( ) -> getParam ( 'html' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_ERROR_SNIPPET_PATH , Config :: VCL_ERROR_SNIPPET ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_' . $ key , 'type' => $ key , 'dynamic' => '0' , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ condition = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_error_page_condition' , 'statement' => 'req.http.ResponseObject == "970"' , 'type' => 'REQUEST' , 'priority' => '9' ] ; $ createCondition = $ this -> api -> createCondition ( $ clone -> number , $ condition ) ; $ response = [ 'name' => Config :: ERROR_PAGE_RESPONSE_OBJECT , 'request_condition' => $ createCondition -> name , 'content' => $ html , 'status' => "503" , 'content_type' => "text/html; charset=utf-8" , 'response' => "Service Temporarily Unavailable" ] ; $ createResponse = $ this -> api -> createResponse ( $ clone -> number , $ response ) ; if ( ! $ createResponse ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to create a RESPONSE object.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*New Error/Maintenance page has updated and activated under config version ' . $ clone -> number . '*' ) ; } $ comment = [ 'comment' => 'Magento Module updated Error Page html' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3727	private function sanitizeConnection ( $ connection ) { if ( $ connection instanceof Connection ) { return $ connection ; } if ( $ connection instanceof Database ) { @ trigger_error ( '"' . __METHOD__ . '" now accepts doctrine instances - ' . 'passing Contao database instances is deprecated.' , E_USER_DEPRECATED ) ; $ reflection = new \ ReflectionProperty ( Database :: class , 'resConnection' ) ; $ reflection -> setAccessible ( true ) ; return $ reflection -> getValue ( $ connection ) ; } if ( null === $ connection ) { @ trigger_error ( 'You should pass a doctrine database connection to "' . __METHOD__ . '".' , E_USER_DEPRECATED ) ; $ connection = System :: getContainer ( ) -> get ( 'database_connection' ) ; } if ( ! ( $ connection instanceof Connection ) ) { throw new \ RuntimeException ( 'Could not obtain doctrine connection.' ) ; } return $ connection ; }
9628	protected function validateParams ( Route $ route , array $ params , array $ requiredParams ) { $ identifier = $ this -> getRouteIdentifier ( $ route ) ; $ givenParams = array_keys ( $ params ) ; $ missingParams = array_diff ( $ requiredParams , $ givenParams ) ; if ( count ( $ missingParams ) > 0 ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validating params "%s": Required parameters "%s" are missing' , $ identifier , implode ( ', ' , $ missingParams ) ) ) ; } if ( ! $ this -> matchParams ( $ route , $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validing params for target "%s": Params don\'t fulfill their matcher\'s criteria' , $ identifier ) ) ; } }
5337	public function api ( $ name ) { switch ( $ name ) { case 'domain' : case 'domain_service' : case 'domainService' : return new Api \ Domain ( $ this ) ; case 'colocation' : case 'colocation_service' : case 'colocationService' : return new Api \ Colocation ( $ this ) ; case 'forward' : case 'forward_service' : case 'forwardService' : return new Api \ Forward ( $ this ) ; case 'vps' : case 'vps_service' : case 'vpsService' : return new Api \ Vps ( $ this ) ; case 'hosting' : case 'web_hosting' : case 'webHosting' : case 'web_hosting_service' : case 'webHostingService' : return new Api \ WebHosting ( $ this ) ; case 'haip' : case 'ha_ip' : case 'ha_ip_service' : case 'haip_service' : case 'haipService' : return new Api \ Haip ( $ this ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined api instance called: [%s]' , $ name ) ) ; } }
7482	public function changeEncoding ( $ encoding ) { $ encoding = ( string ) $ encoding ; $ this -> string = iconv ( $ this -> encoding , $ encoding , $ this -> string ) ; $ this -> encoding = $ encoding ; return $ this ; }
9846	public function createSealedRequest ( string $ method , string $ uri , string $ body , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) , [ ] ) ; }
11771	private function retryCommandOnFailure ( CommandInterface $ command , $ method ) { $ retries = 0 ; SENTINEL_RETRY : { try { $ response = $ this -> getConnectionByCommand ( $ command ) -> $ method ( $ command ) ; } catch ( CommunicationException $ exception ) { $ this -> wipeServerList ( ) ; $ exception -> getConnection ( ) -> disconnect ( ) ; if ( $ retries == $ this -> retryLimit ) { throw $ exception ; } usleep ( $ this -> retryWait * 1000 ) ; ++ $ retries ; goto SENTINEL_RETRY ; } } return $ response ; }
9208	protected function truncateTable ( $ Table ) { $ truncateSql = $ Table -> schema ( ) -> truncateSql ( $ Table -> connection ( ) ) [ 0 ] ; $ success = $ Table -> connection ( ) -> query ( $ truncateSql ) ; if ( $ success ) { $ this -> verbose ( "<success>{$Table->alias()}: Existing DB records truncated.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()}: Can not truncate existing records.</warning>" ) ; } return $ success ; }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
5848	public function populateMetadata ( \ TYPO3 \ CMS \ Core \ Resource \ FileInterface $ file , \ TYPO3 \ CMS \ Core \ Resource \ Folder $ folder ) { if ( is_array ( static :: $ metadata ) && count ( static :: $ metadata ) ) { \ Causal \ ImageAutoresize \ Utility \ FAL :: indexFile ( $ file , '' , '' , static :: $ metadata [ 'COMPUTED' ] [ 'Width' ] , static :: $ metadata [ 'COMPUTED' ] [ 'Height' ] , static :: $ metadata ) ; } }
3893	private function renderEditButton ( $ caption , $ title , UrlBuilder $ url ) { $ icon = $ this -> iconBuilder -> getBackendIconImageTag ( 'system/themes/flexible/icons/alias.svg' , $ caption , 'style="vertical-align:top"' ) ; return sprintf ( '<a href="%s" title="%s" style="padding-left:3px">%s</a>' , $ url -> getUrl ( ) , $ title , $ icon ) ; }
9651	public function duplicate ( $ doWrite = true ) { $ clonedNode = parent :: duplicate ( $ doWrite ) ; if ( $ this -> Options ( ) ) { foreach ( $ this -> Options ( ) as $ field ) { $ newField = $ field -> duplicate ( ) ; $ newField -> ParentID = $ clonedNode -> ID ; $ newField -> write ( ) ; } } return $ clonedNode ; }
8347	public function canEdit ( GroupableInterface $ post , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; if ( $ post -> getAuthor ( ) == $ user -> getUsername ( ) ) { return true ; } foreach ( $ post -> getGroups ( ) as $ group ) { if ( $ this -> decision_manager -> decide ( $ token , [ 'GROUP_ROLE_ADMIN' ] , $ group ) ) { return true ; } } return false ; }
7286	public function getInvoices ( $ filter = null ) { if ( null === $ filter ) { return $ this -> invoices ; } return $ this -> invoices -> filter ( function ( InvoiceInterface $ invoice ) use ( $ filter ) { return $ filter xor InvoiceTypes :: isCredit ( $ invoice ) ; } ) ; }
10071	public function render ( InputFilter $ inputFilter ) { $ inputFilter -> prepare ( ) ; $ props = $ inputFilter -> getAttributes ( ) ; $ treeBuilder = new TreeBuilder ( $ inputFilter ) ; $ props = array_merge ( $ props , $ treeBuilder -> getTree ( ) ) ; return $ this -> make ( 'widget-form' , $ props ) ; }
5684	public function getUrlById ( $ id ) { foreach ( $ this -> links as $ link ) { if ( $ link -> getAttribute ( 'id' ) === ( string ) $ id ) { return $ this -> getUrlFromLink ( $ link ) ; } } return false ; }
12665	public function install ( ) : ApplicationInterface { try { $ resolved_modules = ( new ModuleDependencyResolver ( $ this -> required_modules ) ) -> resolve ( ) ; $ this -> installModules ( $ resolved_modules ) ; return $ this ; } catch ( \ Throwable $ e ) { throw new ApplicationInstallationException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
9740	public function getPrintArea ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; if ( isset ( $ printAreas [ $ index - 1 ] ) ) { return $ printAreas [ $ index - 1 ] ; } throw new PhpSpreadsheetException ( 'Requested Print Area does not exist' ) ; }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
4259	public function getSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return array ( ) ; } if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } return $ this -> sorted [ $ eventName ] ; } foreach ( \ array_keys ( $ this -> subscribers ) as $ eventName ) { if ( ! isset ( $ this -> sorted [ $ eventName ] ) ) { $ this -> sortSubscribers ( $ eventName ) ; } } return \ array_filter ( $ this -> sorted ) ; }
7787	public function setAccountClass ( $ accountClass ) { if ( ! is_callable ( $ accountClass ) && ! class_exists ( $ accountClass ) ) { throw new \ InvalidArgumentException ( '$accountClass must be a valid classname or a PHP callable' ) ; } $ this -> accountClass = $ accountClass ; return $ this ; }
2910	public function runSql ( $ query , $ queryParams = array ( ) ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ statement = $ connection -> query ( $ query , $ queryParams ) ; return $ statement -> fetchAll ( PDO :: FETCH_ASSOC ) ; }
6775	protected function updateKey ( SaleInterface $ sale ) { if ( 0 == strlen ( $ sale -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ sale ) ; return true ; } return false ; }
3082	public function getEngine ( $ endpoint ) { if ( $ this -> isInitialCall == true ) { $ endpointCached = $ endpoint . '-init' ; } else { $ endpointCached = $ endpoint ; } if ( ! isset ( $ this -> engines [ $ endpointCached ] ) ) { $ endPoints = $ this -> getOption ( self :: OPTION_ENGINE_ENDPOINTS ) ; if ( ! empty ( $ endPoints [ $ endpoint ] ) ) { $ engineOptions = $ endPoints [ $ endpoint ] ; $ class = $ engineOptions [ self :: OPTION_ENGINE_CLASS ] ; $ args = $ engineOptions [ self :: OPTION_ENGINE_ARGS ] ; $ args = $ this -> alterTimeoutCallValue ( $ args ) ; $ url = isset ( $ engineOptions [ self :: OPTION_ENGINE_URL ] ) ? $ engineOptions [ self :: OPTION_ENGINE_URL ] : $ endpoint ; array_unshift ( $ args , $ endpoint ) ; try { $ this -> engines [ $ endpointCached ] = new $ class ( $ url , $ this -> getCatEngineVersion ( $ args ) , $ this -> getCatEngineClient ( $ args ) ) ; } catch ( \ Exception $ e ) { \ common_Logger :: e ( 'Fail to connect to CAT endpoint : ' . $ e -> getMessage ( ) ) ; throw new CatEngineNotFoundException ( 'CAT Engine for endpoint "' . $ endpoint . '" is misconfigured.' , $ endpoint , 0 , $ e ) ; } } } if ( empty ( $ this -> engines [ $ endpointCached ] ) ) { throw new CatEngineNotFoundException ( "CAT Engine for endpoint '${endpoint}' is not configured." , $ endpoint ) ; } return $ this -> engines [ $ endpointCached ] ; }
2185	public function onInitialize ( InitializeApplicationEvent $ event ) : void { $ this -> installAssets ( $ event ) ; $ this -> installContao ( $ event ) ; $ this -> createSymlinks ( $ event ) ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
12377	public function superadmin ( User $ account , Container $ application , Database $ database ) { $ config = $ this -> config ; $ username = $ application -> input -> getString ( "user_first_name" , "" , "post" , FALSE , array ( ) ) ; $ usernameid = $ application -> input -> getString ( "user_name_id" , "" , "post" , FALSE , array ( ) ) ; $ userpass = $ application -> input -> getString ( "user_password" , "" , "post" , FALSE , array ( ) ) ; $ userpass2 = $ application -> input -> getString ( "user_password_2" , "" , "post" , FALSE , array ( ) ) ; $ useremail = $ application -> input -> getString ( "user_email" , "" , "post" , FALSE , array ( ) ) ; if ( empty ( $ userpass ) || empty ( $ username ) || empty ( $ usernameid ) || empty ( $ useremail ) ) { throw new Exception ( t ( 'Please provide at least a Name, Username, E-mail and Password' ) ) ; return false ; } if ( $ userpass <> $ userpass2 ) { throw new Exception ( t ( 'The user passwords do not match' ) ) ; return false ; } if ( ! $ account -> store ( $ application -> input -> data ( "post" ) , true ) ) { throw new Exception ( t ( 'Could not store the admin user account' ) ) ; return false ; } $ adminAuthority = $ this -> config -> get ( "setup.site.superadmin-authority" , NULL ) ; if ( ! empty ( $ adminAuthority ) ) { $ query = "INSERT INTO ?objects_authority( authority_id, object_id ) SELECT {$database->quote((int)$adminAuthority)}, object_id FROM ?objects WHERE object_uri={$database->quote($usernameid)}" ; $ database -> exec ( $ query ) ; } $ config -> set ( "setup.session.store" , "database" ) ; $ config -> set ( "setup.database.installed" , TRUE ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
2959	public function confFlowControl ( $ mode ) { if ( $ this -> _dState !== SERIAL_DEVICE_SET ) { trigger_error ( "Unable to set flow control mode : the device is " . "either not set or opened" , E_USER_WARNING ) ; return false ; } $ linuxModes = array ( "none" => "clocal -crtscts -ixon -ixoff" , "rts/cts" => "-clocal crtscts -ixon -ixoff" , "xon/xoff" => "-clocal -crtscts ixon ixoff" ) ; $ windowsModes = array ( "none" => "xon=off octs=off rts=on" , "rts/cts" => "xon=off octs=on rts=hs" , "xon/xoff" => "xon=on octs=off rts=on" , ) ; if ( $ mode !== "none" and $ mode !== "rts/cts" and $ mode !== "xon/xoff" ) { trigger_error ( "Invalid flow control mode specified" , E_USER_ERROR ) ; return false ; } if ( $ this -> _os === "linux" ) { $ ret = $ this -> _exec ( "stty -F " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } elseif ( $ this -> _os === "osx" ) { $ ret = $ this -> _exec ( "stty -f " . $ this -> _device . " " . $ linuxModes [ $ mode ] , $ out ) ; } else { $ ret = $ this -> _exec ( "mode " . $ this -> _winDevice . " " . $ windowsModes [ $ mode ] , $ out ) ; } if ( $ ret === 0 ) { return true ; } else { trigger_error ( "Unable to set flow control : " . $ out [ 1 ] , E_USER_ERROR ) ; return false ; } }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
1273	public function isAmbiguous ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { throw new \ BadMethodCallException ( __METHOD__ . ' should not be called on Address Classification only requests.' ) ; } return isset ( $ this -> response -> AmbiguousAddressIndicator ) ; }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
12745	protected function move ( NodeConnectionInterface $ connection , $ slot ) { $ this -> pool [ ( string ) $ connection ] = $ connection ; $ this -> slots [ ( int ) $ slot ] = $ connection ; $ this -> slotmap [ ( int ) $ slot ] = $ connection ; }
10801	public function renderPageHistoricContentFiltersActionsAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPagehistoricTable' ) ; $ actions = $ melisPageHistoricTable -> getPageHistoricListOfActions ( ) -> toArray ( ) ; $ translator = $ this -> getServiceLocator ( ) -> get ( 'translator' ) ; $ options = '<option value="">' . $ translator -> translate ( 'tr_melispagehistoric_filter_action_select' ) . '</option>' ; foreach ( $ actions as $ action ) { $ options .= '<option value="' . $ action [ 'action' ] . '">' . $ action [ 'action' ] . '</option>' ; } $ view = new ViewModel ( ) ; $ view -> options = $ options ; return $ view ; }
3012	public function unfollow ( $ blogName ) { $ options = array ( 'url' => $ this -> blogUrl ( $ blogName ) ) ; return $ this -> postRequest ( 'v2/user/unfollow' , $ options , false ) ; }
5016	public function logJobStart ( ProcessJobEvent $ event ) : void { $ queue = $ event -> getQueue ( ) ; $ job = $ event -> getJob ( ) ; $ logger = $ this -> getLogger ( ) ; $ logger -> info ( sprintf ( $ this -> tmpl [ 'job' ] , $ queue -> getName ( ) , 'START' , $ this -> formatJob ( $ job ) , '' ) ) ; $ this -> injectLoggerInObject ( $ job ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
812	private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
8820	public function getClientIP ( ) { $ ip = null ; $ client = $ this -> server ( 'HTTP_CLIENT_IP' ) ; $ forward = $ this -> server ( 'HTTP_X_FORWARDED_FOR' ) ; $ remote = $ this -> server ( 'REMOTE_ADDR' ) ; if ( filter_var ( $ client , FILTER_VALIDATE_IP ) ) { $ ip = $ client ; } elseif ( filter_var ( $ forward , FILTER_VALIDATE_IP ) ) { $ ip = $ forward ; } else { $ ip = $ remote ; } return $ ip ; }
11280	public static function getErrorString ( int $ errno ) { $ errno = intval ( $ errno ) ; $ errors = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , ) ; $ errors [ 8192 ] = 'E_DEPRECATED' ; $ errors [ 16384 ] = 'E_USER_DEPRECATED' ; $ errors_desc = array ( ) ; foreach ( $ errors as $ key => $ value ) { if ( ( $ errno & $ key ) != 0 ) { $ errors_desc [ ] = $ value ; } } return implode ( '|' , $ errors_desc ) ; }
6792	public function build ( Notify $ notify ) { $ event = new NotifyEvent ( $ notify ) ; $ this -> eventDispatcher -> dispatch ( NotifyEvents :: BUILD , $ event ) ; return ! $ event -> isAbort ( ) ; }
3370	private function getClassByName ( $ className ) { if ( ! isset ( $ this -> classByNames [ $ className ] ) ) { foreach ( $ this -> metadata as $ class ) { if ( $ class -> getName ( ) === $ className ) { $ this -> classByNames [ $ className ] = $ class ; break ; } } } return $ this -> classByNames [ $ className ] ?? null ; }
10084	protected function write ( $ stream , $ text ) { $ fp = fopen ( $ stream , 'a' ) ; fwrite ( $ fp , $ text ) ; fclose ( $ fp ) ; }
11428	public function toSelect ( array & $ optgroups = [ ] , $ level = 1 , $ root = true ) { $ options = [ ] ; foreach ( $ this -> items as $ item ) { $ options [ ] = $ item -> toSelect ( ) ; } if ( $ root === true ) { $ text = $ this -> text ; } else { $ text = '|' . str_repeat ( '-' , $ level ) . ' ' . $ this -> text ; } $ optgroups [ ] = [ 'text' => $ text , 'options' => $ options , ] ; foreach ( $ this -> groups as $ group ) { $ group -> toSelect ( $ optgroups , $ level + 1 , false ) ; } }
10138	private function writePageLayoutView ( ) { $ record = 0x088B ; $ length = 0x0010 ; $ rt = 0x088B ; $ grbitFrt = 0x0000 ; $ reserved = 0x0000000000000000 ; $ wScalvePLV = $ this -> phpSheet -> getSheetView ( ) -> getZoomScale ( ) ; if ( $ this -> phpSheet -> getSheetView ( ) -> getView ( ) == SheetView :: SHEETVIEW_PAGE_LAYOUT ) { $ fPageLayoutView = 1 ; } else { $ fPageLayoutView = 0 ; } $ fRulerVisible = 0 ; $ fWhitespaceHidden = 0 ; $ grbit = $ fPageLayoutView ; $ grbit |= $ fRulerVisible << 1 ; $ grbit |= $ fWhitespaceHidden << 3 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvVVvv' , $ rt , $ grbitFrt , 0x00000000 , 0x00000000 , $ wScalvePLV , $ grbit ) ; $ this -> append ( $ header . $ data ) ; }
3275	public function delete ( string $ key ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , false ) ; } }
680	protected function validateConjunctionCondition ( $ operator , $ condition ) { if ( ! is_array ( $ condition ) || ! ArrayHelper :: isIndexed ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; return ; } foreach ( $ condition as $ part ) { $ this -> validateCondition ( $ part ) ; } }
8760	public function setLinePrefixMap ( array $ prefixMap ) { foreach ( $ prefixMap as $ status => $ prefix ) { $ this -> setLinePrefix ( $ status , $ prefix ) ; } }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
10171	function fromXML ( $ xmlElement ) { foreach ( $ xmlElement -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = $ field -> type ; } }
9149	public function markAsUnread ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; if ( ! is_null ( $ object -> read_at ) ) { $ object -> forceFill ( [ 'read_at' => null ] ) -> save ( ) ; } \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
2484	protected function getAllSearchTargets ( ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = [ ] ; $ searchTargets = $ this -> endpointResolver -> getEndpoints ( ) ; if ( ! empty ( $ searchTargets ) ) { foreach ( $ searchTargets as $ endpointName ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpointName ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
177	public static function htmlDecode ( $ data , $ valuesOnly = true ) { $ d = [ ] ; foreach ( $ data as $ key => $ value ) { if ( ! $ valuesOnly && is_string ( $ key ) ) { $ key = htmlspecialchars_decode ( $ key , ENT_QUOTES ) ; } if ( is_string ( $ value ) ) { $ d [ $ key ] = htmlspecialchars_decode ( $ value , ENT_QUOTES ) ; } elseif ( is_array ( $ value ) ) { $ d [ $ key ] = static :: htmlDecode ( $ value ) ; } else { $ d [ $ key ] = $ value ; } } return $ d ; }
11895	public function decrypt ( $ data ) { if ( ! is_string ( $ data ) || ! preg_match ( '/^[0-9A-Fa-f]*$/' , $ data ) ) { throw new \ InvalidArgumentException ( 'blowfishDecryptCBC require hex input' , 1502 ) ; } $ data = pack ( 'H*' , $ data ) ; if ( $ this -> iv === null ) { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode ) ; } else { $ return = mcrypt_decrypt ( $ this -> cipher , $ this -> key , $ data , $ this -> mode , $ this -> iv ) ; } return rtrim ( $ return , "\0" ) ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
7886	public function levels ( ) { if ( ! $ this -> levels ) { $ class = new ReflectionClass ( new LogLevel ( ) ) ; $ this -> levels = $ class -> getConstants ( ) ; } return $ this -> levels ; }
11021	private function findTasks ( ) { if ( $ this -> init ) return ; $ resolver = $ this -> app -> moduleManager ; $ modules = $ resolver -> getModules ( ) ; foreach ( $ modules as $ mod ) $ mod -> registerTasks ( $ this ) ; Hook :: execute ( "Wedeto.Application.Task.TaskRunner.findTasks" , [ 'taskrunner' => $ this ] ) ; $ this -> init = true ; }
1121	public function ancestorsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '<=' , $ this -> getLeft ( ) ) -> where ( $ this -> getRightColumnName ( ) , '>=' , $ this -> getRight ( ) ) ; }
12232	public function cloneChildrenFrom ( SimpleXMLElement $ src , $ deep = true ) { $ src = dom_import_simplexml ( $ src ) ; $ dst = dom_import_simplexml ( $ this ) ; $ doc = $ dst -> ownerDocument ; $ fragment = $ doc -> createDocumentFragment ( ) ; foreach ( $ src -> childNodes as $ child ) { $ fragment -> appendChild ( $ doc -> importNode ( $ child -> cloneNode ( $ deep ) , $ deep ) ) ; } $ dst -> appendChild ( $ fragment ) ; return $ this ; }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
5332	public static function haikunate ( array $ params = [ ] ) { $ defaults = [ "delimiter" => "-" , "tokenLength" => 4 , "tokenHex" => false , "tokenChars" => "0123456789" , ] ; $ params = array_merge ( $ defaults , $ params ) ; if ( $ params [ "tokenHex" ] == true ) { $ params [ "tokenChars" ] = "0123456789abcdef" ; } $ adjective = self :: $ ADJECTIVES [ mt_rand ( 0 , count ( self :: $ ADJECTIVES ) - 1 ) ] ; $ noun = self :: $ NOUNS [ mt_rand ( 0 , count ( self :: $ NOUNS ) - 1 ) ] ; $ token = "" ; for ( $ i = 0 ; $ i < $ params [ "tokenLength" ] ; $ i ++ ) { $ token .= $ params [ "tokenChars" ] [ mt_rand ( 0 , strlen ( $ params [ "tokenChars" ] ) - 1 ) ] ; } $ sections = [ $ adjective , $ noun , $ token ] ; return implode ( $ params [ "delimiter" ] , array_filter ( $ sections ) ) ; }
8711	public function whereOriginal ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
10033	function addUnsubscriptionReasonsToUnsubscribedContact ( $ id , $ checksum = null , $ reasons = null , $ ignore_checksum = false ) { $ queryParameters = array ( ) ; $ queryParameters [ 'id' ] = $ id ; if ( ! empty ( $ checksum ) ) { $ queryParameters [ 'checksum' ] = $ checksum ; } if ( $ ignore_checksum === true ) $ queryParameters [ 'ignore_checksum' ] = "true" ; if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } return $ this -> put ( "contacts/contact/unsubscribe/reasons" , null , $ queryParameters ) ; }
10348	public function rewind ( ) { if ( $ this -> yearOffset !== 0 ) { $ this -> generateTimetable ( 0 ) ; } else { reset ( $ this -> minutes ) ; reset ( $ this -> hours ) ; reset ( $ this -> monthAndDays ) ; } }
4894	public function end ( ) { if ( ! $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot end capture, there is no capture running.' ) ; } $ type = $ this -> captureType ; $ content = ob_get_clean ( ) ; $ options = $ this -> captureOptions ; $ this -> captureLock = false ; $ this -> captureType = null ; $ this -> captureOptions = null ; return $ this -> render ( $ type , $ content , $ options ) ; }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
8152	public function getExtension ( $ class ) { $ class = ltrim ( $ class , '\\' ) ; if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) && class_exists ( $ class , false ) ) { $ class = new ReflectionClass ( $ class ) ; $ class = $ class -> name ; } if ( isset ( $ this -> extensions [ $ class ] ) ) { if ( $ class !== get_class ( $ this -> extensions [ $ class ] ) ) { @ trigger_error ( sprintf ( 'Referencing the "%s" extension by its name (defined by getName()) is deprecated since 1.26 and will be removed in Twig 2.0. Use the Fully Qualified Extension Class Name instead.' , $ class ) , E_USER_DEPRECATED ) ; } return $ this -> extensions [ $ class ] ; } if ( ! isset ( $ this -> extensionsByClass [ $ class ] ) ) { throw new Twig_Error_Runtime ( sprintf ( 'The "%s" extension is not enabled.' , $ class ) ) ; } return $ this -> extensionsByClass [ $ class ] ; }
413	public function setPort ( $ value ) { if ( $ value != $ this -> _port ) { $ this -> _port = ( int ) $ value ; $ this -> _hostInfo = null ; } }
7874	private function checkConfig ( ) : void { if ( empty ( $ this -> userkey ) ) { Log :: warning ( 'Config "message.zenziva.userkey" is not defined.' ) ; } if ( empty ( $ this -> passkey ) ) { Log :: warning ( 'Config "message.zenziva.passkey" is not defined.' ) ; } }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
1336	protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
12842	static public function removeFiles ( $ directory ) { $ scan = glob ( rtrim ( $ directory , '/' ) . '/*' ) ; foreach ( $ scan as $ file ) { if ( is_file ( $ file ) ) { unlink ( $ file ) ; } } return true ; }
1865	public function addSenderPlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT sender FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> sender ; } return $ varValue ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
6584	public function sum ( $ n , $ m = 0 ) { if ( $ m > 0 ) return $ this -> sum ( $ n + $ m ) - $ this -> sum ( $ m ) ; static :: ensureValid ( $ n ) ; return $ this -> b * ( 1 - pow ( $ this -> q , $ n ) ) / ( 1 - $ this -> q ) ; }
8836	public function setMaxRetries ( $ retries ) { switch ( gettype ( $ retries ) ) { case 'integer' : $ this -> maxRetries = new Retries ( $ retries ) ; break ; case 'object' : $ this -> maxRetries = $ retries ; break ; default : throw new InvalidArgumentException ( 'Invalid type for max retries given.' ) ; break ; } }
7109	static public function getRoundingIncrement ( $ currency ) { if ( isset ( static :: $ increments [ $ currency ] ) ) { return static :: $ increments [ $ currency ] ; } return static :: $ increments [ $ currency ] = static :: getCurrencyBundle ( ) -> getRoundingIncrement ( $ currency ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
6563	public function carrier_data ( $ carrier = '' , $ field_output = '' ) { $ inputParams = array ( 'carrier' => $ carrier , 'field_output' => $ field_output ) ; $ field_output = strtolower ( $ field_output ) ; $ this -> debug -> info ( __FUNCTION__ , 'Input Params: ' , $ inputParams ) ; try { $ vnCarrierData = DataRepository :: getData ( 'vn_carrier_data' ) ; $ this -> debug -> debug ( __FUNCTION__ , 'VN Carrier All Data: ' , $ vnCarrierData ) ; if ( array_key_exists ( $ carrier , $ vnCarrierData ) ) { $ isCarrier = $ vnCarrierData [ $ carrier ] ; $ this -> debug -> debug ( __FUNCTION__ , 'Is Carrier Data: ' , $ isCarrier ) ; if ( array_key_exists ( $ field_output , $ isCarrier ) ) { $ result = $ isCarrier [ $ field_output ] ; $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ result ) ; return $ result ; } if ( $ field_output = 'full' ) { $ this -> debug -> info ( __FUNCTION__ , 'Final Result get Field : ' . $ field_output , $ isCarrier ) ; return $ isCarrier ; } } } catch ( \ Exception $ e ) { $ message = 'Error File: ' . $ e -> getFile ( ) . ' - Line: ' . $ e -> getLine ( ) . ' - Code: ' . $ e -> getCode ( ) . ' - Message: ' . $ e -> getMessage ( ) ; $ this -> debug -> error ( __FUNCTION__ , $ message ) ; return NULL ; } return NULL ; }
8397	public function getDefinition ( ) : array { if ( $ this -> definition == null ) { $ data = Mapping :: get ( $ this -> mapping ) ; $ this -> definition = Config :: get ( $ data [ 'config' ] [ 'schema' ] ) ; } return $ this -> definition ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
9199	public function getAccessToken ( $ oauthToken , $ oauthVerifier ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'token' => $ oauthToken , 'verifier' => $ oauthVerifier ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ accessTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_access_token' ) , array ( 'auth' => 'oauth' ) ) ; $ response = array ( ) ; parse_str ( $ accessTokenResponse -> getBody ( ) , $ response ) ; $ this -> credentials -> setAccessToken ( $ response [ 'oauth_token' ] ) -> setAccessTokenSecret ( $ response [ 'oauth_token_secret' ] ) ; return $ response ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
9723	private function getTemporaryFolder ( ) { $ tempFolder = sys_get_temp_dir ( ) . '/phpspreadsheet' ; if ( ! is_dir ( $ tempFolder ) ) { if ( ! mkdir ( $ tempFolder ) && ! is_dir ( $ tempFolder ) ) { throw new \ RuntimeException ( sprintf ( 'Directory "%s" was not created' , $ tempFolder ) ) ; } } return $ tempFolder ; }
6700	public function setPreRelease ( $ pre ) { $ this -> pre = array_values ( ( array ) $ pre ) ; array_walk ( $ this -> pre , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
7612	public function getIsSuperAdmin ( ) { if ( $ this -> _isSuperAdmin !== null ) { return $ this -> _isSuperAdmin ; } $ this -> _isSuperAdmin = in_array ( $ this -> username , Yii :: $ app -> getModule ( 'auth' ) -> superAdmins ) ; return $ this -> _isSuperAdmin ; }
6213	public function filter ( & $ array ) { $ current = & $ array ; $ keys = array_keys ( $ this -> keyParts ) ; $ lastElement = end ( $ keys ) ; foreach ( $ this -> keyParts as $ index => $ keyPart ) { if ( ! isset ( $ current [ $ keyPart ] ) ) { break ; } if ( $ index == $ lastElement ) { unset ( $ current [ $ keyPart ] ) ; break ; } $ current = & $ current [ $ keyPart ] ; } }
2631	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ read = $ this -> filesystem -> getDirectoryRead ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ read -> getRelativePath ( 'vcl_snippets_custom' ) ; $ customSnippets = $ read -> read ( $ snippetPath ) ; if ( ! $ customSnippets ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'No snippets found.' ] ) ; } $ snippets = [ ] ; foreach ( $ customSnippets as $ snippet ) { $ snippets [ ] = explode ( '/' , $ snippet ) [ 1 ] ; } return $ result -> setData ( [ 'status' => true , 'snippets' => $ snippets ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
1387	protected function resourceTypeNotSupported ( string $ actual , string $ path = '/data' ) : void { $ this -> errors -> add ( $ this -> translator -> resourceTypeNotSupported ( $ actual , $ path ) ) ; }
1608	public function bulk ( $ redirects , $ separator , $ type , $ siteId ) { $ rawRedirects = array_map ( function ( $ line ) use ( $ separator ) { return str_getcsv ( $ line , $ separator ) ; } , explode ( PHP_EOL , $ redirects ) ) ; $ newFormatted = [ ] ; foreach ( $ rawRedirects as $ redirect ) { $ record = new RedirectRecord ( ) ; $ record -> uri = $ redirect [ 0 ] ; $ record -> to = $ redirect [ 1 ] ; $ record -> type = array_key_exists ( 2 , $ redirect ) ? $ redirect [ 2 ] : $ type ; $ record -> siteId = $ siteId ; $ record -> save ( ) ; $ newFormatted [ ] = [ 'id' => $ record -> id , 'uri' => $ record -> uri , 'to' => $ record -> to , 'type' => $ record -> type , 'siteId' => $ record -> siteId , ] ; } return [ $ newFormatted , false ] ; }
1924	public function setResource ( $ gdResource ) { if ( ! \ is_resource ( $ gdResource ) || get_resource_type ( $ gdResource ) !== 'gd' ) { throw new \ InvalidArgumentException ( '$gdResource is not a valid GD resource' ) ; } $ this -> gdResource = $ gdResource ; return $ this ; }
12082	public function getMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { return $ this -> getAllMedia ( $ objectType , $ objectURI , $ objectId ) ; }
12479	private function generateOptions ( $ folder , $ rootAlias ) { $ assetsPath = $ this -> configurationHandler -> uploadAssetsDir ( ) . '/' . $ folder ; if ( ! is_dir ( $ assetsPath ) ) { @ mkdir ( $ assetsPath ) ; } $ options = array ( 'locale' => '' , 'roots' => array ( array ( 'driver' => 'LocalFileSystem' , 'path' => $ assetsPath , 'URL' => $ this -> configurationHandler -> absoluteUploadAssetsDir ( ) . '/' . $ folder , 'accessControl' => 'access' , 'rootAlias' => $ rootAlias ) ) ) ; return $ options ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
3199	protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; }
12472	public static function isEnabled ( ) { $ class = self :: className ( ) ; foreach ( \ Yii :: $ app -> modules as $ module => $ params ) { switch ( gettype ( $ params ) ) { case 'array' : if ( $ class == @ $ params [ 'class' ] ) return true ; break ; case 'object' : if ( $ class == get_class ( $ params ) ) return true ; break ; default : if ( $ class == $ params ) return true ; } if ( $ module == $ class || ( isset ( $ module [ 'class' ] ) && $ module [ 'class' ] == $ class ) ) { return true ; } } return false ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
2919	public function updateSetter ( $ key , $ value = null , $ comment = null , $ export = false ) { $ pattern = "/^(export\h)?\h*{$key}=.*/m" ; $ line = $ this -> formatter -> formatSetterLine ( $ key , $ value , $ comment , $ export ) ; $ this -> buffer = preg_replace ( $ pattern , $ line , $ this -> buffer ) ; return $ this ; }
7828	protected function getSpacesByWord ( $ word ) { $ length = $ this -> getSideBordersLength ( ) + static :: SPACE_FROM_ARROW + static :: ARROW_WIDTH ; $ extra = $ this -> getHalfWidth ( true ) - $ length - strlen ( $ word ) ; return $ extra > 0 ? str_repeat ( ' ' , $ extra ) : '' ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
9579	public function setChannel ( $ channel , LoggerInterface $ logger ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> channels [ $ channel ] = $ logger ; }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
12464	public function showAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroup entity.' ) ; } $ options = $ this -> getOptionsAvailable ( $ entity -> getEntity ( ) ) ; return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:show.html.twig' , array ( 'entity' => $ entity , 'create_field_form' => $ this -> createCreateFieldForm ( $ entity ) -> createView ( ) , 'options' => $ options ) ) ; }
11604	public function notify ( ) { declare ( ticks = 1 ) ; if ( is_array ( $ this -> _caller ) && ! empty ( $ this -> _caller ) ) { return call_user_func_array ( $ this -> _caller , [ $ this -> _interrupt ] ) ; } else if ( $ this -> _caller instanceof Closure ) { return $ this -> _caller -> call ( $ this , $ this -> _interrupt ) ; } else if ( is_callable ( $ this -> _caller ) ) { $ cl = Closure :: fromCallable ( $ this -> _caller ) ; return $ cl -> call ( $ this , $ this -> _interrupt ) ; } return null ; }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
8050	public function getCalendarEvent ( $ id ) { $ calendarEvent = null ; $ cache = $ this -> cache ; if ( $ cache :: has ( self :: CACHE_KEY . $ id ) ) { return $ cache :: get ( self :: CACHE_KEY . $ id ) ; } $ calendarEvent = $ this -> calendarEvent -> with ( [ 'calendarEventRepeatDates' ] ) -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ cache :: put ( self :: CACHE_KEY . $ id , $ calendarEvent , $ this -> cacheTimeToLive ) ; return $ calendarEvent ; }
1509	public function getResourceUrl ( string $ type , $ id , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id ] , $ params ) ; }
4943	protected function addBaseFieldset ( ) { if ( null === $ this -> baseFieldset ) { return ; } $ fs = $ this -> baseFieldset ; if ( ! is_array ( $ fs ) ) { $ fs = array ( 'type' => $ fs , ) ; } if ( ! isset ( $ fs [ 'options' ] [ 'use_as_base_fieldset' ] ) ) { $ fs [ 'options' ] [ 'use_as_base_fieldset' ] = true ; } $ this -> add ( $ fs ) ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
9985	private function mapVAlign ( $ vAlign ) { switch ( $ vAlign ) { case Alignment :: VERTICAL_BOTTOM : return 'bottom' ; case Alignment :: VERTICAL_TOP : return 'top' ; case Alignment :: VERTICAL_CENTER : case Alignment :: VERTICAL_JUSTIFY : return 'middle' ; default : return 'baseline' ; } }
8463	public static function getProtocol ( $ url = false ) { if ( $ url ) { return ( preg_match ( '/^https/' , $ url ) ) ? 'https' : 'http' ; } $ protocol = strtolower ( $ _SERVER [ 'SERVER_PROTOCOL' ] ) ; $ protocol = substr ( $ protocol , 0 , strpos ( $ protocol , '/' ) ) ; $ ssl = ( isset ( $ _SERVER [ 'HTTPS' ] ) && $ _SERVER [ 'HTTPS' ] == 'on' ) ; return ( $ ssl ) ? $ protocol . 's' : $ protocol ; }
4023	protected function buildOptions ( ) { $ options = array ( ) ; foreach ( $ this -> arrWidgets as $ widgetRow ) { $ columns = array ( ) ; foreach ( $ widgetRow as $ widget ) { $ valign = ( $ widget -> valign != '' ? ' valign="' . $ widget -> valign . '"' : '' ) ; $ class = ( $ widget -> tl_class != '' ? ' class="' . $ widget -> tl_class . '"' : '' ) ; $ style = ( $ widget -> style != '' ? ' style="' . $ widget -> style . '"' : '' ) ; $ help = $ this -> getHelpForWidget ( $ widget ) ; $ columns [ ] = sprintf ( '<td %1$s%2$s%3$s>%4$s%5$s</td>' , $ valign , $ class , $ style , $ widget -> parse ( ) , $ help ) ; } $ options [ ] = implode ( '' , $ columns ) ; } return $ options ; }
6283	protected static function buildHttpClient04 ( LoopInterface $ loop , $ dns = null ) { if ( null === $ dns ) { $ dns = static :: buildDnsResolver ( $ loop ) ; } if ( ! $ dns instanceof DnsResolver ) { throw new \ InvalidArgumentException ( 'For react http client v0.4, $dns must be an instance of DnsResolver' ) ; } $ factory = new HttpClientFactory ( ) ; return $ factory -> create ( $ loop , $ dns ) ; }
4703	protected function lint ( OutputInterface $ output , Ciconia $ ciconia , $ content ) { try { $ ciconia -> render ( $ content , array ( 'strict' => true ) ) ; $ output -> writeln ( 'No syntax errors detected.' ) ; return 0 ; } catch ( SyntaxError $ e ) { $ output -> writeln ( '<error>' . $ e -> getMessage ( ) . '</error>' ) ; return 1 ; } }
1450	protected function validatorForResource ( array $ data , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) : ValidatorInterface { return $ this -> factory -> createResourceValidator ( ResourceObject :: create ( $ data ) , $ rules , $ messages , $ customAttributes ) ; }
9587	protected function getAttribute ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return ( string ) $ attributes [ $ name ] ; }
4628	protected function prepareRequestUrl ( ) { $ protocol = $ this -> node -> useTls ( ) ? 'https' : 'http' ; $ this -> requestURL = sprintf ( '%s://%s%s?%s' , $ protocol , $ this -> node -> getUri ( ) , $ this -> path , $ this -> query ) ; $ this -> options [ CURLOPT_URL ] = $ this -> requestURL ; return $ this ; }
8814	public function post ( $ key = null , $ filter = false ) { if ( is_null ( $ key ) ) { return $ _POST ; } $ value = ( isset ( $ _POST [ $ key ] ) ? $ _POST [ $ key ] : null ) ; return $ this -> filter ( $ value , $ filter ) ; }
8475	public function debug ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'debug' , $ scope , $ message , $ context , $ config ) ; }
9132	protected function validate ( $ config , $ name , $ path ) { if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The definition of "%s" in "%s" must be a YAML array.' , $ name , $ path ) ) ; } if ( $ extraKeys = array_diff ( array_keys ( $ config ) , self :: $ availableKeys ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".' , $ path , $ name , implode ( '", "' , $ extraKeys ) , implode ( '", "' , self :: $ availableKeys ) ) ) ; } if ( isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The business rule file "%s" must not specify both the "resource" key and the "expression" key for "%s". Choose between an import and a rule definition.' , $ path , $ name ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && isset ( $ config [ 'type' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "type" key for the rule definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.' , $ name , $ path ) ) ; } if ( ! isset ( $ config [ 'resource' ] ) && ! isset ( $ config [ 'expression' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'You must define an "expression" for the rule "%s" in file "%s".' , $ name , $ path ) ) ; } if ( isset ( $ config [ 'tags' ] ) && ! is_array ( $ config [ 'tags' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } elseif ( isset ( $ config [ 'tags' ] ) ) { foreach ( $ config [ 'tags' ] as $ tag ) { if ( ! isset ( $ tag [ 'name' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "tags" key for the rule definition "%s" in "%s" contains unsupported data. Each tag defined must be an array with at least the "name" element set to a string.' , $ name , $ path ) ) ; } } } }
5588	public function setCookies ( array $ lstCookies ) { foreach ( $ lstCookies as $ aCookies ) { $ this -> cookie_jar -> setCookie ( $ aCookies [ 'name' ] , $ aCookies [ 'value' ] , $ aCookies [ 'host' ] , $ aCookies [ 'path' ] , $ aCookies [ 'expiry' ] ) ; } }
4036	private function fetchTemplatesFromResourceDirectories ( $ templateBaseName ) { $ allTemplates = [ ] ; $ themeName = $ this -> getNoThemeMessage ( ) ; foreach ( $ this -> resourceDirs as $ resourceDir ) { $ allTemplates = array_replace_recursive ( $ allTemplates , $ this -> getTemplatesForBaseFrom ( $ templateBaseName , $ resourceDir . '/templates' , $ themeName ) ) ; } return $ allTemplates ; }
8088	public function generateUserPassword ( User $ user , $ password , $ generateOld = false ) { $ registrationDate = $ user -> RegDate ; $ pre = $ this -> encode ( $ registrationDate ) ; $ pos = substr ( $ registrationDate , 5 , 1 ) ; $ post = $ this -> encode ( $ registrationDate * ( substr ( $ registrationDate , $ pos , 1 ) ) ) ; $ finalString = $ pre . $ password . $ post ; return $ generateOld ? md5 ( $ finalString ) : sha1 ( $ finalString ) ; }
9972	public function setCodeName ( $ pValue , $ validate = true ) { if ( $ this -> getCodeName ( ) == $ pValue ) { return $ this ; } if ( $ validate ) { $ pValue = str_replace ( ' ' , '_' , $ pValue ) ; self :: checkSheetCodeName ( $ pValue ) ; if ( $ this -> getParent ( ) ) { if ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue ) ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 29 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 29 ) ; } $ i = 1 ; while ( $ this -> getParent ( ) -> sheetCodeNameExists ( $ pValue . '_' . $ i ) ) { ++ $ i ; if ( $ i == 10 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 28 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 28 ) ; } } elseif ( $ i == 100 ) { if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 27 ) { $ pValue = Shared \ StringHelper :: substring ( $ pValue , 0 , 27 ) ; } } } $ pValue = $ pValue . '_' . $ i ; } } } $ this -> codeName = $ pValue ; return $ this ; }
8856	public function increase ( ) { $ this -> retries ++ ; if ( $ this -> retries > $ this -> maxRetries ) { throw new MaxRetriesExceededException ( sprintf ( 'Max allowed retries exceeded. Allowed: %s. Tried: %s.' , $ this -> maxRetries , $ this -> retries ) ) ; } return $ this ; }
6218	public function getPeriodStart ( ) { if ( is_null ( $ this -> parsedPeriodStart ) ) { $ this -> parsedPeriodStart = strtotime ( $ this -> periodStart ) ; } return $ this -> parsedPeriodStart ; }
952	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; $ charge = new Charge ( ) ; $ charge -> type = Charge :: CHARGE_USAGE ; $ charge -> reference_charge = $ planCharge -> charge_id ; $ charge -> shop_id = $ this -> shop -> id ; $ charge -> charge_id = $ this -> response -> id ; $ charge -> price = $ this -> response -> price ; $ charge -> description = $ this -> response -> description ; $ charge -> billing_on = $ this -> response -> billing_on ; return $ charge -> save ( ) ; }
3717	public static function withName ( $ columnName , $ tableName , $ code = 0 , $ previous = null ) { return new static ( sprintf ( 'Column "%s" already exists on table "%s' , $ columnName , $ tableName ) , $ code , $ previous ) ; }
563	public function renderSummary ( ) { $ count = $ this -> dataProvider -> getCount ( ) ; if ( $ count <= 0 ) { return '' ; } $ summaryOptions = $ this -> summaryOptions ; $ tag = ArrayHelper :: remove ( $ summaryOptions , 'tag' , 'div' ) ; if ( ( $ pagination = $ this -> dataProvider -> getPagination ( ) ) !== false ) { $ totalCount = $ this -> dataProvider -> getTotalCount ( ) ; $ begin = $ pagination -> getPage ( ) * $ pagination -> pageSize + 1 ; $ end = $ begin + $ count - 1 ; if ( $ begin > $ end ) { $ begin = $ end ; } $ page = $ pagination -> getPage ( ) + 1 ; $ pageCount = $ pagination -> pageCount ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Showing <b>{begin, number}-{end, number}</b> of <b>{totalCount, number}</b> {totalCount, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } else { $ begin = $ page = $ pageCount = 1 ; $ end = $ totalCount = $ count ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Total <b>{count, number}</b> {count, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } return Yii :: $ app -> getI18n ( ) -> format ( $ summaryContent , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] , Yii :: $ app -> language ) ; }
1837	public static function findOneBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ strColumn , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
2516	public function pnrCreatePnr ( RequestOptions \ PnrCreatePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_AddMultiElements' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2146	protected function generateEmailObject ( Result $ objNewsletter , $ arrAttachments ) { $ objEmail = new Email ( ) ; $ objEmail -> from = $ objNewsletter -> sender ; $ objEmail -> subject = $ objNewsletter -> subject ; if ( $ objNewsletter -> senderName != '' ) { $ objEmail -> fromName = $ objNewsletter -> senderName ; } $ objEmail -> embedImages = ! $ objNewsletter -> externalImages ; $ objEmail -> logFile = TL_NEWSLETTER . '_' . $ objNewsletter -> id ; if ( ! empty ( $ arrAttachments ) && \ is_array ( $ arrAttachments ) ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; foreach ( $ arrAttachments as $ strAttachment ) { $ objEmail -> attachFile ( $ rootDir . '/' . $ strAttachment ) ; } } return $ objEmail ; }
9390	public function getSortValBeforeAll ( $ groupingId = null ) { if ( $ groupingId === null && $ this -> grpColumn ) { throw new SortableException ( 'groupingId may be omitted only when grpColumn is not configured.' ) ; } $ query = ( new Query ( ) ) -> select ( [ $ this -> pkColumn , $ this -> srtColumn ] ) -> from ( $ this -> targetTable ) -> where ( [ 'and' , $ this -> grpColumn ? [ '=' , $ this -> grpColumn , $ groupingId ] : [ ] , $ this -> skipRowsClause ( ) ] ) -> orderBy ( [ $ this -> srtColumn => SORT_ASC ] ) -> limit ( 1 ) ; $ result = $ query -> one ( $ this -> db ) ; if ( $ result && $ result [ $ this -> srtColumn ] == 1 ) { $ this -> rebuildSortAfter ( $ result [ $ this -> pkColumn ] , true ) ; $ sortVal = $ this -> getIniSortVal ( ) ; } else if ( $ result ) { $ sortVal = ceil ( $ result [ $ this -> srtColumn ] / 2 ) ; } else $ sortVal = $ this -> getIniSortVal ( ) ; return ( int ) $ sortVal ; }
1852	protected function getNextPage ( $ rootPageId ) { $ objNextPage = PageModel :: findFirstPublishedByPid ( $ rootPageId ) ; if ( null === $ objNextPage ) { $ this -> log ( 'No active page found under root page "' . $ rootPageId . '")' , __METHOD__ , TL_ERROR ) ; throw new NoActivePageFoundException ( 'No active page found under root page.' ) ; } return $ objNextPage ; }
10703	public function loadLanguage ( $ controller , $ language = 'en_US' , $ return = FALSE ) { $ langDirEvent = new GetLanguageDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_LANG_DIR , $ langDirEvent ) ; $ langDir = $ langDirEvent -> getLangDir ( ) ; $ retVal = FALSE ; if ( NULL === $ langDir ) { $ retVal = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ language . '_lang.php' ; if ( ! file_exists ( $ file ) ) { $ defaultLangEvent = new GetDefaultLanguageEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_DEFAULT_LANG , $ defaultLangEvent ) ; $ defaultLang = $ defaultLangEvent -> getDefaultLanguage ( ) ; if ( NULL === $ defaultLang ) { $ retval = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ defaultLang . '_lang.php' ; } } if ( NULL === $ file ) { throw new RawException ( 'Failed to load language file for ' . $ controller ) ; } $ lang = include_once $ file ; $ this -> language = array_merge ( $ this -> language , $ lang ) ; $ retVal = $ lang ; } return $ retVal ; }
7560	protected function parse_gt ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_BIGGER_THAN ) ; } else { return ( $ this -> token = self :: TOK_CHILD ) ; } }
6214	protected function initialize ( ) { if ( $ this -> get ( 'serverData' ) === null ) { $ this -> set ( 'serverData' , ( array ) $ _SERVER ) ; } if ( $ this -> get ( 'getData' ) === null ) { $ this -> set ( 'getData' , ( array ) $ _GET ) ; } if ( $ this -> get ( 'postData' ) === null ) { $ this -> set ( 'postData' , ( array ) $ _POST ) ; } if ( $ this -> get ( 'sessionData' ) === null && isset ( $ _SESSION ) ) { $ this -> set ( 'sessionData' , ( array ) $ _SESSION ) ; } $ serverData = $ this -> get ( 'serverData' ) ; if ( ! $ this -> get ( 'projectRoot' ) ) { $ projectRoot = isset ( $ serverData [ '_' ] ) ? $ serverData [ '_' ] : $ serverData [ 'DOCUMENT_ROOT' ] ; $ this -> set ( 'projectRoot' , $ projectRoot ) ; } if ( ! $ this -> get ( 'url' ) ) { if ( isset ( $ serverData [ 'REDIRECT_URL' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'REDIRECT_URL' ] ) ; } elseif ( isset ( $ serverData [ 'SCRIPT_NAME' ] ) ) { $ this -> set ( 'url' , $ serverData [ 'SCRIPT_NAME' ] ) ; } } if ( ! $ this -> get ( 'hostname' ) ) { $ this -> set ( 'hostname' , isset ( $ serverData [ 'HTTP_HOST' ] ) ? $ serverData [ 'HTTP_HOST' ] : 'No Host' ) ; } $ protocol = $ this -> get ( 'secure' ) ? 'https' : 'http' ; $ endPoint = $ this -> get ( 'apiEndPoint' ) ? : $ protocol . '://' . $ this -> get ( 'host' ) . $ this -> get ( 'resource' ) ; $ this -> set ( 'apiEndPoint' , $ endPoint ) ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
5604	public function paintMethodStart ( $ method ) { $ this -> pass = false ; $ this -> fail = false ; $ this -> error = false ; $ this -> method = self :: escapeVal ( $ method ) ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
4607	public function statuses ( int $ account_id , int $ limit = 40 , int $ since_id = null ) : array { $ url = "/accounts/${account_id}/statuses" ; $ query = [ 'limit' => $ limit , 'since_id' => $ since_id , ] ; return $ this -> get ( $ url , $ query ) ; }
9044	private function isRotationNeeded ( ) { clearstatcache ( ) ; if ( ! file_exists ( $ this -> file ) ) { return false ; } $ result = false ; $ attributes = stat ( $ this -> file ) ; if ( $ attributes == false || $ attributes [ 'size' ] >= $ this -> maxLogSize * 1024 * 1024 ) { $ result = true ; } return $ result ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
12549	public function boot ( ) { $ pluginFolders = $ this -> configurationHandler -> pluginFolders ( ) ; $ this -> core = $ this -> findPlugins ( $ this -> configurationHandler -> corePluginsDir ( ) . "/Core" ) ; foreach ( $ pluginFolders as $ pluginFolder ) { $ this -> blocks += $ this -> findPlugins ( $ pluginFolder . "/Block" ) ; $ this -> themes += $ this -> findPlugins ( $ pluginFolder . "/Theme" ) ; } return $ this ; }
4583	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! array_key_exists ( $ this -> attribute , $ payload ) ) { $ event -> markAsInvalid ( ) ; } $ uuid = $ payload [ $ this -> attribute ] ; $ tenant = $ this -> tenantService -> getRepository ( ) -> findBy ( [ 'uuid' => $ uuid ] ) ; if ( ! $ tenant ) { $ event -> markAsInvalid ( ) ; } }
11800	public function substitution ( $ search , $ replace ) { $ this -> body = str_replace ( $ search , $ replace , $ this -> body ) ; return $ this -> body ; }
5526	protected function createCodeForSubclass ( $ methods ) { $ code = "" ; if ( ! empty ( $ this -> namespace ) ) { $ code .= 'namespace ' . $ this -> namespace . ";\n" ; } $ code .= 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " public \$mock;\n" ; $ code .= $ this -> addMethodList ( array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new \\' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ this -> reflection -> getMethods ( ) ) ; $ code .= $ this -> createCodeForNewMethod ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
7460	public function lookup ( $ hash , $ className = 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) { try { return $ this -> hashedEntityHelper -> lookup ( $ hash , $ className ) ; } catch ( \ RuntimeException $ e ) { return null ; } }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
4749	public function getAddonsForPlan ( array $ plans , string $ addonType = null ) : array { $ addonApi = new Addon ( $ this -> token , $ this -> organizationId , $ this -> cache , $ this -> ttl ) ; foreach ( $ plans as & $ plan ) { $ addons = [ ] ; foreach ( $ plan [ 'addons' ] as $ planAddon ) { $ addon = $ addonApi -> getAddon ( $ planAddon [ 'addon_code' ] ) ; if ( null !== $ addonType ) { if ( ( $ addon [ 'type' ] == $ addonType ) && ( in_array ( $ addonType , self :: $ addonTypes ) ) ) { $ addons [ ] = $ addon ; } } else { $ addons [ ] = $ addon ; } } $ plan [ 'addons' ] = $ addons ; } return $ plans ; }
11042	function store_text ( & $ elts , & $ i , $ ptype , $ ntext , $ ctext ) { if ( $ ntext == 1 && $ ptype != _ETS_ROOT ) { $ elts [ _ETS_TEXT . ':' . $ i ] = $ ctext ; } }
6774	protected function didDeliveryCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldSameAddress = isset ( $ saleCs [ 'sameAddress' ] ) ? $ saleCs [ 'sameAddress' ] [ 0 ] : $ sale -> isSameAddress ( ) ; if ( $ oldSameAddress ) { $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; } else { $ oldAddress = isset ( $ saleCs [ 'deliveryAddress' ] ) ? $ saleCs [ 'deliveryAddress' ] [ 0 ] : $ sale -> getDeliveryAddress ( ) ; } if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } $ newAddress = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ newAddress ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
2190	public function isRegistered ( Model $ objModel ) { $ intObjectId = spl_object_hash ( $ objModel ) ; return isset ( $ this -> arrIdentities [ $ intObjectId ] ) ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
7006	private function formatD ( & $ str ) { if ( strstr ( $ str , '%D' ) ) $ str = str_replace ( '%D' , $ this -> dayName ( false ) , $ str ) ; }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
4887	public function createAttachedEntity ( $ entityClass , $ values = [ ] , $ key = null ) { if ( is_string ( $ values ) ) { $ key = $ values ; $ values = [ ] ; } $ entity = $ this -> repositories -> getRepository ( $ entityClass ) -> create ( $ values ) ; $ this -> addAttachedEntity ( $ entity , $ key ) ; return $ entity ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
7721	public function actionIndex ( ) { $ searchModel = new MahasiswaSearch ( ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; $ field = [ 'fileImport' => 'File Import' , ] ; $ modelImport = DynamicModel :: validateData ( $ field , [ [ [ 'fileImport' ] , 'required' ] , [ [ 'fileImport' ] , 'file' , 'extensions' => 'xls,xlsx' , 'maxSize' => 1024 * 1024 ] , ] ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider , 'modelImport' => $ modelImport , ] ) ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
2296	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ arrUnset [ ] = 'nb' ; return parent :: addToUrl ( $ strRequest . ( ( $ strRequest != '' ) ? '&amp;' : '' ) . 'rt=' . REQUEST_TOKEN , $ blnAddRef , $ arrUnset ) ; }
12434	private function shouldInterruptInfinityBonus ( $ percent , $ percentParent ) { $ result = false ; if ( ( $ percentParent > 0 ) && ( $ percentParent <= $ percent ) ) { $ result = true ; } return $ result ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
11815	protected function step2 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/requirements" ) ; $ this -> view -> setData ( "step" , "2" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Requirements" ) ) ; $ systemcheck = new Helpers \ Requirements ( ) ; $ requirements = [ ] ; $ directives = require_once ( PATH_CONFIG . '/requirements.inc' ) ; $ server = [ "title" => "Required Server Software" , "tests" => [ ] ] ; foreach ( $ directives [ "server" ] as $ name => $ directive ) { $ server [ "tests" ] [ ] = $ systemcheck -> testServerVersions ( $ name , $ directive ) ; } $ requirements [ ] = $ server ; $ modules = [ "title" => "Required Modules" , "tests" => [ ] ] ; foreach ( $ directives [ "modules" ] as $ name => $ directive ) { $ modules [ "tests" ] [ ] = $ systemcheck -> testModule ( $ name , $ directive ) ; } $ requirements [ ] = $ modules ; $ limits = [ "title" => "Required Resource Limits" , "tests" => [ ] ] ; foreach ( $ directives [ "limits" ] as $ name => $ directive ) { $ limits [ "tests" ] [ ] = $ systemcheck -> testLimit ( $ name , $ directive ) ; } $ requirements [ ] = $ limits ; $ directories = [ "title" => "Required Folder Permissions" , "tests" => [ ] ] ; foreach ( $ directives [ "directories" ] as $ name => $ directive ) { $ directories [ "tests" ] [ ] = $ systemcheck -> testFolderPermissions ( $ directive [ "path" ] , $ directive ) ; } $ requirements [ ] = $ directories ; $ this -> view -> setDataArray ( [ "requirements" => $ requirements ] ) ; return ; }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
3438	public function refreshSections ( ) { if ( $ this -> id === null ) { return [ ] ; } $ this -> fields [ 'IBLOCK_SECTION' ] = [ ] ; $ dbSections = static :: $ bxObject -> getElementGroups ( $ this -> id , true ) ; while ( $ section = $ dbSections -> Fetch ( ) ) { $ this -> fields [ 'IBLOCK_SECTION' ] [ ] = $ section ; } $ this -> sectionsAreFetched = true ; return $ this -> fields [ 'IBLOCK_SECTION' ] ; }
8618	public function removeBlock ( $ spec ) { if ( $ spec instanceof Block ) $ spec = $ spec -> getKey ( ) ; if ( is_string ( $ spec ) ) { if ( $ this -> blocks [ $ spec ] ) { unset ( $ this -> blocks [ $ spec ] ) ; } } }
5132	protected function hasStandardPort ( ) : bool { return ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
403	public function overrideDefaultSettings ( $ action ) { if ( isset ( $ this -> actions [ $ action -> id ] ) ) { $ actionParams = $ this -> actions [ $ action -> id ] ; $ actionParamsKeys = array_keys ( $ actionParams ) ; foreach ( $ this -> cors as $ headerField => $ headerValue ) { if ( in_array ( $ headerField , $ actionParamsKeys ) ) { $ this -> cors [ $ headerField ] = $ actionParams [ $ headerField ] ; } } } }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
7745	private function findGetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ camelProp = $ this -> camelize ( $ this -> name ) ; $ getter = 'get' . $ camelProp ; $ isser = 'is' . $ camelProp ; $ hasser = 'has' . $ camelProp ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ getter ) && $ reflClass -> getMethod ( $ getter ) -> isPublic ( ) ) { $ this -> getter = $ getter ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ isser ) && $ reflClass -> getMethod ( $ isser ) -> isPublic ( ) ) { $ this -> getter = $ isser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( $ reflClass -> hasMethod ( $ hasser ) && $ reflClass -> getMethod ( $ hasser ) -> isPublic ( ) ) { $ this -> getter = $ hasser ; $ this -> getterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__get' ) && $ reflClass -> getMethod ( '__get' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> getter = $ this -> name ; $ this -> getterType = self :: GETTER_SETTER_PROPERTY ; } }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
4614	public function withRangeValue ( $ lowerBound , $ upperBound ) { $ this -> lowerBound = $ lowerBound ; $ this -> upperBound = $ upperBound ; $ this -> match = null ; return $ this ; }
11674	public function setConfigurationOptions ( array $ options = array ( ) ) { $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefined ( array ( 'web_dir' , 'uploads_dir' , ) ) ; $ resolver -> resolve ( $ options ) ; if ( array_key_exists ( 'web_dir' , $ options ) ) { $ this -> webDirname = $ options [ 'web_dir' ] ; } if ( array_key_exists ( 'uploads_dir' , $ options ) ) { $ this -> absoluteUploadAssetsDir = $ options [ 'uploads_dir' ] ; } }
6057	public function removeMediaFromFolder ( $ folderId , $ mediaId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/folders/' . $ folderId . '/media/' . $ mediaId . '' , $ parameters ) ; return $ result ; }
7531	function toString ( $ attributes = true , $ recursive = true , $ content_only = false ) { if ( $ content_only ) { if ( is_int ( $ content_only ) ) { -- $ content_only ; } return $ this -> toString_content ( $ attributes , $ recursive , $ content_only ) ; } $ s = '<' . $ this -> tag ; if ( $ attributes ) { $ s .= $ this -> toString_attributes ( ) ; } if ( $ this -> self_close ) { $ s .= $ this -> self_close_str . '>' ; } else { $ s .= '>' ; if ( $ recursive ) { $ s .= $ this -> toString_content ( $ attributes ) ; } $ s .= '</' . $ this -> tag . '>' ; } return $ s ; }
8052	public function getAllEventsAsJson ( ) { $ cache = $ this -> cache ; if ( $ cache :: has ( self :: ALL_EVENTS_TO_JSON_KEY ) ) { return $ cache :: get ( self :: ALL_EVENTS_TO_JSON_KEY ) ; } $ allEvents = $ this -> calendarEventsEngine -> formatEventsToJson ( $ this -> getAllEvents ( ) ) ; $ allEventsToJson = json_encode ( $ allEvents ) ; $ cache :: put ( self :: ALL_EVENTS_TO_JSON_KEY , $ allEventsToJson , $ this -> cacheTimeToLive ) ; return $ allEventsToJson ; }
4031	private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; }
1775	protected function isChecked ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionChecked ( 1 , 1 ) ; } return static :: optionChecked ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
2764	public function run ( string $ command , array $ argsAndOptions = [ ] , bool $ setDirectory = true ) : string { $ command = new GitCommand ( $ command , ... $ argsAndOptions ) ; if ( $ setDirectory ) { $ command -> setDirectory ( $ this -> directory ) ; } return $ this -> gitWrapper -> run ( $ command ) ; }
3764	private function getVisibleCondition ( $ property ) { $ condition = $ property -> getVisibleCondition ( ) ; if ( $ condition instanceof PropertyConditionChain ) { return $ condition ; } $ conditionChain = new PropertyConditionChain ( ) ; $ property -> setVisibleCondition ( $ conditionChain ) ; if ( $ condition ) { $ conditionChain -> addCondition ( $ condition ) ; } return $ conditionChain ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
2377	public static function convertEncoding ( $ str , $ to , $ from = null ) { if ( $ str == '' ) { return '' ; } if ( ! $ from ) { $ from = mb_detect_encoding ( $ str , 'ASCII,ISO-2022-JP,UTF-8,EUC-JP,ISO-8859-1' ) ; } if ( $ from == $ to ) { return $ str ; } if ( $ from == 'UTF-8' && $ to == 'ISO-8859-1' ) { return utf8_decode ( $ str ) ; } if ( $ from == 'ISO-8859-1' && $ to == 'UTF-8' ) { return utf8_encode ( $ str ) ; } return mb_convert_encoding ( $ str , $ to , $ from ) ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
6615	public function hasEndpoint ( $ method , $ endpointName ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
9292	public function getEndpointNode ( ) { $ builder = new TreeBuilder ( ) ; $ node = $ builder -> root ( 'endpoints' ) ; $ node -> info ( 'Defines version endpoints.' ) -> useAttributeAsKey ( 'endpoint' ) -> prototype ( 'array' ) -> children ( ) -> scalarNode ( 'endpoint' ) -> info ( 'Endpoint name (will be included in url (e.g. products))' ) -> example ( 'products' ) -> end ( ) -> scalarNode ( 'repository' ) -> isRequired ( ) -> info ( 'Document service from Elasticsearch bundle which will be used for data fetching' ) -> example ( 'es.manager.default.products' ) -> end ( ) -> arrayNode ( 'methods' ) -> defaultValue ( [ Request :: METHOD_POST , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> prototype ( 'scalar' ) -> validate ( ) -> ifNotInArray ( [ Request :: METHOD_HEAD , Request :: METHOD_POST , Request :: METHOD_PATCH , Request :: METHOD_GET , Request :: METHOD_PUT , Request :: METHOD_DELETE ] ) -> thenInvalid ( 'Invalid HTTP method used! Please check your ongr_api endpoint configuration.' ) -> end ( ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_extra_fields' ) -> defaultFalse ( ) -> info ( 'Allows to pass unknown fields to an api. ' . 'Make sure you have configured elasticsearch respectively.' ) -> end ( ) -> arrayNode ( 'allow_fields' ) -> defaultValue ( [ ] ) -> info ( 'A list off a allowed fields to operate through api for a document.' ) -> prototype ( 'scalar' ) -> end ( ) -> end ( ) -> booleanNode ( 'allow_get_all' ) -> defaultTrue ( ) -> info ( 'Allows to use `_all` elasticsearch api to get all documents from a type.' ) -> end ( ) -> booleanNode ( 'allow_batch' ) -> defaultTrue ( ) -> info ( 'Allows to use `_batch` elasticsearch api to pass multiple documents in single API request.' ) -> end ( ) -> booleanNode ( 'variants' ) -> defaultFalse ( ) -> info ( 'If set to true user can manipulate document variants over API.' ) -> end ( ) -> booleanNode ( 'batch' ) -> defaultTrue ( ) -> info ( 'If set to true user can sent documents in batch\'s.' ) -> end ( ) -> end ( ) -> end ( ) ; return $ node ; }
4513	public function toObject ( ) : stdClass { $ object = new stdClass ; $ object -> timestamp = $ this -> timestamp ; $ object -> collection = $ this -> collection -> toArray ( ) ; foreach ( $ object -> collection as $ alias => $ status ) { $ object -> collection [ $ alias ] = $ status -> toObject ( ) ; } return $ object ; }
7075	private function addItemDetails ( array & $ details , Model \ SaleItemInterface $ item ) { $ total = 0 ; if ( ! ( $ item -> isCompound ( ) && ! $ item -> hasPrivateChildren ( ) ) ) { $ itemResult = $ item -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ item -> getTotalQuantity ( ) . 'x ' . $ item -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NUMBER' . $ this -> line ] = $ item -> getReference ( ) ; if ( ! empty ( $ description = $ item -> getDescription ( ) ) ) { $ details [ 'L_PAYMENTREQUEST_0_DESC' . $ this -> line ] = $ description ; } $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = $ this -> format ( $ itemResult -> getTotal ( ) ) ; $ total = $ itemResult -> getTotal ( ) ; $ this -> line ++ ; } foreach ( $ item -> getChildren ( ) as $ child ) { $ total += $ this -> addItemDetails ( $ details , $ child ) ; } return $ total ; }
4529	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ content = $ request -> getContent ( ) ; if ( '' === $ content ) { return ; } try { $ filters = json_decode ( $ content , true ) ; } catch ( Exception $ exception ) { throw new BadRequestHttpException ( 'Request body should be an object.' , $ exception ) ; } if ( ! is_array ( $ filters ) ) { throw new BadRequestHttpException ( 'Request body should be an object.' ) ; } $ current = $ request -> attributes -> get ( '_api_filters' , [ ] ) ; $ query = $ request -> query -> all ( ) ; $ filters = array_merge ( $ current , $ query , $ filters ) ; $ request -> attributes -> set ( '_api_filters' , $ filters ) ; }
1501	public function matchesTo ( MediaTypeInterface $ mediaType ) : ? Encoding { return collect ( $ this -> stack ) -> first ( function ( Encoding $ encoding ) use ( $ mediaType ) { return $ encoding -> matchesTo ( $ mediaType ) ; } ) ; }
9105	protected function parse_time ( ) { if ( ! empty ( $ this -> args [ 'time' ] ) ) { $ date_query = new \ WP_Date_Query ( $ this -> args [ 'time' ] , 'q.time' ) ; return new Where_Date ( $ date_query ) ; } else { return null ; } }
12759	public static function parse ( & $ string ) { $ media = array ( "objects" => array ( ) , "hashes" => array ( ) , "links" => array ( ) , ) ; preg_match_all ( '#@([\\d\\w]+)#' , $ string , $ mentions ) ; preg_match_all ( '/#([\\d\\w]+)/' , $ string , $ hashTags ) ; preg_match_all ( '/((http|https|ftp|ftps)\:\/\/)([a-z0-9+!*(),;?&=\$_.-]+(\:[a-z0-9+!*(),;?&=\$_.-]+)?@)?([a-zA-Z0-9\-\.]+)\.([a-zA-Z]{2,3})(\:[0-9]{2,5})?(\/([a-z0-9+\$_-]\.?)+)*\/?/' , $ data , $ openLinks ) ; return $ media ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
1581	public function withAttributes ( $ attributes ) : self { $ copy = clone $ this ; $ copy -> attributes = collect ( $ attributes ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
12612	public function getIP ( ) { $ ip = "UNKNOWN" ; if ( getenv ( "HTTP_CLIENT_IP" ) ) { $ ip = getenv ( "HTTP_CLIENT_IP" ) ; } else if ( getenv ( "HTTP_X_FORWARDED_FOR" ) ) { $ ip = getenv ( "HTTP_X_FORWARDED_FOR" ) ; } else if ( getenv ( "REMOTE_ADDR" ) ) { $ ip = getenv ( "REMOTE_ADDR" ) ; } return $ ip ; }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
12284	public function head ( ) : string { $ property = static :: HEAD_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: HEAD_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
1543	protected function cursor ( EncodingParametersInterface $ parameters ) { return Cursor :: create ( ( array ) $ parameters -> getPaginationParameters ( ) , $ this -> before , $ this -> after , $ this -> limit ) ; }
2158	public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; }
6931	private function feedShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { $ changed = false ; $ shipment = $ invoice -> getShipment ( ) ; $ calculator = $ this -> invoiceBuilder -> getInvoiceCalculator ( ) ; foreach ( $ shipment -> getItems ( ) as $ shipmentItem ) { $ saleItem = $ shipmentItem -> getSaleItem ( ) ; $ max = $ shipment -> isReturn ( ) ? $ calculator -> calculateCreditableQuantity ( $ saleItem ) : $ calculator -> calculateInvoiceableQuantity ( $ saleItem ) ; if ( 0 < $ quantity = min ( $ max , $ shipmentItem -> getQuantity ( ) ) ) { $ line = $ this -> invoiceBuilder -> findOrCreateGoodLine ( $ invoice , $ saleItem , $ max ) ; if ( $ line -> getQuantity ( ) !== $ quantity ) { $ line -> setQuantity ( $ quantity ) ; $ changed = true ; } } } if ( $ invoice -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_GOOD ) ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getAdjustments ( Common \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ saleAdjustment ) { foreach ( $ invoice -> getLinesByType ( Document \ DocumentLineTypes :: TYPE_DISCOUNT ) as $ line ) { if ( $ saleAdjustment === $ line -> getSaleAdjustment ( ) ) { continue 2 ; } } $ this -> invoiceBuilder -> buildDiscountLine ( $ saleAdjustment , $ invoice ) ; $ changed = true ; } if ( null !== $ sale -> getShipmentMethod ( ) && ! $ this -> isShipmentAmountInvoiced ( $ invoice ) ) { $ this -> invoiceBuilder -> buildShipmentLine ( $ invoice ) ; } } return $ changed ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
3500	public function withApnId ( ApnId $ apnId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> apnId = $ apnId ; return $ cloned ; }
6082	public function removeComment ( $ mediaId , $ commentId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ mediaId . '/comments/' . $ commentId . '' , $ parameters ) ; $ result = new Comment ( $ result ) ; return $ result ; }
9370	public function handle ( ServerRequestInterface $ request ) { $ callback = new CallbackHandler ( self :: $ container ) ; if ( static :: $ container -> has ( self :: MIDDLEWARE ) ) { $ middleware = static :: $ container -> get ( self :: MIDDLEWARE ) ; $ delegate = new Delegate ( $ callback ) ; $ result = $ middleware -> process ( $ request , $ delegate ) ; } return isset ( $ result ) ? $ result : $ callback ( $ request ) ; }
12100	public function priceBrutto ( $ netto , $ tax ) { $ tax = round ( ( double ) $ tax / 100.0 , 2 ) ; if ( $ tax < 0.00 ) { throw new Exception ( sprintf ( 'Tax must be greater than or equal to 0, given %s.' , $ tax ) ) ; } if ( $ tax === 0.00 ) { return $ netto ; } $ result = $ netto * ( $ tax + 1 ) ; return round ( $ result , 2 , PHP_ROUND_HALF_UP ) ; }
8953	public function createNode ( $ changeset , $ latitude , $ longitude , $ tags ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'node/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <node changeset="' . $ changeset . '" lat="' . $ latitude . '" lon="' . $ longitude . '">' . $ tagList . '</node> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
5706	public function shouldDisplay ( ) { return $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsPublished ( ) && $ this -> gridFieldRequest -> record -> canEdit ( ) ; }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
7353	protected function getProvider ( $ nameOrRelativeOrSubject ) { if ( null === $ provider = $ this -> registry -> getProvider ( $ nameOrRelativeOrSubject ) ) { throw new SubjectException ( 'Failed to get provider.' ) ; } return $ provider ; }
9533	private function preloadParameters ( $ argv ) { array_shift ( $ argv ) ; $ this -> argv = [ ] ; while ( ( $ argument = array_shift ( $ argv ) ) != null ) { switch ( substr ( $ argument , 0 , 1 ) ) { case '\'' : { $ this -> parseQuote ( $ argv , $ argument , '\'' ) ; break ; } case '"' : { $ this -> parseQuote ( $ argv , $ argument , '"' ) ; break ; } default : { $ this -> argv [ ] = $ argument ; } } } }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
10430	protected function createPipelines ( ContainerBuilder $ container , array $ config ) { foreach ( $ config [ 'pipelines' ] as $ pipelineName => $ pipelineConfig ) { if ( ! isset ( $ pipelineConfig [ 'shop' ] ) ) { $ pipelineConfig [ 'shop' ] = $ container -> getParameter ( 'ongr_connections.active_shop' ) ; } $ serviceConfig = $ this -> prepareServiceConfigs ( $ container , $ pipelineConfig , $ pipelineName ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_sources' ] , $ serviceConfig , "data_sync.{$pipelineName}.source" , 'onSource' ) ; $ this -> createServices ( $ container , $ pipelineConfig [ 'provide_consumers' ] , $ serviceConfig , "data_sync.{$pipelineName}.consume" , 'onConsume' ) ; foreach ( $ pipelineConfig [ 'types' ] as $ type => $ typeConfig ) { $ typeServiceConfig = $ this -> prepareTypeServiceConfigs ( $ serviceConfig , $ typeConfig , $ type ) ; $ serviceList = $ this -> getServiceList ( $ pipelineName , $ type ) ; foreach ( $ serviceList as $ name => $ service ) { $ this -> createServices ( $ container , array_merge ( $ pipelineConfig [ $ name ] , $ typeConfig [ $ name ] ) , $ typeServiceConfig , $ service [ 'tag' ] , $ service [ 'method' ] ) ; } } } }
12776	protected function write ( $ namespace , array $ data ) { $ file = $ this -> adapter -> getFileName ( $ namespace ) ; $ contents = $ this -> adapter -> prepareForWriting ( $ data ) ; if ( ! $ this -> fileSystem -> has ( $ file ) ) { $ this -> fileSystem -> write ( $ file , $ contents ) ; } $ this -> fileSystem -> update ( $ file , $ contents ) ; }
2795	public function getTempDirectory ( ) { if ( is_null ( $ this -> tempDirectory ) ) { $ root = sys_get_temp_dir ( ) ; if ( ! is_dir ( $ root . '/humbug' ) ) { mkdir ( $ root . '/humbug' , 0777 , true ) ; } $ this -> tempDirectory = $ root . '/humbug' ; } return $ this -> tempDirectory ; }
5738	public function setDefaultSuffix ( $ defaultSuffix ) { $ this -> defaultSuffix = ( string ) $ defaultSuffix ; $ this -> defaultSuffix = ltrim ( $ this -> defaultSuffix , '.' ) ; return $ this ; }
4752	public function send ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'c_oegdproptin' ) ; if ( $ this -> isOptInValidationRequired ( ) && ! $ optInValue ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONTACT_FORM_ERROR_MESSAGE' ) ; $ this -> optInError = true ; return false ; } return parent :: send ( ) ; }
537	protected function updateDocComment ( $ doc , $ properties ) { $ lines = explode ( "\n" , $ doc ) ; $ propertyPart = false ; $ propertyPosition = false ; foreach ( $ lines as $ i => $ line ) { $ line = trim ( $ line ) ; if ( strncmp ( $ line , '* @property ' , 12 ) === 0 ) { $ propertyPart = true ; } elseif ( $ propertyPart && $ line == '*' ) { $ propertyPosition = $ i ; $ propertyPart = false ; } if ( strncmp ( $ line , '* @author ' , 10 ) === 0 && $ propertyPosition === false ) { $ propertyPosition = $ i - 1 ; $ propertyPart = false ; } if ( $ propertyPart ) { unset ( $ lines [ $ i ] ) ; } } if ( $ propertyPosition === false ) { $ propertyPosition = \ count ( $ lines ) - 2 ; } $ finalDoc = '' ; foreach ( $ lines as $ i => $ line ) { $ finalDoc .= $ line . "\n" ; if ( $ i == $ propertyPosition ) { $ finalDoc .= $ properties ; } } return $ finalDoc ; }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
5129	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-8' , 'UTF-16BE' ) ; } return preg_replace_callback ( '/(?:[\xD8-\xDB]...)|(?:..)/s' , function ( $ m ) { if ( isset ( $ m [ 0 ] [ 3 ] ) ) { list ( , $ higher , $ lower ) = unpack ( 'n*' , $ m [ 0 ] ) ; $ code = ( ( $ higher & 0x03FF ) << 10 ) + ( $ lower & 0x03FF ) + 0x10000 ; return pack ( 'c*' , $ code >> 18 | 0xF0 , $ code >> 12 & 0x3F | 0x80 , $ code >> 6 & 0x3F | 0x80 , $ code & 0x3F | 0x80 ) ; } list ( , $ code ) = unpack ( 'n' , $ m [ 0 ] ) ; if ( $ code < 0x80 ) { return chr ( $ code ) ; } elseif ( $ code < 0x0800 ) { return chr ( $ code >> 6 | 0xC0 ) . chr ( $ code & 0x3F | 0x80 ) ; } else { return chr ( $ code >> 12 | 0xE0 ) . chr ( $ code >> 6 & 0x3F | 0x80 ) . chr ( $ code & 0x3F | 0x80 ) ; } return '?' ; } , $ str ) ; }
8848	public function tag ( ) { $ tag = $ this -> getCurrentTag ( ) ; if ( $ tag ) { $ this -> blogPosts = $ tag -> BlogPosts ( ) ; return $ this -> render ( ) ; } return $ this -> httpError ( 404 , "Not Found" ) ; }
11357	public function add ( $ blockFile , $ blockContent ) { $ this -> removeBlock ( $ blockFile ) ; $ blockPermalinks = $ this -> fetchPermalinksFromBlock ( $ blockContent , $ blockFile ) ; if ( ! empty ( $ blockPermalinks ) ) { $ this -> permalinks = array_merge_recursive ( $ this -> permalinks , $ blockPermalinks ) ; } return $ this ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12327	protected function getParam ( $ param ) { if ( isset ( $ _POST [ $ param ] ) ) { return $ _POST [ $ param ] ; } elseif ( isset ( $ _GET [ $ param ] ) ) { return $ _GET [ $ param ] ; } return ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
11305	public static function email ( $ email = null , $ errorMsg = null ) { if ( ! $ email ) return null ; $ email = trim ( mb_strtolower ( trim ( $ email ) , "UTF-8" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { return null ; } return $ email ; }
9577	protected function registerMaterializePlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false && is_array ( $ this -> clientOptions ) ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( $ this -> clientOptions ) ; $ js = "Materialize.$name.apply(null, $options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
5605	public function paintMethodEnd ( $ method ) { if ( $ this -> fail || $ this -> error || ! $ this -> pass ) { } else { $ this -> listener -> write ( '{status:"pass",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
1221	private function reduce ( $ from , array $ values , array $ types , callable $ reduce ) { $ i = - 1 ; return array_reduce ( $ values , function ( $ carry , $ item ) use ( $ from , $ types , $ reduce , & $ i ) { if ( ++ $ i > 0 ) { $ this -> validateSeq ( $ from , $ types , $ carry , $ item ) ; } return $ reduce ( $ carry , $ item , $ i ) ; } ) ; }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
1264	private function createVoidRequest ( $ shipmentData ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'VoidShipmentRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , '1' ) ) ; if ( is_string ( $ shipmentData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData ) ) ) ; } else { $ expanded = $ container -> appendChild ( $ xml -> createElement ( 'ExpandedVoidShipment' ) ) ; $ expanded -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData [ 'shipmentId' ] ) ) ) ; if ( array_key_exists ( 'trackingNumbers' , $ shipmentData ) ) { foreach ( $ shipmentData [ 'trackingNumbers' ] as $ tn ) { $ expanded -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , strtoupper ( $ tn ) ) ) ; } } } return $ xml -> saveXML ( ) ; }
4421	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ legacyRootDir = $ this -> container -> getParameter ( 'ezpublish_legacy.root_dir' ) ; $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageCode = $ input -> getOption ( 'language-code' ) ; $ siteAccessLocation = $ legacyRootDir . '/settings/siteaccess/' . $ siteAccessName ; $ skeletonDir = __DIR__ . '/../_templates/legacy_siteaccess' ; if ( $ fileSystem -> exists ( $ siteAccessLocation ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>' . $ siteAccessName . '</comment> legacy siteaccess already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ fileSystem -> remove ( $ siteAccessLocation ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ relatedSiteAccessList = $ this -> container -> getParameter ( 'ezpublish.siteaccess.list' ) ; $ relatedSiteAccessList [ ] = $ siteAccessName ; $ availableLocales = array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languageService -> loadLanguages ( ) ) ; $ availableLocales = array_values ( array_diff ( $ availableLocales , array ( $ languageCode ) ) ) ; $ siteLanguageList = array_merge ( array ( $ languageCode ) , $ availableLocales ) ; $ translationList = implode ( ';' , $ availableLocales ) ; $ fileSystem -> mirror ( $ skeletonDir , $ siteAccessLocation ) ; $ this -> setSkeletonDirs ( $ siteAccessLocation ) ; $ this -> renderFile ( 'site.ini.append.php' , $ siteAccessLocation . '/site.ini.append.php' , array ( 'relatedSiteAccessList' => $ relatedSiteAccessList , 'siteAccessLocale' => $ languageCode , 'siteLanguageList' => $ siteLanguageList , 'translationList' => $ translationList , ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>' . $ siteAccessName . '</comment> legacy siteaccess!' , '' , ) ) ; }
2116	public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } }
2664	public function sendWebHook ( $ message ) { $ url = $ this -> config -> getIncomingWebhookURL ( ) ; $ messagePrefix = $ this -> config -> getWebhookMessagePrefix ( ) ; $ currentUsername = 'System' ; try { if ( $ this -> state -> getAreaCode ( ) == 'adminhtml' ) { $ getUser = $ this -> authSession -> getUser ( ) ; if ( ! empty ( $ getUser ) ) { $ currentUsername = $ getUser -> getUserName ( ) ; } } } catch ( \ Exception $ e ) { $ this -> log -> log ( 100 , 'Failed to retrieve Area Code' ) ; } $ storeName = $ this -> helper -> getStoreName ( ) ; $ storeUrl = $ this -> helper -> getStoreUrl ( ) ; $ text = $ messagePrefix . ' user=' . $ currentUsername . ' ' . $ message . ' on <' . $ storeUrl . '|Store> | ' . $ storeName ; $ headers = [ 'Content-type: application/json' ] ; $ body = json_encode ( [ "text" => $ text , "username" => "fastly-magento-bot" , "icon_emoji" => ":airplane:" ] ) ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_CONNECTTIMEOUT , 2 ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 3 ) ; $ client -> write ( \ Zend_Http_Client :: POST , $ url , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; if ( $ responseCode != 200 ) { $ this -> log -> log ( 100 , 'Failed to send message to the following Webhook: ' . $ url ) ; } $ client -> close ( ) ; }
12381	public static function interval ( $ startDate , $ endDate ) { $ hits = DB :: table ( 'views' ) -> select ( 'id' , 'ip' , 'created_at' ) -> whereBetween ( 'created_at' , [ $ startDate , $ endDate ] ) -> groupBy ( 'ip' ) -> get ( ) ; return count ( $ hits ) ; }
6790	protected function merge ( array $ cachedUnits , array $ fetchedUnits ) { $ cachedIds = [ ] ; foreach ( $ cachedUnits as $ unit ) { if ( null !== $ id = $ unit -> getId ( ) ) { $ cachedIds [ ] = $ unit -> getId ( ) ; } } foreach ( $ fetchedUnits as $ unit ) { if ( in_array ( $ unit -> getId ( ) , $ cachedIds ) ) { continue ; } if ( $ this -> unitCache -> isRemoved ( $ unit ) ) { continue ; } if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ unit ) ) { continue ; } $ cachedUnits [ ] = $ unit ; } return $ cachedUnits ; }
1802	public function initPicker ( PickerInterface $ picker ) { if ( ! empty ( $ _GET [ 'act' ] ) ) { return null ; } $ provider = $ picker -> getCurrentProvider ( ) ; if ( ! $ provider instanceof DcaPickerProviderInterface || $ provider -> getDcaTable ( ) != $ this -> strTable ) { return null ; } $ attributes = $ provider -> getDcaAttributes ( $ picker -> getConfig ( ) ) ; $ this -> objPicker = $ picker ; $ this -> strPickerFieldType = $ attributes [ 'fieldType' ] ; $ this -> objPickerCallback = function ( $ value ) use ( $ picker , $ provider ) { return $ provider -> convertDcaValue ( $ picker -> getConfig ( ) , $ value ) ; } ; if ( isset ( $ attributes [ 'value' ] ) ) { $ this -> arrPickerValue = ( array ) $ attributes [ 'value' ] ; } return $ attributes ; }
1177	public function make ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] , $ selector = null ) { $ validator = $ this -> getValidatorInstance ( $ rules , $ messages , $ customAttributes ) ; return $ this -> validator ( $ validator , $ selector ) ; }
8250	protected function passwordRehash ( $ username , Password $ password ) { $ userData = $ this -> storage -> getUserByName ( $ username ) ; try { $ this -> userDataEncodePassword ( $ userData , $ password ) ; } catch ( \ PicoAuth \ Security \ Password \ Encoder \ EncoderException $ e ) { $ this -> session -> addFlash ( "error" , "Please set a new password." ) ; $ this -> picoAuth -> getContainer ( ) -> get ( 'PasswordReset' ) -> startPasswordResetSession ( $ username ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ this -> storage -> saveUser ( $ username , $ userData ) ; }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
4494	private function getApnsJsonInner ( ? string $ text ) : array { $ apns = [ 'aps' => [ ] , ] ; if ( null !== $ this -> localizedKey ) { $ apns [ 'aps' ] [ 'alert' ] = [ 'loc-key' => $ this -> localizedKey , ] ; if ( $ this -> localizedArguments ) { $ apns [ 'aps' ] [ 'alert' ] [ 'loc-args' ] = $ this -> localizedArguments ; } } elseif ( null !== $ text ) { $ apns [ 'aps' ] [ 'alert' ] = $ text ; } if ( $ this -> isContentAvailable ( ) ) { $ apns [ 'aps' ] [ 'content-available' ] = 1 ; } if ( null !== $ this -> badge ) { $ apns [ 'aps' ] [ 'badge' ] = $ this -> badge ; } if ( null !== $ this -> sound ) { $ apns [ 'aps' ] [ 'sound' ] = $ this -> sound ; } $ merged = $ this -> arrayMergeDeep ( $ apns , $ this -> custom , $ this -> apnsData ? $ this -> apnsData : [ ] ) ; if ( ! \ count ( $ merged [ 'aps' ] ) ) { $ merged [ 'aps' ] = new \ stdClass ( ) ; } return $ merged ; }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
781	public function has ( $ name ) { return isset ( $ this -> _cookies [ $ name ] ) && $ this -> _cookies [ $ name ] -> value !== '' && ( $ this -> _cookies [ $ name ] -> expire === null || $ this -> _cookies [ $ name ] -> expire === 0 || $ this -> _cookies [ $ name ] -> expire >= time ( ) ) ; }
8136	public function setCache ( $ cache ) { if ( is_string ( $ cache ) ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Filesystem ( $ cache ) ; } elseif ( false === $ cache ) { $ this -> originalCache = $ cache ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( null === $ cache ) { @ trigger_error ( 'Using "null" as the cache strategy is deprecated since version 1.23 and will be removed in Twig 2.0.' , E_USER_DEPRECATED ) ; $ this -> originalCache = false ; $ this -> cache = new Twig_Cache_Null ( ) ; } elseif ( $ cache instanceof Twig_CacheInterface ) { $ this -> originalCache = $ this -> cache = $ cache ; } else { throw new LogicException ( sprintf ( 'Cache can only be a string, false, or a Twig_CacheInterface implementation.' ) ) ; } }
7683	function Ext_GetMainIdx ( ) { if ( ( $ this -> ExtInfo !== false ) && isset ( $ this -> ExtInfo [ 'main' ] ) ) { return $ this -> FileGetIdx ( $ this -> ExtInfo [ 'main' ] ) ; } else { return false ; } }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
5504	public function getCallCount ( $ method ) { $ this -> dieOnNoMethod ( $ method , 'get call count' ) ; $ method = strtolower ( $ method ) ; if ( ! isset ( $ this -> call_counts [ $ method ] ) ) { return 0 ; } return $ this -> call_counts [ $ method ] ; }
11049	function parse_info ( $ info ) { $ elements = explode ( ':' , $ info ) ; $ count = count ( $ elements ) ; if ( $ count > 4 ) { for ( $ i = 4 ; $ i < $ count ; ++ $ i ) { $ elements [ 3 ] .= ':' . $ elements [ $ i ] ; } } else { $ elements = array_pad ( $ elements , 4 , '' ) ; } return array ( $ elements [ 0 ] , $ elements [ 2 ] , $ elements [ 3 ] ) ; }
1107	protected function writeModel ( $ name ) { $ output = pathinfo ( $ this -> modeler -> create ( $ name , $ this -> getModelsPath ( ) ) , PATHINFO_FILENAME ) ; $ this -> line ( " <fg=green;options=bold>create</fg=green;options=bold> $output" ) ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
4896	public function start ( $ type = self :: TYPE_INFO , array $ options = array ( ) ) { if ( $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot start capture, there is already a capture running.' ) ; } $ this -> captureLock = true ; $ this -> captureType = $ type ; $ this -> captureOptions = $ options ; ob_start ( ) ; return $ this ; }
2162	public function run35Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_member` CHANGE `username` `username` varchar(64) COLLATE utf8_bin NULL" ) ; $ this -> Database -> query ( "UPDATE `tl_member` SET username=NULL WHERE username=''" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_member` DROP INDEX `username`, ADD UNIQUE KEY `username` (`username`)" ) ; }
9974	public function setBuiltInFormatCode ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'formatCode' => self :: builtInFormatCode ( $ pValue ) ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> builtInFormatCode = $ pValue ; $ this -> formatCode = self :: builtInFormatCode ( $ pValue ) ; } return $ this ; }
11933	public function render ( $ view , array $ parameters = array ( ) , Response $ response = null ) { $ parameters [ 'base_template' ] = isset ( $ parameters [ 'base_template' ] ) ? $ parameters [ 'base_template' ] : $ this -> getBaseTemplate ( ) ; $ parameters [ 'admin_pool' ] = $ this -> get ( 'sonata.admin.pool' ) ; return parent :: render ( $ view , $ parameters ) ; }
11123	public function getUp ( $ time = NOW ) { foreach ( $ this -> movements as $ v ) { if ( $ v -> isActive ( $ time ) ) { $ up = $ v -> getCurrentUp ( $ time ) ; if ( isset ( $ up ) ) { return $ v -> getCurrentUp ( $ time ) ; } } } return new Neuron_GameServer_Map_Vector3 ( 0 , 1 , 0 ) ; }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
7033	protected function lastMigration ( ) { try { $ migration = Db :: query ( "select * from migrations order by created_at desc limit 1" , [ ] , $ this -> dbName ) ; return $ migration [ 0 ] ; } catch ( PDOException $ e ) { if ( $ e -> getCode ( ) === "42S02" ) return null ; } return false ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
9017	public function getWords ( $ string , $ minLength = null ) { $ tokenizer = new Whitespace ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; if ( ! is_null ( $ minLength ) ) { foreach ( $ words as $ key => $ word ) { if ( strlen ( $ word ) <= $ minLength ) { unset ( $ words [ $ key ] ) ; } } } return array_values ( $ words ) ; }
1211	public function callRecursively ( ItemInterface $ item , $ method , $ arguments = array ( ) ) { call_user_func_array ( array ( $ item , $ method ) , $ arguments ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> callRecursively ( $ child , $ method , $ arguments ) ; } }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
9939	public function addChart ( Chart $ pChart , $ iChartIndex = null ) { $ pChart -> setWorksheet ( $ this ) ; if ( $ iChartIndex === null ) { $ this -> chartCollection [ ] = $ pChart ; } else { array_splice ( $ this -> chartCollection , $ iChartIndex , 0 , [ $ pChart ] ) ; } return $ pChart ; }
351	public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; }
9525	public function parse ( $ argv = null , ParameterCluster $ parameterCluster = null ) { $ this -> initialize ( $ argv , $ parameterCluster ) ; return $ this -> checkValidityAndContinueParse ( ) ; }
2689	private function fastlyResize ( ) { if ( $ this -> getWidth ( ) === null && $ this -> getHeight ( ) === null ) { return $ this ; } $ this -> adjustSize ( ) ; return $ this ; }
10606	public function addHeader ( string $ header , $ value ) : void { if ( is_iterable ( $ value ) || is_array ( $ value ) ) { $ iterable = $ value ; $ value = [ ] ; foreach ( $ iterable as $ key => $ entry ) { $ value [ $ key ] = ( string ) $ entry ; } } else { $ value = ( string ) $ value ; } $ this -> headers [ ] = [ $ header , $ value ] ; }
8926	public static function fetch ( $ dir = false ) { if ( false === $ dir ) { $ dir = getcwd ( ) ; } $ config = [ ] ; $ files = glob ( $ dir . '/config/*.config.php' , GLOB_BRACE ) ; foreach ( $ files as $ file ) { $ config = array_merge ( $ config , ( require $ file ) ) ; } return $ config ; }
3827	protected function getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ) { return '' ; } return $ strKeyOption ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
8633	public function setOrderChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11310	public static function setMappings ( array $ messages , $ manual = true ) { $ class = get_called_class ( ) ; if ( $ manual ) { static :: $ messages = $ messages ; self :: setStatus ( ) ; } else { self :: $ mappings [ $ class ] = array_replace ( $ class :: getMappings ( ) , $ messages ) ; } }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
10720	public function removeThumbnail ( \ TYPO3 \ CMS \ Extbase \ Domain \ Model \ FileReference $ thumbnail ) { $ this -> thumbnails -> detach ( $ thumbnail ) ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7979	public function getSessionProperties ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionProperties ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
9644	protected function mapParams ( array $ params ) : array { unset ( $ params [ 0 ] ) ; foreach ( $ params as $ name => $ value ) { if ( ! is_string ( $ name ) ) { unset ( $ params [ $ name ] ) ; } else { $ params [ $ name ] = urldecode ( $ value [ 0 ] ) ; } } return $ params ; }
8352	public function handle ( int $ signal ) { if ( isset ( $ this -> handlers [ $ signal ] ) && $ this -> handlers [ $ signal ] === true ) { return new Failure ( new Exception ( 'Signal is already being processed.' ) ) ; } $ this -> handlers [ $ signal ] = true ; $ this -> dispatcher -> setIsRunning ( false ) ; $ fn = $ this -> signals [ $ signal ] ; $ result = $ this -> $ fn ( ) ; if ( $ result === true ) { unset ( $ this -> handlers [ $ signal ] ) ; return new Success ( $ result ) ; } $ deferred = new Deferred ; Loop :: repeat ( 1000 , function ( $ watcherId , $ callback ) use ( $ deferred , $ signal , $ result ) { if ( count ( $ this -> dispatcher -> getProcesses ( ) ) === 0 ) { Loop :: cancel ( $ watcherId ) ; unset ( $ this -> handlers [ $ signal ] ) ; return $ deferred -> resolve ( $ result ) ; } } ) ; return $ deferred -> promise ( ) ; }
1575	public function api ( $ apiName = null ) { $ repo = $ this -> container -> make ( Repository :: class ) ; return $ repo -> createApi ( $ apiName ? : $ this -> defaultApi ( ) ) ; }
1002	public static function visitWithTypeInfo ( TypeInfo $ typeInfo , $ visitor ) { return [ 'enter' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ typeInfo -> enter ( $ node ) ; $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , false ) ; if ( $ fn ) { $ result = call_user_func_array ( $ fn , func_get_args ( ) ) ; if ( $ result !== null ) { $ typeInfo -> leave ( $ node ) ; if ( $ result instanceof Node ) { $ typeInfo -> enter ( $ result ) ; } } return $ result ; } return null ; } , 'leave' => static function ( Node $ node ) use ( $ typeInfo , $ visitor ) { $ fn = self :: getVisitFn ( $ visitor , $ node -> kind , true ) ; $ result = $ fn ? call_user_func_array ( $ fn , func_get_args ( ) ) : null ; $ typeInfo -> leave ( $ node ) ; return $ result ; } , ] ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
12537	public function setRelatedObjects ( $ relatedObjects ) { foreach ( $ relatedObjects as $ modelName => $ objects ) { if ( ! isset ( $ this -> _relatedObjects [ $ modelName ] ) ) { $ this -> _relatedObjects [ $ modelName ] = [ ] ; } foreach ( $ objects as $ tabId => $ objectAttributes ) { if ( ! isset ( $ objectAttributes [ '_moduleHandler' ] ) ) { continue ; } list ( $ relationship , $ role ) = $ this -> owner -> objectType -> getRelationship ( $ objectAttributes [ '_moduleHandler' ] ) ; $ relatedHandler = $ this -> owner -> objectType -> getRelatedType ( $ objectAttributes [ '_moduleHandler' ] ) ; if ( ! $ relatedHandler ) { continue ; } $ objectAttributes = array_merge ( [ 'companionObject' => $ this -> owner , 'companionRelationship' => $ relationship , 'companionRole' => $ role , ] , $ objectAttributes ) ; $ object = $ relatedHandler -> getModel ( null , $ objectAttributes ) ; $ object -> tabularId = $ objectAttributes [ '_moduleHandler' ] ; if ( ( ! $ object || $ object -> isEmptyObject ( ) ) && ! ( $ relationship -> required ) ) { continue ; } $ object -> companionObject = $ object -> indirectObject = $ this -> owner ; $ object -> companionRelationship = $ relationship ; $ object -> companionRole = $ role ; $ this -> _relatedObjects [ $ modelName ] [ $ tabId ] = $ object ; $ this -> _relatedObjectsFlat [ ] = $ object ; } } }
6257	public function authorize ( $ user , Request $ request ) { $ roleField = $ this -> _config [ 'roleField' ] ; if ( ! isset ( $ user [ $ roleField ] ) ) { throw new RuntimeException ( sprintf ( 'The role field `%s` does not exist!' , $ roleField ) ) ; } if ( is_string ( $ user [ $ roleField ] ) ) { $ user [ $ roleField ] = array ( $ user [ $ roleField ] ) ; } if ( $ this -> authorizeByPrefix ( $ user [ $ roleField ] , $ request ) ) { return true ; } if ( $ this -> authorizeByControllerAndAction ( $ user , $ request ) ) { return true ; } return false ; }
9272	protected function dataToMultipart ( array $ data = [ ] ) { $ multipart = [ ] ; foreach ( $ data as $ name => $ contents ) { array_push ( $ multipart , [ 'name' => $ name , 'contents' => $ contents ] ) ; } return $ multipart ; }
716	public function decimal ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DECIMAL , $ length ) ; }
10302	private function writePrintSettings ( $ objWriter ) { $ objWriter -> startElement ( 'c:printSettings' ) ; $ objWriter -> startElement ( 'c:headerFooter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageMargins' ) ; $ objWriter -> writeAttribute ( 'footer' , 0.3 ) ; $ objWriter -> writeAttribute ( 'header' , 0.3 ) ; $ objWriter -> writeAttribute ( 'r' , 0.7 ) ; $ objWriter -> writeAttribute ( 'l' , 0.7 ) ; $ objWriter -> writeAttribute ( 't' , 0.75 ) ; $ objWriter -> writeAttribute ( 'b' , 0.75 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageSetup' ) ; $ objWriter -> writeAttribute ( 'orientation' , 'portrait' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
2331	public function fetchEach ( $ strKey ) { $ this -> reset ( ) ; $ return = array ( ) ; while ( $ this -> next ( ) ) { $ strPk = $ this -> current ( ) -> getPk ( ) ; if ( $ strKey != 'id' && isset ( $ this -> $ strPk ) ) { $ return [ $ this -> $ strPk ] = $ this -> $ strKey ; } else { $ return [ ] = $ this -> $ strKey ; } } return $ return ; }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
10830	public static function file ( string $ path ) : fs \ entity \ FileEntity { return ( new fs \ entity \ FileEntity ( $ path ) ) -> normalize ( ) ; }
4576	public function get ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = static :: toModel ( $ object ) ; return $ model ; }
11879	public static function getTrace ( ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Trace du contexte' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; $ nb = count ( $ trace ) ; for ( $ i = 1 ; $ i < $ nb ; $ i ++ ) { if ( $ i < $ nb - 1 ) { $ dump .= static :: getContext ( $ trace [ $ i ] , $ trace [ $ i + 1 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ $ i ] ) ; } } $ dump .= static :: getFooter ( ) ; return $ dump ; }
4939	public function setAllowedTypes ( $ types ) { if ( is_array ( $ types ) ) { $ types = implode ( ',' , $ types ) ; } return $ this -> setAttribute ( 'data-allowedtypes' , $ types ) ; }
7293	public function save_transit_posts ( $ new_status , $ old_status , $ post ) { $ this -> transit_posts [ $ post -> ID ] = array ( 'old_status' => $ old_status , 'new_status' => $ new_status ) ; }
5980	public function socialmedia ( ) { if ( ! $ this -> socialmedia instanceof SocialmediaController ) { $ this -> socialmedia = new SocialmediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> socialmedia -> setLogger ( $ this -> logger ) ; } return $ this -> socialmedia ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
5621	protected function chompScheme ( & $ url ) { if ( preg_match ( '#^([^/:]*):(//)(.*)#' , $ url , $ matches ) ) { $ url = $ matches [ 2 ] . $ matches [ 3 ] ; return $ matches [ 1 ] ; } return false ; }
4183	public function fileHas ( $ contains ) { $ this -> files = ( new ClassIterator ( $ this -> finder -> contains ( $ contains ) ) ) -> getClassMap ( ) ; $ this -> count = count ( $ this -> files ) ; return $ this ; }
6062	public function download ( $ id , $ template = null , $ templateType = 'image' , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template , 'templateType' => $ templateType ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/download' , $ parameters , $ cachePolicy ) ; $ tmpFile = tmpfile ( ) ; if ( false === fwrite ( $ tmpFile , $ result ) ) { throw new \ RuntimeException ( 'Could not write download data to temporary file!' ) ; } if ( false === fseek ( $ tmpFile , 0 ) ) { throw new \ RuntimeException ( 'Could not reset file pointer of temporary file!' ) ; } $ result = $ tmpFile ; return $ result ; }
8104	public function query ( $ sql , $ arguments = false ) { if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt ; } }
5734	public function getLeagueMatches ( int $ leagueID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'stage' => '' , 'status' => '' , 'matchday' => '' , 'group' => '' ] ) { $ leagueMatches = $ this -> run ( "v2/competitions/{$leagueID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagueMatches -> matches ) ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
4888	public function gotoAction ( Request $ r ) { return $ this -> redirect ( $ this -> get ( 'zicht_url.provider' ) -> url ( $ this -> getPageManager ( ) -> findForView ( $ r -> get ( 'id' ) ) ) ) ; }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
12790	public static function createView ( string $ actionName , ? string $ ctrlName = null ) : ? View { $ viewsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'views' ) ; $ addPath = '' ; if ( ! empty ( $ ctrlName ) ) { $ addPath .= \ DIRECTORY_SEPARATOR . strtolower ( $ ctrlName ) ; } $ viewFile = $ viewsRoot . $ addPath . \ DIRECTORY_SEPARATOR . strtolower ( $ actionName ) . '.php' ; if ( is_readable ( $ viewFile ) ) { return new View ( $ viewFile ) ; } return null ; }
3350	private function __getPath ( $ type , $ params = array ( ) ) { switch ( $ type ) { case 'root' : return '/' ; case 'account' : return '/account/' ; case 'file_list' : return '/files/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'file_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/storage/' , $ params [ 'uuid' ] ) ; case 'file_copy' : return '/files/' ; case 'files_storage' : return '/files/storage/' ; case 'file' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/files/%s/' , $ params [ 'uuid' ] ) ; case 'group_list' : return '/groups/' . $ this -> __getQueryString ( $ params , '?' ) ; case 'group' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/' , $ params [ 'uuid' ] ) ; case 'group_storage' : if ( array_key_exists ( 'uuid' , $ params ) == false ) { throw new \ Exception ( 'Please provide "uuid" param for request' ) ; } return sprintf ( '/groups/%s/storage/' , $ params [ 'uuid' ] ) ; default : throw new \ Exception ( 'No api url type is provided for request "' . $ type . '". Use store, or appropriate constants.' ) ; } }
7649	public function stream_flush ( ) { $ result = fflush ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } return $ result ; }
11650	protected function _authenticateValidateResult ( $ resultIdentity ) { $ code = Zend_Auth_Result :: FAILURE_CREDENTIAL_INVALID ; $ message = 'Supplied credential is invalid.' ; if ( Benri_Util_String :: verifyPassword ( $ this -> _credential , $ resultIdentity [ $ this -> _credentialColumn ] ) ) { $ code = Zend_Auth_Result :: SUCCESS ; $ message = 'Authentication successful.' ; $ this -> _resultRow = $ resultIdentity ; } $ this -> _authenticateResultInfo [ 'code' ] = $ code ; $ this -> _authenticateResultInfo [ 'messages' ] [ ] = $ message ; return $ this -> _authenticateCreateAuthResult ( ) ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
11839	public static function convert2Jpeg ( $ inputImg , $ savePath = null , $ quality = null , array $ exifData = null ) { $ retval = false ; $ img = self :: imgCreate ( $ inputImg ) ; $ imgSize = self :: size ( $ img ) ; $ jpegImg = imagecreatetruecolor ( $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; imagecopy ( $ jpegImg , $ img , 0 , 0 , 0 , 0 , $ imgSize [ 0 ] , $ imgSize [ 1 ] ) ; if ( null === $ quality ) $ quality = self :: IMG_QUALITY ; if ( null !== $ exifData && array_key_exists ( 'Orientation' , $ exifData ) ) { $ ort = $ exifData [ 'Orientation' ] ; switch ( $ ort ) { default : case 1 : break ; case 2 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; break ; case 3 : $ jpegImg = self :: rotateImage ( $ jpegImg , 180 ) ; break ; case 4 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; break ; case 5 : $ jpegImg = self :: flipImage ( $ jpegImg , 2 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 6 : $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 7 : $ jpegImg = self :: flipImage ( $ jpegImg , 1 ) ; $ jpegImg = self :: rotateImage ( $ jpegImg , 90 ) ; break ; case 8 : $ jpegImg = self :: rotateImage ( $ jpegImg , 270 ) ; break ; } } if ( null === $ savePath ) $ retval = $ jpegImg ; else $ retval = imagejpeg ( $ jpegImg , $ savePath , $ quality ) ; return $ retval ; }
1432	public function allow ( string ... $ params ) : self { $ this -> all = false ; foreach ( $ params as $ param ) { $ this -> allowed -> put ( $ param , $ param ) ; } return $ this ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
4104	protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; }
903	public function isLambda ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; if ( $ startParenthesisToken -> isGivenKind ( CT :: T_RETURN_REF ) ) { $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ startParenthesisIndex ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; } return $ startParenthesisToken -> equals ( '(' ) ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
5857	protected function localize ( $ input ) { if ( TYPO3_MODE === 'FE' ) { $ output = is_object ( $ GLOBALS [ 'TSFE' ] ) ? $ GLOBALS [ 'TSFE' ] -> sL ( $ input ) : $ input ; } else { $ output = $ GLOBALS [ 'LANG' ] -> sL ( $ input ) ; } return $ output ; }
3196	public function getConsumedExtraTime ( $ tags = null , $ maxTime = 0 , $ target = TimePoint :: TARGET_SERVER ) { if ( $ maxTime ) { $ totalConsumed = $ this -> compute ( $ tags , $ target ) ; $ consumedExtraTime = $ totalConsumed - $ maxTime < 0 ? 0 : $ totalConsumed - $ maxTime ; $ this -> setConsumedExtraTime ( $ consumedExtraTime ) -> save ( ) ; } return $ this -> consumedExtraTime ; }
11024	protected function buildGroupBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_groupby as $ grp ) { $ result [ ] = $ grp [ 0 ] ? $ grp [ 1 ] : $ this -> quote ( $ grp [ 1 ] ) ; } return $ result ; }
9056	private function changeColumns ( ) : void { $ change = [ ] ; foreach ( $ this -> oldColumns as $ name => $ column ) { if ( $ this -> columnExists ( $ name ) ) { $ change [ ] = "[$name] $column" ; } } if ( ! empty ( $ change ) ) { $ this -> connection -> query ( "ALTER TABLE %table CHANGE " . implode ( ', CHANGE ' , $ change ) , $ this -> name ) ; } }
8091	static public function examine ( $ hash ) { if ( strlen ( $ hash ) == 40 && preg_match ( "/^[0-9]{4}/" , $ hash ) ) { $ e_uid_pos = substr ( $ hash , 0 , 2 ) ; $ e_uid_length = substr ( $ hash , 2 , 2 ) ; $ e_uid = substr ( $ hash , $ e_uid_pos , $ e_uid_length ) ; $ uid = self :: decode ( $ e_uid ) ; preg_match ( '/^([0-9]{4})(.{2,' . ( $ e_uid_pos - 4 ) . '})(' . $ e_uid . ')/' , $ hash , $ excerpt ) ; $ partial = $ excerpt [ 2 ] ; return array ( $ uid , $ partial ) ; } else { return array ( false , false ) ; } }
9244	private function __loadConfigFiles ( ) { $ additionalConfigs = $ this -> config ( 'additionalConfigFiles' ) ; foreach ( $ additionalConfigs as $ additionalConfig ) { Configure :: load ( $ additionalConfig ) ; } }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
12720	public function callInstance ( $ instance , $ args = [ ] ) { $ args = ( is_array ( $ args ) ? $ args : array_slice ( func_get_args ( ) , 1 ) ) ; $ current = $ this -> make ( $ instance ) ; return call_user_func_array ( $ current , $ args ) ; }
11077	public function getHttpAdapter ( ) { if ( null === $ this -> httpAdapter ) { $ this -> httpAdapter = new Curl ( ) ; $ this -> httpAdapter -> setOptions ( array ( 'sslverifypeer' => false , ) ) ; } return $ this -> httpAdapter ; }
4746	public function isReviewOptInError ( ) { $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; return $ review -> isReviewOptInError ( ) ; }
3821	private function getReferer ( Request $ request , $ table , $ encodeAmp = false ) { $ uri = $ this -> systemAdapter -> getReferer ( $ encodeAmp , $ table ) ; if ( ! preg_match ( '@^https?://@i' , $ uri ) ) { $ uri = $ request -> getBasePath ( ) . '/' . ltrim ( $ uri , '/' ) ; } return $ uri ; }
8092	static public function decode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( '/[1][a-zA-Z]|[2-9]|[a-zA-Z]|[0]/' , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { $ f = preg_match ( '/1([a-zA-Z])/' , $ i , $ v ) ; if ( $ f == true ) { $ i = $ o + array_search ( $ v [ 1 ] , $ k ) ; } else { $ i = array_search ( $ i , $ k ) ; } $ n .= $ i ; } return $ n ; }
12238	public function innerHTML ( ) { $ dom = dom_import_simplexml ( $ this ) ; $ doc = $ dom -> ownerDocument ; $ html = '' ; foreach ( $ dom -> childNodes as $ child ) { $ html .= ( $ child instanceof DOMText ) ? $ child -> textContent : $ doc -> saveXML ( $ child ) ; } return $ html ; }
9564	protected function makeFatalErrorException ( ) { $ error = error_get_last ( ) ; if ( $ error !== null ) { return new FatalErrorException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ; } return null ; }
10820	public static function warning ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'warning' , $ length , $ separator ) ; }
442	public function hasEventHandlers ( $ name ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( ! empty ( $ handlers ) && StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { return true ; } } return ! empty ( $ this -> _events [ $ name ] ) || Event :: hasHandlers ( $ this , $ name ) ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
12897	public function to ( string $ path , int $ status = 301 , array $ headers = array ( ) ) { return $ this -> makeRedirect ( $ path , $ status , $ headers ) ; }
12531	public function getStatus ( $ applyId ) { $ params = [ 'apply_id' => intval ( $ applyId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYSTATUS , $ params ] ) ; }
11614	public function update ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
884	private function getBestDelimiter ( $ pattern ) { $ delimiters = [ ] ; foreach ( self :: $ delimiters as $ k => $ d ) { if ( false === strpos ( $ pattern , $ d ) ) { return $ d ; } $ delimiters [ $ d ] = [ substr_count ( $ pattern , $ d ) , $ k ] ; } uasort ( $ delimiters , static function ( $ a , $ b ) { if ( $ a [ 0 ] === $ b [ 0 ] ) { return Utils :: cmpInt ( $ a , $ b ) ; } return $ a [ 0 ] < $ b [ 0 ] ? - 1 : 1 ; } ) ; return key ( $ delimiters ) ; }
2580	protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
6877	private function buildRevenueData ( array $ result , $ detailed = false ) { $ data = [ ] ; foreach ( $ result as $ r ) { $ data [ $ r [ 'date' ] ] = $ detailed ? json_decode ( $ r [ 'details' ] , true ) : $ r [ 'revenue' ] ; } return $ data ; }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
5445	protected function addSkipping ( ) { $ this -> mapHandler ( 'css' , 'ignore' ) ; $ this -> addEntryPattern ( '<style' , 'text' , 'css' ) ; $ this -> addExitPattern ( '</style>' , 'css' ) ; $ this -> mapHandler ( 'js' , 'ignore' ) ; $ this -> addEntryPattern ( '<script' , 'text' , 'js' ) ; $ this -> addExitPattern ( '</script>' , 'js' ) ; $ this -> mapHandler ( 'comment' , 'ignore' ) ; $ this -> addEntryPattern ( '<!--' , 'text' , 'comment' ) ; $ this -> addExitPattern ( ' , 'comment' ) ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10873	public function cleanUser ( string $ validate = null ) : int { $ result = 0 ; if ( $ validate ) { $ validateTo = new DateTime ; $ validateTo -> modify ( $ validate ) ; $ list = $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.active' => false , $ this -> tableName [ 0 ] . '.added IS NOT NULL' , [ $ this -> tableName [ 0 ] . '.added<=%dt' , $ validateTo ] , ] ) ; foreach ( $ list as $ item ) { if ( $ this -> delete ( $ item [ self :: COLUMN_ID ] ) ) { $ result ++ ; } } } return $ result ; }
186	protected function renderStrike ( $ element ) { return Console :: ansiFormat ( $ this -> parseInline ( $ this -> renderAbsy ( $ element [ 1 ] ) ) , [ Console :: CROSSED_OUT ] ) ; }
10266	public function setRotation ( $ pValue ) { if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'rotation' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> rotation = $ pValue ; } return $ this ; }
3081	protected function buildOptions ( RunnerServiceContext $ context ) { $ session = $ context -> getTestSession ( ) ; $ options = [ 'allowComment' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowComment ( $ session ) , 'allowSkipping' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowSkipping ( $ session ) , 'exitButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowExit ( $ session , $ context ) , 'logoutButton' => \ taoQtiTest_helpers_TestRunnerUtils :: doesAllowLogout ( $ session ) , 'validateResponses' => \ taoQtiTest_helpers_TestRunnerUtils :: doesValidateResponses ( $ session ) , 'sectionPause' => $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> couldBePaused ( $ session ) ] ; $ categories = $ this -> getCategories ( $ context ) ; $ prefixCategory = 'x-tao-option-' ; $ prefixCategoryLen = strlen ( $ prefixCategory ) ; foreach ( $ categories as $ category ) { if ( ! strncmp ( $ category , $ prefixCategory , $ prefixCategoryLen ) ) { $ optionName = lcfirst ( str_replace ( ' ' , '' , ucwords ( strtr ( substr ( $ category , $ prefixCategoryLen ) , [ '-' => ' ' , '_' => ' ' ] ) ) ) ) ; $ options [ $ optionName ] = true ; } } return $ options ; }
9025	public function hasUrl ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( preg_match ( "/\b(?:(?:https?|ftp):\/\/|www\.)[-a-z0-9+&@#\/%?=~_|!:,.;]*[-a-z0-9+&@#\/%=~_|]/i" , $ word ) ) { $ result = true ; } } return $ result ; }
10052	private function resolvePath ( $ path_alias , $ file_name ) { $ path = \ Yii :: getAlias ( $ path_alias , false ) ; $ path = $ path ? realpath ( $ path ) : $ path ; $ file_name = ! preg_match ( '/\.php$/i' , $ file_name ) ? $ file_name . '.php' : $ file_name ; if ( ! $ path || ! is_dir ( $ path ) || ! file_exists ( $ path . '/' . $ file_name ) ) { throw new Exception ( "Faker template \"{$path}/{$file_name}\" not found" ) ; } return $ path . '/' . $ file_name ; }
6988	protected function finalize ( ContextInterface $ context ) : ContextInterface { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ this -> customerGroupRepository -> findDefault ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { $ context -> setInvoiceCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getDeliveryCountry ( ) ) { $ context -> setDeliveryCountry ( $ this -> countryProvider -> getCountry ( ) ) ; } if ( null === $ context -> getCurrency ( ) ) { $ context -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } if ( null === $ context -> getLocale ( ) ) { $ context -> setLocale ( $ this -> localProvider -> getCurrentLocale ( ) ) ; } if ( null === $ context -> getVatDisplayMode ( ) ) { if ( null !== $ mode = $ context -> getCustomerGroup ( ) -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } else { $ context -> setVatDisplayMode ( $ this -> defaultVatDisplayMode ) ; } } $ this -> eventDispatcher -> dispatch ( ContextEvents :: BUILD , new ContextEvent ( $ context ) ) ; return $ context ; }
9340	public function load ( $ directory ) { $ configurations = glob ( $ directory . '/*.php' ) ; foreach ( $ configurations as $ configuration ) { $ items = require $ configuration ; $ name = basename ( $ configuration , '.php' ) ; $ this -> data = array_merge ( $ this -> data , array ( $ name => $ items ) ) ; } return $ this -> data ; }
691	protected function isActive ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; if ( empty ( $ this -> only ) ) { $ onlyMatch = true ; } else { $ onlyMatch = false ; foreach ( $ this -> only as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ onlyMatch = true ; break ; } } } $ exceptMatch = false ; foreach ( $ this -> except as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { $ exceptMatch = true ; break ; } } return ! $ exceptMatch && $ onlyMatch ; }
8632	public function setReportRequestInfoList ( $ reportRequestInfo ) { if ( ! $ this -> _isNumericArray ( $ reportRequestInfo ) ) { $ reportRequestInfo = array ( $ reportRequestInfo ) ; } $ this -> fields [ 'ReportRequestInfo' ] [ 'FieldValue' ] = $ reportRequestInfo ; return $ this ; }
6682	private function setSecurityHeaders ( ) { $ headers = Yii :: $ app -> response -> headers ; $ headers -> add ( 'X-Frame-Options' , 'DENY' ) ; $ headers -> add ( 'X-XSS-Protection' , '1' ) ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
5577	public function clickImage ( $ label , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectByLabel ( $ label ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectByLabel ( $ label ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
4967	public function fromPost ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getPost ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getPost ( $ param , $ default ) ; }
7155	private function nullDateIfLowerThanToday ( \ DateTime $ eda = null ) { if ( null === $ eda ) { return null ; } $ today = new \ DateTime ( ) ; $ today -> setTime ( 0 , 0 , 0 ) ; if ( $ eda < $ today ) { return null ; } return $ eda ; }
336	protected function findConstraints ( $ table ) { $ sql = <<<'SQL'SELECT /*+ PUSH_PRED(C) PUSH_PRED(D) PUSH_PRED(E) */ D.CONSTRAINT_NAME, D.CONSTRAINT_TYPE, C.COLUMN_NAME, C.POSITION, D.R_CONSTRAINT_NAME, E.TABLE_NAME AS TABLE_REF, F.COLUMN_NAME AS COLUMN_REF, C.TABLE_NAMEFROM ALL_CONS_COLUMNS C INNER JOIN ALL_CONSTRAINTS D ON D.OWNER = C.OWNER AND D.CONSTRAINT_NAME = C.CONSTRAINT_NAME LEFT JOIN ALL_CONSTRAINTS E ON E.OWNER = D.R_OWNER AND E.CONSTRAINT_NAME = D.R_CONSTRAINT_NAME LEFT JOIN ALL_CONS_COLUMNS F ON F.OWNER = E.OWNER AND F.CONSTRAINT_NAME = E.CONSTRAINT_NAME AND F.POSITION = C.POSITIONWHERE C.OWNER = :schemaName AND C.TABLE_NAME = :tableNameORDER BY D.CONSTRAINT_NAME, C.POSITIONSQL ; $ command = $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ] ) ; $ constraints = [ ] ; foreach ( $ command -> queryAll ( ) as $ row ) { if ( $ this -> db -> slavePdo -> getAttribute ( \ PDO :: ATTR_CASE ) === \ PDO :: CASE_LOWER ) { $ row = array_change_key_case ( $ row , CASE_UPPER ) ; } if ( $ row [ 'CONSTRAINT_TYPE' ] === 'P' ) { $ table -> columns [ $ row [ 'COLUMN_NAME' ] ] -> isPrimaryKey = true ; $ table -> primaryKey [ ] = $ row [ 'COLUMN_NAME' ] ; if ( empty ( $ table -> sequenceName ) ) { $ table -> sequenceName = $ this -> getTableSequenceName ( $ table -> name ) ; } } if ( $ row [ 'CONSTRAINT_TYPE' ] !== 'R' ) { continue ; } $ name = $ row [ 'CONSTRAINT_NAME' ] ; if ( ! isset ( $ constraints [ $ name ] ) ) { $ constraints [ $ name ] = [ 'tableName' => $ row [ 'TABLE_REF' ] , 'columns' => [ ] , ] ; } $ constraints [ $ name ] [ 'columns' ] [ $ row [ 'COLUMN_NAME' ] ] = $ row [ 'COLUMN_REF' ] ; } foreach ( $ constraints as $ constraint ) { $ name = current ( array_keys ( $ constraint ) ) ; $ table -> foreignKeys [ $ name ] = array_merge ( [ $ constraint [ 'tableName' ] ] , $ constraint [ 'columns' ] ) ; } }
6636	protected function initLanguages ( ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } if ( ! isset ( Yii :: $ app -> wavecms ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Component "wavecms" not defined in config.php' ) ) ; if ( ! count ( Yii :: $ app -> wavecms -> languages ) ) throw new InvalidConfigException ( Yii :: t ( 'wavecms/main' , 'Property "languages" is not defined in config file for component "wavecms"' ) ) ; if ( ! Yii :: $ app -> session -> get ( 'editedLanguage' ) ) { Yii :: $ app -> session -> set ( 'editedLanguage' , Yii :: $ app -> wavecms -> languages [ 0 ] ) ; } Yii :: $ app -> wavecms -> editedLanguage = Yii :: $ app -> session -> get ( 'editedLanguage' ) ; }
4051	private function buildConditionTree ( array $ conditions ) : array { $ conditionMap = [ ] ; $ bySetting = [ ] ; foreach ( $ conditions as $ condition ) { unset ( $ converted ) ; if ( array_key_exists ( $ condition [ 'id' ] , $ conditionMap ) ) { $ converted = & $ conditionMap [ $ condition [ 'id' ] ] ; foreach ( $ condition as $ key => $ value ) { $ converted [ $ key ] = $ value ; } } else { $ converted = \ array_slice ( $ condition , 0 ) ; $ conditionMap [ $ condition [ 'id' ] ] = & $ converted ; } if ( empty ( $ condition [ 'pid' ] ) ) { $ bySetting [ $ condition [ 'settingId' ] ] [ ] = & $ converted ; continue ; } if ( ! isset ( $ conditionMap [ $ condition [ 'pid' ] ] ) ) { $ temp = [ 'children' => [ ] ] ; $ conditionMap [ $ condition [ 'pid' ] ] = & $ temp ; } $ conditionMap [ $ condition [ 'pid' ] ] [ 'children' ] [ ] = & $ converted ; } return $ bySetting ; }
11582	private function getPublicRequireDefinition ( ContainerBuilder $ container , $ id , $ type ) { $ serviceDefinition = $ container -> getDefinition ( $ id ) ; if ( ! $ serviceDefinition -> isPublic ( ) ) { throw new InvalidArgumentException ( sprintf ( 'The service "%s" must be public as block %s are lazy-loaded.' , $ id , $ type ) ) ; } return $ serviceDefinition ; }
168	protected static function loadMimeAliases ( $ aliasesFile ) { if ( $ aliasesFile === null ) { $ aliasesFile = static :: $ mimeAliasesFile ; } $ aliasesFile = Yii :: getAlias ( $ aliasesFile ) ; if ( ! isset ( self :: $ _mimeAliases [ $ aliasesFile ] ) ) { self :: $ _mimeAliases [ $ aliasesFile ] = require $ aliasesFile ; } return self :: $ _mimeAliases [ $ aliasesFile ] ; }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
7503	public function tf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { $ this -> view -> out ( $ this -> getTf ( $ key , $ args , $ replacements , ... $ namespaces ) ) ; }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
3113	public function setStoreId ( $ testSessionId , $ storeId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> setStoreId ( $ storeId ) ; $ extendedState -> save ( ) ; }
738	protected function saveItems ( ) { $ items = [ ] ; foreach ( $ this -> items as $ name => $ item ) { $ items [ $ name ] = array_filter ( [ 'type' => $ item -> type , 'description' => $ item -> description , 'ruleName' => $ item -> ruleName , 'data' => $ item -> data , ] ) ; if ( isset ( $ this -> children [ $ name ] ) ) { foreach ( $ this -> children [ $ name ] as $ child ) { $ items [ $ name ] [ 'children' ] [ ] = $ child -> name ; } } } $ this -> saveToFile ( $ items , $ this -> itemFile ) ; }
3371	private function visitAssociation ( $ className , $ association = null ) { if ( null === $ association ) { if ( isset ( $ this -> visitedAssociations [ $ className ] ) ) { return false ; } $ this -> visitedAssociations [ $ className ] = [ ] ; return true ; } if ( isset ( $ this -> visitedAssociations [ $ className ] [ $ association ] ) ) { return false ; } if ( ! isset ( $ this -> visitedAssociations [ $ className ] ) ) { $ this -> visitedAssociations [ $ className ] = [ ] ; } $ this -> visitedAssociations [ $ className ] [ $ association ] = true ; return true ; }
5856	public function initializeRulesets ( array $ configuration ) { $ general = $ configuration ; $ general [ 'usergroup' ] = '' ; unset ( $ general [ 'rulesets' ] ) ; $ general = $ this -> expandValuesInRuleset ( $ general ) ; if ( $ general [ 'conversion_mapping' ] === '' ) { $ general [ 'conversion_mapping' ] = [ ] ; } if ( isset ( $ configuration [ 'rulesets' ] ) ) { $ rulesets = $ this -> compileRuleSets ( $ configuration [ 'rulesets' ] ) ; } else { $ rulesets = [ ] ; } foreach ( $ rulesets as $ k => & $ ruleset ) { foreach ( $ general as $ key => $ value ) { if ( ! isset ( $ ruleset [ $ key ] ) ) { $ ruleset [ $ key ] = $ value ; } elseif ( $ ruleset [ $ key ] === '' ) { $ ruleset [ $ key ] = $ value ; } } if ( count ( $ ruleset [ 'usergroup' ] ) == 0 ) { $ ruleset [ 'directories' ] = array_diff ( $ ruleset [ 'directories' ] , $ general [ 'directories' ] ) ; if ( count ( $ ruleset [ 'directories' ] ) == 0 ) { unset ( $ rulesets [ $ k ] ) ; } } } $ rulesets [ ] = $ general ; $ this -> rulesets = $ rulesets ; }
7540	function index ( $ count_all = true ) { if ( ! $ this -> parent ) { return - 1 ; } elseif ( $ count_all ) { return $ this -> parent -> findChild ( $ this ) ; } else { $ index = - 1 ; foreach ( array_keys ( $ this -> parent -> children ) as $ k ) { if ( ! $ this -> parent -> children [ $ k ] -> isTextOrComment ( ) ) { ++ $ index ; } if ( $ this -> parent -> children [ $ k ] === $ this ) { return $ index ; } } return - 1 ; } }
12607	public static function makeSafe ( $ file ) { $ regex = [ '#(\.){2,}#' , '#[^A-Za-z0-9\.\_\- ]#' , '#^\.#' , ] ; $ file = rtrim ( $ file , '.' ) ; $ clean = preg_replace ( $ regex , ' ' , $ file ) ; $ clean = preg_replace ( "/[ \_]/" , '-' , $ clean ) ; $ clean = preg_replace ( "/[\-]+/" , '-' , $ clean ) ; return $ clean ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
3660	private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; }
7067	protected function getAccountingFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof AccountingInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . AccountingInterface :: class ) ; } return $ resource ; }
794	public function activeAttributes ( ) { $ scenario = $ this -> getScenario ( ) ; $ scenarios = $ this -> scenarios ( ) ; if ( ! isset ( $ scenarios [ $ scenario ] ) ) { return [ ] ; } $ attributes = array_keys ( array_flip ( $ scenarios [ $ scenario ] ) ) ; foreach ( $ attributes as $ i => $ attribute ) { if ( $ attribute [ 0 ] === '!' ) { $ attributes [ $ i ] = substr ( $ attribute , 1 ) ; } } return $ attributes ; }
4095	protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; ob_start ( ) ; curl_exec ( $ conn ) ; $ response = ob_get_clean ( ) ; if ( $ response !== false ) { $ data = json_decode ( $ response , true ) ; if ( ! $ data ) { $ data = array ( 'error' => $ response , "code" => curl_getinfo ( $ conn , CURLINFO_HTTP_CODE ) ) ; } } else { $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; }
2483	protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
11290	protected function _getModels ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = [ ] ; if ( $ relatedObjName ) { if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelsFromTableColumn ( $ attributeName , $ relatedObjName , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelsFromCustomRelationship ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } else { $ result = $ this -> _getModelsFromRelationTable ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } } if ( $ result == null ) { $ this -> $ attributeName = new \ Cora \ Collection ( ) ; $ result = $ this -> model_data [ $ attributeName ] ; } return $ result ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
10370	public static function add ( $ type , $ data = [ ] ) { $ is_admin = is_admin ( ) ; if ( self :: validate ( $ type , $ data , $ is_admin ) ) { $ hook = $ is_admin ? 'admin_enqueue_scripts' : 'wp_enqueue_scripts' ; $ method = __CLASS__ . "::add_{$type}s" ; if ( has_action ( $ hook , $ method ) === false ) { add_action ( $ hook , $ method ) ; } return true ; } return false ; }
5322	public function lockExecute ( callable $ callable ) { $ this -> isAcquired = $ this -> acquire ( ) ; $ result = $ callable ( ) ; $ this -> isAcquired = $ this -> release ( ) ; return $ result ; }
9541	private function decodeResponse ( Response $ response ) { $ data = json_decode ( $ response -> getBody ( ) -> read ( $ response -> getBody ( ) -> getSize ( ) ) , true ) ; if ( json_last_error ( ) !== JSON_ERROR_NONE ) { throw new ClientException ( 'Unable to parse response body into JSON: ' . json_last_error ( ) ) ; } return $ data === null ? array ( ) : $ data ; }
5269	private function translateSelect ( ) { $ build = array ( 'select' ) ; if ( $ this -> found_rows ) { $ build [ ] = 'SQL_CALC_FOUND_ROWS' ; } if ( $ this -> distinct ) { $ build [ ] = 'distinct' ; } $ build [ ] = ! empty ( $ this -> statements [ 'select' ] ) && is_array ( $ this -> statements [ 'select' ] ) ? join ( ', ' , $ this -> statements [ 'select' ] ) : '*' ; $ build [ ] = 'from ' . $ this -> table ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> statements [ 'groups' ] ) ) { $ build [ ] = 'group by ' . join ( ', ' , $ this -> statements [ 'groups' ] ) ; if ( ! empty ( $ this -> statements [ 'having' ] ) ) { $ build [ ] = $ this -> statements [ 'having' ] ; } } if ( ! empty ( $ this -> statements [ 'orders' ] ) ) { $ build [ ] = $ this -> translateOrderBy ( ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
6502	public function parseQueryString ( Uri $ uri ) : IImmutableDictionary { if ( ( $ queryString = $ uri -> getQueryString ( ) ) === null ) { return new ImmutableHashTable ( [ ] ) ; } if ( ! isset ( $ this -> parsedQueryStringCache [ $ queryString ] ) ) { $ parsedQueryString = [ ] ; parse_str ( $ queryString , $ parsedQueryString ) ; $ kvps = [ ] ; foreach ( $ parsedQueryString as $ key => $ value ) { $ kvps [ ] = new KeyValuePair ( $ key , $ value ) ; } $ this -> parsedQueryStringCache [ $ queryString ] = new ImmutableHashTable ( $ kvps ) ; } return $ this -> parsedQueryStringCache [ $ queryString ] ; }
2954	protected function findTemplate ( $ text ) { $ matchedTemplate = [ ] ; $ maxMatch = - 1 ; foreach ( $ this -> directoryIterator as $ fileInfo ) { $ templateContent = file_get_contents ( $ fileInfo -> getPathname ( ) ) ; similar_text ( $ text , $ templateContent , $ matchPercentage ) ; if ( $ matchPercentage > $ maxMatch ) { $ this -> logger -> debug ( sprintf ( 'Template "%s" is a best match for now' , $ fileInfo -> getPathname ( ) ) ) ; $ maxMatch = $ matchPercentage ; $ matchedTemplate = [ $ fileInfo -> getPathname ( ) => $ templateContent ] ; } } return $ matchedTemplate ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
10305	private function recursiveReplace ( $ path ) { $ patterns = [ '/*.md' , '/*.php' , '/*.phtml' , '/*.txt' , '/*.TXT' , ] ; $ from = array_keys ( $ this -> getMapping ( ) ) ; $ to = array_values ( $ this -> getMapping ( ) ) ; foreach ( $ patterns as $ pattern ) { foreach ( glob ( $ path . $ pattern ) as $ file ) { $ original = file_get_contents ( $ file ) ; $ converted = str_replace ( $ from , $ to , $ original ) ; if ( $ original !== $ converted ) { echo $ file . " converted\n" ; file_put_contents ( $ file , $ converted ) ; } } } foreach ( glob ( $ path . '/*' , GLOB_ONLYDIR ) as $ subpath ) { if ( strpos ( $ subpath , $ path . '/' ) === 0 ) { $ this -> recursiveReplace ( $ subpath ) ; } } }
1400	public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; }
7527	private function nest ( $ x , $ node , $ end = false ) { array_push ( $ x -> stmtStack , $ node ) ; $ n = $ this -> statement ( $ x ) ; array_pop ( $ x -> stmtStack ) ; if ( $ end ) $ this -> t -> mustMatch ( $ end ) ; return $ n ; }
12946	protected function parseTags ( $ tags ) { return array_unique ( is_array ( $ tags ) ? array_filter ( $ tags ) : preg_split ( '/\s*,\s*/' , $ tags , - 1 , PREG_SPLIT_NO_EMPTY ) ) ; }
7001	public function method ( $ method = null ) { if ( $ method ) $ this -> method = trim ( $ method ) ; return $ this -> method ; }
8962	private static function extractArrayCriteria ( $ key , array $ criteria ) { if ( ! empty ( $ criteria [ $ key ] ) ) { return array ( $ criteria [ $ key ] ) ; } if ( ! empty ( $ criteria [ $ key . 's' ] ) ) { return $ criteria [ $ key . 's' ] ; } return array ( ) ; }
1236	public function attachment ( $ data = null , $ mimeType = 'application/octet-stream' ) { if ( $ data !== null ) { if ( is_array ( $ data ) ) { $ this -> attachment [ 'data' ] = array_key_exists ( 'data' , $ data ) ? $ data [ 'data' ] : null ; $ this -> attachment [ 'mimeType' ] = array_key_exists ( 'mimeType' , $ data ) ? $ data [ 'mimeType' ] : 'application/octet-stream' ; } else { $ this -> attachment [ 'data' ] = $ data ; $ this -> attachment [ 'mimeType' ] = $ mimeType ; } } return $ this -> attachment ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
1231	public function resolveOptions ( array $ configuration ) { foreach ( $ configuration as $ key => $ value ) { if ( isset ( $ this -> definitions [ $ key ] ) ) { $ def = $ this -> definitions [ $ key ] ; $ this -> checkType ( $ def [ 'valid' ] , $ key , $ value ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ configuration [ $ key ] , $ configuration ) ; } } } return $ configuration ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
3715	public function addKnownAttributeType ( $ typeName ) { if ( ! is_array ( $ this -> attributeTypes ) ) { throw new \ LogicException ( 'Filter setting ' . $ this -> typeClass . ' can not handle attributes.' ) ; } $ this -> attributeTypes [ $ typeName ] = $ typeName ; return $ this ; }
11396	private static function _setFileNameInErrorFile ( ) { if ( defined ( 'BASH_CALLED' ) ) { error_log ( Bash :: setColor ( '############### ' . BASH_CALLED . ' ###############' , 'cyan' ) ) ; } else { if ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ) { error_log ( Bash :: setColor ( '############### ' . $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] . ' ###############' , 'cyan' ) ) ; } } }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
8379	public function getNested ( $ keyString , $ default = null , $ separator = '.' ) { $ keys = explode ( $ separator , $ keyString ) ; $ data = $ this -> array ; foreach ( $ keys as $ key ) { if ( ! is_array ( $ data ) or ! array_key_exists ( $ key , $ data ) ) { return $ default ; } $ data = $ data [ $ key ] ; } return $ data ; }
10051	private function resolveVisibleFields ( ) { $ result = [ ] ; $ columns = $ this -> model -> getColumns ( ) ; foreach ( $ columns as $ column ) { $ result [ ] = $ column -> getName ( ) ; } return $ result ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
12657	public function deleteTextContainer ( $ name ) { foreach ( $ this -> languages as $ lang ) { $ this -> getPageTexts ( $ lang ) ; unset ( $ this -> contents [ $ lang ] [ $ name ] ) ; $ this -> writeTextsToFile ( $ lang ) ; } }
9415	public function precision ( $ n ) { if ( ! is_numeric ( $ n ) || $ n < 0 ) { throw new \ InvalidArgumentException ( 'Precision must be positive number' ) ; } $ this -> int_precision = ( integer ) $ n ; }
12725	public function format ( $ event ) { $ output = $ this -> format ; if ( array_key_exists ( 'extra' , $ event ) === true ) { $ this -> formatExtra ( $ event , $ event [ 'extra' ] ) ; $ event [ 'message' ] = 'Missing Key:' ; } else { $ event [ 'extra' ] = [ ] ; } foreach ( $ event as $ name => $ value ) { if ( is_array ( $ value ) === true && count ( $ value ) === 0 ) { $ value = '' ; } else { $ value = $ this -> normalize ( $ value ) ; } $ output = str_replace ( '%' . $ name . '%' , $ value , $ output ) ; } return trim ( $ output ) ; }
342	public static function validateMultiple ( $ models , $ attributes = null ) { $ result = [ ] ; foreach ( $ models as $ i => $ model ) { $ model -> validate ( $ attributes ) ; foreach ( $ model -> getErrors ( ) as $ attribute => $ errors ) { $ result [ Html :: getInputId ( $ model , "[$i]" . $ attribute ) ] = $ errors ; } } return $ result ; }
11714	public function getTokenFromServer ( ) { $ params = [ 'appid' => $ this -> appId , 'secret' => $ this -> secret , 'grant_type' => 'client_credential' , ] ; $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJSON ( $ http -> get ( self :: API_TOKEN_GET , $ params ) ) ; if ( empty ( $ token [ $ this -> tokenJsonKey ] ) ) { throw new HttpException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
8759	public function postUpload ( Request $ request ) { $ input = $ request -> all ( ) ; $ response = $ this -> uploadRepository -> upload ( $ input ) ; return $ response ; }
2353	protected function fputs ( $ varData , $ strMode ) { if ( ! \ is_resource ( $ this -> resFile ) ) { $ this -> strTmp = 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ; if ( strncmp ( $ strMode , 'a' , 1 ) === 0 && file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { $ this -> Files -> copy ( $ this -> strFile , $ this -> strTmp ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strTmp , $ strMode ) ) { return false ; } } fwrite ( $ this -> resFile , $ varData ) ; return true ; }
6042	public function session ( $ sourceId , $ sessionHash , $ remoteIp , $ userAgent , $ userId = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sourceId' => $ sourceId , 'sessionHash' => $ sessionHash , 'remoteIp' => $ remoteIp , 'userAgent' => $ userAgent , 'userId' => $ userId ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/session' , $ parameters ) ; return $ result ; }
6645	public static function formatPhoneNumberToInternationalFormat ( $ countryCode , $ number , $ numberLength ) { $ actualNumber = substr ( $ number , - ( $ numberLength ) , $ numberLength ) ; if ( ! $ actualNumber ) { return $ number ; } return '+' . $ countryCode . $ actualNumber ; }
1367	protected function bootBladeDirectives ( ) { $ compiler = $ this -> app -> make ( BladeCompiler :: class ) ; $ compiler -> directive ( 'jsonapi' , Renderer :: class . '::compileWith' ) ; $ compiler -> directive ( 'encode' , Renderer :: class . '::compileEncode' ) ; }
5485	public function hasImage ( SelectorInterface $ selector ) { foreach ( $ this -> images as $ image ) { if ( $ selector -> isMatch ( $ image ) ) { return true ; } } return false ; }
10886	protected function startSession ( Request $ request , $ sessionId ) { return tap ( $ this -> getSession ( $ sessionId ) , function ( $ session ) use ( $ request ) { $ session -> setRequestOnHandler ( $ request ) ; $ session -> start ( ) ; } ) ; }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
1938	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> newsletters ) || ! \ is_array ( $ this -> User -> newsletters ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> newsletters ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_newsletter_channel' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_newsletter_channel' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, newsletters, newsletterp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objGroup -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT newsletters, newsletterp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrNewsletterp = Contao \ StringUtil :: deserialize ( $ objUser -> newsletterp ) ; if ( \ is_array ( $ arrNewsletterp ) && \ in_array ( 'create' , $ arrNewsletterp ) ) { $ arrNewsletters = Contao \ StringUtil :: deserialize ( $ objUser -> newsletters , true ) ; $ arrNewsletters [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET newsletters=? WHERE id=?" ) -> execute ( serialize ( $ arrNewsletters ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> newsletter = $ root ; } }
3720	protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; }
8805	protected function driver ( ) { if ( $ this -> getDefaultDriver ( ) === 'argon' ) { return $ this -> createArgonDriver ( ) ; } elseif ( $ this -> getDefaultDriver ( ) === 'argon2id' ) { return $ this -> createArgon2IdDriver ( ) ; } return $ this -> createBcryptDriver ( ) ; }
10579	private function codesEqual ( string $ known , string $ given ) : bool { if ( strlen ( $ given ) !== strlen ( $ known ) ) { return false ; } $ res = 0 ; $ knownLen = strlen ( $ known ) ; for ( $ i = 0 ; $ i < $ knownLen ; ++ $ i ) { $ res |= ( ord ( $ known [ $ i ] ) ^ ord ( $ given [ $ i ] ) ) ; } return $ res === 0 ; }
11067	protected function compileMixins ( ) { $ sql = array ( ) ; foreach ( $ this -> mixins as $ mixin ) { $ compiled = $ this -> { $ mixin } -> compile ( ) ; if ( $ compiled !== "" ) { $ sql [ ] = $ compiled ; } } return $ sql ; }
2552	private function getStringBetween ( $ string , $ start , $ end ) { $ startPos = strpos ( $ string , $ start ) + strlen ( $ start ) ; $ endPos = strlen ( $ string ) - strpos ( $ string , $ end ) ; return substr ( $ string , $ startPos , - $ endPos ) ; }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
11583	public function exchangeArray ( $ array ) { return $ this -> setId ( isset ( $ array [ 'id' ] ) ? $ array [ 'id' ] : null ) -> setAutenticacaoId ( $ array [ 'autenticacao_id' ] ) -> setValor ( $ array [ 'valor' ] ) -> setData ( isset ( $ array [ 'data' ] ) ? $ array [ 'data' ] : null ) ; }
11827	public function getBom ( $ encoding = 'UTF-8' ) { $ boms = array ( 'UTF-8' => pack ( 'CCC' , 0xef , 0xbb , 0xbf ) , 'UTF-16 Big Endian' => pack ( 'CC' , 0xfe , 0xff ) , 'UTF-16 Little Endian' => pack ( 'CC' , 0xff , 0xfe ) , 'UTF-32 Big Endian' => pack ( 'CCCC' , 0x00 , 0x00 , 0xfe , 0xff ) , 'UTF-32 Little Endian' => pack ( 'CCCC' , 0xff , 0xfe , 0x00 , 0x00 ) , 'SCSU' => pack ( 'CCC' , 0x0e , 0xfe , 0xff ) , 'UTF-7 (1)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x38 ) , 'UTF-7 (2)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x39 ) , 'UTF-7 (3)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2b ) , 'UTF-7 (4)' => pack ( 'CCCC' , 0x2b , 0x2f , 0x76 , 0x2f ) , 'UTF-7 (5)' => pack ( 'CCCCC' , 0x2b , 0x2f , 0x76 , 0x38 , 0x2d ) , 'UTF-1' => pack ( 'CCC' , 0xF7 , 0x64 , 0x4c ) , 'UTF-EBCDIC' => pack ( 'CCCC' , 0xdd , 0x73 , 0x66 , 0x73 ) , 'BOCU-1' => pack ( 'CCC' , 0xfb , 0xee , 0x28 ) , 'GB-18030' => pack ( 'CCCC' , 0x84 , 0x31 , 0x95 , 0x33 ) , ) ; if ( 'all' == $ encoding ) { return $ boms ; } return $ boms [ $ encoding ] ; }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
3769	public function collectAttributeSettings ( IMetaModel $ metaModel , $ renderSetting ) { $ attributeRows = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' ) -> setParameter ( 'pid' , $ renderSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ attributeRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ attributeRow ) { $ attribute = $ metaModel -> getAttributeById ( $ attributeRow [ 'attr_id' ] ) ; if ( ! $ attribute ) { continue ; } $ attributeSetting = $ renderSetting -> getSetting ( $ attribute -> getColName ( ) ) ; if ( ! $ attributeSetting ) { $ attributeSetting = $ attribute -> getDefaultRenderSettings ( ) ; } foreach ( $ attributeRow as $ strKey => $ varValue ) { if ( $ varValue ) { $ attributeSetting -> set ( $ strKey , StringUtil :: deserialize ( $ varValue ) ) ; } } $ renderSetting -> setSetting ( $ attribute -> getColName ( ) , $ attributeSetting ) ; } }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
11871	public function buildForm ( FormBuilderInterface $ builder , CustomField $ customField ) { $ options = $ customField -> getOptions ( ) ; $ type = ( $ options [ self :: MAX_LENGTH ] < 256 ) ? 'text' : 'textarea' ; $ attrArray = array ( ) ; if ( array_key_exists ( self :: MULTIPLE_CF_INLINE , $ options ) and $ options [ self :: MULTIPLE_CF_INLINE ] ) { $ attrArray [ 'class' ] = 'multiple-cf-inline' ; } $ builder -> add ( $ customField -> getSlug ( ) , $ type , array ( 'label' => $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) , 'required' => false , 'attr' => $ attrArray ) ) ; }
5257	public static function search ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ model = static :: createInstance ( ) ; return $ model -> _dal -> search ( $ query ) ; }
10252	public function getLastName ( $ max = 250 ) { return LastName :: where ( 'rank' , '<=' , $ max ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; }
3292	public function twitter ( ) { if ( is_null ( $ this -> title ) ) { $ this -> title = config ( 'laravel-share.services.twitter.text' ) ; } $ base = config ( 'laravel-share.services.twitter.uri' ) ; $ url = $ base . '?text=' . urlencode ( $ this -> title ) . '&url=' . $ this -> url ; $ this -> buildLink ( 'twitter' , $ url ) ; return $ this ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
6495	public function visitPage ( $ path , $ code = 200 ) { if ( ! $ this -> assertStatusCode ( $ path , $ code ) ) { throw new \ Exception ( sprintf ( 'The page "%s" is not accessible!' , $ path ) ) ; } self :: debug ( [ 'Visited page: %s' ] , [ $ path ] ) ; $ this -> visitPath ( $ path ) ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
7827	public function getSpacedPipe ( $ pipe , $ arrow , $ method ) { $ left = $ this -> getSpacesByWord ( $ pipe ) ; $ arrow = $ this -> addSpacesToArrow ( $ arrow ) ; $ right = $ this -> getSpacesByWord ( $ method ) ; return $ left . $ pipe . $ arrow . $ method . $ right ; }
7924	public function extract ( $ zipFile , $ targetPath ) { $ zipArchive = $ this -> openZipFile ( $ zipFile ) ; $ targetPath = $ this -> fixPath ( $ targetPath ) ; $ filenames = $ this -> extractFilenames ( $ zipArchive ) ; if ( $ zipArchive -> extractTo ( $ targetPath , $ filenames ) === false ) { throw new \ Exception ( $ this -> getError ( $ zipArchive -> status ) ) ; } $ zipArchive -> close ( ) ; return $ filenames ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
2822	protected function _afterLoad ( ) { $ info = $ this -> getUnserializedInfo ( ) ; $ this -> logging = $ info [ 'logging' ] ; $ this -> action = $ info [ 'action' ] ; $ this -> design = $ info [ 'design' ] ; $ this -> blocks = $ info [ 'blocks' ] ; $ this -> models = $ info [ 'models' ] ; $ this -> collections = $ info [ 'collections' ] ; $ this -> queries = $ info [ 'queries' ] ; $ this -> timers = $ info [ 'timers' ] ; $ this -> emails = $ info [ 'emails' ] ; return parent :: _afterLoad ( ) ; }
834	private function getFunctionyTokenKinds ( ) { static $ tokens = [ T_ARRAY , T_ECHO , T_EMPTY , T_EVAL , T_EXIT , T_INCLUDE , T_INCLUDE_ONCE , T_ISSET , T_LIST , T_PRINT , T_REQUIRE , T_REQUIRE_ONCE , T_UNSET , T_VARIABLE , ] ; return $ tokens ; }
3478	public function withBodyLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> body = '' ; $ cloned -> bodyLocalized = $ localized ; return $ cloned ; }
11351	public function submit ( Request $ request ) { $ this -> isConfirmed = false ; if ( $ this -> formTags [ 'method' ] == 'post' && $ request -> getType ( ) == 'POST' ) { $ this -> isConfirmed = true ; } $ query = $ request -> getQuery ( ) ; if ( count ( $ this -> fields ) > 0 && $ this -> formTags [ 'method' ] == 'get' && isset ( $ query [ $ this -> fields [ 0 ] -> getName ( ) ] ) ) { $ this -> isConfirmed = true ; } if ( ! $ this -> isConfirmed ) return ; if ( $ this -> formTags [ 'method' ] == 'post' ) { $ storage = $ request -> getData ( ) ; } else { $ storage = $ request -> getQuery ( ) ; } $ result = [ ] ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ storage [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ storage [ $ field -> getName ( ) ] ) ; } else if ( $ field instanceof FileField ) { try { $ field -> setData ( $ request -> getFile ( $ field -> getName ( ) ) ) ; } catch ( FileNotUploadedException $ e ) { $ field -> setData ( '' ) ; } } else if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) && isset ( $ storage [ $ result [ 1 ] ] ) ) { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ value = $ storage [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ value [ $ deep ] ) ) { $ value = null ; break ; } $ value = $ value [ $ deep ] ; } if ( $ result [ 2 ] == '' ) { } else { $ field -> setData ( $ value ) ; } } else { $ field -> setData ( null ) ; } } if ( $ request -> isFullUploadedData ( ) ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getValidator ( ) ) { if ( $ error = $ field -> getValidator ( ) -> validate ( $ field -> getData ( ) ) ) { $ field -> setError ( $ error ) ; } } } } else { foreach ( $ this -> fields as $ field ) { $ field -> setError ( 'Request data is too large.' ) ; } } }
12680	public function hasFlag ( $ name ) { $ option = $ this -> definition -> getOption ( $ name ) ; if ( ! $ option -> isFlag ( ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The "--%s" option is not a flag.' , $ name ) ) ; } return ! empty ( $ this -> options [ $ name ] ) ; }
6295	private function parseThemeInfo ( array $ info ) { $ themeInfo = new ThemeInfo ( ) ; $ required = [ 'name' , 'author' , 'directory' ] ; foreach ( $ required as $ key ) { if ( ! array_key_exists ( $ key , $ info ) ) { throw new ThemeInfoAttributeException ( $ key ) ; } } $ themeInfo -> setName ( $ info [ 'name' ] ) ; $ themeInfo -> setAuthor ( $ info [ 'author' ] ) ; $ themeInfo -> setDirectory ( strtolower ( $ info [ 'directory' ] ) ) ; if ( isset ( $ info [ 'description' ] ) ) { $ themeInfo -> setDescription ( $ info [ 'description' ] ) ; } if ( isset ( $ info [ 'version' ] ) ) { $ themeInfo -> setVersion ( $ info [ 'version' ] ) ; } if ( isset ( $ info [ 'parent' ] ) ) { $ themeInfo -> setParent ( $ info [ 'parent' ] ) ; } $ themeInfo -> setPath ( $ this -> findPath ( $ info [ 'directory' ] ) ) ; return $ themeInfo ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
12626	public function post ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'POST' , $ url , array ( 'form_params' => $ data ) ) ; }
8014	protected function prepareCommand ( $ filename , $ saveToFile , $ pdfIsTemp = false ) { $ resultIsTemp = false ; $ command = new Command ( ) ; $ command -> setPdfFile ( $ filename , $ pdfIsTemp ) ; if ( $ saveToFile === null ) { $ saveToFile = tempnam ( sys_get_temp_dir ( ) , 'pdfbox' ) ; $ resultIsTemp = true ; } $ command -> setTextFile ( $ saveToFile , $ resultIsTemp ) ; return $ command ; }
1896	private function purgeOldFiles ( string $ webDir ) : void { if ( file_exists ( $ webDir . '/app_dev.php' ) ) { $ this -> fs -> remove ( $ webDir . '/app_dev.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/app_dev.php</comment> file.' ) ; } if ( file_exists ( $ webDir . '/install.php' ) ) { $ this -> fs -> remove ( $ webDir . '/install.php' ) ; $ this -> io -> writeln ( 'Deleted the <comment>web/install.php</comment> file.' ) ; } }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
3561	protected function getMutatedType ( $ value , $ dir = 'setter' ) { foreach ( $ this -> { "{$dir}Mutators" } as $ mutated => $ mutator ) { if ( $ this -> getValueType ( $ value ) == $ mutated || $ value instanceof $ mutated ) { return $ mutated ; } } }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
6838	public function mapDatas ( $ kvs ) { foreach ( $ kvs as $ k => $ v ) { $ this -> mapData ( $ k , $ v ) ; } }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
11768	public function updateSentinels ( ) { SENTINEL_QUERY : { $ sentinel = $ this -> getSentinelConnection ( ) ; try { $ payload = $ sentinel -> executeCommand ( RawCommand :: create ( 'SENTINEL' , 'sentinels' , $ this -> service ) ) ; $ this -> sentinels = array ( ) ; $ this -> sentinels [ ] = $ sentinel -> getParameters ( ) -> toArray ( ) ; foreach ( $ payload as $ sentinel ) { $ this -> sentinels [ ] = array ( 'host' => $ sentinel [ 3 ] , 'port' => $ sentinel [ 5 ] , 'role' => 'sentinel' , ) ; } } catch ( ConnectionException $ exception ) { $ this -> sentinelConnection = null ; goto SENTINEL_QUERY ; } } }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
7354	protected function getUrl ( $ name , $ subject , $ path ) { if ( $ subject instanceof SubjectRelativeInterface ) { if ( null === $ subject = $ this -> resolve ( $ subject , false ) ) { return null ; } } if ( ! $ subject instanceof SubjectInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SubjectInterface :: class ) ; } $ event = new SubjectUrlEvent ( $ subject , $ path ) ; $ this -> eventDispatcher -> dispatch ( $ name , $ event ) ; return $ event -> getUrl ( ) ; }
10294	public static function excelToTimestamp ( $ excelTimestamp , $ timeZone = null ) { return ( int ) self :: excelToDateTimeObject ( $ excelTimestamp , $ timeZone ) -> format ( 'U' ) ; }
8115	public function advanceReviewDate ( ) { $ nextDateTimestamp = false ; $ options = $ this -> getOptions ( ) ; if ( $ options && $ options -> ReviewPeriodDays ) { $ nextDateTimestamp = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextDateTimestamp ) -> Format ( DBDate :: ISO_DATE ) ; $ this -> owner -> write ( ) ; } return ( bool ) $ nextDateTimestamp ; }
4918	public function setParam ( $ key , $ value ) { if ( $ this -> has ( $ key ) ) { $ this -> get ( $ key ) -> setValue ( $ value ) ; } else { $ this -> add ( [ 'type' => 'hidden' , 'name' => $ key , 'attributes' => [ 'value' => $ value ] ] ) ; } return $ this ; }
9786	public function parseEscape ( ) { $ token = $ this -> pop ( 'ESCAPE' ) ; $ value = $ this -> stripQuotes ( $ token [ 1 ] ) ; $ this -> currLine += substr_count ( $ value , "\n" ) ; return '$output .= \'' . $ value . "';\n" ; }
1834	public static function findByPk ( $ varValue , array $ arrOptions = array ( ) ) { if ( empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varValue ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => static :: $ strPk , 'value' => $ varValue , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
10306	public function setLineStyleProperties ( $ line_width = null , $ compound_type = null , $ dash_type = null , $ cap_type = null , $ join_type = null , $ head_arrow_type = null , $ head_arrow_size = null , $ end_arrow_type = null , $ end_arrow_size = null ) { ( $ line_width !== null ) ? $ this -> lineStyleProperties [ 'width' ] = $ this -> getExcelPointsWidth ( ( float ) $ line_width ) : null ; ( $ compound_type !== null ) ? $ this -> lineStyleProperties [ 'compound' ] = ( string ) $ compound_type : null ; ( $ dash_type !== null ) ? $ this -> lineStyleProperties [ 'dash' ] = ( string ) $ dash_type : null ; ( $ cap_type !== null ) ? $ this -> lineStyleProperties [ 'cap' ] = ( string ) $ cap_type : null ; ( $ join_type !== null ) ? $ this -> lineStyleProperties [ 'join' ] = ( string ) $ join_type : null ; ( $ head_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'type' ] = ( string ) $ head_arrow_type : null ; ( $ head_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'head' ] [ 'size' ] = ( string ) $ head_arrow_size : null ; ( $ end_arrow_type !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'type' ] = ( string ) $ end_arrow_type : null ; ( $ end_arrow_size !== null ) ? $ this -> lineStyleProperties [ 'arrow' ] [ 'end' ] [ 'size' ] = ( string ) $ end_arrow_size : null ; }
1750	public static function log ( $ strText , $ strFunction , $ strCategory ) { @ trigger_error ( 'Using System::log() has been deprecated and will no longer work in Contao 5.0. Use the logger service instead.' , E_USER_DEPRECATED ) ; $ level = 'ERROR' === $ strCategory ? LogLevel :: ERROR : LogLevel :: INFO ; $ logger = static :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ logger -> log ( $ level , $ strText , array ( 'contao' => new ContaoContext ( $ strFunction , $ strCategory ) ) ) ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
11230	public function get ( $ section , array $ params = [ ] , $ headers = [ ] ) { $ params = array_merge ( $ this -> parameters , $ params , $ this -> defaultParameters ) ; return $ this -> client -> get ( $ this -> getUrl ( $ section , $ params ) , $ headers ) ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
8636	public function setShipmentFeeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentFeeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5608	public function after ( $ method ) { $ this -> invoker -> after ( $ method ) ; $ output = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( $ output !== '' ) { $ result = $ this -> listener -> write ( '{status:"info",message:"' . EclipseReporter :: escapeVal ( $ output ) . '"}' ) ; } }
8800	public function needsRehash ( $ hashedValue , array $ options = [ ] ) { return password_needs_rehash ( $ hashedValue , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; }
3195	public function setConsumedExtraTime ( $ time ) { $ this -> consumedExtraTime = max ( $ this -> consumedExtraTime , floatval ( $ time ) ) ; return $ this ; }
8067	public function run ( $ input ) { while ( $ this -> workerPoolSize > 0 ) { try { $ processDetailsOfFreeWorker = $ this -> getNextFreeWorker ( ) ; $ processDetailsOfFreeWorker -> getSocket ( ) -> send ( array ( 'cmd' => 'run' , 'data' => $ input ) ) ; return $ processDetailsOfFreeWorker -> getPid ( ) ; } catch ( \ Exception $ e ) { pcntl_signal_dispatch ( ) ; } } throw new WorkerPoolException ( 'Unable to run the task.' ) ; }
3607	protected function getTableNames ( ) { $ schemas = DB :: getConfig ( 'used_schemas' ) ? : [ DB :: getConfig ( 'schema' ) ] ; $ schemaCount = count ( $ schemas ) ; $ binds = implode ( ',' , array_fill ( 0 , $ schemaCount , '?' ) ) ; return collect ( DB :: select ( "SELECT schemaname || '.' || tablename AS table FROM pg_catalog.pg_tables WHERE schemaname IN (" . $ binds . ')' , $ schemas ) ) -> pluck ( 'table' ) -> reject ( function ( $ value , $ key ) { $ tableName = explode ( '.' , $ value ) [ 1 ] ; return $ tableName === 'spatial_ref_sys' ; } ) ; }
2531	private function getStatefulStatusCode ( $ messageName , array $ messageOptions ) { if ( 'Security_Authenticate' === $ messageName ) { return self :: TRANSACTION_STATUS_CODE_START ; } if ( isset ( $ messageOptions [ 'endSession' ] ) && $ messageOptions [ 'endSession' ] === true ) { return self :: TRANSACTION_STATUS_CODE_END ; } return self :: TRANSACTION_STATUS_CODE_INSERIES ; }
9674	public function allConditionalStyles ( Spreadsheet $ spreadsheet ) { $ aStyles = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { foreach ( $ spreadsheet -> getSheet ( $ i ) -> getConditionalStylesCollection ( ) as $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditionalStyle ) { $ aStyles [ ] = $ conditionalStyle ; } } } return $ aStyles ; }
7094	private function loadItem ( Model \ SaleItemInterface $ item ) { $ item -> getAdjustments ( ) -> toArray ( ) ; $ children = $ item -> getChildren ( ) -> toArray ( ) ; foreach ( $ children as $ child ) { $ this -> loadItem ( $ child ) ; } }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
5434	protected function isStaticMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isStatic ( ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
9196	public function config ( ) { if ( ! $ this -> config ) { $ config = array ( ) ; $ configFile = $ this -> getThemesPath ( ) . DIRECTORY_SEPARATOR . $ this -> getName ( ) . DIRECTORY_SEPARATOR . 'theme.config.php' ; if ( file_exists ( $ configFile ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; $ config = include $ configFile ; restore_error_handler ( ) ; ob_get_clean ( ) ; if ( ! is_array ( $ config ) ) throw new \ Exception ( 'Invalid "' . $ this -> getName ( ) . '" Theme Config File. It must return array.' ) ; } $ this -> config = new Entity ( $ config ) ; } return $ this -> config ; }
2953	protected function extractData ( $ text , $ template ) { preg_match ( '/' . $ template . '/s' , $ text , $ matches ) ; $ keys = array_filter ( array_keys ( $ matches ) , 'is_string' ) ; $ matches = array_intersect_key ( $ matches , array_flip ( $ keys ) ) ; if ( ! empty ( $ matches ) ) { return $ this -> cleanExtractedData ( $ matches ) ; } return false ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
10226	public function noAssociationsMenuFor ( $ model , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; $ menuFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\NoAssociationsIndexMenuFactory' ) ; return $ menuFactory -> create ( $ modelName , $ config ) ; }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
9325	protected function registerMarkdown ( ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown' , function ( $ app ) { return new Converter ( $ app [ 'commonmark.docparser' ] , $ app [ 'commonmark.htmlrenderer' ] ) ; } ) ; $ app -> alias ( 'markdown' , Converter :: class ) ; }
10197	public function writeStringTable ( array $ pStringTable ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'sst' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'uniqueCount' , count ( $ pStringTable ) ) ; foreach ( $ pStringTable as $ textElement ) { $ objWriter -> startElement ( 'si' ) ; if ( ! $ textElement instanceof RichText ) { $ textToWrite = StringHelper :: controlCharacterPHP2OOXML ( $ textElement ) ; $ objWriter -> startElement ( 't' ) ; if ( $ textToWrite !== trim ( $ textToWrite ) ) { $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; } $ objWriter -> writeRawData ( $ textToWrite ) ; $ objWriter -> endElement ( ) ; } elseif ( $ textElement instanceof RichText ) { $ this -> writeRichText ( $ objWriter , $ textElement ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
8588	public function setASINPrepInstructions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ASINPrepInstructions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
8562	public function createShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_CreateShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_CreateShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_CreateShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10282	public static function splitRange ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ exploded = explode ( ',' , $ pRange ) ; $ counter = count ( $ exploded ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ exploded [ $ i ] = explode ( ':' , $ exploded [ $ i ] ) ; } return $ exploded ; }
125	public function whatProvides ( $ name , ConstraintInterface $ constraint = null , $ mustMatchName = false , $ bypassFilters = false ) { if ( $ bypassFilters ) { return $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , true ) ; } $ key = ( ( int ) $ mustMatchName ) . $ constraint ; if ( isset ( $ this -> providerCache [ $ name ] [ $ key ] ) ) { return $ this -> providerCache [ $ name ] [ $ key ] ; } return $ this -> providerCache [ $ name ] [ $ key ] = $ this -> computeWhatProvides ( $ name , $ constraint , $ mustMatchName , $ bypassFilters ) ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9369	protected function resolve ( ContainerInterface $ container , ServerRequestInterface $ request , ResponseInterface $ response ) { if ( class_exists ( 'Zend\Diactoros\ServerRequestFactory' ) ) { $ response = new ZendResponse ; $ request = ServerRequestFactory :: fromGlobals ( ) ; } $ container -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ container -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
11483	public function getFactory ( $ class , array $ params = array ( ) ) { if ( ! isset ( $ this -> factories [ $ class ] ) && $ this -> autowire ) { $ this -> factories [ $ class ] = Definition :: getDefaultForClass ( $ class ) ; } $ factory = $ this -> factories [ $ class ] ; if ( $ params ) { $ factory = $ factory -> getFactory ( $ params ) ; } return $ factory ; }
836	public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } }
11158	protected function getVideoId ( $ url ) { $ logger = $ this -> getLogger ( ) ; $ parsed = parse_url ( $ url ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'parsed' => $ parsed ) ) ; switch ( $ parsed [ 'host' ] ) { case 'youtu.be' : return ltrim ( $ parsed [ 'path' ] , '/' ) ; case 'www.youtube.com' : case 'youtube.com' : if ( ! empty ( $ parsed [ 'query' ] ) ) { parse_str ( $ parsed [ 'query' ] , $ query ) ; $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'query' => $ query ) ) ; if ( ! empty ( $ query [ 'v' ] ) ) { return $ query [ 'v' ] ; } } elseif ( isset ( $ parsed [ 'path' ] ) && substr ( $ parsed [ 'path' ] , 0 , 7 ) == '/embed/' ) { $ logger -> debug ( 'getVideoId' , array ( 'url' => $ url , 'path' => $ parsed [ 'path' ] ) ) ; $ vId = substr ( $ parsed [ 'path' ] , 7 ) ; if ( ! empty ( $ vId ) ) { return $ vId ; } } } return null ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
7656	function AddReplyTo ( $ address , $ name = "" ) { $ cur = count ( $ this -> ReplyTo ) ; $ this -> ReplyTo [ $ cur ] [ 0 ] = trim ( $ address ) ; $ this -> ReplyTo [ $ cur ] [ 1 ] = $ name ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
7617	public function api_request ( $ path , $ options ) { $ data = $ this -> requestHandler -> request ( $ path , $ options ) ; return json_encode ( $ data -> json ) ; }
10834	public function using ( $ column ) { if ( $ this -> active_join === null ) { throw new \ Peyote \ Exception ( "You need to start a join before calling \Peyote\Join::using()" ) ; } list ( $ table , $ type ) = $ this -> active_join ; $ this -> active_join = null ; $ this -> joins [ ] = array ( "USING" , $ table , $ type , $ column ) ; return $ this ; }
10222	public function authenticationForm ( $ title , $ target ) { $ formFactory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\AuthenticationFormFactory' ) ; return $ formFactory -> create ( $ title , $ target ) ; }
8552	public function setServiceFeeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceFeeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12801	public function createItem ( $ name , array $ options = array ( ) ) { if ( ! empty ( $ options [ 'admin' ] ) ) { $ admin = $ options [ 'admin' ] ; if ( ! $ options [ 'admin' ] instanceof AdminInterface ) { $ admin = $ this -> container -> get ( 'sonata.admin.pool' ) -> getAdminByAdminCode ( $ admin ) ; } $ action = isset ( $ options [ 'admin_action' ] ) ? $ options [ 'admin_action' ] : 'list' ; $ options [ 'uri' ] = $ admin -> generateUrl ( $ action ) ; $ options [ 'translationDomain' ] = $ admin -> getTranslationDomain ( ) ; } if ( ! empty ( $ options [ 'route' ] ) ) { $ params = isset ( $ options [ 'routeParameters' ] ) ? $ options [ 'routeParameters' ] : array ( ) ; $ absolute = isset ( $ options [ 'routeAbsolute' ] ) ? $ options [ 'routeAbsolute' ] : false ; $ options [ 'uri' ] = $ this -> generator -> generate ( $ options [ 'route' ] , $ params , $ absolute ) ; } $ item = new MenuItem ( $ name , $ this ) ; $ options = array_merge ( array ( 'uri' => null , 'label' => null , 'attributes' => array ( ) , 'linkAttributes' => array ( ) , 'childrenAttributes' => array ( ) , 'labelAttributes' => array ( ) , 'extras' => array ( ) , 'display' => true , 'displayChildren' => true , 'translationDomain' => 'messages' , 'displayLink' => true , 'displayLabel' => true , ) , $ options ) ; $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setExtras ( $ options [ 'extras' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) -> setTranslationDomain ( $ options [ 'translationDomain' ] ) -> setDisplayLink ( $ options [ 'displayLink' ] ) -> setDisplayLabel ( $ options [ 'displayLabel' ] ) ; return $ item ; return parent :: createItem ( $ name , $ options ) ; }
8595	public function getServiceStatus ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetServiceStatus' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_GetServiceStatusResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
8762	public function upload ( $ input ) { $ validator = \ Validator :: make ( $ input , config ( 'dropzoner.validator' ) , config ( 'dropzoner.validator-messages' ) ) ; if ( $ validator -> fails ( ) ) { return response ( ) -> json ( [ 'error' => true , 'message' => $ validator -> messages ( ) -> first ( ) , 'code' => 400 ] , 400 ) ; } $ photo = $ input [ 'file' ] ; $ original_name = $ photo -> getClientOriginalName ( ) ; $ extension = $ photo -> getClientOriginalExtension ( ) ; $ original_name_without_extension = substr ( $ original_name , 0 , strlen ( $ original_name ) - strlen ( $ extension ) - 1 ) ; $ filename = $ this -> sanitize ( $ original_name_without_extension ) ; $ allowed_filename = $ this -> createUniqueFilename ( $ filename ) ; $ filename_with_extension = $ allowed_filename . '.' . $ extension ; $ manager = new ImageManager ( ) ; $ image = $ manager -> make ( $ photo ) -> save ( config ( 'dropzoner.upload-path' ) . $ filename_with_extension ) ; if ( ! $ image ) { return response ( ) -> json ( [ 'error' => true , 'message' => 'Server error while uploading' , 'code' => 500 ] , 500 ) ; } event ( new ImageWasUploaded ( $ original_name , $ filename_with_extension ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 , 'filename' => $ filename_with_extension ] , 200 ) ; }
12394	protected function fill ( array $ data ) { $ this -> uuid = $ data [ "uuid" ] ? : "" ; $ this -> status = $ data [ "status" ] ? : "" ; $ this -> code = $ data [ "code" ] ? : "" ; $ this -> modules = $ data [ "modules" ] ? : [ ] ; $ this -> vars = $ data [ "vars" ] ? : [ ] ; $ this -> error = $ data [ "error" ] ? : "" ; $ this -> logs = $ data [ "logs" ] ? : [ ] ; $ this -> results = $ data [ "results" ] ? : [ ] ; $ this -> duration = $ data [ "duration" ] ? : 0 ; $ this -> createdAt = $ this -> parseDate ( $ data [ "created_at" ] ) ; $ this -> startedAt = $ this -> parseDate ( $ data [ "started_at" ] ) ; $ this -> finishedAt = $ this -> parseDate ( $ data [ "finished_at" ] ) ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
10709	public function getManyPaginated ( $ perPage = null , $ columns = [ '*' ] ) { $ query = $ this -> getQuery ( ) ; $ results = $ query -> paginate ( $ perPage , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
2005	protected function validateForm ( Widget $ objWidget = null ) { $ varInput = Idna :: encodeEmail ( Input :: post ( 'email' , true ) ) ; if ( ! Validator :: isEmail ( $ varInput ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'email' ] ; return false ; } $ this -> Template -> email = $ varInput ; $ arrChannels = Input :: post ( 'channels' ) ; if ( ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ arrChannels = array_intersect ( $ arrChannels , $ this -> nl_channels ) ; if ( empty ( $ arrChannels ) || ! \ is_array ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'noChannels' ] ; return false ; } $ this -> Template -> selectedChannels = $ arrChannels ; $ arrSubscriptions = array ( ) ; if ( ( $ objSubscription = NewsletterRecipientsModel :: findBy ( array ( "email=? AND active='1'" ) , $ varInput ) ) !== null ) { $ arrSubscriptions = $ objSubscription -> fetchEach ( 'pid' ) ; } $ arrChannels = array_intersect ( $ arrChannels , $ arrSubscriptions ) ; if ( empty ( $ arrChannels ) ) { $ this -> Template -> mclass = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'unsubscribed' ] ; return false ; } if ( $ objWidget !== null ) { $ objWidget -> validate ( ) ; if ( $ objWidget -> hasErrors ( ) ) { return false ; } } return array ( $ varInput , $ arrChannels ) ; }
7820	public function store ( $ pipeline , array $ pipes ) { $ workflow = [ $ pipeline => $ pipes ] ; $ yaml = $ this -> parser -> dump ( $ workflow ) ; $ this -> files -> append ( $ this -> getSource ( ) , $ yaml ) ; }
2257	public static function addStaticUrlTo ( $ script , ContaoContext $ context = null ) { if ( preg_match ( '@^https?://@' , $ script ) ) { return $ script ; } if ( $ context === null ) { $ context = System :: getContainer ( ) -> get ( 'contao.assets.assets_context' ) ; } if ( $ strStaticUrl = $ context -> getStaticUrl ( ) ) { return $ strStaticUrl . $ script ; } return $ script ; }
8164	static public function render ( $ template , $ userData ) { if ( ! is_string ( $ template ) ) return '' ; $ path = strlen ( $ template ) <= 256 ? trim ( $ template ) : '' ; $ data = array_merge ( Tpl :: $ data , is_array ( $ userData ) ? $ userData : [ ] ) ; $ twig = TwigEnv :: instance ( ) ; if ( Str :: startsWith ( $ path , '@' ) || Str :: endsWith ( strtolower ( $ path ) , '.twig' ) ) { return $ twig -> renderPath ( $ path , $ data ) ; } return $ twig -> renderString ( $ template , $ data ) ; }
1437	public static function classify ( $ value ) { if ( isset ( self :: $ classified [ $ value ] ) ) { return self :: $ classified [ $ value ] ; } $ converted = ucwords ( str_replace ( [ '-' , '_' ] , ' ' , $ value ) ) ; return self :: $ classified [ $ value ] = str_replace ( ' ' , '' , $ converted ) ; }
1190	protected function isRemoteRule ( $ rule ) { return in_array ( $ rule , $ this -> serverRules ) || ! in_array ( $ rule , $ this -> clientRules ) ; }
4817	public function insertRowBefore ( $ rowNumber , $ row = null ) { if ( $ rowNumber > count ( $ this -> collection ) ) { $ this -> appendRow ( $ row ) ; } else { $ singleRow = $ row ; if ( ! ( $ row instanceof Row ) ) { $ singleRow = new Row ( $ row ) ; } array_splice ( $ this -> collection , $ rowNumber , 0 , '' ) ; $ this -> collection [ $ rowNumber ] = $ singleRow ; } }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
2229	public function dragFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return '<button type="button" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '" ' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</button> ' ; }
5048	protected function callPlugin ( $ name , $ args ) { $ controller = $ this -> getController ( ) ; $ plugin = $ controller -> plugin ( $ name ) ; unset ( $ args [ 'as' ] ) ; array_push ( $ args , $ this -> parameters ) ; return call_user_func_array ( $ plugin , $ args ) ; }
2103	public function hasOldDatabase ( ) : bool { if ( ! $ this -> hasTable ( 'tl_layout' ) ) { return false ; } $ sql = $ this -> connection -> getDatabasePlatform ( ) -> getListTableColumnsSQL ( 'tl_layout' , $ this -> connection -> getDatabase ( ) ) ; $ columns = $ this -> connection -> fetchAll ( $ sql ) ; foreach ( $ columns as $ column ) { if ( 'sections' === $ column [ 'Field' ] ) { return ! \ in_array ( $ column [ 'Type' ] , [ 'varchar(1022)' , 'blob' ] , true ) ; } } return false ; }
9789	public function setBottomRightPosition ( $ cell , $ xOffset = null , $ yOffset = null ) { $ this -> bottomRightCellRef = $ cell ; if ( $ xOffset !== null ) { $ this -> setBottomRightXOffset ( $ xOffset ) ; } if ( $ yOffset !== null ) { $ this -> setBottomRightYOffset ( $ yOffset ) ; } return $ this ; }
546	protected function getCreateTableSql ( $ table ) { $ row = $ this -> db -> createCommand ( 'SHOW CREATE TABLE ' . $ this -> quoteTableName ( $ table -> fullName ) ) -> queryOne ( ) ; if ( isset ( $ row [ 'Create Table' ] ) ) { $ sql = $ row [ 'Create Table' ] ; } else { $ row = array_values ( $ row ) ; $ sql = $ row [ 1 ] ; } return $ sql ; }
2711	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } else { $ authItems = $ this -> api -> dictionaryItemsList ( $ dictionary -> id ) ; if ( is_array ( $ authItems ) && empty ( $ authItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Basic Authentication cannot be enabled because there are no users assigned to it.' ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
12782	public function getAll ( ) { if ( is_null ( $ this -> intersections ) ) { $ this -> intersections = [ ] ; if ( $ this -> arraysSize >= 2 ) { $ this -> createIntersections ( ) ; } } return $ this -> intersections ; }
2248	public static function addToUrl ( $ strRequest , $ blnAddRef = true , $ arrUnset = array ( ) ) { $ query = new Query ( Environment :: get ( 'queryString' ) ) ; $ query = $ query -> withoutPairs ( array_merge ( array ( 'rt' , 'ref' ) , $ arrUnset ) ) ; $ query = $ query -> merge ( str_replace ( '&amp;' , '&' , $ strRequest ) ) ; if ( isset ( $ _GET [ 'ref' ] ) || ( $ strRequest != '' && $ blnAddRef ) ) { $ query = $ query -> merge ( 'ref=' . System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) ) ; } $ uri = $ query -> getUriComponent ( ) ; if ( strpos ( $ strRequest , '%2B' ) !== false ) { $ uri = str_replace ( '+' , '%2B' , $ uri ) ; } return TL_SCRIPT . ampersand ( $ uri ) ; }
8852	public function getCurrentTag ( ) { $ tag = $ this -> request -> param ( "Tag" ) ; if ( $ tag ) { return $ this -> dataRecord -> Tags ( ) -> filter ( "URLSegment" , $ tag ) -> first ( ) ; } return null ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
3025	public function postRequest ( $ path , $ options , $ addApiKey ) { if ( isset ( $ options [ 'source' ] ) && is_array ( $ options [ 'source' ] ) ) { $ sources = $ options [ 'source' ] ; unset ( $ options [ 'source' ] ) ; foreach ( $ sources as $ i => $ source ) { $ options [ "source[$i]" ] = $ source ; } } $ response = $ this -> makeRequest ( 'POST' , $ path , $ options , $ addApiKey ) ; return $ this -> parseResponse ( $ response ) ; }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
7753	public function serialize ( $ data , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Serialization for the format ' . $ format . ' is not supported' ) ; } if ( false === is_object ( $ data ) ) { throw new \ Exception ( 'Only objects can be serialized' ) ; } return JsonLD :: toString ( $ this -> doSerialize ( $ data , true ) , true ) ; }
2773	public function fetchTags ( ) : array { $ output = $ this -> gitWorkingCopy -> tag ( [ 'l' => true ] ) ; $ tags = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimTags' ] , $ tags ) ; }
10213	public function getSharedComponent ( ) { switch ( $ this -> parentPropertyName ) { case 'allBorders' : case 'horizontal' : case 'inside' : case 'outline' : case 'vertical' : throw new PhpSpreadsheetException ( 'Cannot get shared component for a pseudo-border.' ) ; break ; case 'bottom' : return $ this -> parent -> getSharedComponent ( ) -> getBottom ( ) ; case 'diagonal' : return $ this -> parent -> getSharedComponent ( ) -> getDiagonal ( ) ; case 'left' : return $ this -> parent -> getSharedComponent ( ) -> getLeft ( ) ; case 'right' : return $ this -> parent -> getSharedComponent ( ) -> getRight ( ) ; case 'top' : return $ this -> parent -> getSharedComponent ( ) -> getTop ( ) ; } }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
627	public function bindParam ( $ name , & $ value , $ dataType = null , $ length = null , $ driverOptions = null ) { $ this -> prepare ( ) ; if ( $ dataType === null ) { $ dataType = $ this -> db -> getSchema ( ) -> getPdoType ( $ value ) ; } if ( $ length === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType ) ; } elseif ( $ driverOptions === null ) { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length ) ; } else { $ this -> pdoStatement -> bindParam ( $ name , $ value , $ dataType , $ length , $ driverOptions ) ; } $ this -> params [ $ name ] = & $ value ; return $ this ; }
1462	protected function getColumnValue ( $ id ) { $ value = $ this -> getQuery ( ) -> where ( $ this -> key , $ id ) -> value ( $ this -> column ) ; if ( is_null ( $ value ) ) { throw new \ OutOfRangeException ( "Cursor key {$id} does not exist or has a null value." ) ; } return $ value ; }
10515	public function inc ( $ key , $ expire = 0 ) { $ this -> getLock ( $ key ) ; $ this -> set ( $ key , ( int ) $ this -> get ( $ key ) + 1 ) ; $ this -> releaseLock ( $ key ) ; return true ; }
4727	private function getCachedSingular ( $ plural ) { $ plural = StringHelper :: strtolower ( $ plural ) ; return array_search ( $ plural , $ this -> cache ) ; }
4593	public static function replace ( string $ string , array $ data = [ ] ) : string { $ expressionLanguage = new ExpressionLanguage ; preg_match_all ( '/\%([a-z0-9_\[\]\"\.]+)\%/i' , $ string , $ matches ) ; $ placeholders = array_unique ( $ matches [ 1 ] ) ; $ translations = [ ] ; foreach ( $ placeholders as $ placeholder ) { $ translations [ '%' . $ placeholder . '%' ] = $ expressionLanguage -> evaluate ( $ placeholder , $ data ) ; } $ string = strtr ( $ string , $ translations ) ; return $ string ; }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
8066	protected function collectWorkerResults ( $ sec = 0 ) { $ this -> respawnIfRequired ( ) ; pcntl_signal_dispatch ( ) ; if ( isset ( $ this -> workerProcesses ) === FALSE ) { throw new WorkerPoolException ( 'There is no list of worker processes. Maybe you destroyed the worker pool?' , 1401179881 ) ; } $ result = SimpleSocket :: select ( $ this -> workerProcesses -> getSockets ( ) , array ( ) , array ( ) , $ sec ) ; foreach ( $ result [ 'read' ] as $ socket ) { $ processId = $ socket -> annotation [ 'pid' ] ; $ result = $ socket -> receive ( ) ; $ possibleArrayKeys = array ( 'data' , 'poolException' , 'workerException' ) ; if ( is_array ( $ result ) && count ( ( $ resultTypes = array_intersect ( array_keys ( $ result ) , $ possibleArrayKeys ) ) ) === 1 ) { $ this -> workerProcesses -> registerFreeProcessId ( $ processId ) ; $ result [ 'pid' ] = $ processId ; $ resultType = reset ( $ resultTypes ) ; if ( $ resultType !== 'data' || $ result [ 'data' ] !== NULL ) { array_push ( $ this -> results , $ result ) ; } } } pcntl_signal_dispatch ( ) ; $ this -> respawnIfRequired ( ) ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
7415	public function errorMessage ( ) : string { static $ errors = array ( UPLOAD_ERR_INI_SIZE => 'The file "%s" exceeds your upload_max_filesize ini directive (limit is %d KiB).' , UPLOAD_ERR_FORM_SIZE => 'The file "%s" exceeds the upload limit defined in your form.' , UPLOAD_ERR_PARTIAL => 'The file "%s" was only partially uploaded.' , UPLOAD_ERR_NO_FILE => 'No file was uploaded.' , UPLOAD_ERR_CANT_WRITE => 'The file "%s" could not be written on disk.' , UPLOAD_ERR_NO_TMP_DIR => 'File could not be uploaded: missing temporary directory.' , UPLOAD_ERR_EXTENSION => 'File upload was stopped by a PHP extension.' , ) ; $ errorCode = $ this -> error ; $ maxFileSize = $ errorCode === UPLOAD_ERR_INI_SIZE ? $ this -> getMaxFileSize ( ) / 1024 : 0 ; $ message = isset ( $ errors [ $ errorCode ] ) ? $ errors [ $ errorCode ] : 'The file "%s" was not uploaded due to an unknown error.' ; return sprintf ( $ message , $ this -> name , $ maxFileSize ) ; }
9978	public function request ( $ url ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ this -> timeout ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( $ response === false ) { throw new \ RuntimeException ( 'Connection timeout.' ) ; } return $ response ; }
62	public function unlink ( $ path ) { $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; if ( ! $ unlinked ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ unlinked = @ $ this -> unlinkImplementation ( $ path ) ; } if ( ! $ unlinked ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
12736	public function mapModelToLangName ( $ modelName , $ langName ) { $ modelName = $ this -> getClassName ( $ modelName ) ; $ this -> modelToLangName [ $ modelName ] = $ langName ; }
12122	public function setLastModified ( Request $ request , \ DateTime $ lastModified ) { $ this -> cache -> save ( $ this -> getCacheKeyRequest ( sha1 ( $ request -> getUri ( ) ) , 'lastmodified' ) , $ lastModified -> format ( 'r' ) ) ; foreach ( $ this -> itemIds as $ itemId => $ bool ) { $ key = $ this -> getCacheKeyItem ( $ itemId , 'uri' ) ; $ urisForItem = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) -> getOrElse ( array ( ) ) ; $ urisForItem [ $ request -> getUri ( ) ] = $ bool ; $ this -> cache -> save ( $ key , $ urisForItem ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ request , $ itemId ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" is used on "%s".' , $ itemId , $ request -> getUri ( ) ) ) ; } ) ; } }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
7008	private function format_l ( & $ str ) { if ( strstr ( $ str , '%l' ) ) $ str = str_replace ( '%l' , $ this -> dayName ( true ) , $ str ) ; }
8487	public static function getCpuFreq ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT CurrentClockSpeed FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> CurrentClockSpeed ; } return 'Unknown' ; }
3172	protected function updateStats ( & $ target , $ itemInfos ) { if ( ! isset ( $ target [ 'stats' ] ) ) { $ target [ 'stats' ] = [ 'questions' => 0 , 'answered' => 0 , 'flagged' => 0 , 'viewed' => 0 , 'total' => 0 , 'questionsViewed' => 0 , ] ; } if ( empty ( $ itemInfos [ 'informational' ] ) ) { $ target [ 'stats' ] [ 'questions' ] ++ ; if ( ! empty ( $ itemInfos [ 'answered' ] ) ) { $ target [ 'stats' ] [ 'answered' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'questionsViewed' ] ++ ; } } if ( ! empty ( $ itemInfos [ 'flagged' ] ) ) { $ target [ 'stats' ] [ 'flagged' ] ++ ; } if ( ! empty ( $ itemInfos [ 'viewed' ] ) ) { $ target [ 'stats' ] [ 'viewed' ] ++ ; } $ target [ 'stats' ] [ 'total' ] ++ ; }
1483	public function register ( AbstractProvider $ provider ) { $ this -> resolver -> attach ( $ provider -> getResolver ( ) ) ; $ this -> errors = array_replace ( $ provider -> getErrors ( ) , $ this -> errors ) ; }
222	protected function isNormalizedValueMispresented ( $ value , $ normalizedValue ) { if ( empty ( $ value ) ) { $ value = 0 ; } return ( string ) $ normalizedValue !== $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; }
12379	public function handle ( ) : void { $ help = " -----------------------------------------------------------------\n" ; $ help .= " | Command Line Interface\n" ; $ help .= " | See more in https://github.com/senhungwong/command-line-interface\n" ; $ help .= " -------------------------------------------------------------------\n" ; $ commands = CommandEntry :: getCommands ( ) ; if ( $ command = $ this -> getArgument ( 'function-name' ) ) { $ command = new $ commands [ $ command ] ; $ help .= " - " . $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } else { foreach ( $ commands as $ command ) { $ command = new $ command ; $ help .= " - " ; $ help .= $ command -> getCommand ( ) . ": " ; $ help .= $ command -> getDescription ( ) . "\n" ; } } echo $ help ; }
11476	public function authenticate ( Zend_Auth_Adapter_Interface $ adapter ) { $ result = $ adapter -> authenticate ( ) ; if ( $ this -> hasIdentity ( ) ) { $ this -> clearIdentity ( ) ; } if ( $ result -> isValid ( ) ) { $ this -> getStorage ( ) -> write ( $ adapter -> getResultRowObject ( ) ) ; } return $ result ; }
12640	public function init ( $ adapter , $ client = null ) { $ this -> adapter = $ adapter ; if ( ! $ client ) { $ client = new \ PeterColes \ Cluster \ HttpClients \ GuzzleHttp ; } $ client -> initClient ( $ this -> adapter -> getHeaders ( ) ) ; $ this -> adapter -> setClient ( $ client ) ; }
1319	private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { if ( is_bool ( $ value ) ) { $ parameters [ $ key ] = var_export ( $ value , true ) ; } } return $ parameters ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
4904	protected function createValueOptions ( NodeInterface $ node , $ allowSelectNodes = false , $ isRoot = true ) { $ key = $ isRoot ? $ node -> getValue ( ) : $ node -> getValueWithParents ( ) ; $ name = $ node -> getName ( ) ; if ( $ node -> hasChildren ( ) ) { $ leafOptions = [ ] ; if ( $ allowSelectNodes && ! $ isRoot ) { $ leafOptions [ $ key ] = $ name ; $ key = "$key-group" ; } foreach ( $ node -> getChildren ( ) as $ child ) { $ leafOptions += $ this -> createValueOptions ( $ child , $ allowSelectNodes , false ) ; } $ value = [ 'label' => $ name , 'options' => $ leafOptions ] ; } else { $ value = $ name ; } return [ $ key => $ value ] ; }
1265	public function recoverLabel ( $ trackingData , $ labelSpecification = null , $ labelDelivery = null , $ translate = null ) { if ( is_array ( $ trackingData ) ) { if ( ! isset ( $ trackingData [ 'value' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `value`.' ) ; } if ( ! isset ( $ trackingData [ 'shipperNumber' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `shipperNumber`.' ) ; } } if ( ! empty ( $ translate ) ) { if ( ! isset ( $ translateOpts [ 'language' ] ) ) { $ translateOpts [ 'language' ] = 'eng' ; } if ( ! isset ( $ translateOpts [ 'dialect' ] ) ) { $ translateOpts [ 'dialect' ] = 'US' ; } } $ request = $ this -> createRecoverLabelRequest ( $ trackingData , $ labelSpecification , $ labelDelivery , $ translate ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> recoverLabelEndpoint ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } }
10646	public function execute ( ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> getURI ( ) ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_POST , true ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> data ) ; $ response = curl_exec ( $ ch ) ; $ result = json_decode ( $ response ) ; curl_close ( $ ch ) ; if ( empty ( $ result ) || ! $ result -> success ) { throw new \ Exception ( "Pipedrive API error!" ) ; } return $ result ; }
710	public function tinyInteger ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TINYINT , $ length ) ; }
599	private function joinWithRelation ( $ parent , $ child , $ joinType ) { $ via = $ child -> via ; $ child -> via = null ; if ( $ via instanceof self ) { $ this -> joinWithRelation ( $ parent , $ via , $ joinType ) ; $ this -> joinWithRelation ( $ via , $ child , $ joinType ) ; return ; } elseif ( is_array ( $ via ) ) { $ this -> joinWithRelation ( $ parent , $ via [ 1 ] , $ joinType ) ; $ this -> joinWithRelation ( $ via [ 1 ] , $ child , $ joinType ) ; return ; } list ( $ parentTable , $ parentAlias ) = $ parent -> getTableNameAndAlias ( ) ; list ( $ childTable , $ childAlias ) = $ child -> getTableNameAndAlias ( ) ; if ( ! empty ( $ child -> link ) ) { if ( strpos ( $ parentAlias , '{{' ) === false ) { $ parentAlias = '{{' . $ parentAlias . '}}' ; } if ( strpos ( $ childAlias , '{{' ) === false ) { $ childAlias = '{{' . $ childAlias . '}}' ; } $ on = [ ] ; foreach ( $ child -> link as $ childColumn => $ parentColumn ) { $ on [ ] = "$parentAlias.[[$parentColumn]] = $childAlias.[[$childColumn]]" ; } $ on = implode ( ' AND ' , $ on ) ; if ( ! empty ( $ child -> on ) ) { $ on = [ 'and' , $ on , $ child -> on ] ; } } else { $ on = $ child -> on ; } $ this -> join ( $ joinType , empty ( $ child -> from ) ? $ childTable : $ child -> from , $ on ) ; if ( ! empty ( $ child -> where ) ) { $ this -> andWhere ( $ child -> where ) ; } if ( ! empty ( $ child -> having ) ) { $ this -> andHaving ( $ child -> having ) ; } if ( ! empty ( $ child -> orderBy ) ) { $ this -> addOrderBy ( $ child -> orderBy ) ; } if ( ! empty ( $ child -> groupBy ) ) { $ this -> addGroupBy ( $ child -> groupBy ) ; } if ( ! empty ( $ child -> params ) ) { $ this -> addParams ( $ child -> params ) ; } if ( ! empty ( $ child -> join ) ) { foreach ( $ child -> join as $ join ) { $ this -> join [ ] = $ join ; } } if ( ! empty ( $ child -> union ) ) { foreach ( $ child -> union as $ union ) { $ this -> union [ ] = $ union ; } } }
11195	public function asArray ( ) { $ result = array ( ) ; foreach ( $ this -> collection as $ response ) { $ result [ ] = $ response -> getResultAsArray ( ) ; } return $ result ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
4781	public function addWidgetConfig ( string $ widgetId , array $ config = [ ] ) { $ this -> config [ $ widgetId ] = array_merge ( $ this -> config [ $ widgetId ] ?? [ ] , $ config ) ; return $ this ; }
6587	public function setOpt ( $ name , $ value = null ) { if ( is_array ( $ name ) ) { try { $ i = 0 ; foreach ( $ name as $ opt => $ value ) { $ this -> setOpt ( $ opt , $ value ) ; ++ $ i ; } } catch ( CurlException $ e ) { throw $ e -> getCode ( ) ? $ e : new CurlException ( "Set failed at #$i: " . $ e -> getMessage ( ) ) ; } } else { try { set_error_handler ( function ( $ s , $ m , $ f , $ l , $ c = null ) use ( $ name ) { throw new CurlException ( "$m (" . CurlOptions :: name ( $ name ) . ")." ) ; } , \ E_WARNING ) ; $ this -> perform ( 'curl_setopt' , $ name , $ value ) ; } finally { restore_error_handler ( ) ; } } }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
6429	public function getLoginStartUrl ( $ redirecturl ) { $ facebook = $ this -> getFacebookObject ( ) ; $ helper = $ facebook -> getRedirectLoginHelper ( ) ; $ permissions = [ 'email' ] ; $ loginUrl = $ helper -> getLoginUrl ( $ redirecturl , $ permissions ) ; return $ loginUrl ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
7833	protected function generatePipes ( ) { foreach ( $ this -> getPipesByOption ( 'attach' ) as $ pipe ) { $ this -> currentPipe = $ pipe ; parent :: fire ( ) ; } }
6146	public function setStatusCode ( int $ value = null ) { if ( is_null ( $ value ) ) { return $ this ; } $ this -> statusCode = $ value ; return $ this ; }
74	public function requestToken ( $ originUrl , $ consumerKey , $ consumerSecret ) { if ( ! empty ( $ this -> token ) || $ this -> getTokenFromConfig ( $ originUrl ) ) { return $ this -> token [ 'access_token' ] ; } $ this -> io -> setAuthentication ( $ originUrl , $ consumerKey , $ consumerSecret ) ; if ( ! $ this -> requestAccessToken ( $ originUrl ) ) { return '' ; } $ this -> storeInAuthConfig ( $ originUrl , $ consumerKey , $ consumerSecret ) ; return $ this -> token [ 'access_token' ] ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
6296	private static function migrateConfig ( array $ config ) : array { if ( isset ( $ config [ 'class' ] ) ) { do_action ( 'inpsyde.assets.debug' , 'The asset config-format with "type" and "class" is deprecated.' , $ config ) ; $ config [ 'location' ] = $ config [ 'type' ] ?? Asset :: FRONTEND ; $ config [ 'type' ] = $ config [ 'class' ] ; unset ( $ config [ 'class' ] ) ; } return $ config ; }
12685	public function removeFromDB ( ) { if ( is_null ( $ this -> result ) ) { $ this -> fetchData ( ) ; } if ( count ( $ this -> result ) > 0 ) { if ( ! $ this -> result [ 0 ] instanceof Web2All_Table_SaveObject ) { throw new Exception ( "Web2All_Table_ObjectList->removeFromDB: Not a saveobject, you can't delete a non saveobject." ) ; } foreach ( $ this -> result as $ row ) { $ row -> deleteFromDB ( ) ; } } }
3974	protected function build ( IMetaModelDataDefinition $ container ) { $ inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( ! $ inputScreen ) { return ; } $ meta = $ inputScreen [ 'meta' ] ; $ config = $ this -> getDataProviderDefinition ( $ container ) ; if ( ! $ config -> hasInformation ( $ container -> getName ( ) ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ container -> getName ( ) ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ container -> getName ( ) ) ; } $ basicDefinition = $ container -> getBasicDefinition ( ) ; if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ container -> getName ( ) ) -> setClassName ( Driver :: class ) -> setInitializationData ( [ 'source' => $ container -> getName ( ) ] ) -> setVersioningEnabled ( false ) ; $ basicDefinition -> setDataProvider ( $ container -> getName ( ) ) ; } if ( $ basicDefinition -> getMode ( ) == BasicDefinitionInterface :: MODE_HIERARCHICAL ) { $ basicDefinition -> setRootDataProvider ( $ container -> getName ( ) ) ; } if ( 'ctable' === $ meta [ 'rendertype' ] ) { $ parentTable = $ meta [ 'ptable' ] ; if ( ! $ config -> hasInformation ( $ parentTable ) ) { $ providerInformation = new ContaoDataProviderInformation ( ) ; $ providerInformation -> setName ( $ parentTable ) ; $ config -> addInformation ( $ providerInformation ) ; } else { $ providerInformation = $ config -> getInformation ( $ parentTable ) ; } if ( $ providerInformation instanceof ContaoDataProviderInformation ) { $ providerInformation -> setTableName ( $ parentTable ) -> setInitializationData ( [ 'source' => $ parentTable ] ) ; if ( in_array ( $ parentTable , $ this -> factory -> collectNames ( ) ) ) { $ providerInformation -> setClassName ( Driver :: class ) ; } $ basicDefinition -> setParentDataProvider ( $ parentTable ) ; } } }
4027	protected function getLabelComment ( ModelInterface $ model , TranslatorInterface $ translator ) { if ( $ model -> getProperty ( 'comment' ) ) { return sprintf ( $ translator -> translate ( 'typedesc._comment_' , 'tl_metamodel_filtersetting' ) , StringUtil :: specialchars ( $ model -> getProperty ( 'comment' ) ) ) ; } return '' ; }
12212	public function getSnippet ( string $ snptName = '' ) { if ( empty ( $ snptName ) ) { return $ this -> snippets ; } else { return isset ( $ this -> snippets [ $ snptName ] ) ? $ this -> snippets [ $ snptName ] : null ; } }
4220	private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; }
9185	protected function toArray ( $ data , $ type , $ format ) { $ serializer = SerializerBuilder :: create ( ) -> build ( ) ; return $ serializer -> toArray ( $ serializer -> deserialize ( $ data , $ type , $ format ) ) ; }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9551	public function setOrderBy ( $ order_by , $ order = null ) { $ this -> order_by = $ order_by ; $ this -> order = $ order ; return $ this ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
1887	protected function linkToPage ( $ intPage ) { if ( $ intPage <= 1 && ! $ this -> blnForceParam ) { return ampersand ( $ this -> strUrl ) ; } else { return ampersand ( $ this -> strUrl ) . $ this -> strVarConnector . $ this -> strParameter . '=' . $ intPage ; } }
3860	protected function getAttributeNames ( ) { $ arrAttributes = $ this -> objView -> getSettingNames ( ) ; $ strDesiredLanguage = $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ; $ strFallbackLanguage = $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ; $ intFilterSettings = 0 ; foreach ( ( array ) $ this -> getView ( ) -> get ( 'jumpTo' ) as $ arrJumpTo ) { if ( ! $ this -> getMetaModel ( ) -> isTranslated ( ) || $ arrJumpTo [ 'langcode' ] == $ strDesiredLanguage || $ arrJumpTo [ 'langcode' ] == $ strFallbackLanguage ) { $ intFilterSettings = $ arrJumpTo [ 'filter' ] ; if ( $ strDesiredLanguage == $ arrJumpTo [ 'langcode' ] ) { break ; } } } if ( $ intFilterSettings ) { $ objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ intFilterSettings ) ; $ arrAttributes = array_merge ( $ objFilterSettings -> getReferencedAttributes ( ) , $ arrAttributes ) ; } return $ arrAttributes ; }
10115	private function writeFooter ( ) { $ record = 0x0015 ; $ recordData = StringHelper :: UTF8toBIFF8UnicodeLong ( $ this -> phpSheet -> getHeaderFooter ( ) -> getOddFooter ( ) ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
6573	protected static function examine ( $ part , array & $ array , $ path_relative , $ allow_escape = false ) { if ( $ part === '.' ) { return ; } if ( $ part !== '..' ) { $ array [ ] = $ part ; return ; } $ last = end ( $ array ) ; if ( $ last === '..' ) { $ array [ ] = $ part ; return ; } if ( $ last !== false ) { array_pop ( $ array ) ; return ; } if ( ! $ path_relative ) { return ; } if ( ! $ allow_escape ) throw new \ UnexpectedValueException ( 'Attempt to traverse outside the root directory.' ) ; $ array [ ] = $ part ; }
56	public function update ( PackageInterface $ initial , PackageInterface $ target , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ initial ) ; if ( ! $ downloader ) { return ; } $ installationSource = $ initial -> getInstallationSource ( ) ; if ( 'dist' === $ installationSource ) { $ initialType = $ initial -> getDistType ( ) ; $ targetType = $ target -> getDistType ( ) ; } else { $ initialType = $ initial -> getSourceType ( ) ; $ targetType = $ target -> getSourceType ( ) ; } if ( $ target -> isDev ( ) && 'dist' === $ installationSource ) { $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir ) ; return ; } if ( $ initialType === $ targetType ) { $ target -> setInstallationSource ( $ installationSource ) ; try { $ downloader -> update ( $ initial , $ target , $ targetDir ) ; return ; } catch ( \ RuntimeException $ e ) { if ( ! $ this -> io -> isInteractive ( ) ) { throw $ e ; } $ this -> io -> writeError ( '<error> Update failed (' . $ e -> getMessage ( ) . ')</error>' ) ; if ( ! $ this -> io -> askConfirmation ( ' Would you like to try reinstalling the package instead [<comment>yes</comment>]? ' , true ) ) { throw $ e ; } } } $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir , 'source' === $ installationSource ) ; }
846	public function generatePartialCode ( $ start , $ end ) { $ code = '' ; for ( $ i = $ start ; $ i <= $ end ; ++ $ i ) { $ code .= $ this [ $ i ] -> getContent ( ) ; } return $ code ; }
2206	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'FMD' ] [ 'logout' ] [ 0 ] ) . ' ###' ; $ objTemplate -> title = $ this -> headline ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> name ; $ objTemplate -> href = 'contao/main.php?do=themes&amp;table=tl_module&amp;act=edit&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> redirectBack ) { $ _SESSION [ 'LAST_PAGE_VISITED' ] = $ this -> getReferer ( ) ; } $ strLogoutUrl = System :: getContainer ( ) -> get ( 'security.logout_url_generator' ) -> getLogoutUrl ( ) ; $ strRedirect = Environment :: get ( 'base' ) ; if ( $ this -> redirectBack && ! empty ( $ _SESSION [ 'LAST_PAGE_VISITED' ] ) ) { $ strRedirect = $ _SESSION [ 'LAST_PAGE_VISITED' ] ; } elseif ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ strRedirect = $ objTarget -> getAbsoluteUrl ( ) ; } $ uri = Http :: createFromString ( $ strLogoutUrl ) ; $ query = new Query ( $ uri -> getQuery ( ) ) ; $ query = $ query -> merge ( 'redirect=' . $ strRedirect ) ; $ this -> redirect ( ( string ) $ uri -> withQuery ( ( string ) $ query ) ) ; return '' ; }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
7896	public function from ( $ provider = null ) { $ provider = $ provider ? : $ this -> getDefaultProvider ( ) ; return new Uploader ( $ this -> app -> make ( 'config' ) , $ this -> app -> make ( 'filesystem' ) , $ this -> createProviderInstance ( $ provider ) ) ; }
11666	public function addFunction ( $ functionName , $ callback ) { if ( is_string ( $ functionName ) && is_callable ( $ callback ) ) { $ functions = [ 'name' => $ functionName , 'callable' => $ callback , ] ; array_push ( $ this -> functionList , $ functions ) ; } }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
1169	protected function purgeNonRemoteRules ( $ rules , $ validator ) { $ protectedValidator = $ this -> createProtectedCaller ( $ validator ) ; foreach ( $ rules as $ i => $ rule ) { $ parsedRule = ValidationRuleParser :: parse ( [ $ rule ] ) ; if ( ! $ this -> isRemoteRule ( $ parsedRule [ 0 ] ) ) { unset ( $ rules [ $ i ] ) ; } } return $ rules ; }
3626	protected function getDefaultSerial ( $ serial_number ) { if ( empty ( $ serial_number ) ) { $ devices_serials = $ this -> getDevices ( ) ; if ( count ( $ devices_serials ) == 0 ) { $ devices_serials = $ this -> getDevices ( DEVICE_TYPE_PROTECT ) ; } $ serial_number = $ devices_serials [ 0 ] ; } return $ serial_number ; }
5701	protected function createFieldList ( $ buttons ) { $ actions = FieldList :: create ( ) ; foreach ( $ buttons as $ buttonType => $ bool ) { if ( ! $ bool || ! $ buttonType ) { continue ; } if ( substr ( $ buttonType , 0 , 6 ) == "Group_" ) { $ group = $ this -> createButtonGroup ( substr ( $ buttonType , 6 ) ) ; if ( $ group -> children -> exists ( ) ) { $ actions -> push ( $ group ) ; } } elseif ( $ b = $ this -> instantiateButton ( $ buttonType ) ) { $ actions -> push ( $ b ) ; } } return $ actions ; }
6812	private function getDateTimeFormatter ( ) { if ( $ this -> dateTimeFormatter ) { return $ this -> dateTimeFormatter ; } return $ this -> dateTimeFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: SHORT , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
495	public function getProfiling ( $ categories = [ ] , $ excludeCategories = [ ] ) { $ timings = $ this -> calculateTimings ( $ this -> messages ) ; if ( empty ( $ categories ) && empty ( $ excludeCategories ) ) { return $ timings ; } foreach ( $ timings as $ i => $ timing ) { $ matched = empty ( $ categories ) ; foreach ( $ categories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = true ; break ; } } if ( $ matched ) { foreach ( $ excludeCategories as $ category ) { $ prefix = rtrim ( $ category , '*' ) ; foreach ( $ timings as $ i => $ timing ) { if ( ( $ timing [ 'category' ] === $ category || $ prefix !== $ category ) && strpos ( $ timing [ 'category' ] , $ prefix ) === 0 ) { $ matched = false ; break ; } } } } if ( ! $ matched ) { unset ( $ timings [ $ i ] ) ; } } return array_values ( $ timings ) ; }
5188	private function createPage ( string $ title , string $ body , string $ source , int $ order , string $ cover , string $ lead ) : \ One \ Model \ Page { return new Page ( $ title , $ body , $ source , $ order , $ cover , $ lead ) ; }
3887	public function editRenderSettingButton ( \ DC_Table $ dataContainer ) { if ( $ dataContainer -> value < 1 ) { return '' ; } $ url = $ this -> urlBuilderFactory -> create ( 'contao/main.php?do=metamodels&table=tl_metamodel_rendersetting' ) -> setQueryParameter ( 'pid' , ModelId :: fromValues ( 'tl_metamodel_rendersettings' , $ dataContainer -> value ) -> getSerialized ( ) ) ; return $ this -> renderEditButton ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 0 ] , sprintf ( StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ static :: $ tableName ] [ 'editrendersetting' ] [ 1 ] ) , $ dataContainer -> value ) , $ url ) ; }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
5949	public function setResults ( array $ results ) { $ this -> results = [ ] ; foreach ( $ results as $ item ) { switch ( $ item [ 'discriminatorId' ] ) { case ObjectResponse :: DISCRIMINATOR_FOLDER : $ this -> addFolderResponse ( $ item ) ; break ; case ObjectResponse :: DISCRIMINATOR_MEDIA : default : $ this -> addMediaResponse ( $ item ) ; break ; } } return $ this ; }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
88	public function equals ( Rule $ rule ) { if ( $ rule instanceof self ) { if ( $ this -> literal1 !== $ rule -> literal1 ) { return false ; } if ( $ this -> literal2 !== $ rule -> literal2 ) { return false ; } return true ; } $ literals = $ rule -> getLiterals ( ) ; if ( 2 != count ( $ literals ) ) { return false ; } if ( $ this -> literal1 !== $ literals [ 0 ] ) { return false ; } if ( $ this -> literal2 !== $ literals [ 1 ] ) { return false ; } return true ; }
7486	public function indexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
1354	protected function sort ( $ query , array $ sortBy ) { foreach ( $ sortBy as $ param ) { $ this -> sortBy ( $ query , $ param ) ; } }
7080	public function onPreCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; if ( $ source instanceof OrderInterface ) { if ( $ source -> getState ( ) !== OrderStates :: STATE_NEW ) { $ event -> addMessage ( new ResourceMessage ( 'ekyna_commerce.sale.message.transform_prevented' , ResourceMessage :: TYPE_ERROR ) ) ; } } }
4414	public function onKernelRequest ( GetResponseEvent $ event ) { if ( ! $ event -> isMasterRequest ( ) ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( mb_stripos ( $ currentRoute , 'netgen_information_collection' ) !== 0 ) { return ; } $ this -> globalVariable -> setPageLayoutTemplate ( $ this -> pageLayoutTemplate ) ; }
7500	public function requestJson ( $ method , $ url , $ options = array ( ) ) { $ options [ 'headers' ] [ ] = 'Content-Type: application/json' ; $ options [ 'headers' ] [ ] = 'Content-Length: ' . strlen ( $ options [ 'body' ] ) ; $ this -> request ( $ method , $ url , $ options ) ; }
2850	public function setTemplateHints ( $ status ) { $ this -> deleteTemplateHintsDbConfigs ( ) ; $ config = $ this -> getConfig ( ) ; $ config -> saveConfig ( 'dev/debug/template_hints' , ( int ) $ status ) ; $ config -> saveConfig ( 'dev/debug/template_hints_blocks' , ( int ) $ status ) ; }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
4472	public function retry ( $ group , $ message , $ delay = 0 ) { return $ this -> client -> retry ( $ this -> jid , $ this -> queue , $ this -> worker , $ delay , $ group , $ message ) ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
12384	public static function perDay ( $ days = 1 , $ date_format = "m-d" ) { $ hits_per_day = [ ] ; for ( $ i = 1 ; $ i <= $ days ; $ i ++ ) { $ hits_count = self :: interval ( Carbon :: now ( ) -> subDays ( $ i ) , Carbon :: now ( ) -> subDays ( $ i - 1 ) ) ; $ hits_per_day [ Carbon :: now ( ) -> subDays ( $ i ) -> format ( $ date_format ) ] = $ hits_count ; } return $ hits_per_day ; }
5982	protected function getClient ( ) { if ( ! ( $ this -> client instanceof Client ) ) { $ handlerStack = HandlerStack :: create ( ) ; $ handlerStack = $ this -> withOAuth2MiddleWare ( $ handlerStack ) ; $ this -> client = new Client ( [ 'handler' => $ handlerStack , 'auth' => 'oauth2' , 'base_uri' => $ this -> basepath , 'headers' => [ 'Accept' => 'application/json' , 'Content-type' => 'application/json' , 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , 'verify' => $ this -> verifyCertificates , ] ) ; $ this -> logger -> debug ( 'Guzzle client instantiated.' , [ 'basepath' => $ this -> basepath ] ) ; } return $ this -> client ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
2623	public function daysFromInstallation ( ) { $ stat = $ this -> statisticRepository -> getStatByAction ( self :: FASTLY_INSTALLED_FLAG ) ; if ( ! $ stat -> getCreatedAt ( ) ) { return null ; } $ installDate = date_create ( $ stat -> getCreatedAt ( ) ) ; $ currentDate = date_create ( $ this -> dateTime -> gmtDate ( ) ) ; $ dateDiff = date_diff ( $ installDate , $ currentDate ) ; return $ dateDiff -> days ; }
5814	public function validate ( ) { $ result = parent :: validate ( ) ; $ this -> Title = strtolower ( $ this -> Title ) ; if ( $ result -> valid ( ) && ! $ this -> Title ) { $ result -> error ( '"Title" required!' ) ; } else if ( $ result -> valid ( ) && FusionTag :: get_one ( 'FusionTag' , array ( 'ID != ?' => $ this -> ID , 'Title = ?' => $ this -> Title ) ) ) { $ result -> error ( 'Tag already exists!' ) ; } $ this -> extend ( 'validateFusionTag' , $ result ) ; return $ result ; }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
5111	protected function appendPart ( $ part , $ sql , $ bind = false ) { if ( ! is_array ( $ sql ) ) $ sql = [ $ sql ] ; if ( ! $ this -> parts [ $ part ] ) { $ this -> parts [ $ part ] = $ sql ; } else { $ this -> parts [ $ part ] = array_merge ( $ this -> parts [ $ part ] , $ sql ) ; } return $ this -> appendBind ( $ part , $ bind ) ; }
1285	private function fetchResourcesForGivenIds ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ resources = [ ] ; $ resourcePoolOptions = [ 'locale' => $ locale ] ; foreach ( $ resourceIds as $ index => $ resourceId ) { if ( $ this -> resourcePool -> has ( $ type , $ resourceId , $ resourcePoolOptions ) ) { $ resources [ ] = $ this -> resourcePool -> get ( $ type , $ resourceId , $ resourcePoolOptions ) ; unset ( $ resourceIds [ $ index ] ) ; } } foreach ( $ this -> createIdChunks ( $ resourceIds ) as $ chunk ) { $ resources += $ this -> fetchCollectionFromApi ( $ chunk , $ type , $ locale ) ; } return $ resources ; }
8041	public function formatEventsToJson ( array $ calendarEvents ) { $ array = [ ] ; foreach ( $ calendarEvents as $ event ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ event -> end ) ) -> toIso8601String ( ) ; $ allDay = $ event -> all_day == 1 ; $ data = [ 'title' => $ event -> title , 'description' => $ event -> description , 'start' => $ start , 'end' => $ end , 'allDay' => $ allDay , 'borderColor' => $ event -> border_color , 'textColor' => $ event -> text_color , 'backgroundColor' => $ event -> background_color , ] ; $ array [ ] = $ data ; if ( $ event -> calendarEventRepeatDates ( ) -> count ( ) > 0 ) { foreach ( $ event -> calendarEventRepeatDates ( ) -> get ( ) as $ repeatDate ) { $ start = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> start ) ) -> toIso8601String ( ) ; $ end = $ this -> carbon -> copy ( ) -> setTimestamp ( strtotime ( $ repeatDate -> end ) ) -> toIso8601String ( ) ; $ data [ 'start' ] = $ start ; $ data [ 'end' ] = $ end ; $ array [ ] = $ data ; } } } return $ array ; }
12636	protected function getSandboxSignKey ( ) { if ( $ this -> sandboxSignKey ) { return $ this -> sandboxSignKey ; } $ cacheKey = 'sandbox_signkey.' . $ this -> merchant -> merchant_id . $ this -> merchant -> sub_merchant_id ; $ cache = $ this -> getCache ( ) ; $ this -> sandboxSignKey = $ cache -> fetch ( $ cacheKey ) ; if ( ! $ this -> sandboxSignKey ) { $ result = $ this -> request ( self :: API_SANDBOX_SIGN_KEY , [ ] ) ; if ( $ result -> return_code === 'SUCCESS' ) { $ cache -> save ( $ cacheKey , $ result -> sandbox_signkey , 24 * 3600 ) ; return $ this -> sandboxSignKey = $ result -> sandbox_signkey ; } throw new Exception ( $ result -> return_msg ) ; } return $ this -> sandboxSignKey ; }
7124	protected function getMessageFromEvent ( ResourceEventInterface $ event ) { $ message = $ event -> getResource ( ) ; if ( ! $ message instanceof TicketMessageInterface ) { throw new UnexpectedValueException ( "Expected instance of " . TicketMessageInterface :: class ) ; } return $ message ; }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
4753	private function getContactFormMethod ( ) { $ method = self :: CONTACT_FORM_METHOD_DEFAULT ; if ( $ configMethod = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'OeGdprOptinContactFormMethod' ) ) { $ method = $ configMethod ; } return $ method ; }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
6088	public function createMoodboard ( Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
6800	public function installCurrencies ( $ code = 'USD' ) { $ currencyNames = Intl :: getCurrencyBundle ( ) -> getCurrencyNames ( ) ; if ( ! isset ( $ currencyNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default currency code '$code'." ) ; } asort ( $ currencyNames ) ; $ this -> generate ( Currency :: class , $ currencyNames , $ code ) ; }
5320	public function waitReady ( ) { $ x = 0 ; while ( $ x ++ < 100 ) { usleep ( self :: WAIT_IDLE ) ; if ( $ this [ self :: STARTED_MARKER ] === true ) { return $ this ; } } throw new \ RuntimeException ( 'Wait process running timeout for child pid ' . $ this -> getPid ( ) ) ; }
2830	public function disableSqlProfilerAction ( ) { try { $ this -> getService ( ) -> setSqlProfilerStatus ( false ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'SQL profiler was disabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to disable SQL profiler: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
8724	public function translations ( ) { $ localKey = $ this -> getKeyName ( ) ; $ foreignKey = $ this -> getForeignKey ( ) ; $ instance = $ this -> translationModel ( ) ; return new HasMany ( $ instance -> newQuery ( ) , $ this , $ instance -> getTable ( ) . '.' . $ foreignKey , $ localKey ) ; }
6884	static public function isValidType ( $ type , $ throw = true ) { if ( in_array ( $ type , static :: getTypes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid notification type.' ) ; } return false ; }
9959	public function unprotectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> unprotectCells ( $ cellRange ) ; }
250	public function setUseCookies ( $ value ) { $ this -> freeze ( ) ; if ( $ value === false ) { ini_set ( 'session.use_cookies' , '0' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } elseif ( $ value === true ) { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '1' ) ; } else { ini_set ( 'session.use_cookies' , '1' ) ; ini_set ( 'session.use_only_cookies' , '0' ) ; } $ this -> unfreeze ( ) ; }
3296	protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; }
2545	protected function makeDomXpath ( $ response ) { $ domDoc = $ this -> loadDomDocument ( $ response ) ; $ domXpath = new \ DOMXPath ( $ domDoc ) ; $ domXpath -> registerNamespace ( self :: XMLNS_PREFIX , $ domDoc -> documentElement -> lookupNamespaceUri ( null ) ) ; return $ domXpath ; }
3963	public static function isReserveColumnPostFix ( $ strColName ) { $ inputProvider = new InputProvider ( ) ; if ( ! $ inputProvider -> hasValue ( 'colname' ) || strtolower ( $ strColName ) !== strtolower ( $ inputProvider -> getValue ( 'colname' ) ) ) { return false ; } foreach ( self :: $ reservedColumnPostFix as $ postFix ) { if ( $ postFix !== strtolower ( substr ( $ strColName , - strlen ( $ postFix ) ) ) ) { continue ; } return true ; } return false ; }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
7258	protected function mergeItemsResults ( Model \ SaleItemInterface $ item , Amount $ result ) : void { foreach ( $ item -> getChildren ( ) as $ child ) { if ( $ child -> isPrivate ( ) ) { continue ; } if ( ! ( $ child -> isCompound ( ) && ! $ child -> hasPrivateChildren ( ) ) ) { $ result -> merge ( $ child -> getResult ( ) ) ; } if ( $ child -> hasChildren ( ) ) { $ this -> mergeItemsResults ( $ child , $ result ) ; } } }
2455	public function copyAll ( ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'config' ] [ 'notCopyable' ] ) { throw new InternalServerErrorException ( 'Table "' . $ this -> strTable . '" is not copyable.' ) ; } $ objSession = System :: getContainer ( ) -> get ( 'session' ) ; $ arrClipboard = $ objSession -> get ( 'CLIPBOARD' ) ; if ( isset ( $ arrClipboard [ $ this -> strTable ] ) && \ is_array ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] ) ) { foreach ( $ arrClipboard [ $ this -> strTable ] [ 'id' ] as $ id ) { $ this -> intId = $ id ; $ id = $ this -> copy ( true ) ; Input :: setGet ( 'pid' , $ id ) ; Input :: setGet ( 'mode' , 1 ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
12673	public function setSourceFiles ( $ value ) { foreach ( $ value as $ key => $ settings ) { if ( $ settings === false ) { $ this -> _sourceFiles [ $ key ] = false ; continue ; } if ( ! isset ( $ settings [ 'class' ] ) ) { $ settings [ 'class' ] = $ this -> sourceFileClass ; } $ settings [ 'id' ] = $ key ; $ this -> _sourceFiles [ $ key ] = Yii :: createObject ( $ settings ) ; } }
11372	protected function onClassFound ( ScannedPhpClass $ subject ) { $ class = $ subject -> getClass ( ) ; $ main = $ this -> reader -> getClassAnnotation ( $ class , Di \ DiServiceAnnotation :: class ) ; if ( $ main instanceof Di \ DiServiceAnnotation ) { $ definition = $ this -> provideServiceDefinitionFor ( new ServiceDefinitionProvider \ Frame ( $ class , $ main , DiOptionsCollection :: from ( $ this -> reader , $ class ) , null ) ) ; $ this -> addServiceDefinition ( $ definition ) ; } }
4270	public function dir_rewinddir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; \ rewinddir ( $ this -> handle ) ; self :: register ( ) ; return true ; }
12490	public static function select ( $ select ) { if ( gettype ( $ select ) == "array" ) { foreach ( $ select as $ key => $ field ) { if ( $ field instanceof Key ) { $ alias = '"' . $ field . '"' ; $ field = self :: field ( $ field ) ; $ select [ $ key ] = "{$field} as {$alias}" ; } } $ select = implode ( ", " , $ select ) ; } elseif ( gettype ( $ select ) != "string" ) { throw new ClusterpointException ( "\"->select()\" function: passed parametr is not in valid format." , 9002 ) ; } return $ select ; }
8799	public function make ( $ value , array $ options = [ ] ) { $ hash = password_hash ( $ value , PASSWORD_ARGON2I , [ 'memory_cost' => $ this -> memory ( $ options ) , 'time_cost' => $ this -> time ( $ options ) , 'threads' => $ this -> threads ( $ options ) , ] ) ; if ( $ hash === false ) { throw new RuntimeException ( 'Argon2 hashing not supported.' ) ; } return $ hash ; }
379	public function renderCallStackItem ( $ file , $ line , $ class , $ method , $ args , $ index ) { $ lines = [ ] ; $ begin = $ end = 0 ; if ( $ file !== null && $ line !== null ) { $ line -- ; $ lines = @ file ( $ file ) ; if ( $ line < 0 || $ lines === false || ( $ lineCount = count ( $ lines ) ) < $ line ) { return '' ; } $ half = ( int ) ( ( $ index === 1 ? $ this -> maxSourceLines : $ this -> maxTraceSourceLines ) / 2 ) ; $ begin = $ line - $ half > 0 ? $ line - $ half : 0 ; $ end = $ line + $ half < $ lineCount ? $ line + $ half : $ lineCount - 1 ; } return $ this -> renderFile ( $ this -> callStackItemView , [ 'file' => $ file , 'line' => $ line , 'class' => $ class , 'method' => $ method , 'index' => $ index , 'lines' => $ lines , 'begin' => $ begin , 'end' => $ end , 'args' => $ args , ] ) ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
8386	public function having ( $ having ) { $ this -> having = ( $ having instanceof Condition ? $ having : new Condition ( $ having ) ) ; return $ this ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
9566	public function addAfterHook ( $ hook ) { if ( ! isset ( $ this -> options [ 'after' ] ) ) { $ this -> options [ 'after' ] = [ ] ; } $ this -> options [ 'after' ] [ ] = $ hook ; }
12037	function generate ( ) { if ( $ this -> namespace ) { $ fqcn = $ this -> namespace . '\\' . $ this -> className ; } else { $ fqcn = $ this -> className ; } $ this -> addProperties ( ) ; $ this -> addConstructorMethod ( ) ; $ this -> addSetAPIMethod ( ) ; $ this -> addSetParameterMethod ( ) ; $ this -> addCheckScopeMethod ( ) ; $ this -> addAccessorMethods ( ) ; $ this -> addFilteredParameterMethod ( ) ; $ this -> addCreateRequestMethod ( ) ; $ this -> addCreateAndExecuteMethod ( ) ; $ this -> addCallMethod ( ) ; $ this -> addExecuteMethod ( ) ; $ this -> addExecuteAsyncMethod ( ) ; $ this -> addDispatchMethod ( ) ; $ this -> addDispatchAsyncMethod ( ) ; $ this -> addProcessResponseMethod ( ) ; $ this -> addShouldResponseBeProcessedMethod ( ) ; $ this -> addTranslateResponseToExceptionMethod ( ) ; $ this -> addShouldUseCachedResponseMethod ( ) ; $ this -> addShouldResponseBeCachedMethod ( ) ; $ this -> addSetOriginalResponseMethod ( ) ; $ this -> addGetOriginalResponseMethod ( ) ; $ this -> addGetResultInstantiationInfoMethod ( ) ; $ this -> classGenerator -> setImplementedInterfaces ( [ 'ArtaxServiceBuilder\Operation' ] ) ; $ this -> classGenerator -> setFQCN ( $ fqcn ) ; $ text = $ this -> classGenerator -> generate ( ) ; saveFile ( $ this -> outputPath , $ fqcn , $ text ) ; }
2549	protected function loadClientParams ( Params $ params , $ receivedFromIdentifier , $ version ) { if ( $ params -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> authParams ; if ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams instanceof Params \ SessionHandlerParams ) { $ params -> sessionHandlerParams -> authParams = $ this -> authParams ; } } elseif ( isset ( $ params -> sessionHandlerParams ) && $ params -> sessionHandlerParams -> authParams instanceof Params \ AuthParams ) { $ this -> authParams = $ params -> sessionHandlerParams -> authParams ; } $ this -> sessionHandler = $ this -> loadSessionHandler ( $ params -> sessionHandler , $ params -> sessionHandlerParams ) ; $ this -> requestCreator = $ this -> loadRequestCreator ( $ params -> requestCreator , $ params -> requestCreatorParams , $ receivedFromIdentifier . "-" . $ version , $ this -> sessionHandler -> getOriginatorOffice ( ) , $ this -> sessionHandler -> getMessagesAndVersions ( ) ) ; $ this -> responseHandler = $ this -> loadResponseHandler ( $ params -> responseHandler ) ; $ this -> returnResultXml = $ params -> returnXml ; }
11611	public function move ( $ path , $ filename = null ) { $ newFilename = ( $ filename != null ) ? $ filename : $ this -> filename ; $ lastSlash = substr ( $ path , strlen ( $ path ) , 1 ) ; if ( $ lastSlash !== '/' ) { $ path .= '/' ; } $ result = move_uploaded_file ( $ this -> realPath , $ path . $ newFilename ) ; return $ result ; }
112	private function collectDependencies ( Pool $ pool , array $ collected , PackageInterface $ package ) { $ requires = array_merge ( $ package -> getRequires ( ) , $ package -> getDevRequires ( ) ) ; foreach ( $ requires as $ requireLink ) { $ requiredPackage = $ this -> lookupInstalledPackage ( $ pool , $ requireLink ) ; if ( $ requiredPackage && ! isset ( $ collected [ $ requiredPackage -> getName ( ) ] ) ) { $ collected [ $ requiredPackage -> getName ( ) ] = $ requiredPackage ; $ collected = $ this -> collectDependencies ( $ pool , $ collected , $ requiredPackage ) ; } } return $ collected ; }
227	public function getSchemaNames ( $ refresh = false ) { if ( $ this -> _schemaNames === null || $ refresh ) { $ this -> _schemaNames = $ this -> findSchemaNames ( ) ; } return $ this -> _schemaNames ; }
10513	private function checkIfObserverMustBeUpdate ( \ StdClass $ observer ) { if ( $ observer -> eventName == $ this -> event -> name ) { return true ; } return false ; }
10038	function renameCustomField ( $ oldName , $ newName ) { $ encodedOldName = urlencode ( mb_convert_encoding ( $ oldName , "UTF-8" ) ) ; $ encodedNewName = urlencode ( mb_convert_encoding ( $ newName , "UTF-8" ) ) ; return $ this -> put ( "contacts/fields/custom/${encodedOldName}/${encodedNewName}" ) ; }
9547	public function rank ( $ info , $ weights ) { if ( ! empty ( $ weights ) ) { $ weights = explode ( ',' , $ weights ) ; } $ score = ( float ) 0.0 ; $ isize = 4 ; $ phrases = ( int ) ord ( substr ( $ info , 0 , $ isize ) ) ; $ columns = ( int ) ord ( substr ( $ info , $ isize , $ isize ) ) ; $ string = $ phrases . ' ' . $ columns . ' ' ; for ( $ p = 0 ; $ p < $ phrases ; ++ $ p ) { $ term = substr ( $ info , ( 2 + $ p * $ columns * 3 ) * $ isize ) ; for ( $ c = 0 ; $ c < $ columns ; ++ $ c ) { $ here = ( float ) ord ( substr ( $ term , ( 3 * $ c * $ isize ) , 1 ) ) ; $ total = ( float ) ord ( substr ( $ term , ( 3 * $ c + 1 ) * $ isize , 1 ) ) ; $ rows = ( float ) ord ( substr ( $ term , ( 3 * $ c + 2 ) * $ isize , 1 ) ) ; $ relevance = ( ! empty ( $ total ) ) ? ( $ rows / $ total ) * $ here : 0 ; $ weight = ( isset ( $ weights [ $ c ] ) ) ? ( float ) $ weights [ $ c ] : 1 ; $ score += $ relevance * $ weight ; $ string .= $ here . $ total . $ rows . ' (' . round ( $ relevance , 2 ) . '*' . $ weight . ') ' ; } } return $ score ; }
3266	public function getPath ( ) : string { return $ this -> config -> getDir ( ) . $ this -> getName ( ) . $ this -> config -> getExt ( ) ; }
1902	public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; if ( strncasecmp ( $ this -> strQuery , 'INSERT' , 6 ) === 0 || strncasecmp ( $ this -> strQuery , 'UPDATE' , 6 ) === 0 ) { $ this -> strQuery = str_replace ( '%s' , '%p' , $ this -> strQuery ) ; } $ arrChunks = preg_split ( "/('[^']*')/" , $ this -> strQuery , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; foreach ( $ arrChunks as $ k => $ v ) { if ( substr ( $ v , 0 , 1 ) == "'" ) { continue ; } $ arrChunks [ $ k ] = str_replace ( '?' , '%s' , $ v ) ; } $ this -> strQuery = implode ( '' , $ arrChunks ) ; return $ this ; }
11731	protected function generateSlot ( $ path , $ blocks = array ( ) , $ username = null ) { if ( is_dir ( $ path ) && ! $ this -> override ) { return ; } $ folders = array ( ) ; $ activeDir = $ path . '/active' ; $ contributorsDir = $ path . '/contributors' ; $ folders [ ] = $ activeDir . '/blocks' ; $ folders [ ] = $ activeDir . '/archive' ; $ folders [ ] = $ contributorsDir ; $ targetDir = $ activeDir ; $ blocksDir = $ activeDir . '/blocks' ; if ( null !== $ username ) { $ targetDir = $ contributorsDir . '/' . $ username ; $ blocksDir = $ targetDir . '/blocks' ; $ folders [ ] = $ targetDir ; $ folders [ ] = $ targetDir . '/archive' ; $ folders [ ] = $ blocksDir ; } $ this -> filesystem -> mkdir ( $ folders ) ; $ this -> generateBlocks ( $ blocks , $ blocksDir , $ targetDir ) ; }
2255	protected function eliminateNestedPages ( $ arrPages , $ strTable = null , $ blnSorting = false ) { if ( empty ( $ arrPages ) || ! \ is_array ( $ arrPages ) ) { return array ( ) ; } if ( ! $ strTable ) { $ strTable = 'tl_page' ; } $ arrPages = array_intersect ( $ arrPages , $ this -> Database -> getChildRecords ( 0 , $ strTable , $ blnSorting ) ) ; $ arrPages = array_values ( array_diff ( $ arrPages , $ this -> Database -> getChildRecords ( $ arrPages , $ strTable , $ blnSorting ) ) ) ; return $ arrPages ; }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
8641	public function setShipmentItemAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
11992	public function toArray ( ) { $ urls = [ ] ; $ actions = [ ] ; if ( count ( $ this -> items ) < 1 ) { return parent :: toArray ( ) ; } $ entity = $ this -> items [ 0 ] ; if ( is_array ( $ entity -> load ) ) { foreach ( $ entity -> load as $ k => $ load ) { $ this -> load ( $ load ) ; } } $ data = parent :: toArray ( ) ; $ actions = $ entity -> getActions ( ) ; if ( count ( $ actions ) > 0 ) { foreach ( $ data as $ k => $ resource ) { if ( count ( $ resource ) < 2 ) { continue ; } $ data [ $ k ] += [ 'actions' => $ actions ] ; } } $ data = $ this -> normalizeArray ( $ data ) ; return $ data ; }
8076	public function post ( $ endpoint , $ data , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ data = $ this -> prepareData ( $ data ) ; $ this -> response = $ this -> client -> post ( $ endpoint , $ data , $ headers ) ; return $ this -> response ; }
2613	private function prepareGAReqData ( ) { if ( ! empty ( $ this -> GAReqData ) ) { return $ this -> GAReqData ; } $ mandatoryReqData = [ ] ; $ mandatoryReqData [ 'v' ] = 1 ; $ mandatoryReqData [ 'tid' ] = $ this -> getGATrackingId ( ) ; $ cid = $ this -> config -> getCID ( ) ; $ mandatoryReqData [ 'cid' ] = $ cid ; $ mandatoryReqData [ 'uid' ] = $ cid ; $ mandatoryReqData [ 'ua' ] = $ this -> metaData -> getVersion ( ) ; $ mandatoryReqData [ 'geoid' ] = $ this -> getCountry ( ) ; $ mandatoryReqData [ 'ds' ] = 'Fastly' ; $ customVars = $ this -> prepareCustomVariables ( ) ; $ this -> GAReqData = array_merge ( $ mandatoryReqData , $ customVars ) ; return $ this -> GAReqData ; }
11017	public function run ( ) { $ event = new BeforeControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ event ) ; $ action = $ this -> action -> getName ( ) ; if ( $ this -> action -> hasParams ( ) ) { call_user_func_array ( [ $ this , $ action ] , $ this -> action -> getParams ( ) ) ; } else { $ this -> $ action ( ) ; } $ event = new AfterControllerRunEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ event ) ; }
9667	private function writeGradientFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'gradientFill' ) ; $ objWriter -> writeAttribute ( 'type' , $ pFill -> getFillType ( ) ) ; $ objWriter -> writeAttribute ( 'degree' , $ pFill -> getRotation ( ) ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '0' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'stop' ) ; $ objWriter -> writeAttribute ( 'position' , '1' ) ; $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
9147	private function open ( ) { $ this -> handle = @ socket_create ( AF_INET , SOCK_STREAM , SOL_TCP ) ; if ( ! is_resource ( $ this -> handle ) ) { $ code = socket_last_error ( ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
6690	public function canAccess ( $ permissionKeys , $ fullAccessKey , $ errorMsg , $ defaultUrl , $ redirect = false ) { if ( $ this -> getUser ( ) -> isGuest ) { return $ this -> getUser ( ) -> loginRequired ( ) ; } if ( $ this -> getPermissionManager ( ) -> canAccess ( $ fullAccessKey ) ) { return true ; } if ( ! is_array ( $ permissionKeys ) ) { $ permissionKeys = [ $ permissionKeys ] ; } foreach ( $ permissionKeys as $ permissionKey ) { if ( $ this -> getPermissionManager ( ) -> canAccess ( $ permissionKey ) ) { return true ; } } if ( $ redirect ) { $ this -> flashError ( $ errorMsg ) ; $ request = $ this -> getRequest ( ) ; $ referrerUrl = $ request -> referrer ; $ redirectUrl = ( $ referrerUrl == $ request -> url || is_null ( $ referrerUrl ) ) ? $ defaultUrl : $ referrerUrl ; $ this -> redirect ( $ redirectUrl ) -> send ( ) ; Yii :: $ app -> end ( ) ; } return false ; }
4102	public function request ( $ path , $ method = 'GET' , $ payload = false , $ verbose = false ) { $ response = $ this -> transport -> request ( $ this -> expandPath ( $ path ) , $ method , $ payload ) ; return ( $ verbose || ! isset ( $ response [ '_source' ] ) ) ? $ response : $ response [ '_source' ] ; }
9104	protected function parse_user ( ) { if ( ! empty ( $ this -> args [ 'user' ] ) ) { $ this -> args [ 'user__in' ] = array ( $ this -> args [ 'user' ] ) ; } return $ this -> parse_in_or_not_in_query ( 'user' , $ this -> args [ 'user__in' ] , $ this -> args [ 'user__not_in' ] ) ; }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
4190	protected function dumpMethods ( $ methods ) { $ label = \ count ( $ methods ) ? 'methods' : 'no methods' ; $ str = '<dt class="methods">' . $ label . '</dt>' . "\n" ; $ magicMethods = \ array_intersect ( array ( '__call' , '__callStatic' ) , \ array_keys ( $ methods ) ) ; $ str .= $ this -> magicMethodInfo ( $ magicMethods ) ; foreach ( $ methods as $ methodName => $ info ) { if ( ! isset ( $ info [ 'phpDoc' ] [ 'return' ] ) ) { $ info [ 'phpDoc' ] [ 'return' ] = array ( 'desc' => null , 'type' => null , ) ; } $ classes = \ array_keys ( \ array_filter ( array ( 'method' => true , 'deprecated' => $ info [ 'isDeprecated' ] , ) ) ) ; $ modifiers = \ array_keys ( \ array_filter ( array ( 'final' => $ info [ 'isFinal' ] , $ info [ 'visibility' ] => true , 'static' => $ info [ 'isStatic' ] , ) ) ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'dd' , array ( 'class' => \ array_merge ( $ classes , $ modifiers ) , 'data-implements' => $ info [ 'implements' ] , ) , \ implode ( ' ' , \ array_map ( function ( $ modifier ) { return '<span class="t_modifier_' . $ modifier . '">' . $ modifier . '</span>' ; } , $ modifiers ) ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 't_type' , 'title' => $ info [ 'phpDoc' ] [ 'return' ] [ 'desc' ] , ) , $ info [ 'phpDoc' ] [ 'return' ] [ 'type' ] ) . ' ' . $ this -> debug -> utilities -> buildTag ( 'span' , array ( 'class' => 'method-name' , 'title' => \ trim ( $ info [ 'phpDoc' ] [ 'summary' ] . ( $ this -> debug -> output -> getCfg ( 'outputMethodDescription' ) ? "\n\n" . $ info [ 'phpDoc' ] [ 'description' ] : '' ) ) , ) , $ methodName ) . '<span class="t_punct">(</span>' . $ this -> dumpMethodParams ( $ info [ 'params' ] ) . '<span class="t_punct">)</span>' . ( $ methodName == '__toString' ? '<br />' . $ this -> debug -> output -> html -> dump ( $ info [ 'returnValue' ] ) : '' ) ) . "\n" ; } $ str = \ str_replace ( ' data-implements="null"' , '' , $ str ) ; $ str = \ str_replace ( ' <span class="t_type"></span>' , '' , $ str ) ; return $ str ; }
10106	private function writeDefcol ( ) { $ defaultColWidth = 8 ; $ record = 0x0055 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ defaultColWidth ) ; $ this -> append ( $ header . $ data ) ; }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
9816	public function writeRawData ( $ text ) { if ( is_array ( $ text ) ) { $ text = implode ( "\n" , $ text ) ; } return $ this -> writeRaw ( htmlspecialchars ( $ text ) ) ; }
12183	public static function getOne ( Item $ parent , Item $ child , $ options = [ ] ) { $ key = md5 ( $ parent -> systemId . "." . $ child -> systemId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { self :: $ _relationships [ $ key ] -> mergeOptions ( $ options ) ; } else { self :: $ _relationships [ $ key ] = new Relationship ( $ parent , $ child , $ options ) ; } return self :: $ _relationships [ $ key ] ; }
7999	public function identifyTargetName ( $ username , $ nt_domain , ServerChallenge $ server_challenge ) { $ target_name = $ nt_domain ? : $ server_challenge -> getTargetName ( ) ; if ( false !== strpos ( $ username , static :: USER_PRINCIPAL_NAME_SEPARATOR ) ) { $ target_name = '' ; } return $ target_name ; }
496	public function getDbProfiling ( ) { $ timings = $ this -> getProfiling ( [ 'yii\db\Command::query' , 'yii\db\Command::execute' ] ) ; $ count = count ( $ timings ) ; $ time = 0 ; foreach ( $ timings as $ timing ) { $ time += $ timing [ 'duration' ] ; } return [ $ count , $ time ] ; }
7089	public function defaultHeader ( array $ headers = [ ] ) { $ this -> defaultHeaders = array_merge ( $ this -> defaultHeaders , $ headers ) ; return $ this -> defaultHeaders ; }
506	public function getMessageFormatter ( ) { if ( $ this -> _messageFormatter === null ) { $ this -> _messageFormatter = new MessageFormatter ( ) ; } elseif ( is_array ( $ this -> _messageFormatter ) || is_string ( $ this -> _messageFormatter ) ) { $ this -> _messageFormatter = Yii :: createObject ( $ this -> _messageFormatter ) ; } return $ this -> _messageFormatter ; }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
3129	private function loadItemData ( $ itemRef , $ path ) { $ cacheKey = $ itemRef . $ path ; if ( ! empty ( $ cacheKey ) && isset ( $ this -> dataCache [ $ itemRef . $ path ] ) ) { return $ this -> dataCache [ $ itemRef . $ path ] ; } $ directoryIds = explode ( '|' , $ itemRef ) ; if ( count ( $ directoryIds ) < 3 ) { if ( is_scalar ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . strval ( $ itemRef ) ; } elseif ( is_object ( $ itemRef ) ) { $ itemRefInfo = gettype ( $ itemRef ) . ': ' . get_class ( $ itemRef ) ; } else { $ itemRefInfo = gettype ( $ itemRef ) ; } throw new \ common_exception_InconsistentData ( "The itemRef (value = '${itemRefInfo}') is not formatted correctly." ) ; } $ itemUri = $ directoryIds [ 0 ] ; $ userDataLang = \ common_session_SessionManager :: getSession ( ) -> getDataLanguage ( ) ; $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; if ( $ directory -> has ( $ userDataLang ) ) { $ lang = $ userDataLang ; } elseif ( $ directory -> has ( DEFAULT_LANG ) ) { \ common_Logger :: d ( $ userDataLang . ' is not part of compilation directory for item : ' . $ itemUri . ' use ' . DEFAULT_LANG ) ; $ lang = DEFAULT_LANG ; } else { throw new \ common_Exception ( 'item : ' . $ itemUri . 'is neither compiled in ' . $ userDataLang . ' nor in ' . DEFAULT_LANG ) ; } try { $ content = $ directory -> read ( $ lang . DIRECTORY_SEPARATOR . $ path ) ; $ assetService = $ this -> getServiceManager ( ) -> get ( ItemAssetsReplacement :: SERVICE_ID ) ; $ jsonContent = json_decode ( $ content , true ) ; $ jsonAssets = [ ] ; if ( isset ( $ jsonContent [ 'assets' ] ) ) { foreach ( $ jsonContent [ 'assets' ] as $ type => $ assets ) { foreach ( $ assets as $ key => $ asset ) { $ jsonAssets [ $ type ] [ $ key ] = $ assetService -> postProcessAssets ( $ asset ) ; } } $ jsonContent [ "assets" ] = $ jsonAssets ; } $ this -> dataCache [ $ cacheKey ] = $ jsonContent ; return $ this -> dataCache [ $ cacheKey ] ; } catch ( \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } catch ( \ League \ Flysystem \ FileNotFoundException $ e ) { throw new \ tao_models_classes_FileNotFoundException ( $ path . ' for item reference ' . $ itemRef ) ; } }
8294	private function openTransactionFile ( $ id ) { if ( ! isset ( $ this -> tFiles [ $ id ] ) ) { self :: preparePath ( $ this -> dir , self :: DATA_DIR ) ; $ fileName = $ this -> dir . static :: DATA_DIR . $ id ; $ handle = @ fopen ( $ fileName , 'c+' ) ; if ( $ handle === false ) { throw new \ RuntimeException ( "Could not open file: " . $ fileName ) ; } $ this -> tFiles [ $ id ] = new \ PicoAuth \ Storage \ File \ FileReader ( $ fileName , [ "handle" => $ handle ] ) ; } }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
12927	public function lists ( $ offset = 0 , $ limit = 10 ) { $ params = [ 'begin' => $ offset , 'limit' => $ limit , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST , $ params ] ) ; }
5695	public function nestedFormSave ( $ data , $ form , $ request ) { $ formAction = $ this -> getFormActionFromRequest ( $ request ) ; $ actionName = $ formAction -> getButtonName ( ) ; $ this -> record -> $ actionName ( $ data , $ form , $ request ) ; return Controller :: curr ( ) -> redirectBack ( ) ; }
5046	public function form ( $ form , $ options = null , $ as = 'searchform' ) { if ( is_string ( $ options ) ) { $ as = $ options ; $ options = null ; } $ this -> stack [ 'form' ] = [ 'as' => $ as , $ form , $ options ] ; return $ this ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
936	public static function getNameForId ( $ id ) { if ( CT :: has ( $ id ) ) { return CT :: getName ( $ id ) ; } $ name = token_name ( $ id ) ; return 'UNKNOWN' === $ name ? null : $ name ; }
7208	public function round ( ) : void { $ this -> unit = Money :: round ( $ this -> unit , $ this -> currency ) ; $ this -> gross = Money :: round ( $ this -> gross , $ this -> currency ) ; $ this -> discount = Money :: round ( $ this -> discount , $ this -> currency ) ; $ this -> base = Money :: round ( $ this -> base , $ this -> currency ) ; $ this -> total = Money :: round ( $ this -> total , $ this -> currency ) ; $ this -> tax = Money :: round ( $ this -> total - $ this -> base , $ this -> currency ) ; }
12751	public function sendWelcomeMessage ( User $ user , Token $ token = null ) { return $ this -> sendMessage ( $ user -> email , $ this -> welcomeSubject , 'welcome' , [ 'user' => $ user , 'token' => $ token ] ) ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
3066	public function process ( QtiRunnerServiceContext $ context , array $ data = [ ] ) { return $ this -> getServiceManager ( ) -> get ( SynchronisationService :: SERVICE_ID ) -> process ( $ data , $ context ) ; }
11143	public function run ( ) { $ list = $ this -> getClassList ( ) ; $ directCollection = new DirectCollection ( ) ; foreach ( $ list as $ class ) { $ cl = $ this -> processClass ( $ class ) ; if ( $ cl !== false ) { $ directCollection -> add ( $ cl ) ; } } return $ directCollection ; }
4930	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ i => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ i ] ) ; } } return empty ( $ this -> listeners ) ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
5713	public function updateItemEditForm ( $ form ) { if ( $ this -> owner -> record -> stat ( 'better_buttons_enabled' ) !== true ) { return false ; } Requirements :: css ( BETTER_BUTTONS_DIR . '/css/gridfield_betterbuttons.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons.js' ) ; $ actions = $ this -> owner -> record -> getBetterButtonsActions ( ) ; $ form -> setActions ( $ this -> filterFieldList ( $ form , $ actions ) ) ; if ( $ form -> Fields ( ) -> hasTabSet ( ) ) { $ form -> Fields ( ) -> findOrMakeTab ( 'Root' ) -> setTemplate ( TabSet :: class ) ; $ form -> addExtraClass ( 'cms-tabset' ) ; } $ utils = $ this -> owner -> record -> getBetterButtonsUtils ( ) ; $ form -> Utils = $ this -> filterFieldList ( $ form , $ utils ) ; $ form -> setTemplate ( [ 'type' => 'Includes' , 'BetterButtons_EditForm' , ] ) ; $ form -> addExtraClass ( 'better-buttons-form' ) ; }
5458	protected function openTag ( $ tag ) { $ name = $ tag -> getTagName ( ) ; if ( ! in_array ( $ name , array_keys ( $ this -> tags ) ) ) { $ this -> tags [ $ name ] = array ( ) ; } $ this -> tags [ $ name ] [ ] = $ tag ; }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
3143	public function timeout ( RunnerServiceContext $ context , $ scope , $ ref , $ late = false ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Select next item before timeout" ) ; $ context -> selectAdaptiveNextItem ( ) ; } try { $ session -> closeTimer ( $ ref , $ scope ) ; if ( $ late ) { if ( $ scope == 'assessmentTest' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW ; } else if ( $ scope == 'testPart' ) { $ code = AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW ; } else if ( $ scope == 'assessmentSection' ) { $ code = AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW ; } else { $ code = AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW ; } throw new AssessmentTestSessionException ( "Maximum duration of ${scope} '${ref}' not respected." , $ code ) ; } else { $ session -> checkTimeLimits ( false , true , false ) ; } } catch ( AssessmentTestSessionException $ e ) { $ this -> onTimeout ( $ context , $ e ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'timeout' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
2120	public function getFromFile ( ) { $ return = array ( ) ; $ files = System :: getContainer ( ) -> get ( 'contao.resource_finder' ) -> findIn ( 'config' ) -> depth ( 0 ) -> files ( ) -> name ( 'database.sql' ) ; foreach ( $ files as $ file ) { $ return = array_replace_recursive ( $ return , SqlFileParser :: parse ( $ file ) ) ; } ksort ( $ return ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'sqlGetFromFile' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ return = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ return ) ; } } return $ return ; }
10722	public function count ( $ col , $ alias , $ distinct = false ) { $ this -> counts [ ] = [ $ col , $ alias , $ distinct ] ; return $ this ; }
5161	public function attach ( string $ field , Model $ item ) : self { $ this -> attachment [ $ field ] [ ] = $ item ; return $ this ; }
9027	public function isQuestion ( $ string ) { $ probability = 0 ; if ( strpos ( $ string , '?' ) ) { $ probability += 1 ; } $ words = $ this -> getWords ( $ string ) ; foreach ( $ this -> inquiryWords as $ queryWord ) { if ( ! strncmp ( strtolower ( $ string ) , $ queryWord , strlen ( $ queryWord ) ) ) { $ probability += 1 ; } elseif ( stristr ( strtolower ( $ string ) , $ queryWord ) ) { $ probability += 0.5 ; } } if ( $ probability >= 2 ) { return true ; } return false ; }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
6622	public function add_styles ( ) { $ css = App :: EFG ( ) -> getOption ( 'assets' , 'css' ) ; WP_Register :: add ( 'style' , $ css [ 'extensionsForGrifusAdmin' ] ) ; WP_Register :: add ( 'style' , Module :: CustomRatingGrifus ( ) -> getOption ( 'assets' , 'css' , 'customRatingGrifusAdmin' ) ) ; }
1691	protected function compileColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( ! \ is_array ( $ color ) ) { return '#' . $ this -> shortenHexColor ( $ color ) ; } elseif ( ! isset ( $ color [ 1 ] ) || empty ( $ color [ 1 ] ) ) { return '#' . $ this -> shortenHexColor ( $ color [ 0 ] ) ; } else { return 'rgba(' . implode ( ',' , $ this -> convertHexColor ( $ color [ 0 ] , $ blnWriteToFile , $ vars ) ) . ',' . ( $ color [ 1 ] / 100 ) . ')' ; } }
8235	protected function ivalidateToken ( $ index , array & $ tokenStorage ) { unset ( $ tokenStorage [ $ index ] ) ; $ this -> session -> set ( self :: SESSION_KEY , $ tokenStorage ) ; }
5173	public static function createArticle ( String $ title , string $ body , string $ source , string $ uniqueId , int $ typeId , int $ categoryId , string $ reporter , string $ lead , string $ tags , string $ publishedAt , int $ identifier ) : Article { return new Article ( $ title , $ body , $ source , $ uniqueId , $ typeId , $ categoryId , $ reporter , $ lead , $ tags , $ publishedAt , $ identifier ) ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
9042	private function emptyEnvironment ( ) { foreach ( array_keys ( $ _ENV ) as $ key ) { putenv ( $ key ) ; unset ( $ _ENV [ $ key ] ) ; unset ( $ _SERVER [ $ key ] ) ; } }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
1672	public function protect ( ) { if ( ! $ this -> isUnprotected ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.public' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot protect folder "%s" because one of its parent folders is public' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.public' ) ) -> delete ( ) ; }
1488	public function when ( bool $ test , $ decodings ) : self { if ( ! $ test ) { return $ this ; } if ( $ decodings instanceof \ Closure ) { return $ decodings ( $ this ) ; } $ decodings = $ decodings instanceof Decoding ? [ $ decodings ] : $ decodings ; return $ this -> push ( ... $ decodings ) ; }
4908	public function render ( SummaryFormInterface $ form , $ layout = Form :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ renderer = $ this -> getView ( ) ; $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/jquery.summary-form.js' ) ) ; $ label = $ form -> getLabel ( ) ; $ labelContent = $ label ? '<div class="sf-headline"><h3>' . $ this -> getView ( ) -> translate ( $ label ) . '</h3></div>' : '' ; $ formContent = $ this -> renderForm ( $ form , $ layout , $ parameter ) ; $ summaryContent = $ this -> renderSummary ( $ form ) ; $ formContent = sprintf ( '<div class="sf-form"><div class="panel panel-info"><div class="panel-body">%s</div></div></div> <div class="sf-summary">%s</div> ' , $ formContent , $ summaryContent ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ this -> getView ( ) -> headscript ( ) -> appendFile ( $ this -> getView ( ) -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8">%s</div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } $ markup = '<div id="sf-%s" class="sf-container" data-display-mode="%s">' . '%s' . '%s' . '</div>' ; $ id = str_replace ( '.' , '-' , $ form -> getAttribute ( 'name' ) ) ; $ content = sprintf ( $ markup , $ id , $ form -> getDisplayMode ( ) , $ labelContent , $ formContent ) ; return $ content ; }
78	public function findPackage ( $ name , $ constraint ) { foreach ( $ this -> repositories as $ repository ) { if ( $ package = $ repository -> findPackage ( $ name , $ constraint ) ) { return $ package ; } } return null ; }
41	public static function checkCertificateHost ( $ certificate , $ hostname , & $ cn = null ) { $ names = self :: getCertificateNames ( $ certificate ) ; if ( empty ( $ names ) ) { return false ; } $ combinedNames = array_merge ( $ names [ 'san' ] , array ( $ names [ 'cn' ] ) ) ; $ hostname = strtolower ( $ hostname ) ; foreach ( $ combinedNames as $ certName ) { $ matcher = self :: certNameMatcher ( $ certName ) ; if ( $ matcher && $ matcher ( $ hostname ) ) { $ cn = $ names [ 'cn' ] ; return true ; } } return false ; }
11256	private function resolve ( string $ class ) : AbstractSeed { $ instance = $ this -> autowire ( $ class ) ; $ instance -> setDatabase ( $ this -> database ) ; $ instance -> setSeeder ( $ this ) ; if ( ! is_null ( $ this -> container ) ) { $ instance -> setContainer ( $ this -> container ) ; } return $ instance ; }
1217	public static function slice ( $ value , $ start = null , $ stop = null , $ step = 1 ) { if ( ! Utils :: isArray ( $ value ) && ! is_string ( $ value ) ) { throw new \ InvalidArgumentException ( 'Expects string or array' ) ; } return self :: sliceIndices ( $ value , $ start , $ stop , $ step ) ; }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
1925	public function convertToPaletteImage ( ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return $ this ; } $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; $ transparentColor = null ; if ( $ this -> countColors ( 256 ) <= 256 ) { $ paletteImage = imagecreate ( $ width , $ height ) ; $ colors = array ( ) ; $ isTransparent = false ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ color = imagecolorat ( $ this -> gdResource , $ x , $ y ) ; if ( ( ( $ color >> 24 ) & 0x7F ) === 127 ) { $ isTransparent = true ; } else { $ colors [ $ color & 0xFFFFFF ] = true ; } } } $ colors = array_keys ( $ colors ) ; foreach ( $ colors as $ index => $ color ) { imagecolorset ( $ paletteImage , $ index , ( $ color >> 16 ) & 0xFF , ( $ color >> 8 ) & 0xFF , $ color & 0xFF ) ; } if ( $ isTransparent ) { $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; } else { $ paletteImage = imagecreatetruecolor ( $ width , $ height ) ; imagealphablending ( $ paletteImage , false ) ; imagesavealpha ( $ paletteImage , true ) ; imagecopy ( $ paletteImage , $ this -> gdResource , 0 , 0 , 0 , 0 , $ width , $ height ) ; imagetruecolortopalette ( $ paletteImage , false , 255 ) ; $ transparentColor = imagecolorallocate ( $ paletteImage , 0 , 0 , 0 ) ; imagecolortransparent ( $ paletteImage , $ transparentColor ) ; } if ( $ transparentColor !== null ) { for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { if ( ( ( imagecolorat ( $ this -> gdResource , $ x , $ y ) >> 24 ) & 0x7F ) === 127 ) { imagefilledrectangle ( $ paletteImage , $ x , $ y , $ x , $ y , $ transparentColor ) ; } } } } imagedestroy ( $ this -> gdResource ) ; $ this -> gdResource = $ paletteImage ; return $ this ; }
7645	protected function getStorageClient ( $ path = '' ) { if ( is_null ( $ this -> storageClient ) ) { $ url = explode ( ':' , $ path ) ; if ( ! $ url ) { throw new BlobException ( 'Could not parse path "' . $ path . '".' ) ; } $ this -> storageClient = BlobClient :: getWrapperClient ( $ url [ 0 ] ) ; if ( ! $ this -> storageClient ) { throw new BlobException ( 'No storage client registered for stream type "' . $ url [ 0 ] . '://".' ) ; } } return $ this -> storageClient ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
701	protected function cleanupVendorDir ( $ dir ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } $ extensions = $ this -> findDirs ( "$dir/vendor/yiisoft" ) ; foreach ( $ extensions as $ ext ) { if ( is_link ( $ link = "$dir/vendor/yiisoft/yii2-$ext" ) ) { $ this -> stdout ( "Removing symlink $link.\n" ) ; FileHelper :: unlink ( $ link ) ; } } }
6796	protected function getValues ( $ valueIds , $ language ) { $ queryBuilder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ where = $ this -> getWhereColumn ( ) ? '(' . $ this -> getWhereColumn ( ) . ')' : null ; $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'source.*' ) -> from ( $ this -> getTagSource ( ) , 'source' ) -> where ( $ queryBuilder -> expr ( ) -> in ( 'source.' . $ this -> getIdColumn ( ) , $ valueIds ) ) -> andWhere ( $ queryBuilder -> expr ( ) -> andX ( ) -> add ( 'source.' . $ this -> getTagLangColumn ( ) . '=:lang' ) -> add ( $ where ) ) -> setParameter ( 'lang' , $ language ) -> groupBy ( 'source.' . $ this -> getIdColumn ( ) ) ; if ( $ this -> getTagSortSourceTable ( ) ) { $ statement -> addSelect ( $ this -> getTagSortSourceTable ( ) . '.*' ) ; $ statement -> join ( 's' , $ this -> getTagSortSourceTable ( ) , 'sort' , $ queryBuilder -> expr ( ) -> eq ( 'source.' . $ this -> getIdColumn ( ) , 'sort.id' ) ) ; if ( $ this -> getTagSortSourceColumn ( ) ) { $ statement -> orderBy ( $ this -> getTagSortSourceColumn ( 'sort' ) ) ; } } $ statement -> addOrderBy ( 'source.' . $ this -> getSortingColumn ( ) ) ; return $ statement -> execute ( ) ; }
11859	public static function getHandlingObject ( $ a , $ b ) { $ handlingA = $ a -> handlingComparison ; $ handlingB = $ b -> handlingComparison ; if ( ! $ handlingB ) { return $ a ; } if ( $ handlingA !== false && $ handlingB !== false ) { if ( $ handlingA > $ handlingB ) { return $ a ; } else { return $ b ; } } return $ a ; }
6120	public function serverStart ( $ sid ) { if ( $ sid == $ this -> serverSelectedId ( ) ) { $ this -> serverDeselect ( ) ; } $ this -> execute ( "serverstart" , array ( "sid" => $ sid ) ) ; $ this -> serverListReset ( ) ; Signal :: getInstance ( ) -> emit ( "notifyServerstarted" , $ this , $ sid ) ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
6858	protected static function solsticeJune ( $ year , $ vsop = true ) { $ month = 6 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
141	public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; }
7718	function meth_Conv_Prepare ( & $ Loc , $ StrConv ) { $ x = strtolower ( $ StrConv ) ; $ x = '+' . str_replace ( ' ' , '' , $ x ) . '+' ; if ( strpos ( $ x , '+esc+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvEsc = true ; } if ( strpos ( $ x , '+wsp+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvWS = true ; } if ( strpos ( $ x , '+js+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvJS = true ; } if ( strpos ( $ x , '+url+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUrl = true ; } if ( strpos ( $ x , '+utf8+' ) !== false ) { $ this -> f_Misc_ConvSpe ( $ Loc ) ; $ Loc -> ConvStr = false ; $ Loc -> ConvUtf8 = true ; } if ( strpos ( $ x , '+no+' ) !== false ) $ Loc -> ConvStr = false ; if ( strpos ( $ x , '+yes+' ) !== false ) $ Loc -> ConvStr = true ; if ( strpos ( $ x , '+nobr+' ) !== false ) { $ Loc -> ConvStr = true ; $ Loc -> ConvBr = false ; } }
1763	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; }
12816	private static function getColumns ( string $ table ) : array { if ( self :: $ columnsCache !== null && array_key_exists ( $ table , self :: $ columnsCache ) ) return self :: $ columnsCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT * FROM information_schema.columns WHERE table_name = '$table' " ; self :: $ columnsCache [ $ table ] = [ ] ; $ rows = $ pdo -> query ( $ query ) ; while ( $ row = $ rows -> fetch ( ) ) self :: $ columnsCache [ $ table ] [ $ row [ "column_name" ] ] = $ row ; return self :: $ columnsCache [ $ table ] ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
5938	public function addFunctionality ( $ item ) { if ( ! ( $ item instanceof Functionality ) ) { if ( is_array ( $ item ) ) { try { $ item = new Functionality ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate Functionality. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "Functionality"!' , E_USER_WARNING ) ; } } $ this -> functionalities [ ] = $ item ; return $ this ; }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
9228	public function put ( $ path , $ data = array ( ) , $ headers = array ( ) ) { return $ this -> postprocessResponse ( parent :: put ( $ path , $ this -> preprocessData ( $ data ) , $ headers ) ) ; }
4743	public function validateOptIn ( ) { $ optInValue = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) ; if ( $ this -> isReviewOptInValidationRequired ( ) && ! $ optInValue ) { return false ; } return true ; }
2509	protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; }
9709	private function writeCodepage ( ) { $ record = 0x0042 ; $ length = 0x0002 ; $ cv = $ this -> codepage ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cv ) ; $ this -> append ( $ header . $ data ) ; }
2266	public function indexExists ( $ strName , $ strTable , $ blnNoCache = false ) { if ( $ strName == '' || $ strTable == '' ) { return false ; } foreach ( $ this -> listFields ( $ strTable , $ blnNoCache ) as $ arrField ) { if ( $ arrField [ 'name' ] == $ strName && $ arrField [ 'type' ] == 'index' ) { return true ; } } return false ; }
3337	public function getInputTag ( $ name , $ attributes = array ( ) ) { $ to_compile = array ( ) ; foreach ( $ attributes as $ key => $ value ) { $ to_compile [ ] = sprintf ( '%s="%s"' , $ key , $ value ) ; } return sprintf ( '<input type="hidden" role="uploadcare-uploader" name="%s" data-upload-url-base="" data-integration="%s" %s />' , $ name , $ this -> getIntegrationData ( ) , join ( ' ' , $ to_compile ) ) ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
225	protected function asPercentStringFallback ( $ value , $ decimals = null ) { if ( empty ( $ value ) ) { $ value = 0 ; } if ( $ decimals === null ) { $ decimals = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = str_pad ( substr ( $ value , $ separatorPosition + 1 ) , 2 , '0' ) ; $ integerPart .= substr ( $ fractionalPart , 0 , 2 ) ; $ fractionalPart = substr ( $ fractionalPart , 2 ) ; if ( $ fractionalPart === '' ) { $ multipliedValue = $ integerPart ; } else { $ multipliedValue = $ integerPart . '.' . $ fractionalPart ; } } else { $ multipliedValue = $ value . '00' ; } return $ this -> asDecimalStringFallback ( $ multipliedValue , $ decimals ) . '%' ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
9191	public static function convert ( $ identifier , $ sourceFormat , $ outputFormat ) { $ parts = Parser :: parse ( $ identifier , $ sourceFormat ) ; return Formatter :: format ( $ parts , $ outputFormat ) ; }
8574	public function setGetMyPriceForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
10002	public function apply ( Tag $ tag , Renderer $ renderer ) { foreach ( $ this -> stack as $ item ) { $ result = $ item [ 'decorator' ] ( $ tag , $ renderer ) ; if ( $ result instanceof Tag ) { $ tag = $ result ; } else { trigger_error ( sprintf ( '%s does not return an instance of Sirius\\Html\\Tag' , get_class ( $ item [ 'decorator' ] ) ) , E_USER_WARNING ) ; } } return $ tag ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
3991	public function acceptsAnotherChild ( ModelInterface $ model , ModelCollector $ collector ) { $ conditionType = $ model -> getProperty ( 'type' ) ; if ( ! $ this -> conditionFactory -> supportsNesting ( $ conditionType ) ) { return false ; } if ( - 1 === ( $ max = $ this -> conditionFactory -> maxChildren ( $ conditionType ) ) ) { return true ; } return \ count ( $ collector -> collectDirectChildrenOf ( $ model ) ) < $ max ; }
7467	public function addColor ( $ color , $ code = null ) { $ newColors = $ this -> parseColor ( $ color , $ code ) ; $ this -> colors = array_merge ( $ this -> colors , $ newColors ) ; return $ this ; }
5646	public function createInvoker ( $ invoker ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ invoker = $ this -> reporters [ $ i ] -> createInvoker ( $ invoker ) ; } return $ invoker ; }
10967	public static function isSsl ( ) { $ isSecure = false ; if ( isset ( $ _SERVER [ 'HTTPS' ] ) && in_array ( $ _SERVER [ 'HTTPS' ] , [ 'on' , '1' ] ) ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] == 'https' ) { $ isSecure = true ; } elseif ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_SSL' ] == 'on' ) { $ isSecure = true ; } return $ isSecure ; }
9795	public function setDataValidation ( DataValidation $ pDataValidation = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set data validation for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setDataValidation ( $ this -> getCoordinate ( ) , $ pDataValidation ) ; return $ this -> updateInCollection ( ) ; }
11309	protected function populateStub ( string $ stub , ? string $ class = null ) : string { return str_replace ( '{class}' , $ this -> getName ( $ class ) , $ stub ) ; }
2589	protected function addReceivedFrom ( $ explicitRf , $ doAutoAdd , $ defaultRf , & $ tattooCounter ) { if ( $ this -> dataElementsMaster === null ) { $ this -> dataElementsMaster = new DataElementsMaster ( ) ; } if ( ! empty ( $ explicitRf ) || ( $ doAutoAdd && ! empty ( $ defaultRf ) ) ) { $ tattooCounter ++ ; $ rfToAdd = ( ! empty ( $ explicitRf ) ) ? $ explicitRf : $ defaultRf ; $ this -> dataElementsMaster -> dataElementsIndiv [ ] = $ this -> createElement ( new ReceivedFrom ( [ 'receivedFrom' => $ rfToAdd ] ) , $ tattooCounter ) ; } }
7688	function OpenXML_Rels_ReplaceTarget ( $ RelsPath , $ OldTarget , $ NewTarget ) { $ idx = $ this -> FileGetIdx ( $ RelsPath ) ; if ( $ idx === false ) $ this -> RaiseError ( "Cannot edit target in '$RelsPath' because the file is not found." ) ; $ txt = $ this -> TbsStoreGet ( $ idx , 'Replace target in rels file' ) ; $ att = 'Target="' . $ OldTarget . '"' ; $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ txt , $ att , 0 ) ; if ( $ loc ) { if ( $ NewTarget === false ) { $ loc -> Delete ( ) ; } else { $ loc -> ReplaceAtt ( 'Target' , $ NewTarget ) ; } $ this -> TbsStorePut ( $ idx , $ txt ) ; return true ; } else { return false ; } }
9485	public function checkCreatable ( ) { if ( property_exists ( $ this , 'id' ) && $ this -> id > 0 ) { throw new \ Exception ( get_class ( $ this ) . " has ID:" . $ this -> id ( ) . " thus not creatable." ) ; } }
1777	public static function optionSelected ( $ strOption , $ varValues ) { if ( $ strOption === '' ) { return '' ; } return ( \ is_array ( $ varValues ) ? \ in_array ( $ strOption , $ varValues ) : $ strOption == $ varValues ) ? ' selected' : '' ; }
2009	public function onInitializeSystem ( ) : void { foreach ( $ this -> globals as $ key => $ value ) { if ( \ is_array ( $ value ) && isset ( $ GLOBALS [ $ key ] ) && \ is_array ( $ GLOBALS [ $ key ] ) ) { $ GLOBALS [ $ key ] = array_replace_recursive ( $ GLOBALS [ $ key ] , $ value ) ; } else { $ GLOBALS [ $ key ] = $ value ; } } }
5321	public function remove ( ) { if ( is_resource ( $ this -> mutex ) ) { sem_remove ( $ this -> mutex ) ; } if ( file_exists ( $ this -> file ) ) { unlink ( $ this -> file ) ; } }
8681	public function set ( $ key , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; $ this -> items [ $ key ] = $ value ; }
4901	public static function loadConfig ( $ configuration = [ ] ) { $ configDir = static :: getConfigDir ( ) ; if ( empty ( $ configuration ) ) { $ configFile = $ configDir . '/config.php' ; if ( ! is_file ( $ configFile ) ) { throw new InvalidArgumentException ( sprintf ( 'Can not load config file "%s". Please be sure that this file exists and readable' , $ configFile ) ) ; } $ configuration = include $ configFile ; } $ isCli = php_sapi_name ( ) === 'cli' ; $ modules = $ configuration [ 'modules' ] ; $ modules = static :: generateModuleConfiguration ( $ modules ) ; $ yawikConfig = $ configDir . '/autoload/yawik.config.global.php' ; $ installMode = false ; if ( ! $ isCli && ! file_exists ( $ yawikConfig ) ) { $ modules = static :: generateModuleConfiguration ( [ 'Install' ] ) ; $ installMode = true ; } elseif ( in_array ( 'Install' , $ modules ) ) { $ modules = array_diff ( $ modules , [ 'Install' ] ) ; } static :: $ env = $ env = getenv ( 'APPLICATION_ENV' ) ? : 'production' ; $ defaults = [ 'module_listener_options' => [ 'module_paths' => [ './module' , './vendor' , './modules' ] , 'config_glob_paths' => [ sprintf ( $ configDir . '/autoload/{,*.}{global,%s,local}.php' , $ env ) ] , 'config_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_enabled' => ( $ env == 'production' ) , 'module_map_cache_key' => 'module_map' , 'check_dependencies' => ( $ env != 'production' ) , 'cache_dir' => getcwd ( ) . "/var/cache" , ] , ] ; $ envConfig = [ ] ; $ envConfigFile = $ configDir . '/config.' . $ env . '.php' ; if ( file_exists ( $ envConfigFile ) ) { if ( is_readable ( $ envConfigFile ) ) { $ envConfig = include $ envConfigFile ; } else { \ trigger_error ( sprintf ( 'Environment config file "%s" is not readable.' , $ envConfigFile ) , E_USER_NOTICE ) ; } } $ configuration = ArrayUtils :: merge ( $ defaults , $ configuration ) ; $ configuration = ArrayUtils :: merge ( $ configuration , $ envConfig ) ; $ configuration [ 'modules' ] = $ modules ; if ( $ installMode ) { $ configuration [ 'module_listener_options' ] [ 'config_cache_enabled' ] = false ; $ configuration [ 'module_listener_options' ] [ 'module_map_cache_enabled' ] = false ; } if ( getenv ( 'DOCKER_ENV' ) == 'yes' ) { $ configuration = ArrayUtils :: merge ( $ configuration , static :: getDockerEnv ( $ configuration ) ) ; } return $ configuration ; }
2834	public function startRendering ( Mage_Core_Block_Abstract $ block ) { if ( $ this -> isRendering ) { $ this -> renderedCount ++ ; Mage :: log ( "Recursive block rendering {$this->getName()}" , Zend_Log :: DEBUG ) ; return ; } $ this -> init ( $ block ) ; $ this -> isRendering = true ; $ this -> renderedCount ++ ; $ this -> renderedAt = microtime ( true ) ; if ( self :: $ startRenderingTime === null ) { self :: $ startRenderingTime = $ this -> renderedAt ; } }
12029	function generateParamFilterBlock ( \ ArtaxServiceBuilder \ Parameter $ parameter ) { $ i1 = ' ' ; $ i2 = ' ' ; $ text = '' ; $ text .= sprintf ( $ i1 . "case ('%s'): {" . PHP_EOL , $ parameter -> getName ( ) ) ; foreach ( $ parameter -> getFilters ( ) as $ filter ) { if ( is_array ( $ filter ) ) { $ text .= $ i2 . '$args = [];' . PHP_EOL ; if ( isset ( $ filter [ 'args' ] ) == true ) { if ( is_array ( $ filter [ 'args' ] ) == false ) { throw new \ ArtaxServiceBuilder \ APIBuilderException ( "Filter args should be an array instead received " . var_export ( $ filter [ 'args' ] , true ) ) ; } foreach ( $ filter [ 'args' ] as $ data ) { if ( $ data == '@value' ) { $ text .= $ i2 . '$args[] = $value;' . PHP_EOL ; } elseif ( $ data == '@api' ) { $ text .= $ i2 . "\$args[] = \$this->\$api;" . PHP_EOL ; } else { $ text .= $ i2 . "\$args[] = $data;" . PHP_EOL ; } } } $ text .= sprintf ( $ i2 . '$value = call_user_func_array([$value, \'%s\'], $args);' . PHP_EOL , $ filter [ 'method' ] ) ; } else { $ text .= sprintf ( $ i2 . 'call_user_func(\'%s\', $value);' . PHP_EOL , $ filter ) ; } } $ text .= $ i1 . ' break;' . PHP_EOL ; $ text .= $ i1 . '}' . PHP_EOL ; return $ text ; }
10073	public function allDrawings ( Spreadsheet $ spreadsheet ) { $ aDrawings = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { $ iterator = $ spreadsheet -> getSheet ( $ i ) -> getDrawingCollection ( ) -> getIterator ( ) ; while ( $ iterator -> valid ( ) ) { $ aDrawings [ ] = $ iterator -> current ( ) ; $ iterator -> next ( ) ; } } return $ aDrawings ; }
11423	public function batchGet ( array $ openIds , $ lang = 'zh_CN' ) { $ params = [ ] ; $ params [ 'user_list' ] = array_map ( function ( $ openId ) use ( $ lang ) { return [ 'openid' => $ openId , 'lang' => $ lang , ] ; } , $ openIds ) ; return $ this -> parseJSON ( 'json' , [ self :: API_BATCH_GET , $ params ] ) ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
7516	protected function expect ( $ token , $ do_next = true , $ try_next = false , $ next_on_match = 1 ) { if ( $ do_next ) { if ( $ do_next === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } if ( is_int ( $ token ) ) { if ( ( $ this -> token !== $ token ) && ( ( ! $ try_next ) || ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== $ token ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== $ token ) ) ) ) ) { $ this -> addError ( 'Unexpected "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } else { if ( ( $ this -> doc [ $ this -> pos ] !== $ token ) && ( ( ! $ try_next ) || ( ( ( ( $ try_next === 1 ) && ( $ this -> next ( ) !== self :: TOK_NULL ) ) || ( ( $ try_next === true ) && ( $ this -> next_no_whitespace ( ) !== self :: TOK_NULL ) ) ) && ( $ this -> doc [ $ this -> pos ] !== $ token ) ) ) ) { $ this -> addError ( 'Expected "' . $ token . '", but found "' . $ this -> getTokenString ( ) . '"' ) ; return false ; } } if ( $ next_on_match ) { if ( $ next_on_match === 1 ) { $ this -> next ( ) ; } else { $ this -> next_no_whitespace ( ) ; } } return true ; }
2748	private function extractMapping ( $ mapping , $ countryCode ) { $ final = null ; $ extractMapping = json_decode ( $ mapping , true ) ; if ( ! $ extractMapping ) { try { $ extractMapping = unserialize ( $ mapping ) ; } catch ( \ Exception $ e ) { $ extractMapping = [ ] ; } } if ( is_array ( $ extractMapping ) ) { $ countryId = 'country_id' ; $ key = 'store_id' ; foreach ( $ extractMapping as $ map ) { if ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && strtolower ( str_replace ( ' ' , '' , $ map [ $ countryId ] ) ) == strtolower ( $ countryCode ) ) { if ( isset ( $ map [ $ key ] ) ) { return ( int ) $ map [ $ key ] ; } } elseif ( is_array ( $ map ) && isset ( $ map [ $ countryId ] ) && $ map [ $ countryId ] == '*' && isset ( $ map [ $ key ] ) && $ final === null ) { $ final = ( int ) $ map [ $ key ] ; } } } return $ final ; }
5405	public function agePrematurely ( $ interval ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ this -> cookies [ $ i ] -> agePrematurely ( $ interval ) ; } }
5056	public function attachEvents ( EventManagerInterface $ events , array $ eventsSpec = null ) { if ( null === $ eventsSpec ) { $ eventsSpec = $ this -> eventsProvider ( ) ; } foreach ( $ eventsSpec as $ spec ) { if ( ! is_array ( $ spec ) || 2 > count ( $ spec ) ) { throw new \ UnexpectedValueException ( 'Event specification must be an array with at least two entries: event name and method name.' ) ; } $ event = $ spec [ 0 ] ; $ method = $ spec [ 1 ] ; $ priority = isset ( $ spec [ 2 ] ) ? $ spec [ 2 ] : 0 ; $ this -> listeners [ ] = $ events -> attach ( $ event , [ $ this , $ method ] , $ priority ) ; } return $ this ; }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
11969	public static function SetAuthClass ( $ authClass ) { $ toolClass = \ MvcCore \ Application :: GetInstance ( ) -> GetToolClass ( ) ; if ( $ toolClass :: CheckClassInterface ( $ authClass , 'MvcCore\Ext\Auths\Basics\IAuth' , TRUE , TRUE ) ) self :: $ authClass = $ authClass ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
11516	public function updateMetadata ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ HTML5Favicon = $ config -> HTML5Favicon ( ) ; $ IOSPinicon = $ config -> IOSPinicon ( ) ; $ AndroidPinicon = $ config -> AndroidPinicon ( ) ; $ WindowsPinicon = $ config -> WindowsPinicon ( ) ; if ( $ IOSPinicon -> exists ( ) ) { $ this -> GenerateIOSPinicon ( $ config , $ owner , $ metadata , $ IOSPinicon ) ; } if ( $ HTML5Favicon -> exists ( ) ) { $ this -> GenerateHTML5Favicon ( $ owner , $ metadata , $ HTML5Favicon ) ; } if ( $ AndroidPinicon -> exists ( ) ) { $ this -> GenerateAndroidPinicon ( $ config , $ owner , $ metadata ) ; } if ( $ WindowsPinicon -> exists ( ) ) { $ this -> GenerateWindowsPinicon ( $ config , $ owner , $ metadata , $ WindowsPinicon ) ; } }
9852	public function setPath ( $ pValue , $ pVerifyFile = true ) { if ( $ pVerifyFile ) { if ( file_exists ( $ pValue ) ) { $ this -> path = $ pValue ; if ( $ this -> width == 0 && $ this -> height == 0 ) { list ( $ this -> width , $ this -> height ) = getimagesize ( $ pValue ) ; } } else { throw new PhpSpreadsheetException ( "File $pValue not found!" ) ; } } else { $ this -> path = $ pValue ; } return $ this ; }
2297	public static function handleRunOnce ( ) { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/runonce.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { return ; } foreach ( $ files as $ file ) { try { include $ file ; } catch ( \ Exception $ e ) { } $ strRelpath = StringUtil :: stripRootDir ( $ file ) ; if ( ! unlink ( $ file ) ) { throw new \ Exception ( "The file $strRelpath cannot be deleted. Please remove the file manually and correct the file permission settings on your server." ) ; } System :: log ( "File $strRelpath ran once and has then been removed successfully" , __METHOD__ , TL_GENERAL ) ; } }
5780	private function setNav ( ) { $ this -> nav = [ 'System' => [ 'subSections' => [ 'Administrators' => [ 'route' => ROUTE_ADMINISTRATORS , 'authorization' => ADMINISTRATORS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_INSERT , 'authorization' => ADMINISTRATORS_INSERT_RESOURCE , ] , ] ] , 'Roles' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES , 'authorization' => ROLES_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_ROLES_INSERT , 'authorization' => ROLES_INSERT_RESOURCE , ] , ] , ] , 'Permissions' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS , 'authorization' => PERMISSIONS_VIEW_RESOURCE , 'subSections' => [ 'Insert' => [ 'route' => ROUTE_ADMINISTRATORS_PERMISSIONS_INSERT , 'authorization' => PERMISSIONS_INSERT_RESOURCE , ] , ] ] , 'Events' => [ 'route' => ROUTE_EVENTS , 'authorization' => EVENTS_VIEW_RESOURCE , 'subSections' => [ 'Types' => [ 'route' => ROUTE_DATABASE_TABLES , 'args' => [ ROUTEARG_DATABASE_TABLE_NAME => 'event_types' ] , 'authorization' => EVENTS_VIEW_RESOURCE , ] , ] ] , 'Database' => [ 'authorization' => DATABASE_TABLES_VIEW_RESOURCE , 'subSections' => $ this -> getDatabaseTablesSection ( ) ] , ] ] , 'Logout' => [ 'route' => ROUTE_LOGOUT , ] , ] ; if ( isset ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { if ( ! is_array ( $ this -> container [ 'settings' ] [ 'adminNav' ] ) ) { throw new \ Exception ( "adminNav config must be array" ) ; } $ this -> nav = array_merge ( $ this -> container [ 'settings' ] [ 'adminNav' ] , $ this -> nav ) ; } }
7693	function MsExcel_SheetIsIt ( $ FileName ) { $ this -> MsExcel_SheetInit ( ) ; foreach ( $ this -> MsExcel_Sheets as $ o ) { if ( $ FileName == 'xl/' . $ o -> file ) return true ; } return false ; }
7347	static public function calculateDeliveryRemainingQuantity ( $ item ) { if ( $ item instanceof SupplierOrderItemInterface ) { return $ item -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ item ) ; } if ( ! $ item instanceof SupplierDeliveryItemInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SupplierOrderItemInterface :: class . " or " . SupplierDeliveryItemInterface :: class ) ; } $ orderItem = $ item -> getOrderItem ( ) ; $ result = $ orderItem -> getQuantity ( ) - static :: calculateReceivedQuantity ( $ orderItem ) ; if ( 0 < $ item -> getQuantity ( ) ) { $ result += $ item -> getQuantity ( ) ; } return $ result ; }
1528	protected function transaction ( Closure $ closure ) { if ( ! $ this -> useTransactions ) { return $ closure ( ) ; } return app ( 'db' ) -> connection ( $ this -> connection ) -> transaction ( $ closure ) ; }
6055	public function addMediaToFolder ( $ folderId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/folders/' . $ folderId . '/media' , $ parameters ) ; return $ result ; }
8988	public function toStatusLine ( ) : string { return sprintf ( "%s %d %s" , $ this -> proto , $ this -> code , self :: getStatus ( $ this -> code ) ) ; }
4563	public function preUpdate ( PreUpdateEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Parameter ) { return ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
942	public function isDryRun ( ) { if ( null === $ this -> isDryRun ) { if ( $ this -> isStdIn ( ) ) { $ this -> isDryRun = true ; } else { $ this -> isDryRun = $ this -> options [ 'dry-run' ] ; } } return $ this -> isDryRun ; }
11447	public function actionIndex ( $ option = null ) { $ fixtures = Yii :: createObject ( Fixtures :: className ( ) ) ; $ option = Question :: displayWithQuit ( 'Select operation' , [ 'Export' , 'Import' ] , $ option ) ; if ( $ option == 'e' ) { $ allTables = $ fixtures -> tableNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for export' , $ allTables , 1 ) ; $ tables = $ fixtures -> export ( $ answer ) ; Output :: items ( $ tables , 'Exported tables' ) ; } else { Output :: block ( "not tables for export!" ) ; } } elseif ( $ option == 'i' ) { $ allTables = $ fixtures -> fixtureNameList ( ) ; if ( ! empty ( $ allTables ) ) { $ answer = Select :: display ( 'Select tables for import' , $ allTables , 1 ) ; $ tables = $ fixtures -> import ( $ answer ) ; Output :: items ( $ tables , 'Imported tables' ) ; } else { Output :: block ( "not tables for import!" ) ; } } }
10194	public static function getLastQuery ( $ connection = "" ) { $ last_query = "" ; $ pretty_queries = self :: getPrettyQueryLog ( $ connection ) ; if ( ! empty ( $ pretty_queries ) ) { $ last_query = $ pretty_queries [ count ( $ pretty_queries ) - 1 ] ; } return $ last_query ; }
686	protected function sortModels ( $ models , $ sort ) { $ orders = $ sort -> getOrders ( ) ; if ( ! empty ( $ orders ) ) { ArrayHelper :: multisort ( $ models , array_keys ( $ orders ) , array_values ( $ orders ) ) ; } return $ models ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
7578	protected function configureData ( $ data ) { if ( ! empty ( $ this -> _REQUIRED_DATA ) && is_array ( $ data ) ) { $ data = $ this -> configureDefaultData ( $ data ) ; } $ this -> setData ( $ data ) ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
10657	public function getArrayCopyRec ( ) { $ ret = array ( ) ; $ it = $ this -> getIterator ( ) ; while ( $ it -> valid ( ) ) { if ( $ it -> current ( ) instanceof self ) { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) -> getArrayCopyRec ( ) ; } else { $ ret [ $ it -> key ( ) ] = $ it -> current ( ) ; } $ it -> next ( ) ; } return $ ret ; }
4800	function via ( $ column ) { $ this -> column = $ column ; $ this -> conditions [ 0 ] = "$this->table.$column AND" ; $ this -> where [ 0 ] = "(" . $ this -> whereIn ( "$this->table.$column" , array_keys ( ( array ) $ this -> result -> rows ) ) . ")" ; return $ this ; }
11622	public function api ( string $ link = null , string $ method = null ) : \ TheCMSThread \ Classes \ API { static $ api ; if ( $ api === null ) { $ api = $ this -> container -> get ( "TheCMSThread\\Core\\API" ) ; } return $ api -> set ( $ link , $ method ) ; }
7809	public static function toDebugReport ( ) { $ report = 'PHP SDK (zipMoney) Debug Report:' . PHP_EOL ; $ report .= ' OS: ' . php_uname ( ) . PHP_EOL ; $ report .= ' PHP Version: ' . phpversion ( ) . PHP_EOL ; $ report .= ' OpenAPI Spec Version: 2017-03-01' . PHP_EOL ; $ report .= ' Temp Folder Path: ' . self :: getDefaultConfiguration ( ) -> getTempFolderPath ( ) . PHP_EOL ; return $ report ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
4105	public function beginBulk ( ) { if ( ! $ this -> bulk ) { $ this -> bulk = $ this -> createBulk ( $ this ) ; } return $ this -> bulk ; }
10528	protected function getIpAddressFromProxy ( ) { if ( ! $ this -> useProxy || ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) && ! in_array ( $ _SERVER [ 'REMOTE_ADDR' ] , $ this -> trustedProxies ) ) ) { return false ; } $ header = $ this -> proxyHeader ; if ( ! isset ( $ _SERVER [ $ header ] ) || empty ( $ _SERVER [ $ header ] ) ) { return false ; } $ ips = explode ( ',' , $ _SERVER [ $ header ] ) ; $ ips = array_map ( 'trim' , $ ips ) ; $ ips = array_diff ( $ ips , $ this -> trustedProxies ) ; if ( empty ( $ ips ) ) { return false ; } $ ip = array_pop ( $ ips ) ; return $ ip ; }
9016	public function markAllNotificationsAsRead ( ) { $ object = Auth :: user ( ) ; $ object -> unreadNotifications -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
3763	private function getLegendProperty ( LegendInterface $ legend , $ propertyName ) { if ( $ legend -> hasProperty ( $ propertyName ) ) { $ property = $ legend -> getProperty ( $ propertyName ) ; } else { $ property = new Property ( $ propertyName ) ; $ legend -> addProperty ( $ property ) ; } return $ property ; }
12252	public function addMissing ( $ objStructure , & $ objElement ) { foreach ( $ objStructure -> attributes ( ) as $ strName => $ objAttribute ) { if ( ! isset ( $ objElement -> attributes ( ) -> $ strName ) ) { $ objElement -> addAttribute ( $ strName , ( string ) $ objAttribute ) ; } } foreach ( $ objStructure -> children ( ) as $ strName => $ varNode ) { if ( count ( $ varNode ) > 0 ) { $ objNode = $ objElement -> addChild ( $ strName ) ; $ this -> addMissing ( $ varNode , $ objNode ) ; } else { $ objElement -> addChild ( $ strName , ( string ) $ varNode ) ; } } }
9496	public function getCollection ( $ end_point , $ collectionName , $ page = 1 , $ per_page = 100 , $ sort_by = null , $ sort_order = 'asc' ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ query = $ request -> getQuery ( ) -> set ( 'page' , $ page ) -> set ( 'per_page' , $ per_page ) ; if ( $ sort_by ) { $ query -> set ( 'sort_by' , $ sort_by ) -> set ( 'sort_order' , $ sort_order == 'asc' ? 'asc' : 'desc' ) ; } $ response = $ this -> processRequest ( $ request ) ; $ values = $ response -> json ( ) ; $ result = new PaginatedResult ( ) ; $ result -> setClient ( $ this ) ; if ( array_key_exists ( 'count' , $ values ) ) { $ result -> setCount ( $ values [ 'count' ] ) ; } $ result -> setCurrentPage ( $ page ) ; $ result -> setPerPage ( $ per_page ) ; $ result -> setEndPoint ( $ end_point ) ; $ type = $ this -> getType ( ) ; if ( array_key_exists ( $ collectionName , $ values ) && is_array ( $ values [ $ collectionName ] ) ) { foreach ( $ values [ $ collectionName ] as $ value ) { $ entity = new $ type ( ) ; $ this -> manage ( $ entity ) ; $ result [ ] = $ entity -> fromArray ( $ value ) ; } } return $ result ; }
12780	public function setState ( $ key , $ value ) { return Yii :: $ app -> webState -> set ( $ this -> stateKeyName ( $ key ) , $ value ) ; }
2237	public function generatePdf ( ) { $ this -> headline = $ this -> title ; $ this -> printable = false ; $ strArticle = $ this -> replaceInsertTags ( $ this -> generate ( ) , false ) ; $ strArticle = html_entity_decode ( $ strArticle , ENT_QUOTES , Config :: get ( 'characterSet' ) ) ; $ strArticle = $ this -> convertRelativeUrls ( $ strArticle , '' , true ) ; $ arrSearch = array ( '@<form.*</form>@Us' , '@<a [^>]*href="[^"]*javascript:[^>]+>.*</a>@Us' ) ; $ strArticle = preg_replace ( $ arrSearch , '' , $ strArticle ) ; if ( empty ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { throw new \ Exception ( 'No PDF extension found. Did you forget to install contao/tcpdf-bundle?' ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'printArticleAsPdf' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strArticle , $ this ) ; } } }
399	protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } $ condition = $ this -> getOldPrimaryKey ( true ) ; $ lock = $ this -> optimisticLock ( ) ; if ( $ lock !== null ) { $ condition [ $ lock ] = $ this -> $ lock ; } $ result = static :: deleteAll ( $ condition ) ; if ( $ lock !== null && ! $ result ) { throw new StaleObjectException ( 'The object being deleted is outdated.' ) ; } $ this -> setOldAttributes ( null ) ; $ this -> afterDelete ( ) ; return $ result ; }
9958	public function unprotectCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( isset ( $ this -> protectedCells [ $ pRange ] ) ) { unset ( $ this -> protectedCells [ $ pRange ] ) ; } else { throw new Exception ( 'Cell range ' . $ pRange . ' not known as protected.' ) ; } return $ this ; }
11276	public function getMessage ( ) { $ response = [ ] ; if ( $ messages = $ this -> data -> query ( '/Message/Body/Errors' ) -> array ( ) ) { foreach ( $ messages as $ message ) { $ response [ ] = $ message -> textContent ; } } return count ( $ response ) ? implode ( ', ' , $ response ) : null ; }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
2322	public static function getPixelValue ( $ size ) { @ trigger_error ( 'Using Image::getPixelValue() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ value = preg_replace ( '/[^0-9.-]+/' , '' , $ size ) ; $ unit = preg_replace ( '/[^acehimnprtvwx%]/' , '' , $ size ) ; switch ( $ unit ) { case '' : case 'px' : return ( int ) round ( $ value ) ; break ; case 'em' : return ( int ) round ( $ value * 16 ) ; break ; case 'ex' : return ( int ) round ( $ value * 16 / 2 ) ; break ; case 'pt' : return ( int ) round ( $ value * 16 / 12 ) ; break ; case 'pc' : return ( int ) round ( $ value * 16 ) ; break ; case 'in' : return ( int ) round ( $ value * 16 * 6 ) ; break ; case 'cm' : return ( int ) round ( $ value * 16 / ( 2.54 / 6 ) ) ; break ; case 'mm' : return ( int ) round ( $ value * 16 / ( 25.4 / 6 ) ) ; break ; case '%' : return ( int ) round ( $ value * 16 / 100 ) ; break ; } return 0 ; }
9811	protected function pureGet ( string $ path , array $ params = [ ] , array $ headers = [ ] ) { if ( $ params ) { $ path .= '?' . http_build_query ( $ params ) ; } return $ this -> client -> get ( $ path , $ headers ) ; }
1869	private function parseFile ( string $ file ) : array { $ code = '' ; $ namespace = '' ; $ buffer = false ; $ stream = new \ PHP_Token_Stream ( $ file ) ; foreach ( $ stream as $ token ) { switch ( true ) { case $ token instanceof \ PHP_Token_OPEN_TAG : case $ token instanceof \ PHP_Token_CLOSE_TAG : break ; case false !== $ buffer : $ buffer .= $ token ; if ( ';' === ( string ) $ token ) { $ code .= $ this -> handleDeclare ( $ buffer ) ; $ buffer = false ; } break ; case $ token instanceof \ PHP_Token_NAMESPACE : if ( '{' === $ token -> getName ( ) ) { $ namespace = false ; $ code .= $ token ; } else { $ namespace = $ token -> getName ( ) ; $ stream -> seek ( $ token -> getEndTokenId ( ) ) ; } break ; case $ token instanceof \ PHP_Token_DECLARE : $ buffer = ( string ) $ token ; break ; default : $ code .= $ token ; } } return [ $ code , $ namespace ] ; }
684	public function mergeRules ( array $ rules ) { $ this -> setRules ( ArrayHelper :: merge ( $ this -> getRules ( ) , $ rules ) ) ; return $ this ; }
11686	public function getLocation ( $ location , $ owner = null ) { $ bucket = $ this -> getBucket ( 'locations:' . $ location ) ; if ( is_null ( $ owner ) ) { return $ bucket -> toArray ( ) ; } else { $ result = [ ] ; foreach ( $ bucket as $ key => $ widget ) { if ( $ widget -> owner === $ owner ) { $ result [ $ key ] = $ widget ; } } return $ result ; } }
1195	private function getExtensions ( ) { if ( null === $ this -> sorted ) { krsort ( $ this -> extensions ) ; $ this -> sorted = ! empty ( $ this -> extensions ) ? call_user_func_array ( 'array_merge' , $ this -> extensions ) : array ( ) ; } return $ this -> sorted ; }
10686	private function showPermissionError ( PermissionError $ e ) { if ( PHP_SAPI !== "cli" ) { http_response_code ( 500 ) ; header ( "Content-type: text/plain" ) ; } if ( $ this -> dev ) { $ file = $ e -> path ; echo "{$e->getMessage()}\n" ; echo "\n" ; echo WF :: str ( $ e , false ) ; } else { echo "A permission error is preventing this page from displaying properly." ; } die ( ) ; }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
6324	public function start ( ) { if ( ! isset ( $ this -> _dir ) ) { return false ; } $ this -> _page = $ this -> url ; $ this -> _file = $ this -> _dir . md5 ( $ this -> _page ) . '.' . $ this -> _ext ; $ ignore_page = false ; for ( $ i = 0 ; $ i < count ( $ this -> _ignoreList ) ; $ i ++ ) { $ ignore_page = ( strpos ( $ this -> _page , $ this -> _ignoreList [ $ i ] ) !== false ) ? true : $ ignore_page ; } $ cachefile_created = ( file_exists ( $ this -> _file ) && ( $ ignore_page === false ) ) ? filemtime ( $ this -> _file ) : 0 ; clearstatcache ( ) ; if ( time ( ) - $ this -> _time < $ cachefile_created ) { ob_start ( 'ob_gzhandler' ) ; readfile ( $ this -> _file ) ; ob_end_flush ( ) ; exit ( ) ; } ob_start ( 'ob_gzhandler' ) ; }
12171	public static function getDefaultForClass ( $ class , array $ params = array ( ) ) { $ reflectionClass = new ReflectionClass ( $ class ) ; if ( ! $ reflectionClass -> isInstantiable ( ) ) { throw new NotInstantiableException ( "Class $class is not instantiable" ) ; } $ factory = new static ( [ $ reflectionClass , 'newInstance' ] , "$class::__construct" ) ; if ( $ reflectionClass -> hasMethod ( '__construct' ) ) { static :: addReflectionArguments ( $ factory , $ reflectionClass -> getMethod ( '__construct' ) ) ; } return $ factory -> getFactory ( $ params ) ; }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
2634	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippet = $ this -> getRequest ( ) -> getParam ( 'snippet_id' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ snippet ) ; $ snippetName = explode ( '_' , $ snippet ) ; $ snippetName = explode ( '.' , $ snippetName [ 2 ] ) ; $ reqName = Config :: FASTLY_MAGENTO_MODULE . '_' . $ snippetName [ 0 ] ; $ checkIfSnippetExist = $ this -> api -> hasSnippet ( $ activeVersion , $ reqName ) ; if ( $ checkIfSnippetExist ) { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ this -> api -> removeSnippet ( $ clone -> number , $ reqName ) ; $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ comment = [ 'comment' => 'Magento Module deleted the ' . $ reqName . ' custom snippet.' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; } if ( $ write -> isExist ( $ snippetPath ) ) { $ write -> delete ( $ snippetPath ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5244	private function prefixNamespace ( string $ targetFile ) { $ pattern = sprintf ( '/%1$s\\s+(?!(%2$s)|(Composer(\\\\|;)))/' , 'namespace' , $ this -> namespacePrefix ) ; $ replacement = sprintf ( '%1$s %2$s' , 'namespace' , $ this -> namespacePrefix ) ; $ this -> replace ( $ pattern , $ replacement , $ targetFile ) ; }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
3239	private function resetCalculations ( ) { $ this -> shopCalculations = null ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: forget ( $ this -> calculationsCacheKey ) ; } }
4353	public function onLog ( Event $ event ) { if ( ! $ this -> fileHandle ) { return ; } $ method = $ event [ 'method' ] ; if ( $ method == 'groupUncollapse' ) { return ; } $ args = $ event [ 'args' ] ; $ meta = $ event [ 'meta' ] ; $ isSummaryBookend = $ method == 'groupSummary' || ! empty ( $ meta [ 'closesSummary' ] ) ; if ( $ isSummaryBookend ) { \ fwrite ( $ this -> fileHandle , "=========\n" ) ; return ; } if ( $ args ) { $ str = $ this -> processLogEntryWEvent ( $ method , $ args , $ meta ) ; \ fwrite ( $ this -> fileHandle , $ str ) ; } elseif ( $ method == 'groupEnd' && $ this -> depth > 0 ) { $ this -> depth -- ; } }
970	public function setDomain ( string $ shopDomain ) { $ this -> fixLifetime ( ) ; Session :: put ( self :: DOMAIN , $ shopDomain ) ; }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
11835	public function save ( IUser $ user ) : bool { if ( ! $ user instanceof Entity ) { return false ; } return entityManager ( ) -> save ( $ user ) ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
9002	public function column_time ( AbstractLog $ item ) { $ time = $ item -> get_time ( ) ; if ( empty ( $ time ) ) { echo '-' ; } else { echo $ time -> format ( get_option ( 'date_format' ) . ' ' . get_option ( 'time_format' ) ) ; } }
4307	public function timeEnd ( $ label = null , $ returnOrTemplate = false , $ precision = 4 ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'label' => null , 'returnOrTemplate' => false , 'precision' => 4 , ) ) ; \ extract ( $ args ) ; if ( \ is_bool ( $ label ) || \ strpos ( $ label , '%time' ) !== false ) { if ( \ is_numeric ( $ returnOrTemplate ) ) { $ precision = $ returnOrTemplate ; } $ returnOrTemplate = $ label ; $ label = null ; } $ ret = $ this -> timeGet ( $ label , true , null ) ; if ( isset ( $ label ) ) { if ( isset ( $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] ) ) { $ this -> data [ 'timers' ] [ 'labels' ] [ $ label ] = array ( $ ret , null , ) ; } } else { $ label = 'time' ; \ array_pop ( $ this -> data [ 'timers' ] [ 'stack' ] ) ; } if ( \ is_int ( $ precision ) ) { $ ret = \ number_format ( $ ret , $ precision , '.' , '' ) ; } $ this -> doTime ( $ ret , $ returnOrTemplate , $ label , $ meta ) ; return $ ret ; }
6624	public function process ( Request $ request ) : Response { $ router = $ request -> attributes -> get ( 'router' ) ; $ next = next ( $ this -> middlewareStack ) ; if ( $ next instanceof Middleware ) { $ router -> log ( "Router: Calling Middleware: %s" , get_class ( $ next ) ) ; $ response = $ next -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , get_class ( $ next ) ) ; return $ response ; } elseif ( is_string ( $ next ) ) { $ router -> log ( "Router: Calling Middleware: %s" , $ next ) ; $ response = $ router -> getMiddleware ( $ next ) -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , $ next ) ; return $ response ; } else { $ params = $ request -> attributes -> get ( 'controller' ) ; $ router -> log ( "Router: Calling Controller: %s@%s" , $ params -> className , $ params -> method ) ; $ return = ( new $ params -> className ( $ params -> container ) ) -> { $ params -> method } ( $ request , ... array_values ( $ params -> args ) ) ; $ router -> log ( "Router: Controller Left" ) ; if ( $ return instanceof Response ) { return $ return ; } if ( is_array ( $ return ) or is_object ( $ return ) ) { return new JsonResponse ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'application/json' ) ) ; } return new Response ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'text/html' ) ) ; } }
809	private function sortByLength ( array $ first , array $ second ) { $ firstNamespace = ( self :: IMPORT_TYPE_CLASS === $ first [ 'importType' ] ? '' : $ first [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ; $ secondNamespace = ( self :: IMPORT_TYPE_CLASS === $ second [ 'importType' ] ? '' : $ second [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ; $ firstNamespaceLength = \ strlen ( $ firstNamespace ) ; $ secondNamespaceLength = \ strlen ( $ secondNamespace ) ; if ( $ firstNamespaceLength === $ secondNamespaceLength ) { $ sortResult = strcasecmp ( $ firstNamespace , $ secondNamespace ) ; } else { $ sortResult = $ firstNamespaceLength > $ secondNamespaceLength ? 1 : - 1 ; } return $ sortResult ; }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
8254	protected function handleRegistration ( Request $ httpRequest ) { $ registration = $ this -> picoAuth -> getContainer ( ) -> get ( 'Registration' ) ; $ registration -> setConfig ( $ this -> config ) -> handleRegistration ( $ httpRequest ) ; }
2686	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ req = $ this -> api -> checkImageOptimizationStatus ( ) ; if ( ! $ req ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check image optimization status.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'req_setting' => $ req ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
991	public static function allRules ( ) { if ( ! self :: $ initRules ) { static :: $ rules = array_merge ( static :: defaultRules ( ) , self :: securityRules ( ) , self :: $ rules ) ; static :: $ initRules = true ; } return self :: $ rules ; }
1530	public function resource ( string $ resourceType , array $ options = [ ] ) : ResourceRegistration { return new ResourceRegistration ( $ this -> router , $ resourceType , array_merge ( $ this -> options , $ options ) ) ; }
10766	private function implodeContent ( ) { ksort ( $ this -> content ) ; $ output = '' ; foreach ( $ this -> content as $ key => $ value ) { $ output .= $ key . self :: KV_DELIMITER . $ value . self :: DELIMITER ; } return rtrim ( $ output , self :: DELIMITER ) ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
11215	public static function __callstatic ( $ method , $ params ) { $ uri = $ params [ 0 ] ; $ callback = $ params [ 1 ] ; array_push ( self :: $ routes , $ uri ) ; array_push ( self :: $ methods , strtoupper ( $ method ) ) ; array_push ( self :: $ callbacks , $ callback ) ; }
8175	protected function optimizePrintNode ( Twig_NodeInterface $ node , Twig_Environment $ env ) { if ( ! $ node instanceof Twig_Node_Print ) { return $ node ; } $ exprNode = $ node -> getNode ( 'expr' ) ; if ( $ exprNode instanceof Twig_Node_Expression_BlockReference || $ exprNode instanceof Twig_Node_Expression_Parent ) { $ exprNode -> setAttribute ( 'output' , true ) ; return $ exprNode ; } return $ node ; }
8601	private function _convertDeleteSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetNotificationType ( ) ) { $ parameters [ 'NotificationType' ] = $ request -> getNotificationType ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeleteSubscriptionInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeleteSubscriptionInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
929	public function clean ( ) { foreach ( $ this -> files as $ file => $ value ) { $ this -> unlink ( $ file ) ; } $ this -> files = [ ] ; }
2215	public function next ( ) { if ( $ this -> blnDone ) { return false ; } if ( $ this -> fetchAssoc ( ) !== false ) { return $ this ; } $ this -> blnDone = true ; return false ; }
3186	public function start ( $ tags , $ timestamp ) { if ( ! is_numeric ( $ timestamp ) || $ timestamp < 0 ) { throw new InvalidDataException ( 'start() needs a valid timestamp!' ) ; } $ range = $ this -> getRange ( $ tags ) ; if ( $ this -> isRangeOpen ( $ range ) ) { \ common_Logger :: t ( 'Missing END TimePoint in QtiTimer, auto add an arbitrary value' ) ; $ point = new TimePoint ( $ tags , $ timestamp - ( 1 / TimePoint :: PRECISION ) , TimePoint :: TYPE_END , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; $ range [ ] = $ point ; } $ this -> checkTimestampCoherence ( $ range , $ timestamp ) ; $ point = new TimePoint ( $ tags , $ timestamp , TimePoint :: TYPE_START , TimePoint :: TARGET_SERVER ) ; $ this -> timeLine -> add ( $ point ) ; return $ this ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
3047	protected function getToolStates ( ) { $ toolStates = $ this -> getRunnerService ( ) -> getToolsStates ( $ this -> getServiceContext ( ) ) ; array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_decode ( $ toolState ) ; } ) ; return $ toolStates ; }
8406	private function getModelName ( ) { if ( isset ( $ this -> class ) ) { return $ this -> class ; } if ( isset ( $ this -> model ) ) { $ rClass = new \ ReflectionClass ( $ this -> model ) ; return $ rClass -> getShortName ( ) ; } return 'Icon' ; }
727	public static function on ( $ class , $ name , $ handler , $ data = null , $ append = true ) { $ class = ltrim ( $ class , '\\' ) ; if ( strpos ( $ class , '*' ) !== false || strpos ( $ name , '*' ) !== false ) { if ( $ append || empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { self :: $ _eventWildcards [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _eventWildcards [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } return ; } if ( $ append || empty ( self :: $ _events [ $ name ] [ $ class ] ) ) { self :: $ _events [ $ name ] [ $ class ] [ ] = [ $ handler , $ data ] ; } else { array_unshift ( self :: $ _events [ $ name ] [ $ class ] , [ $ handler , $ data ] ) ; } }
3152	protected function onTimeout ( RunnerServiceContext $ context , AssessmentTestSessionException $ timeOutException ) { $ session = $ context -> getTestSession ( ) ; $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , true ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ isLinear = $ session -> getCurrentNavigationMode ( ) === NavigationMode :: LINEAR ; switch ( $ timeOutException -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : \ common_Logger :: i ( 'TIMEOUT: closing the assessment test session' ) ; $ session -> endTestSession ( ) ; break ; case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next test part' ) ; $ session -> moveNextTestPart ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment test part' ) ; $ session -> closeTestPart ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next assessment section' ) ; $ session -> moveNextAssessmentSection ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment section session' ) ; $ session -> closeAssessmentSection ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next item' ) ; $ session -> moveNextAssessmentItem ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment item session' ) ; $ session -> closeAssessmentItem ( ) ; } break ; } $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , false ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> continueInteraction ( $ context ) ; }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
4256	protected function buildNotInConsole ( ) { if ( ! $ this -> stats [ 'notInConsole' ] ) { return '' ; } $ errors = $ this -> errorHandler -> get ( 'errors' ) ; $ lis = array ( ) ; foreach ( $ errors as $ err ) { if ( \ array_intersect_assoc ( array ( 'category' => 'fatal' , 'inConsole' => true , 'isSuppressed' => true , ) , $ err -> getValues ( ) ) ) { continue ; } $ lis [ ] = '<li>' . $ err [ 'typeStr' ] . ': ' . $ err [ 'file' ] . ' (line ' . $ err [ 'line' ] . '): ' . ( $ err [ 'isHtml' ] ? $ err [ 'message' ] : \ htmlspecialchars ( $ err [ 'message' ] ) ) . '</li>' ; } if ( ! $ lis ) { return '' ; } $ count = \ count ( $ lis ) ; $ header = \ sprintf ( '%s %s captured while not collecting debug log' , $ this -> stats [ 'inConsole' ] || isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ? 'Additionally, there' : 'There' , $ count === 1 ? 'was 1 error' : 'were ' . $ count . ' errors' ) ; $ html = '<h3>' . $ header . '</h3>' . '<ul class="list-unstyled indent">' . "\n" . \ implode ( "\n" , $ lis ) . "\n" . '</ul>' ; return $ html ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
7530	protected function toString_attributes ( ) { $ s = '' ; foreach ( $ this -> attributes as $ a => $ v ) { $ s .= ' ' . $ a ; if ( ( ! $ this -> attribute_shorttag ) || ( $ v !== $ a ) ) { $ quote = ( strpos ( $ v , '"' ) === false ) ? '"' : "'" ; $ s .= '=' . $ quote . $ v . $ quote ; } } return $ s ; }
12610	public function getParents ( ) { $ parents = [ ] ; foreach ( $ this -> _parents as $ key => $ parent ) { if ( ! $ parent -> active ) { continue ; } $ parents [ $ key ] = $ parent ; } return $ parents ; }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
12091	public function client ( ) { if ( empty ( $ this -> authToken ) ) { throw new NotFoundTokenException ( 'Token not found' ) ; } $ this -> client = new Client ( [ 'base_uri' => $ this -> microService , 'timeout' => $ this -> timeout , 'headers' => [ 'Auth-Token' => $ this -> authToken ] ] ) ; return $ this -> client ; }
1189	protected function isImplemented ( $ rule ) { return in_array ( $ rule , $ this -> clientRules ) || in_array ( $ rule , $ this -> serverRules ) ; }
10963	public static function getUri ( ) { $ parts = [ $ uri = self :: getScheme ( ) , '://' ] ; $ authUsername = self :: getAuthUsername ( ) ; $ authPassword = self :: getAuthPassword ( ) ; if ( $ authUsername !== null && $ authPassword !== null ) { $ parts [ ] = $ authUsername . ':' . $ authPassword . '@' ; } $ parts [ ] = self :: getHost ( ) ; $ port = self :: getPort ( ) ; if ( $ port != self :: getStandardPort ( self :: getScheme ( ) ) ) { $ parts [ ] = ':' . $ port ; } $ path = self :: getPath ( ) ; if ( $ path !== null && $ path != '' ) { $ parts [ ] = '/' . $ path ; } $ query = Input :: getQuery ( ) ; if ( is_array ( $ query ) && count ( $ query ) > 0 ) { $ queryString = [ ] ; foreach ( $ query as $ key => $ value ) { $ queryKeyValue = $ key . '=' ; if ( $ value !== null ) { if ( is_string ( $ value ) ) { $ value = urlencode ( $ value ) ; } $ queryKeyValue .= $ value ; } $ queryString [ ] = $ queryKeyValue ; } if ( count ( $ queryString ) > 0 ) { $ parts [ ] = '?' . implode ( '&' , $ queryString ) ; } } return implode ( '' , $ parts ) ; }
5501	protected function checkArgumentsIsArray ( $ args , $ task ) { if ( ! is_array ( $ args ) ) { $ errormsg = sprintf ( 'Cannot %s. Parameter %s is not an array.' , $ task , $ args ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
10122	private function writePrintHeaders ( ) { $ record = 0x002a ; $ length = 0x0002 ; $ fPrintRwCol = $ this -> printHeaders ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fPrintRwCol ) ; $ this -> append ( $ header . $ data ) ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
12854	public function process ( Pipeline \ Pipeline $ pipeline , $ payload ) { $ runner = clone ( $ this ) ; $ runner -> stages = $ pipeline -> getIterator ( ) ; return $ runner -> handle ( $ payload ) ; }
8157	public function prependPath ( $ path , $ namespace = self :: MAIN_NAMESPACE ) { $ this -> cache = $ this -> errorCache = array ( ) ; $ checkPath = $ this -> isAbsolutePath ( $ path ) ? $ path : $ this -> rootPath . $ path ; if ( ! is_dir ( $ checkPath ) ) { throw new Twig_Error_Loader ( sprintf ( 'The "%s" directory does not exist ("%s").' , $ path , $ checkPath ) ) ; } $ path = rtrim ( $ path , '/\\' ) ; if ( ! isset ( $ this -> paths [ $ namespace ] ) ) { $ this -> paths [ $ namespace ] [ ] = $ path ; } else { array_unshift ( $ this -> paths [ $ namespace ] , $ path ) ; } }
8168	public function outdent ( $ step = 1 ) { if ( $ this -> indentation < $ step ) { throw new LogicException ( 'Unable to call outdent() as the indentation would become negative.' ) ; } $ this -> indentation -= $ step ; return $ this ; }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
3866	private function getOrCreateBasicDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasBasicDefinition ( ) ) { return $ container -> getBasicDefinition ( ) ; } $ config = new DefaultBasicDefinition ( ) ; $ container -> setBasicDefinition ( $ config ) ; return $ config ; }
1760	public static function anonymizeIp ( $ strIp ) { if ( $ strIp == '127.0.0.1' || $ strIp == '::1' ) { return $ strIp ; } if ( strpos ( $ strIp , ':' ) !== false ) { return substr_replace ( $ strIp , ':0000' , strrpos ( $ strIp , ':' ) ) ; } else { return substr_replace ( $ strIp , '.0' , strrpos ( $ strIp , '.' ) ) ; } }
7832	protected function getSpacesByCore ( $ up = false ) { $ free = $ this -> getTotalWidth ( ) - $ this -> getBordersLength ( ) - $ this -> getCoreLength ( ) ; return $ free < 1 ? '' : str_repeat ( ' ' , $ this -> roundHalf ( $ free , $ up ) ) ; }
12649	public function build ( ) { $ assetManager = new AssetManager ( ) ; $ filterManager = new FilterManager ( ) ; foreach ( $ this -> filters as $ filterName => $ filter ) { $ filterManager -> set ( $ filterName , $ filter ) ; } $ assetsFactory = new AssetFactory ( $ this -> configurationHandler -> webDir ( ) ) ; $ assetsFactory -> setAssetManager ( $ assetManager ) ; $ assetsFactory -> setFilterManager ( $ filterManager ) ; return $ assetsFactory ; }
5145	public function _after ( \ Codeception \ TestCase $ test ) { if ( isset ( $ this -> config [ 'deleteEmailsAfterScenario' ] ) && $ this -> config [ 'deleteEmailsAfterScenario' ] ) { $ this -> deleteAllEmails ( ) ; } }
2414	protected function addTableTlModule ( \ DOMDocument $ xml , \ DOMNode $ tables , Result $ objTheme ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_module' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_module' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_module' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ objModule = $ this -> Database -> prepare ( "SELECT * FROM tl_module WHERE pid=? ORDER BY name" ) -> execute ( $ objTheme -> id ) ; while ( $ objModule -> next ( ) ) { $ this -> addDataRow ( $ xml , $ table , $ objModule -> row ( ) , $ arrOrder ) ; } }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
543	public function init ( ) { parent :: init ( ) ; if ( $ this -> logFile === null ) { $ this -> logFile = Yii :: $ app -> getRuntimePath ( ) . '/logs/app.log' ; } else { $ this -> logFile = Yii :: getAlias ( $ this -> logFile ) ; } if ( $ this -> maxLogFiles < 1 ) { $ this -> maxLogFiles = 1 ; } if ( $ this -> maxFileSize < 1 ) { $ this -> maxFileSize = 1 ; } }
2702	public function beforeSave ( ) { $ value = $ this -> getValue ( ) ; $ file = $ this -> getFileData ( ) ; if ( ! empty ( $ file ) ) { $ uploadDir = $ this -> _getUploadDir ( ) ; try { $ uploader = $ this -> _uploaderFactory -> create ( [ 'fileId' => $ file ] ) ; $ uploader -> setAllowedExtensions ( $ this -> getAllowedExtensions ( ) ) ; $ uploader -> setAllowRenameFiles ( true ) ; $ uploader -> addValidateCallback ( 'size' , $ this , 'validateMaxSize' ) ; $ result = $ uploader -> save ( $ uploadDir ) ; } catch ( \ Exception $ e ) { throw new \ Magento \ Framework \ Exception \ LocalizedException ( __ ( '%1' , $ e -> getMessage ( ) ) ) ; } $ filename = $ result [ 'file' ] ; if ( $ filename ) { if ( $ this -> _addWhetherScopeInfo ( ) ) { $ filename = $ this -> _prependScopeInfo ( $ filename ) ; } $ this -> setValue ( $ filename ) ; } } else { if ( is_array ( $ value ) && ! empty ( $ value [ 'delete' ] ) ) { $ this -> setValue ( '' ) ; } elseif ( is_array ( $ value ) && ! empty ( $ value [ 'value' ] ) ) { $ this -> setValue ( $ value [ 'value' ] ) ; } else { $ this -> unsValue ( ) ; } } return $ this ; }
6569	public function unsetData ( ) : void { foreach ( array_keys ( $ this -> data ) as $ var ) { if ( ! in_array ( $ var , self :: ALL_HEADERS ) ) { unset ( $ this -> data [ $ var ] ) ; } } }
10507	private function registerFilesystem ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ Filesystem :: class , function ( $ app ) { $ files = $ app [ 'files' ] ; $ filesystem = new Utilities \ Filesystem ( $ files , storage_path ( 'logs' ) ) ; $ filesystem -> setPattern ( Utilities \ Filesystem :: PATTERN_PREFIX , Utilities \ Filesystem :: PATTERN_DATE , Utilities \ Filesystem :: PATTERN_EXTENSION ) ; return $ filesystem ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.filesystem' , Contracts \ Utilities \ Filesystem :: class ) ; }
8829	protected function option ( $ display , $ value , $ selected , array $ attributes = [ ] ) { $ selected = $ this -> getSelectedValue ( $ value , $ selected ) ; $ options = array_merge ( [ 'value' => $ value , 'selected' => $ selected ] , $ attributes ) ; return $ this -> toHtmlString ( '<option' . $ this -> html -> attributes ( $ options ) . '>' . e ( $ display ) . '</option>' ) ; }
7441	protected function hasAccessToAction ( $ packageKey , $ subpackageKey , $ controllerName , $ actionName ) { $ actionControllerName = $ this -> router -> getControllerObjectName ( $ packageKey , $ subpackageKey , $ controllerName ) ; try { return $ this -> privilegeManager -> isGranted ( 'Neos\Flow\Security\Authorization\Privilege\Method\MethodPrivilege' , new MethodPrivilegeSubject ( new JoinPoint ( NULL , $ actionControllerName , $ actionName . 'Action' , array ( ) ) ) ) ; } catch ( AccessDeniedException $ e ) { return FALSE ; } }
0	public static function supports ( IOInterface $ io , Config $ config , $ url , $ deep = false ) { if ( ! preg_match ( self :: URL_REGEX , $ url , $ match ) ) { return false ; } $ scheme = ! empty ( $ match [ 'scheme' ] ) ? $ match [ 'scheme' ] : null ; $ guessedDomain = ! empty ( $ match [ 'domain' ] ) ? $ match [ 'domain' ] : $ match [ 'domain2' ] ; $ urlParts = explode ( '/' , $ match [ 'parts' ] ) ; if ( false === self :: determineOrigin ( ( array ) $ config -> get ( 'gitlab-domains' ) , $ guessedDomain , $ urlParts ) ) { return false ; } if ( 'https' === $ scheme && ! extension_loaded ( 'openssl' ) ) { $ io -> writeError ( 'Skipping GitLab driver for ' . $ url . ' because the OpenSSL PHP extension is missing.' , true , IOInterface :: VERBOSE ) ; return false ; } return true ; }
851	public function getTokenNotOfKindSibling ( $ index , $ direction , array $ tokens = [ ] ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( $ this -> isEmptyAt ( $ index ) ) { continue ; } if ( $ this [ $ index ] -> equalsAny ( $ tokens ) ) { continue ; } return $ index ; } }
4515	public static function parseFile ( string $ file , array $ data = [ ] ) : array { $ string = file_get_contents ( $ file ) ; return static :: parse ( $ string , $ data ) ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
1702	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objArchive = NewsArchiveModel :: findByProtected ( '' ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { if ( ! $ objArchive -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objArchive -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objArchive -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objArchive -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objArchive -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objArchive -> jumpTo ] ; $ objArticle = NewsModel :: findPublishedDefaultByPid ( $ objArchive -> id ) ; if ( $ objArticle !== null ) { while ( $ objArticle -> next ( ) ) { $ arrPages [ ] = $ this -> getLink ( $ objArticle , $ strUrl ) ; } } } } return $ arrPages ; }
5642	public function paintCaseEnd ( $ test_name ) { $ this -> progress ++ ; array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
8299	public function addRule ( $ url , $ rule ) { if ( ! is_string ( $ url ) || ! is_array ( $ rule ) ) { throw new \ InvalidArgumentException ( "addRule() expects a string and an array." ) ; } $ this -> runtimeRules [ $ url ] = $ rule ; }
10898	public function getScheme ( ) : array { if ( null === $ this -> scheme ) { $ raw = $ this -> medoo -> query ( 'DESCRIBE ' . $ this -> getTable ( ) ) -> fetchAll ( ) ; $ this -> scheme = [ ] ; foreach ( $ raw as $ field ) { $ this -> scheme [ $ field [ 'Field' ] ] = $ field ; } } return $ this -> scheme ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
4008	public function collectMetaModelTableNames ( CollectMetaModelTableNamesEvent $ event ) { if ( $ this -> tableNamesCollected ) { $ event -> addMetaModelNames ( $ this -> tableNames ) ; return ; } $ tables = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; foreach ( $ tables as $ table ) { $ this -> tableNames [ $ table [ 'id' ] ] = $ table [ 'tableName' ] ; } $ event -> addMetaModelNames ( $ this -> tableNames ) ; $ this -> tableNamesCollected = true ; }
11930	public function getActiveCustomFields ( ) { if ( $ this -> activeCustomFields === null ) { $ this -> activeCustomFields = array ( ) ; foreach ( $ this -> customFields as $ cf ) { if ( $ cf -> isActive ( ) ) { array_push ( $ this -> activeCustomFields , $ cf ) ; } } } return $ this -> activeCustomFields ; }
7524	function parse_all ( ) { $ this -> errors = array ( ) ; $ this -> status [ 'last_pos' ] = - 1 ; if ( ( $ this -> token === self :: TOK_TAG_OPEN ) || ( $ this -> next_pos ( '<' , false ) === self :: TOK_UNKNOWN ) ) { do { if ( ! $ this -> parse_tag ( ) ) { return false ; } } while ( $ this -> next_pos ( '<' ) !== self :: TOK_NULL ) ; } $ this -> pos = $ this -> size ; $ this -> parse_text ( ) ; return true ; }
3063	protected function saveAdaptiveResults ( CatSession $ catSession ) { $ testResult = $ catSession -> getTestResult ( ) ; $ testResult = empty ( $ testResult ) ? [ ] : [ $ testResult ] ; return $ this -> storeResult ( array_merge ( $ testResult , $ catSession -> getItemResults ( ) ) ) ; }
8610	public function updateSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_UpdateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_UpdateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/UpdateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_UpdateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3209	function createOAuth2AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/oauth2/token_from_oauth1" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ parts = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( ! array_key_exists ( 'token_type' , $ parts ) || ! is_string ( $ parts [ 'token_type' ] ) ) { throw new Exception_BadResponse ( "Missing \"token_type\" field." ) ; } $ tokenType = $ parts [ 'token_type' ] ; if ( ! array_key_exists ( 'access_token' , $ parts ) || ! is_string ( $ parts [ 'access_token' ] ) ) { throw new Exception_BadResponse ( "Missing \"access_token\" field." ) ; } $ accessToken = $ parts [ 'access_token' ] ; if ( $ tokenType !== "Bearer" && $ tokenType !== "bearer" ) { throw new Exception_BadResponse ( "Unknown \"token_type\"; expecting \"Bearer\", got " . Util :: q ( $ tokenType ) ) ; } return $ accessToken ; }
1054	private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; }
10946	public function post ( $ name = null , $ defaultValue = null ) { if ( $ name === null ) { return $ this -> getBodyParams ( ) ; } else { return $ this -> getBodyParam ( $ name , $ defaultValue ) ; } }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
2907	public function getPartDecodedContent ( Zend_Mime_Part $ mimePart ) { if ( method_exists ( $ mimePart , 'getRawContent' ) ) { return $ mimePart -> getRawContent ( ) ; } $ content = '' ; if ( method_exists ( $ mimePart , 'getContent' ) ) { $ encoding = $ mimePart -> encoding ; $ mimePart -> encoding = 'none' ; $ content = $ mimePart -> getContent ( ) ; $ mimePart -> encoding = $ encoding ; } return $ content ; }
2604	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ checkIfSettingExists = $ this -> api -> hasSnippet ( $ activeVersion , Config :: WAF_SETTING_NAME ) ; $ snippet = $ this -> config -> getVclSnippets ( Config :: VCL_WAF_PATH , Config :: VCL_WAF_ALLOWLIST_SNIPPET ) ; $ acls = $ this -> prepareAcls ( $ this -> config -> getWafAllowByAcl ( ) ) ; $ allowedItems = $ acls ; $ strippedAllowedItems = substr ( $ allowedItems , 0 , strrpos ( $ allowedItems , '||' , - 1 ) ) ; if ( ! $ checkIfSettingExists ) { foreach ( $ snippet as $ key => $ value ) { if ( $ strippedAllowedItems === '' ) { $ value = '' ; } else { $ value = str_replace ( '####WAF_ALLOWLIST####' , $ strippedAllowedItems , $ value ) ; } $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key , 'type' => $ key , 'dynamic' => 1 , 'priority' => 10 , 'content' => $ value ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } } else { foreach ( $ snippet as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_waf_' . $ key ; if ( $ this -> api -> hasSnippet ( $ clone -> number , $ name ) == true ) { $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ checkIfSettingExists , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON WAF ACL Bypass' ] ; if ( $ checkIfSettingExists ) { $ comment = [ 'comment' => 'Magento Module turned OFF WAF ACL Bypass' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5005	protected function attachListeners ( $ services , $ eventManager , $ listeners ) { $ lazyListeners = [ ] ; foreach ( $ listeners as $ name => $ options ) { $ options = $ this -> normalizeListenerOptions ( $ name , $ options ) ; if ( $ options [ 'lazy' ] && null !== $ options [ 'attach' ] ) { foreach ( $ options [ 'attach' ] as $ spec ) { $ lazyListeners [ ] = [ 'service' => $ options [ 'service' ] , 'event' => $ spec [ 'event' ] , 'method' => $ spec [ 'method' ] , 'priority' => $ spec [ 'priority' ] , ] ; } continue ; } if ( $ services -> has ( $ options [ 'service' ] ) ) { $ listener = $ services -> get ( $ options [ 'service' ] ) ; } elseif ( class_exists ( $ options [ 'service' ] , true ) ) { $ listener = new $ options [ 'service' ] ( ) ; } else { throw new \ UnexpectedValueException ( sprintf ( 'Class or service %s does not exists. Cannot create listener instance.' , $ options [ 'service' ] ) ) ; } if ( $ listener instanceof ListenerAggregateInterface ) { $ listener -> attach ( $ eventManager , $ options [ 'priority' ] ) ; continue ; } foreach ( $ options [ 'attach' ] as $ spec ) { $ callback = $ spec [ 'method' ] ? [ $ listener , $ spec [ 'method' ] ] : $ listener ; $ eventManager -> attach ( $ spec [ 'event' ] , $ callback , $ spec [ 'priority' ] ) ; } } if ( ! empty ( $ lazyListeners ) ) { $ aggregate = $ services -> get ( 'Core/Listener/DeferredListenerAggregate' ) ; $ aggregate -> setListeners ( $ lazyListeners ) -> attach ( $ eventManager ) ; } }
11832	public function getCache ( ) { if ( ! $ this -> cache ) { $ services = $ this -> getServices ( ) ; $ cache = $ services -> get ( 'Cache' ) ; $ this -> setCache ( $ cache ) ; } return $ this -> cache ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
10467	public static function createSimpleAnonymousRecipient ( $ emailAddress , $ countryCode ) { return ( new Recipient ( ) ) -> setHash ( self :: getEmailAddressHash ( $ emailAddress ) ) -> setCountry ( $ countryCode ) -> setProvider ( self :: getDomainFromEmail ( $ emailAddress ) ) ; }
1312	public function setTimeouts ( $ connectionTimeout , $ timeout ) { $ this -> connectionTimeout = ( int ) $ connectionTimeout ; $ this -> timeout = ( int ) $ timeout ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
1139	public function shiftSiblingsForRestore ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> increment ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>=' , $ lft ) -> increment ( $ rgtCol , $ diff ) ; } ) ; }
3741	protected function getLabelParameters ( EnvironmentInterface $ environment , ModelInterface $ model ) { if ( $ model -> getProperty ( 'type' ) == 'simplelookup' ) { return $ this -> getLabelParametersWithAttributeAndUrlParam ( $ environment , $ model ) ; } return $ this -> getLabelParametersNormal ( $ environment , $ model ) ; }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
2780	public function buildOptions ( ) : array { $ options = [ ] ; foreach ( $ this -> options as $ option => $ values ) { foreach ( ( array ) $ values as $ value ) { $ prefix = strlen ( $ option ) !== 1 ? '--' : '-' ; $ options [ ] = $ prefix . $ option ; if ( $ value !== true ) { $ options [ ] = $ value ; } } } return $ options ; }
6021	public function setApiKey ( $ apiKey ) { $ this -> apiKey = $ apiKey ; list ( , $ datacentre ) = explode ( '-' , $ this -> apiKey ) ; $ this -> apiUrl = str_replace ( '<dc>' , $ datacentre , $ this -> apiUrl ) ; }
6531	protected function applyAnalyzer ( array $ mapping , Field $ field , \ stdClass $ rootObject , $ path = null ) { if ( null === $ this -> defaultAnalyzer ) { return $ mapping ; } if ( ! isset ( $ mapping [ 'type' ] ) || 'text' !== $ mapping [ 'type' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'index' ] ) && false === $ mapping [ 'index' ] ) { return $ mapping ; } if ( isset ( $ mapping [ 'analyzer' ] ) ) { return $ mapping ; } $ mapping [ 'analyzer' ] = $ this -> defaultAnalyzer ; return $ mapping ; }
10812	protected function callAPI ( $ data ) { $ apiUtility = new PipedriveApi ( $ this -> apiEndpoint ) ; $ apiUtility -> setData ( $ data ) ; $ formState = $ this -> finisherContext -> getFormRuntime ( ) -> getFormState ( ) ; $ response = $ apiUtility -> execute ( ) ; if ( $ response -> data -> id ) { $ formState -> setFormValue ( $ this -> getIdentifier ( ) . ".ID" , $ response -> data -> id ) ; return true ; } else { throw new FinisherException ( "Something went wrong while calling the API!" ) ; } }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
524	protected function migrateToTime ( $ time ) { $ count = 0 ; $ migrations = array_values ( $ this -> getMigrationHistory ( null ) ) ; while ( $ count < count ( $ migrations ) && $ migrations [ $ count ] > $ time ) { ++ $ count ; } if ( $ count === 0 ) { $ this -> stdout ( "Nothing needs to be done.\n" , Console :: FG_GREEN ) ; } else { $ this -> actionDown ( $ count ) ; } }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
605	protected function indexAfter ( $ string , $ offset = null ) { if ( $ offset === null ) { $ offset = $ this -> offset ; } if ( $ offset + mb_strlen ( $ string , 'UTF-8' ) > $ this -> length ) { return $ this -> length ; } $ afterIndexOf = mb_strpos ( $ this -> sql , $ string , $ offset , 'UTF-8' ) ; if ( $ afterIndexOf === false ) { $ afterIndexOf = $ this -> length ; } else { $ afterIndexOf += mb_strlen ( $ string , 'UTF-8' ) ; } return $ afterIndexOf ; }
6634	public function parseProfileResponse ( Response $ response , AccessTokenInterface $ access_token ) { $ profile = $ response -> json ( ) ; if ( gettype ( $ profile ) !== 'object' ) { throw new InvalidProfileException ( ) ; } if ( isset ( $ profile -> error ) ) { $ error = $ profile -> error ; throw new InvalidProfileException ( $ error -> type . ': ' . $ error -> message , $ error -> code ) ; } $ profile -> access_token = $ access_token -> token ( ) ; return $ this -> profile -> instantiate ( $ profile , $ this -> name ) ; }
3045	protected function getAssessmentsFromDelivery ( \ core_kernel_classes_Resource $ compiledDelivery ) { $ unionAssignmentService = $ this -> getServiceLocator ( ) -> get ( UnionAssignmentService :: SERVICE_ID ) ; $ runtime = $ unionAssignmentService -> getRuntime ( $ compiledDelivery ) ; $ inputParameters = \ tao_models_classes_service_ServiceCallHelper :: getInputValues ( $ runtime , [ ] ) ; $ testDefinition = \ taoQtiTest_helpers_Utils :: getTestDefinition ( $ inputParameters [ 'QtiTestCompilation' ] ) ; $ assessmentItemRefs = $ testDefinition -> getComponentsByClassName ( 'assessmentItemRef' ) ; $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Starting to recompile items for delivery {$compiledDelivery->getLabel()} with identifier {$compiledDelivery->getUri()}:" ) ) ; $ count = 0 ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ directoryIds = explode ( '|' , $ assessmentItemRef -> getHref ( ) ) ; $ item = $ this -> getResource ( $ directoryIds [ 0 ] ) ; $ properties = [ ] ; foreach ( $ item -> getRdfTriples ( ) as $ triple ) { $ properties [ $ triple -> predicate ] = $ triple -> object ; } if ( $ properties ) { $ directory = \ tao_models_classes_service_FileStorage :: singleton ( ) -> getDirectoryById ( $ directoryIds [ 2 ] ) ; $ languages = $ item -> getUsedLanguages ( $ this -> getProperty ( \ taoItems_models_classes_ItemsService :: PROPERTY_ITEM_CONTENT ) ) ; foreach ( $ languages as $ lang ) { $ path = $ lang . DIRECTORY_SEPARATOR . QtiJsonItemCompiler :: METADATA_FILE_NAME ; if ( ! $ directory -> has ( $ path ) ) { $ this -> writeMetadata ( $ item , $ directory , $ path , $ properties ) ; $ count ++ ; } } } } $ this -> report -> add ( new Report ( Report :: TYPE_INFO , "Was updated {$count} items." ) ) ; }
6880	public function transform ( $ data ) { $ address = new ShipmentAddress ( ) ; if ( ! is_array ( $ data ) || empty ( $ data ) ) { return $ address ; } foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field ] ) ) { $ value = $ data [ $ field ] ; if ( $ field === 'country' ) { if ( 0 >= $ value ) { throw new InvalidArgumentException ( "Invalid country id." ) ; } $ value = $ this -> countryRepository -> find ( $ value ) ; if ( null === $ value ) { throw new InvalidArgumentException ( "Country not found." ) ; } } elseif ( $ field === 'phone' || $ field === 'mobile' ) { $ value = unserialize ( $ value ) ; if ( ! $ value instanceof PhoneNumber ) { throw new InvalidArgumentException ( "Invalid phone number." ) ; } } $ this -> accessor -> setValue ( $ address , $ field , $ value ) ; } } return $ address ; }
1694	public function exportStyleSheet ( DataContainer $ dc ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT * FROM tl_style_sheet WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objStyleSheet -> numRows < 1 ) { throw new \ Exception ( "Invalid style sheet ID {$dc->id}" ) ; } $ vars = array ( ) ; $ objTheme = $ this -> Database -> prepare ( "SELECT vars FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ objStyleSheet -> pid ) ; if ( $ objTheme -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objTheme -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } if ( $ objStyleSheet -> vars != '' ) { if ( \ is_array ( ( $ tmp = StringUtil :: deserialize ( $ objStyleSheet -> vars ) ) ) ) { foreach ( $ tmp as $ v ) { $ vars [ $ v [ 'key' ] ] = $ v [ 'value' ] ; } } } uksort ( $ vars , 'length_sort_desc' ) ; $ objFile = new File ( 'system/tmp/' . md5 ( uniqid ( mt_rand ( ) , true ) ) ) ; $ objFile -> write ( '' ) ; if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '@media ' . $ objStyleSheet -> mediaQuery . ' {' ) ; } $ objDefinitions = $ this -> Database -> prepare ( "SELECT * FROM tl_style WHERE pid=? AND invisible!='1' ORDER BY sorting" ) -> execute ( $ objStyleSheet -> id ) ; while ( $ objDefinitions -> next ( ) ) { $ objFile -> append ( $ this -> compileDefinition ( $ objDefinitions -> row ( ) , false , $ vars , $ objStyleSheet -> row ( ) , true ) , '' ) ; } if ( $ objStyleSheet -> mediaQuery != '' ) { $ objFile -> append ( '}' ) ; } $ objFile -> close ( ) ; $ objFile -> sendToBrowser ( $ objStyleSheet -> name . '.css' ) ; $ objFile -> delete ( ) ; }
7297	private function modulate_next_group ( $ object_id , $ object_type , $ mail_to_chunks ) { if ( ! empty ( $ mail_to_chunks ) ) { $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] = $ mail_to_chunks ; if ( $ object_type == 'post' ) { $ this -> transit_posts [ $ object_id ] = array ( 'new_status' => 'publish' , 'old_status' => 'draft' ) ; $ this -> inform_about_posts ( $ object_id ) ; } elseif ( $ object_type == 'comment' ) { $ this -> inform_about_comment ( $ object_id ) ; } } else { } }
6426	public function completeLogin ( $ extrainputs = array ( ) ) { if ( $ extrainputs [ 'code' ] == '' && $ extrainputs [ 'error' ] != '' ) { throw new \ Exception ( $ extrainputs [ 'error' ] ) ; } $ client = $ this -> getClient ( ) ; $ client -> authenticate ( $ extrainputs [ 'code' ] ) ; $ this -> access_token = $ client -> getAccessToken ( ) ; return $ this -> getUserProfile ( ) ; }
8210	protected function parseConnection ( $ connectionName ) { $ connection = null ; if ( $ connectionName ) { if ( ! $ connection = config ( "queue.connections.$connectionName" ) ) { throw new \ InvalidArgumentException ( "Connection '$connectionName' doesn't exist." ) ; } } if ( ! $ connection ) { $ defaultConnection = config ( 'queue.default' ) ; if ( 'beanstalkd' == config ( "queue.connections.$defaultConnection.driver" ) ) { $ connection = config ( "queue.connections.$defaultConnection" ) ; } } if ( ! $ connection ) { foreach ( config ( 'queue.connections' ) as $ connection ) { if ( 'beanstalkd' == $ connection [ 'driver' ] ) { break ; } } } if ( ! empty ( $ connection [ 'host' ] ) ) { $ parsedConfigHost = explode ( ':' , $ connection [ 'host' ] ) ; $ this -> host = $ parsedConfigHost [ 0 ] ; if ( isset ( $ parsedConfigHost [ 1 ] ) ) { $ this -> port = $ parsedConfigHost [ 1 ] ; } } if ( ! empty ( $ connection [ 'queue' ] ) ) { $ this -> defaultTube = $ connection [ 'queue' ] ; } }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
7477	public function downloadAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ file = $ em -> find ( 'Orkestra\Bundle\ApplicationBundle\Entity\File' , $ id ) ; if ( ! $ file ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } $ securityContext = $ this -> get ( 'security.authorization_checker' ) ; foreach ( $ file -> getGroups ( ) as $ group ) { if ( ! $ securityContext -> isGranted ( $ group -> getRole ( ) ) ) { throw $ this -> createNotFoundException ( 'Unable to locate File' ) ; } } return new Response ( $ file -> getContent ( ) , 200 , array ( 'Content-Type' => $ file -> getMimeType ( ) , 'Content-Disposition' => sprintf ( 'attachment; filename="%s"' , $ file -> getFilename ( ) ) ) ) ; }
7585	public static function getSDKEndpointRegistry ( ) { $ entryPoints = array ( ) ; require __DIR__ . DIRECTORY_SEPARATOR . 'registry.php' ; foreach ( $ entryPoints as $ funcName => $ className ) { $ className = "SugarAPI\\SDK\\Endpoint\\" . $ className ; $ entryPoints [ $ funcName ] = $ className ; } return $ entryPoints ; }
9030	public function exception ( Request $ request ) { $ ex = $ request -> getException ( ) ; $ this -> response -> setCode ( 500 ) ; printf ( "<h2>%s</h2>" , HttpStatus :: getStatus ( 500 ) ) ; while ( $ ex != null ) { printf ( "<h3>%s</h3><pre>%s</pre>" , $ ex -> getMessage ( ) , $ ex -> getTraceAsString ( ) ) ; $ ex = $ ex -> getPrevious ( ) ; } }
10108	private function writeSelection ( ) { $ selectedCells = Coordinate :: splitRange ( $ this -> phpSheet -> getSelectedCells ( ) ) ; $ selectedCells = $ selectedCells [ 0 ] ; if ( count ( $ selectedCells ) == 2 ) { list ( $ first , $ last ) = $ selectedCells ; } else { $ first = $ selectedCells [ 0 ] ; $ last = $ selectedCells [ 0 ] ; } list ( $ colFirst , $ rwFirst ) = Coordinate :: coordinateFromString ( $ first ) ; $ colFirst = Coordinate :: columnIndexFromString ( $ colFirst ) - 1 ; -- $ rwFirst ; list ( $ colLast , $ rwLast ) = Coordinate :: coordinateFromString ( $ last ) ; $ colLast = Coordinate :: columnIndexFromString ( $ colLast ) - 1 ; -- $ rwLast ; $ colFirst = min ( $ colFirst , 255 ) ; $ colLast = min ( $ colLast , 255 ) ; $ rwFirst = min ( $ rwFirst , 65535 ) ; $ rwLast = min ( $ rwLast , 65535 ) ; $ record = 0x001D ; $ length = 0x000F ; $ pnn = $ this -> activePane ; $ rwAct = $ rwFirst ; $ colAct = $ colFirst ; $ irefAct = 0 ; $ cref = 1 ; if ( ! isset ( $ rwLast ) ) { $ rwLast = $ rwFirst ; } if ( ! isset ( $ colLast ) ) { $ colLast = $ colFirst ; } if ( $ rwFirst > $ rwLast ) { list ( $ rwFirst , $ rwLast ) = [ $ rwLast , $ rwFirst ] ; } if ( $ colFirst > $ colLast ) { list ( $ colFirst , $ colLast ) = [ $ colLast , $ colFirst ] ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'CvvvvvvCC' , $ pnn , $ rwAct , $ colAct , $ irefAct , $ cref , $ rwFirst , $ rwLast , $ colFirst , $ colLast ) ; $ this -> append ( $ header . $ data ) ; }
6130	protected function getCorpusName ( ) { if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { if ( $ this -> currObj -> spacerGetType ( ) != TeamSpeak3 :: SPACER_CUSTOM ) { return "" ; } $ string = $ this -> currObj [ "channel_name" ] -> section ( "]" , 1 , 99 ) ; if ( $ this -> currObj -> spacerGetAlign ( ) == TeamSpeak3 :: SPACER_ALIGN_REPEAT ) { $ string -> resize ( 30 , $ string ) ; } return htmlspecialchars ( $ string ) ; } if ( $ this -> currObj instanceof Client ) { $ before = array ( ) ; $ behind = array ( ) ; foreach ( $ this -> currObj -> memberOf ( ) as $ group ) { if ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEFORE ) { $ before [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } elseif ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEHIND ) { $ behind [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } } return implode ( "" , $ before ) . " " . htmlspecialchars ( $ this -> currObj ) . " " . implode ( "" , $ behind ) ; } return htmlspecialchars ( $ this -> currObj ) ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
2347	public function getContent ( ) { $ strContent = file_get_contents ( $ this -> strRootDir . '/' . ( $ this -> strTmp ? : $ this -> strFile ) ) ; if ( strncmp ( $ strContent , "\xEF\xBB\xBF" , 3 ) === 0 ) { $ strContent = substr ( $ strContent , 3 ) ; } elseif ( strncmp ( $ strContent , "\xFF\xFE" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } elseif ( strncmp ( $ strContent , "\xFE\xFF" , 2 ) === 0 ) { $ strContent = substr ( $ strContent , 2 ) ; } return $ strContent ; }
4388	public function setConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Iface $ orderServiceItem , array $ attributes ) { $ this -> setAttributes ( $ orderServiceItem , $ attributes , 'session' ) ; }
14	public function copyTo ( $ file , $ target ) { if ( $ this -> enabled ) { $ file = preg_replace ( '{[^' . $ this -> whitelist . ']}i' , '-' , $ file ) ; if ( file_exists ( $ this -> root . $ file ) ) { try { touch ( $ this -> root . $ file , filemtime ( $ this -> root . $ file ) , time ( ) ) ; } catch ( \ ErrorException $ e ) { Silencer :: call ( 'touch' , $ this -> root . $ file ) ; } $ this -> io -> writeError ( 'Reading ' . $ this -> root . $ file . ' from cache' , true , IOInterface :: DEBUG ) ; return copy ( $ this -> root . $ file , $ target ) ; } } return false ; }
2877	public function searchGroupClassAction ( ) { if ( ! $ this -> getRequest ( ) -> isPost ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 405 ) ; return ; } $ uri = ( string ) $ this -> getRequest ( ) -> getPost ( 'uri' ) ; $ groupType = $ this -> getRequest ( ) -> getPost ( 'group' ) ; $ groupTypes = array ( $ groupType ) ; if ( $ groupType == 'all' ) { $ groupTypes = array ( 'model' , 'block' , 'helper' ) ; } $ items = array ( ) ; if ( $ uri ) { foreach ( $ groupTypes as $ type ) { $ items [ $ type ] [ 'class' ] = Mage :: getConfig ( ) -> getGroupedClassName ( $ type , $ uri ) ; $ items [ $ type ] [ 'filepath' ] = mageFindClassFile ( $ items [ $ type ] [ 'class' ] ) ; } $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/array' ) ; $ block -> setTemplate ( 'sheep_debug/grouped_class_search.phtml' ) ; $ block -> assign ( 'items' , $ items ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; } else { $ this -> getResponse ( ) -> setBody ( $ this -> __ ( 'Please fill in a search query' ) ) ; } }
10064	public function all ( ) { $ meta = $ this -> metaModel :: get ( [ 'key' , 'value' , 'type' ] ) ; $ data = [ ] ; foreach ( $ meta as $ m ) { $ data [ $ m -> key ] = $ m -> value ; } return $ data ; }
10647	private function buildMessages ( $ scope = 'create' ) { $ custom_messages = $ this -> messages [ 'global' ] ; foreach ( $ this -> messages [ $ scope ] as $ key => $ value ) { $ custom_messages [ $ key ] = $ value ; } return $ custom_messages ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
441	public function hasMethod ( $ name , $ checkBehaviors = true ) { if ( method_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> hasMethod ( $ name ) ) { return true ; } } } return false ; }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
3071	protected function saveItemResponses ( $ emptyAllowed = true ) { if ( $ this -> getRequestParameter ( 'itemDefinition' ) && $ this -> getRequestParameter ( 'itemResponse' ) ) { $ itemDefinition = $ this -> getRequestParameter ( 'itemDefinition' ) ; $ serviceContext = $ this -> getServiceContext ( ) ; $ itemResponse = $ this -> getRequestParameter ( 'itemResponse' ) ? json_decode ( $ this -> getRequestParameter ( 'itemResponse' ) , true ) : null ; if ( ! is_null ( $ itemResponse ) && ! empty ( $ itemDefinition ) ) { $ responses = $ this -> getRunnerService ( ) -> parsesItemResponse ( $ serviceContext , $ itemDefinition , $ itemResponse ) ; if ( ! $ emptyAllowed && $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'enableAllowSkipping' ) && ! TestRunnerUtils :: doesAllowSkipping ( $ serviceContext -> getTestSession ( ) ) ) { if ( $ this -> getRunnerService ( ) -> emptyResponse ( $ serviceContext , $ responses ) ) { throw new QtiRunnerEmptyResponsesException ( ) ; } } return $ this -> getRunnerService ( ) -> storeItemResponse ( $ serviceContext , $ itemDefinition , $ responses ) ; } } return false ; }
7127	public function getDetails ( ) { return [ 'valid' => $ this -> valid , 'country' => $ this -> country , 'number' => $ this -> number , 'name' => $ this -> name , 'address' => $ this -> address , 'date' => $ this -> date , ] ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
5696	protected function getFormActionFromRequest ( HTTPRequest $ r ) { $ action = $ r -> requestVar ( 'action' ) ; $ formAction = $ this -> record -> findActionByName ( $ action ) ; if ( ! $ formAction instanceof BetterButtonNestedForm ) { throw new Exception ( "Action $action doesn't exist or is not a BetterButtonNestedForm" ) ; } return $ formAction ; }
66	public function isSymlinkedDirectory ( $ directory ) { if ( ! is_dir ( $ directory ) ) { return false ; } $ resolved = $ this -> resolveSymlinkedDirectorySymlink ( $ directory ) ; return is_link ( $ resolved ) ; }
2082	public function generateXmlFiles ( ) { $ this -> generateSitemap ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'generateXmlFiles' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Regenerated the XML files' , __METHOD__ , TL_CRON ) ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
7643	protected function parseMetadataHeaders ( $ headers = array ( ) ) { if ( ! is_array ( $ headers ) ) { return array ( ) ; } $ metadata = array ( ) ; foreach ( $ headers as $ key => $ value ) { if ( substr ( strtolower ( $ key ) , 0 , 10 ) == "x-ms-meta-" ) { $ metadata [ str_replace ( "x-ms-meta-" , '' , strtolower ( $ key ) ) ] = $ value ; } } return $ metadata ; }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
1755	public static function getTimeZones ( ) { $ arrReturn = array ( ) ; $ timezones = array ( ) ; require __DIR__ . '/../../config/timezones.php' ; foreach ( $ timezones as $ strGroup => $ arrTimezones ) { foreach ( $ arrTimezones as $ strTimezone ) { $ arrReturn [ $ strGroup ] [ ] = $ strTimezone ; } } return $ arrReturn ; }
10404	public function get ( $ key ) { $ pair = $ this -> repository -> find ( $ key ) ; return $ pair ? $ pair -> getValue ( ) : null ; }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
12494	public static function find ( $ id = null , $ connection ) { if ( gettype ( $ id ) != "string" && ! is_numeric ( $ id ) ) { throw new ClusterpointException ( "\"->find()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'GET' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; $ connection -> multiple = false ; return self :: sendQuery ( $ connection ) ; }
7590	public function renderTemplate ( CollectionElement $ collection ) { if ( false != ( $ sElementLayout = $ collection -> getOption ( 'twb-layout' ) ) ) { $ elementOrFieldset = $ collection -> getTemplateElement ( ) ; $ elementOrFieldset -> setOption ( 'twb-layout' , $ sElementLayout ) ; } return parent :: renderTemplate ( $ collection ) ; }
8096	public function destroy ( ) { if ( ! is_null ( $ this -> getValue ( ) ) ) { if ( ! headers_sent ( ) ) { return setcookie ( $ this -> name , '' , time ( ) - 3600 , $ this -> path , $ this -> host ) ; } else { return false ; } } else { return true ; } }
3091	public function store ( $ data ) { $ this -> cache [ $ this -> testSessionId ] = & $ data ; $ encodedData = $ this -> getStorageFormat ( ) -> encode ( $ data ) ; $ this -> getStorageService ( ) -> set ( $ this -> getUserKey ( ) , $ this -> getStorageKey ( ) , $ encodedData ) ; \ common_Logger :: d ( sprintf ( 'QtiTimer: Stored %d bytes into state storage' , strlen ( $ encodedData ) ) ) ; return $ this ; }
11253	public function transaction ( callable $ callback ) : void { $ this -> pdo -> beginTransaction ( ) ; $ callback ( $ this ) ; $ this -> pdo -> commit ( ) ; }
12777	public function render ( ) { $ sort = 0 ; $ query = $ this -> request -> getQuery ( ) ; if ( isset ( $ query [ 'sort' ] ) && isset ( $ this -> columns [ $ query [ 'sort' ] ] ) ) { $ sort = $ query [ 'sort' ] ; } return $ this -> formatter -> render ( $ this -> columns , $ this -> getRecords ( ) , $ this -> dataManager -> getTotalCount ( ) , $ this -> limit , $ this -> page , $ sort ) ; }
3302	public function json ( $ url , $ options = [ ] , $ encodeOption = JSON_UNESCAPED_UNICODE , $ queries = [ ] ) { is_array ( $ options ) && $ options = json_encode ( $ options , $ encodeOption ) ; return $ this -> setHeaders ( [ 'content-type' => 'application/json' ] ) -> request ( 'POST' , $ url , [ 'query' => $ queries , 'body' => $ options ] ) ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
3692	protected function breadcrumb ( EnvironmentInterface $ environment ) { $ event = new GetBreadcrumbEvent ( $ environment ) ; $ environment -> getEventDispatcher ( ) -> dispatch ( $ event :: NAME , $ event ) ; $ arrReturn = $ event -> getElements ( ) ; if ( ! is_array ( $ arrReturn ) || count ( $ arrReturn ) == 0 ) { return null ; } $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/ccadcgeneral/css/generalBreadcrumb.css' ; $ objTemplate = new ContaoBackendViewTemplate ( 'dcbe_general_breadcrumb' ) ; $ objTemplate -> elements = $ arrReturn ; return $ objTemplate -> parse ( ) ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
8390	public function addRightOuterJoin ( $ table , $ on ) { $ this -> rightOuterJoins [ ] = array ( 'table' => $ table , 'on' => ( $ on instanceof Condition ? $ on : new Condition ( $ on ) ) ) ; return $ this ; }
6184	public function display ( $ type = 'all' , $ print = false ) { $ messages = '' ; $ data = '' ; if ( in_array ( $ type , $ this -> msgTypes ) ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages [ $ type ] as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; $ this -> clear ( $ type ) ; } elseif ( $ type === 'all' ) { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; foreach ( $ flashMessages as $ type => $ msgArray ) { $ messages = '' ; foreach ( $ msgArray as $ msg ) { $ messages .= $ msg ; } $ data .= $ messages ; } $ this -> clear ( ) ; } else { return false ; } if ( $ print ) { echo $ data ; return null ; } return $ data ; }
7472	public function resetPasswordAction ( Request $ request , $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( ChangePasswordType :: class , null , array ( 'require_current' => false ) ) ; if ( $ request -> isMethod ( 'POST' ) ) { $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ data = $ form -> getData ( ) ; $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ data [ 'password' ] , $ user -> getSalt ( ) ) ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The password has been changed.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ id ) ) ) ; } } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
2950	private function failedDispatch ( $ queue , \ Exception $ error ) { foreach ( $ queue as $ index => $ data ) { $ this -> clear ( $ data [ 'key' ] ) ; $ data [ 'reject' ] ( $ error ) ; } }
6181	protected function getSeverity ( $ errorCode ) { if ( isset ( $ this -> severityMapping [ $ errorCode ] ) ) { return $ this -> severityMapping [ $ errorCode ] ; } else { return $ this -> severityMapping [ Logger :: ERROR ] ; } }
1412	public function resourceDoesNotSupportClientIds ( string $ type , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_FORBIDDEN , $ this -> trans ( 'resource_client_ids_not_supported' , 'code' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'title' ) , $ this -> trans ( 'resource_client_ids_not_supported' , 'detail' , compact ( 'type' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
2303	public function addCustomLayoutSectionReferences ( ) { $ objLayout = $ this -> Database -> getInstance ( ) -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ v [ 'id' ] ] = $ v [ 'title' ] ; } } } } }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
2278	public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; }
8861	public function canView ( $ member = null ) { if ( ! parent :: canView ( $ member ) ) return false ; if ( $ this -> PublishDate ) { $ publishDate = $ this -> dbObject ( "PublishDate" ) ; if ( $ publishDate -> InFuture ( ) && ! Permission :: checkMember ( $ member , "VIEW_DRAFT_CONTENT" ) ) { return false ; } } return true ; }
12331	public function get ( $ key ) { if ( ! $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceDoesNotExistException ( ) ; return $ this -> repository -> get ( $ key ) ; }
4788	function insert ( $ data ) { $ rows = func_get_args ( ) ; $ return = $ this -> insert_multi ( $ rows ) ; if ( ! $ return ) { return false ; } if ( ! is_array ( $ data ) ) { return $ return ; } if ( $ this -> notORM -> driver == "pgsql" ) { if ( ! isset ( $ data [ $ this -> primary ] ) ) { $ pgss = $ this -> query ( "SELECT pg_get_serial_sequence('" . $ this -> table . "', '" . $ this -> primary . "') pgss" , $ this -> parameters ) -> fetch ( ) ; if ( isset ( $ pgss [ 'pgss' ] ) ) { $ rs = $ this -> query ( "select last_value id from " . $ pgss [ 'pgss' ] , $ this -> parameters ) -> fetch ( ) ; $ data [ $ this -> primary ] = $ rs [ 'id' ] ; $ this -> sequence = $ rs [ 'id' ] ; } } } else { if ( ! isset ( $ data [ $ this -> primary ] ) && ( $ id = $ this -> notORM -> connection -> lastInsertId ( $ this -> notORM -> structure -> getSequence ( $ this -> table ) ) ) ) { $ data [ $ this -> primary ] = $ id ; } } return new $ this -> notORM -> rowClass ( $ data , $ this ) ; }
3167	private function isThemeSwitcherEnabled ( ) { $ extensionsManager = $ this -> getServiceLocator ( ) -> get ( \ common_ext_ExtensionsManager :: SERVICE_ID ) ; $ config = $ extensionsManager -> getExtensionById ( "taoTests" ) -> getConfig ( "test_runner_plugin_registry" ) ; return array_key_exists ( self :: TOOL_ITEM_THEME_SWITCHER_KEY , $ config ) && $ config [ self :: TOOL_ITEM_THEME_SWITCHER_KEY ] [ "active" ] === true ; }
11491	public function getAll ( ) : array { $ res = [ ] ; foreach ( $ this -> getKeys ( ) as $ key ) { $ res [ $ key ] = $ this -> get ( $ key ) ; } return $ res ; }
8290	protected function checkLogoutSubmission ( ) { $ post = $ this -> request -> request ; if ( $ post -> has ( "logout" ) ) { if ( ! $ this -> isValidCSRF ( $ post -> get ( "csrf_token" ) , self :: LOGOUT_CSRF_ACTION ) ) { $ this -> redirectToPage ( "logout" ) ; } $ this -> logout ( ) ; } }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
10537	public function prepareHeaders ( $ requestHeaders ) { $ responseHeaders = [ ] ; if ( isset ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { if ( in_array ( '*' , $ this -> cors [ 'Origin' ] ) || in_array ( $ requestHeaders [ 'Origin' ] , $ this -> cors [ 'Origin' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Origin' ] = $ requestHeaders [ 'Origin' ] ; } } $ this -> prepareAllowHeaders ( 'Headers' , $ requestHeaders , $ responseHeaders ) ; if ( isset ( $ requestHeaders [ 'Access-Control-Request-Method' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Methods' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Request-Method' ] ) ; } if ( isset ( $ this -> cors [ 'Access-Control-Allow-Credentials' ] ) ) { $ responseHeaders [ 'Access-Control-Allow-Credentials' ] = $ this -> cors [ 'Access-Control-Allow-Credentials' ] ? 'true' : 'false' ; } if ( isset ( $ this -> cors [ 'Access-Control-Max-Age' ] ) && Yii :: $ app -> getRequest ( ) -> getIsOptions ( ) ) { $ responseHeaders [ 'Access-Control-Max-Age' ] = $ this -> cors [ 'Access-Control-Max-Age' ] ; } if ( isset ( $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ) { $ responseHeaders [ 'Access-Control-Expose-Headers' ] = implode ( ', ' , $ this -> cors [ 'Access-Control-Expose-Headers' ] ) ; } return $ responseHeaders ; }
9671	private function writeCellStyleDxf ( XMLWriter $ objWriter , \ PhpOffice \ PhpSpreadsheet \ Style \ Style $ pStyle ) { $ objWriter -> startElement ( 'dxf' ) ; $ this -> writeFont ( $ objWriter , $ pStyle -> getFont ( ) ) ; $ this -> writeNumFmt ( $ objWriter , $ pStyle -> getNumberFormat ( ) ) ; $ this -> writeFill ( $ objWriter , $ pStyle -> getFill ( ) ) ; $ objWriter -> startElement ( 'alignment' ) ; if ( $ pStyle -> getAlignment ( ) -> getHorizontal ( ) !== null ) { $ objWriter -> writeAttribute ( 'horizontal' , $ pStyle -> getAlignment ( ) -> getHorizontal ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getVertical ( ) !== null ) { $ objWriter -> writeAttribute ( 'vertical' , $ pStyle -> getAlignment ( ) -> getVertical ( ) ) ; } if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) !== null ) { $ textRotation = 0 ; if ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) >= 0 ) { $ textRotation = $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } elseif ( $ pStyle -> getAlignment ( ) -> getTextRotation ( ) < 0 ) { $ textRotation = 90 - $ pStyle -> getAlignment ( ) -> getTextRotation ( ) ; } $ objWriter -> writeAttribute ( 'textRotation' , $ textRotation ) ; } $ objWriter -> endElement ( ) ; $ this -> writeBorder ( $ objWriter , $ pStyle -> getBorders ( ) ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) || ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) ) { if ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT || $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) { $ objWriter -> startElement ( 'protection' ) ; if ( ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getLocked ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'locked' , ( $ pStyle -> getProtection ( ) -> getLocked ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } if ( ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== null ) && ( $ pStyle -> getProtection ( ) -> getHidden ( ) !== Protection :: PROTECTION_INHERIT ) ) { $ objWriter -> writeAttribute ( 'hidden' , ( $ pStyle -> getProtection ( ) -> getHidden ( ) == Protection :: PROTECTION_PROTECTED ? 'true' : 'false' ) ) ; } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
1632	public function log ( $ level , $ message , array $ context = [ ] ) { parent :: log ( $ level , $ message , $ context ) ; $ this -> fireLogEvent ( $ level , $ message , $ context ) ; }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
1962	public static function decodeEmail ( $ strEmail ) { if ( $ strEmail == '' ) { return '' ; } if ( strpos ( $ strEmail , '@' ) === false ) { return $ strEmail ; } $ arrChunks = explode ( '@' , $ strEmail ) ; $ strHost = static :: decode ( array_pop ( $ arrChunks ) ) ; if ( $ strHost == '' ) { return '' ; } return implode ( '@' , $ arrChunks ) . '@' . $ strHost ; }
3464	public function get ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: get ( $ route ) ) ; }
5669	public function clipString ( $ string , $ size , $ position = 0 ) { $ utf8 = false ; if ( function_exists ( 'mb_detect_encoding' ) && mb_detect_encoding ( $ string ) == 'UTF-8' ) { $ utf8 = true ; } $ length = ( $ utf8 == true ) ? mb_strlen ( $ string , "UTF-8" ) : strlen ( $ string ) ; if ( $ length <= $ size ) { return $ string ; } $ position = min ( $ position , $ length ) ; $ start = ( $ size / 2 > $ position ? 0 : $ position - $ size / 2 ) ; if ( $ start + $ size > $ length ) { $ start = $ length - $ size ; } $ string = ( $ utf8 == true ) ? mb_substr ( $ string , $ start , $ size ) : substr ( $ string , $ start , $ size ) ; return ( $ start > 0 ? '...' : '' ) . $ string . ( $ start + $ size < $ length ? '...' : '' ) ; }
2673	public function getSingleAcl ( $ version , $ acl ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/acl/' . $ acl ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7399	public function redirect ( string $ url = '' , int $ statusCode = 302 ) { $ this -> is404 = false ; $ server = filter_input_array ( INPUT_SERVER ) ; if ( '' == $ url && isset ( $ server [ 'REQUEST_URI' ] ) ) { $ url = '/' . trim ( $ server [ 'REQUEST_URI' ] , '/' ) ; preg_match ( '/^[\\a-zA-Z0-9-\._~:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=%]*$/iD' , $ url , $ match ) ; $ url = $ match [ 1 ] ?? '' ; } if ( ! headers_sent ( ) ) { header ( 'Location: ' . $ url , true , $ statusCode ) ; } echo sprintf ( '<!DOCTYPE html><html> <head> <meta charset="UTF-8" /> <meta http-equiv="refresh" content="0;url=%1$s" /> <title>Redirecting to %1$s</title> </head> <body> <script type="text/javascript"> window.location.href = "%1$s"; </script> Redirecting to <a href="%1$s">%1$s</a>. </body></html>' , htmlspecialchars ( $ url , ENT_QUOTES , 'UTF-8' ) ) ; }
6583	public static function create ( $ b , $ q , $ n = 1 ) { if ( $ n == 1 ) return new static ( $ b , $ q ) ; static :: ensureValid ( $ n , "Amount of elements must be an integer number bigger than zero." ) ; return new static ( $ b * ( 1 - $ q ) / ( 1 - pow ( $ q , $ n ) ) , $ q ) ; }
9167	public function setFieldValidationStatus ( $ action = '' , $ shortname = '' , Elements \ ValidationStatus $ validation = null ) { if ( ! isset ( $ _SESSION [ 'prototyper_validation' ] [ $ action ] ) ) { $ _SESSION [ 'prototyper_validation' ] [ $ action ] = array ( ) ; } $ _SESSION [ 'prototyper_validation' ] [ $ action ] [ $ shortname ] = array ( 'status' => $ validation -> getStatus ( ) , 'messages' => $ validation -> getMessages ( ) ) ; }
596	public function actionCheckGuide ( $ directory = null ) { if ( $ directory === null ) { $ directory = \ dirname ( \ dirname ( __DIR__ ) ) . '/docs' ; } if ( is_file ( $ directory ) ) { $ files = [ $ directory ] ; } else { $ files = FileHelper :: findFiles ( $ directory , [ 'only' => [ '*.md' ] , ] ) ; } foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; $ chars = preg_split ( '//u' , $ content , null , PREG_SPLIT_NO_EMPTY ) ; $ line = 1 ; $ pos = 0 ; foreach ( $ chars as $ c ) { $ ord = $ this -> unicodeOrd ( $ c ) ; $ pos ++ ; if ( $ ord == 0x000A ) { $ line ++ ; $ pos = 0 ; } if ( $ ord === false ) { $ this -> found ( 'BROKEN UTF8' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( 0x2000 <= $ ord && $ ord <= 0x200F || 0x2028 <= $ ord && $ ord <= 0x202E || 0x205f <= $ ord && $ ord <= 0x206F ) { $ this -> found ( 'UNSUPPORTED SPACE CHARACTER' , $ c , $ line , $ pos , $ file ) ; continue ; } if ( $ ord < 0x0020 && $ ord != 0x000A && $ ord != 0x0009 || 0x0080 <= $ ord && $ ord < 0x009F ) { $ this -> found ( 'CONTROL CHARARCTER' , $ c , $ line , $ pos , $ file ) ; continue ; } } } }
6673	public function update_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_after_update_post ( $ post , $ update ) ) { if ( isset ( $ _POST [ 'efg-update-rating' ] ) ) { for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( ! isset ( $ _POST [ "efg-rating-$i" ] ) ) { return false ; } $ votes [ "$i" ] = ( int ) $ _POST [ "efg-rating-$i" ] ; } $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; } } return true ; }
7713	function FindEndTag ( $ Encaps = false ) { if ( is_null ( $ this -> SelfClosing ) ) { $ pe = $ this -> PosEnd ; $ SelfClosing = ( substr ( $ this -> Txt , $ pe - 1 , 1 ) == '/' ) ; if ( ! $ SelfClosing ) { if ( $ Encaps ) { $ loc = clsTinyButStrong :: f_Xml_FindTag ( $ this -> Txt , $ this -> FindName ( ) , null , $ pe , true , - 1 , false , false ) ; if ( $ loc === false ) return false ; $ this -> pET_PosBeg = $ loc -> PosBeg ; $ this -> PosEnd = $ loc -> PosEnd ; } else { $ pe = clsTinyButStrong :: f_Xml_FindTagStart ( $ this -> Txt , $ this -> FindName ( ) , false , $ pe , true , true ) ; if ( $ pe === false ) return false ; $ this -> pET_PosBeg = $ pe ; $ pe = strpos ( $ this -> Txt , '>' , $ pe ) ; if ( $ pe === false ) return false ; $ this -> PosEnd = $ pe ; } } $ this -> SelfClosing = $ SelfClosing ; } return true ; }
274	public function renderDataCell ( $ model , $ key , $ index ) { if ( $ this -> contentOptions instanceof Closure ) { $ options = call_user_func ( $ this -> contentOptions , $ model , $ key , $ index , $ this ) ; } else { $ options = $ this -> contentOptions ; } return Html :: tag ( 'td' , $ this -> renderDataCellContent ( $ model , $ key , $ index ) , $ options ) ; }
416	public function getAcceptableLanguages ( ) { if ( $ this -> _languages === null ) { if ( $ this -> headers -> has ( 'Accept-Language' ) ) { $ this -> _languages = array_keys ( $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept-Language' ) ) ) ; } else { $ this -> _languages = [ ] ; } } return $ this -> _languages ; }
514	public function actionDown ( $ limit = 1 ) { if ( $ limit === 'all' ) { $ limit = null ; } else { $ limit = ( int ) $ limit ; if ( $ limit < 1 ) { throw new Exception ( 'The step argument must be greater than 0.' ) ; } } $ migrations = $ this -> getMigrationHistory ( $ limit ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No migration has been done before.\n" , Console :: FG_YELLOW ) ; return ExitCode :: OK ; } $ migrations = array_keys ( $ migrations ) ; $ n = count ( $ migrations ) ; $ this -> stdout ( "Total $n " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be reverted:\n" , Console :: FG_YELLOW ) ; foreach ( $ migrations as $ migration ) { $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ reverted = 0 ; if ( $ this -> confirm ( 'Revert the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateDown ( $ migration ) ) { $ this -> stdout ( "\n$reverted from $n " . ( $ reverted === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ reverted ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " reverted.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated down successfully.\n" , Console :: FG_GREEN ) ; } }
2208	public function __isset ( $ strKey ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return isset ( $ this -> arrCache [ $ strKey ] ) ; }
1570	public function getResource ( ) { $ resource = $ this -> parameter ( ResourceRegistrar :: PARAM_RESOURCE_ID ) ; return is_object ( $ resource ) ? $ resource : null ; }
6742	public function apply ( Request $ request , ParamConverter $ configuration ) { $ param = $ this -> getRequestAttributeName ( $ request , $ configuration ) ; if ( ! $ request -> attributes -> has ( $ param ) ) { return false ; } $ value = $ request -> attributes -> get ( $ param ) ; if ( ! $ value && $ configuration -> isOptional ( ) ) { return false ; } $ convertedValue = $ this -> convertValue ( $ value , $ configuration ) ; if ( null === $ convertedValue && false === $ configuration -> isOptional ( ) ) { throw new NotFoundHttpException ( "Unable to find '{$configuration->getClass()}' with identifier '{$value}' not found" ) ; } $ request -> attributes -> set ( $ configuration -> getName ( ) , $ convertedValue ) ; return true ; }
1442	protected function replaceRecord ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'DummyRecord' , Str :: classify ( str_singular ( $ resource ) ) , $ stub ) ; return $ this ; }
8252	protected function logInvalidLoginAttempt ( $ name ) { $ max = $ this -> config [ "registration" ] [ "nameLenMax" ] ; if ( strlen ( $ name ) > $ max ) { $ max = substr ( $ name , 0 , $ max ) . " (trimmed)" ; } $ this -> getLogger ( ) -> notice ( "Invalid login attempt for {name} by {addr}" , array ( "name" => $ name , "addr" => $ _SERVER [ 'REMOTE_ADDR' ] , ) ) ; }
5409	public function selectAsPairs ( $ url ) { $ pairs = array ( ) ; foreach ( $ this -> cookies as $ cookie ) { if ( $ this -> isMatch ( $ cookie , $ url -> getHost ( ) , $ url -> getPath ( ) , $ cookie -> getName ( ) ) ) { $ pairs [ ] = $ cookie -> getName ( ) . '=' . $ cookie -> getValue ( ) ; } } return $ pairs ; }
946	public function handle ( Request $ request , Closure $ next ) { $ query = $ request -> query -> all ( ) ; $ signature = $ query [ 'signature' ] ; unset ( $ query [ 'signature' ] ) ; $ signatureLocal = ShopifyApp :: createHmac ( [ 'data' => $ query , 'buildQuery' => true ] ) ; if ( $ signature !== $ signatureLocal || ! isset ( $ query [ 'shop' ] ) ) { return Response :: make ( 'Invalid proxy signature.' , 401 ) ; } Session :: put ( 'shopify_domain' , ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ) ; return $ next ( $ request ) ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
17	public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; }
7635	public function getBlockList ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ type = 0 ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; if ( $ type < 0 || $ type > 2 ) { throw new BlobException ( 'Invalid type of block list to retrieve.' ) ; } $ blockListType = 'all' ; if ( $ type == 1 ) { $ blockListType = 'committed' ; } if ( $ type == 2 ) { $ blockListType = 'uncommitted' ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ query = array ( 'comp' => 'blocklist' , 'blocklisttype' => $ blockListType ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'GET' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ blockList = $ this -> parseResponse ( $ response ) ; $ returnValue = array ( ) ; if ( $ blockList -> CommittedBlocks ) { foreach ( $ blockList -> CommittedBlocks -> Block as $ block ) { $ returnValue [ 'CommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } if ( $ blockList -> UncommittedBlocks ) { foreach ( $ blockList -> UncommittedBlocks -> Block as $ block ) { $ returnValue [ 'UncommittedBlocks' ] [ ] = ( object ) array ( 'Name' => ( string ) $ block -> Name , 'Size' => ( string ) $ block -> Size ) ; } } return $ returnValue ; }
6713	public function getParameter ( $ key , $ default = null ) { if ( array_key_exists ( $ key , $ this -> parameters ) ) { return $ this -> parameters [ $ key ] ; } $ flatKey = $ this -> flatten ( $ key ) ; foreach ( $ this -> parameters as $ index => $ value ) { if ( $ flatKey == $ this -> flatten ( $ index ) ) { return $ value ; } } return $ default ; }
321	public function normalizePathInfo ( $ pathInfo , $ suffix , & $ normalized = false ) { if ( empty ( $ pathInfo ) ) { return $ pathInfo ; } $ sourcePathInfo = $ pathInfo ; if ( $ this -> collapseSlashes ) { $ pathInfo = $ this -> collapseSlashes ( $ pathInfo ) ; } if ( $ this -> normalizeTrailingSlash === true ) { $ pathInfo = $ this -> normalizeTrailingSlash ( $ pathInfo , $ suffix ) ; } $ normalized = $ sourcePathInfo !== $ pathInfo ; return $ pathInfo ; }
63	public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ deleted = @ rmdir ( $ path ) ; } if ( ! $ deleted ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
8828	public function image ( $ name , $ file , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ file , $ secure ) ; return $ this -> input ( 'image' , $ name , null , $ attributes ) ; }
9570	public function addMiddleware ( $ middleware , $ priority = null ) { $ this -> middlewares -> insert ( $ middleware , ( int ) $ priority ) ; }
2309	public function getImportantPart ( ) { if ( $ this -> importantPart ) { return $ this -> importantPart ; } return array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight ) ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
833	private function findFunction ( Tokens $ tokens , $ name , $ startIndex , $ endIndex ) { $ function = $ tokens -> findSequence ( [ [ T_FUNCTION ] , [ T_STRING , $ name ] , '(' , ] , $ startIndex , $ endIndex , false ) ; if ( null === $ function ) { return null ; } $ function = array_keys ( $ function ) ; $ possibleModifiers = [ T_PUBLIC , T_PROTECTED , T_PRIVATE , T_STATIC , T_ABSTRACT , T_FINAL ] ; $ modifiers = [ ] ; $ prevBlock = $ tokens -> getPrevMeaningfulToken ( $ function [ 0 ] ) ; while ( null !== $ prevBlock && $ tokens [ $ prevBlock ] -> isGivenKind ( $ possibleModifiers ) ) { $ modifiers [ $ tokens [ $ prevBlock ] -> getId ( ) ] = $ prevBlock ; $ prevBlock = $ tokens -> getPrevMeaningfulToken ( $ prevBlock ) ; } if ( isset ( $ modifiers [ T_ABSTRACT ] ) ) { $ bodyStart = null ; $ funcEnd = $ tokens -> getNextTokenOfKind ( $ function [ 2 ] , [ ';' ] ) ; } else { $ bodyStart = $ tokens -> getNextTokenOfKind ( $ function [ 2 ] , [ '{' ] ) ; $ funcEnd = null !== $ bodyStart ? $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ bodyStart ) : null ; } return [ 'nameIndex' => $ function [ 1 ] , 'startIndex' => $ prevBlock + 1 , 'endIndex' => $ funcEnd , 'bodyIndex' => $ bodyStart , 'modifiers' => $ modifiers , ] ; }
12878	public function setValue ( $ value ) { $ this -> value = $ value ; if ( is_array ( $ value ) && array_key_exists ( 'start' , $ value ) && array_key_exists ( 'end' , $ value ) ) { $ start = ( float ) $ value [ 'start' ] ; $ end = ( float ) $ value [ 'end' ] ; if ( $ start <= $ end ) { $ this -> startElement -> setValue ( $ start ) ; $ this -> endElement -> setValue ( $ end ) ; } } return $ this ; }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
2980	public function addResource ( Bundle $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { throw new \ RuntimeException ( sprintf ( 'The target config file %s does not exist' , $ this -> file ) ) ; } $ code = $ this -> getImportCode ( $ bundle ) ; $ currentContents = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ currentContents , $ code ) ) { throw new \ RuntimeException ( sprintf ( 'The %s configuration file from %s is already imported' , $ bundle -> getServicesConfigurationFilename ( ) , $ bundle -> getName ( ) ) ) ; } $ lastImportedPath = $ this -> findLastImportedPath ( $ currentContents ) ; if ( ! $ lastImportedPath ) { throw new \ RuntimeException ( sprintf ( 'Could not find the imports key in %s' , $ this -> file ) ) ; } $ importsPosition = strpos ( $ currentContents , 'imports:' ) ; $ lastImportPosition = strpos ( $ currentContents , $ lastImportedPath , $ importsPosition ) ; $ targetLinebreakPosition = strpos ( $ currentContents , "\n" , $ lastImportPosition ) ; $ newContents = substr ( $ currentContents , 0 , $ targetLinebreakPosition ) . "\n" . $ code . substr ( $ currentContents , $ targetLinebreakPosition ) ; if ( false === Generator :: dump ( $ this -> file , $ newContents ) ) { throw new \ RuntimeException ( sprintf ( 'Could not write file %s ' , $ this -> file ) ) ; } }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
8745	protected function resetListener ( ) { $ this -> currentKey = null ; $ this -> escapePressedAt = null ; $ this -> charSequenceEnabled = false ; $ this -> isListening = true ; return $ this ; }
6074	public function restoreMedia ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/media/' . $ id . '/restore' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
7191	private function copyNotification ( Model \ SaleNotificationInterface $ source , Model \ SaleNotificationInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'type' , 'data' , 'sentAt' , 'details' ] ) ; }
5970	public function accounts ( ) { if ( ! $ this -> accounts instanceof AccountsController ) { $ this -> accounts = new AccountsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> accounts -> setLogger ( $ this -> logger ) ; } return $ this -> accounts ; }
10897	public function setScheme ( $ scheme ) { foreach ( $ this -> uris as $ name => $ uri ) { $ this -> add ( $ name , $ uri -> withScheme ( $ scheme ) ) ; } }
1917	public static function findByArchive ( $ intId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.archives LIKE '%\"" . ( int ) $ intId . "\"%'" ) , null , $ arrOptions ) ; }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
11438	public function getDefault ( $ name ) { return isset ( $ this -> options [ 'defaults' ] [ $ name ] ) ? $ this -> options [ 'defaults' ] [ $ name ] : null ; }
8923	public function generate ( $ sourceDocument , $ targetDocument ) { if ( $ sourceDocument === null || $ targetDocument === null ) { return $ targetDocument ; } if ( $ sourceDocument == new \ stdClass ( ) ) { return null ; } if ( is_array ( $ sourceDocument ) ) { if ( $ sourceDocument !== $ targetDocument ) { return $ targetDocument ; } return null ; } $ patchDocument = new \ stdClass ( ) ; $ sourceDocumentVars = get_object_vars ( $ sourceDocument ) ; $ targetDocumentVars = get_object_vars ( $ targetDocument ) ; foreach ( $ targetDocumentVars as $ var => $ value ) { if ( ! in_array ( $ var , array_keys ( $ sourceDocumentVars ) ) || ! in_array ( $ value , array_values ( $ sourceDocumentVars ) ) ) { $ patchDocument -> $ var = $ value ; } } foreach ( $ sourceDocumentVars as $ var => $ value ) { if ( $ targetDocumentVars === [ ] ) { $ patchDocument -> $ var = null ; break ; } if ( is_object ( $ value ) ) { if ( $ sourceDocument -> $ var !== null && is_object ( $ sourceDocument -> $ var ) ) { $ subPatch = $ this -> generate ( $ sourceDocument -> $ var , $ targetDocument -> $ var ) ; if ( $ subPatch !== null ) { $ patchDocument -> $ var = $ subPatch ; } } } elseif ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) || ! in_array ( $ value , array_values ( $ targetDocumentVars ) ) ) { $ sourceDocument -> $ var = null ; if ( ! in_array ( $ var , array_keys ( $ targetDocumentVars ) ) ) { $ patchDocument -> $ var = null ; } } } if ( count ( get_object_vars ( $ patchDocument ) ) > 0 ) { return $ patchDocument ; } return null ; }
6005	public function addCategoryResponse ( $ item ) { if ( ! ( $ item instanceof CategoryResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new CategoryResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate CategoryResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "CategoryResponse"!' , E_USER_WARNING ) ; } } $ this -> categories [ ] = $ item ; return $ this ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
1808	public function getContentElements ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'TL_CTE' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
8395	public static function get ( ) : Logger { if ( self :: $ log == null ) { self :: $ log = new Logger ( ) ; } return self :: $ log ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
10952	protected function write ( Response $ response , $ body ) : Response { $ response -> getBody ( ) -> write ( ( string ) $ body ) ; return $ response ; }
10779	private function addSessionCookie ( ResponseInterface $ response ) : ResponseInterface { $ params = session_get_cookie_params ( ) ; $ cookie = new SetCookie ( session_name ( ) , session_id ( ) , time ( ) + $ params [ "lifetime" ] , $ params [ "path" ] , $ params [ "domain" ] , $ params [ "secure" ] , $ params [ "httponly" ] ) ; return $ cookie -> addToResponse ( $ response ) ; }
5721	public function doSaveAndPrev ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; $ link = $ this -> getEditLink ( $ this -> getPreviousRecordID ( ) ) ; return $ this -> saveAndRedirect ( $ data , $ form , $ link ) ; }
3064	protected function storeResult ( array $ results ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ success = true ; try { foreach ( $ results as $ result ) { if ( ! $ result instanceof AbstractResult ) { throw new \ common_Exception ( __FUNCTION__ . ' requires a CAT result to store it.' ) ; } $ variables = $ this -> convertCatVariables ( $ result -> getVariables ( ) ) ; if ( empty ( $ variables ) ) { \ common_Logger :: t ( 'No Cat result variables to store.' ) ; continue ; } if ( $ result instanceof ItemResult ) { $ itemId = $ result -> getItemRefId ( ) ; $ itemUri = $ this -> getItemUriFromRefId ( $ itemId ) ; } else { $ itemUri = $ itemId = null ; $ sectionId = $ this -> getTestSession ( ) -> getRoute ( ) -> current ( ) -> getAssessmentSection ( ) -> getIdentifier ( ) ; foreach ( $ variables as $ variable ) { $ variable -> setIdentifier ( $ sectionId . '-' . $ variable -> getIdentifier ( ) ) ; } } if ( ! $ runnerService -> storeVariables ( $ this , $ itemUri , $ variables , $ itemId ) ) { $ success = false ; } } } catch ( \ Exception $ e ) { \ common_Logger :: w ( 'An error has occurred during CAT result storing: ' . $ e -> getMessage ( ) ) ; $ success = false ; } return $ success ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
12046	public function getThumbnails ( $ videoId , $ format = null ) { $ listResponse = $ this -> videos -> listVideos ( 'snippet' , array ( 'id' => $ videoId ) ) ; if ( empty ( $ listResponse ) ) { throw new \ RuntimeException ( sprintf ( 'Could not find video with id %s' , $ videoId ) ) ; } $ video = $ listResponse [ 0 ] ; $ videoSnippet = $ video [ 'snippet' ] ; if ( is_null ( $ format ) ) { return $ videoSnippet [ 'thumbnails' ] [ 'data' ] ; } if ( ! in_array ( $ format , array ( 'default' , 'medium' , 'high' ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid format "%s"' , $ format ) ) ; } return $ videoSnippet [ 'thumbnails' ] [ 'data' ] [ $ format ] ; }
3234	static function stringEquals ( $ a , $ b ) { if ( func_num_args ( ) !== 2 ) { throw new \ InvalidArgumentException ( "Expecting 2 args, got " . func_num_args ( ) . "." ) ; } Checker :: argString ( "a" , $ a ) ; Checker :: argString ( "b" , $ b ) ; $ len = strlen ( $ a ) ; if ( strlen ( $ b ) !== $ len ) return false ; $ result = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ result |= ord ( $ a [ $ i ] ) ^ ord ( $ b [ $ i ] ) ; } return $ result === 0 ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
2329	public function delete ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } return $ this -> arrModels [ $ this -> intIndex ] -> delete ( ) ; }
10363	public function __isset ( $ childName ) { foreach ( $ this -> nodes as $ node ) { if ( isset ( $ node -> $ childName ) ) { return true ; } } return false ; }
744	private function getFragmentCacheConfiguration ( ) { $ cache = $ this -> getCacheInstance ( ) ; $ fragmentCacheConfiguration = [ 'cache' => $ cache , 'duration' => $ this -> cacheDuration , 'dependency' => $ this -> cacheDependency , 'enabled' => $ this -> cacheEnabled , ] ; return $ fragmentCacheConfiguration ; }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
6144	public function hasQueryVar ( $ key ) { if ( ! $ this -> hasQuery ( ) ) { return false ; } parse_str ( $ this -> query , $ queryArray ) ; return array_key_exists ( $ key , $ queryArray ) ? true : false ; }
12078	public function childAssociate ( $ request , $ idParent , $ idChild , $ relation ) { $ request -> request -> merge ( [ 'url' => $ request -> request -> path ( ) ] ) ; $ idParent = $ this -> getRealId ( $ idParent ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resourceChild = $ this -> repository -> attach ( $ idParent , $ idChild , $ relation , $ request -> all ( ) ) ; if ( ! $ resourceChild ) { } return $ this -> success ( [ $ resourceChild ] ) ; }
267	protected function loadMessagesFromDb ( $ category , $ language ) { $ mainQuery = ( new Query ( ) ) -> select ( [ 'message' => 't1.message' , 'translation' => 't2.translation' ] ) -> from ( [ 't1' => $ this -> sourceMessageTable , 't2' => $ this -> messageTable ] ) -> where ( [ 't1.id' => new Expression ( '[[t2.id]]' ) , 't1.category' => $ category , 't2.language' => $ language , ] ) ; $ fallbackLanguage = substr ( $ language , 0 , 2 ) ; $ fallbackSourceLanguage = substr ( $ this -> sourceLanguage , 0 , 2 ) ; if ( $ fallbackLanguage !== $ language ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackLanguage ) , true ) ; } elseif ( $ language === $ fallbackSourceLanguage ) { $ mainQuery -> union ( $ this -> createFallbackQuery ( $ category , $ language , $ fallbackSourceLanguage ) , true ) ; } $ messages = $ mainQuery -> createCommand ( $ this -> db ) -> queryAll ( ) ; return ArrayHelper :: map ( $ messages , 'message' , 'translation' ) ; }
11204	public function where ( $ key = false , $ desiredValue , $ op = "==" ) { $ collection = $ this -> getIterator ( ) ; $ subset = new Collection ( ) ; foreach ( $ collection as $ prop => $ result ) { $ realValue = $ result ; if ( is_object ( $ result ) ) { $ realValue = $ result -> $ key ; } else if ( is_array ( $ result ) ) { $ realValue = $ result [ $ key ] ; } $ add = false ; if ( $ op == '==' && $ realValue == $ desiredValue ) { $ add = true ; } else if ( $ op == '>=' && $ realValue >= $ desiredValue ) { $ add = true ; } else if ( $ op == '<=' && $ realValue <= $ desiredValue ) { $ add = true ; } else if ( $ op == '>' && $ realValue > $ desiredValue ) { $ add = true ; } else if ( $ op == '<' && $ realValue < $ desiredValue ) { $ add = true ; } else if ( $ op == '===' && $ realValue === $ desiredValue ) { $ add = true ; } else if ( $ op == '!=' && $ realValue != $ desiredValue ) { $ add = true ; } if ( $ add ) { $ subset -> add ( $ result , $ prop ) ; } } return $ subset ; }
1138	public function destroyDescendants ( ) { if ( is_null ( $ this -> getRight ( ) ) || is_null ( $ this -> getLeft ( ) ) ) return ; $ self = $ this ; $ this -> getConnection ( ) -> transaction ( function ( ) use ( $ self ) { $ self -> reload ( ) ; $ lftCol = $ self -> getLeftColumnName ( ) ; $ rgtCol = $ self -> getRightColumnName ( ) ; $ lft = $ self -> getLeft ( ) ; $ rgt = $ self -> getRight ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>=' , $ lft ) -> select ( $ self -> getKeyName ( ) ) -> lockForUpdate ( ) -> get ( ) ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ lft ) -> where ( $ rgtCol , '<' , $ rgt ) -> delete ( ) ; $ diff = $ rgt - $ lft + 1 ; $ self -> newNestedSetQuery ( ) -> where ( $ lftCol , '>' , $ rgt ) -> decrement ( $ lftCol , $ diff ) ; $ self -> newNestedSetQuery ( ) -> where ( $ rgtCol , '>' , $ rgt ) -> decrement ( $ rgtCol , $ diff ) ; } ) ; }
9965	public function setSelectedCells ( $ pCoordinate ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+)$/' , '${1}:${1}' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^([A-Z]+):([A-Z]+)$/' , '${1}1:${2}1048576' , $ pCoordinate ) ; $ pCoordinate = preg_replace ( '/^(\d+):(\d+)$/' , 'A${1}:XFD${2}' , $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { list ( $ first ) = Coordinate :: splitRange ( $ pCoordinate ) ; $ this -> activeCell = $ first [ 0 ] ; } else { $ this -> activeCell = $ pCoordinate ; } $ this -> selectedCells = $ pCoordinate ; return $ this ; }
2137	protected function escape ( $ varValue ) { if ( is_numeric ( $ varValue ) && ! preg_match ( '/e|^[+-]?0[^.]/' , $ varValue ) && $ varValue < PHP_INT_MAX ) { return $ varValue ; } if ( \ is_bool ( $ varValue ) ) { return $ varValue ? 'true' : 'false' ; } if ( $ varValue == 'true' ) { return 'true' ; } if ( $ varValue == 'false' ) { return 'false' ; } return "'" . str_replace ( '\\"' , '"' , preg_replace ( '/[\n\r\t ]+/' , ' ' , addslashes ( $ varValue ) ) ) . "'" ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
6123	public function login ( $ username , $ password ) { $ this -> execute ( "login" , array ( "client_login_name" => $ username , "client_login_password" => $ password ) ) ; $ this -> whoamiReset ( ) ; $ crypt = new Crypt ( $ username ) ; $ this -> setStorage ( "_login_user" , $ username ) ; $ this -> setStorage ( "_login_pass" , $ crypt -> encrypt ( $ password ) ) ; Signal :: getInstance ( ) -> emit ( "notifyLogin" , $ this ) ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
11475	public function setObjectType ( $ type ) { if ( ! is_object ( $ type ) ) { if ( Yii :: $ app -> collectors [ 'types' ] -> has ( $ type ) ) { $ type = Yii :: $ app -> collectors [ 'types' ] -> getOne ( $ type ) -> object ; } else { $ type = null ; } } $ this -> _objectType = $ type ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
2217	public function getChannels ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> newsletters ) ) { return array ( ) ; } $ arrChannels = array ( ) ; $ objChannels = $ this -> Database -> execute ( "SELECT id, title FROM tl_newsletter_channel ORDER BY title" ) ; while ( $ objChannels -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objChannels -> id , 'newsletters' ) ) { $ arrChannels [ $ objChannels -> id ] = $ objChannels -> title ; } } return $ arrChannels ; }
12667	public function getInputSpecification ( ) { $ datetimeElement = $ this ; return array ( 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => array ( array ( 'name' => 'Zend\Filter\StringTrim' ) , array ( 'name' => 'Callback' , 'options' => array ( 'callback' => function ( $ value ) use ( $ datetimeElement ) { if ( ! empty ( $ value ) && is_string ( $ value ) ) { return DateTime :: createFromFormat ( $ datetimeElement -> getFormat ( ) , $ value ) ; } return $ value ; } ) ) ) , 'validators' => $ this -> getValidators ( ) , ) ; }
7743	public function setValue ( $ entity , $ value ) { if ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( ! is_array ( $ value ) && ! ( $ value instanceof \ Traversable ) ) { if ( ( null !== $ this -> adderRemover ) && ( null !== $ this -> getter ) ) { $ itemsToAdd = is_object ( $ value ) ? iterator_to_array ( $ value ) : $ value ; $ itemToRemove = array ( ) ; $ previousValue = $ this -> getValue ( $ entity ) ; if ( is_array ( $ previousValue ) || $ previousValue instanceof \ Traversable ) { foreach ( $ previousValue as $ previousItem ) { foreach ( $ value as $ key => $ item ) { if ( $ item === $ previousItem ) { unset ( $ itemsToAdd [ $ key ] ) ; continue 2 ; } } $ itemToRemove [ ] = $ previousItem ; } } foreach ( $ itemToRemove as $ item ) { call_user_func ( array ( $ entity , 'remove' . $ this -> adderRemover ) , $ item ) ; } foreach ( $ itemsToAdd as $ item ) { call_user_func ( array ( $ entity , 'add' . $ this -> adderRemover ) , $ item ) ; } return ; } } if ( null === $ this -> setter ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as no setter has been found." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> setterType ) { return $ entity -> { $ this -> setter } ( $ value ) ; } else { return $ entity -> { $ this -> setter } = $ value ; } }
2369	public static function splitFriendlyEmail ( $ strEmail ) { if ( strpos ( $ strEmail , '<' ) !== false ) { return array_map ( 'trim' , explode ( ' <' , str_replace ( '>' , '' , $ strEmail ) ) ) ; } elseif ( strpos ( $ strEmail , '[' ) !== false ) { return array_map ( 'trim' , explode ( ' [' , str_replace ( ']' , '' , $ strEmail ) ) ) ; } else { return array ( '' , $ strEmail ) ; } }
3586	protected function unbindNumerics ( ArgumentBag $ args ) { if ( ( $ value = $ args -> get ( 'value' ) ) && ( is_int ( $ value ) || is_float ( $ value ) ) ) { $ args -> set ( 'value' , $ this -> raw ( $ value ) ) ; } elseif ( $ values = $ args -> get ( 'values' ) ) { foreach ( $ values as $ key => $ value ) { if ( is_int ( $ value ) || is_float ( $ value ) ) { $ values [ $ key ] = $ this -> raw ( $ value ) ; } } $ args -> set ( 'values' , $ values ) ; } }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
9295	public function buildCustomFields ( $ form_fields = [ ] , $ config_name = 'custom_form' ) { $ fields = collect ( $ form_fields ) -> map ( function ( $ field , $ name ) use ( $ config_name ) { return $ this -> render ( isset ( $ field [ 'type' ] ) ? $ field [ 'type' ] : 'text' , [ $ name , $ field [ 'label' ] , [ 'data-table' => $ config_name ] ] ) ; } ) ; return $ fields ; }
4366	protected function backtraceStr ( Event $ error ) { $ backtrace = $ error [ 'backtrace' ] ? $ error [ 'backtrace' ] : $ error -> getSubject ( ) -> backtrace ( ) ; if ( \ count ( $ backtrace ) < 2 ) { return '' ; } if ( $ backtrace && $ error [ 'vars' ] ) { $ backtrace [ 0 ] [ 'vars' ] = $ error [ 'vars' ] ; } if ( $ this -> cfg [ 'emailBacktraceDumper' ] ) { $ str = \ call_user_func ( $ this -> cfg [ 'emailBacktraceDumper' ] , $ backtrace ) ; } else { $ search = array ( ")\n\n" , ) ; $ replace = array ( ")\n" , ) ; $ str = \ print_r ( $ backtrace , true ) ; $ str = \ preg_replace ( '#\bArray\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '/\barray\s+\(\s+\)/s' , 'array()' , $ str ) ; $ str = \ str_replace ( $ search , $ replace , $ str ) ; $ str = \ substr ( $ str , 0 , - 1 ) ; } return $ str ; }
4590	public function exists ( $ form , Parameters $ parameters = null ) : bool { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
3812	protected function transformConditions ( $ conditions ) { $ sorted = array ( ) ; $ byPid = array ( ) ; foreach ( $ conditions as $ i => $ condition ) { $ sorted [ $ condition [ 'id' ] ] = $ conditions [ $ i ] ; $ byPid [ $ condition [ 'pid' ] ] [ ] = $ condition [ 'id' ] ; } $ instances = array ( ) ; foreach ( $ sorted as $ id => $ condition ) { $ instances [ $ id ] = $ this -> transformCondition ( $ condition ) ; } foreach ( $ byPid as $ pid => $ ids ) { foreach ( $ ids as $ id ) { $ settingId = $ sorted [ $ id ] [ 'settingId' ] ; if ( ! isset ( $ this -> conditions [ $ settingId ] ) ) { $ this -> conditions [ $ settingId ] = new PropertyConditionChain ( ) ; } $ result = $ this -> conditions [ $ settingId ] ; $ condition = $ instances [ $ id ] ; $ parent = ( $ pid == 0 ) ? $ result : $ instances [ $ pid ] ; if ( $ parent instanceof ConditionChainInterface ) { $ parent -> addCondition ( $ condition ) ; } elseif ( $ parent instanceof NotCondition ) { $ parent -> setCondition ( $ condition ) ; } } } }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
11323	protected function getAnnotationMethodForMethod ( ClassInterface $ class , $ requestMethod ) { foreach ( $ class -> getMethods ( ) as $ method ) { if ( $ method -> getAnnotatedName ( ) === $ requestMethod ) { return $ method ; } } throw new ExtDirectException ( "extjs method name '{$requestMethod}' does not exist'" ) ; }
4601	public function kernelRequest ( GetResponseEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> isMethod ( Request :: METHOD_PUT ) ) { return ; } if ( ! $ request -> attributes -> has ( 'data' ) ) { return ; } $ data = $ request -> attributes -> get ( 'data' ) ; if ( ! $ data instanceof Access ) { return ; } $ access = $ data ; $ manager = $ this -> accessService -> getManager ( ) ; foreach ( $ access -> getPermissions ( ) as $ permission ) { $ manager -> remove ( $ permission ) ; } $ manager -> flush ( ) ; }
4978	public function filter ( $ value ) { return isset ( $ this -> map [ $ value ] ) ? $ this -> map [ $ value ] : $ value ; }
4864	public function pop ( array $ options = [ ] ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ now = $ this -> dateTimeToUTCDateTime ( $ this -> now ) ; $ envelope = $ this -> mongoCollection -> findOneAndUpdate ( [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'scheduled' => [ '$lte' => $ now ] , ] , [ '$set' => [ 'status' => self :: STATUS_RUNNING , 'executed' => $ now , ] , ] , [ 'sort' => [ 'priority' => 1 , 'scheduled' => 1 ] , 'returnDocument' => \ MongoDB \ Operation \ FindOneAndUpdate :: RETURN_DOCUMENT_AFTER ] ) ; if ( ! $ envelope ) { return null ; } return $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; }
9127	private function checkConnection ( $ start ) : bool { if ( ! $ this -> ready ( ) ) { if ( time ( ) - $ start > $ this -> timeout ) { $ this -> disconnect ( ) ; throw new HttpException ( "Connection timed out!" ) ; } return false ; } return true ; }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
11226	final public static function getShortName ( $ className = '' ) { $ base = strrchr ( static :: getRealClassName ( $ className ) , '\\' ) ; return $ base ? substr ( $ base , 1 ) : $ className ; }
2318	public static function getPath ( $ src ) { if ( $ src == '' ) { return '' ; } $ src = rawurldecode ( $ src ) ; if ( strpos ( $ src , '/' ) !== false ) { return $ src ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strncmp ( $ src , 'icon' , 4 ) === 0 ) { if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'assets/contao/images/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/assets/contao/images/' . $ filename . '.svg' ) ) { return 'assets/contao/images/' . $ filename . '.svg' ; } return 'assets/contao/images/' . $ src ; } else { $ theme = Backend :: getTheme ( ) ; if ( pathinfo ( $ src , PATHINFO_EXTENSION ) == 'svg' ) { return 'system/themes/' . $ theme . '/icons/' . $ src ; } $ filename = pathinfo ( $ src , PATHINFO_FILENAME ) ; if ( file_exists ( $ rootDir . '/system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ) ) { return 'system/themes/' . $ theme . '/icons/' . $ filename . '.svg' ; } return 'system/themes/' . $ theme . '/images/' . $ src ; } }
1314	public function url ( $ path , array $ parameters ) { $ this -> resetLastResponse ( ) ; $ this -> response -> setApiPath ( $ path ) ; $ query = http_build_query ( $ parameters ) ; return sprintf ( '%s/%s?%s' , self :: API_HOST , $ path , $ query ) ; }
6227	public function removeOnFree ( bool $ activate = true ) : self { $ this -> storage -> removeOnFree ( $ activate ) ; return $ this ; }
8013	protected function getBasicOptions ( ) { $ options = array ( ) ; $ options [ ] = '-encoding UTF-8' ; if ( $ this -> _asHtml ) { $ options [ ] = '-html' ; } if ( $ this -> _toConsole ) { $ options [ ] = '-console' ; } return join ( ' ' , $ options ) ; }
824	public function getName ( ) { if ( null === $ this -> name ) { Preg :: matchAll ( '/@[a-zA-Z0-9_-]+(?=\s|$)/' , $ this -> line -> getContent ( ) , $ matches ) ; if ( isset ( $ matches [ 0 ] [ 0 ] ) ) { $ this -> name = ltrim ( $ matches [ 0 ] [ 0 ] , '@' ) ; } else { $ this -> name = 'other' ; } } return $ this -> name ; }
7074	private function addSaleDetails ( array & $ details , Model \ SaleInterface $ sale ) { if ( $ sale -> getCurrency ( ) -> getCode ( ) !== $ this -> currency ) { return ; } if ( 0 !== Money :: compare ( $ sale -> getGrandTotal ( ) , $ details [ 'PAYMENTREQUEST_0_AMT' ] , $ this -> currency ) ) { return ; } $ this -> calculator -> calculateSale ( $ sale ) ; $ this -> line = 0 ; $ lineTotals = 0 ; foreach ( $ sale -> getItems ( ) as $ item ) { $ lineTotals += $ this -> addItemDetails ( $ details , $ item ) ; } foreach ( $ sale -> getAdjustments ( Model \ AdjustmentTypes :: TYPE_DISCOUNT ) as $ discount ) { $ lineTotals += $ this -> addDiscountDetails ( $ details , $ discount ) ; } $ details [ 'PAYMENTREQUEST_0_ITEMAMT' ] = $ this -> format ( $ lineTotals ) ; $ details [ 'PAYMENTREQUEST_0_SHIPPINGAMT' ] = $ this -> format ( $ sale -> getShipmentResult ( ) -> getTotal ( ) ) ; }
3301	public function request ( $ method , $ url , $ options = [ ] ) { $ method = strtoupper ( $ method ) ; $ options = array_merge ( self :: $ defaults , [ 'headers' => $ this -> headers ] , $ options ) ; return $ this -> getClient ( ) -> request ( $ method , $ url , $ options ) ; }
6138	protected function parseUri ( $ uriString = '' ) { $ status = @ preg_match ( "~^((//)([^/?#]*))([^?#]*)(\?([^#]*))?(#(.*))?$~" , $ uriString , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> path = ( isset ( $ matches [ 4 ] ) ) ? $ matches [ 4 ] : '' ; $ this -> query = ( isset ( $ matches [ 6 ] ) ) ? $ matches [ 6 ] : '' ; $ this -> fragment = ( isset ( $ matches [ 8 ] ) ) ? $ matches [ 8 ] : '' ; $ status = @ preg_match ( "~^(([^:@]*)(:([^@]*))?@)?([^:]+)(:(.*))?$~" , ( isset ( $ matches [ 3 ] ) ) ? $ matches [ 3 ] : "" , $ matches ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI scheme-specific authority decomposition failed" ) ; } if ( ! $ status ) { return ; } $ this -> user = isset ( $ matches [ 2 ] ) ? $ matches [ 2 ] : "" ; $ this -> pass = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : "" ; $ this -> host = isset ( $ matches [ 5 ] ) ? $ matches [ 5 ] : "" ; $ this -> port = isset ( $ matches [ 7 ] ) ? $ matches [ 7 ] : "" ; }
6811	private function getDateFormatter ( ) { if ( $ this -> dateFormatter ) { return $ this -> dateFormatter ; } return $ this -> dateFormatter = IntlDateFormatter :: create ( $ this -> locale , IntlDateFormatter :: SHORT , IntlDateFormatter :: NONE , ini_get ( 'date.timezone' ) , IntlDateFormatter :: GREGORIAN ) ; }
9014	public function longtext ( string $ charset = null ) : self { $ this -> type = 'longtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
4261	public function removeSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> unsubscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
11758	public function reply ( $ msgId , $ index , $ commentId , $ content ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , 'content' => $ content , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_REPLY_COMMENT , $ params ] ) ; }
3368	public function generateFromMetadata ( array $ metadata ) { $ this -> metadata = $ metadata ; $ this -> visitedAssociations = [ ] ; $ str = [ ] ; foreach ( $ metadata as $ class ) { $ parent = $ this -> getParent ( $ class ) ; if ( $ parent ) { $ str [ ] = $ this -> getClassString ( $ parent ) . '^' . $ this -> getClassString ( $ class ) ; } $ associations = $ class -> getAssociationNames ( ) ; if ( empty ( $ associations ) && ! isset ( $ this -> visitedAssociations [ $ class -> getName ( ) ] ) ) { $ str [ ] = $ this -> getClassString ( $ class ) ; continue ; } foreach ( $ associations as $ associationName ) { if ( $ parent && in_array ( $ associationName , $ parent -> getAssociationNames ( ) ) ) { continue ; } if ( $ this -> visitAssociation ( $ class -> getName ( ) , $ associationName ) ) { $ str [ ] = $ this -> getAssociationString ( $ class , $ associationName ) ; } } } return implode ( ',' , $ str ) ; }
12462	private function createCreateForm ( CustomFieldsGroup $ entity ) { $ form = $ this -> createForm ( 'custom_fields_group' , $ entity , array ( 'action' => $ this -> generateUrl ( 'customfieldsgroup_create' ) , 'method' => 'POST' , ) ) ; $ form -> add ( 'submit' , 'submit' , array ( 'label' => 'Create' ) ) ; return $ form ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
9140	public static function parseFromServerRequest ( $ serverVars , $ defaultController = 'Index' , $ defaultAction = 'index' ) { if ( ! isset ( $ serverVars [ 'REQUEST_URI' ] ) ) { throw new InvalidUrlException ( "No such uri provided" ) ; } return self :: parse ( $ serverVars [ 'REQUEST_URI' ] , $ serverVars , $ defaultController , $ defaultAction ) ; }
7774	protected function canSkipRule ( $ ruleToCall , $ value ) { return ( ( is_array ( $ ruleToCall ) && method_exists ( $ ruleToCall [ 0 ] , 'canSkip' ) && $ ruleToCall [ 0 ] -> canSkip ( ) ) || empty ( $ value ) && ! is_array ( $ value ) ) ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
7676	function TbsQuickLoad ( $ NameLst ) { if ( ! is_array ( $ NameLst ) ) $ NameLst = array ( $ NameLst ) ; $ nbr = 0 ; $ TBS = & $ this -> TBS ; foreach ( $ NameLst as $ FileName ) { $ idx = $ this -> FileGetIdx ( $ FileName ) ; if ( ( ! isset ( $ this -> TbsStoreLst [ $ idx ] ) ) && ( ! isset ( $ this -> TbsNoField [ $ idx ] ) ) ) { $ txt = $ this -> FileRead ( $ idx , true ) ; if ( strpos ( $ txt , $ TBS -> _ChrOpen ) !== false ) { $ nbr ++ ; if ( $ nbr == 1 ) { $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ SaveIdx = $ this -> TbsCurrIdx ; $ SaveName = $ TBS -> OtbsCurrFile ; $ this -> TbsSwitchMode ( true ) ; } $ this -> TbsStorePark ( ) ; $ TBS -> Source = $ txt ; unset ( $ txt ) ; $ TBS -> OtbsCurrFile = $ FileName ; $ this -> TbsCurrIdx = $ idx ; if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } else { $ this -> TbsNoField [ $ idx ] = true ; } } } if ( $ nbr > 0 ) { $ this -> TbsSwitchMode ( false ) ; $ this -> TbsStorePark ( ) ; $ this -> TbsStoreLoad ( $ SaveIdx , $ SaveName ) ; } return $ nbr ; }
7182	protected function generateKey ( PaymentInterface $ payment ) { if ( 0 == strlen ( $ payment -> getKey ( ) ) ) { $ this -> keyGenerator -> generate ( $ payment ) ; return true ; } return false ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
3228	function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; }
7858	private function registerPipelineRepository ( ) { $ abstract = 'Cerbero\Workflow\Repositories\PipelineRepositoryInterface' ; $ this -> app -> bind ( $ abstract , function ( $ app ) { return new YamlPipelineRepository ( new SymfonyYamlParser , new \ Illuminate \ Filesystem \ Filesystem , config ( 'workflow.path' ) ) ; } ) ; }
5339	public function setMode ( $ mode ) { if ( ! in_array ( $ mode , $ this -> acceptedModes ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid mode: [%s]' , $ mode ) ) ; } $ this -> mode = $ mode ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
5399	public function setHost ( $ host ) { if ( $ host = $ this -> truncateHost ( $ host ) ) { $ this -> host = $ host ; return true ; } return false ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
6260	public function getControllerNameAndAction ( Request $ request ) { $ controller = $ this -> _registry -> getController ( ) ; $ name = $ controller -> name ; $ action = $ request -> action ; if ( ! empty ( $ request -> params [ 'plugin' ] ) ) { $ name = Inflector :: camelize ( $ request -> params [ 'plugin' ] ) . '.' . $ name ; } return compact ( 'name' , 'action' ) ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
2416	protected function addTableTlFiles ( \ DOMDocument $ xml , \ DOMElement $ tables , Result $ objTheme , ZipWriter $ objArchive ) { $ table = $ xml -> createElement ( 'table' ) ; $ table -> setAttribute ( 'name' , 'tl_files' ) ; $ table = $ tables -> appendChild ( $ table ) ; $ this -> loadDataContainer ( 'tl_files' ) ; $ objDcaExtractor = DcaExtractor :: getInstance ( 'tl_files' ) ; $ arrOrder = $ objDcaExtractor -> getOrderFields ( ) ; $ arrFolders = StringUtil :: deserialize ( $ objTheme -> folders ) ; if ( ! empty ( $ arrFolders ) && \ is_array ( $ arrFolders ) ) { $ objFolders = FilesModel :: findMultipleByUuids ( $ arrFolders ) ; if ( $ objFolders !== null ) { foreach ( $ this -> eliminateNestedPaths ( $ objFolders -> fetchEach ( 'path' ) ) as $ strFolder ) { $ this -> addFolderToArchive ( $ objArchive , $ strFolder , $ xml , $ table , $ arrOrder ) ; } } } }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
4106	public function commitBulk ( ) { if ( $ this -> bulk && $ this -> bulk -> count ( ) ) { $ result = $ this -> bulk -> commit ( ) ; $ this -> bulk = null ; return $ result ; } }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
8318	public function minLength ( $ n ) { $ this -> constraints [ ] = ( function ( Password $ str ) use ( $ n ) { if ( mb_strlen ( $ str ) < $ n ) { return sprintf ( "Minimum password length is %d characters." , $ n ) ; } else { return true ; } } ) ; return $ this ; }
6411	public static function any ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: any ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
12593	public function setOperator ( $ operator ) { $ this -> checkParams ( $ this -> operation , $ operator ) ; $ this -> operator = $ operator ; }
1113	protected function mapTreeRecursive ( array $ tree , $ parentKey = null , & $ affectedKeys = array ( ) ) { foreach ( $ tree as $ attributes ) { $ node = $ this -> firstOrNew ( $ this -> getSearchAttributes ( $ attributes ) ) ; $ data = $ this -> getDataAttributes ( $ attributes ) ; if ( ! is_null ( $ parentKey ) ) $ data [ $ node -> getParentColumnName ( ) ] = $ parentKey ; $ node -> fill ( $ data ) ; $ result = $ node -> save ( ) ; if ( ! $ result ) return false ; $ affectedKeys [ ] = $ node -> getKey ( ) ; if ( array_key_exists ( $ this -> getChildrenKeyName ( ) , $ attributes ) ) { $ children = $ attributes [ $ this -> getChildrenKeyName ( ) ] ; if ( count ( $ children ) > 0 ) { $ result = $ this -> mapTreeRecursive ( $ children , $ node -> getKey ( ) , $ affectedKeys ) ; if ( ! $ result ) return false ; } } } return true ; }
11063	public function getRealEncoding ( $ encoding ) { if ( static :: isEncodingSupported ( $ encoding ) === false ) { throw new \ Exception ( 'Encoding is not supported: "' . $ encoding . '"' ) ; } return static :: supportedEncodings ( ) [ strtolower ( $ encoding ) ] ; }
4558	public function generateUuid ( Uuidentifiable $ entity , bool $ overwrite = false ) { if ( null === $ entity -> getUuid ( ) || $ overwrite ) { $ uuid = Uuid :: uuid4 ( ) -> toString ( ) ; $ entity -> setUuid ( $ uuid ) ; } return $ this ; }
2771	public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
3051	protected function retrieveItemIndex ( ) { $ this -> itemIndex = new QtiTestCompilerIndex ( ) ; try { $ directories = $ this -> getCompilationDirectory ( ) ; $ data = $ directories [ 'private' ] -> read ( taoQtiTest_models_classes_QtiTestService :: TEST_COMPILED_INDEX ) ; if ( $ data ) { $ this -> itemIndex -> unserialize ( $ data ) ; } } catch ( \ Exception $ e ) { \ common_Logger :: d ( 'Ignoring file not found exception for Items Index' ) ; } }
5805	public function increment ( ) { $ this -> counter ++ ; if ( 1 === $ this -> counter ) { $ this -> expiresAt = $ this -> now ( ) + $ this -> expiresIn ; } }
1267	private function createRequest ( $ labelRecoveryRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; $ labelSpecificationNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelRecoveryRequest -> LabelSpecification ) ) { $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelRecoveryRequest -> LabelSpecification -> HTTPUserAgent ) ) ; $ labelImageFormatNode = $ labelSpecificationNode -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ labelImageFormatNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> LabelSpecification -> LabelImageFormat -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> Translate ) ) { $ translateNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ labelRecoveryRequest -> Translate -> LanguageCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ labelRecoveryRequest -> Translate -> DialectCode ) ) ; $ translateNode -> appendChild ( $ xml -> createElement ( 'Code' , $ labelRecoveryRequest -> Translate -> Code ) ) ; } if ( isset ( $ labelRecoveryRequest -> LabelLinkIndicator ) ) { $ labelLinkIndicatorNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; $ labelLinkIndicatorNode -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' ) ) ; } if ( isset ( $ labelRecoveryRequest -> TrackingNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ labelRecoveryRequest -> TrackingNumber ) ) ; } if ( isset ( $ labelRecoveryRequest -> ReferenceNumber ) ) { $ referenceNumberNode = $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumberNode -> appendChild ( $ xml -> createElement ( 'Value' , $ labelRecoveryRequest -> ReferenceNumber -> getValue ( ) ) ) ; } if ( isset ( $ labelRecoveryRequest -> ShipperNumber ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ labelRecoveryRequest -> ShipperNumber ) ) ; } return $ xml -> saveXML ( ) ; }
8367	public static function get ( string $ name ) : array { if ( isset ( self :: $ mappings [ $ name ] ) === false ) { throw new MappingNotFound ( 'there\'s no registered mapping with name "' . $ name . '"' ) ; } return self :: $ mappings [ $ name ] ; }
12229	public function replaceSelf ( SimpleXMLElement $ new ) { $ old = dom_import_simplexml ( $ this ) ; $ new = $ old -> ownerDocument -> importNode ( dom_import_simplexml ( $ new ) , true ) ; $ node = $ old -> parentNode -> replaceChild ( $ new , $ old ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
3902	public function deleteColumn ( ) { $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableColumns ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> dropColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) ) ; } }
8577	public function setItemFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7210	public function getAutoLoginUrl ( array $ autoUrl , array $ redirectUrl = null , string $ expireInterval = '1 day' , bool $ addRememberMeCookie = true ) : string { $ autoUrl [ '?' ] [ 't' ] = $ this -> generateLoginToken ( $ redirectUrl , $ expireInterval , $ addRememberMeCookie ) ; $ url = Router :: url ( $ autoUrl , true ) ; $ urlLength = strlen ( $ url ) ; if ( strlen ( $ url ) > 2080 ) { throw new \ Exception ( 'Generated url "' . $ url . '" is too long' ) ; } return $ url ; }
9602	public function dotProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; $ bComponents = $ b -> components ( ) ; $ product = 0 ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ product += $ component * $ bComponents [ $ i ] ; } return $ product ; }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
6589	public function post ( $ url , $ data = null , $ method = "POST" ) { return $ this -> request ( [ CURLOPT_POST => true , CURLOPT_CUSTOMREQUEST => $ method ? : "POST" , CURLOPT_URL => "$url" , CURLOPT_POSTFIELDS => $ data ? : '' , ] ) ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
7366	protected function checkPrivacyIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ parent = $ item -> getParent ( ) ; if ( $ item -> isPrivate ( ) ) { if ( null === $ parent ) { $ this -> context -> buildViolation ( $ constraint -> root_item_cant_be_private ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } elseif ( $ item -> getTaxGroup ( ) !== $ parent -> getTaxGroup ( ) ) { $ this -> context -> buildViolation ( $ constraint -> tax_group_integrity ) -> atPath ( 'taxGroup' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } } elseif ( null !== $ parent && $ parent -> isPrivate ( ) ) { $ this -> context -> buildViolation ( $ constraint -> privacy_integrity ) -> atPath ( 'private' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
3241	protected function createSeeder ( $ data ) { $ seederFile = base_path ( '/database/seeds' ) . '/LaravelShopSeeder.php' ; $ output = $ this -> laravel -> view -> make ( 'laravel-shop::generators.seeder' ) -> with ( $ data ) -> render ( ) ; if ( ! file_exists ( $ seederFile ) && $ fs = fopen ( $ seederFile , 'x' ) ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; return true ; } return false ; }
201	private function valueExists ( $ targetClass , $ query , $ value ) { $ db = $ targetClass :: getDb ( ) ; $ exists = false ; if ( $ this -> forceMasterDb && method_exists ( $ db , 'useMaster' ) ) { $ db -> useMaster ( function ( $ db ) use ( $ query , $ value , & $ exists ) { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } ) ; } else { $ exists = $ this -> queryValueExists ( $ query , $ value ) ; } return $ exists ; }
6240	public static function getMimeFor ( string $ extension ) : ? string { $ extensions = static :: getExtensions ( ) ; if ( isset ( $ extensions [ $ extension ] ) ) { return $ extensions [ $ extension ] ; } return null ; }
10627	public static function cpuCoreInfo ( ) { $ cores = array ( ) ; if ( false !== ( $ data = @ file ( '/proc/stat' ) ) ) { foreach ( $ data as $ line ) { if ( preg_match ( '/^cpu[0-9]/' , $ line ) ) { $ info = explode ( ' ' , $ line ) ; $ cores [ ] = array ( 'user' => $ info [ 1 ] , 'nice' => $ info [ 2 ] , 'sys' => $ info [ 3 ] , 'idle' => $ info [ 4 ] , 'iowait' => $ info [ 5 ] , 'irq' => $ info [ 6 ] , 'softirq' => $ info [ 7 ] ) ; } } } return $ cores ; }
7970	public function deleteBlacklist ( $ domain , $ number ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ number ) throw new BadMethodCallException ( 'Parameter $number is missing.' ) ; try { $ r = $ this -> delete ( 'sms/' . $ domain . '/blacklists/' . $ number ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
4649	protected function getServices ( $ config ) { $ services = array ( ) ; $ travisServices = isset ( $ config [ 'services' ] ) && is_array ( $ config [ 'services' ] ) ? $ config [ 'services' ] : array ( ) ; foreach ( $ travisServices as $ service ) { if ( isset ( $ this -> servicesMapping [ $ service ] ) ) { $ services [ ] = new Service ( $ service , $ this -> servicesMapping [ $ service ] [ 'repository' ] , $ this -> servicesMapping [ $ service ] [ 'tag' ] , $ this -> servicesMapping [ $ service ] [ 'config' ] ) ; } } return $ services ; }
3842	private function parsePanelSort ( PanelRowInterface $ row ) { if ( ! $ row -> hasElement ( 'sort' ) ) { $ element = new DefaultSortElementInformation ( ) ; $ row -> addElement ( $ element ) ; } }
4196	private function getAbstractionDetails ( Event $ abs ) { $ reflector = $ abs [ 'reflector' ] ; $ abs [ 'phpDoc' ] = $ this -> phpDoc -> getParsed ( $ reflector ) ; $ traversed = false ; if ( $ abs [ 'debugMethod' ] === 'table' && \ count ( $ abs [ 'hist' ] ) < 2 ) { $ obj = $ abs -> getSubject ( ) ; if ( $ obj instanceof \ Traversable && ! $ abs [ 'traverseValues' ] ) { $ traversed = true ; $ abs [ 'hist' ] [ ] = $ obj ; foreach ( $ obj as $ k => $ v ) { $ abs [ 'traverseValues' ] [ $ k ] = $ this -> abstracter -> needsAbstraction ( $ v ) ? $ this -> abstracter -> getAbstraction ( $ v , $ abs [ 'debugMethod' ] , $ abs [ 'hist' ] ) : $ v ; } } } if ( ! $ traversed ) { $ this -> addConstants ( $ abs ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ abs [ 'extends' ] [ ] = $ reflector -> getName ( ) ; } $ this -> addProperties ( $ abs ) ; $ this -> addMethods ( $ abs ) ; } }
7637	public function getBlobProperties ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; return $ this -> getBlobInstance ( $ containerName , $ blobName , $ snapshotId , $ leaseId ) ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
1358	public static function create ( $ mediaType , int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , new EncoderOptions ( $ options , $ urlPrefix , $ depth ) ) ; }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
1370	protected function bindExceptionParser ( ) { $ this -> app -> singleton ( ExceptionParserInterface :: class , ExceptionParser :: class ) ; $ this -> app -> alias ( ExceptionParserInterface :: class , 'json-api.exceptions' ) ; }
6500	public function afterStep ( Scope \ StepScope $ scope ) { if ( ! empty ( $ this -> mainWindow ) && count ( $ this -> getWindowNames ( ) ) == 1 ) { $ this -> iSwitchToWindow ( ) ; } if ( self :: hasTag ( 'javascript' ) && self :: isStepImpliesJsEvent ( $ scope ) ) { $ this -> waitAjaxAndAnimations ( ) ; } }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
101	public function setPsr4 ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr4 = ( array ) $ paths ; } else { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
1765	public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; }
10177	public function cloneCellCollection ( Worksheet $ parent ) { $ this -> storeCurrentCell ( ) ; $ newCollection = clone $ this ; $ newCollection -> parent = $ parent ; if ( ( $ newCollection -> currentCell !== null ) && ( is_object ( $ newCollection -> currentCell ) ) ) { $ newCollection -> currentCell -> attach ( $ this ) ; } $ oldKeys = $ newCollection -> getAllCacheKeys ( ) ; $ oldValues = $ newCollection -> cache -> getMultiple ( $ oldKeys ) ; $ newValues = [ ] ; $ oldCachePrefix = $ newCollection -> cachePrefix ; $ newCollection -> cachePrefix = $ newCollection -> getUniqueID ( ) ; foreach ( $ oldValues as $ oldKey => $ value ) { $ newValues [ str_replace ( $ oldCachePrefix , $ newCollection -> cachePrefix , $ oldKey ) ] = clone $ value ; } $ stored = $ newCollection -> cache -> setMultiple ( $ newValues ) ; if ( ! $ stored ) { $ newCollection -> __destruct ( ) ; throw new PhpSpreadsheetException ( 'Failed to copy cells in cache' ) ; } return $ newCollection ; }
2238	private function handlePrependLocale ( array $ extensionConfigs , ContainerBuilder $ container ) : array { if ( ! $ container -> hasParameter ( 'prepend_locale' ) ) { return $ extensionConfigs ; } foreach ( $ extensionConfigs as $ extensionConfig ) { if ( isset ( $ extensionConfig [ 'prepend_locale' ] ) ) { return $ extensionConfigs ; } } @ trigger_error ( 'Defining the "prepend_locale" parameter in the parameters.yml file has been deprecated and will no longer work in Contao 5.0. Define the "contao.prepend_locale" parameter in the config.yml file instead.' , E_USER_DEPRECATED ) ; $ extensionConfigs [ ] = [ 'prepend_locale' => '%prepend_locale%' , ] ; return $ extensionConfigs ; }
10068	protected function registerDecorators ( ) { $ decorators = array ( 'AutoId' ) ; foreach ( $ decorators as $ decoratorClass ) { $ decoratorClass = '\\Sirius\FormRenderer\\Decorator\\' . $ decoratorClass ; $ this -> addDecorator ( new $ decoratorClass ) ; } }
4278	public function stream_read ( $ count ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ buffer = \ fread ( $ this -> handle , $ count ) ; $ bufferLen = \ strlen ( $ buffer ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS , 2 ) ; $ isRequire = ! \ in_array ( $ backtrace [ 1 ] [ 'function' ] , array ( 'file_get_contents' ) ) ; if ( ! $ this -> declaredTicks && $ isRequire ) { foreach ( self :: $ pathsExclude as $ excludePath ) { if ( \ strpos ( $ this -> filepath , $ excludePath . DIRECTORY_SEPARATOR ) === 0 ) { $ this -> declaredTicks = true ; } } } if ( ! $ this -> declaredTicks && $ isRequire ) { $ buffer = \ preg_replace ( '/^(<\?php\s*)$/m' , '$0 declare(ticks=1);' , $ buffer , 1 ) ; $ this -> declaredTicks = true ; self :: $ filesModified [ ] = $ this -> filepath ; } $ buffer = $ this -> bufferPrepend . $ buffer ; $ bufferLenAfter = \ strlen ( $ buffer ) ; $ diff = $ bufferLenAfter - $ bufferLen ; $ this -> bufferPrepend = '' ; if ( $ diff ) { $ this -> bufferPrepend = \ substr ( $ buffer , $ count ) ; $ buffer = \ substr ( $ buffer , 0 , $ count ) ; } self :: register ( ) ; return $ buffer ; }
11478	public function addTemplateSlots ( $ templateName , $ username ) { if ( ! array_key_exists ( $ templateName , $ this -> templateBlocks ) ) { return null ; } $ blocks = $ this -> templateBlocks [ $ templateName ] ; $ this -> addSlots ( $ blocks , $ username ) ; }
5766	private function clear ( ) { if ( ! isset ( $ this -> phpMailer ) ) { return ; } $ this -> phpMailer -> clearAddresses ( ) ; $ this -> phpMailer -> clearCCs ( ) ; $ this -> phpMailer -> clearBCCs ( ) ; $ this -> phpMailer -> clearReplyTos ( ) ; $ this -> phpMailer -> clearAllRecipients ( ) ; $ this -> phpMailer -> clearAttachments ( ) ; $ this -> phpMailer -> clearCustomHeaders ( ) ; }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
1444	protected function getStubFor ( $ implementationType ) { return sprintf ( '%s/%s/%s.stub' , $ this -> stubsDirectory , $ implementationType , Str :: dasherize ( $ this -> type ) ) ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
3046	protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { $ param = $ this -> getRawRequestParameter ( $ toolStateParameter ) ; if ( $ param ) { $ toolStates = json_decode ( $ param , true ) ; if ( count ( $ toolStates ) > 0 ) { array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_encode ( $ toolState ) ; } ) ; $ this -> getRunnerService ( ) -> setToolsStates ( $ this -> getServiceContext ( ) , $ toolStates ) ; return true ; } } } return false ; }
10185	static function json_decode ( $ jsonString , $ deserializationType = null ) { if ( is_array ( $ deserializationType ) && count ( $ deserializationType ) > 1 ) { $ type = $ deserializationType [ 0 ] ; $ innerType = $ deserializationType [ 1 ] ; } else { $ type = $ deserializationType ; $ innerType = null ; } return self :: fromArray ( json_decode ( $ jsonString ) , $ type , $ innerType ) ; }
12339	private function getColoredMsg ( string $ msg , ? string $ fontColor , ? string $ bgColor ) : string { $ res = '' ; if ( ! is_null ( $ fontColor ) ) { $ res .= "\033[{$fontColor}m" ; } if ( ! is_null ( $ bgColor ) ) { $ res .= "\033[{$bgColor}m" ; } if ( ! is_null ( $ fontColor ) || ! is_null ( $ bgColor ) ) { return "{$res}{$msg}\033[0m" ; } return $ msg ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
6025	public function addMetaData ( $ item ) { if ( ! ( $ item instanceof MetaData ) ) { if ( is_array ( $ item ) ) { try { $ item = new MetaData ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate MetaData. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "MetaData"!' , E_USER_WARNING ) ; } } $ this -> metadata [ ] = $ item ; return $ this ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
9792	public function setDataType ( $ pDataType ) { if ( $ pDataType == DataType :: TYPE_STRING2 ) { $ pDataType = DataType :: TYPE_STRING ; } $ this -> dataType = $ pDataType ; return $ this -> updateInCollection ( ) ; }
3367	protected function prepareEvent ( EventInterface $ event ) { foreach ( [ 'elementSpec' , 'inputSpec' ] as $ type ) { if ( ! $ event -> getParam ( $ type ) ) { $ event -> setParam ( $ type , new ArrayObject ( ) ) ; } } $ elementSpec = $ event -> getParam ( 'elementSpec' ) ; $ inputSpec = $ event -> getParam ( 'inputSpec' ) ; if ( ! isset ( $ elementSpec [ 'spec' ] ) ) { $ elementSpec [ 'spec' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'filters' ] ) ) { $ inputSpec [ 'filters' ] = [ ] ; } if ( ! isset ( $ inputSpec [ 'validators' ] ) ) { $ inputSpec [ 'validators' ] = [ ] ; } }
5537	public function setFrame ( $ path , $ page ) { $ name = array_shift ( $ path ) ; if ( isset ( $ this -> names [ $ name ] ) ) { $ index = $ this -> names [ $ name ] ; } else { $ index = $ name - 1 ; } if ( count ( $ path ) === 0 ) { $ this -> frames [ $ index ] = $ page ; return ; } $ this -> frames [ $ index ] -> setFrame ( $ path , $ page ) ; }
2775	public function streamOutput ( bool $ streamOutput = true ) : void { if ( $ streamOutput && ! isset ( $ this -> gitOutputListener ) ) { $ this -> gitOutputListener = new GitOutputStreamListener ( ) ; $ this -> addOutputListener ( $ this -> gitOutputListener ) ; } if ( ! $ streamOutput && isset ( $ this -> gitOutputListener ) ) { $ this -> removeOutputListener ( $ this -> gitOutputListener ) ; unset ( $ this -> gitOutputListener ) ; } }
11362	public static function mailTagger ( $ mail = '' , $ name = null ) { return ( ( ! is_int ( $ name ) ? "\"" . $ name . "\" <" : '' ) . $ mail . ( ! is_int ( $ name ) ? ">" : '' ) ) ; }
8598	public function createSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_CreateSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_CreateSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/CreateSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_CreateSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3714	protected function allowAttributeTypes ( $ initialType1toN = null ) { if ( is_array ( $ initialType1toN ) ) { $ this -> attributeTypes = $ initialType1toN ; } else { $ this -> attributeTypes = func_get_args ( ) ; } return $ this ; }
9915	public function render ( $ action = null , $ layout = null ) { $ this -> viewPath .= DS . 'Spreadsheet' ; $ content = parent :: render ( $ action , false ) ; if ( $ this -> response -> type ( ) == 'text/html' ) { return $ content ; } ob_start ( ) ; $ writer = IOFactory :: createWriter ( $ this -> Spreadsheet , CAKE_SPREADSHEET_PHPSPREADSHEET_WRITER ) ; $ writer -> setPreCalculateFormulas ( false ) ; $ writer -> save ( 'php://output' ) ; $ content = ob_get_clean ( ) ; $ this -> Blocks -> set ( 'content' , $ content ) ; $ fileName = $ this -> getFileName ( ) ; $ fileName .= '.' . CAKE_SPREADSHEET_FILE_EXTENSION ; $ this -> response -> download ( $ fileName ) ; return $ this -> Blocks -> get ( 'content' ) ; }
3936	private function setWidgetType ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getWidgetType ( ) || ! isset ( $ propInfo [ 'inputType' ] ) ) { return ; } $ property -> setWidgetType ( $ propInfo [ 'inputType' ] ) ; }
10927	private function updateWidth ( $ columnNumber , $ width ) { if ( $ width > $ this -> getWidth ( $ columnNumber ) ) { $ this -> widths [ $ columnNumber ] = $ width ; } }
6944	protected function registerClassInstanceSingleton ( $ singletonName , $ classNameOrInstance = null ) { if ( empty ( $ classNameOrInstance ) ) { $ classNameOrInstance = $ singletonName ; } $ this -> app -> singleton ( $ singletonName , function ( ) use ( $ classNameOrInstance ) { return is_string ( $ classNameOrInstance ) ? $ classNameOrInstance :: getInstance ( ) : $ classNameOrInstance ; } ) ; }
1480	private function flip ( array $ resources ) { $ all = [ ] ; foreach ( $ resources as $ resourceType => $ types ) { foreach ( ( array ) $ types as $ type ) { $ all [ $ type ] = $ resourceType ; } } return $ all ; }
510	public function actionList ( ) { foreach ( $ this -> getCommandDescriptions ( ) as $ command => $ description ) { $ result = Yii :: $ app -> createController ( $ command ) ; if ( $ result === false || ! ( $ result [ 0 ] instanceof Controller ) ) { continue ; } list ( $ controller , $ actionID ) = $ result ; $ actions = $ this -> getActions ( $ controller ) ; if ( ! empty ( $ actions ) ) { $ prefix = $ controller -> getUniqueId ( ) ; $ this -> stdout ( "$prefix\n" ) ; foreach ( $ actions as $ action ) { $ this -> stdout ( "$prefix/$action\n" ) ; } } } }
11353	private function compress ( $ dwnlSnap , $ pv , $ calcId ) { $ in = new \ Praxigento \ Core \ Data ( ) ; $ in -> set ( PPhase1 :: IN_DWNL_PLAIN , $ dwnlSnap ) ; $ in -> set ( PPhase1 :: IN_PV , $ pv ) ; $ in -> set ( PPhase1 :: IN_CALC_ID , $ calcId ) ; $ in -> set ( PPhase1 :: IN_KEY_CALC_ID , EBonDwnl :: A_CALC_REF ) ; $ in -> set ( PPhase1 :: IN_KEY_CUST_ID , QBSnap :: A_CUST_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_PARENT_ID , QBSnap :: A_PARENT_ID ) ; $ in -> set ( PPhase1 :: IN_KEY_DEPTH , QBSnap :: A_DEPTH ) ; $ in -> set ( PPhase1 :: IN_KEY_PATH , QBSnap :: A_PATH ) ; $ in -> set ( PPhase1 :: IN_KEY_PV , EBonDwnl :: A_PV ) ; $ out = $ this -> procPhase1 -> exec ( $ in ) ; $ updates = $ out -> get ( PPhase1 :: OUT_COMPRESSED ) ; $ pvTransfers = $ out -> get ( PPhase1 :: OUT_PV_TRANSFERS ) ; $ result = [ $ updates , $ pvTransfers ] ; return $ result ; }
1899	private function createConfig ( $ size , ImageInterface $ image ) : array { if ( ! \ is_array ( $ size ) ) { $ size = [ 0 , 0 , $ size ] ; } $ config = new ResizeConfiguration ( ) ; if ( isset ( $ size [ 2 ] ) && is_numeric ( $ size [ 2 ] ) ) { $ imageModel = $ this -> framework -> getAdapter ( ImageSizeModel :: class ) ; $ imageSize = $ imageModel -> findByPk ( $ size [ 2 ] ) ; if ( null !== $ imageSize ) { $ config -> setWidth ( $ imageSize -> width ) -> setHeight ( $ imageSize -> height ) -> setMode ( $ imageSize -> resizeMode ) -> setZoomLevel ( $ imageSize -> zoom ) ; } return [ $ config , null ] ; } if ( ! empty ( $ size [ 0 ] ) ) { $ config -> setWidth ( $ size [ 0 ] ) ; } if ( ! empty ( $ size [ 1 ] ) ) { $ config -> setHeight ( $ size [ 1 ] ) ; } if ( ! isset ( $ size [ 2 ] ) || 1 !== substr_count ( $ size [ 2 ] , '_' ) ) { if ( ! empty ( $ size [ 2 ] ) ) { $ config -> setMode ( $ size [ 2 ] ) ; } return [ $ config , null ] ; } $ config -> setMode ( ResizeConfigurationInterface :: MODE_CROP ) ; return [ $ config , $ this -> getImportantPartFromLegacyMode ( $ image , $ size [ 2 ] ) ] ; }
10126	private function writeGuts ( ) { $ record = 0x0080 ; $ length = 0x0008 ; $ dxRwGut = 0x0000 ; $ dxColGut = 0x0000 ; $ maxRowOutlineLevel = 0 ; foreach ( $ this -> phpSheet -> getRowDimensions ( ) as $ rowDimension ) { $ maxRowOutlineLevel = max ( $ maxRowOutlineLevel , $ rowDimension -> getOutlineLevel ( ) ) ; } $ col_level = 0 ; $ colcount = count ( $ this -> columnInfo ) ; for ( $ i = 0 ; $ i < $ colcount ; ++ $ i ) { $ col_level = max ( $ this -> columnInfo [ $ i ] [ 5 ] , $ col_level ) ; } $ col_level = max ( 0 , min ( $ col_level , 7 ) ) ; if ( $ maxRowOutlineLevel ) { ++ $ maxRowOutlineLevel ; } if ( $ col_level ) { ++ $ col_level ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvv' , $ dxRwGut , $ dxColGut , $ maxRowOutlineLevel , $ col_level ) ; $ this -> append ( $ header . $ data ) ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
1182	protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; }
11949	protected function createBaseString ( Request $ request , array $ params ) { $ request = clone $ request ; $ uri = $ request -> getUri ( ) ; $ queryString = '' ; if ( $ questionMark = strpos ( $ uri , '?' ) ) { $ uri = substr ( $ uri , 0 , $ questionMark ) ; $ request -> setUri ( $ uri ) ; } $ query = http_build_query ( $ params , '' , '&' , PHP_QUERY_RFC3986 ) ; return strtoupper ( $ request -> getMethod ( ) ) . '&' . rawurlencode ( $ uri ) . '&' . rawurlencode ( $ query ) ; }
9344	public function addCol ( $ arr_col ) { if ( isset ( $ this -> arr [ 0 ] ) && ( count ( $ this -> arr [ 0 ] ) == $ this -> size -> cols ) ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another column! Max number of columns is %d' , $ this -> size -> cols ) ) ; } if ( count ( $ arr_col ) != $ this -> size -> rows ) { throw new \ InvalidArgumentException ( 'New column must have same amout of rows than previous columns.' ) ; } $ arr_col = array_values ( $ arr_col ) ; foreach ( $ arr_col as $ k => $ v ) { $ this -> arr [ $ k ] [ ] = $ arr_col [ $ k ] ; } return $ this ; }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1770	public function getErrorsAsString ( $ strSeparator = null ) { if ( $ strSeparator === null ) { $ strSeparator = '<br' . $ this -> strTagEnding . "\n" ; } return $ this -> hasErrors ( ) ? implode ( $ strSeparator , $ this -> arrErrors ) : '' ; }
5983	protected function withOAuth2MiddleWare ( HandlerStack $ stack ) { if ( ! ( $ this -> oauth2Middleware instanceof OAuthMiddleware ) ) { $ oauthClient = new Client ( [ 'base_uri' => $ this -> basepath , 'verify' => $ this -> verifyCertificates , 'headers' => [ 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , ] ) ; $ config = [ PasswordCredentials :: CONFIG_USERNAME => $ this -> credentials -> getUsername ( ) , PasswordCredentials :: CONFIG_PASSWORD => $ this -> credentials -> getPassword ( ) , PasswordCredentials :: CONFIG_CLIENT_ID => $ this -> credentials -> getClientId ( ) , PasswordCredentials :: CONFIG_TOKEN_URL => 'oauth2/token' , ] ; $ this -> oauth2Middleware = new OAuthMiddleware ( $ oauthClient , new PasswordCredentials ( $ oauthClient , $ config ) , new RefreshToken ( $ oauthClient , $ config ) ) ; $ tokens = $ this -> getTokens ( ) ; if ( ! empty ( $ tokens [ 'accessTokens' ] ) ) { $ this -> oauth2Middleware -> setAccessToken ( $ tokens [ 'accessTokens' ] ) ; } if ( ! empty ( $ tokens [ 'refreshTokens' ] ) ) { $ this -> oauth2Middleware -> setRefreshToken ( $ tokens [ 'refreshTokens' ] ) ; } } $ stack -> push ( $ this -> oauth2Middleware -> onBefore ( ) ) ; $ stack -> push ( $ this -> oauth2Middleware -> onFailure ( 3 ) ) ; return $ stack ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
7528	static function minify_javascript ( & $ root , $ indent_string = ' ' , $ wrap_comment = true , $ recursive = true ) { include_once ( 'third party/jsminplus.php' ) ; $ errors = array ( ) ; foreach ( $ root -> select ( 'script:not-empty > "~text~"' , false , $ recursive , true ) as $ c ) { try { $ text = $ c -> text ; while ( $ text ) { $ text = trim ( $ text ) ; if ( substr ( $ text , 0 , 4 ) === '<!--' ) { $ text = substr ( $ text , 5 ) ; continue ; } elseif ( strtolower ( substr ( $ text , 0 , 9 ) ) === '<![cdata[' ) { $ text = substr ( $ text , 10 ) ; continue ; } if ( ( $ end = substr ( $ text , - 3 ) ) && ( ( $ end === ' ) || ( $ end === ']]>' ) ) ) { $ text = substr ( $ text , 0 , - 3 ) ; continue ; } break ; } if ( trim ( $ text ) ) { $ text = \ JSMinPlus :: minify ( $ text ) ; if ( $ wrap_comment ) { $ text = "<!--\n" . $ text . "\n// ; } if ( $ indent_string && ( $ wrap_comment || ( strpos ( $ text , "\n" ) !== false ) ) ) { $ text = indent_text ( "\n" . $ text , $ c -> indent ( ) , $ indent_string ) ; } } $ c -> text = $ text ; } catch ( \ Exception $ e ) { $ errors [ ] = array ( $ e , $ c -> parent -> dumpLocation ( ) ) ; } } return ( ( $ errors ) ? $ errors : true ) ; }
483	public function createIndex ( $ name , $ table , $ columns , $ unique = false ) { $ time = $ this -> beginCommand ( 'create' . ( $ unique ? ' unique' : '' ) . " index $name on $table (" . implode ( ',' , ( array ) $ columns ) . ')' ) ; $ this -> db -> createCommand ( ) -> createIndex ( $ name , $ table , $ columns , $ unique ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
1542	protected function query ( $ query ) { return new CursorBuilder ( $ query , $ this -> column , $ this -> identifier , $ this -> descending ) ; }
7343	protected function initializeStock ( ) { $ this -> stockMode = StockSubjectModes :: MODE_AUTO ; $ this -> stockState = StockSubjectStates :: STATE_OUT_OF_STOCK ; $ this -> stockFloor = 0 ; $ this -> inStock = 0 ; $ this -> availableStock = 0 ; $ this -> virtualStock = 0 ; $ this -> replenishmentTime = 2 ; $ this -> minimumOrderQuantity = 1 ; $ this -> quoteOnly = false ; $ this -> endOfLife = false ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
3697	public function checkPurge ( AbstractModelAwareEvent $ event ) { $ table = $ event -> getModel ( ) -> getProviderName ( ) ; if ( ( $ table == 'tl_metamodel' ) || ( $ table == 'tl_metamodel_dca' ) || ( $ table == 'tl_metamodel_dca_sortgroup' ) || ( $ table == 'tl_metamodel_dcasetting' ) || ( $ table == 'tl_metamodel_dcasetting_condition' ) || ( $ table == 'tl_metamodel_attribute' ) || ( $ table == 'tl_metamodel_filter' ) || ( $ table == 'tl_metamodel_filtersetting' ) || ( $ table == 'tl_metamodel_rendersettings' ) || ( $ table == 'tl_metamodel_rendersetting' ) || ( $ table == 'tl_metamodel_dca_combine' ) ) { $ this -> purger -> purge ( ) ; } }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
1774	public function addAttributes ( $ arrAttributes ) { if ( ! \ is_array ( $ arrAttributes ) ) { return ; } foreach ( $ arrAttributes as $ k => $ v ) { $ this -> $ k = $ v ; } }
8616	public function setId ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Id' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2094	private function isScope ( string $ scope ) : bool { if ( null === $ this -> container || null === ( $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ) ) { return false ; } $ matcher = $ this -> container -> get ( 'contao.routing.scope_matcher' ) ; if ( ContaoCoreBundle :: SCOPE_BACKEND === $ scope ) { return $ matcher -> isBackendRequest ( $ request ) ; } if ( ContaoCoreBundle :: SCOPE_FRONTEND === $ scope ) { return $ matcher -> isFrontendRequest ( $ request ) ; } return false ; }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
7595	protected function renderLabel ( ElementInterface $ oElement ) { if ( ( $ sLabel = $ oElement -> getLabel ( ) ) && ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabel = $ oTranslator -> translate ( $ sLabel , $ this -> getTranslatorTextDomain ( ) ) ; } return $ sLabel ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
2870	public function getExtensionStatus ( ) { $ status = array ( ) ; $ extensions = $ this -> getExtensionRequirements ( ) ; foreach ( $ extensions as $ extension ) { $ status [ $ extension ] = extension_loaded ( $ extension ) ; } return $ status ; }
11142	public function getAttributes ( $ props ) { $ attr = '' ; if ( isset ( $ props [ 'primaryKey' ] ) ) { $ attr .= 'NOT NULL AUTO_INCREMENT ' ; } if ( isset ( $ props [ 'defaultValue' ] ) ) { $ attr .= "DEFAULT '" . $ props [ 'defaultValue' ] . "'" ; } return $ attr ; }
3972	public function decodeAttributeValue ( DecodePropertyValueForWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ value = $ event -> getValue ( ) ; if ( ! ( $ metaModel && $ value ) ) { return ; } $ attribute = $ metaModel -> getAttributeById ( $ value ) ; if ( $ attribute ) { $ event -> setValue ( $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ) ; } }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
8629	public function setParticipation ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Participation' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2637	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; $ this -> api -> upsertDictionaryItem ( $ dictionaryId , $ key , $ value ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5544	public function getRaw ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRaw ( ) ; } $ raw = '' ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ raw .= $ this -> frames [ $ i ] -> getRaw ( ) ; } return $ raw ; }
4525	protected function createZoneMemberCountryFromDefinition ( array $ definition ) { $ zoneMember = new ZoneMemberCountry ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; $ this -> countryCode = $ definition [ 'country_code' ] ; if ( isset ( $ definition [ 'administrative_area' ] ) ) { $ this -> administrativeArea = $ definition [ 'administrative_area' ] ; } if ( isset ( $ definition [ 'locality' ] ) ) { $ this -> locality = $ definition [ 'locality' ] ; } if ( isset ( $ definition [ 'dependent_locality' ] ) ) { $ this -> dependentLocality = $ definition [ 'dependent_locality' ] ; } if ( isset ( $ definition [ 'included_postal_codes' ] ) ) { $ this -> includedPostalCodes = $ definition [ 'included_postal_codes' ] ; } if ( isset ( $ definition [ 'excluded_postal_codes' ] ) ) { $ this -> excludedPostalCodes = $ definition [ 'excluded_postal_codes' ] ; } } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberCountry' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
4211	public static function getConstants ( $ phpVer = null ) { $ phpVer = $ phpVer ? : PHP_VERSION ; $ phpVer = \ preg_match ( '/^\d+\.\d+$/' , $ phpVer ) ? $ phpVer . '.0' : $ phpVer ; $ constants = array ( 'E_ERROR' => 1 , 'E_WARNING' => 2 , 'E_PARSE' => 4 , 'E_NOTICE' => 8 , 'E_CORE_ERROR' => 16 , 'E_CORE_WARNING' => 32 , 'E_COMPILE_ERROR' => 64 , 'E_COMPILE_WARNING' => 128 , 'E_USER_ERROR' => 256 , 'E_USER_WARNING' => 512 , 'E_USER_NOTICE' => 1024 , 'E_STRICT' => \ version_compare ( $ phpVer , '5.0.0' , '>=' ) ? 2048 : null , 'E_RECOVERABLE_ERROR' => \ version_compare ( $ phpVer , '5.2.0' , '>=' ) ? 4096 : null , 'E_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 8192 : null , 'E_USER_DEPRECATED' => \ version_compare ( $ phpVer , '5.3.0' , '>=' ) ? 16384 : null , 'E_ALL' => null , ) ; $ constants = \ array_filter ( $ constants ) ; $ constants [ 'E_ALL' ] = \ array_sum ( $ constants ) ; if ( isset ( $ constants [ 'E_STRICT' ] ) && \ version_compare ( $ phpVer , '5.4.0' , '<' ) ) { $ constants [ 'E_ALL' ] -= $ constants [ 'E_STRICT' ] ; } return $ constants ; }
2156	protected function validator ( $ varInput ) { if ( $ varInput == '*****' ) { $ this -> blnSubmitInput = false ; return true ; } return parent :: validator ( $ varInput ) ; }
9332	public function requireField ( ) { $ charset = MySQLDatabase :: config ( ) -> charset ; $ collation = MySQLDatabase :: config ( ) -> collation ; $ spec = [ 'type' => 'varchar' , 'parts' => [ 'datatype' => 'varchar' , 'precision' => 64 , 'collate' => $ collation , 'character set' => $ charset , 'arrayValue' => $ this -> arrayValue ] ] ; DB :: require_field ( $ this -> tableName , $ this -> name , $ spec ) ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
3844	protected static function upgradeJumpTo ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_content' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_content' , true ) ) { TableManipulation :: createColumn ( 'tl_content' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_content' , true ) ) { $ objDB -> execute ( 'UPDATE tl_content SET metamodel_jumpTo=jumpTo;' ) ; } } if ( $ objDB -> tableExists ( 'tl_module' , null , true ) && ! $ objDB -> fieldExists ( 'metamodel_jumpTo' , 'tl_module' , true ) ) { TableManipulation :: createColumn ( 'tl_module' , 'metamodel_jumpTo' , 'int(10) unsigned NOT NULL default \'0\'' ) ; if ( $ objDB -> fieldExists ( 'jumpTo' , 'tl_module' , true ) ) { $ objDB -> execute ( 'UPDATE tl_module SET metamodel_jumpTo=jumpTo;' ) ; } } }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
9428	public function updateCMSFields ( FieldList $ fields ) { $ fields -> insertAfter ( Tab :: create ( 'Icon' , $ this -> owner -> fieldLabel ( 'Icon' ) ) , 'Main' ) ; $ fields -> addFieldsToTab ( 'Root.Icon' , [ FontIconField :: create ( 'FontIcon' , $ this -> owner -> fieldLabel ( 'FontIcon' ) ) , ColorField :: create ( 'FontIconColor' , $ this -> owner -> fieldLabel ( 'FontIconColor' ) ) ] ) ; }
1897	private function isExistingOptionalFile ( SplFileInfo $ file , string $ webDir ) : bool { $ path = $ file -> getRelativePathname ( ) ; return 'robots.txt' === $ path && $ this -> fs -> exists ( $ webDir . '/' . $ path ) ; }
9171	public function getControllerPluginConfig ( ) { return [ 'aliases' => [ 'email' => Controller \ Plugin \ Email :: class , 'mutex' => Controller \ Plugin \ Mutex :: class , 'referer' => Controller \ Plugin \ Referer :: class , 'settings' => Controller \ Plugin \ Settings :: class , 'thumbnail' => Controller \ Plugin \ Thumbnail :: class , 'zettaUrl' => Controller \ Plugin \ Url :: class , ] , 'factories' => [ Controller \ Plugin \ Email :: class => Controller \ Plugin \ Factory \ EmailFactory :: class , Controller \ Plugin \ Mutex :: class => Controller \ Plugin \ Factory \ MutexFactory :: class , Controller \ Plugin \ Referer :: class => InvokableFactory :: class , Controller \ Plugin \ Settings :: class => Factory \ WithSettingsFactory :: class , Controller \ Plugin \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , Controller \ Plugin \ Url :: class => Factory \ WithUrlConfigFactory :: class , ] , ] ; }
10975	public function populateLocationOwner ( ) { $ location = $ this -> location ; if ( $ location !== null ) { $ this -> country_id = $ location -> country_id ; $ this -> region_id = $ location -> region_id ; $ this -> city_id = $ location -> city_id ; $ this -> state_id = $ location -> state_id ; $ this -> address = $ location -> address ; $ this -> postal_code = $ location -> postal_code ; $ this -> latitude = $ location -> latitude ; $ this -> longitude = $ location -> longitude ; } }
1571	public function getProcessId ( ) : ? string { if ( is_null ( $ this -> processId ) ) { return $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; } return $ this -> processId ? : null ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
11152	public function setParameters ( array $ request ) { foreach ( $ this -> getRequiredParameters ( ) as $ param ) { if ( isset ( $ request [ $ param ] ) ) { $ dynamicMethod = "set" . ucfirst ( $ param ) ; if ( method_exists ( $ this , $ dynamicMethod ) ) { $ this -> $ dynamicMethod ( $ request [ $ param ] ) ; } else { throw new ExtDirectException ( "Method for required parameter '{$param}' not implemented" ) ; } } else { throw new ExtDirectException ( "Required parameter '{$param}' is missing" ) ; } } }
3150	public function comment ( RunnerServiceContext $ context , $ comment ) { $ testSession = $ context -> getTestSession ( ) ; $ item = $ testSession -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ occurrence = $ testSession -> getCurrentAssessmentItemRefOccurence ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; $ transmissionId = "${sessionId}.${item}.${occurrence}" ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ transmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ resultStore ) ; $ itemUri = TestRunnerUtils :: getCurrentItemUri ( $ testSession ) ; $ testUri = $ testSession -> getTest ( ) -> getUri ( ) ; $ variable = new ResponseVariable ( 'comment' , Cardinality :: SINGLE , BaseType :: STRING , new QtismString ( $ comment ) ) ; $ transmitter -> transmitItemVariable ( $ variable , $ transmissionId , $ itemUri , $ testUri ) ; return true ; }
11265	public function model ( $ pathname ) { $ fullPath = $ this -> config [ 'pathToModels' ] . $ this -> getPath ( $ pathname ) . $ this -> config [ 'modelsPrefix' ] . $ this -> getName ( $ pathname ) . $ this -> config [ 'modelsPostfix' ] . '.php' ; include_once ( $ fullPath ) ; }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
3748	protected function getIdsFromFilter ( $ filter , $ config ) { $ sorting = $ this -> extractSorting ( $ config ) ; return $ this -> getMetaModel ( ) -> getIdsFromFilter ( $ filter , $ sorting [ 0 ] , $ config -> getStart ( ) , $ config -> getAmount ( ) , strtoupper ( $ sorting [ 1 ] ) ) ; }
2205	public static function findPost ( $ strKey ) { if ( isset ( $ _POST [ $ strKey ] ) ) { return $ _POST [ $ strKey ] ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getMasterRequest ( ) ; if ( $ request === null || ! $ request -> hasPreviousSession ( ) ) { return null ; } if ( isset ( $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) ) { return ( $ strKey == 'FORM_SUBMIT' ) ? preg_replace ( '/^auto_/i' , '' , $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ) : $ _SESSION [ 'FORM_DATA' ] [ $ strKey ] ; } return null ; }
1695	public function checkStyleSheetName ( $ strName ) { $ objStyleSheet = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_style_sheet WHERE name=?" ) -> limit ( 1 ) -> execute ( $ strName ) ; if ( $ objStyleSheet -> count < 1 ) { return $ strName ; } $ chunks = explode ( '-' , $ strName ) ; $ i = ( \ count ( $ chunks ) > 1 ) ? array_pop ( $ chunks ) : 0 ; $ strName = implode ( '-' , $ chunks ) . '-' . ( ( int ) $ i + 1 ) ; return $ this -> checkStyleSheetName ( $ strName ) ; }
4287	public function getSubscriptions ( ) { if ( ! $ this -> isConnected ( ) ) { $ this -> debug -> alert ( 'WAMP publisher not connected to WAMP router' ) ; return array ( ) ; } $ this -> publishMeta ( ) ; $ this -> processExistingData ( ) ; return array ( 'debug.log' => array ( 'onLog' , PHP_INT_MAX * - 1 ) , 'errorHandler.error' => 'onError' , 'php.shutdown' => array ( 'onShutdown' , PHP_INT_MAX * - 1 ) , ) ; }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
1556	protected function queryRulesWithoutSearch ( ) { return collect ( $ this -> queryRules ( ) ) -> reject ( function ( $ value , $ key ) { return Str :: startsWith ( $ key , [ 'filter.' , 'sort.' , 'page.' ] ) ; } ) -> all ( ) ; }
3833	protected function getLangValue ( $ arrValues , $ strLangCode = null ) { if ( ! ( $ this -> getMetaModel ( ) -> isTranslated ( ) && is_array ( $ arrValues ) ) ) { return $ arrValues ; } if ( $ strLangCode === null ) { return $ this -> getLangValue ( $ arrValues , $ this -> getMetaModel ( ) -> getActiveLanguage ( ) ) ; } if ( array_key_exists ( $ strLangCode , $ arrValues ) ) { return $ arrValues [ $ strLangCode ] ; } return $ arrValues [ $ this -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; }
10531	public function count ( ) { if ( is_array ( $ this -> items ) && $ this -> items !== null ) { return count ( $ this -> items ) ; } return 0 ; }
11308	public function entityFromBody ( $ body , $ entity ) { $ json = $ this -> decodeJson ( $ body ) ; return $ entity -> populate ( $ json ) ; }
11963	private function setParam ( $ key , $ value , $ allowed_keys ) { if ( in_array ( $ key , $ allowed_keys ) ) { $ this -> { $ key } = $ value ; } }
11808	public function paginate ( $ perPage = null , $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) && ( $ columns !== null ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( $ columnsPassed ) { return $ query -> paginate ( $ perPage , $ columns ) ; } return $ query -> paginate ( $ perPage , $ this -> getQueryColumns ( ) ) ; }
3193	public function load ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ data = $ this -> storage -> load ( ) ; if ( isset ( $ data ) ) { if ( ! is_array ( $ data ) ) { $ data = [ self :: STORAGE_KEY_TIME_LINE => $ data , ] ; } if ( isset ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ) { $ this -> timeLine = $ this -> unserializeTimeLine ( $ data [ self :: STORAGE_KEY_TIME_LINE ] ) ; } else { $ this -> timeLine = new QtiTimeLine ( ) ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ) ) { $ this -> extraTime = $ data [ self :: STORAGE_KEY_EXTRA_TIME ] ; } else { $ this -> extraTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ) ) { $ this -> extendedTime = $ data [ self :: STORAGE_KEY_EXTENDED_TIME ] ; } else { $ this -> extendedTime = 0 ; } if ( isset ( $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ) ) { $ this -> consumedExtraTime = $ data [ self :: STORAGE_KEY_CONSUMED_EXTRA_TIME ] ; } else { $ this -> consumedExtraTime = 0 ; } if ( ! $ this -> timeLine instanceof TimeLine ) { throw new InvalidDataException ( 'The storage did not provide acceptable data when loading!' ) ; } } return $ this ; }
4922	public function removeRegion ( $ region ) { if ( array_key_exists ( $ region , $ this -> matrix ) ) { unset ( $ this -> matrix [ $ region ] ) ; } return $ this ; }
11114	public function rollback ( array $ options = [ ] ) : void { $ migrations = $ this -> getMigrationsForRollback ( $ options ) ; if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to rollback.</info>' ) ; return ; } $ this -> rollbackMigrations ( $ migrations ) ; }
4425	protected function generateLegacyAutoloads ( ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> write ( 'Generating legacy autoloads... ' ) ; $ currentWorkingDirectory = getcwd ( ) ; try { chdir ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish_legacy.root_dir' ) ) ; $ processBuilder = new ProcessBuilder ( array ( 'php' , 'bin/php/ezpgenerateautoloads.php' , '--quiet' , ) ) ; $ process = $ processBuilder -> getProcess ( ) ; $ process -> setTimeout ( 3600 ) ; $ process -> run ( function ( $ type , $ buffer ) { echo $ buffer ; } ) ; chdir ( $ currentWorkingDirectory ) ; if ( ! $ process -> isSuccessful ( ) ) { return array ( '- Run the following command from your ezpublish_legacy root to generate legacy autoloads:' , '' , ' <comment>php bin/php/ezpgenerateautoloads.php</comment>' , '' , ) ; } } catch ( Exception $ e ) { chdir ( $ currentWorkingDirectory ) ; return array ( 'There was an error generating legacy autoloads: ' . $ e -> getMessage ( ) , '' , ) ; } }
3412	public function finishedCrawling ( ) { $ this -> consoleOutput -> writeln ( '' ) ; $ this -> consoleOutput -> writeln ( 'Crawling summary' ) ; $ this -> consoleOutput -> writeln ( '----------------' ) ; ksort ( $ this -> crawledUrls ) ; foreach ( $ this -> crawledUrls as $ statusCode => $ urls ) { $ colorTag = $ this -> getColorTagForStatusCode ( $ statusCode ) ; $ count = count ( $ urls ) ; if ( is_numeric ( $ statusCode ) ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>Crawled {$count} url(s) with statuscode {$statusCode}</{$colorTag}>" ) ; } if ( $ statusCode == static :: UNRESPONSIVE_HOST ) { $ this -> consoleOutput -> writeln ( "<{$colorTag}>{$count} url(s) did have unresponsive host(s)</{$colorTag}>" ) ; } } $ this -> consoleOutput -> writeln ( '' ) ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
1995	public function generateRss ( ) { $ this -> adjustPublicationDate ( ) ; $ xml = '<?xml version="1.0" encoding="' . Config :: get ( 'characterSet' ) . '"?>' ; $ xml .= '<rss version="2.0" xmlns:media="http://search.yahoo.com/mrss/" xmlns:atom="http://www.w3.org/2005/Atom">' ; $ xml .= '<channel>' ; $ xml .= '<title>' . StringUtil :: specialchars ( $ this -> title ) . '</title>' ; $ xml .= '<description>' . StringUtil :: specialchars ( $ this -> description ) . '</description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ this -> link ) . '</link>' ; $ xml .= '<language>' . $ this -> language . '</language>' ; $ xml .= '<pubDate>' . date ( 'r' , $ this -> published ) . '</pubDate>' ; $ xml .= '<generator>Contao Open Source CMS</generator>' ; $ xml .= '<atom:link href="' . StringUtil :: specialchars ( Environment :: get ( 'base' ) . 'share/' . $ this -> strName ) . '.xml" rel="self" type="application/rss+xml" />' ; foreach ( $ this -> arrItems as $ objItem ) { $ xml .= '<item>' ; $ xml .= '<title>' . StringUtil :: specialchars ( strip_tags ( StringUtil :: stripInsertTags ( $ objItem -> title ) ) ) . '</title>' ; $ xml .= '<description><![CDATA[' . preg_replace ( '/[\n\r]+/' , ' ' , $ objItem -> description ) . ']]></description>' ; $ xml .= '<link>' . StringUtil :: specialchars ( $ objItem -> link ) . '</link>' ; $ xml .= '<pubDate>' . date ( 'r' , $ objItem -> published ) . '</pubDate>' ; if ( $ objItem -> guid ) { if ( strncmp ( $ objItem -> guid , 'http://' , 7 ) !== 0 && strncmp ( $ objItem -> guid , 'https://' , 8 ) !== 0 ) { $ xml .= '<guid isPermaLink="false">' . $ objItem -> guid . '</guid>' ; } else { $ xml .= '<guid>' . $ objItem -> guid . '</guid>' ; } } else { $ xml .= '<guid>' . StringUtil :: specialchars ( $ objItem -> link ) . '</guid>' ; } if ( \ is_array ( $ objItem -> enclosure ) ) { foreach ( $ objItem -> enclosure as $ arrEnclosure ) { if ( ! empty ( $ arrEnclosure [ 'media' ] ) && $ arrEnclosure [ 'media' ] == 'media:content' ) { $ xml .= '<media:content url="' . $ arrEnclosure [ 'url' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } else { $ xml .= '<enclosure url="' . $ arrEnclosure [ 'url' ] . '" length="' . $ arrEnclosure [ 'length' ] . '" type="' . $ arrEnclosure [ 'type' ] . '" />' ; } } } $ xml .= '</item>' ; } $ xml .= '</channel>' ; $ xml .= '</rss>' ; return $ xml ; }
1932	public function parse ( ) { $ strBuffer = parent :: parse ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'parseBackendTemplate' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ strBuffer = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strBuffer , $ this -> strTemplate ) ; } } return $ strBuffer ; }
8132	public function getSourceContext ( ) { return $ this -> filename ? new Twig_Source ( $ this -> sourceCode , $ this -> filename , $ this -> sourcePath ) : null ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
12560	public function fixFileSlashes ( $ file , & $ contents ) { $ changed = false ; foreach ( $ contents as $ lineNumber => $ line ) { if ( preg_match ( '/(psesd|canis|cascade)\\\\\\\/' , $ line ) === 1 ) { $ fixedLine = preg_replace ( '/\\\\\\\/' , '\\' , $ line ) ; if ( $ fixedLine !== $ line ) { $ contents [ $ lineNumber ] = $ fixedLine ; $ changed = true ; } } } return $ changed ; }
11753	public function close ( $ msgId , $ index ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CLOSE_COMMENT , $ params ] ) ; }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
10794	public function passwordRecovery ( array $ data ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.passwordrecovery' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ data = $ form -> getData ( ) ; $ email = isset ( $ data [ 'email' ] ) ? $ data [ 'email' ] : null ; $ user = $ userRepository -> findOneBy ( array ( 'email' => $ email ) ) ; if ( null === $ user ) { throw new \ Exception ( 'No user found' ) ; } $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ userModel -> init ( $ user , $ this -> getServiceLocator ( ) ) ; $ hash = $ userModel -> hashId . sha1 ( $ user -> getPassword ( ) ) ; $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ event = new PasswordRecoveryEvent ( __FUNCTION__ , null , array ( 'user' => $ user , 'form' => $ form , 'hash' => $ hash , 'email' => $ email , 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; return $ user ; }
7226	public function info ( $ name = null ) { if ( $ name ) { return $ this -> info ? $ this -> info [ $ name ] : curl_getinfo ( $ this -> curl , "CURLINFO" . strtoupper ( $ name ) ) ; } else { return $ this -> info ? : curl_getinfo ( $ this -> curl ) ; } }
2290	protected function addRecipient ( $ strEmail , $ arrNew ) { if ( ( $ objOld = NewsletterRecipientsModel :: findOldSubscriptionsByEmailAndPids ( $ strEmail , $ arrNew ) ) !== null ) { while ( $ objOld -> next ( ) ) { $ objOld -> delete ( ) ; } } $ time = time ( ) ; $ arrRelated = array ( ) ; foreach ( $ arrNew as $ id ) { $ objRecipient = new NewsletterRecipientsModel ( ) ; $ objRecipient -> pid = $ id ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> email = $ strEmail ; $ objRecipient -> active = '' ; $ objRecipient -> addedOn = $ time ; $ objRecipient -> save ( ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( md5 ( $ strEmail ) , $ id ) ) !== null ) { $ objBlacklist -> delete ( ) ; } $ arrRelated [ 'tl_newsletter_recipients' ] [ ] = $ objRecipient -> id ; } $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'nl' , $ strEmail , $ arrRelated ) ; $ objChannel = NewsletterChannelModel :: findByIds ( $ arrNew ) ; $ arrData = array ( ) ; $ arrData [ 'token' ] = $ optInToken -> getIdentifier ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ objChannel -> fetchEach ( 'title' ) ) ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> nl_subscribe , $ arrData ) ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_confirm' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_confirm' ] ) ; $ this -> reload ( ) ; }
8443	public function exit ( $ id , $ pid , $ code , $ forceRetry = false , $ queueBackoffTime = null ) { $ this -> logger -> info ( 'Job ended' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ id , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ hash = explode ( ':' , $ id ) ; $ jobId = $ hash [ count ( $ hash ) - 1 ] ; try { $ job = $ this -> queue -> getJob ( $ jobId ) ; } catch ( JobNotFoundException $ e ) { $ this -> logger -> info ( 'Unable to process job exit code or retry status. Job data unavailable' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return true ; } if ( $ code === 0 ) { $ this -> logger -> info ( 'Job succeeded and is now complete' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> end ( ) ; } else { $ retry = $ job -> getRetry ( ) ; if ( $ forceRetry === true ) { $ retry = true ; } if ( $ retry === true || $ retry > 0 ) { $ this -> logger -> info ( 'Rescheduling job' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) , 'time' => \ time ( ) + $ queueBackoffTime ?? 0 ] ) ; return $ job -> retry ( $ queueBackoffTime ) ; } else { $ this -> logger -> info ( 'Job failed' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> fail ( ) ; } } return ; }
7459	private function color ( string $ color ) : Font { $ this -> color = $ color ; if ( $ this -> background ) { $ this -> turnToBackground ( ) ; } return $ this ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
9596	public function makeSession ( ) { $ session = new Session ( $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface' ) , $ this -> dic -> resolve ( 'Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface' ) ) ; $ session -> setName ( $ this -> config -> get ( 'session.cookie.name' , 'autarky_session' ) ) ; return $ session ; }
12832	private function _processModifiers ( $ expression ) { $ mStart = '' ; $ mEnd = '' ; $ rawEcho = false ; if ( strpos ( $ expression , '|' ) !== false && strpos ( $ expression , '||' ) === false ) { $ modifiers = explode ( '|' , $ expression ) ; $ expression = array_shift ( $ modifiers ) ; foreach ( $ modifiers as $ modifier ) { $ params = array ( ) ; if ( strpos ( $ modifier , ':' ) !== false ) { $ params = explode ( ':' , $ modifier ) ; $ modifier = array_shift ( $ params ) ; } if ( $ modifier == 'raw' ) { $ rawEcho = true ; continue ; } if ( $ this -> isCallable ( $ modifier ) ) { $ mStart = $ modifier . '(' . $ mStart ; if ( $ modifier !== 'raw' ) { foreach ( $ params as $ param ) { $ mEnd .= ', ' . $ this -> compileExpression ( $ param ) ; } } $ mEnd .= ')' ; } else { throw new \ Exception ( 'SLOT compiler error: undefined modifier ' . $ modifier ) ; } } } return array ( $ expression , $ mStart , $ mEnd , $ rawEcho ) ; }
4639	private function attachFiles ( Message $ message , Email $ email ) { if ( ! $ email -> hasAttachments ( ) ) { return ; } $ attachments = $ email -> getComputedAttachments ( ) ; $ mimeMessage = $ message -> getBody ( ) ; $ oldParts = $ mimeMessage -> getParts ( ) ; $ attachmentParts = [ ] ; $ info = null ; foreach ( $ attachments as $ key => $ attachment ) { if ( is_array ( $ attachment ) && isset ( $ attachment [ 'parser_name' ] , $ attachment [ 'value' ] ) ) { $ attachment = Attachment :: fromArray ( $ attachment ) ; } $ parserName = $ this -> resolveParserNameFromAttachment ( $ attachment ) ; if ( ! $ this -> attachmentParserManager -> has ( $ parserName ) ) { throw new Exception \ ServiceNotCreatedException ( sprintf ( 'The attachment parser "%s" could not be found' , $ parserName ) ) ; } $ parser = $ this -> attachmentParserManager -> get ( $ parserName ) ; $ attachmentValue = $ attachment instanceof Attachment ? $ attachment -> getValue ( ) : $ attachment ; $ part = $ parser -> parse ( $ attachmentValue , is_string ( $ key ) ? $ key : null ) ; $ part -> charset = $ email -> getCharset ( ) ; $ attachmentParts [ ] = $ part ; } $ body = new Mime \ Message ( ) ; $ body -> setParts ( array_merge ( $ oldParts , $ attachmentParts ) ) ; $ message -> setBody ( $ body ) ; }
2184	protected function getAllEvents ( $ arrCalendars , $ intStart , $ intEnd ) { if ( ! \ is_array ( $ arrCalendars ) ) { return array ( ) ; } $ this -> arrEvents = array ( ) ; foreach ( $ arrCalendars as $ id ) { $ objEvents = CalendarEventsModel :: findCurrentByPid ( $ id , $ intStart , $ intEnd ) ; if ( $ objEvents === null ) { continue ; } while ( $ objEvents -> next ( ) ) { $ this -> addEvent ( $ objEvents , $ objEvents -> startTime , $ objEvents -> endTime , $ intStart , $ intEnd , $ id ) ; if ( $ objEvents -> recurring ) { $ arrRepeat = StringUtil :: deserialize ( $ objEvents -> repeatEach ) ; if ( ! \ is_array ( $ arrRepeat ) || ! isset ( $ arrRepeat [ 'unit' ] ) || ! isset ( $ arrRepeat [ 'value' ] ) || $ arrRepeat [ 'value' ] < 1 ) { continue ; } $ count = 0 ; $ intStartTime = $ objEvents -> startTime ; $ intEndTime = $ objEvents -> endTime ; $ strtotime = '+ ' . $ arrRepeat [ 'value' ] . ' ' . $ arrRepeat [ 'unit' ] ; while ( $ intEndTime < $ intEnd ) { if ( $ objEvents -> recurrences > 0 && $ count ++ >= $ objEvents -> recurrences ) { break ; } $ intStartTime = strtotime ( $ strtotime , $ intStartTime ) ; $ intEndTime = strtotime ( $ strtotime , $ intEndTime ) ; if ( $ intStartTime === false || $ intEndTime === false ) { break ; } if ( $ intEndTime < $ intStart || $ intStartTime > $ intEnd ) { continue ; } $ this -> addEvent ( $ objEvents , $ intStartTime , $ intEndTime , $ intStart , $ intEnd , $ id ) ; } } } } foreach ( array_keys ( $ this -> arrEvents ) as $ key ) { ksort ( $ this -> arrEvents [ $ key ] ) ; } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getAllEvents' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> arrEvents = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ this -> arrEvents , $ arrCalendars , $ intStart , $ intEnd , $ this ) ; } } return $ this -> arrEvents ; }
11834	public function doStore ( ModulesEvent $ event ) { $ cache = $ this -> getCache ( ) ; $ config = $ this -> getConfig ( ) ; $ cache -> set ( 'config' , $ config ) ; }
5638	public function shouldInvoke ( $ test_case , $ method ) { if ( $ this -> shouldRunTest ( $ test_case , $ method ) ) { return $ this -> reporter -> shouldInvoke ( $ test_case , $ method ) ; } return false ; }
170	public static function filterPath ( $ path , $ options ) { if ( isset ( $ options [ 'filter' ] ) ) { $ result = call_user_func ( $ options [ 'filter' ] , $ path ) ; if ( is_bool ( $ result ) ) { return $ result ; } } if ( empty ( $ options [ 'except' ] ) && empty ( $ options [ 'only' ] ) ) { return true ; } $ path = str_replace ( '\\' , '/' , $ path ) ; if ( ! empty ( $ options [ 'except' ] ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'except' ] ) ) !== null ) { return $ except [ 'flags' ] & self :: PATTERN_NEGATIVE ; } } if ( ! empty ( $ options [ 'only' ] ) && ! is_dir ( $ path ) ) { if ( ( $ except = self :: lastExcludeMatchingFromList ( $ options [ 'basePath' ] , $ path , $ options [ 'only' ] ) ) !== null ) { return true ; } return false ; } return true ; }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
12191	protected function buildMessage ( ) { $ className = $ this -> getClassName ( ) ; $ methodName = $ this -> getMethodName ( ) ; $ functionName = $ this -> getFunctionName ( ) ; if ( $ className !== null && $ methodName !== null ) { $ callable = $ className . '::' . $ methodName ; ; } else { $ callable = $ functionName ; } $ this -> message = s ( 'Container could not resolve argument %s for %s.' , $ this -> getArgumentIndex ( ) , $ callable ) ; }
12839	static public function generateFilename ( $ directory , $ extension , $ length = 16 ) { do { $ name = \ Extlib \ Generator :: generate ( $ length ) ; $ filepath = rtrim ( $ directory , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . sprintf ( '%s.%s' , $ name , $ extension ) ; } while ( file_exists ( $ filepath ) ) ; return $ name ; }
1622	private function addColumn ( $ column , & $ columns ) { if ( isset ( $ columns [ $ column ] ) ) { return $ columns [ $ column ] ; } $ name = 'c' . preg_replace ( "/[^a-z]+/i" , "" , $ column ) . count ( $ columns ) ; return $ columns [ $ column ] = $ name ; }
5616	public function compareChildren ( $ a , $ b ) { if ( $ this -> _children [ $ a ] -> getTotalSize ( ) > $ this -> _children [ $ b ] -> getTotalSize ( ) ) { $ node_a = $ this -> _children [ $ a ] ; $ node_b = $ this -> _children [ $ b ] ; $ this -> _children [ $ a ] = $ node_b ; $ this -> _children [ $ b ] = $ node_a ; } }
7079	public static function getTypes ( ) { return [ self :: TYPE_WEBSITE , self :: TYPE_USER , self :: TYPE_ADMINISTRATOR , self :: TYPE_IN_CHARGE , self :: TYPE_CUSTOMER , self :: TYPE_SALESMAN , self :: TYPE_ACCOUNTABLE , self :: TYPE_SUPPLIER , ] ; }
10495	public function mod ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value % $ value ) ; }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
11999	static protected function phalconQuery ( $ modelName , $ field , $ generate ) { $ return = \ Phalcon \ Mvc \ Model :: query ( ) -> setModelName ( $ modelName ) -> where ( "$field = :value:" ) -> bind ( array ( 'value' => $ generate ) ) -> execute ( ) ; return ( boolean ) $ return -> count ( ) ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
7342	protected function scheduleSupplierOrderContentChangeEvent ( Model \ SupplierOrderInterface $ order ) { $ this -> persistenceHelper -> scheduleEvent ( SupplierOrderEvents :: CONTENT_CHANGE , $ order ) ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
3421	protected function loadModels ( ) { $ queryType = 'UserQuery::getList' ; $ sort = $ this -> sort ; $ filter = $ this -> normalizeFilter ( ) ; $ params = [ 'SELECT' => $ this -> propsMustBeSelected ( ) ? [ 'UF_*' ] : ( $ this -> normalizeUfSelect ( ) ? : false ) , 'NAV_PARAMS' => $ this -> navigation , 'FIELDS' => $ this -> normalizeSelect ( ) , ] ; $ selectGroups = $ this -> groupsMustBeSelected ( ) ; $ keyBy = $ this -> keyBy ; $ callback = function ( ) use ( $ sort , $ filter , $ params , $ selectGroups ) { $ users = [ ] ; $ rsUsers = $ this -> bxObject -> getList ( $ sort , $ sortOrder = false , $ filter , $ params ) ; while ( $ arUser = $ this -> performFetchUsingSelectedMethod ( $ rsUsers ) ) { if ( $ selectGroups ) { $ arUser [ 'GROUP_ID' ] = $ this -> bxObject -> getUserGroup ( $ arUser [ 'ID' ] ) ; } $ this -> addItemToResultsUsingKeyBy ( $ users , new $ this -> modelName ( $ arUser [ 'ID' ] , $ arUser ) ) ; } return new Collection ( $ users ) ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'sort' , 'filter' , 'params' , 'selectGroups' , 'keyBy' ) , $ callback ) ; }
8173	private function addCallable ( $ type = 'function' , $ name , $ func ) { if ( ! is_string ( $ name ) || ! is_callable ( $ func ) ) { return ; } $ twname = trim ( $ name , '*' ) ; $ params = [ ] ; if ( strpos ( $ name , '*' ) === 0 ) { $ params [ 'is_safe' ] = [ 'html' ] ; } if ( $ type === 'function' ) { $ this -> twig -> addFunction ( new Twig_SimpleFunction ( $ twname , $ func , $ params ) ) ; } if ( $ type === 'filter' ) { $ this -> twig -> addFilter ( new Twig_SimpleFilter ( $ twname , $ func , $ params ) ) ; } }
9298	public function getHome ( ) { $ query = $ this -> createQueryBuilder ( 'c' ) -> join ( 'c.forums' , 'f' ) -> join ( 'f.lastMessage' , 'm' ) -> join ( 'm.user' , 'u' ) -> addSelect ( 'f' ) -> addSelect ( 'm' ) -> addSelect ( 'u' ) -> where ( 'f.status = :status' ) -> setParameter ( 'status' , Forum :: STATUS_PUBLIC ) ; $ query -> orderBy ( 'c.position' , 'ASC' ) -> addOrderBy ( 'f.position' , 'ASC' ) ; return $ query -> getQuery ( ) ; }
11562	protected function getWeekWordsUnitsAndShortcuts ( $ lang ) { if ( ! isset ( $ this -> weekWords [ $ lang ] ) ) { if ( isset ( static :: $ WeekWordsDefault [ $ lang ] ) ) { $ this -> weekWords [ $ lang ] = explode ( ',' , static :: $ WeekWordsDefault [ $ lang ] ) ; } else { $ this -> weekWords [ $ lang ] = [ ] ; } } if ( ! $ this -> units ) $ this -> units = explode ( ',' , static :: $ UnitsDefault ) ; if ( ! isset ( $ this -> shortcuts [ $ lang ] ) ) { if ( isset ( static :: $ ShortcutsDefault [ $ lang ] ) ) { $ shortcuts = [ ] ; foreach ( static :: $ ShortcutsDefault [ $ lang ] as $ shortcutsLocalized ) foreach ( $ shortcutsLocalized as $ shortcut ) $ shortcuts [ $ shortcut ] = str_replace ( ' ' , '&nbsp;' , $ shortcut ) ; $ this -> shortcuts [ $ lang ] = & $ shortcuts ; } else { $ this -> shortcuts [ $ lang ] = [ ] ; } } return [ $ this -> weekWords [ $ lang ] , $ this -> units , $ this -> shortcuts [ $ lang ] ] ; }
6820	protected function writeInvoiceTaxesLine ( ) { $ sale = $ this -> invoice -> getSale ( ) ; $ date = $ sale -> getCreatedAt ( ) ; $ credit = $ this -> invoice -> getType ( ) === InvoiceTypes :: TYPE_CREDIT ; foreach ( $ this -> invoice -> getTaxesDetails ( ) as $ detail ) { $ amount = $ this -> round ( $ detail [ 'amount' ] ) ; if ( 0 === $ this -> compare ( $ amount , 0 ) ) { continue ; } $ account = $ this -> getTaxAccountNumber ( $ detail [ 'rate' ] , $ this -> invoice -> getNumber ( ) ) ; if ( $ credit ) { $ this -> writer -> credit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance -= $ amount ; } else { $ this -> writer -> debit ( $ account , ( string ) $ amount , $ date ) ; $ this -> balance += $ amount ; } } }
9967	public function getHyperlink ( $ pCellCoordinate ) { if ( isset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ) { return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; } $ this -> hyperlinkCollection [ $ pCellCoordinate ] = new Hyperlink ( ) ; return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; }
12546	public function once ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> once ( $ event , $ callback , $ priority ) ; }
11408	public function onBootstrap ( MvcEvent $ e ) { if ( ! $ e -> getRequest ( ) instanceof HttpRequest ) { return ; } $ app = $ e -> getApplication ( ) ; $ services = $ app -> getServiceManager ( ) ; $ eventManager = $ app -> getEventManager ( ) ; $ sharedEventManager = $ eventManager -> getSharedManager ( ) ; $ sharedEventManager -> attach ( UserService :: class , 'register' , function ( $ e ) use ( $ services ) { $ user = $ e -> getParam ( 'user' ) ; if ( $ user instanceof RoleableInterface && $ services -> has ( AuthorizationModuleOptions :: class ) ) { $ config = $ services -> get ( PermissionsModuleOptions :: class ) ; $ roleClass = $ config -> getRoleEntityClass ( ) ; $ mapper = $ services -> get ( 'MapperManager' ) -> get ( $ roleClass ) ; if ( $ defaultRole = $ mapper -> find ( $ config -> getAuthenticatedRole ( ) ) ) { $ user -> addRole ( $ defaultRole ) ; } } } , 100 ) ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
1104	protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
12679	public static function boot ( ConfigurationHandler $ configurationHandler ) { $ pluginDirs = $ configurationHandler -> pluginFolders ( ) ; foreach ( $ pluginDirs as $ pluginDir ) { self :: $ blocks += self :: parse ( $ pluginDir ) ; } }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
5602	public function paintFail ( $ message ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> fail = true ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"fail",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
575	protected function getDefaultValue ( $ event ) { if ( $ this -> defaultValue instanceof \ Closure || ( is_array ( $ this -> defaultValue ) && is_callable ( $ this -> defaultValue ) ) ) { return call_user_func ( $ this -> defaultValue , $ event ) ; } return $ this -> defaultValue ; }
12501	private static function updateRecursion ( $ document ) { $ result = array ( ) ; foreach ( self :: toDotted ( $ document , '' , 1 ) as $ path => $ value ) { $ result [ ] = $ path . $ value ; } return implode ( ' ' , $ result ) ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
5088	public function queryMap ( $ key = 0 , $ value = 1 ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) || is_string ( $ value ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) || ! key_exists ( $ value , $ row ) ) throw new MySqlException ( "Key '$key' or Value '$value' columns not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; $ map [ $ row [ $ key ] ] = $ row [ $ value ] ; } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
11326	public static function removeSuffix ( $ string , $ suffix ) { if ( static :: hasSuffix ( $ string , $ suffix ) ) { return substr ( $ string , 0 , - strlen ( $ suffix ) ) ; } return $ string ; }
3767	private function getOptions ( $ attribute , $ onlyUsed ) { $ options = [ ] ; foreach ( $ attribute -> getFilterOptions ( null , $ onlyUsed ) as $ key => $ value ) { $ value = trim ( strip_tags ( $ value ) ) ; if ( ! empty ( $ value ) ) { $ options [ $ key ] = $ value ; } } return $ options ; }
6200	public function currentPath ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ gets = $ parseUrl [ 'sVars' ] ; } else { $ gets = $ _SERVER [ 'QUERY_STRING' ] ; } return $ gets ; }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
10461	public function initialize ( $ filePath , $ params ) { copy ( __DIR__ . '/../../../recipe/releaz.php' , $ filePath ) ; $ exampleFile = $ this -> getExamplePath ( ) ; $ projectFile = dirname ( $ filePath ) . '/' . $ this -> getExample ( ) ; copy ( $ exampleFile , $ projectFile ) ; $ this -> setParamsInExample ( $ projectFile , $ params ) ; }
7741	public function addOperation ( OperationDefinition $ operation ) { if ( false === $ this -> supportsOperation ( $ operation -> getName ( ) ) ) { $ this -> operations [ ] = $ operation ; } return $ this ; }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
4820	public function addField ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> row [ $ name ] = $ value ; } elseif ( is_array ( $ this -> row [ $ name ] ) ) { $ this -> row [ $ name ] [ ] = $ value ; } else { $ this -> row [ $ name ] = array ( $ this -> row [ $ name ] , $ value ) ; } $ this -> informChanges ( ) ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
9904	private function updateCellRange ( $ pCellRange = 'A1:A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( ! Coordinate :: coordinateIsRange ( $ pCellRange ) ) { throw new Exception ( 'Only cell ranges may be passed to this method.' ) ; } $ range = Coordinate :: splitRange ( $ pCellRange ) ; $ ic = count ( $ range ) ; for ( $ i = 0 ; $ i < $ ic ; ++ $ i ) { $ jc = count ( $ range [ $ i ] ) ; for ( $ j = 0 ; $ j < $ jc ; ++ $ j ) { if ( ctype_alpha ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] . '1' , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 0 ] ; } elseif ( ctype_digit ( $ range [ $ i ] [ $ j ] ) ) { $ r = Coordinate :: coordinateFromString ( $ this -> updateSingleCellReference ( 'A' . $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ) ; $ range [ $ i ] [ $ j ] = $ r [ 1 ] ; } else { $ range [ $ i ] [ $ j ] = $ this -> updateSingleCellReference ( $ range [ $ i ] [ $ j ] , $ pBefore , $ pNumCols , $ pNumRows ) ; } } } return Coordinate :: buildRange ( $ range ) ; }
1212	public static function isTruthy ( $ value ) { if ( ! $ value ) { return $ value === 0 || $ value === '0' ; } elseif ( $ value instanceof \ stdClass ) { return ( bool ) get_object_vars ( $ value ) ; } elseif ( $ value instanceof JmesPathableArrayInterface ) { return Utils :: isTruthy ( iterator_to_array ( $ value ) ) ; } elseif ( $ value instanceof JmesPathableObjectInterface ) { return ( bool ) $ value -> toArray ( ) ; } else { return true ; } }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
4130	public function createNativeQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new Query ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; return $ query ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
4449	public function pop ( ? string $ worker = null , ? int $ numJobs = null ) { $ workerName = $ worker ? : $ this -> client -> getWorkerName ( ) ; $ jids = json_decode ( $ this -> client -> pop ( $ this -> name , $ workerName , $ numJobs ? : 1 ) , true ) ; $ jobs = [ ] ; array_map ( function ( array $ data ) use ( & $ jobs ) { $ job = new BaseJob ( $ this -> client , $ data ) ; $ job -> setEventsManager ( $ this -> getEventsManager ( ) ) ; $ jobs [ ] = $ job ; } , $ jids ? : [ ] ) ; return $ numJobs === null ? array_shift ( $ jobs ) : $ jobs ; }
10732	public function getSecond ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'second' ] ; } }
3864	private function setTitleAndDescription ( ) { $ page = $ this -> getPage ( ) ; if ( $ page && $ this -> objItems -> getCount ( ) ) { if ( ! empty ( $ this -> strTitleAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrTitle = $ objCurrentItem -> parseAttribute ( $ this -> strTitleAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrTitle [ 'text' ] ) ) { $ page -> pageTitle = strip_tags ( $ arrTitle [ 'text' ] ) ; break ; } } $ this -> objItems -> reset ( ) ; } if ( ! empty ( $ this -> strDescriptionAttribute ) ) { while ( $ this -> objItems -> next ( ) ) { $ objCurrentItem = $ this -> objItems -> current ( ) ; $ arrDescription = $ objCurrentItem -> parseAttribute ( $ this -> strDescriptionAttribute , 'text' , $ this -> getView ( ) ) ; if ( ! empty ( $ arrDescription [ 'text' ] ) ) { $ page -> description = StringUtil :: substr ( $ arrDescription [ 'text' ] , 160 ) ; break ; } } $ this -> objItems -> reset ( ) ; } } }
3662	private function parseTable ( ) { $ this -> queryString = str_replace ( '{{table}}' , $ this -> collection -> getMetaModel ( ) -> getTableName ( ) , $ this -> queryString ) ; }
8941	public function expandBBoxChangeset ( $ id , $ nodes ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/expand_bbox' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ nodeList = '' ; if ( ! empty ( $ nodes ) ) { foreach ( $ nodes as $ node ) { $ nodeList .= '<node lat="' . $ node [ 0 ] . '" lon="' . $ node [ 1 ] . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ nodeList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'POST' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
734	public function init ( ) { parent :: init ( ) ; $ this -> itemFile = Yii :: getAlias ( $ this -> itemFile ) ; $ this -> assignmentFile = Yii :: getAlias ( $ this -> assignmentFile ) ; $ this -> ruleFile = Yii :: getAlias ( $ this -> ruleFile ) ; $ this -> load ( ) ; }
1740	public function checkImportantPart ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( is_dir ( $ rootDir . '/' . $ dc -> id ) || ! \ in_array ( strtolower ( substr ( $ dc -> id , strrpos ( $ dc -> id , '.' ) + 1 ) ) , Contao \ StringUtil :: trimsplit ( ',' , strtolower ( Contao \ Config :: get ( 'validImageTypes' ) ) ) ) ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] = str_replace ( ',importantPartX,importantPartY,importantPartWidth,importantPartHeight' , '' , $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'palettes' ] ) ; } }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
10700	public static function isMobilePhoneNumber ( $ phone ) { $ phoneNumber = substr ( Tools :: removeSpace ( $ phone ) , - 9 , 1 ) ; return ( ! self :: isCzechPhoneNumber ( $ phoneNumber ) || ( $ phoneNumber === '6' || $ phoneNumber === '7' ) ) ; }
9905	private function updateSingleCellReference ( $ pCellReference = 'A1' , $ pBefore = 'A1' , $ pNumCols = 0 , $ pNumRows = 0 ) { if ( Coordinate :: coordinateIsRange ( $ pCellReference ) ) { throw new Exception ( 'Only single cell references may be passed to this method.' ) ; } list ( $ beforeColumn , $ beforeRow ) = Coordinate :: coordinateFromString ( $ pBefore ) ; list ( $ newColumn , $ newRow ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ updateColumn = ( ( $ newColumn [ 0 ] != '$' ) && ( $ beforeColumn [ 0 ] != '$' ) && ( Coordinate :: columnIndexFromString ( $ newColumn ) >= Coordinate :: columnIndexFromString ( $ beforeColumn ) ) ) ; $ updateRow = ( ( $ newRow [ 0 ] != '$' ) && ( $ beforeRow [ 0 ] != '$' ) && $ newRow >= $ beforeRow ) ; if ( $ updateColumn ) { $ newColumn = Coordinate :: stringFromColumnIndex ( Coordinate :: columnIndexFromString ( $ newColumn ) + $ pNumCols ) ; } if ( $ updateRow ) { $ newRow = $ newRow + $ pNumRows ; } return $ newColumn . $ newRow ; }
1026	private function doesFragmentConditionMatch ( $ fragment , ObjectType $ type ) { $ typeConditionNode = $ fragment -> typeCondition ; if ( $ typeConditionNode === null ) { return true ; } $ conditionalType = TypeInfo :: typeFromAST ( $ this -> exeContext -> schema , $ typeConditionNode ) ; if ( $ conditionalType === $ type ) { return true ; } if ( $ conditionalType instanceof AbstractType ) { return $ this -> exeContext -> schema -> isPossibleType ( $ conditionalType , $ type ) ; } return false ; }
8215	protected function getServerStats ( $ pattern = '' ) { $ stats = ( array ) $ this -> getPheanstalk ( ) -> stats ( ) ; if ( ! empty ( $ pattern ) ) { $ stats = array_filter ( $ stats , function ( $ key ) use ( $ pattern ) { return 1 === preg_match ( "/$pattern/i" , $ key ) ; } , ARRAY_FILTER_USE_KEY ) ; } ksort ( $ stats ) ; return $ stats ; }
10883	public function reportException ( \ Exception $ ex ) { $ report = new ErrorStreamReport ( ) ; $ report -> error_group = $ ex -> getMessage ( ) . ':' . $ ex -> getLine ( ) ; $ report -> line_number = $ ex -> getLine ( ) ; $ report -> file_name = $ ex -> getFile ( ) ; $ report -> message = $ ex -> getMessage ( ) ; $ report -> stack_trace = $ ex -> getTraceAsString ( ) ; $ report -> severity = 3 ; return $ this -> report ( $ report ) ; }
7768	public function validate ( array $ data , $ rules = [ ] ) { $ this -> clearErrors ( ) ; $ this -> clearFieldAliases ( ) ; $ data = $ this -> extractFieldAliases ( $ data ) ; if ( empty ( $ rules ) ) { $ rules = $ this -> extractRules ( $ data ) ; $ data = $ this -> extractInput ( $ data ) ; } $ this -> input = $ data ; foreach ( $ this -> before as $ before ) { call_user_func_array ( $ before , [ $ this ] ) ; } foreach ( $ data as $ field => $ value ) { $ fieldRules = explode ( '|' , $ rules [ $ field ] ) ; foreach ( $ fieldRules as $ rule ) { $ continue = $ this -> validateAgainstRule ( $ field , $ value , $ this -> getRuleName ( $ rule ) , $ this -> getRuleArgs ( $ rule ) ) ; if ( ! $ continue ) { break ; } } } return $ this ; }
12979	protected function registerBehaviors ( EventManager $ evm , Configuration $ config ) { $ reader = new AnnotationReader ; if ( $ cache = $ config -> getMetadataCacheImpl ( ) ) { $ reader = new CachedReader ( $ reader , $ cache ) ; } foreach ( $ this -> getConfig ( 'behaviors' , array ( ) ) as $ behavior ) { if ( $ class = DiC :: resolve ( 'doctrine.behavior.' . $ behavior ) ) { $ class -> setAnnotationReader ( $ reader ) ; $ this -> configureBehavior ( $ behavior , $ class ) ; $ evm -> addEventSubscriber ( $ class ) ; } } if ( $ mapping = $ config -> getMetadataDriverImpl ( ) ) { $ type = 'registerMappingIntoDriverChainORM' ; if ( $ this -> getConfig ( 'behavior.superclass' , false ) ) { $ type = 'registerAbstractMappingIntoDriverChainORM' ; } DoctrineExtensions :: $ type ( $ mapping , $ reader ) ; } }
3443	public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; }
11885	public function addPlaceholder ( $ placeholder , $ description , $ sampleValue , $ emptyValue ) { if ( isset ( $ this -> placeholders [ $ placeholder ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Field with same placeholder "%s" already exists in structure' , $ placeholder ) ) ; } $ this -> placeholders [ $ placeholder ] = array ( 'placeholder' => $ placeholder , 'description' => $ description , 'sample' => $ sampleValue , 'empty' => $ emptyValue , ) ; }
9575	protected function resolveStack ( ) { if ( $ this -> stack !== null ) { return $ this -> stack ; } $ this -> stack = new StackBuilder ; foreach ( $ this -> middlewares as $ middleware ) { call_user_func_array ( [ $ this -> stack , 'push' ] , ( array ) $ middleware ) ; } return $ this -> stack ; }
9439	public function alias ( $ id , $ original ) { $ this -> instances [ $ id ] = $ this -> get ( $ original ) ; return $ this ; }
8118	public function Form ( $ object ) { $ placeholder = _t ( __CLASS__ . '.Placeholder' , 'Add comments (optional)' ) ; $ title = _t ( __CLASS__ . '.MarkAsReviewedAction' , 'Mark as reviewed' ) ; $ fields = FieldList :: create ( [ HiddenField :: create ( 'ID' , null , $ object -> ID ) , HiddenField :: create ( 'ClassName' , null , $ object -> baseClass ( ) ) , TextareaField :: create ( 'Review' , '' ) -> setAttribute ( 'placeholder' , $ placeholder ) -> setSchemaData ( [ 'attributes' => [ 'placeholder' => $ placeholder ] ] ) ] ) ; $ action = FormAction :: create ( 'savereview' , $ title ) -> setTitle ( $ title ) -> setUseButtonTag ( false ) -> addExtraClass ( 'review-content__action btn btn-primary' ) ; $ actions = FieldList :: create ( [ $ action ] ) ; $ form = Form :: create ( $ this -> controller , $ this -> name , $ fields , $ actions ) -> setHTMLID ( 'Form_EditForm_ReviewContent' ) -> addExtraClass ( 'form--no-dividers review-content__form' ) ; return $ form ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
6535	protected function hydrate ( $ propertyName ) { if ( isset ( $ this -> yuccaMappingManager ) && ( false === isset ( $ this -> yuccaInitialized [ $ propertyName ] ) ) && ( false === empty ( $ this -> yuccaIdentifier ) ) ) { $ values = $ this -> yuccaMappingManager -> getMapper ( get_class ( $ this ) ) -> load ( $ this -> yuccaIdentifier , $ propertyName , $ this -> yuccaShardingKey ) ; foreach ( $ values as $ property => $ value ) { if ( false === isset ( $ this -> yuccaInitialized [ $ property ] ) ) { $ this -> $ property = $ value ; $ this -> yuccaInitialized [ $ property ] = true ; } } } $ this -> yuccaInitialized [ $ propertyName ] = true ; return $ this ; }
8981	private static function matchesDateCriteria ( $ key , RateInterface $ rate , array $ criteria ) { $ date = self :: extractDateCriteria ( $ key , $ criteria ) ; if ( $ date === null ) { return true ; } if ( $ key === 'dateFrom' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 23 , 59 , 59 ) ; return $ date <= $ rateDate ; } if ( $ key === 'dateTo' ) { $ rateDate = new \ DateTime ( $ rate -> getDate ( ) -> format ( \ DateTime :: ATOM ) ) ; $ rateDate -> setTime ( 0 , 0 , 0 ) ; return $ date >= $ rateDate ; } return $ date -> format ( 'Y-m-d' ) === $ rate -> getDate ( ) -> format ( 'Y-m-d' ) ; }
10912	public function convertDateTimeToUtcTimeZone ( $ inStrictIso8601DtTm ) { $ tmpDateTimeIn = $ this -> convertTimeFromFormatSafely ( $ inStrictIso8601DtTm ) ; $ tmpDateTimeIn -> setTimezone ( new \ DateTimeZone ( 'UTC' ) ) ; return $ tmpDateTimeIn -> format ( 'Y-m-d H:i:s' ) ; }
10449	public function load ( $ config ) { if ( is_string ( $ config ) and file_exists ( $ config ) ) { $ config = include $ config ; } if ( ! is_array ( $ config ) ) { $ msg = 'Failed to load configuration data' ; throw new ConfigurationException ( $ msg ) ; } return new Configuration ( $ config ) ; }
12265	public function findInSourceDirs ( Finder $ finder ) { foreach ( $ this -> sourceDirs as $ dir ) { $ finder -> in ( $ dir ) ; } return $ finder ; }
2652	public function uploadSnippet ( $ version , array $ snippet ) { if ( isset ( $ snippet [ 'content' ] ) ) { $ adminUrl = $ this -> vcl -> getAdminFrontName ( ) ; $ adminPathTimeout = $ this -> config -> getAdminPathTimeout ( ) ; $ ignoredUrlParameters = $ this -> config -> getIgnoredUrlParameters ( ) ; $ ignoredUrlParameterPieces = explode ( "," , $ ignoredUrlParameters ) ; $ filterIgnoredUrlParameterPieces = array_filter ( array_map ( 'trim' , $ ignoredUrlParameterPieces ) ) ; $ queryParameters = implode ( '|' , $ filterIgnoredUrlParameterPieces ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH####' , $ adminUrl , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####ADMIN_PATH_TIMEOUT####' , $ adminPathTimeout , $ snippet [ 'content' ] ) ; $ snippet [ 'content' ] = str_replace ( '####QUERY_PARAMETERS####' , $ queryParameters , $ snippet [ 'content' ] ) ; } $ checkIfExists = $ this -> hasSnippet ( $ version , $ snippet [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ snippet [ 'name' ] ; unset ( $ snippet [ 'name' ] , $ snippet [ 'type' ] , $ snippet [ 'dynamic' ] , $ snippet [ 'priority' ] ) ; } $ result = $ this -> _fetch ( $ url , $ verb , $ snippet ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to upload the Snippet file.' ) ) ; } }
1492	public function current ( $ meta = null , array $ queryParams = [ ] ) { $ url = $ this -> generator -> current ( ) ; if ( $ queryParams ) { $ url .= '?' . http_build_query ( $ queryParams ) ; } return $ this -> factory -> createLink ( $ url , $ meta , true ) ; }
2713	public function getValues ( ) { $ values = [ ] ; $ ratios = $ this -> pixelRatios -> toOptionArray ( ) ; foreach ( $ ratios as $ value ) { $ values [ $ value [ 'value' ] ] = $ value [ 'label' ] ; } return $ values ; }
10188	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> active ) ) $ this -> active = $ xmlElement -> active ; if ( isset ( $ xmlElement -> anonymizable ) ) $ this -> anonymizable = $ xmlElement -> anonymizable ; if ( isset ( $ xmlElement -> description ) ) $ this -> description = $ xmlElement -> description ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> attributes ) ) { $ this -> attributes = array ( ) ; foreach ( $ xmlElement -> attributes -> children ( ) as $ xmlAttribute ) { $ attribute = array ( ) ; if ( isset ( $ xmlAttribute -> name ) ) $ attribute [ 'name' ] = trim ( $ xmlAttribute -> name ) ; if ( isset ( $ xmlAttribute -> datatype ) ) $ attribute [ 'datatype' ] = DataType :: getDataType ( $ xmlAttribute -> datatype ) ; if ( isset ( $ xmlAttribute -> description ) ) $ attribute [ 'description' ] = trim ( $ xmlAttribute -> description ) ; if ( isset ( $ xmlAttribute -> required ) ) $ attribute [ 'required' ] = $ xmlAttribute -> required ; array_push ( $ this -> attributes , $ attribute ) ; } } }
11791	public function setFrom ( $ mail = '' , $ name = null , $ reply = true ) { $ mail = trim ( $ mail ) ; if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { $ this -> from = ! empty ( $ name ) ? array ( $ name => $ mail ) : array ( $ mail ) ; $ this -> getMailer ( ) -> setRegistry ( 'Return-Path' , '<' . $ mail . '>' , 'headers' ) ; $ this -> getMailer ( ) -> setRegistry ( 'X-Sender' , $ mail , 'headers' ) ; if ( $ reply ) { $ this -> setReplyTo ( $ mail , $ name ) ; } } return $ this ; }
615	protected function resolveDependencies ( $ dependencies , $ reflection = null ) { foreach ( $ dependencies as $ index => $ dependency ) { if ( $ dependency instanceof Instance ) { if ( $ dependency -> id !== null ) { $ dependencies [ $ index ] = $ this -> get ( $ dependency -> id ) ; } elseif ( $ reflection !== null ) { $ name = $ reflection -> getConstructor ( ) -> getParameters ( ) [ $ index ] -> getName ( ) ; $ class = $ reflection -> getName ( ) ; throw new InvalidConfigException ( "Missing required parameter \"$name\" when instantiating \"$class\"." ) ; } } } return $ dependencies ; }
7292	public function get_users_by_meta ( $ meta_key , $ meta_value = '' , $ meta_compare = '' , $ include_empty = FALSE ) { if ( $ include_empty ) { if ( in_array ( $ meta_compare , array ( '<>' , '!=' ) ) ) { $ meta_compare = '=' ; } else { $ meta_compare = '!=' ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'ID' ) ) ; $ exclude_users = $ query -> get_results ( ) ; $ query = new WP_User_Query ( array ( 'fields' => 'all_with_meta' , 'exclude' => $ exclude_users ) ) ; return $ query -> get_results ( ) ; } $ query = new WP_User_Query ( array ( 'meta_key' => $ meta_key , 'meta_value' => $ meta_value , 'meta_compare' => $ meta_compare , 'fields' => 'all_with_meta' ) ) ; return $ query -> get_results ( ) ; }
6521	public function boot ( ) { $ this -> app -> when ( SmsGatewayChannel :: class ) -> needs ( SmsGatewayClient :: class ) -> give ( function ( ) { $ config = $ this -> app [ 'config' ] [ 'services.smsgateway' ] ; return new SmsGatewayClient ( new HttpClient , $ config [ 'email' ] , $ config [ 'password' ] , $ config [ 'device' ] ) ; } ) ; }
4238	public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; }
2818	public function getModelsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getModels ( ) as $ model ) { $ data [ ] = array ( 'resource_name' => $ model -> getResource ( ) , 'class' => $ model -> getClass ( ) , 'count' => $ model -> getCount ( ) ) ; } return $ data ; }
9430	public function getFontIconTag ( ) { if ( $ this -> owner -> hasFontIcon ( ) ) { return $ this -> backend -> getTag ( $ this -> owner -> FontIconClass , $ this -> owner -> FontIconColor ) ; } }
4531	public function process ( ContainerBuilder $ container ) { $ definition = $ container -> findDefinition ( LoaderCollection :: class ) ; $ services = $ container -> findTaggedServiceIds ( 'ds_tenant.loader' ) ; $ items = [ ] ; foreach ( $ services as $ id => $ tags ) { foreach ( $ tags as $ tag ) { $ items [ ] = [ 'id' => $ id , 'priority' => array_key_exists ( 'priority' , $ tag ) ? $ tag [ 'priority' ] : 0 , 'alias' => array_key_exists ( 'alias' , $ tag ) ? $ tag [ 'alias' ] : null ] ; } } usort ( $ items , function ( $ a , $ b ) { return $ a [ 'priority' ] === $ b [ 'priority' ] ? 0 : $ a [ 'priority' ] < $ b [ 'priority' ] ? - 1 : 1 ; } ) ; foreach ( $ items as $ item ) { if ( null !== $ item [ 'alias' ] ) { $ definition -> addMethodCall ( 'set' , [ $ item [ 'alias' ] , new Reference ( $ item [ 'id' ] ) ] ) ; } else { $ definition -> addMethodCall ( 'add' , [ new Reference ( $ item [ 'id' ] ) ] ) ; } } }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
7547	function getEncoding ( ) { $ root = $ this -> getRoot ( ) ; if ( $ root !== null ) { if ( $ enc = $ root -> select ( 'meta[charset]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "charset" ) ; } elseif ( $ enc = $ root -> select ( '"?xml"[encoding]' , 0 , true , true ) ) { return $ enc -> getAttribute ( "encoding" ) ; } elseif ( $ enc = $ root -> select ( 'meta[content*="charset="]' , 0 , true , true ) ) { $ enc = $ enc -> getAttribute ( "content" ) ; return substr ( $ enc , strpos ( $ enc , "charset=" ) + 8 ) ; } } return false ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
8140	public function createTemplate ( $ template ) { $ name = sprintf ( '__string_template__%s' , hash ( 'sha256' , $ template , false ) ) ; $ loader = new Twig_Loader_Chain ( array ( new Twig_Loader_Array ( array ( $ name => $ template ) ) , $ current = $ this -> getLoader ( ) , ) ) ; $ this -> setLoader ( $ loader ) ; try { $ template = $ this -> loadTemplate ( $ name ) ; } catch ( Exception $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } catch ( Throwable $ e ) { $ this -> setLoader ( $ current ) ; throw $ e ; } $ this -> setLoader ( $ current ) ; return $ template ; }
11207	public function getIterator ( ) { if ( ! $ this -> content || $ this -> contentModified ) { $ this -> generateContent ( ) ; } return new \ ArrayIterator ( $ this -> content ) ; }
11298	public function getModelsFromCustomRelationship ( $ attributeName , $ objName , $ query = false , $ loadMap = false ) { $ repo = \ Cora \ RepositoryFactory :: make ( $ objName , false , false , false , $ this -> model_db ) ; if ( ! $ query ) $ query = $ this -> _getQueryObjectForRelation ( $ attributeName ) ; $ definingFunctionName = $ this -> model_attributes [ $ attributeName ] [ 'using' ] ; $ query = $ this -> $ definingFunctionName ( $ query ) ; return $ repo -> findAll ( $ query , false , $ loadMap ) ; }
1240	private static function propertyToXml ( $ name , $ value ) { if ( is_subclass_of ( $ value , '\DTS\eBaySDK\Types\BaseType' , false ) ) { return $ value -> toXml ( $ name ) ; } else { return sprintf ( '<%s>%s</%s>' , $ name , self :: encodeValueXml ( $ value ) , $ name ) ; } }
8339	public static function get ( string $ fileName ) : array { if ( isset ( self :: $ files [ $ fileName ] ) === false ) { if ( ( $ content = file_get_contents ( $ fileName ) ) === false ) { throw new FileNotReadable ( 'file "' . $ fileName . '" can\'t be read' ) ; } $ content = ( string ) $ content ; try { $ content = Yaml :: parse ( $ content ) ; } catch ( ParseException $ e ) { throw new FileNotParsable ( 'file "' . $ fileName . '" can\'t be parsed' ) ; } self :: $ files [ $ fileName ] = $ content ; } return self :: $ files [ $ fileName ] ; }
167	protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; }
7520	function parse_cdata ( ) { if ( $ this -> next_pos ( ']]>' , false ) === self :: TOK_UNKNOWN ) { $ this -> status [ 'cdata' ] = $ this -> getTokenString ( 9 , - 1 ) ; $ this -> status [ 'last_pos' ] = $ this -> pos + 2 ; return true ; } else { $ this -> addError ( 'Invalid cdata tag' ) ; return false ; } }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
2947	public function grant ( $ permission ) { if ( $ this -> hasPermission ( $ permission ) ) { return true ; } if ( ! array_key_exists ( $ permission , Gate :: abilities ( ) ) ) { abort ( 403 , 'Unknown permission' ) ; } return Permission :: create ( [ 'role_id' => $ this -> id , 'permission_slug' => $ permission , ] ) ; return false ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
8998	public function exists ( ) : bool { if ( ! file_exists ( $ this -> path ) ) { return false ; } if ( ! is_dir ( $ this -> path ) ) { throw new DirectoryException ( "Entry {path} exists, but it is not a directory!" , array ( 'path' => $ this -> path ) ) ; } return true ; }
1792	private function addHostToContext ( RequestContext $ context , array $ parameters , int & $ referenceType ) : void { [ $ host , $ port ] = $ this -> getHostAndPort ( $ parameters [ '_domain' ] ) ; if ( $ context -> getHost ( ) === $ host ) { return ; } $ context -> setHost ( $ host ) ; $ referenceType = UrlGeneratorInterface :: ABSOLUTE_URL ; if ( ! $ port ) { return ; } if ( isset ( $ parameters [ '_ssl' ] ) && true === $ parameters [ '_ssl' ] ) { $ context -> setHttpsPort ( $ port ) ; } else { $ context -> setHttpPort ( $ port ) ; } }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
3983	private function buildBackendMenuSection ( $ groupName , Request $ request ) { $ strRefererId = $ request -> attributes -> get ( '_contao_referer_id' ) ; $ label = $ this -> translator -> trans ( 'MOD.' . $ groupName , [ ] , 'contao_modules' ) ; if ( \ is_array ( $ label ) ) { $ label = $ label [ 0 ] ; } return [ 'class' => ' node-expanded' , 'title' => StringUtil :: specialchars ( $ this -> translator -> trans ( 'MSC.collapseNode' , [ ] , 'contao_modules' ) ) , 'label' => $ label , 'href' => $ this -> urlGenerator -> generate ( 'contao_backend' , [ 'do' => $ request -> get ( 'do' ) , 'mtg' => $ groupName , 'ref' => $ strRefererId ] ) , 'ajaxUrl' => $ this -> urlGenerator -> generate ( 'contao_backend' ) , 'icon' => 'modPlus.gif' , 'modules' => [ ] , ] ; }
5360	protected function createBodyStatements ( Operation $ operation , $ queryParamVariable , Context $ context ) { $ bodyParameter = null ; $ bodyVariable = new Expr \ Variable ( 'body' ) ; $ parameterKey = 0 ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof BodyParameter ) { $ bodyParameter = $ parameter ; $ parameterKey = $ key ; } } } if ( null === $ bodyParameter ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( $ queryParamVariable , 'buildFormDataString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] , $ bodyVariable ] ; } if ( $ bodyParameter -> getSchema ( ) instanceof Reference || $ context -> getRegistry ( ) -> hasClass ( $ operation -> getReference ( ) . '/parameters/' . $ parameterKey ) ) { return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ MethodCall ( new Expr \ PropertyFetch ( new Expr \ Variable ( 'this' ) , 'serializer' ) , 'serialize' , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) , new Arg ( new Scalar \ String_ ( 'json' ) ) ] ) ) ] , $ bodyVariable ] ; } return [ [ new Expr \ Assign ( $ bodyVariable , new Expr \ Variable ( Inflector :: camelize ( $ bodyParameter -> getName ( ) ) ) ) ] , $ bodyVariable ] ; }
3820	private function perform ( $ table , Request $ request , $ metaModel , $ parentId ) { $ activate = ( bool ) $ request -> request -> get ( 'activate' ) ; $ query = $ this -> connection -> createQueryBuilder ( ) -> insert ( $ table ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( $ this -> knowsAttribute ( $ attribute ) || ! ( $ this -> accepts ( $ attribute ) && $ this -> isAttributeSubmitted ( $ attribute -> get ( 'id' ) , $ request ) ) ) { continue ; } $ data = [ ] ; foreach ( $ this -> createEmptyDataFor ( $ attribute , $ parentId , $ activate , $ this -> startSort ) as $ key => $ value ) { $ data [ $ key ] = ':' . $ key ; $ query -> setParameter ( $ key , $ value ) ; } $ query -> values ( $ data ) -> execute ( ) ; $ this -> startSort += 128 ; } $ this -> purger -> purge ( ) ; }
121	private function createAuthFromConfig ( ) { if ( ! $ this -> config -> has ( 'http-basic' ) ) { return $ this -> hasAuth = false ; } $ authConfig = $ this -> config -> get ( 'http-basic' ) ; $ host = parse_url ( $ this -> url , PHP_URL_HOST ) ; if ( isset ( $ authConfig [ $ host ] ) ) { $ this -> credentials [ 'username' ] = $ authConfig [ $ host ] [ 'username' ] ; $ this -> credentials [ 'password' ] = $ authConfig [ $ host ] [ 'password' ] ; return $ this -> hasAuth = true ; } return $ this -> hasAuth = false ; }
7132	protected function updateExchangeRate ( SupplierOrderInterface $ order ) { if ( null !== $ order -> getExchangeRate ( ) ) { return false ; } if ( ! SupplierOrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ order -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ order -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
566	public function setScriptFile ( $ value ) { $ scriptFile = realpath ( Yii :: getAlias ( $ value ) ) ; if ( $ scriptFile !== false && is_file ( $ scriptFile ) ) { $ this -> _scriptFile = $ scriptFile ; } else { throw new InvalidConfigException ( 'Unable to determine the entry script file path.' ) ; } }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
7473	public function editAction ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ user = $ em -> getRepository ( 'Orkestra\Bundle\ApplicationBundle\Entity\User' ) -> find ( $ id ) ; if ( ! $ user ) { throw $ this -> createNotFoundException ( 'Unable to locate User' ) ; } $ form = $ this -> createForm ( UserType :: class , $ user , array ( 'include_password' => false ) ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) , ) ; }
2204	public static function encodeSpecialChars ( $ varValue ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: encodeSpecialChars ( $ v ) ; } return $ varValue ; } $ arrSearch = array ( '#' , '<' , '>' , '(' , ')' , '\\' , '=' ) ; $ arrReplace = array ( '&#35;' , '&#60;' , '&#62;' , '&#40;' , '&#41;' , '&#92;' , '&#61;' ) ; return str_replace ( $ arrSearch , $ arrReplace , $ varValue ) ; }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
3819	private function checkboxCaption ( $ key , $ table , IAttribute $ attribute ) { return $ this -> translator -> trans ( $ table . '.' . $ key , [ $ attribute -> getName ( ) ] , 'contao_' . $ table ) ; }
1368	protected function bindService ( ) { $ this -> app -> singleton ( JsonApiService :: class ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api' ) ; $ this -> app -> alias ( JsonApiService :: class , 'json-api.service' ) ; }
5552	public function getResponseCode ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getResponseCode ( ) ; } return $ this -> frameset -> getResponseCode ( ) ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
3369	private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
12532	public function update ( array $ deviceIdentifier , $ comment ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'comment' => $ comment , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_UPDATE , $ params ] ) ; }
5080	public function postIndex ( ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ this -> userCan ( static :: ACTION_CREATE ) ; $ aData = $ oInput -> post ( ) ; if ( empty ( $ aData ) ) { $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; } $ aData = $ this -> validateUserInput ( $ aData ) ; $ iItemId = $ this -> oModel -> create ( $ aData ) ; if ( empty ( $ iItemId ) ) { throw new ApiException ( 'Failed to create resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } $ oItem = $ this -> oModel -> getById ( $ iItemId , static :: CONFIG_LOOKUP_DATA ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
2610	public function determineVersions ( array $ versions ) { $ activeVersion = null ; $ nextVersion = null ; if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { $ activeVersion = $ version -> number ; } } $ nextVersion = ( int ) end ( $ versions ) -> number + 1 ; } return [ 'active_version' => $ activeVersion , 'next_version' => $ nextVersion ] ; }
5754	protected function setIndexFilter ( Request $ request , Response $ response , $ args , array $ listViewColumns , AdminListView $ view ) { $ this -> setRequestInput ( $ request , [ $ view -> getSessionFilterFieldKey ( ) ] ) ; if ( ! isset ( $ this -> requestInput [ $ view -> getSessionFilterFieldKey ( ) ] ) ) { throw new \ Exception ( "session filter input must be set" ) ; } $ this -> storeFilterFieldValueInSession ( $ view ) ; if ( null !== $ filterColumnsInfo = $ this -> getFilterColumns ( $ view -> getSessionFilterFieldKey ( ) , $ listViewColumns ) ) { $ this -> storeFilterColumnsInfoInSession ( $ filterColumnsInfo , $ view ) ; } }
3795	private function checkEmpty ( $ action ) { if ( $ this -> hasVariants ( ) && $ this -> currentModel !== null ) { $ this -> disablePA = false ; } elseif ( $ action == 'create' ) { $ this -> disablePA = false ; $ this -> disablePI = false ; } }
828	private function isValidVariable ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_VARIABLE ) ) { return false ; } $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ index ) ; return $ tokens [ $ nextIndex ] -> equals ( '=' ) ; }
5492	protected function renderArguments ( $ args ) { $ descriptions = array ( ) ; if ( is_array ( $ args ) ) { foreach ( $ args as $ arg ) { $ dumper = new SimpleDumper ( ) ; $ descriptions [ ] = $ dumper -> describeValue ( $ arg ) ; } } return implode ( ', ' , $ descriptions ) ; }
4784	public function handle ( $ message , callable $ next ) { try { $ next ( $ message ) ; } catch ( UndefinedCallable $ exception ) { $ this -> logger -> log ( $ this -> logLevel , 'No message handler found, trying to handle it asynchronously' , [ 'type' => get_class ( $ message ) ] ) ; $ this -> publisher -> publish ( $ message ) ; } }
11420	protected function getCache ( $ pk ) { $ app = App :: getInstance ( ) ; return $ app [ 'cache' ] -> getItem ( $ this -> dbtable . '/' . $ pk -> getValue ( ) ) ; }
5388	protected function valuesArePossible ( $ values ) { $ matches = array ( ) ; $ widgets = & $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { $ possible = $ widgets [ $ i ] -> getAttribute ( 'value' ) ; if ( in_array ( $ possible , $ values ) ) { $ matches [ ] = $ possible ; } } return ( $ values == $ matches ) ; }
2522	protected function callMessage ( $ messageName , $ options , $ messageOptions , $ endSession = false ) { $ messageOptions = $ this -> makeMessageOptions ( $ messageOptions , $ endSession ) ; $ this -> lastMessage = $ messageName ; $ sendResult = $ this -> sessionHandler -> sendMessage ( $ messageName , $ this -> requestCreator -> createRequest ( $ messageName , $ options ) , $ messageOptions ) ; $ response = $ this -> responseHandler -> analyzeResponse ( $ sendResult , $ messageName ) ; if ( $ messageOptions [ 'returnXml' ] === false ) { $ response -> responseXml = null ; } return $ response ; }
5261	public function mergeQuery ( array $ query ) { $ types = [ Filter :: MERGE_AND => 'must' , Filter :: MERGE_OR => 'should' ] ; $ type = $ this -> getMergeType ( ) ; $ query [ 'body' ] [ 'filter' ] [ 'bool' ] [ $ types [ $ type ] ] [ ] = $ this -> makeQuery ( ) ; return $ query ; }
12458	private function createCommentForm ( CommentFront $ model , $ entity ) { $ form = $ this -> createForm ( 'BlogBundle\Form\CommentFrontType' , $ model , array ( 'action' => $ this -> generateUrl ( 'blog_blog_comment' , array ( 'post' => $ entity -> getId ( ) ) ) , 'method' => 'POST' , 'attr' => array ( 'id' => 'comment-form' , 'class' => 'comment-form' ) ) ) ; return $ form ; }
9827	public function setPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> password = $ pValue ; return $ this ; }
7751	protected function loadMetadata ( $ className ) { if ( false === isset ( $ this -> loadedMetadata [ $ className ] ) ) { if ( null === ( $ class = $ this -> driver -> loadMetadataForClass ( $ className ) ) ) { throw new \ Exception ( "Can't load metadata for $className" ) ; } $ this -> completeMetadata ( $ class ) ; $ this -> loadedMetadata [ $ className ] = $ class ; } return $ this -> loadedMetadata [ $ className ] ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
10281	public static function absoluteCoordinate ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } list ( $ column , $ row ) = self :: coordinateFromString ( $ pCoordinateString ) ; $ column = ltrim ( $ column , '$' ) ; $ row = ltrim ( $ row , '$' ) ; return $ worksheet . '$' . $ column . '$' . $ row ; }
3541	public static function getGroupAssigmentOptions ( $ optionName , $ individualGroupAssignmentOptions = null ) { if ( $ individualGroupAssignmentOptions != null && is_array ( $ individualGroupAssignmentOptions ) && array_key_exists ( $ optionName , $ individualGroupAssignmentOptions ) ) { return $ individualGroupAssignmentOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-Group-Assignment-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX ) ) { return static :: GROUP_ASSIGNMENT_TOUCH_ONLY_MATCHING_REGEX [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Group-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
11618	private function compressPhase2 ( $ calcIdWriteOff , $ calcIdPhase1 , $ calcIdPhase2 , $ scheme ) { $ pv = $ this -> rouGetPv -> exec ( $ calcIdWriteOff ) ; $ dwnlPlain = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdWriteOff ) ; $ dwnlPhase1 = $ this -> daoBonDwnl -> getByCalcId ( $ calcIdPhase1 ) ; $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_CALC_ID_PHASE2 , $ calcIdPhase2 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_SCHEME , $ scheme ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PLAIN , $ dwnlPlain ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_DWNL_PHASE1 , $ dwnlPhase1 ) ; $ ctx -> set ( PCpmrsPhase2 :: IN_MAP_PV , $ pv ) ; $ out = $ this -> procCmprsPhase2 -> exec ( $ ctx ) ; $ dwnlPhase2 = $ out -> get ( PCpmrsPhase2 :: OUT_DWNL_PHASE2 ) ; $ legs = $ out -> get ( PCpmrsPhase2 :: OUT_LEGS ) ; $ result = [ $ dwnlPhase2 , $ legs ] ; return $ result ; }
8526	public function listFinancialEventGroups ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1526	protected function doUpdate ( StoreInterface $ store , UpdateResource $ request ) { if ( $ response = $ this -> beforeCommit ( $ request ) ) { return $ response ; } $ record = $ store -> updateRecord ( $ request -> getRecord ( ) , $ request -> all ( ) , $ request -> getParameters ( ) ) ; return $ this -> afterCommit ( $ request , $ record , true ) ? : $ record ; }
3835	protected function prepareTemplate ( Template $ objTemplate , $ arrRowData , $ objSettings ) { $ objTemplate -> setData ( array ( 'attribute' => $ this , 'settings' => $ objSettings , 'row' => $ arrRowData , 'raw' => $ arrRowData [ $ this -> getColName ( ) ] , 'additional_class' => $ objSettings -> get ( 'additional_class' ) ? ' ' . $ objSettings -> get ( 'additional_class' ) : '' ) ) ; }
12251	public function getNode ( $ strName , $ varDefault = false ) { $ varResult = $ this -> $ strName ; if ( ( $ varResult !== false ) && ( ( string ) $ varResult !== '' ) ) { return ( string ) $ varResult ; } else { return $ varDefault ; } }
12701	public function setEditorConfig ( $ config ) { if ( $ config instanceof Traversable ) { $ config = ArrayUtils :: iteratorToArray ( $ config ) ; } if ( ! is_array ( $ config ) ) { throw new InvalidArgumentException ( 'The options parameter must be an array or a Traversable' ) ; } $ this -> editorConfig = $ config ; return $ this ; }
12329	public function enqueue_style ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue style, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ media = $ options -> get_media ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_enqueue_style ( $ handle , $ source , $ dependencies , $ version , $ media ) ; }
12441	public function attach ( $ key , $ instance , $ type = self :: OBJECT ) { switch ( $ type ) { case self :: OBJECT : case self :: CACHE : if ( ! is_object ( $ instance ) ) { throw new \ LogicException ( 'Instance is not an object!' ) ; } break ; case self :: DATABASE : if ( ! ( $ instance instanceof \ PDO ) ) { throw new \ LogicException ( ) ; } break ; } if ( isset ( $ this -> instances [ $ key ] ) ) { return $ this ; } $ this -> instances [ $ key ] = $ instance ; return $ this ; }
4845	protected static function call ( $ method , $ url , $ params = array ( ) ) { $ ch = curl_init ( ) ; $ curl_options = array ( CURLOPT_CONNECTTIMEOUT => 10 , CURLOPT_RETURNTRANSFER => true , CURLOPT_TIMEOUT => 60 , CURLOPT_USERAGENT => 'gocardless-php/v' . GoCardless :: VERSION , ) ; if ( isset ( $ params [ 'ua_tag' ] ) ) { $ curl_options [ CURLOPT_USERAGENT ] .= ' ' . $ params [ 'ua_tag' ] ; unset ( $ params [ 'ua_tag' ] ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Accept: application/json' ; $ curl_options [ CURLOPT_SSL_VERIFYPEER ] = true ; if ( isset ( $ params [ 'http_authorization' ] ) ) { $ curl_options [ CURLOPT_USERPWD ] = $ params [ 'http_authorization' ] ; unset ( $ params [ 'http_authorization' ] ) ; } else { if ( ! isset ( $ params [ 'http_bearer' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Authorization: Bearer ' . $ params [ 'http_bearer' ] ; unset ( $ params [ 'http_bearer' ] ) ; } if ( $ method == 'post' ) { $ curl_options [ CURLOPT_POST ] = 1 ; if ( ! empty ( $ params ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'get' ) { $ curl_options [ CURLOPT_HTTPGET ] = 1 ; if ( ! empty ( $ params ) ) { $ url .= '?' . http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'put' ) { $ curl_options [ CURLOPT_PUT ] = 1 ; $ fh = fopen ( 'php://memory' , 'rw+' ) ; $ curl_options [ CURLOPT_INFILE ] = $ fh ; $ curl_options [ CURLOPT_INFILESIZE ] = 0 ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt_array ( $ ch , $ curl_options ) ; $ result = curl_exec ( $ ch ) ; $ error = curl_errno ( $ ch ) ; if ( $ error == CURLE_SSL_PEER_CERTIFICATE || $ error == CURLE_SSL_CACERT || $ error == 77 ) { curl_setopt ( $ ch , CURLOPT_CAINFO , dirname ( __FILE__ ) . '/cert-bundle.crt' ) ; $ result = curl_exec ( $ ch ) ; } $ http_response_code = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( $ http_response_code < 200 || $ http_response_code > 300 ) { $ message = print_r ( json_decode ( $ result , true ) , true ) ; throw new GoCardless_ApiException ( $ message , $ http_response_code , $ result ) ; } curl_close ( $ ch ) ; if ( isset ( $ fh ) ) { fclose ( $ fh ) ; } return json_decode ( $ result , true ) ; }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
8234	protected function isExpired ( array $ tokenData , $ tokenValidity = null ) { return time ( ) > $ tokenData [ 'time' ] + ( ( $ tokenValidity !== null ) ? $ tokenValidity : self :: TOKEN_VALIDITY ) ; }
3236	public function getTotalPriceAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> totalPrice , 2 ) ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
12663	static public function getMessage ( $ code = self :: CODE_INTERNAL_SERVER_ERROR ) { if ( isset ( self :: $ messages [ $ code ] ) ) { return self :: $ messages [ $ code ] ; } return self :: $ messages [ self :: CODE_INTERNAL_SERVER_ERROR ] ; }
12283	public function render ( array $ data = null ) : string { $ this -> init ( $ data ?? [ ] ) ; return trim ( $ this -> make ( static :: LAYOUT_NAME ) ) . PHP_EOL ; }
12431	protected function generateContentTypeFilter ( $ contentType ) { $ filter = null ; if ( ! is_null ( $ contentType ) && '' != $ contentType ) { $ filter = array ( 'contentType' => $ contentType ) ; } return $ filter ; }
71	protected function filterPackageMap ( array $ packageMap , PackageInterface $ mainPackage ) { $ packages = array ( ) ; $ include = array ( ) ; foreach ( $ packageMap as $ item ) { $ package = $ item [ 0 ] ; $ name = $ package -> getName ( ) ; $ packages [ $ name ] = $ package ; } $ add = function ( PackageInterface $ package ) use ( & $ add , $ packages , & $ include ) { foreach ( $ package -> getRequires ( ) as $ link ) { $ target = $ link -> getTarget ( ) ; if ( ! isset ( $ include [ $ target ] ) ) { $ include [ $ target ] = true ; if ( isset ( $ packages [ $ target ] ) ) { $ add ( $ packages [ $ target ] ) ; } } } } ; $ add ( $ mainPackage ) ; return array_filter ( $ packageMap , function ( $ item ) use ( $ include ) { $ package = $ item [ 0 ] ; foreach ( $ package -> getNames ( ) as $ name ) { if ( isset ( $ include [ $ name ] ) ) { return true ; } } return false ; } ) ; }
3509	private static function renderToTextFromOpcode ( $ opcode , $ from , $ from_offset , $ from_len ) { if ( $ opcode === 'c' || $ opcode === 'i' ) { echo substr ( $ from , $ from_offset , $ from_len ) ; } }
12289	private function make ( string $ block , array $ vars = null ) : string { $ commonVars = static :: COMMON_NAME . static :: VARS_PROPERTY_SUFFIX ; $ blockVars = $ block . static :: VARS_PROPERTY_SUFFIX ; $ allVars = [ ] ; if ( isset ( $ this -> $ commonVars ) && is_array ( $ this -> $ commonVars ) ) { $ allVars = $ this -> $ commonVars ; } if ( isset ( $ this -> $ blockVars ) && is_array ( $ this -> $ blockVars ) ) { $ allVars += $ this -> $ blockVars ; } if ( isset ( $ vars ) ) { $ allVars += $ vars ; } $ file = $ this -> path . $ this -> { $ block . static :: BLOCK_PROPERTY_SUFFIX } . '.' . static :: FILE_EXTENSION ; $ localScope = function ( $ vars , $ file ) { ob_start ( ) ; extract ( $ vars ) ; try { require $ file ; } catch ( \ Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } $ _ = isset ( $ _ ) ? str_pad ( '' , $ _ ) : '' ; return str_replace ( PHP_EOL , PHP_EOL . $ _ , PHP_EOL . ob_get_clean ( ) ) ; } ; return $ localScope ( $ allVars , $ file ) ; }
406	public function getIsFlash ( ) { $ userAgent = $ this -> headers -> get ( 'User-Agent' , '' ) ; return stripos ( $ userAgent , 'Shockwave' ) !== false || stripos ( $ userAgent , 'Flash' ) !== false ; }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
10861	protected function createObjectUsingFactory ( string $ typeName , Factory $ factory , ? bool $ nullable = false ) : ? object { $ this -> underConstruction [ $ typeName ] = true ; try { $ object = ( $ factory -> callback ) ( ... $ this -> populateArguments ( $ factory -> getReflection ( ) , null , $ typeName ) ) ; if ( ! $ object instanceof $ typeName ) { if ( $ object === null && $ nullable ) { return null ; } $ type = \ is_object ( $ object ) ? \ get_class ( $ object ) : \ gettype ( $ object ) ; throw new ContainerException ( \ sprintf ( 'Factory must return an instance of %s, returned value is %s' , $ typeName , $ type ) ) ; } } finally { unset ( $ this -> underConstruction [ $ typeName ] ) ; } return $ object ; }
10568	public function create ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter = self :: SORT , array $ defaultSort = [ ] ) : Pagination { $ offset = 0 ; $ max = PHP_INT_MAX ; $ params = $ request -> getQueryParams ( ) ; $ range = $ request -> getHeaderLine ( self :: RANGE ) ; if ( $ range !== null && preg_match ( self :: REGEX_RANGE , $ range , $ rm ) ) { $ offset = ( int ) $ rm [ 1 ] ; $ max = ( int ) $ rm [ 2 ] - $ offset + 1 ; } else { $ max = $ this -> parse ( self :: $ maxAlias , $ params , PHP_INT_MAX ) ; $ offVal = $ this -> parse ( self :: $ offsetAlias , $ params , 0 ) ; if ( $ offVal > 0 ) { $ offset = $ offVal ; } elseif ( isset ( $ params [ self :: START_INDEX ] ) ) { $ startIdx = isset ( $ params [ self :: START_INDEX ] ) ? ( int ) $ params [ self :: START_INDEX ] : 0 ; if ( $ startIdx > 0 ) { $ offset = $ startIdx - 1 ; } } elseif ( isset ( $ params [ self :: START_PAGE ] ) || isset ( $ params [ self :: PAGE ] ) ) { $ startPage = $ this -> parse ( self :: $ pageAlias , $ params , 0 ) ; if ( $ startPage > 0 ) { $ offset = ( $ max * ( $ startPage - 1 ) ) ; } } } return new Pagination ( $ max , $ offset , $ this -> getOrder ( $ request , $ sortParameter , $ defaultSort ) ) ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
3304	public function appendSignature ( array $ params = [ ] , $ timestamp = '' , $ noncestr = '' ) { $ params += [ 'app_id' => $ this -> appId , 'time_stamp' => $ timestamp ? : time ( ) , 'nonce_str' => $ noncestr ? : md5 ( uniqid ( ) ) ] ; if ( isset ( $ params [ 'app_key' ] ) ) { unset ( $ params [ 'app_key' ] ) ; } ksort ( $ params ) ; $ params [ 'sign' ] = strtoupper ( md5 ( http_build_query ( $ params + [ 'app_key' => $ this -> appKey ] ) ) ) ; return $ params ; }
1279	private function extractSpaceId ( array $ data ) : string { if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Space' === $ data [ 'sys' ] [ 'type' ] ) { return $ data [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'sys' ] [ 'type' ] ) && 'Environment' === $ data [ 'sys' ] [ 'type' ] ) { return $ this -> spaceId ; } if ( isset ( $ data [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] ) ) { return $ data [ 'items' ] [ 0 ] [ 'sys' ] [ 'space' ] [ 'sys' ] [ 'id' ] ; } if ( isset ( $ data [ 'items' ] ) && ! $ data [ 'items' ] ) { return $ this -> spaceId ; } return '[blank]' ; }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
3834	public function hookAdditionalFormatters ( $ arrBaseFormatted , $ arrRowData , $ strOutputFormat , $ objSettings ) { $ arrResult = $ arrBaseFormatted ; if ( isset ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) && is_array ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] ) ) { foreach ( $ GLOBALS [ 'METAMODEL_HOOKS' ] [ 'parseValue' ] as $ callback ) { list ( $ strClass , $ strMethod ) = $ callback ; $ objCallback = ( in_array ( 'getInstance' , get_class_methods ( $ strClass ) ) ) ? call_user_func ( array ( $ strClass , 'getInstance' ) ) : new $ strClass ( ) ; $ arrResult = $ objCallback -> $ strMethod ( $ this , $ arrResult , $ arrRowData , $ strOutputFormat , $ objSettings ) ; } } return $ arrResult ; }
3529	public static function sendUnrealClientGetRequest ( $ endpoint , $ authorization = self :: EPIC_LAUNCHER_AUTHORIZATION , $ oauth = false ) { $ client = new Client ( ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => [ 'User-Agent' => self :: UNREAL_CLIENT_USER_AGENT , 'Authorization' => ( ! $ oauth ) ? 'basic ' . $ authorization : 'bearer ' . $ authorization ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
1990	protected function jumpToOrReload ( $ intId , $ strParams = null , $ strForceLang = null ) { if ( $ strForceLang !== null ) { @ trigger_error ( 'Using Frontend::jumpToOrReload() with $strForceLang has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; } global $ objPage ; $ blnForceRedirect = ( $ strParams !== null || $ strForceLang !== null ) ; if ( \ is_array ( $ intId ) ) { $ intId = $ intId [ 'id' ] ?? 0 ; } if ( $ intId > 0 && ( $ intId != $ objPage -> id || $ blnForceRedirect ) && ( $ objNextPage = PageModel :: findPublishedById ( $ intId ) ) !== null ) { $ this -> redirect ( $ objNextPage -> getFrontendUrl ( $ strParams , $ strForceLang ) ) ; } $ this -> reload ( ) ; }
5826	public function setJson ( $ toggle ) { $ this -> setEncoding ( $ toggle ? Request :: ENCODING_JSON : Request :: ENCODING_QUERY ) ; return $ this ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
4881	public function getContent ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getBytes ( ) ; } return null ; }
7037	protected static function computeDependencies ( array $ tables ) { $ result = [ ] ; while ( ! empty ( $ tables ) ) { $ num = count ( $ tables ) ; foreach ( $ tables as $ i => $ table ) if ( ! $ table -> dependent ( ) ) { $ result [ ] = $ table ; unset ( $ tables [ $ i ] ) ; foreach ( $ tables as $ t ) $ t -> removeDependency ( $ table -> name ( ) ) ; } if ( count ( $ tables ) === $ num ) return false ; } return $ result ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
4128	protected function loadMetadata ( $ className ) { if ( class_exists ( $ className ) ) { return parent :: loadMetadata ( $ className ) ; } throw MappingException :: classNotFound ( $ className ) ; }
12734	public function unregister ( Listener $ register ) { $ id = $ register -> id ; $ success = false ; if ( isset ( $ this -> _byId [ $ id ] ) ) { unset ( $ this -> _byId [ $ id ] ) ; $ success = true ; } foreach ( $ this -> _bySignal as $ signal => $ reg ) { if ( isset ( $ reg [ $ id ] ) ) { unset ( $ this -> _bySignal [ $ signal ] [ $ id ] ) ; } } return $ success ; }
12167	private function createMenuGroupTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?menu_group`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?menu_group` ( `menu_group_id` int(11) NOT NULL AUTO_INCREMENT, `menu_group_title` varchar(45) NOT NULL, `menu_group_order` int(11) NOT NULL DEFAULT '0', `menu_group_uid` varchar(45) NOT NULL, `menu_group_iscore` TINYINT(1) NOT NULL DEFAULT '0', PRIMARY KEY (`menu_group_id`), UNIQUE KEY `menu_group_id_UNIQUE` (`menu_group_id`), UNIQUE KEY `menu_group_uid_UNIQUE` (`menu_group_uid`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=6 ; " ) ; $ this -> database -> query ( "INSERT INTO `?menu_group` (`menu_group_id`, `menu_group_title`, `menu_group_order`, `menu_group_uid`, `menu_group_iscore`) VALUES (1, 'Media Menu', 1, 'mediamenu', 1), (2, 'User Menu', 2, 'usermenu', 1), (3, 'Dashboard Menu', 3, 'dashboardmenu', 1), (4, 'Messages Menu', 4, 'messagesmenu', 1), (5, 'Profile Menu', 5, 'profilemenu', 1), (6, 'People Menu', 6, 'peoplemenu', 1);" ) ; }
7754	public function deserialize ( $ data , $ type , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Deserialization for the format ' . $ format . ' is not supported' ) ; } $ reflectionClass = new \ ReflectionClass ( $ type ) ; if ( null !== ( $ constructor = $ reflectionClass -> getConstructor ( ) ) ) { if ( 0 !== $ constructor -> getNumberOfRequiredParameters ( ) ) { throw new RuntimeException ( 'Cannot create an instance of ' . $ type . ' from serialized data because its constructor has required parameters.' ) ; } } return $ this -> doDeserialize ( $ data , new $ type ) ; }
1210	public function split ( ItemInterface $ item , $ length ) { return array ( 'primary' => $ this -> slice ( $ item , 0 , $ length ) , 'secondary' => $ this -> slice ( $ item , $ length ) , ) ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
5895	public function listImageTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ImageTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12651	private function writeTextsToFile ( $ language ) { $ textInfo = array ( ) ; $ outdateInfo = array ( ) ; foreach ( $ this -> contents [ $ language ] as $ id => $ info ) { $ textInfo [ $ id ] = $ info [ 'content' ] ; $ outdateInfo [ $ id ] = $ info [ 'outdated' ] ; } if ( $ language === $ this -> baseLang ) { $ content = array ( 'root' => $ textInfo ) + array_fill_keys ( $ this -> extraLangs , true ) ; } else { $ content = $ textInfo ; } $ encodeFlags = JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES ; $ content = "'use strict';\n/*global define*/\ndefine(" . json_encode ( $ content , $ encodeFlags ) . ");\n" ; $ fs = $ this -> env -> getFileSystem ( ) ; $ fs -> putFile ( $ this -> getFileName ( $ language ) , $ content ) ; $ fs -> putFile ( $ this -> getOutdateInfoFileName ( $ language ) , json_encode ( $ outdateInfo , $ encodeFlags ) ) ; }
739	protected function saveAssignments ( ) { $ assignmentData = [ ] ; foreach ( $ this -> assignments as $ userId => $ assignments ) { foreach ( $ assignments as $ name => $ assignment ) { $ assignmentData [ $ userId ] [ ] = $ assignment -> roleName ; } } $ this -> saveToFile ( $ assignmentData , $ this -> assignmentFile ) ; }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
3245	public function onCharge ( $ order ) { $ this -> statusCode = 'pending' ; $ this -> detail = 'pending response, token:' . $ this -> token ; return parent :: onCharge ( $ order ) ; }
133	public function getInstaller ( $ type ) { $ type = strtolower ( $ type ) ; if ( isset ( $ this -> cache [ $ type ] ) ) { return $ this -> cache [ $ type ] ; } foreach ( $ this -> installers as $ installer ) { if ( $ installer -> supports ( $ type ) ) { return $ this -> cache [ $ type ] = $ installer ; } } throw new \ InvalidArgumentException ( 'Unknown installer type: ' . $ type ) ; }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
6205	public function onException ( \ Exception $ exception ) { if ( $ this -> shouldNotifyException ( $ exception ) ) { $ this -> airbrakeClient -> notifyOnException ( $ exception ) ; } return true ; }
3948	private function buildMap ( ) { $ map = [ ] ; foreach ( $ this -> combination -> getParented ( ) as $ childName => $ child ) { $ map [ $ child [ 'meta' ] [ 'ptable' ] ] [ $ childName ] = $ child ; } return $ map ; }
10819	public static function comment ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'comment' , $ length , $ separator ) ; }
8181	public function getDefaultStrategy ( $ name ) { if ( ! is_string ( $ this -> defaultStrategy ) && false !== $ this -> defaultStrategy ) { return call_user_func ( $ this -> defaultStrategy , $ name ) ; } return $ this -> defaultStrategy ; }
4756	public function transform ( $ value ) { if ( $ value instanceof \ Traversable || is_array ( $ value ) ) { return $ this -> transformIterable ( $ value ) ; } if ( is_bool ( $ value ) ) { return $ this -> transformBoolean ( $ value ) ; } if ( is_scalar ( $ value ) || ( is_object ( $ value ) && method_exists ( $ value , '__toString' ) ) ) { return $ value ; } if ( $ value instanceof Cache ) { return $ this -> transformCacheAnnotation ( $ value ) ; } if ( $ value instanceof Method ) { return $ this -> transformMethodAnnotation ( $ value ) ; } if ( $ value instanceof ParamConverter ) { return $ this -> transformParamConverter ( $ value ) ; } if ( $ value instanceof Security ) { return $ this -> transformSecurity ( $ value ) ; } if ( $ value instanceof Template ) { return $ this -> transformTemplate ( $ value ) ; } return get_class ( $ value ) ; }
9018	public function getActionWords ( $ string , $ language = 'english' ) { $ words = $ this -> getWords ( $ string ) ; $ filter = new ActionWordsFilter ( $ language ) ; $ actionWords = [ ] ; foreach ( $ words as $ word ) { $ word = $ this -> removePunctuation ( $ word ) ; if ( ! is_null ( $ filter -> filter ( $ word ) ) ) { $ actionWords [ ] = $ word ; } } return $ actionWords ; }
11635	public function getPageByDeviceId ( array $ deviceIdentifier , $ raw = false ) { $ params = [ 'type' => 1 , 'device_identifier' => $ deviceIdentifier , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; if ( $ raw === true ) { return $ result ; } $ page_ids = [ ] ; if ( ! empty ( $ result -> data [ 'relations' ] ) ) { foreach ( $ result -> data [ 'relations' ] as $ item ) { $ page_ids [ ] = $ item [ 'page_id' ] ; } } return $ page_ids ; }
12638	public static function select ( string $ table , array $ columns = [ ] , string $ orderBy = "" ) : array { $ pdo = self :: connect ( ) ; $ sql = "SELECT " . ( $ columns === [ ] ? "*" : "\"" . implode ( "\", \"" , $ columns ) . "\"" ) . " FROM \"$table\"" . ( $ orderBy !== "" ? " ORDER BY $orderBy" : "" ) ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; return $ results ; }
697	public function actionAll ( ) { if ( ! $ this -> confirm ( 'Install all applications and all extensions now?' ) ) { return 1 ; } foreach ( $ this -> extensions as $ ext => $ repo ) { $ ret = $ this -> actionExt ( $ ext ) ; if ( $ ret !== 0 ) { return $ ret ; } } foreach ( $ this -> apps as $ app => $ repo ) { $ ret = $ this -> actionApp ( $ app ) ; if ( $ ret !== 0 ) { return $ ret ; } } return 0 ; }
649	public function dropCommentFromColumn ( $ table , $ column ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromColumn ( $ table , $ column ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
478	public function dropColumn ( $ table , $ column ) { $ time = $ this -> beginCommand ( "drop column $column from table $table" ) ; $ this -> db -> createCommand ( ) -> dropColumn ( $ table , $ column ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7678	function TbsSheetCheck ( ) { if ( count ( $ this -> OtbsSheetSlidesDelete ) > 0 ) $ this -> RaiseError ( "Unable to delete the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , $ this -> OtbsSheetSlidesDelete ) ) ) . '.' ) ; if ( count ( $ this -> OtbsSheetSlidesVisible ) > 0 ) $ this -> RaiseError ( "Unable to change visibility of the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , array_keys ( $ this -> OtbsSheetSlidesVisible ) ) ) ) . '.' ) ; }
7793	public function getStatements ( $ text ) { if ( ! $ this -> parsers ) { $ this -> addParsers ( $ this -> getDefaultParsers ( ) ) ; } foreach ( $ this -> parsers as $ class ) { $ parser = new $ class ( $ this ) ; if ( $ parser -> accept ( $ text ) ) { return $ parser -> parse ( $ text ) ; } } throw new \ RuntimeException ( 'No suitable parser found.' ) ; }
466	public function buildInCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
9504	private function listen ( ) { $ this -> emitter -> on ( 'peridot.configure' , [ $ this , 'onPeridotConfigure' ] ) ; $ this -> emitter -> on ( 'peridot.start' , [ $ this , 'onPeridotStart' ] ) ; $ this -> emitter -> on ( 'peridot.end' , [ $ this , 'onPeridotEnd' ] ) ; }
9676	public function allFonts ( Spreadsheet $ spreadsheet ) { $ aFonts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( ! isset ( $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] ) ) { $ aFonts [ $ style -> getFont ( ) -> getHashCode ( ) ] = $ style -> getFont ( ) ; } } return $ aFonts ; }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
6152	public function run ( ) { if ( ! empty ( $ this -> _fields ) ) { throw new InvalidCallException ( 'Each beginField() should have a matching endField() call.' ) ; } $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> getClientOptions ( ) ) ; $ attributes = Json :: encode ( $ this -> attributes ) ; $ view = $ this -> getView ( ) ; AdminUiActiveForm :: register ( $ view ) ; $ view -> registerJs ( "jQuery('#$id').yiiActiveForm($attributes, $options);" ) ; echo Html :: endForm ( ) ; }
6301	protected function getMain ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.main' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> main ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } $ nav = $ this -> active ( $ this -> main [ $ name ] ) ; return $ this -> process ( $ nav ) ; }
2836	public function getLayoutUpdates ( ) { if ( $ this -> uncompressedLayoutUpdates === null ) { $ this -> uncompressedLayoutUpdates = $ this -> layoutUpdates ? json_decode ( gzuncompress ( $ this -> layoutUpdates ) , true ) : array ( ) ; } return $ this -> uncompressedLayoutUpdates ; }
3935	private function setSearchable ( PropertyInterface $ property , $ propInfo ) { if ( ! isset ( $ propInfo [ 'search' ] ) ) { return ; } $ property -> setSearchable ( ( bool ) $ propInfo [ 'search' ] ) ; }
11988	function readLine ( ) { $ i = $ this -> pos ; $ tot_len = strlen ( $ this -> data ) ; while ( $ i < $ tot_len && ! $ this -> isEndOfLine ( $ i ) ) { $ i ++ ; } $ result = substr ( $ this -> data , $ this -> pos , $ i - $ this -> pos ) ; $ i ++ ; if ( $ this -> getLineEndingModeCrlf ( ) ) $ i ++ ; $ this -> pos = $ i ; return $ result ; }
12313	public function toArray ( ) { $ data = [ "uuid" => $ this -> uuid , "code" => $ this -> code , "modules" => $ this -> modules , "vars" => $ this -> vars , ] ; foreach ( [ 'modules' , 'vars' ] as $ key ) { if ( ! array_key_exists ( $ key , $ data ) ) { continue ; } if ( empty ( $ data [ $ key ] ) ) { $ data [ $ key ] = new \ stdClass ( ) ; } } return $ data ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
6638	protected function initContainer ( $ module ) { $ map = [ ] ; $ defaultClassMap = [ 'AddPermissionForm' => AddPermissionForm :: class , 'AssignRoleForm' => AssignRoleForm :: class , 'LoginForm' => LoginForm :: class , 'RequestPasswordResetForm' => RequestPasswordResetForm :: class , 'ResetPasswordForm' => ResetPasswordForm :: class , 'AuthAssignment' => AuthAssignment :: class , 'AuthItem' => AuthItem :: class , 'AuthItemChild' => AuthItemChild :: class , 'AuthRule' => AuthRule :: class , 'Message' => Message :: class , 'SourceMessage' => SourceMessage :: class , 'User' => User :: class , 'MessageQuery' => MessageQuery :: class , 'SourceMessageQuery' => SourceMessageQuery :: class , 'UserQuery' => UserQuery :: class , 'SourceMessageSearch' => SourceMessageSearch :: class , 'UserSearch' => UserSearch :: class , ] ; $ routes = [ 'mrstroz\\wavecms\\forms' => [ 'AddPermissionForm' , 'AssignRoleForm' , 'LoginForm' , 'RequestPasswordResetForm' , 'ResetPasswordForm' , ] , 'mrstroz\\wavecms\\models' => [ 'AuthAssignment' , 'AuthItem' , 'AuthItemChild' , 'AuthRule' , 'Message' , 'SourceMessage' , 'User' , ] , 'mrstroz\\wavecms\\models\\query' => [ 'MessageQuery' , 'SourceMessageQuery' , 'UserQuery' , ] , 'mrstroz\\wavecms\\models\\search' => [ 'SourceMessageSearch' , 'UserSearch' , ] ] ; $ mapping = array_merge ( $ defaultClassMap , $ module -> classMap ) ; foreach ( $ mapping as $ name => $ definition ) { $ map [ $ this -> getContainerRoute ( $ routes , $ name ) . "\\$name" ] = $ definition ; } $ di = Yii :: $ container ; foreach ( $ map as $ class => $ definition ) { if ( ! $ di -> has ( $ class ) ) { $ di -> set ( $ class , $ definition ) ; } } }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
3705	public function handle ( CreateMetaModelEvent $ event ) { if ( null === $ metaModel = $ event -> getMetaModel ( ) ) { return ; } foreach ( $ this -> attributeFactory -> createAttributesForMetaModel ( $ metaModel ) as $ attribute ) { $ metaModel -> addAttribute ( $ attribute ) ; } }
12201	public function mediaAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_media_connector" ] , ) ; return parent :: show ( $ options ) ; }
11455	public function deviceSummary ( array $ deviceIdentifier , $ beginDate , $ endDate ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'begin_date' => $ beginDate , 'end_date' => $ endDate , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE , $ params ] ) ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
12301	public function getChilds ( $ id , $ relation , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; return $ this -> builder -> get ( ) ; } $ resource = $ parent -> $ relation ; return $ resource ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
1397	public function deleted ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
361	public function renderErrors ( ) { if ( $ this -> filterModel instanceof Model && $ this -> filterModel -> hasErrors ( ) ) { return Html :: errorSummary ( $ this -> filterModel , $ this -> filterErrorSummaryOptions ) ; } return '' ; }
6434	public function getLoginStartUrl ( $ redirecturl ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] , 'callback_uri' => $ redirecturl ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ this -> temp_credentials = $ server -> getTemporaryCredentials ( ) ; return $ server -> getAuthorizationUrl ( $ this -> temp_credentials ) ; }
11772	public function resolve ( ) : array { try { $ app_required_modules = array_unique ( $ this -> required_modules ) ; $ component_dependency_map = $ this -> getComponentDependencyMap ( $ app_required_modules ) ; $ component_type_list = $ this -> resolveComponentDependencyMap ( $ component_dependency_map ) ; $ component_module_list = [ ] ; foreach ( $ component_type_list as $ component_type ) { $ component_module = $ this -> findComponentModuleByType ( $ app_required_modules , $ component_type ) ; if ( ! $ component_module ) { throw new ModuleDependencyResolverException ( 'Could not find component module: ' . $ component_type ) ; } if ( ! in_array ( $ component_module , $ component_module_list ) ) { $ component_module_list [ ] = $ component_module ; } } $ module_list = array_merge ( $ component_module_list , $ app_required_modules ) ; $ module_dependency_map = self :: getModuleDependencyMap ( $ module_list ) ; $ resolved_list = $ this -> resolveModuleDependencyMap ( $ module_dependency_map ) ; return $ resolved_list ; } catch ( \ Throwable $ e ) { throw new ModuleDependencyResolverException ( __METHOD__ . ' failed: ' . $ e -> getMessage ( ) , $ e ) ; } }
4488	private function broadcastToPlatform ( $ message , string $ platform ) { if ( $ this -> debug ) { $ this -> logger && $ this -> logger -> notice ( "Message would have been sent to $platform" , [ 'Message' => $ message , ] ) ; return ; } foreach ( $ this -> sns -> getPaginator ( 'ListEndpointsByPlatformApplication' , [ 'PlatformApplicationArn' => $ this -> arns [ $ platform ] , ] ) as $ endpointsResult ) { foreach ( $ endpointsResult [ 'Endpoints' ] as $ endpoint ) { if ( $ endpoint [ 'Attributes' ] [ 'Enabled' ] == 'true' ) { try { $ this -> send ( $ message , $ endpoint [ 'EndpointArn' ] ) ; } catch ( \ Exception $ e ) { $ this -> logger && $ this -> logger -> error ( "Failed to push to {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Exception' => $ e , 'Endpoint' => $ endpoint , ] ) ; } } else { $ this -> logger && $ this -> logger -> info ( "Disabled endpoint {$endpoint['EndpointArn']}" , [ 'Message' => $ message , 'Endpoint' => $ endpoint , ] ) ; } } } }
4694	public function addOrderBy ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order [ ] = $ expression ; $ this -> pushArgs ( 'order' , $ args ) ; return $ this ; }
9907	public function setBlocSize ( $ size ) { if ( null !== $ this -> memory ) { throw new Exception \ RuntimeException ( 'You can not change the segment size because memory is already allocated.' . ' Use realloc() function to create new memory segment.' ) ; } $ this -> blocSize = ( integer ) $ size ; return $ this ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
1064	private function collectConflictsWithin ( ValidationContext $ context , array & $ conflicts , array $ fieldMap ) { foreach ( $ fieldMap as $ responseName => $ fields ) { $ fieldsLength = count ( $ fields ) ; if ( $ fieldsLength <= 1 ) { continue ; } for ( $ i = 0 ; $ i < $ fieldsLength ; $ i ++ ) { for ( $ j = $ i + 1 ; $ j < $ fieldsLength ; $ j ++ ) { $ conflict = $ this -> findConflict ( $ context , false , $ responseName , $ fields [ $ i ] , $ fields [ $ j ] ) ; if ( ! $ conflict ) { continue ; } $ conflicts [ ] = $ conflict ; } } } }
1693	protected function convertHexColor ( $ color , $ blnWriteToFile = false , $ vars = array ( ) ) { if ( strncmp ( $ color , '$' , 1 ) === 0 ) { if ( ! $ blnWriteToFile ) { return array ( $ color ) ; } else { $ color = str_replace ( array_keys ( $ vars ) , $ vars , $ color ) ; } } $ rgb = array ( ) ; if ( \ strlen ( $ color ) == 6 ) { $ dec = hexdec ( $ color ) ; $ rgb [ 'red' ] = 0xFF & ( $ dec >> 0x10 ) ; $ rgb [ 'green' ] = 0xFF & ( $ dec >> 0x8 ) ; $ rgb [ 'blue' ] = 0xFF & $ dec ; } elseif ( \ strlen ( $ color ) == 3 ) { $ rgb [ 'red' ] = hexdec ( str_repeat ( substr ( $ color , 0 , 1 ) , 2 ) ) ; $ rgb [ 'green' ] = hexdec ( str_repeat ( substr ( $ color , 1 , 1 ) , 2 ) ) ; $ rgb [ 'blue' ] = hexdec ( str_repeat ( substr ( $ color , 2 , 1 ) , 2 ) ) ; } return $ rgb ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
140	public function markAliasInstalled ( RepositoryInterface $ repo , MarkAliasInstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; if ( ! $ repo -> hasPackage ( $ package ) ) { $ repo -> addPackage ( clone $ package ) ; } }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
12937	private function changeBlockSlotAndName ( $ targetFile , $ blockName , $ slotName ) { $ block = json_decode ( FilesystemTools :: readFile ( $ targetFile ) , true ) ; $ block [ "name" ] = $ blockName ; $ block [ "slot_name" ] = $ slotName ; $ json = json_encode ( $ block ) ; FilesystemTools :: writeFile ( $ targetFile , $ json ) ; return $ block ; }
8065	protected function getNextFreeWorker ( ) { $ sec = 0 ; while ( TRUE ) { $ this -> collectWorkerResults ( $ sec ) ; $ freeProcess = $ this -> workerProcesses -> takeFreeProcess ( ) ; if ( $ freeProcess !== NULL ) { return $ freeProcess ; } $ sec = $ this -> child_timeout_sec ; if ( $ this -> workerPoolSize <= 0 ) { throw new WorkerPoolException ( 'All workers were gone.' ) ; } } return NULL ; }
9422	public function getMetadata ( $ key = null ) { isset ( $ this -> stream ) && $ this -> meta = stream_get_meta_data ( $ this -> stream ) ; $ metadata = isset ( $ this -> meta [ $ key ] ) ? $ this -> meta [ $ key ] : null ; return is_null ( $ key ) ? $ this -> meta : $ metadata ; }
12728	public function expectsOutcome ( IOutcomeRule $ rule , IOutcomeRule $ rule2 = null , IOutcomeRule $ rule3 = null , IOutcomeRule $ rule4 = null , IOutcomeRule $ rule5 = null , IOutcomeRule $ rule6 = null , IOutcomeRule $ rule7 = null , IOutcomeRule $ rule8 = null , IOutcomeRule $ rule9 = null , IOutcomeRule $ rule10 = null ) { foreach ( func_get_args ( ) as $ arg ) { if ( $ arg instanceof IInputRule ) { $ this -> outcomeRules [ ] = $ arg ; } } return $ this ; }
9466	private function getServerModules ( array $ requirements ) { if ( ! function_exists ( 'apache_get_modules' ) ) { return collect ( [ ] ) ; } $ modules = apache_get_modules ( ) ; $ requirements = array_combine ( $ requirements , $ requirements ) ; return collect ( $ requirements ) -> transform ( function ( $ requirement ) use ( $ modules ) { return in_array ( $ requirement , $ modules ) ; } ) ; }
4097	public function field ( $ field , $ config = array ( ) ) { if ( is_string ( $ config ) ) $ config = array ( 'type' => $ config ) ; $ this -> properties [ $ field ] = $ config ; return $ this ; }
9452	public function query ( $ index , array $ filters = null , array $ queries = null , array $ fieldWeights = null , $ limit = 20 , $ offset = 0 ) { $ sphinxClient = $ this -> getSphinxClient ( ) ; $ sphinxClient -> SetLimits ( $ offset , $ limit ) ; if ( null !== $ filters ) { foreach ( $ filters as $ filter ) { if ( ! isset ( $ filter [ 'key' ] ) ) { } if ( array_key_exists ( 'min' , $ filter ) && array_key_exists ( 'max' , $ filter ) ) { $ sphinxClient -> SetFilterRange ( $ filter [ 'key' ] , ( integer ) $ filter [ 'min' ] , ( integer ) $ filter [ 'max' ] ) ; } else { if ( ! isset ( $ filter [ 'values' ] ) || ! is_array ( $ filter [ 'values' ] ) ) { } $ sphinxClient -> SetFilter ( $ filter [ 'key' ] , $ filter [ 'values' ] ) ; } } } if ( null !== $ queries ) { foreach ( $ queries as $ key => $ queryInfo ) { $ query = $ this -> implodeQueryValues ( $ queryInfo ) ; if ( array_key_exists ( 'countableAttributes' , $ queryInfo ) ) { $ array = $ queryInfo [ 'countableAttributes' ] ; if ( ! is_array ( $ array ) ) { $ array = [ $ array ] ; } $ sphinxClient -> addFacetedQuery ( $ query , $ index , $ array ) ; } else { $ sphinxClient -> AddQuery ( $ query , $ index ) ; } } } if ( null !== $ fieldWeights ) { $ sphinxClient -> SetFieldWeights ( $ fieldWeights ) ; } $ result = $ this -> getResult ( $ sphinxClient ) ; return $ result ; }
4433	public function createSubscriber ( array $ channels ) : WatchdogSubscriber { $ redis = clone $ this -> redis ; $ redis -> disconnect ( ) ; $ redis -> connect ( ) ; return new WatchdogSubscriber ( $ redis , $ channels ) ; }
4176	public function getFacades ( ) { return $ this -> facades ? : $ this -> facades = new Facade ( clone $ this -> getFiles ( ) , $ this -> console ) ; }
12661	public function createAuthorizerApplication ( $ appId , $ refreshToken ) { $ this -> fetch ( 'authorizer' , function ( $ authorizer ) use ( $ appId , $ refreshToken ) { $ authorizer -> setAppId ( $ appId ) ; $ authorizer -> setRefreshToken ( $ refreshToken ) ; } ) ; return $ this -> fetch ( 'app' , function ( $ app ) { $ app [ 'access_token' ] = $ this -> fetch ( 'authorizer_access_token' ) ; $ app [ 'oauth' ] = $ this -> fetch ( 'oauth' ) ; $ app [ 'server' ] = $ this -> fetch ( 'server' ) ; } ) ; }
10463	private function bindParams ( $ statement , $ params ) { foreach ( $ params as $ param ) { $ statement -> bindValue ( $ param [ 0 ] , $ param [ 1 ] , $ param [ 2 ] ) ; } }
4029	protected function getLabelText ( TranslatorInterface $ translator , ModelInterface $ model ) { $ type = $ model -> getProperty ( 'type' ) ; $ label = $ translator -> translate ( 'typenames.' . $ type , 'tl_metamodel_filtersetting' ) ; if ( $ label == 'typenames.' . $ type ) { return $ type ; } return $ label ; }
4226	public function register ( ) { if ( $ this -> registered ) { return ; } $ this -> prevDisplayErrors = \ ini_set ( 'display_errors' , 0 ) ; $ this -> prevErrorHandler = \ set_error_handler ( array ( $ this , 'handleError' ) ) ; $ this -> prevExceptionHandler = \ set_exception_handler ( array ( $ this , 'handleException' ) ) ; $ this -> registered = true ; return ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
7437	public static function handleFatal ( ) { $ error = error_get_last ( ) ; if ( null !== $ error ) { self :: render ( $ error [ "type" ] , $ error [ "message" ] , $ error [ "file" ] , $ error [ "line" ] ) ; } }
9807	private function readBlipJPEG ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ pos = 0 ; $ rgbUid1 = substr ( $ recordData , 0 , 16 ) ; $ pos += 16 ; if ( in_array ( $ recInstance , [ 0x046B , 0x06E3 ] ) ) { $ rgbUid2 = substr ( $ recordData , 16 , 16 ) ; $ pos += 16 ; } $ tag = ord ( $ recordData [ $ pos ] ) ; $ pos += 1 ; $ data = substr ( $ recordData , $ pos ) ; $ blip = new Blip ( ) ; $ blip -> setData ( $ data ) ; $ this -> object -> setBlip ( $ blip ) ; }
3650	protected function getTemplate ( $ strTemplate , $ strFormat = 'html5' , $ blnFailIfNotFound = false ) { $ strTemplate = basename ( $ strTemplate ) ; $ strCustom = 'templates' ; if ( TL_MODE == 'FE' ) { $ tmpDir = str_replace ( '../' , '' , $ GLOBALS [ 'objPage' ] -> templateGroup ) ; if ( ! empty ( $ tmpDir ) ) { $ strCustom = $ tmpDir ; } } try { return \ TemplateLoader :: getPath ( $ strTemplate , $ strFormat , $ strCustom ) ; } catch ( \ Exception $ exception ) { if ( $ blnFailIfNotFound ) { throw new \ RuntimeException ( sprintf ( 'Could not find template %s.%s' , $ strTemplate , $ strFormat ) , 1 , $ exception ) ; } } return null ; }
1456	protected function validateHasMany ( RelationshipInterface $ relationship , $ record = null , $ key = null , ResourceObjectInterface $ resource = null ) { if ( ! $ relationship -> isHasMany ( ) ) { $ this -> addError ( $ this -> errorFactory -> relationshipHasManyExpected ( $ key ) ) ; return false ; } $ identifiers = $ relationship -> getIdentifiers ( ) ; if ( ! $ this -> validateIdentifiers ( $ identifiers , $ record , $ key , $ resource ) ) { return false ; } return true ; }
385	public function getOrders ( $ recalculate = false ) { $ attributeOrders = $ this -> getAttributeOrders ( $ recalculate ) ; $ orders = [ ] ; foreach ( $ attributeOrders as $ attribute => $ direction ) { $ definition = $ this -> attributes [ $ attribute ] ; $ columns = $ definition [ $ direction === SORT_ASC ? 'asc' : 'desc' ] ; if ( is_array ( $ columns ) || $ columns instanceof \ Traversable ) { foreach ( $ columns as $ name => $ dir ) { $ orders [ $ name ] = $ dir ; } } else { $ orders [ ] = $ columns ; } } return $ orders ; }
619	public static function validateData ( array $ data , $ rules = [ ] ) { $ model = new static ( $ data ) ; if ( ! empty ( $ rules ) ) { $ validators = $ model -> getValidators ( ) ; foreach ( $ rules as $ rule ) { if ( $ rule instanceof Validator ) { $ validators -> append ( $ rule ) ; } elseif ( is_array ( $ rule ) && isset ( $ rule [ 0 ] , $ rule [ 1 ] ) ) { $ validator = Validator :: createValidator ( $ rule [ 1 ] , $ model , ( array ) $ rule [ 0 ] , array_slice ( $ rule , 2 ) ) ; $ validators -> append ( $ validator ) ; } else { throw new InvalidConfigException ( 'Invalid validation rule: a rule must specify both attribute names and validator type.' ) ; } } } $ model -> validate ( ) ; return $ model ; }
770	public function getIterator ( ) { $ value = $ this -> getValue ( ) ; if ( $ value instanceof QueryInterface ) { throw new InvalidConfigException ( 'The ArrayExpression class can not be iterated when the value is a QueryInterface object' ) ; } if ( $ value === null ) { $ value = [ ] ; } return new \ ArrayIterator ( $ value ) ; }
11535	public function bootstrap ( $ app ) { Yii :: beginProfile ( get_called_class ( ) ) ; Yii :: $ app -> modules = static :: getModules ( ) ; Yii :: $ app -> on ( \ yii \ base \ Application :: EVENT_BEFORE_REQUEST , [ $ this , 'beforeRequest' ] ) ; Yii :: endProfile ( get_called_class ( ) ) ; Yii :: trace ( "Registered " . count ( static :: getModules ( ) ) . " modules in " . get_called_class ( ) ) ; }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
174	protected function isOptional ( $ action ) { $ id = $ this -> getActionId ( $ action ) ; foreach ( $ this -> optional as $ pattern ) { if ( StringHelper :: matchWildcard ( $ pattern , $ id ) ) { return true ; } } return false ; }
7180	public function getTypes ( ) { if ( is_string ( $ this -> type ) ) { $ types = array ( $ this -> type ) ; } elseif ( is_array ( $ this -> type ) ) { $ types = $ this -> type ; } else { $ types = array ( ) ; } $ types = array_filter ( $ types , array ( $ this , 'isValidType' ) ) ; return empty ( $ types ) ? array ( self :: ANY ) : $ types ; }
9858	private function isValueInList ( Cell $ cell ) { $ cellValue = $ cell -> getValue ( ) ; $ dataValidation = $ cell -> getDataValidation ( ) ; $ formula1 = $ dataValidation -> getFormula1 ( ) ; if ( ! empty ( $ formula1 ) ) { if ( $ formula1 [ 0 ] === '"' ) { return in_array ( strtolower ( $ cellValue ) , explode ( ',' , strtolower ( trim ( $ formula1 , '"' ) ) ) , true ) ; } elseif ( strpos ( $ formula1 , ':' ) > 0 ) { $ matchFormula = '=MATCH(' . $ cell -> getCoordinate ( ) . ', ' . $ formula1 . ', 0)' ; $ calculation = Calculation :: getInstance ( $ cell -> getWorksheet ( ) -> getParent ( ) ) ; try { $ result = $ calculation -> calculateFormula ( $ matchFormula , $ cell -> getCoordinate ( ) , $ cell ) ; return $ result !== Functions :: NA ( ) ; } catch ( Exception $ ex ) { return false ; } } } return true ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
4714	public function replaceString ( $ search , $ replace ) { $ this -> text = str_replace ( $ search , $ replace , $ this -> text ) ; return $ this ; }
10840	protected function getRaw ( $ Key ) { $ CacheFile = $ this -> getCacheFile ( $ Key ) ; if ( ! file_exists ( $ CacheFile ) ) { return false ; } return unserialize ( file_get_contents ( $ CacheFile ) ) ; }
11404	public function changeAction ( ) { $ theme = $ this -> container -> get ( 'request' ) -> request -> get ( 'admin_theme' ) ; $ this -> container -> get ( 'vince_t.admin.theme.handler' ) -> setCurrentTheme ( $ theme ) ; $ headers = $ this -> container -> get ( 'request' ) -> server -> getHeaders ( ) ; $ referer = $ headers [ 'REFERER' ] ; return new RedirectResponse ( $ referer ) ; }
10161	private function readPane ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ px = self :: getUInt2d ( $ recordData , 0 ) ; $ py = self :: getUInt2d ( $ recordData , 2 ) ; $ rwTop = self :: getUInt2d ( $ recordData , 4 ) ; $ colLeft = self :: getUInt2d ( $ recordData , 6 ) ; if ( $ this -> frozen ) { $ cell = Coordinate :: stringFromColumnIndex ( $ px + 1 ) . ( $ py + 1 ) ; $ topLeftCell = Coordinate :: stringFromColumnIndex ( $ colLeft + 1 ) . ( $ rwTop + 1 ) ; $ this -> phpSheet -> freezePane ( $ cell , $ topLeftCell ) ; } } }
12552	private function addHeaders ( ) { self :: response ( ) -> addHeader ( 'Cache-Control' , 'no-cache, no-store, must-revalidate' ) ; self :: response ( ) -> addHeader ( 'Pragma' , 'no-cache' ) ; self :: response ( ) -> addHeader ( 'Expires' , '-1' ) ; }
6692	public function addGroup ( $ prefix , array $ middleware , callable $ callback ) { $ previousMiddlewareStack = $ this -> middlewareStack ; $ previousGroupPrefix = $ this -> currentGroupPrefix ; $ this -> currentGroupPrefix = $ previousGroupPrefix . $ prefix ; $ this -> middlewareStack = array_merge ( $ previousMiddlewareStack , $ middleware ) ; $ callback ( $ this ) ; $ this -> currentGroupPrefix = $ previousGroupPrefix ; $ this -> middlewareStack = $ previousMiddlewareStack ; }
6051	public function listFolders ( $ root = 0 , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'root' => $ root , 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11907	public function doFullBootBuildIfNecessary ( AviatorApp $ app ) { $ beaconUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/watch_beacon' ) ; if ( $ beaconUpdatedAt > LocalDate :: now ( ) -> modifyBySeconds ( 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherBeaconInFuture ( ) ; die ( ) ; } if ( PHP_SAPI !== 'cli' && $ beaconUpdatedAt < LocalDate :: now ( ) -> modifyBySeconds ( - 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherNotRunning ( ) ; exit ( - 1 ) ; } $ needsBuild = ! class_exists ( $ app -> getContainerFqcn ( ) ) ; if ( ! $ needsBuild ) { $ reflect = new \ ReflectionClass ( $ app -> getContainerFqcn ( ) ) ; $ containerFile = $ reflect -> getFileName ( ) ; clearstatcache ( true , $ containerFile ) ; $ fileUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/file_update_found' ) ; $ needsBuild = filemtime ( $ containerFile ) < $ fileUpdatedAt ; } if ( $ needsBuild ) { $ this -> doFullBootBuild ( $ app ) ; } }
1297	private function resolveFieldLinks ( $ field , string $ locale = null ) { if ( null === $ locale ) { $ locale = null === $ this -> sys -> getLocale ( ) ? '*' : $ this -> getLocale ( ) ; } if ( $ field instanceof Link ) { return $ this -> client -> resolveLink ( $ field , $ locale ) ; } if ( \ is_array ( $ field ) && isset ( $ field [ 0 ] ) && $ field [ 0 ] instanceof Link ) { return $ this -> client -> resolveLinkCollection ( $ field , $ locale ) ; } return $ field ; }
10598	protected function initViewPanelRequestedUrlData ( ) { $ req = & $ this -> request ; $ this -> view -> requestedUrl = ( object ) [ 'method' => htmlSpecialChars ( $ req -> GetMethod ( ) , ENT_IGNORE , 'UTF-8' ) , 'baseUrl' => htmlSpecialChars ( $ req -> GetBaseUrl ( ) , ENT_IGNORE , 'UTF-8' ) , 'path' => htmlSpecialChars ( $ req -> GetRequestPath ( ) , ENT_IGNORE , 'UTF-8' ) , ] ; }
11780	public function fromDbToEntity ( array $ data ) { $ hydratorFactory = $ this -> documentManager -> getHydratorFactory ( ) ; $ documentClass = $ this -> documentClass ; $ document = new $ documentClass ( ) ; $ hydratorFactory -> hydrate ( $ document , $ data ) ; return $ document ; }
9289	public function getDuration ( ) { $ executed = $ this -> getExecuted ( ) ; $ finished = $ this -> getFinished ( ) ; if ( is_null ( $ executed ) || is_null ( $ finished ) ) { return 0 ; } return strtotime ( $ finished ) - strtotime ( $ executed ) ; }
1414	public function resourceCannotBeDeleted ( string $ detail = null ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_UNPROCESSABLE_ENTITY , $ this -> trans ( 'resource_cannot_be_deleted' , 'code' ) , $ this -> trans ( 'resource_cannot_be_deleted' , 'title' ) , $ detail ? : $ this -> trans ( 'resource_cannot_be_deleted' , 'detail' ) ) ; }
12234	public function firstOf ( $ xpath ) { $ nodes = $ this -> xpath ( $ xpath ) ; return ( isset ( $ nodes [ 0 ] ) ) ? $ nodes [ 0 ] : null ; }
7762	public function getContext ( $ exposedClassName ) { $ classes = $ this -> metadata -> getAllMetadata ( ) ; $ metadata = null ; foreach ( $ classes as $ class ) { if ( $ class -> getExposeAs ( ) === $ exposedClassName ) { $ metadata = $ class ; break ; } } if ( null === $ metadata ) { return null ; } $ context = array ( 'hydra' => 'http://www.w3.org/ns/hydra/core#' , 'vocab' => $ this -> vocabUrl . '#' ) ; $ context [ $ exposedClassName ] = ( $ metadata -> isExternalReference ( ) ) ? $ metadata -> getIri ( ) : 'vocab:' . $ metadata -> getIri ( ) ; foreach ( $ metadata -> getProperties ( ) as $ property ) { if ( 0 === strncmp ( $ property -> getExposeAs ( ) , '@' , 1 ) ) { continue ; } $ termDefinition = ( $ property -> isExternalReference ( ) ) ? $ property -> getIri ( ) : 'vocab:' . $ property -> getIri ( ) ; if ( $ property -> getRoute ( ) ) { $ termDefinition = array ( '@id' => $ termDefinition , '@type' => '@id' ) ; } elseif ( $ this -> hasNormalizer ( $ property -> getType ( ) ) ) { $ normalizer = $ this -> getNormalizer ( $ property -> getType ( ) ) ; $ termDefinition = array ( '@id' => $ termDefinition , '@type' => $ normalizer -> getTypeIri ( ) ) ; } $ context [ $ property -> getExposeAs ( ) ] = $ termDefinition ; } return array ( '@context' => $ context ) ; }
1923	public static function fromDimensions ( $ width , $ height ) { $ image = imagecreatetruecolor ( $ width , $ height ) ; $ arrGdInfo = gd_info ( ) ; $ strGdVersion = preg_replace ( '/[^0-9.]+/' , '' , $ arrGdInfo [ 'GD Version' ] ) ; if ( version_compare ( $ strGdVersion , '2.0' , '>=' ) ) { imagealphablending ( $ image , false ) ; imagefill ( $ image , 0 , 0 , imagecolorallocatealpha ( $ image , 0 , 0 , 0 , 127 ) ) ; imagesavealpha ( $ image , true ) ; } return new static ( $ image ) ; }
2786	public static function mutates ( array & $ tokens , $ index ) { $ t = $ tokens [ $ index ] ; if ( ! is_array ( $ t ) && $ t == '+' ) { $ tokenCount = count ( $ tokens ) ; for ( $ i = $ index + 1 ; $ i < $ tokenCount ; $ i ++ ) { if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == '[' ) { return false ; } if ( is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] [ 0 ] == T_ARRAY && $ tokens [ $ i ] [ 1 ] == 'array' ) { return false ; } if ( ! is_array ( $ tokens [ $ i ] ) && $ tokens [ $ i ] == ';' ) { return true ; } } return true ; } return false ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
11600	public function getConfig ( string $ sName = '' ) { if ( empty ( $ sName ) ) { return $ this -> configSet ; } elseif ( isset ( $ this -> configSet [ $ sName ] ) ) { return $ this -> configSet [ $ sName ] ; } else { return null ; } }
7091	protected function match ( Request $ request ) { foreach ( $ this -> routes as $ route ) { if ( $ route -> method ( ) === $ request -> method ( ) && $ route -> match ( $ request -> url ( ) ) ) { if ( $ action = $ route -> action ( ) ) { try { $ response = $ action ( $ request , $ route -> args ( ) ) ; if ( $ response !== false ) return $ response ; } catch ( AbortRouteException $ abort ) { return $ abort -> response ( ) ; } } else return null ; } } return false ; }
5241	private function exceptionFields ( \ Exception $ exception ) { return '|' . get_class ( $ exception ) . '|' . $ exception -> getMessage ( ) . '|' . $ exception -> getFile ( ) . '|' . $ exception -> getLine ( ) ; }
6853	public function onStatus ( PaymentEvent $ event ) { $ payment = $ event -> getPayment ( ) ; $ sale = $ payment -> getSale ( ) ; if ( $ sale instanceof OrderInterface ) { return ; } if ( $ sale instanceof CartInterface && $ sale -> getState ( ) !== CartStates :: STATE_ACCEPTED ) { return ; } if ( $ sale instanceof QuoteInterface && $ sale -> getState ( ) !== QuoteStates :: STATE_ACCEPTED ) { return ; } $ tokens = $ this -> findPaymentTokens ( $ payment ) ; if ( null === $ order = $ this -> transform ( $ sale ) ) { return ; } $ newPayment = null ; foreach ( $ order -> getPayments ( ) as $ p ) { if ( $ p -> getNumber ( ) === $ payment -> getNumber ( ) ) { $ newPayment = $ p ; break ; } } if ( null === $ newPayment ) { throw new RuntimeException ( "Failed to find the transformed payment." ) ; } $ this -> convertTokens ( $ this -> getPaymentIdentity ( $ newPayment ) , $ tokens ) ; $ event -> setPayment ( $ newPayment ) ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
6018	public function addMediaToDeploymentSite ( $ id , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
9944	public function getCellByColumnAndRow ( $ columnIndex , $ row , $ createIfNotExists = true ) { $ columnLetter = Coordinate :: stringFromColumnIndex ( $ columnIndex ) ; $ coordinate = $ columnLetter . $ row ; if ( $ this -> cellCollection -> has ( $ coordinate ) ) { return $ this -> cellCollection -> get ( $ coordinate ) ; } return $ createIfNotExists ? $ this -> createNewCell ( $ coordinate ) : null ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
12400	public function first ( ) { $ this -> scope -> limit = 1 ; $ this -> scope -> offset = 0 ; return $ this -> get ( null ) ; }
1604	public function onException ( ExceptionEvent $ event ) { $ exception = $ event -> exception ; $ craft = \ Craft :: $ app ; if ( ! ( $ exception instanceof HttpException ) || $ exception -> statusCode !== 404 ) return ; $ path = $ craft -> request -> getFullPath ( ) ; $ query = $ craft -> request -> getQueryStringWithoutPath ( ) ; if ( $ query ) $ path .= '?' . $ query ; if ( $ redirect = $ this -> findRedirectByPath ( $ path ) ) { $ event -> handled = true ; $ craft -> response -> redirect ( $ redirect [ 'to' ] , $ redirect [ 'type' ] ) -> send ( ) ; $ craft -> end ( ) ; } }
9399	protected function compute ( $ n ) { $ int_fact = 1 ; for ( $ i = 1 ; $ i <= $ n ; $ i ++ ) { $ int_fact *= $ i ; } return $ int_fact ; }
4731	public static function unicode_to_utf16 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) ) { return preg_replace_callback ( '/\\\\u([0-9a-fA-F]{4})/' , function ( $ match ) { return mb_convert_encoding ( pack ( 'H*' , $ match [ 1 ] ) , 'UTF-8' , 'UTF-16BE' ) ; } , $ str ) ; } return $ str ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
11842	private function getBind ( ) { [ $ dsBegin , $ treeType ] = $ this -> extractInput ( ) ; $ calcId = $ this -> getCalcId ( $ dsBegin , $ treeType ) ; $ bind = [ QGrid :: BND_CALC_ID => $ calcId ] ; return $ bind ; }
7614	public function actionUpdate ( ) { $ model = $ this -> findModel ( ) ; $ model -> setScenario ( 'profile' ) ; if ( $ model -> load ( $ _POST ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'view' , 'id' => $ model -> id ] ) ; } else { return $ this -> render ( 'update' , [ 'model' => $ model , ] ) ; } }
12666	public function edit ( $ sourceDir , array $ options , $ username , $ values ) { $ this -> resolveOptions ( $ options ) ; $ this -> init ( $ sourceDir , $ options , $ username ) ; $ this -> createContributorDir ( $ sourceDir , $ options , $ username ) ; $ filename = sprintf ( '%s/blocks/%s.json' , $ this -> getDirInUse ( ) , $ options [ "blockname" ] ) ; $ currentBlock = $ options [ "baseBlock" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; $ values = $ this -> parseChildren ( $ values ) ; $ block = JsonTools :: join ( $ currentBlock , $ values ) ; $ encodedBlock = json_encode ( $ block ) ; $ blockClass = BlockFactory :: getBlockClass ( $ block [ "type" ] ) ; $ event = Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITING , new BlockEditingEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; $ blockContent = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ filename , $ blockContent ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_EDITED , new BlockEditedEvent ( $ this -> serializer , $ filename , $ encodedBlock , $ blockClass ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been edited on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
4338	private function removeHideIfEmptyGroups ( & $ log ) { $ groupStack = array ( ) ; $ groupStackCount = 0 ; $ removed = false ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ entry = $ log [ $ i ] ; $ groupStack [ ] = array ( 'i' => $ i , 'meta' => ! empty ( $ entry [ 2 ] ) ? $ entry [ 2 ] : array ( ) , 'hasEntries' => false , ) ; $ groupStackCount ++ ; } elseif ( $ method == 'groupEnd' ) { $ group = \ end ( $ groupStack ) ; if ( ! $ group [ 'hasEntries' ] && ! empty ( $ group [ 'meta' ] [ 'hideIfEmpty' ] ) ) { unset ( $ log [ $ group [ 'i' ] ] ) ; unset ( $ log [ $ i ] ) ; $ removed = true ; } \ array_pop ( $ groupStack ) ; $ groupStackCount -- ; } elseif ( $ groupStack ) { $ groupStack [ $ groupStackCount - 1 ] [ 'hasEntries' ] = true ; } } if ( $ removed ) { $ log = \ array_values ( $ log ) ; } }
3975	private function getDataProviderDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDataProviderDefinition ( ) ) { return $ container -> getDataProviderDefinition ( ) ; } $ config = new DefaultDataProviderDefinition ( ) ; $ container -> setDataProviderDefinition ( $ config ) ; return $ config ; }
4461	private function handleChildErrors ( & $ socket ) : Closure { $ reserved = str_repeat ( '*' , 32 * 1024 ) ; return function ( ) use ( & $ reserved , & $ socket ) : void { unset ( $ reserved ) ; $ error = error_get_last ( ) ; if ( $ error === null ) { unset ( $ reserved ) ; return ; } $ handler = new ErrorFormatter ( ) ; if ( $ handler -> constant ( $ error [ 'type' ] ) === null ) { $ this -> logger -> warning ( '{type}: Unable to recognize error type. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } if ( is_resource ( $ socket ) == false ) { $ this -> logger -> warning ( '{type}: supplied resource is not a valid socket resource. Skip sending error to master: {message}' , $ this -> logContext + [ 'message' => $ error [ 'message' ] ] ) ; return ; } $ this -> logger -> debug ( '{type}: sending error to master' , $ this -> logContext ) ; $ data = serialize ( $ error ) ; do { $ len = socket_write ( $ socket , $ data ) ; if ( $ len === false || $ len === 0 ) { break ; } $ data = substr ( $ data , $ len ) ; } while ( is_numeric ( $ len ) && $ len > 0 && is_resource ( $ socket ) ) ; } ; }
9638	public function getAttributes ( ) { $ attributes = array ( 'placeholder' => $ this -> config [ 'defaultparts' ] [ 'scheme' ] . "://example.com" ) ; if ( $ this -> config [ 'html5validation' ] ) { $ attributes += array ( 'type' => 'url' , 'pattern' => 'https?://.+' , ) ; } return array_merge ( parent :: getAttributes ( ) , $ attributes ) ; }
3939	private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; }
2064	public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> value || $ varValue == '' ) { return $ varValue ; } $ varValue = Contao \ StringUtil :: standardize ( $ varValue ) ; $ this -> import ( 'Contao\Automator' , 'Automator' ) ; $ arrFeeds = $ this -> Automator -> purgeXmlFiles ( true ) ; if ( \ in_array ( $ varValue , $ arrFeeds ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
1329	public function set ( $ key , $ value = null ) { $ keys = is_array ( $ key ) ? $ key : [ $ key => $ value ] ; foreach ( $ keys as $ key => $ value ) { self :: updateOrCreate ( [ 'key' => $ key ] , [ 'value' => $ value ] ) ; } }
9188	public function connect ( ) { if ( ! is_resource ( $ this -> handle ) ) { throw new SocketException ( "Socket is not available" ) ; } if ( ! @ socket_connect ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ this -> conntected = true ; }
3224	function getThumbnail ( $ path , $ format , $ size ) { Path :: checkArgNonRoot ( "path" , $ path ) ; Checker :: argString ( "format" , $ format ) ; Checker :: argString ( "size" , $ size ) ; if ( ! in_array ( $ format , array ( "jpeg" , "png" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'format': " . Util :: q ( $ format ) ) ; } if ( ! in_array ( $ size , array ( "xs" , "s" , "m" , "l" , "xl" ) ) ) { throw new \ InvalidArgumentException ( "Invalid 'size': " . Util :: q ( $ size ) ) ; } $ url = $ this -> buildUrlForGetOrPut ( $ this -> contentHost , $ this -> appendFilePath ( "1/thumbnails" , $ path ) , array ( "size" => $ size , "format" => $ format ) ) ; $ curl = $ this -> mkCurl ( $ url ) ; $ metadataCatcher = new DropboxMetadataHeaderCatcher ( $ curl -> handle ) ; $ curl -> set ( CURLOPT_RETURNTRANSFER , true ) ; $ response = $ curl -> exec ( ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ metadata = $ metadataCatcher -> getMetadata ( ) ; return array ( $ metadata , $ response -> body ) ; }
11032	protected function supports ( $ attribute , $ subject ) { if ( ! in_array ( $ attribute , array ( self :: MENU , self :: PERMISO ) ) ) { return false ; } if ( $ attribute == self :: MENU && ! is_null ( $ subject ) && ! $ subject instanceof Menu ) { return false ; } return true ; }
8262	protected function isValidCallback ( Request $ httpRequest ) { return $ this -> session -> has ( "provider" ) && $ httpRequest -> query -> has ( "state" ) && $ this -> session -> has ( "oauth2state" ) && is_string ( $ this -> session -> get ( "oauth2state" ) ) && ( strlen ( $ this -> session -> get ( "oauth2state" ) ) > 0 ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
4544	public function kernelException ( GetResponseForExceptionEvent $ event ) { $ exception = $ event -> getException ( ) ; if ( $ exception instanceof ValidationException ) { return ; } $ data = [ 'type' => 'https://tools.ietf.org/html/rfc2616#section-10' , 'title' => 'An error occurred' ] ; if ( in_array ( $ this -> environment , [ 'dev' , 'test' ] , true ) ) { $ data [ 'detail' ] = $ exception -> getMessage ( ) ; $ data [ 'trace' ] = $ exception -> getTrace ( ) ; } $ request = $ event -> getRequest ( ) ; $ contentTypes = $ request -> getAcceptableContentTypes ( ) ; $ accept = array_shift ( $ contentTypes ) ; switch ( $ accept ) { case 'application/json' : case 'application/ld+json' : $ code = Response :: HTTP_INTERNAL_SERVER_ERROR ; if ( $ exception instanceof HttpException ) { $ code = $ exception -> getStatusCode ( ) ; } $ response = new JsonResponse ( $ data , $ code ) ; $ event -> setResponse ( $ response ) ; break ; } }
3281	public function setDir ( string $ dir ) { if ( ! is_dir ( $ dir ) ) { throw new Exception ( 'Directory does not exist: ' . $ dir ) ; } $ this -> config [ 'dir' ] = rtrim ( $ dir , '/\\' ) . DIRECTORY_SEPARATOR ; }
9850	public function stringToStream ( string $ input ) : StreamInterface { $ stream = \ fopen ( 'php://temp' , 'w+' ) ; if ( ! \ is_resource ( $ stream ) ) { throw new \ Error ( 'Could not create stream' ) ; } \ fwrite ( $ stream , $ input ) ; \ rewind ( $ stream ) ; return new Stream ( $ stream ) ; }
11112	public function getMigrationFiles ( string $ type ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( $ type === pathinfo ( $ file [ 'filename' ] , PATHINFO_EXTENSION ) ) { $ array [ ] = $ file ; } } return $ array ; }
1941	public function checkBlacklistedRecipient ( $ varValue , Contao \ DataContainer $ dc ) { $ objBlacklist = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_blacklist WHERE hash=? AND pid=(SELECT pid FROM tl_newsletter_recipients WHERE id=?) AND id!=?" ) -> execute ( md5 ( $ varValue ) , $ dc -> id , $ dc -> id ) ; if ( $ objBlacklist -> count > 0 ) { throw new Exception ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'blacklisted' ] ) ; } return $ varValue ; }
7634	public function putBlockList ( $ containerName = '' , $ blobName = '' , $ blockList = array ( ) , $ metadata = array ( ) , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; Assertion :: notEmpty ( $ blockList , 'Block list does not contain any elements.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ blocks = '' ; foreach ( $ blockList as $ block ) { $ blocks .= ' <Latest>' . base64_encode ( $ block ) . '</Latest>' . "\n" ; } $ fileContents = utf8_encode ( implode ( "\n" , array ( '<?xml version="1.0" encoding="utf-8"?>' , '<BlockList>' , $ blocks , '</BlockList>' ) ) ) ; $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } $ headers = array_merge ( $ headers , $ this -> generateMetadataHeaders ( $ metadata ) ) ; foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , array ( 'comp' => 'blocklist' ) , 'PUT' , $ headers , false , $ fileContents , self :: RESOURCE_BLOB , self :: PERMISSION_WRITE ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } }
6836	private function isIdentityValid ( SaleInterface $ cart ) { return 0 < strlen ( $ cart -> getEmail ( ) ) && 0 < strlen ( $ cart -> getGender ( ) ) && 0 < strlen ( $ cart -> getFirstName ( ) ) && 0 < strlen ( $ cart -> getLastName ( ) ) ; }
12397	public function orWhere ( $ field , $ operator = null , $ value = null ) { return $ this -> where ( $ field , $ operator , $ value , '||' ) ; }
6390	public function readFacetofaceSessionSignups ( $ sessionid , $ timecreated ) { $ signups = $ this -> readStoreRecords ( 'facetoface_signups' , [ 'sessionid' => $ sessionid ] ) ; foreach ( $ signups as $ index => $ signup ) { $ signups [ $ index ] -> statuses = $ this -> readStoreRecords ( 'facetoface_signups_status' , [ 'signupid' => $ signup -> id ] ) ; $ signups [ $ index ] -> attendee = $ this -> readUser ( $ signup -> userid ) ; } return $ signups ; }
11735	private function updateOv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ ov = $ one -> getOv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setOv ( $ ov ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
8467	public static function addBackSlash ( $ uri , $ position = 'end' ) { switch ( $ position ) { case 'top' : $ uri = '/' . ltrim ( $ uri , '/' ) ; break ; case 'end' : $ uri = rtrim ( $ uri , '/' ) . '/' ; break ; case 'both' : $ uri = ! empty ( $ uri ) ? '/' . trim ( $ uri , '/' ) . '/' : '' ; break ; default : $ uri = false ; } return $ uri ; }
2271	public function getUuid ( ) { static $ ids ; if ( empty ( $ ids ) ) { $ statement = $ this -> resConnection -> executeQuery ( implode ( ' UNION ALL ' , array_fill ( 0 , 10 , "SELECT UNHEX(REPLACE(UUID(), '-', '')) AS uuid" ) ) ) ; $ ids = $ statement -> fetchAll ( \ PDO :: FETCH_COLUMN ) ; } return array_pop ( $ ids ) ; }
2731	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ backends = $ this -> api -> getBackends ( $ activeVersion ) ; if ( ! $ backends ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Backend details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'backends' => $ backends ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6246	public function files ( ? int $ constraints = null ) : \ Generator { foreach ( $ this -> all ( $ constraints ) as $ file ) { if ( ! $ file -> isDir ( ) ) { yield $ file ; } } }
6795	protected function convertValueIds ( $ valueResult , & $ counter = null ) { $ result = [ ] ; $ aliases = [ ] ; $ idColumn = $ this -> getIdColumn ( ) ; $ aliasColumn = $ this -> getAliasColumn ( ) ; while ( $ row = $ valueResult -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ valueId = $ row -> $ idColumn ; $ aliases [ $ valueId ] = $ row -> $ aliasColumn ; $ result [ ] = $ valueId ; } if ( ( $ counter !== null ) && ! empty ( $ result ) ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'value_id' , 'COUNT(value_id) as mm_count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'value_id IN (:values)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'values' , $ result , Connection :: PARAM_STR_ARRAY ) -> execute ( ) -> fetch ( \ PDO :: FETCH_OBJ ) ; $ amount = $ statement -> mm_count ; $ valueId = $ statement -> value_id ; $ alias = $ aliases [ $ valueId ] ; $ counter [ $ valueId ] = $ amount ; $ counter [ $ alias ] = $ amount ; } return $ result ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
1701	protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
12124	public function getLanguages ( ) { $ languages = array ( ) ; foreach ( $ this -> getAliases ( ) as $ siteAlias ) { $ language = $ siteAlias -> getLanguage ( ) ; if ( ! in_array ( $ language , $ languages ) ) { $ languages [ ] = $ language ; } } return $ languages ; }
415	public function getAcceptableContentTypes ( ) { if ( $ this -> _contentTypes === null ) { if ( $ this -> headers -> get ( 'Accept' ) !== null ) { $ this -> _contentTypes = $ this -> parseAcceptHeader ( $ this -> headers -> get ( 'Accept' ) ) ; } else { $ this -> _contentTypes = [ ] ; } } return $ this -> _contentTypes ; }
11436	private function _removeDirectory ( $ sName ) { if ( $ rDirectory = opendir ( $ sName ) ) { while ( ( $ sFile = readdir ( $ rDirectory ) ) !== false ) { if ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "file" ) { unlink ( $ sName . $ sFile ) ; } elseif ( $ sFile > '0' && filetype ( $ sName . $ sFile ) == "dir" ) { remove_dir ( $ sName . $ sFile . "\\" ) ; } } closedir ( $ rDirectory ) ; rmdir ( $ sName ) ; } }
4310	public function getChannels ( $ allDescendants = false ) { if ( $ allDescendants ) { $ channels = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ channels = \ array_merge ( $ channels , array ( $ channel -> getCfg ( 'channel' ) => $ channel ) , $ channel -> getChannels ( true ) ) ; } return $ channels ; } return $ this -> channels ; }
6616	public function getEndpointResult ( $ method , $ endpointName , Request $ request ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ reflectionMethod = $ this -> reflection -> getMethod ( $ methodName ) ; return $ reflectionMethod -> invokeArgs ( $ this -> controller , $ this -> mapRequestToArguments ( $ reflectionMethod , $ request ) ) ; }
10480	private function isTrackedFieldModified ( AbstractDiffItem $ item , ExtractionDescriptorInterface $ relation ) { if ( ! $ item instanceof UpdateDiffItem ) { throw new \ InvalidArgumentException ( 'Wrong diff item type. Got: ' . get_class ( $ item ) ) ; } $ trackedFields = $ relation -> getUpdateFields ( ) ; if ( empty ( $ trackedFields ) ) { return true ; } $ itemRow = $ item -> getItem ( ) ; $ oldItemRow = $ item -> getOldItem ( ) ; foreach ( array_keys ( $ trackedFields ) as $ key ) { if ( array_key_exists ( $ key , $ itemRow ) && $ itemRow [ $ key ] !== $ oldItemRow [ $ key ] ) { return true ; } } return false ; }
6798	public function install ( $ country = 'US' , $ currency = 'USD' ) { $ this -> installCountries ( $ country ) ; $ this -> installCurrencies ( $ currency ) ; $ this -> installTaxes ( $ country ) ; $ this -> installTaxGroups ( $ country ) ; $ this -> installTaxRules ( $ country ) ; $ this -> installCustomerGroups ( ) ; }
8606	public function listSubscriptions ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_ListSubscriptionsInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsInput.php' ) ; $ request = new MWSSubscriptionsService_Model_ListSubscriptionsInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListSubscriptions' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListSubscriptionsResponse.php' ) ; $ response = MWSSubscriptionsService_Model_ListSubscriptionsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2221	public static function findPublishedFromToByPids ( $ intFrom , $ intTo , $ arrPids , $ intLimit = 0 , $ intOffset = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.date>=? AND $t.date<=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } $ arrOptions [ 'limit' ] = $ intLimit ; $ arrOptions [ 'offset' ] = $ intOffset ; return static :: findBy ( $ arrColumns , array ( $ intFrom , $ intTo ) , $ arrOptions ) ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
8785	public function fullUrlWithQuery ( array $ query ) { $ question = $ this -> getBaseUrl ( ) . $ this -> getPathInfo ( ) == '/' ? '/?' : '?' ; return count ( $ this -> query ( ) ) > 0 ? $ this -> url ( ) . $ question . http_build_query ( array_merge ( $ this -> query ( ) , $ query ) ) : $ this -> fullUrl ( ) . $ question . http_build_query ( $ query ) ; }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
6703	public function get ( OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token , $ httpverb , $ url , $ params = [ ] ) { uksort ( $ params , 'strcmp' ) ; $ base_url = $ this -> baseURL ( $ httpverb , $ url , $ params ) ; $ key = $ consumer -> secret . '&' . $ token -> secret ; return base64_encode ( hash_hmac ( 'sha1' , $ base_url , $ key , true ) ) ; }
4402	protected function getProvider ( ) { $ config = $ this -> getServiceItem ( ) -> getConfig ( ) ; $ config [ 'apiKey' ] = $ this -> getServiceItem ( ) -> getConfigValue ( 'stripe.apiKey' ) ; if ( ! isset ( $ this -> provider ) ) { $ this -> provider = OPay :: create ( 'Stripe' ) ; $ this -> provider -> setTestMode ( ( bool ) $ this -> getValue ( 'testmode' , false ) ) ; $ this -> provider -> initialize ( $ config ) ; } return $ this -> provider ; }
5543	public function getFrames ( ) { $ report = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ report [ $ this -> getPublicNameFromIndex ( $ i ) ] = $ this -> frames [ $ i ] -> getFrames ( ) ; } return $ report ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
2835	public function completeRendering ( Mage_Core_Block_Abstract $ block ) { $ this -> isRendering = false ; $ this -> renderedCompletedAt = microtime ( true ) ; $ this -> renderedDuration += ( $ this -> renderedCompletedAt * 1000 - $ this -> renderedAt * 1000 ) ; $ this -> templateFile = $ block instanceof Mage_Core_Block_Template ? $ block -> getTemplateFile ( ) : '' ; self :: $ endRenderingTime = $ this -> renderedCompletedAt ; }
11978	public function transform ( $ message ) { if ( is_array ( $ message ) ) { $ class = News :: class ; } else { if ( is_string ( $ message ) ) { $ message = new Text ( [ 'content' => $ message ] ) ; } $ class = get_class ( $ message ) ; } $ handle = 'transform' . substr ( $ class , strlen ( 'EasyWeChat\Message\\' ) ) ; return method_exists ( $ this , $ handle ) ? $ this -> $ handle ( $ message ) : [ ] ; }
3747	protected function extractSorting ( $ config ) { $ sorting = $ config -> getSorting ( ) ; $ sortBy = key ( $ sorting ) ; $ sortDir = current ( $ sorting ) ? : DCGE :: MODEL_SORTING_ASC ; return array ( $ sortBy , $ sortDir ) ; }
8123	public function savereview ( $ data , Form $ form ) { $ page = $ this -> findRecord ( $ data ) ; $ results = $ this -> getReviewContentHandler ( ) -> submitReview ( $ page , $ data ) ; if ( is_null ( $ results ) ) { return null ; } if ( $ this -> getSchemaRequested ( ) ) { $ extraData = [ 'message' => $ results ] ; $ schemaId = $ this -> owner -> join_links ( $ this -> owner -> Link ( 'schema/ReviewContentForm' ) , $ page -> ID ) ; return $ this -> getSchemaResponse ( $ schemaId , $ form , null , $ extraData ) ; } return $ results ; }
1994	public static function indexPageIfApplicable ( Response $ objResponse ) { global $ objPage ; if ( $ objPage === null ) { return ; } if ( Config :: get ( 'enableSearch' ) && $ objResponse -> getStatusCode ( ) == 200 && ! BE_USER_LOGGED_IN && ! $ objPage -> noSearch ) { if ( Config :: get ( 'indexProtected' ) || ( ! FE_USER_LOGGED_IN && ! $ objPage -> protected ) ) { $ blnIndex = true ; foreach ( array_keys ( $ _GET ) as $ key ) { if ( \ in_array ( $ key , $ GLOBALS [ 'TL_NOINDEX_KEYS' ] ) || strncmp ( $ key , 'page_' , 5 ) === 0 ) { $ blnIndex = false ; break ; } } if ( $ blnIndex ) { $ arrData = array ( 'url' => Environment :: get ( 'base' ) . Environment :: get ( 'relativeRequest' ) , 'content' => $ objResponse -> getContent ( ) , 'title' => $ objPage -> pageTitle ? : $ objPage -> title , 'protected' => ( $ objPage -> protected ? '1' : '' ) , 'groups' => $ objPage -> groups , 'pid' => $ objPage -> id , 'language' => $ objPage -> language ) ; Search :: indexPage ( $ arrData ) ; } } } }
11391	public function createMainMenu ( Request $ request ) { $ menu = $ this -> factory -> createItem ( 'root' ) ; $ menu -> setCurrentUri ( $ request -> getBaseUrl ( ) . $ request -> getPathInfo ( ) ) ; $ admin_pool = $ this -> container -> get ( 'sonata.admin.pool' ) ; foreach ( $ admin_pool -> getDashboardGroups ( ) as $ group ) { $ menu -> addChild ( $ group [ 'label' ] , array ( 'translationDomain' => $ group [ 'label_catalogue' ] ) ) ; foreach ( $ group [ 'items' ] as $ admin ) { if ( $ admin -> hasRoute ( 'list' ) && $ admin -> isGranted ( 'LIST' ) ) { $ menu [ $ group [ 'label' ] ] -> addChild ( $ admin -> getLabel ( ) , array ( 'admin' => $ admin ) ) ; } } } $ dispatcher = $ this -> container -> get ( 'event_dispatcher' ) ; $ event = new MenuCreateEvent ( $ menu ) ; $ dispatcher -> dispatch ( MenuEvents :: ADMIN_MENU_CREATE , $ event ) ; return $ menu ; }
12190	public function getActive ( ) { return ( isset ( $ this -> _child ) and $ this -> _child -> active ) and ( isset ( $ this -> _parent ) and $ this -> _parent -> active ) ; }
8648	private function addRequiredParameters ( array $ parameters ) { $ parameters [ 'AWSAccessKeyId' ] = $ this -> awsAccessKeyId ; $ parameters [ 'Timestamp' ] = $ this -> getFormattedTimestamp ( new DateTime ( 'now' , new DateTimeZone ( 'UTC' ) ) ) ; $ parameters [ 'Version' ] = self :: SERVICE_VERSION ; $ parameters [ 'SignatureVersion' ] = $ this -> config [ 'SignatureVersion' ] ; if ( $ parameters [ 'SignatureVersion' ] > 1 ) { $ parameters [ 'SignatureMethod' ] = $ this -> config [ 'SignatureMethod' ] ; } $ parameters [ 'Signature' ] = $ this -> signParameters ( $ parameters , $ this -> awsSecretAccessKey ) ; return $ parameters ; }
9098	public function initThemeManager ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ themManager = $ sm -> get ( 'yimaTheme.Manager' ) ; if ( ! $ themManager instanceof ManagerInterface ) { throw new \ Exception ( sprintf ( 'yimaTheme theme manager most instance of "ManagerInterface" but "%s" given.' , get_class ( $ themManager ) ) ) ; } $ themManager -> init ( ) ; }
8609	private function _convertRegisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'RegisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationRegisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationRegisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
7575	public function getCustomFields ( $ parameters = array ( ) ) { $ this -> _harvest = $ this -> _harvestHelper -> parse ( 'getCustomFields' , $ parameters ) ; if ( ! array_key_exists ( 'id' , $ parameters ) ) $ this -> _harvest [ 'url' ] = $ this -> _harvest [ 'url' ] . '/' ; $ this -> sendRequest ( ) ; }
2874	public function enableAction ( ) { $ moduleName = ( string ) $ this -> getRequest ( ) -> getParam ( 'module' ) ; try { $ this -> getService ( ) -> setModuleStatus ( $ moduleName , true ) ; $ this -> getService ( ) -> flushCache ( ) ; Mage :: getSingleton ( 'core/session' ) -> addSuccess ( 'Module was enabled.' ) ; } catch ( Exception $ e ) { Mage :: getSingleton ( 'core/session' ) -> addError ( 'Unable to enable module: ' . $ e -> getMessage ( ) ) ; } $ this -> _redirectReferer ( ) ; }
1496	public function prepend ( Encoding ... $ encodings ) : self { $ copy = clone $ this ; array_unshift ( $ copy -> stack , ... $ encodings ) ; return $ copy ; }
11221	private static function routeValidator ( ) { self :: $ uri = Url :: getUriMethods ( ) ; self :: $ uri = Url :: setUrlParams ( self :: $ uri ) ; self :: $ uri = Url :: addBackSlash ( self :: $ uri ) ; self :: cleanResources ( ) ; if ( self :: getMethod ( self :: $ uri ) ) { self :: any ( self :: $ uri , self :: $ routes [ self :: $ uri ] ) ; } }
2600	public function peek ( ) { if ( isset ( $ this -> tokens [ $ this -> position + $ this -> peek ] ) ) { return $ this -> tokens [ $ this -> position + $ this -> peek ++ ] ; } else { return null ; } }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
12196	public static function current ( ) { if ( defined ( 'PHPUNIT_RUNNING' ) ) { return 'http://localhost' ; } $ protocol = 'http://' ; if ( ! empty ( $ _SERVER [ 'HTTPS' ] ) || ( ! empty ( $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] ) && $ _SERVER [ 'HTTP_X_FORWARDED_PROTO' ] === 'https' ) ) { $ protocol = 'https://' ; } return $ protocol . request ( ) -> server ( 'HTTP_HOST' ) . request ( ) -> server ( 'REQUEST_URI' ) ; }
11956	function addQueue ( $ channel , $ queue , $ weight = 1 ) { $ orig = $ channel ; $ channel = $ this -> _normalizeQueueName ( $ channel ) ; if ( ! $ queue instanceof iQueueDriver ) throw new \ Exception ( sprintf ( 'Queue must be instance of iQueueDriver; given: (%s).' , \ Poirot \ Std \ flatten ( $ queue ) ) ) ; if ( isset ( $ this -> channels_queue [ $ channel ] ) ) throw new \ RuntimeException ( sprintf ( 'Channel (%s) is currently filled with (%s) and is not empty.' , $ orig , get_class ( $ this -> channels_queue [ $ channel ] ) ) ) ; $ this -> channels_queue [ $ channel ] = $ queue ; $ this -> channels_weight [ $ channel ] = $ weight ; return $ this ; }
9614	public function authenticate ( TokenInterface $ token ) { $ user = $ this -> userProvider -> loadUserByApiKey ( $ this -> encoder -> encodePassword ( $ token -> getCredentials ( ) ) ) ; if ( ! $ user || ! ( $ user instanceof UserInterface ) ) { throw new AuthenticationException ( 'Bad credentials' ) ; } $ token = new ApiKeyToken ( $ token -> getCredentials ( ) , $ user -> getRoles ( ) ) ; $ token -> setUser ( $ user ) ; return $ token ; }
9062	private function getTableSchema ( ) : ? Row { return $ this -> connection -> query ( " SELECT [tab.ENGINE], [col.COLLATION_NAME], [col.CHARACTER_SET_NAME] FROM [information_schema.TABLES] tab JOIN [information_schema.COLLATION_CHARACTER_SET_APPLICABILITY] col ON [tab.TABLE_COLLATION] = [col.COLLATION_NAME] WHERE [tab.TABLE_SCHEMA] = %s AND [tab.TABLE_NAME] = %s" , $ this -> database , $ this -> name ) -> fetch ( ) ; }
6982	public function validate ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ errors = $ this -> validateAndReturnErrors ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( ! empty ( $ errors ) ) { $ this -> throwValidationErrorsResponse ( $ errors ) ; } return $ this -> extractInputFromRules ( $ dataOrRequest , $ rules ) ; }
2627	public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
10532	public function valid ( ) { if ( $ this -> items === null ) { return false ; } $ key = key ( $ this -> items ) ; return ( $ key !== null && $ key !== false ) ; }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
5628	public function makeAbsolute ( $ base ) { if ( ! is_object ( $ base ) ) { $ base = new self ( $ base ) ; } if ( $ this -> getHost ( ) ) { $ scheme = $ this -> getScheme ( ) ; $ host = $ this -> getHost ( ) ; $ port = $ this -> getPort ( ) ? ':' . $ this -> getPort ( ) : '' ; $ identity = $ this -> getIdentity ( ) ? $ this -> getIdentity ( ) . '@' : '' ; if ( ! $ identity ) { $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } } else { $ scheme = $ base -> getScheme ( ) ; $ host = $ base -> getHost ( ) ; $ port = $ base -> getPort ( ) ? ':' . $ base -> getPort ( ) : '' ; $ identity = $ base -> getIdentity ( ) ? $ base -> getIdentity ( ) . '@' : '' ; } $ path = $ this -> normalisePath ( $ this -> extractAbsolutePath ( $ base ) ) ; $ encoded = $ this -> getEncodedRequest ( ) ; $ fragment = $ this -> getFragment ( ) ? '#' . $ this -> getFragment ( ) : '' ; $ coords = $ this -> getX ( ) === false ? '' : '?' . $ this -> getX ( ) . ',' . $ this -> getY ( ) ; return new self ( "$scheme://$identity$host$port$path$encoded$fragment$coords" ) ; }
9574	protected function registerProvider ( ProviderInterface $ provider ) { if ( $ provider instanceof AbstractProvider ) { $ provider -> setApplication ( $ this ) ; } $ provider -> register ( ) ; if ( $ this -> console && $ provider instanceof ConsoleProviderInterface ) { $ provider -> registerConsole ( $ this -> console ) ; } }
4821	public function getAsArray ( $ fieldName ) { if ( ! array_key_exists ( $ fieldName , $ this -> row ) ) { return [ ] ; } $ result = $ this -> row [ $ fieldName ] ; if ( empty ( $ result ) ) { return [ ] ; } return ( array ) $ result ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
4645	public function setDimension ( $ name , array $ values ) { if ( empty ( $ values ) ) { $ values = array ( null ) ; } $ this -> dimensions [ $ name ] = $ values ; }
1108	protected function validateDuplicates ( ) { return ( ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedLeftColumnName ( ) ) && ! $ this -> duplicatesExistForColumn ( $ this -> node -> getQualifiedRightColumnName ( ) ) ) ; }
2071	private function getDateAndTime ( CalendarEventsModel $ objEvent , PageModel $ objPage , $ intStartTime , $ intEndTime , $ span ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) ; if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> dateFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> dateFormat , $ intEndTime ) ; } $ strTime = '' ; if ( $ objEvent -> addTime ) { if ( $ span > 0 ) { $ strDate = Date :: parse ( $ objPage -> datimFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> datimFormat , $ intEndTime ) ; } elseif ( $ intStartTime == $ intEndTime ) { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) ; } else { $ strTime = Date :: parse ( $ objPage -> timeFormat , $ intStartTime ) . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'cal_timeSeparator' ] . Date :: parse ( $ objPage -> timeFormat , $ intEndTime ) ; } } return array ( $ strDate , $ strTime ) ; }
3142	public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; }
5057	private function getClassName ( $ requestedName ) { $ exp = explode ( '/' , $ requestedName ) ; $ className = array_shift ( $ exp ) . '\\Controller\\' . implode ( '\\' , $ exp ) . 'Controller' ; if ( ! class_exists ( $ className ) ) { throw new ServiceNotCreatedException ( sprintf ( 'Can\'t find correct controller class for "%s"' , $ requestedName ) ) ; } return $ className ; }
5325	protected function lockExecute ( callable $ task ) { if ( $ this -> mutex -> isAcquired ( ) ) { return $ task ( ) ; } return $ this -> mutex -> lockExecute ( $ task ) ; }
4538	public function setTenantId ( ? string $ tenantId ) { $ this -> tenantId = $ tenantId ; $ this -> _tenantId = null !== $ tenantId ; return $ this ; }
7471	public function createAction ( Request $ request ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; $ form -> bind ( $ request ) ; if ( $ form -> isValid ( ) ) { $ factory = $ this -> get ( 'security.encoder_factory' ) ; $ encoder = $ factory -> getEncoder ( $ user ) ; $ user -> setPassword ( $ encoder -> encodePassword ( $ user -> getPassword ( ) , $ user -> getSalt ( ) ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ user ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The user has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_user_show' , array ( 'id' => $ user -> getId ( ) ) ) ) ; } return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
8978	protected function getRateKey ( $ currencyCode , $ date , $ rateType , $ sourceName ) { return str_replace ( [ '%currency_code%' , '%date%' , '%rate_type%' , '%source_name%' ] , [ $ currencyCode , $ date -> format ( 'Y-m-d' ) , $ rateType , $ sourceName ] , '%currency_code%_%date%_%rate_type%_%source_name%' ) ; }
12785	protected function generateIntersection ( $ combinationMask ) { $ combination = [ ] ; foreach ( str_split ( $ combinationMask ) as $ key => $ indicator ) { if ( $ indicator ) { $ combination [ ] = $ this -> arrays [ $ this -> arrayKeys [ $ key ] ] ; } } $ intersection = call_user_func_array ( 'array_intersect_assoc' , $ combination ) ; if ( count ( $ intersection ) >= $ this -> threshold ) { $ this -> intersections [ ] = $ intersection ; return ; } $ this -> noResultMasks [ ] = $ combinationMask ; }
681	protected function validateAttributeCondition ( $ attribute , $ condition ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; if ( ! isset ( $ attributeTypes [ $ attribute ] ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unknownAttribute' , [ 'attribute' => $ attribute ] ) ) ; return ; } if ( is_array ( $ condition ) ) { $ operatorCount = 0 ; foreach ( $ condition as $ rawOperator => $ value ) { if ( isset ( $ this -> filterControls [ $ rawOperator ] ) ) { $ operator = $ this -> filterControls [ $ rawOperator ] ; if ( isset ( $ this -> operatorTypes [ $ operator ] ) ) { $ operatorCount ++ ; $ this -> validateOperatorCondition ( $ rawOperator , $ value , $ attribute ) ; } } } if ( $ operatorCount > 0 ) { if ( $ operatorCount < count ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'invalidAttributeValueFormat' , [ 'attribute' => $ attribute ] ) ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
12556	private function createDeleteForm ( Tag $ tag ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_tag_delete' , array ( 'id' => $ tag -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
11322	protected function getAnnotationClassForAction ( $ requestAction ) { $ actions = $ this -> getActions ( ) ; foreach ( $ actions as $ action ) { if ( $ action -> getAnnotatedName ( ) === $ requestAction ) { return $ action ; } } throw new ExtDirectException ( "extjs direct name '{$requestAction}' does not exist'" ) ; }
8321	public function badCaptcha ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=reportbad&id={$captchaId}" ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( $ responseText === self :: STATUS_OK_REPORT_RECORDED ) { return true ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : $ responseText , $ this -> getErrorCode ( $ responseText ) ? : 0 ) ; }
1192	private function addCustomAttributes ( array $ attributes , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ attributes as $ attribute ) { $ required = ! empty ( $ attribute [ 3 ] ) ? true : false ; $ onElement = $ attribute [ 0 ] ; $ attrName = $ required ? $ attribute [ 1 ] . '*' : $ attribute [ 1 ] ; $ validValues = $ attribute [ 2 ] ; $ definition -> addAttribute ( $ onElement , $ attrName , $ validValues ) ; } return $ definition ; }
3423	protected function groupsMustBeSelected ( ) { return in_array ( 'GROUPS' , $ this -> select ) || in_array ( 'GROUP_ID' , $ this -> select ) || in_array ( 'GROUPS_ID' , $ this -> select ) ; }
6711	protected function urlToParameters ( $ url ) { $ urlParameters = [ ] ; $ url = parse_url ( $ url , PHP_URL_PATH ) ; $ urlParts = explode ( '/' , $ url ) ; reset ( $ urlParts ) ; $ key = next ( $ urlParts ) ; while ( ( $ value = next ( $ urlParts ) ) !== false ) { $ urlParameters [ $ key ] = $ value ; $ key = $ value ; } return $ urlParameters ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
8170	public function recoverPassword ( ) { $ user = User :: findOne ( [ 'email' => $ this -> email ] ) ; if ( $ user != NULL ) { $ user -> password_reset_token = Yii :: $ app -> getSecurity ( ) -> generateRandomString ( ) . '_' . time ( ) ; $ user -> save ( FALSE ) ; } Mailer :: sendRecoveryMessage ( $ user ) ; Yii :: $ app -> session -> setFlash ( 'info' , 'You will receive an email with instructions on how to reset your password in a few minutes.' ) ; }
1718	public function onKernelRequest ( GetResponseEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser || ! $ user -> language ) { return ; } $ request = $ event -> getRequest ( ) ; $ request -> setLocale ( $ user -> language ) ; $ this -> translator -> setLocale ( $ user -> language ) ; $ GLOBALS [ 'TL_LANGUAGE' ] = str_replace ( '_' , '-' , $ user -> language ) ; }
938	public function isGivenKind ( $ possibleKind ) { return $ this -> isArray && ( \ is_array ( $ possibleKind ) ? \ in_array ( $ this -> id , $ possibleKind , true ) : $ this -> id === $ possibleKind ) ; }
1377	protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; }
8765	public static function getNextAvailableVariableName ( string $ variable , array $ usedVariables ) : string { $ variable = self :: toVariableName ( $ variable ) ; while ( true ) { if ( ! in_array ( $ variable , $ usedVariables , true ) ) { break ; } $ numbers = '' ; while ( true ) { $ lastCharacter = substr ( $ variable , strlen ( $ variable ) - 1 ) ; if ( $ lastCharacter >= '0' && $ lastCharacter <= '9' ) { $ numbers = $ lastCharacter . $ numbers ; $ variable = substr ( $ variable , 0 , strlen ( $ variable ) - 1 ) ; } else { break ; } } if ( $ numbers === '' ) { $ numbers = 0 ; } else { $ numbers = ( int ) $ numbers ; } ++ $ numbers ; $ variable = $ variable . $ numbers ; } return $ variable ; }
12164	private function createAuthorityTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority` ( `authority_id` bigint(20) NOT NULL AUTO_INCREMENT, `authority_title` varchar(100) NOT NULL, `authority_parent_id` bigint(20) NOT NULL, `authority_name` varchar(45) NOT NULL COMMENT ' ', `authority_description` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, PRIMARY KEY (`authority_id`), UNIQUE KEY `authority_name_UNIQUE` (`authority_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority` (`authority_id`, `authority_title`, `authority_parent_id`, `authority_name`, `authority_description`, `lft`, `rgt`) VALUES (1, 'PUBLIC', 0, 'PUBLIC', 'All unregistered nodes, users and applications', 1, 8), (2, 'Registered Users', 1, 'REGISTEREDUSERS', 'All registered nodes with a known unique identifier', 2, 7), (3, 'Moderators', 2, 'MODERATORS', 'System moderators, Users allowed to manage user generated import', 3, 6), (4, 'Super Administrators', 3, 'MASTERADMINISTRATORS', 'Special users with awesome powers', 4, 5);" ) ; }
1058	public static function findTypesRemovedFromUnions ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ typesRemovedFromUnion = [ ] ; foreach ( $ oldTypeMap as $ typeName => $ oldType ) { $ newType = $ newTypeMap [ $ typeName ] ?? null ; if ( ! ( $ oldType instanceof UnionType ) || ! ( $ newType instanceof UnionType ) ) { continue ; } $ typeNamesInNewUnion = [ ] ; foreach ( $ newType -> getTypes ( ) as $ type ) { $ typeNamesInNewUnion [ $ type -> name ] = true ; } foreach ( $ oldType -> getTypes ( ) as $ type ) { if ( isset ( $ typeNamesInNewUnion [ $ type -> name ] ) ) { continue ; } $ typesRemovedFromUnion [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED_FROM_UNION , 'description' => sprintf ( '%s was removed from union type %s.' , $ type -> name , $ typeName ) , ] ; } } return $ typesRemovedFromUnion ; }
6669	public function set_movie_params ( ) { $ post_id = get_the_ID ( ) ; $ is_active = $ this -> get_rating_state ( $ post_id ) ; $ options = $ this -> model -> get_theme_options ( ) ; $ params = [ 'postID' => $ post_id , 'dark' => $ options [ 'enable-dark' ] , 'imdb_button' => __ ( 'TOTAL' , 'extensions-for-grifus-rating' ) , 'is_active' => $ is_active , ] ; return $ params ; }
5942	public function readLine ( $ token = "\n" ) { $ this -> connect ( ) ; $ line = StringHelper :: factory ( "" ) ; while ( ! $ line -> endsWith ( $ token ) ) { $ this -> waitForReadyRead ( ) ; $ data = @ fgets ( $ this -> stream , 4096 ) ; Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "DataRead" , $ data ) ; if ( $ data === false ) { if ( $ line -> count ( ) ) { $ line -> append ( $ token ) ; } else { throw new Ts3Exception ( "connection to server '" . $ this -> config [ "host" ] . ":" . $ this -> config [ "port" ] . "' lost" ) ; } } else { $ line -> append ( $ data ) ; } } return $ line -> trim ( ) ; }
11675	public function homepageTemplate ( ) { if ( null === $ this -> homepageTemplate ) { $ homepageFile = $ this -> pagesDir . "/" . $ this -> homepage ( ) . '/page.json' ; $ page = json_decode ( FilesystemTools :: readFile ( $ homepageFile ) , true ) ; $ this -> homepageTemplate = $ page [ "template" ] ; } return $ this -> homepageTemplate ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
2151	public function onToggleVisibility ( $ blnDisabled , DataContainer $ dc ) { if ( ! $ dc -> id ) { return $ blnDisabled ; } $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET tstamp=?, active=? WHERE email=?" ) -> execute ( time ( ) , ( $ blnDisabled ? '' : '1' ) , $ objUser -> email ) ; } return $ blnDisabled ; }
1721	private function getStringRepresentation ( array $ chunks , $ value ) : string { switch ( \ count ( $ chunks ) ) { case 2 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteValue ( $ value ) ) ; case 3 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteValue ( $ value ) ) ; case 4 : return sprintf ( "\$GLOBALS['TL_LANG']['%s'][%s][%s][%s] = %s;\n" , $ chunks [ 0 ] , $ this -> quoteKey ( $ chunks [ 1 ] ) , $ this -> quoteKey ( $ chunks [ 2 ] ) , $ this -> quoteKey ( $ chunks [ 3 ] ) , $ this -> quoteValue ( $ value ) ) ; } throw new \ OutOfBoundsException ( 'Cannot load less than 2 or more than 4 levels in XLIFF language files.' ) ; }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
5529	protected function chainMockReturns ( ) { $ code = " function returns(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValue(\$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returns(\$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByValueAt(\$timing, \$method, \$value, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByValueAt(\$timing, \$method, \$value, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReference(\$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReference(\$method, \$ref, \$args);\n" ; $ code .= " }\n" ; $ code .= " function returnsByReferenceAt(\$timing, \$method, &\$ref, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->returnsByReferenceAt(\$timing, \$method, \$ref, \$args);\n" ; $ code .= " }\n" ; return $ code ; }
5956	public function channelClientPermList ( $ cid , $ cldbid , $ permsid = false ) { return $ this -> execute ( "channelclientpermlist" , array ( "cid" => $ cid , "cldbid" => $ cldbid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
5223	protected function getValueCreator ( $ value ) { if ( is_string ( $ value ) && class_exists ( $ value ) ) { return function ( $ injector ) use ( $ value ) { return $ injector -> getInstance ( $ value ) ; } ; } return function ( ) use ( $ value ) { return $ value ; } ; }
2090	public static function countPublishedBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.source=? AND $t.parent=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.published='1'" ; } return static :: countBy ( $ arrColumns , array ( $ strSource , ( int ) $ intParent ) ) ; }
3667	private function getRow ( $ rowId , $ table ) { return ( object ) $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'id=:id' ) -> setParameter ( 'id' , $ rowId ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
11239	public function run ( ) { if ( count ( $ this -> errors ) == 0 ) { return true ; } else { $ this -> controller -> setData ( 'errors' , $ this -> errors ) ; return false ; } }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
9864	private function writeDataValidations ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ dataValidationCollection = $ pSheet -> getDataValidationCollection ( ) ; if ( ! empty ( $ dataValidationCollection ) ) { $ dataValidationCollection = Coordinate :: mergeRangesInCollection ( $ dataValidationCollection ) ; $ objWriter -> startElement ( 'dataValidations' ) ; $ objWriter -> writeAttribute ( 'count' , count ( $ dataValidationCollection ) ) ; foreach ( $ dataValidationCollection as $ coordinate => $ dv ) { $ objWriter -> startElement ( 'dataValidation' ) ; if ( $ dv -> getType ( ) != '' ) { $ objWriter -> writeAttribute ( 'type' , $ dv -> getType ( ) ) ; } if ( $ dv -> getErrorStyle ( ) != '' ) { $ objWriter -> writeAttribute ( 'errorStyle' , $ dv -> getErrorStyle ( ) ) ; } if ( $ dv -> getOperator ( ) != '' ) { $ objWriter -> writeAttribute ( 'operator' , $ dv -> getOperator ( ) ) ; } $ objWriter -> writeAttribute ( 'allowBlank' , ( $ dv -> getAllowBlank ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showDropDown' , ( ! $ dv -> getShowDropDown ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showInputMessage' , ( $ dv -> getShowInputMessage ( ) ? '1' : '0' ) ) ; $ objWriter -> writeAttribute ( 'showErrorMessage' , ( $ dv -> getShowErrorMessage ( ) ? '1' : '0' ) ) ; if ( $ dv -> getErrorTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'errorTitle' , $ dv -> getErrorTitle ( ) ) ; } if ( $ dv -> getError ( ) !== '' ) { $ objWriter -> writeAttribute ( 'error' , $ dv -> getError ( ) ) ; } if ( $ dv -> getPromptTitle ( ) !== '' ) { $ objWriter -> writeAttribute ( 'promptTitle' , $ dv -> getPromptTitle ( ) ) ; } if ( $ dv -> getPrompt ( ) !== '' ) { $ objWriter -> writeAttribute ( 'prompt' , $ dv -> getPrompt ( ) ) ; } $ objWriter -> writeAttribute ( 'sqref' , $ coordinate ) ; if ( $ dv -> getFormula1 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula1' , $ dv -> getFormula1 ( ) ) ; } if ( $ dv -> getFormula2 ( ) !== '' ) { $ objWriter -> writeElement ( 'formula2' , $ dv -> getFormula2 ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
2330	public function next ( ) { if ( ! isset ( $ this -> arrModels [ $ this -> intIndex + 1 ] ) ) { return false ; } ++ $ this -> intIndex ; return $ this ; }
10381	protected static function unify_files ( $ params , $ data = '' ) { $ type = $ params [ 'type' ] ; $ routes = $ params [ 'routes' ] ; $ extension = ( 'style' == $ type ) ? '.css' : '.js' ; $ hash = sha1 ( implode ( '' , $ params [ 'files' ] ) ) ; $ min_file = $ routes [ 'path' ] . $ hash . $ extension ; if ( ! is_file ( $ min_file ) || self :: $ changes ) { foreach ( $ params [ 'paths' ] as $ id => $ path ) { if ( isset ( $ params [ 'urls' ] [ $ id ] ) ) { $ url = $ params [ 'urls' ] [ $ id ] ; $ path = $ routes [ 'path' ] . $ params [ 'files' ] [ $ id ] ; $ data .= self :: save_external_file ( $ url , $ path ) ; } $ data .= file_get_contents ( $ path ) ; } $ data = ( self :: $ minify ) ? self :: compress_files ( $ data ) : $ data ; self :: save_file ( $ min_file , $ data ) ; } self :: set_processed_files ( ) ; return self :: set_new_params ( $ type , $ hash , $ routes [ 'url' ] , $ extension ) ; }
9913	function getFieldValue ( $ fieldName ) { $ name = trim ( $ fieldName ) ; if ( isset ( $ this -> fields ) ) { return ( $ this -> fields [ $ name ] ) ; } return ; }
7287	public function getInvoicedAt ( $ latest = false ) { if ( 0 == $ this -> invoices -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'type' , InvoiceTypes :: TYPE_INVOICE ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ invoices = $ this -> invoices ; $ invoices = $ invoices -> matching ( $ criteria ) ; if ( false !== $ invoice = $ invoices -> first ( ) ) { return $ invoice -> getCreatedAt ( ) ; } return null ; }
10640	protected function createUniquePath ( UploadedFile $ file ) { $ dir = 'mmmb/' . mb_substr ( mb_strtolower ( ( string ) $ file -> getClientOriginalName ( ) ) , 0 , 2 ) ; $ filename = str_replace ( array ( ' ' , $ file -> getClientOriginalExtension ( ) ) , '-' , $ file -> getClientOriginalName ( ) ) ; $ name = mb_strtolower ( $ filename . uniqid ( ) . '.' . $ file -> getClientOriginalExtension ( ) ) ; return array ( 'dir' => $ dir , 'filename' => $ name , 'path' => $ dir . '/' . $ name , ) ; }
4837	public function confirm_resource ( $ params ) { $ endpoint = '/confirm' ; $ required_params = array ( 'resource_id' , 'resource_type' ) ; foreach ( $ required_params as $ key => $ value ) { if ( ! isset ( $ params [ $ value ] ) ) { throw new GoCardless_ArgumentsException ( "$value missing" ) ; } $ data [ $ value ] = $ params [ $ value ] ; } if ( isset ( $ params [ 'state' ] ) ) { $ data [ 'state' ] = $ params [ 'state' ] ; } if ( isset ( $ params [ 'resource_uri' ] ) ) { $ data [ 'resource_uri' ] = $ params [ 'resource_uri' ] ; } $ sig_validation_data = array ( 'data' => $ data , 'secret' => $ this -> account_details [ 'app_secret' ] , 'signature' => $ params [ 'signature' ] ) ; if ( $ this -> validate_signature ( $ sig_validation_data ) == false ) { throw new GoCardless_SignatureException ( ) ; } $ confirm_params = array ( 'resource_id' => $ params [ 'resource_id' ] , 'resource_type' => $ params [ 'resource_type' ] ) ; $ confirm_params [ 'http_authorization' ] = $ this -> account_details [ 'app_id' ] . ':' . $ this -> account_details [ 'app_secret' ] ; if ( ! isset ( $ params [ 'redirect_uri' ] ) && isset ( $ this -> redirect_uri ) ) { $ confirm_params [ 'redirect_uri' ] = $ this -> redirect_uri ; } $ response = $ this -> request ( 'post' , $ endpoint , $ confirm_params ) ; if ( $ response [ 'success' ] == true ) { $ endpoint = '/' . $ params [ 'resource_type' ] . 's/' . $ params [ 'resource_id' ] ; $ class_name = 'GoCardless_' . GoCardless_Utils :: camelize ( $ params [ 'resource_type' ] ) ; return new $ class_name ( $ this , $ this -> request ( 'get' , $ endpoint ) ) ; } else { throw new GoCardless_ClientException ( 'Failed to fetch the confirmed resource.' ) ; } }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
1673	public function isUnprotected ( ) { $ path = $ this -> strFolder ; do { if ( file_exists ( $ this -> strRootDir . '/' . $ path . '/.public' ) ) { return true ; } $ path = \ dirname ( $ path ) ; } while ( $ path != '.' ) ; return false ; }
12957	public function authenticate ( ) { $ identity = $ this -> getIdentity ( ) ; $ results = $ this -> model -> findByIdentity ( $ identity ) ; $ identityObject = null ; $ count = 0 ; foreach ( $ results as $ identityObject ) { if ( $ count > 1 ) { return new Result ( Result :: FAILURE_IDENTITY_AMBIGUOUS , $ identity , [ 'More than one record matches the supplied identity.' ] ) ; } $ count ++ ; } if ( $ count == 0 ) { return new Result ( Result :: FAILURE_IDENTITY_NOT_FOUND , $ identity , [ 'A record with the supplied identity could not be found.' ] ) ; } if ( $ identityObject instanceof ObjectInterface ) { if ( $ identityObject -> validateCredential ( $ this -> getCredential ( ) ) ) { return new Result ( Result :: SUCCESS , $ identity ) ; } return new Result ( Result :: FAILURE_CREDENTIAL_INVALID , $ identity , [ 'wrong password' ] ) ; } return new Result ( Result :: FAILURE_UNCATEGORIZED , $ identity , [ 'generic error' ] ) ; }
12901	private function addSource ( array $ arguments = array ( ) ) { $ this -> builder -> addSource ( array_key_exists ( 'cache' , $ this -> source ) ? $ this -> createCacheAdapter ( ) : new HttpApiAdapter ( ) , new Request ( array ( 'source' => $ this -> source , 'arguments' => $ arguments , 'service' => $ this -> getGroup ( ) -> getService ( ) -> getName ( ) , 'group' => $ this -> getGroup ( ) -> getName ( ) , 'action' => $ this -> getName ( ) , ) ) ) ; }
2640	public function cleanUrl ( $ url ) { $ result = $ this -> _purge ( $ url , 'PURGE' , 'PURGE' ) ; if ( $ result [ 'status' ] ) { $ this -> logger -> execute ( $ url ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishKeyUrlChanges ( ) ) { $ this -> sendWebHook ( '*clean by URL for* ' . $ url ) ; } return $ result ; }
7985	public function getAvailableOptions ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/availableOptions' ) -> send ( ) ; } catch ( ClientErrorResponseException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == '404' && json_decode ( $ e -> getResponse ( ) -> getBody ( ) ) -> message == "No options found" ) return "[]" ; else throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
6285	public static function unsignedShiftRight ( $ a , $ b ) { if ( $ b == 0 ) { return $ a ; } if ( $ a & 0x80000000 ) { return ( ( $ a & 0x7fffffff ) >> $ b ) | ( 0x40000000 >> ( $ b - 1 ) ) ; } else { return $ a >> $ b ; } }
11570	final public static function load ( & $ object , & $ params ) { $ attachments = static :: getInstance ( ) ; $ attachment = & $ object ; if ( ! is_a ( $ attachment , Entity :: class ) ) { $ attachment = $ attachments -> loadObjectByURI ( $ attachment ) ; } if ( $ attachment -> getObjectType ( ) !== "attachment" ) return false ; $ fileId = $ attachment -> getObjectType ( ) ; $ filePath = FSPATH . DS . $ attachment -> getPropertyValue ( "attachment_src" ) ; $ contentType = $ attachment -> getPropertyValue ( "attachment_type" ) ; static :: place ( $ fileId , $ filePath , $ contentType , $ params ) ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
6653	public function removeExtraData ( array $ extraDataKeys = [ ] ) { foreach ( $ extraDataKeys as $ key ) { if ( array_key_exists ( $ key , $ this -> extraData ) ) { unset ( $ this -> extraData [ $ key ] ) ; } } }
7148	public function getTotal ( $ discounted = true ) { $ base = $ this -> base ; if ( $ discounted && $ this -> hasDiscounts ( ) ) { foreach ( $ this -> discounts as $ discount ) { $ base -= $ this -> calculateAdjustment ( $ discount , $ base ) ; } } $ total = $ base ; if ( ! empty ( $ this -> taxes ) && $ this -> mode === VatDisplayModes :: MODE_ATI ) { foreach ( $ this -> taxes as $ tax ) { $ total += $ this -> calculateAdjustment ( $ tax , $ base ) ; } } return $ total ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
6090	public function addMediaToMoodboard ( $ moodboardId , array $ mediaIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'mediaIds' => $ mediaIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ moodboardId . '/media' , $ parameters ) ; return $ result ; }
9721	public function getSamples ( ) { $ baseDir = realpath ( __DIR__ . '/../../../samples' ) ; $ directory = new RecursiveDirectoryIterator ( $ baseDir ) ; $ iterator = new RecursiveIteratorIterator ( $ directory ) ; $ regex = new RegexIterator ( $ iterator , '/^.+\.php$/' , RecursiveRegexIterator :: GET_MATCH ) ; $ files = [ ] ; foreach ( $ regex as $ file ) { $ file = str_replace ( $ baseDir . '/' , '' , $ file [ 0 ] ) ; $ info = pathinfo ( $ file ) ; $ category = str_replace ( '_' , ' ' , $ info [ 'dirname' ] ) ; $ name = str_replace ( '_' , ' ' , preg_replace ( '/(|\.php)/' , '' , $ info [ 'filename' ] ) ) ; if ( ! in_array ( $ category , [ '.' , 'boostrap' , 'templates' ] ) ) { if ( ! isset ( $ files [ $ category ] ) ) { $ files [ $ category ] = [ ] ; } $ files [ $ category ] [ $ name ] = $ file ; } } ksort ( $ files ) ; foreach ( $ files as & $ f ) { asort ( $ f ) ; } return $ files ; }
10917	private function isCmsActive ( ) { $ melisCms = 'MelisCms' ; $ moduleSvc = $ this -> getServiceLocator ( ) -> get ( 'ModulesService' ) ; $ modules = $ moduleSvc -> getActiveModules ( ) ; if ( in_array ( $ melisCms , $ modules ) ) { return true ; } return false ; }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
3451	protected function recordThat ( AggregateChanged $ event ) : void { $ this -> version += 1 ; $ this -> recordedEvents [ ] = $ event -> withVersion ( $ this -> version ) ; $ this -> apply ( $ event ) ; }
11249	public function log ( string $ file , int $ batch ) : void { $ stmt = $ this -> pdo -> prepare ( "insert into {$this->table} (migration, batch) values (?, ?)" ) ; $ stmt -> bindParam ( 1 , $ file ) ; $ stmt -> bindParam ( 2 , $ batch , PDO :: PARAM_INT ) ; $ stmt -> execute ( ) ; }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
1401	protected function isNoContent ( $ resource , $ links , $ meta ) { return is_null ( $ resource ) && empty ( $ links ) && empty ( $ meta ) ; }
12084	public function getObject ( Entity $ subject ) { $ object = NULL ; $ mediaObjectURI = $ subject -> getObjectURI ( ) ; if ( ! empty ( $ mediaObjectURI ) ) : $ mediaSubject = new Object ( ) ; $ mediaObjectType = $ subject -> getObjectType ( ) ; if ( is_object ( $ mediaSubject ) && method_exists ( $ mediaSubject , "getArray" ) ) : $ object = $ mediaSubject :: getArray ( ) ; endif ; else : endif ; return $ object ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
4602	public function encrypt ( $ data , string $ key = null ) : string { $ key = $ this -> createKey ( $ key ) ; $ data = Crypto :: encrypt ( serialize ( $ data ) , $ key ) ; return $ data ; }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
7731	public function supportsNormalization ( $ data , $ format = null ) { return is_object ( $ data ) && ( $ data instanceof \ DateTime ) && ( self :: FORMAT === $ format ) ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
9962	public function insertNewRowBefore ( $ pBefore , $ pNumRows = 1 ) { if ( $ pBefore >= 1 ) { $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . $ pBefore , 0 , $ pNumRows , $ this ) ; } else { throw new Exception ( 'Rows can only be inserted before at least row 1.' ) ; } return $ this ; }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
1163	public function validate ( $ field , $ parameters = [ ] ) { $ attribute = $ this -> parseAttributeName ( $ field ) ; $ validationParams = $ this -> parseParameters ( $ parameters ) ; $ validationResult = $ this -> validateJsRemoteRequest ( $ attribute , $ validationParams ) ; $ this -> throwValidationException ( $ validationResult , $ this -> validator ) ; }
7883	public function getDelete ( $ date ) { try { LogViewer :: delete ( $ date ) ; $ today = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return Redirect :: to ( 'logviewer/' . $ today . '/all' ) -> with ( 'success' , 'Log deleted successfully!' ) ; } catch ( \ Exception $ e ) { return Redirect :: to ( 'logviewer/' . $ date . '/all' ) -> with ( 'error' , 'There was an error while deleting the log.' ) ; } }
1202	public function buildItem ( ItemInterface $ item , array $ options ) { $ item -> setUri ( $ options [ 'uri' ] ) -> setLabel ( $ options [ 'label' ] ) -> setAttributes ( $ options [ 'attributes' ] ) -> setLinkAttributes ( $ options [ 'linkAttributes' ] ) -> setChildrenAttributes ( $ options [ 'childrenAttributes' ] ) -> setLabelAttributes ( $ options [ 'labelAttributes' ] ) -> setCurrent ( $ options [ 'current' ] ) -> setDisplay ( $ options [ 'display' ] ) -> setDisplayChildren ( $ options [ 'displayChildren' ] ) ; $ this -> buildExtras ( $ item , $ options ) ; }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
5532	protected function createCodeForOverridenMethods ( $ methods ) { $ code = '' ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) . " {\n" ; $ code .= " return \$this->mock->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } return $ code ; }
12569	public function previewText ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_TEXT , $ message , $ to , $ by ) ; }
9652	protected function initFormField ( ) { $ options = $ this -> Options ( ) -> map ( 'EscapedTitle' , 'Title' ) ; return new OptionsetField ( $ this -> Name , $ this -> Title , $ options ) ; }
6732	protected function processMessage ( & $ message ) { if ( ! $ message instanceof \ Closure ) { return ; } $ callback = $ message ; $ message = $ callback ( $ this -> model ) ; }
10888	public function addOption ( $ short , $ long , $ arg , $ description ) { $ this -> parameters [ ] = array ( $ short , $ long , $ arg , $ description ) ; return $ this ; }
3884	private function createSetting ( $ dbResult , $ filterSettings ) { $ factory = $ this -> getTypeFactory ( $ dbResult [ 'type' ] ) ; if ( $ factory ) { $ setting = $ factory -> createInstance ( $ dbResult , $ filterSettings ) ; if ( ! $ setting ) { return null ; } if ( $ factory -> isNestedType ( ) ) { $ this -> collectRulesFor ( $ setting , $ filterSettings ) ; } return $ setting ; } return null ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
10737	public function parse ( string $ string ) : self { $ pattern = '/^[\[\(]-?(\d*[\.]?\d+|INF), -?(\d*[\.]?\d+|INF)[\]\)]$/' ; if ( ! preg_match ( $ pattern , $ string ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval; see the README for details" ) ; } $ this -> isLowerInclusive = substr ( $ string , 0 , 1 ) === '[' ; $ this -> isUpperInclusive = substr ( $ string , - 1 , 1 ) === ']' ; $ endpoints = explode ( $ this -> separator , substr ( $ string , 1 , - 1 ) ) ; foreach ( $ endpoints as & $ endpoint ) { if ( $ endpoint === self :: INFINITY_NEGATIVE ) { $ endpoint = - INF ; } elseif ( $ endpoint === self :: INFINITY_POSITIVE ) { $ endpoint = INF ; } else { $ endpoint = + $ endpoint ; } } if ( $ endpoints [ 1 ] < $ endpoints [ 0 ] ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the upper bound appears to be greater " . "than the lower bound" ) ; } if ( $ endpoints [ 0 ] == $ endpoints [ 1 ] && $ this -> isLowerInclusive !== $ this -> isUpperInclusive ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the endpoints are the same but the " . "boundaries are different" ) ; } $ this -> lower = $ endpoints [ 0 ] ; $ this -> upper = $ endpoints [ 1 ] ; return $ this ; }
2166	public static function convertOrderField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field LIKE '%,%'" ) ; while ( $ objRow -> next ( ) ) { $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( serialize ( explode ( ',' , $ objRow -> $ field ) ) , $ objRow -> id ) ; } static :: convertMultiField ( $ table , $ field ) ; }
12325	protected function execute ( InputInterface $ input , OutputInterface $ output ) { try { $ this -> doPreExecute ( $ input , $ output ) ; $ this -> returnCode = $ this -> doExecute ( $ input , $ output ) ; $ this -> doPostExecute ( $ input , $ output ) ; } catch ( Exception $ e ) { $ this -> returnCode = static :: RETURN_ERROR ; throw $ e ; } return $ this -> returnCode ; }
7973	public function purchase ( $ domain , $ quantity ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ quantity ) throw new BadMethodCallException ( 'Parameter $quantity is missing.' ) ; $ quantity = intval ( $ quantity ) ; $ allowedQ = array ( 100 , 200 , 250 , 500 , 1000 , 5000 , 2500 , 10000 , 50000 , 100000 ) ; if ( ! in_array ( $ quantity , $ allowedQ ) ) throw new BadMethodCallException ( 'Parameter $quantity must be in array (' . implode ( ', ' , $ allowedQ ) . '), "' . $ quantity . '" given.' ) ; try { $ r = $ this -> post ( 'sms/' . $ domain . '/purchase' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ quantity ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
10323	private function createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , $ source , $ embedFieldBackups ) { $ queryParameters = array ( 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; if ( isset ( $ fromDate ) ) $ queryParameters [ 'from_date' ] = $ fromDate ; if ( isset ( $ toDate ) ) $ queryParameters [ 'to_date' ] = $ toDate ; if ( isset ( $ source ) ) $ queryParameters [ 'source' ] = $ source ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "ids" , $ contactIds ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "emails" , $ contactEmails ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , "eids" , $ contactExternalIds ) ; if ( isset ( $ embedFieldBackups ) ) $ queryParameters [ 'embed_field_backups' ] = ( $ embedFieldBackups == true ) ? "true" : "false" ; if ( isset ( $ mailingIds ) ) { $ queryParameters [ 'mailing_id' ] = array ( ) ; foreach ( $ mailingIds as $ mailingId ) { $ queryParameters [ 'mailing_id' ] [ ] = $ mailingId ; } } return $ queryParameters ; }
7168	public function updateTab ( $ tabLabel , array $ formInputs ) { $ tabExists = false ; foreach ( $ this -> getTabs ( ) as $ tabIndex => $ tabInfo ) { if ( array_get ( $ tabInfo , 'label' ) === $ tabLabel ) { $ this -> currentTab = $ tabIndex ; $ this -> currentInputsGroup = null ; if ( count ( ( array ) array_get ( $ tabInfo , 'groups' , [ ] ) ) === 1 && is_int ( array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ) ) { $ this -> currentInputsGroup = array_keys ( $ tabInfo [ 'groups' ] ) [ 0 ] ; } $ tabExists = true ; break ; } } if ( ! $ tabExists ) { $ this -> newTab ( $ tabLabel ) ; } $ this -> setFormInputs ( $ formInputs ) ; $ this -> currentTab = null ; $ this -> currentInputsGroup = null ; return $ this ; }
4061	public function getLongMessage ( $ glue = ' ' ) { $ messages = array ( ) ; $ exception = $ this ; do { $ messages [ ] = $ exception -> getMessage ( ) ; } while ( null !== ( $ exception = $ exception -> getPrevious ( ) ) ) ; return implode ( $ glue , $ messages ) ; }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
2460	protected function paginationMenu ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; list ( $ offset , $ limit ) = explode ( ',' , $ this -> limit ) ; if ( isset ( $ _GET [ 'lp' ] ) ) { $ lp = ( int ) Input :: get ( 'lp' ) - 1 ; if ( $ lp >= 0 && $ lp < ceil ( $ this -> total / $ limit ) ) { $ session [ 'filter' ] [ $ filter ] [ 'limit' ] = ( $ lp * $ limit ) . ',' . $ limit ; $ objSessionBag -> replace ( $ session ) ; } $ this -> redirect ( preg_replace ( '/&(amp;)?lp=[^&]+/i' , '' , Environment :: get ( 'request' ) ) ) ; } if ( $ limit ) { Input :: setGet ( 'lp' , $ offset / $ limit + 1 ) ; } $ objPagination = new Pagination ( $ this -> total , $ limit , 7 , 'lp' , new BackendTemplate ( 'be_pagination' ) , true ) ; return $ objPagination -> generate ( ) ; }
1208	public function moveChildToPosition ( ItemInterface $ item , ItemInterface $ child , $ position ) { $ name = $ child -> getName ( ) ; $ order = array_keys ( $ item -> getChildren ( ) ) ; $ oldPosition = array_search ( $ name , $ order ) ; unset ( $ order [ $ oldPosition ] ) ; $ order = array_values ( $ order ) ; array_splice ( $ order , $ position , 0 , $ name ) ; $ item -> reorderChildren ( $ order ) ; }
1472	public function createRelationshipDocumentValidator ( $ document ) { return new Validation \ Spec \ RelationValidator ( $ this -> container -> make ( StoreInterface :: class ) , $ this -> createErrorTranslator ( ) , $ document ) ; }
1150	public function render ( $ view = null , $ selector = null ) { $ this -> view ( $ view ) ; $ this -> selector ( $ selector ) ; return View :: make ( $ this -> view , [ 'validator' => $ this -> getViewData ( ) ] ) -> render ( ) ; }
12364	public function updateSource ( ) { $ source = array ( "value" => $ this -> value , "tags" => $ this -> tags , "type" => $ this -> type , ) ; $ this -> source = Yaml :: dump ( $ source , 100 , 2 ) ; }
4518	public function preFlush ( PreFlushEventArgs $ args ) { $ entities = $ args -> getEntityManager ( ) -> getUnitOfWork ( ) -> getScheduledEntityInsertions ( ) ; foreach ( $ entities as $ entity ) { if ( ! $ entity instanceof Parameter ) { continue ; } $ entity -> setValue ( serialize ( $ entity -> getValue ( ) ) ) ; } }
8059	public function setSemaphore ( Semaphore $ semaphore ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } if ( ! $ semaphore -> isCreated ( ) ) { throw new \ InvalidArgumentException ( 'The Semaphore hasn\'t yet been created.' ) ; } $ this -> semaphore = $ semaphore ; return $ this ; }
10132	private function writePassword ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) || ! $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) { return ; } $ record = 0x0013 ; $ length = 0x0002 ; $ wPassword = hexdec ( $ this -> phpSheet -> getProtection ( ) -> getPassword ( ) ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ wPassword ) ; $ this -> append ( $ header . $ data ) ; }
8455	protected function argsForNextCommand ( $ args ) { if ( ! is_array ( $ args ) ) { $ args = func_get_args ( ) ; } $ this -> argumentsForNextCommand .= ' ' . implode ( ' ' , $ args ) ; return $ this ; }
10544	public function setSites ( array $ sites ) { $ this -> sites = array ( ) ; foreach ( $ sites as $ site ) $ this -> addSite ( $ site ) ; return $ this ; }
7328	private function configureVatNumberSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ VatNumberSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> vatNumberSubjectClassCache ) ) { return ; } $ this -> addMappings ( $ metadata , $ this -> getVatNumberSubjectMappings ( ) ) ; $ this -> vatNumberSubjectClassCache [ ] = $ class ; }
11757	public function delete ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE_COMMENT , $ params ] ) ; }
6341	final public static function init ( ) : void { $ className = static :: class ; self :: $ cache [ $ className ] = [ ] ; $ reflectionClass = self :: objectClass ( ) ; $ constructorParams = static :: constructorArgs ( ) ; $ ordinal = 0 ; foreach ( $ reflectionClass -> getProperties ( ReflectionProperty :: IS_STATIC ) as $ property ) { if ( $ property -> isPublic ( ) ) { $ name = $ property -> getName ( ) ; $ instance = self :: newInstance ( $ name , $ constructorParams ) ; $ property -> setValue ( $ instance ) ; self :: $ cache [ $ className ] [ $ name ] = $ instance ; self :: $ ordinals [ $ className ] [ $ name ] = $ ordinal ++ ; } } }
1514	public function update ( StoreInterface $ store , UpdateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doUpdate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> updated ( $ record ) ; }
7761	protected function validateMappingConfiguration ( array $ mappingConfig , $ mappingName ) { if ( ! $ mappingConfig [ 'type' ] || ! $ mappingConfig [ 'dir' ] || ! $ mappingConfig [ 'prefix' ] ) { throw new \ InvalidArgumentException ( sprintf ( 'Hydra mapping definitions for "%s" require at least the "type", "dir" and "prefix" options.' , $ mappingName ) ) ; } if ( ! is_dir ( $ mappingConfig [ 'dir' ] ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Specified non-existing directory "%s" as Hydra mapping source.' , $ mappingConfig [ 'dir' ] ) ) ; } if ( ! in_array ( $ mappingConfig [ 'type' ] , array ( 'xml' , 'yml' , 'annotation' , 'php' , 'staticphp' ) ) ) { throw new \ InvalidArgumentException ( 'Can only configure "xml", "yml", "annotation", "php" or ' . '"staticphp" through the HydraBundle. Use your own bundle to configure other metadata drivers. ' . 'You can register them by adding a new driver to the ' . '"hydra.metadata_driver" service definition.' ) ; } }
6718	protected function setParameter ( $ name , $ value ) { if ( ! is_scalar ( $ name ) ) { throw new \ Exception ( 'Parameter name must be scalar' ) ; } $ this -> parameters [ $ name ] = $ value ; return $ this ; }
3256	public function map ( Router $ router ) { $ router -> group ( [ 'namespace' => 'Amsgames\LaravelShop\Http\Controllers' ] , function ( $ router ) { $ router -> group ( [ 'prefix' => 'shop' ] , function ( $ router ) { $ router -> get ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; $ router -> post ( 'callback/payment/{status}/{id}/{shoptoken}' , [ 'as' => 'shop.callback' , 'uses' => 'Shop\CallbackController@process' ] ) ; } ) ; } ) ; }
9650	public function delete ( ) { $ options = $ this -> Options ( ) ; if ( $ options ) { foreach ( $ options as $ option ) { $ option -> delete ( ) ; } } parent :: delete ( ) ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
11722	public function getPosts ( $ limit = null , $ offset = null ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; if ( is_null ( $ limit ) && is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) ) ; } elseif ( is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit ) ; } elseif ( ! is_null ( $ limit ) && ! is_null ( $ offset ) ) { $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( ) , array ( 'published' => 'DESC' ) , $ limit , $ offset ) ; } return $ entities ; }
4005	protected function createInstanceViaLegacyFactory ( CreateMetaModelEvent $ event , $ arrData ) { $ name = $ arrData [ 'tableName' ] ; if ( ! isset ( $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ) ) { return false ; } @ trigger_error ( 'Creating MetaModel instances via global factories is deprecated.' , E_USER_DEPRECATED ) ; $ factoryClass = $ GLOBALS [ 'METAMODELS' ] [ 'factories' ] [ $ name ] ; $ event -> setMetaModel ( call_user_func_array ( array ( $ factoryClass , 'createInstance' ) , array ( $ arrData ) ) ) ; return $ event -> getMetaModel ( ) !== null ; }
9107	public function getMvcLayout ( MvcEvent $ e ) { try { $ resolver = $ this -> getResolverObject ( 'mvclayout_resolver_adapter' , array ( 'event_mvc' => $ e ) ) ; } catch ( \ Exception $ e ) { throw $ e ; } $ layout = $ resolver -> getName ( ) ; if ( empty ( $ layout ) && ! ( $ layout === '0' ) ) { return false ; } return $ layout ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
2449	public function editComment ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return $ this -> isAllowedToEditComment ( $ row [ 'parent' ] , $ row [ 'source' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg/i' , '_.svg' , $ icon ) ) . ' ' ; }
6751	private function createQualifiedTransformerClass ( ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ name = $ reflection -> getName ( ) ; $ qualifiedTransformerClass = $ name . "Transformer" ; $ this -> setTransformer ( $ qualifiedTransformerClass ) ; }
2107	public static function findOneByRelatedTableAndId ( $ strTable , $ intId , array $ arrOptions = array ( ) ) { @ trigger_error ( 'Using the Contao\OptInModel::findOneByRelatedTableAndIds() method has been deprecated and will no longer work in Contao 5.0. Use the Contao\OptInModel::findByRelatedTableAndIds() method instead.' , E_USER_DEPRECATED ) ; $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE id IN (SELECT pid FROM tl_opt_in_related WHERE relTable=? AND relId=?)" ) -> execute ( $ strTable , $ intId ) ; if ( $ objResult -> numRows < 1 ) { return null ; } $ objRegistry = Registry :: getInstance ( ) ; if ( $ objOptIn = $ objRegistry -> fetch ( $ t , $ objResult -> id ) ) { return $ objOptIn ; } return new static ( $ objResult ) ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
11702	public function add ( $ sName , $ mType , $ sLabel = null , $ mValue = null , $ mOptions = null ) { if ( $ mType instanceof Container ) { $ this -> _aElement [ $ sName ] = $ mType ; } else if ( $ mType === 'text' || $ mType === 'submit' || $ mType === 'password' || $ mType === 'file' || $ mType === 'tel' || $ mType === 'url' || $ mType === 'email' || $ mType === 'search' || $ mType === 'date' || $ mType === 'time' || $ mType === 'datetime' || $ mType === 'month' || $ mType === 'week' || $ mType === 'number' || $ mType === 'range' || $ mType === 'color' || $ mType === 'hidden' ) { $ this -> _aElement [ $ sName ] = new Input ( $ sName , $ mType , $ sLabel , $ mValue ) ; } elseif ( $ mType === 'textarea' ) { $ this -> _aElement [ $ sName ] = new Textarea ( $ sName , $ sLabel , $ mValue ) ; } else if ( $ mType === 'select' ) { $ this -> _aElement [ $ sName ] = new Select ( $ sName , $ mOptions , $ sLabel , $ mValue ) ; } else if ( $ mType === 'label' ) { $ this -> _aElement [ $ sName ] = new Label ( $ sName ) ; } else if ( $ mType === 'list_checkbox' ) { $ i = 0 ; $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Label ( $ sLabel ) ; foreach ( $ mValue as $ mKey => $ sValue ) { $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Checkbox ( $ sName , $ sValue , $ mKey , $ mOptions ) ; } } else if ( $ mType === 'checkbox' ) { $ this -> _aElement [ $ sName ] = new Checkbox ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } else if ( $ mType === 'radio' ) { $ this -> _aElement [ $ sName . rand ( 100000 , 999999 ) ] = new Radio ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } return $ this ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
721	public function money ( $ precision = null , $ scale = null ) { $ length = [ ] ; if ( $ precision !== null ) { $ length [ ] = $ precision ; } if ( $ scale !== null ) { $ length [ ] = $ scale ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_MONEY , $ length ) ; }
2155	public function getSearchablePages ( $ arrPages , $ intRoot = 0 , $ blnIsSitemap = false ) { $ arrRoot = array ( ) ; if ( $ intRoot > 0 ) { $ arrRoot = $ this -> Database -> getChildRecords ( $ intRoot , 'tl_page' ) ; } $ arrProcessed = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objNewsletter = NewsletterChannelModel :: findAll ( ) ; if ( $ objNewsletter !== null ) { while ( $ objNewsletter -> next ( ) ) { if ( ! $ objNewsletter -> jumpTo ) { continue ; } if ( ! empty ( $ arrRoot ) && ! \ in_array ( $ objNewsletter -> jumpTo , $ arrRoot ) ) { continue ; } if ( ! isset ( $ arrProcessed [ $ objNewsletter -> jumpTo ] ) ) { $ objParent = PageModel :: findWithDetails ( $ objNewsletter -> jumpTo ) ; if ( $ objParent === null ) { continue ; } if ( ! $ objParent -> published || ( $ objParent -> start != '' && $ objParent -> start > $ time ) || ( $ objParent -> stop != '' && $ objParent -> stop <= ( $ time + 60 ) ) ) { continue ; } if ( $ blnIsSitemap ) { if ( $ objParent -> protected ) { continue ; } if ( $ objParent -> sitemap == 'map_never' ) { continue ; } } $ arrProcessed [ $ objNewsletter -> jumpTo ] = $ objParent -> getAbsoluteUrl ( Config :: get ( 'useAutoItem' ) ? '/%s' : '/items/%s' ) ; } $ strUrl = $ arrProcessed [ $ objNewsletter -> jumpTo ] ; $ objItem = NewsletterModel :: findSentByPid ( $ objNewsletter -> id ) ; if ( $ objItem !== null ) { while ( $ objItem -> next ( ) ) { $ arrPages [ ] = sprintf ( preg_replace ( '/%(?!s)/' , '%%' , $ strUrl ) , ( $ objItem -> alias ? : $ objItem -> id ) ) ; } } } } return $ arrPages ; }
4216	private function clearErrors ( $ flags ) { $ clearErrors = $ flags & Debug :: CLEAR_LOG_ERRORS || $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( ! $ clearErrors ) { return ; } $ errorsNotCleared = array ( ) ; $ errorsNotCleared = $ this -> clearErrorsHelper ( $ this -> data [ 'log' ] , $ flags & Debug :: CLEAR_LOG_ERRORS ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ errorsNotCleared = \ array_merge ( $ this -> clearErrorsHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ flags & Debug :: CLEAR_SUMMARY_ERRORS ) ) ; } $ errorsNotCleared = \ array_unique ( $ errorsNotCleared ) ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; foreach ( $ errors as $ error ) { if ( ! \ in_array ( $ error [ 'hash' ] , $ errorsNotCleared ) ) { $ error [ 'inConsole' ] = false ; } } }
9238	private function getTextualPath ( array $ path , Vertex $ startVertex ) { $ currentVertex = $ startVertex ; $ currentTable = $ currentVertex -> getId ( ) ; $ textPath = $ currentTable ; foreach ( $ path as $ edge ) { if ( $ fk = $ edge -> getAttribute ( 'fk' ) ) { if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ fk -> getLocalTable ( ) -> getName ( ) ; $ isForward = false ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; $ isForward = true ; } $ columns = implode ( ',' , $ fk -> getLocalColumns ( ) ) ; $ textPath .= ' ' . ( ! $ isForward ? '<' : '' ) ; $ textPath .= '--(' . $ columns . ')--' ; $ textPath .= ( $ isForward ? '>' : '' ) . ' ' ; $ textPath .= $ currentTable ; } elseif ( $ junctionTable = $ edge -> getAttribute ( 'junction' ) ) { $ junctionFks = array_values ( $ junctionTable -> getForeignKeys ( ) ) ; $ fk = $ junctionFks [ 0 ] ; if ( $ fk -> getForeignTableName ( ) == $ currentTable ) { $ currentTable = $ junctionFks [ 1 ] -> getForeignTableName ( ) ; } else { $ currentTable = $ fk -> getForeignTableName ( ) ; } $ textPath .= ' <=(' . $ junctionTable -> getName ( ) . ')=> ' . $ currentTable ; } else { throw new SchemaAnalyzerException ( 'Unexpected edge. We should have a fk or a junction attribute.' ) ; } } return $ textPath ; }
6294	private function findPath ( $ directory ) { $ path = [ ] ; $ path [ ] = $ this -> basePath ; $ path [ ] = $ directory ; $ path [ ] = 'views' ; return implode ( DIRECTORY_SEPARATOR , $ path ) ; }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
2498	private function getLanguageFilter ( array $ languageCodes ) { $ languageFilters = array ( ) ; foreach ( $ languageCodes as $ languageCode ) { $ condition = new CustomField ( self :: FIELD_LANGUAGE , Operator :: EQ , $ languageCode ) ; $ excluded = $ this -> getExcludedLanguageCodes ( $ languageCodes , $ languageCode ) ; if ( ! empty ( $ excluded ) ) { $ condition = new LogicalAnd ( array ( $ condition , new LogicalNot ( new CustomField ( self :: FIELD_LANGUAGES , Operator :: IN , $ excluded ) ) , ) ) ; } $ languageFilters [ ] = $ condition ; } if ( count ( $ languageFilters ) > 1 ) { $ languageFilters = array ( new LogicalOr ( $ languageFilters ) ) ; } if ( $ this -> hasMainLanguagesEndpoint ) { $ languageFilters [ ] = new LogicalNot ( new CustomField ( self :: FIELD_IS_MAIN_LANGUAGES_INDEX , Operator :: EQ , true ) ) ; } if ( count ( $ languageFilters ) > 1 ) { return new LogicalAnd ( $ languageFilters ) ; } return reset ( $ languageFilters ) ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
8439	protected static function completeFilesCountsAndEditorLinks ( ) { if ( ! static :: $ files ) { $ rawList = get_included_files ( ) ; $ list = [ ] ; $ docRoot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; $ docRootLength = mb_strlen ( $ docRoot ) ; $ tracyFileDetectionSubstr = '/tracy' ; foreach ( $ rawList as & $ file ) { $ file = str_replace ( '\\' , '/' , $ file ) ; $ text = mb_substr ( $ file , $ docRootLength ) ; $ tracyFile = mb_stripos ( $ text , $ tracyFileDetectionSubstr ) !== FALSE ; if ( ! $ tracyFile ) static :: $ appFilesCount += 1 ; static :: $ allFilesCount += 1 ; $ href = \ Tracy \ Helpers :: editorUri ( $ file , 1 ) ; $ list [ ] = '<a ' . ( $ tracyFile ? 'class="tracy" ' : '' ) . 'href="' . $ href . '"><nobr>' . $ text . '</nobr></a><br />' ; } static :: $ files = & $ list ; } }
7044	private function getMetaModelTableNames ( $ keyTranslated , $ keyUntranslated ) { $ result = [ ] ; foreach ( $ this -> factory -> collectNames ( ) as $ table ) { $ metaModel = $ this -> factory -> getMetaModel ( $ table ) ; if ( null === $ metaModel ) { continue ; } if ( $ metaModel -> isTranslated ( ) ) { $ result [ $ keyTranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } else { $ result [ $ keyUntranslated ] [ $ table ] = \ sprintf ( '%s (%s)' , $ metaModel -> get ( 'name' ) , $ table ) ; } } return $ result ; }
8878	private function safeSendSignal ( $ process , string $ signal , int $ mappedSignal ) : void { if ( true !== proc_terminate ( $ process , $ mappedSignal ) ) { throw new CommandExecutionException ( 'Call to proc_terminate with signal "' . $ signal . '" failed for unknown reason.' ) ; } }
1984	public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
1918	public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; }
9618	public function registerStackMiddleware ( $ class ) { if ( func_num_args ( ) === 0 ) { throw new \ InvalidArgumentException ( "Missing argument(s) when calling registerStackMiddlerware" ) ; } if ( ! class_exists ( $ class ) && ! is_callable ( $ class ) ) { throw new \ InvalidArgumentException ( "{$class} not found or not callable" ) ; } call_user_func_array ( [ $ this -> builder , "push" ] , func_get_args ( ) ) ; }
10384	protected static function set_new_params ( $ type , $ hash , $ url , $ extension ) { $ data = [ 'name' => self :: $ id , 'url' => $ url . $ hash . $ extension , 'deps' => self :: unify_params ( $ type , 'deps' ) , 'version' => self :: unify_params ( $ type , 'version' , '1.0.0' ) , ] ; switch ( $ type ) { case 'style' : $ data [ 'media' ] = self :: unify_params ( $ type , 'media' , 'all' ) ; break ; case 'script' : $ data [ 'params' ] = self :: unify_params ( $ type , 'params' ) ; $ data [ 'footer' ] = self :: unify_params ( $ type , 'footer' , false ) ; $ data [ 'params' ] [ 'nonce' ] = wp_create_nonce ( self :: $ id ) ; break ; default : } self :: $ data [ $ type ] = [ $ data [ 'name' ] => $ data ] ; return true ; }
7878	protected function registerLogFilesystem ( ) { $ this -> app -> singleton ( 'logviewer.filesystem' , function ( $ app ) { $ files = $ app [ 'files' ] ; $ path = $ app [ 'path.storage' ] . '/logs' ; return new Filesystem ( $ files , $ path ) ; } ) ; $ this -> app -> alias ( 'logviewer.filesystem' , Filesystem :: class ) ; }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
4468	public function setPriority ( int $ priority ) : void { if ( $ this -> client -> call ( 'priority' , $ this -> jid , $ priority ) ) { parent :: setPriority ( $ priority ) ; } }
629	public function queryScalar ( ) { $ result = $ this -> queryInternal ( 'fetchColumn' , 0 ) ; if ( is_resource ( $ result ) && get_resource_type ( $ result ) === 'stream' ) { return stream_get_contents ( $ result ) ; } return $ result ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
8645	private function parseHttpHeader ( $ header ) { $ parsedHeader = array ( ) ; foreach ( explode ( "\n" , $ header ) as $ line ) { $ splitLine = preg_split ( '/:\s/' , $ line , 2 , PREG_SPLIT_NO_EMPTY ) ; if ( sizeof ( $ splitLine ) == 2 ) { $ k = strtolower ( trim ( $ splitLine [ 0 ] ) ) ; $ v = trim ( $ splitLine [ 1 ] ) ; if ( array_key_exists ( $ k , $ parsedHeader ) ) { $ parsedHeader [ $ k ] = $ parsedHeader [ $ k ] . "," . $ v ; } else { $ parsedHeader [ $ k ] = $ v ; } } } return $ parsedHeader ; }
3262	public static function callback ( $ order , $ transaction , $ status , $ data = null ) { $ statusCode = $ order -> statusCode ; try { if ( in_array ( $ status , [ 'success' , 'fail' ] ) ) { static :: $ gatewayKey = $ transaction -> gateway ; static :: $ gateway = static :: instanceGateway ( ) ; if ( $ status == 'success' ) { static :: $ gateway -> onCallbackSuccess ( $ order , $ data ) ; $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else if ( $ status == 'fail' ) { static :: $ gateway -> onCallbackFail ( $ order , $ data ) ; $ order -> statusCode = 'failed' ; } $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } catch ( GatewayException $ e ) { static :: setException ( $ e ) ; $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } static :: checkStatusChange ( $ order , $ statusCode ) ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
7465	public static function createFromUploadedFile ( UploadedFile $ upload , $ uploadPath , $ filename = null ) { if ( ! $ upload -> isValid ( ) ) { throw new UploadException ( sprintf ( 'An error occurred during file upload. Error code: %s' , $ upload -> getError ( ) ) ) ; } elseif ( ( $ uploadPath = realpath ( $ uploadPath . '/' ) ) === false ) { throw new UploadException ( 'An error occurred during file upload. The specified upload path is invalid.' ) ; } if ( ! $ filename ) { $ fullPath = sprintf ( '%s%s%s.%s' , rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) , DIRECTORY_SEPARATOR , uniqid ( ) , ( $ upload -> getExtension ( ) ? : ( $ upload -> guessExtension ( ) ? : 'file' ) ) ) ; } else { $ fullPath = rtrim ( $ uploadPath , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR . $ filename ; } $ file = new self ( $ fullPath , $ upload -> getClientOriginalName ( ) , $ upload -> getMimeType ( ) , $ upload -> getClientSize ( ) , md5_file ( $ upload -> getRealPath ( ) ) ) ; $ file -> _uploadedFile = $ upload ; return $ file ; }
10224	private function buildComplexIndexMenu ( $ modelName , $ modelId , ModelConfig $ config = null ) { $ model = $ this -> aujaConfigurator -> getModel ( $ modelName ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ associationRelations = array ( ) ; foreach ( $ relations as $ relation ) { if ( $ relation -> getType ( ) == Relation :: HAS_MANY || $ relation -> getType ( ) == Relation :: HAS_AND_BELONGS_TO ) { $ associationRelations [ ] = $ relation ; } } switch ( count ( $ associationRelations ) ) { case 0 : $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; break ; case 1 : $ menu = $ this -> singleAssociationMenuFor ( $ modelName , $ modelId , $ associationRelations [ 0 ] , $ config ) ; break ; default : $ menu = $ this -> multipleAssociationsMenuFor ( $ modelName , $ modelId , $ associationRelations , $ config ) ; break ; } return $ menu ; }
12154	public function getRequiredRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = false ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
2003	public static function getNormalizedVersion ( string $ packageName ) : string { $ chunks = explode ( '.' , static :: getVersion ( $ packageName ) ) ; $ chunks += [ 0 , 0 , 0 ] ; if ( \ count ( $ chunks ) > 3 ) { $ chunks = \ array_slice ( $ chunks , 0 , 3 ) ; } return implode ( '.' , $ chunks ) ; }
7321	public function dayOfYear ( ) { $ k = $ this -> isLeapYear ( ) ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ this -> month / 9 ) - $ k * intval ( ( ( int ) $ this -> month + 9 ) / 12 ) + ( int ) $ this -> day - 30 ; return ( int ) $ n ; }
2228	public function addBreadcrumb ( ) { $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; if ( isset ( $ _GET [ 'fn' ] ) ) { if ( Contao \ Validator :: isInsecurePath ( Contao \ Input :: get ( 'fn' , true ) ) ) { throw new RuntimeException ( 'Insecure path ' . Contao \ Input :: get ( 'fn' , true ) ) ; } $ objSessionBag -> set ( 'tl_templates_node' , Contao \ Input :: get ( 'fn' , true ) ) ; $ this -> redirect ( preg_replace ( '/(&|\?)fn=[^&]*/' , '' , Contao \ Environment :: get ( 'request' ) ) ) ; } $ strNode = $ objSessionBag -> get ( 'tl_templates_node' ) ; if ( $ strNode == '' ) { return ; } if ( Contao \ Validator :: isInsecurePath ( $ strNode ) ) { throw new RuntimeException ( 'Insecure path ' . $ strNode ) ; } $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( ! is_dir ( $ rootDir . '/' . $ strNode ) ) { $ objSessionBag -> set ( 'tl_templates_node' , '' ) ; return ; } $ strPath = 'templates' ; $ arrNodes = explode ( '/' , preg_replace ( '/^templates\//' , '' , $ strNode ) ) ; $ arrLinks = array ( ) ; $ arrLinks [ ] = Contao \ Image :: getHtml ( 'filemounts.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAllNodes' ] ) . '">' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'filterAll' ] . '</a>' ; foreach ( $ arrNodes as $ strFolder ) { $ strPath .= '/' . $ strFolder ; if ( $ strFolder == basename ( $ strNode ) ) { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' ' . $ strFolder ; } else { $ arrLinks [ ] = Contao \ Image :: getHtml ( 'folderC.svg' ) . ' <a href="' . $ this -> addToUrl ( 'fn=' . $ strPath ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectNode' ] ) . '">' . $ strFolder . '</a>' ; } } $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'root' ] = array ( $ strNode ) ; $ GLOBALS [ 'TL_DCA' ] [ 'tl_templates' ] [ 'list' ] [ 'sorting' ] [ 'breadcrumb' ] .= '<nav aria-label="' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'breadcrumbMenu' ] . '"> <ul id="tl_breadcrumb"> <li>' . implode ( ' › </li><li>', $ r rLinks) . ' /li> </ul></nav>' ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
11278	protected function populateStub ( string $ filename , string $ stub , ? string $ table = null ) : string { $ search = [ '{name}' , '{table}' ] ; $ replace = [ $ filename , $ table ? : 'dummy_table' ] ; return str_replace ( $ search , $ replace , $ stub ) ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
10175	public function getHighestColumn ( $ row = null ) { if ( $ row == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'column' ] ; } $ columnList = [ 1 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r != $ row ) { continue ; } $ columnList [ ] = Coordinate :: columnIndexFromString ( $ c ) ; } return Coordinate :: stringFromColumnIndex ( max ( $ columnList ) + 1 ) ; }
12824	protected function addBlockToSlot ( $ dir , array $ options ) { $ slot = $ this -> getSlotDefinition ( $ dir ) ; $ blocks = $ slot [ "blocks" ] ; $ blockName = $ options [ "blockname" ] ; $ position = $ options [ "position" ] ; array_splice ( $ blocks , $ position , 0 , $ blockName ) ; $ slot [ "next" ] = str_replace ( 'block' , '' , $ blockName ) + 1 ; $ slot [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ dir , $ slot ) ; return $ blockName ; }
8585	public function setProductGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ProductGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3706	public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
590	protected function compressJsFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing JavaScript files...\n" ) ; if ( is_string ( $ this -> jsCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineJsFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> jsCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> jsCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress JavaScript files into '{$outputFile}'." ) ; } $ this -> stdout ( " JavaScript files compressed into '{$outputFile}'.\n" ) ; }
8097	private function validate ( ) { $ server = new Collection ( $ _SERVER ) ; $ ip = $ server -> HTTP_X_FORWARDED_FOR ; if ( is_null ( $ ip ) && $ server -> REMOTE_ADDR ) { $ ip = $ server -> REMOTE_ADDR ; } if ( ! is_null ( $ this -> _ip ) ) { if ( $ this -> _ip != $ ip ) { $ this -> destroy ( ) ; } } else { $ this -> _ip = $ ip ; } }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
9261	public function map ( $ route , $ name , $ handler , array $ methods = array ( 'GET' ) ) { foreach ( $ methods as $ method ) { if ( null === $ name ) { $ this -> addRoute ( $ method , $ route , $ handler ) ; } else { $ this -> addNamedRoute ( $ name , $ method , $ route , $ handler ) ; } } }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
8024	public function destroy ( ) { if ( ! is_resource ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Semaphore hasn\'t yet been created.' ) ; } if ( ! sem_remove ( $ this -> semaphore ) ) { throw new SemaphoreException ( 'Cannot remove the semaphore.' ) ; } $ this -> semaphore = NULL ; $ this -> semKey = NULL ; return $ this ; }
7581	protected function verifyData ( ) { if ( isset ( $ this -> _DATA_TYPE ) || ! empty ( $ this -> _DATA_TYPE ) ) { $ this -> verifyDataType ( ) ; } if ( ! empty ( $ this -> _REQUIRED_DATA ) ) { $ this -> verifyRequiredData ( ) ; } return true ; }
12909	public function all ( ) { $ _filters = $ this -> filters ; if ( ! $ this -> allowDeleted ) { $ this -> filters = array ( "`" . $ this -> table . "`.deleted = 0" ) ; } else { $ this -> filters = array ( ) ; } $ values = $ this -> values ( ) ; $ this -> filters = $ _filters ; return $ values ; }
12356	public function generate ( ) { if ( ! $ this -> configurationHandler -> isTheme ( ) || $ this -> theme -> getName ( ) != $ this -> configurationHandler -> handledTheme ( ) ) { return ; } $ templates = array_keys ( $ this -> templates [ "template" ] ) ; $ homepage = json_decode ( file_get_contents ( $ this -> configurationHandler -> pagesDir ( ) . '/' . $ this -> configurationHandler -> homepage ( ) . '/page.json' ) , true ) ; $ homepageTemplate = $ homepage [ "template" ] ; if ( ! in_array ( $ homepageTemplate , $ templates ) ) { $ homepageTemplate = $ templates [ 0 ] ; } $ themeDefinition = array ( "home_template" => $ homepageTemplate , "templates" => $ templates , ) ; $ this -> synchronizeThemeSlots ( ) ; FilesystemTools :: writeFile ( $ this -> themeDir . '/theme.json' , json_encode ( $ themeDefinition ) ) ; }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
69	public function removeJunction ( $ junction ) { if ( ! Platform :: isWindows ( ) ) { return false ; } $ junction = rtrim ( str_replace ( '/' , DIRECTORY_SEPARATOR , $ junction ) , DIRECTORY_SEPARATOR ) ; if ( ! $ this -> isJunction ( $ junction ) ) { throw new IOException ( sprintf ( '%s is not a junction and thus cannot be removed as one' , $ junction ) ) ; } return $ this -> rmdir ( $ junction ) ; }
6767	protected function handleAddressChange ( SaleInterface $ sale ) { $ changed = false ; if ( $ this -> didDeliveryCountryChanged ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentMethodAndAmount ( $ sale ) ; } if ( $ this -> isDiscountUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateDiscounts ( $ sale , true ) ; } if ( $ this -> isTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateTaxation ( $ sale , true ) ; } elseif ( $ this -> isShipmentTaxationUpdateNeeded ( $ sale ) ) { $ changed |= $ this -> saleUpdater -> updateShipmentTaxation ( $ sale , true ) ; } return $ changed ; }
11764	protected function handleStage ( & $ stages , $ stage ) { if ( $ stage instanceof Pipeline ) { $ stages = array_merge ( $ stages , $ stage -> stages ( ) ) ; } elseif ( $ stage instanceof MiddlewareInterface ) { $ stages [ ] = $ stage ; } elseif ( $ stage instanceof RequestHandlerInterface ) { $ stages [ ] = new RequestHandler ( $ stage ) ; } elseif ( is_callable ( $ stage ) ) { $ stages [ ] = new Lambda ( $ stage ) ; } else { throw new InvalidMiddlewareArgument ( is_string ( $ stage ) ? $ stage : get_class ( $ stage ) ) ; } }
9938	private static function checkSheetTitle ( $ pValue ) { if ( str_replace ( self :: $ invalidCharacters , '' , $ pValue ) !== $ pValue ) { throw new Exception ( 'Invalid character found in sheet title' ) ; } if ( Shared \ StringHelper :: countCharacters ( $ pValue ) > 31 ) { throw new Exception ( 'Maximum 31 characters allowed in sheet title.' ) ; } return $ pValue ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
6299	public function addToBar ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } if ( $ first ) { $ this -> bar [ $ name ] = array_merge ( [ $ item ] , $ this -> bar [ $ name ] ) ; } else { $ this -> bar [ $ name ] [ ] = $ item ; } return $ this ; }
4392	public function checkConfigBE ( array $ attributes ) { return array_merge ( parent :: checkConfigBE ( $ attributes ) , $ this -> checkConfig ( $ this -> beConfig , $ attributes ) ) ; }
4417	public function showLocationLayouts ( $ locationId ) { $ repository = $ this -> getRepository ( ) ; $ location = $ repository -> getLocationService ( ) -> loadLocation ( $ locationId ) ; $ content = $ repository -> getContentService ( ) -> loadContent ( $ location -> contentInfo -> id ) ; $ request = $ this -> createRequest ( $ content , $ location ) ; return $ this -> render ( '@NetgenAdminUI/layouts/location_layouts.html.twig' , array ( 'rules' => $ this -> layoutResolver -> resolveRules ( $ request , array ( 'ez_content_type' ) ) , 'related_layouts' => $ this -> relatedLayoutsLoader -> loadRelatedLayouts ( $ location ) , 'location' => $ location , ) ) ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
6848	public static function days ( $ month , $ year = null ) { static $ months ; if ( ! isset ( $ year ) ) { $ year = date ( 'Y' ) ; } $ month = ( int ) $ month ; $ year = ( int ) $ year ; if ( empty ( $ months [ $ year ] [ $ month ] ) ) { $ total = date ( 't' , mktime ( 1 , 0 , 0 , $ month , 1 , $ year ) ) + 1 ; $ months [ $ year ] [ $ month ] = array ( ) ; for ( $ i = 1 ; $ i < $ total ; $ i ++ ) { $ months [ $ year ] [ $ month ] [ $ i ] = ( string ) $ i ; } } return $ months [ $ year ] [ $ month ] ; }
5373	public function getValue ( $ key ) { $ values = array ( ) ; foreach ( $ this -> request as $ pair ) { if ( $ pair -> isKey ( $ key ) ) { $ values [ ] = $ pair -> getValue ( ) ; } } if ( count ( $ values ) == 0 ) { return false ; } elseif ( count ( $ values ) == 1 ) { return $ values [ 0 ] ; } else { return $ values ; } }
7876	protected function generateRequestIfGuarded ( ) { if ( ! $ this -> option ( 'unguard' ) ) { $ name = $ this -> inflector -> getRequest ( ) ; $ this -> call ( 'make:request' , compact ( 'name' ) ) ; } }
3237	public function getTotalAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return $ this -> totalPrice + $ this -> totalTax + $ this -> totalShipping ; }
4570	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Encryptable ) { return ; } $ entity -> setEncrypted ( true ) ; $ this -> encryptionService -> decrypt ( $ entity ) ; }
2798	public function toArray ( ) { return [ 'file' => $ this -> getMutationFileRelativePath ( ) , 'mutator' => $ this -> mutation -> getMutator ( ) , 'class' => $ this -> mutation -> getClass ( ) , 'method' => $ this -> mutation -> getMethod ( ) , 'line' => $ this -> mutation -> getLine ( ) , 'diff' => $ this -> getDiff ( ) , 'tests' => $ this -> testMethods ] ; }
7672	function TbsLoadSubFileAsTemplate ( $ SubFileLst ) { if ( ! is_array ( $ SubFileLst ) ) $ SubFileLst = array ( $ SubFileLst ) ; $ ok = true ; $ TBS = false ; foreach ( $ SubFileLst as $ SubFile ) { $ idx = $ this -> FileGetIdx ( $ SubFile ) ; if ( $ idx === false ) { $ ok = $ this -> RaiseError ( 'Cannot load "' . $ SubFile . '". The file is not found in the archive "' . $ this -> ArchFile . '".' ) ; } elseif ( $ idx !== $ this -> TbsCurrIdx ) { $ this -> TbsStorePark ( ) ; if ( ! is_string ( $ SubFile ) ) $ SubFile = $ this -> TbsGetFileName ( $ idx ) ; $ this -> TbsStoreLoad ( $ idx , $ SubFile ) ; if ( $ this -> LastReadNotStored ) { if ( $ TBS === false ) { $ this -> TbsSwitchMode ( true ) ; $ MergeAutoFields = $ this -> TbsMergeAutoFields ( ) ; $ TBS = & $ this -> TBS ; } if ( $ this -> LastReadComp <= 0 ) { if ( $ this -> ExtInfo !== false ) { $ i = $ this -> ExtInfo ; $ e = $ this -> ExtEquiv ; if ( isset ( $ i [ 'rpl_what' ] ) ) { $ TBS -> Source = str_replace ( $ i [ 'rpl_what' ] , $ i [ 'rpl_with' ] , $ TBS -> Source ) ; } if ( ( $ e === 'odt' ) && $ TBS -> OtbsClearWriter ) { $ this -> OpenDoc_CleanRsID ( $ TBS -> Source ) ; } if ( ( $ e === 'ods' ) && $ TBS -> OtbsMsExcelCompatibility ) { $ this -> OpenDoc_MsExcelCompatibility ( $ TBS -> Source ) ; } if ( $ e === 'docx' ) { if ( $ TBS -> OtbsSpacePreserve ) $ this -> MsWord_CleanSpacePreserve ( $ TBS -> Source ) ; if ( $ TBS -> OtbsClearMsWord ) $ this -> MsWord_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'pptx' ) && $ TBS -> OtbsClearMsPowerpoint ) { $ this -> MsPowerpoint_Clean ( $ TBS -> Source ) ; } if ( ( $ e === 'xlsx' ) && $ TBS -> OtbsMsExcelConsistent ) { $ this -> MsExcel_DeleteFormulaResults ( $ TBS -> Source ) ; $ this -> MsExcel_ConvertToRelative ( $ TBS -> Source ) ; } } if ( $ MergeAutoFields ) $ TBS -> LoadTemplate ( null , '+' ) ; } } } } if ( $ TBS !== false ) $ this -> TbsSwitchMode ( false ) ; return $ ok ; }
92	protected static function validateSyntax ( $ json , $ file = null ) { $ parser = new JsonParser ( ) ; $ result = $ parser -> lint ( $ json ) ; if ( null === $ result ) { if ( defined ( 'JSON_ERROR_UTF8' ) && JSON_ERROR_UTF8 === json_last_error ( ) ) { throw new \ UnexpectedValueException ( '"' . $ file . '" is not UTF-8, could not parse as JSON' ) ; } return true ; } throw new ParsingException ( '"' . $ file . '" does not contain valid JSON' . "\n" . $ result -> getMessage ( ) , $ result -> getDetails ( ) ) ; }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
12378	public function database ( Container $ application ) { $ config = $ this -> config ; $ dbName = $ application -> input -> getString ( "dbname" , "" , "post" ) ; $ dbPass = $ application -> input -> getString ( "dbpassword" , "" , "post" ) ; $ dbHost = $ application -> input -> getString ( "dbhost" , "" , "post" ) ; $ dbPref = $ application -> input -> getString ( "dbtableprefix" , "" , "post" ) ; $ dbUser = $ application -> input -> getString ( "dbusername" , "" , "post" ) ; $ dbDriver = $ application -> input -> getString ( "dbdriver" , "MySQLi" , "post" ) ; $ dbPort = $ application -> input -> getInt ( "dbport" , "" , "post" ) ; if ( empty ( $ dbName ) ) { throw new \ Exception ( t ( "Database Name is required to proceed." ) ) ; return false ; } if ( empty ( $ dbDriver ) ) { throw new \ Exception ( t ( "Database Driver Type is required to proceed." ) ) ; return false ; } if ( empty ( $ dbUser ) ) { throw new \ Exception ( t ( "Database username is required to proceed" ) ) ; return false ; } if ( empty ( $ dbHost ) ) { throw new \ Exception ( t ( "Please provide a link to your database host. If using SQLite, provide a path to the SQLite database as host" ) ) ; return false ; } $ config -> set ( "setup.database.host" , $ dbHost ) ; $ config -> set ( "setup.database.prefix" , $ dbPref ) ; $ config -> set ( "setup.database.user" , $ dbUser ) ; $ config -> set ( "setup.database.password" , $ dbPass ) ; $ config -> set ( "setup.database.name" , $ dbName ) ; $ config -> set ( "setup.database.driver" , strtolower ( $ dbDriver ) ) ; $ config -> set ( "setup.database.port" , intval ( $ dbPort ) ) ; try { $ application -> createInstance ( "database" , [ $ application -> config -> get ( "setup.database.driver" ) , $ application -> config -> get ( "setup.database" ) ] ) ; } catch ( Exception $ exception ) { return false ; } $ schema = new Schema ( ) ; if ( ! $ schema -> createTables ( $ application -> database ) ) { echo "wtf" ; return false ; } $ encryptor = $ this -> encryptor ; $ encryptKey = $ encryptor -> generateKey ( time ( ) . getRandomString ( 5 ) ) ; $ config -> set ( "setup.encrypt.key" , $ encryptKey ) ; if ( ! $ config -> saveParams ( ) ) { throw new Exception ( "could not save config" ) ; return false ; } return true ; }
7458	public function background ( ) : Font { if ( $ this -> color !== null ) { $ this -> turnToBackground ( ) ; } $ this -> background = true ; return $ this ; }
2368	public static function extractEmail ( $ strString , $ strAllowedTags = '' ) { $ arrEmails = array ( ) ; if ( strpos ( $ strString , '@' ) === false ) { return $ arrEmails ; } preg_match_all ( '/mailto:(?:[^\x00-\x20\x22\x40\x7F]{1,64}+|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , $ strString , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( 'mailto:' , '' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } unset ( $ strEmail ) ; $ strString = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ strString ) ; preg_match_all ( '/(?:[^\x00-\x20\x22\x40\x7F]{1,64}|\x22[^\x00-\x1F\x7F]{1,64}?\x22)@(?:\[(?:IPv)?[a-f0-9.:]{1,47}\]|[\w.-]{1,252}\.[a-z]{2,63}\b)/u' , strip_tags ( $ strString ) , $ matches ) ; foreach ( $ matches [ 0 ] as & $ strEmail ) { $ strEmail = str_replace ( '&lt;' , '<' , $ strEmail ) ; if ( Validator :: isEmail ( $ strEmail ) ) { $ arrEmails [ ] = $ strEmail ; } } return array_unique ( $ arrEmails ) ; }
77	protected function configure ( ) { $ this -> setDefinition ( array ( new InputArgument ( self :: ARGUMENT_PACKAGE , InputArgument :: REQUIRED , 'Package to inspect' ) , new InputArgument ( self :: ARGUMENT_CONSTRAINT , InputArgument :: OPTIONAL , 'Optional version constraint' , '*' ) , new InputOption ( self :: OPTION_RECURSIVE , 'r' , InputOption :: VALUE_NONE , 'Recursively resolves up to the root package' ) , new InputOption ( self :: OPTION_TREE , 't' , InputOption :: VALUE_NONE , 'Prints the results as a nested tree' ) , ) ) ; }
8497	public function getPackageTrackingDetails ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetPackageTrackingDetails' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetPackageTrackingDetailsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
7814	private function _processRequest ( ) { $ this -> _isAjaxRequest = $ this -> request -> is ( 'ajax' ) ; if ( isset ( $ this -> request -> query [ 'length' ] ) && ! empty ( $ this -> request -> query [ 'length' ] ) ) { $ this -> config ( 'length' , $ this -> request -> query [ 'length' ] ) ; } if ( isset ( $ this -> request -> query [ 'start' ] ) && ! empty ( $ this -> request -> query [ 'start' ] ) ) { $ this -> config ( 'start' , ( int ) $ this -> request -> query [ 'start' ] ) ; } if ( isset ( $ this -> request -> query [ 'order' ] ) && ! empty ( $ this -> request -> query [ 'order' ] ) ) { $ order = $ this -> config ( 'order' ) ; foreach ( $ this -> request -> query [ 'order' ] as $ item ) { $ order [ $ this -> request -> query [ 'columns' ] [ $ item [ 'column' ] ] [ 'name' ] ] = $ item [ 'dir' ] ; } $ this -> config ( 'order' , $ order ) ; } if ( isset ( $ this -> request -> query [ 'draw' ] ) && ! empty ( $ this -> request -> query [ 'draw' ] ) ) { $ this -> _viewVars [ 'draw' ] = ( int ) $ this -> request -> query [ 'draw' ] ; } if ( ! isset ( $ this -> request -> query [ 'columns' ] ) || empty ( $ this -> request -> query [ 'columns' ] ) ) { return ; } $ globalSearch = ( isset ( $ this -> request -> query [ 'search' ] [ 'value' ] ) ? $ this -> request -> query [ 'search' ] [ 'value' ] : false ) ; foreach ( $ this -> request -> query [ 'columns' ] as $ column ) { if ( $ globalSearch && $ column [ 'searchable' ] == 'true' ) { $ this -> _addCondition ( $ column [ 'name' ] , $ globalSearch , 'or' ) ; } $ localSearch = $ column [ 'search' ] [ 'value' ] ; if ( ! empty ( $ localSearch ) && ( $ localSearch !== $ globalSearch ) ) { $ this -> _addCondition ( $ column [ 'name' ] , $ column [ 'search' ] [ 'value' ] ) ; } } }
9117	public function unregisterView ( $ view , $ order , $ applicationName = 'default' ) { if ( isset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ) { unset ( $ this -> views [ $ applicationName ] [ $ order ] [ $ view ] ) ; } return $ this ; }
12627	public function format ( $ format = null ) { if ( null === $ format ) { $ format = $ this -> _format ; } return parent :: format ( $ format ) ; }
7630	public function getContainerMetadata ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; return $ this -> getContainer ( $ containerName ) -> Metadata ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
6648	public function create_tables ( ) { global $ wpdb ; $ charset_collate = $ wpdb -> get_charset_collate ( ) ; $ table_name = $ wpdb -> prefix . 'efg_custom_rating' ; if ( $ wpdb -> get_var ( "SHOW TABLES LIKE '$table_name'" ) != $ table_name ) { $ sql = "CREATE TABLE $table_name ( id mediumint(9) NOT NULL AUTO_INCREMENT, post_id mediumint(9) NOT NULL, ip varchar(45) NOT NULL, vote int(2) NOT NULL, PRIMARY KEY (id) ) $charset_collate;" ; require_once ( ABSPATH . 'wp-admin/includes/upgrade.php' ) ; dbDelta ( $ sql ) ; } }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
2102	protected static function resolveCustomModifiers ( $ strDate ) { if ( strpos ( $ strDate , '::' ) === false ) { return $ strDate ; } System :: loadLanguageFile ( 'default' ) ; if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] = 3 ; } if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] = 3 ; } $ strReturn = '' ; $ chunks = preg_split ( "/([0-9]{1,2}::[1-4])/" , $ strDate , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ chunks as $ chunk ) { list ( $ index , $ flag ) = explode ( '::' , $ chunk ) ; switch ( $ flag ) { case 1 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ index ] ; break ; case 2 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] [ $ index ] ; break ; case 3 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ ( $ index - 1 ) ] ; break ; case 4 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] [ ( $ index - 1 ) ] ; break ; default : $ strReturn .= $ chunk ; break ; } } return $ strReturn ; }
7384	private function generateString ( ) { $ this -> generateNumbers ( ) ; $ this -> adjective = $ this -> adjectives [ $ this -> first ] ; $ this -> animal = $ this -> animals [ $ this -> second ] ; switch ( $ this -> case ) { case 'ucfirst' : $ this -> string = ucfirst ( $ this -> adjective . $ this -> animal . $ this -> number ) ; break ; case 'ucwords' : case 'sentence' : $ this -> string = ucfirst ( $ this -> adjective ) . ucfirst ( $ this -> animal ) . ucfirst ( $ this -> number ) ; break ; case 'camel' : $ this -> string = $ this -> adjective . ucfirst ( $ this -> animal ) . $ this -> number ; break ; default : $ this -> string = $ this -> adjective . $ this -> animal . $ this -> number ; break ; } }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
10019	public function addCellXf ( Style $ style ) { $ this -> cellXfCollection [ ] = $ style ; $ style -> setIndex ( count ( $ this -> cellXfCollection ) - 1 ) ; }
12787	public static function getPut ( ) { $ aPut = array ( ) ; $ rPutResource = fopen ( "php://input" , "r" ) ; while ( $ sData = fread ( $ rPutResource , 1024 ) ) { $ aSeparatePut = explode ( '&' , $ sData ) ; foreach ( $ aSeparatePut as $ sOne ) { $ aOnePut = explode ( '=' , $ sOne ) ; $ aPut [ $ aOnePut [ 0 ] ] = $ aOnePut [ 1 ] ; } } return $ aPut ; }
4499	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ result = [ ] ; foreach ( \ func_get_args ( ) as $ array ) { foreach ( $ array as $ key => $ value ) { if ( \ is_int ( $ key ) ) { $ result [ ] = $ value ; } elseif ( isset ( $ result [ $ key ] ) && \ is_array ( $ result [ $ key ] ) && \ is_array ( $ value ) ) { $ result [ $ key ] = $ this -> arrayMergeDeep ( $ result [ $ key ] , $ value ) ; } else { $ result [ $ key ] = $ value ; } } } return $ result ; }
4541	public function set ( string $ key , $ value ) { $ config = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ config ) { throw new OutOfRangeException ( 'Config "' . $ key . '" does not exist.' ) ; } $ config -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ config ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ config ) ; }
10660	public function withHeaders ( array $ headers ) { $ object = clone $ this ; $ object -> configs [ 'headers' ] = [ ] ; $ object -> inProcessingLoop = true ; $ object -> replaceHeaders ( $ headers ) ; $ object -> inProcessingLoop = true ; return $ object -> buildConfigClient ( ) ; }
10206	public function setReadOrder ( $ pValue ) { if ( $ pValue < 0 || $ pValue > 2 ) { $ pValue = 0 ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'readOrder' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> readOrder = $ pValue ; } return $ this ; }
3007	public function setLayout ( $ layout ) { if ( $ layout === "" || $ layout === null ) { $ this -> layout = null ; } else { $ layoutPath = $ this -> templatePath . $ layout ; if ( ! is_file ( $ layoutPath ) ) { throw new \ RuntimeException ( "Layout template `$layout` does not exist" ) ; } $ this -> layout = $ layoutPath ; } }
9021	public function getWordsByComplexity ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ sortedWords = $ analysis -> getKeyValuesByFrequency ( ) ; $ wordsByFrequency = array_unique ( array_keys ( $ sortedWords ) ) ; usort ( $ wordsByFrequency , function ( $ a , $ b ) { return strlen ( $ b ) - strlen ( $ a ) ; } ) ; return $ wordsByFrequency ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11704	public function getFormInObject ( ) { $ sExKey = null ; if ( $ this -> _iIdEntity > 0 && $ this -> _sSynchronizeEntity !== null && count ( $ _POST ) < 1 ) { $ sModelName = str_replace ( 'Entity' , 'Model' , $ this -> _sSynchronizeEntity ) ; $ oModel = new $ sModelName ; $ oEntity = new $ this -> _sSynchronizeEntity ; $ sPrimaryKey = LibEntity :: getPrimaryKeyNameWithoutMapping ( $ oEntity ) ; $ sMethodName = 'findOneBy' . $ sPrimaryKey ; $ oCompleteEntity = call_user_func_array ( array ( & $ oModel , $ sMethodName ) , array ( $ this -> _iIdEntity ) ) ; if ( is_object ( $ oCompleteEntity ) ) { foreach ( $ this -> _aElement as $ sKey => $ sValue ) { if ( $ sValue instanceof \ Venus \ lib \ Form \ Input && $ sValue -> getType ( ) == 'submit' ) { continue ; } if ( $ sValue instanceof \ Venus \ lib \ Form \ Radio ) { $ sExKey = $ sKey ; $ sKey = substr ( $ sKey , 0 , - 6 ) ; } if ( $ sValue instanceof Form ) { ; } else { $ sMethodNameInEntity = 'get_' . $ sKey ; if ( method_exists ( $ oCompleteEntity , $ sMethodNameInEntity ) ) { $ mValue = $ oCompleteEntity -> $ sMethodNameInEntity ( ) ; } if ( $ sValue instanceof \ Venus \ lib \ Form \ Radio && method_exists ( $ this -> _aElement [ $ sExKey ] , 'setValueChecked' ) ) { $ this -> _aElement [ $ sExKey ] -> setValueChecked ( $ mValue ) ; } else if ( isset ( $ mValue ) && method_exists ( $ this -> _aElement [ $ sKey ] , 'setValue' ) ) { $ this -> _aElement [ $ sKey ] -> setValue ( $ mValue ) ; } } } } } $ oForm = new \ StdClass ( ) ; $ oForm -> start = '<form name="form' . $ this -> _iFormNumber . '" method="post" enctype="multipart/form-data"><input type="hidden" value="1" name="validform' . $ this -> _iFormNumber . '">' ; $ oForm -> form = array ( ) ; foreach ( $ this -> _aElement as $ sKey => $ sValue ) { if ( $ sValue instanceof Container ) { $ oForm -> form [ $ sKey ] = $ sValue ; } else { $ oForm -> form [ $ sKey ] = $ sValue -> fetch ( ) ; } } $ oForm -> end = '</form>' ; return $ oForm ; }
10827	public static function words ( array $ words , $ style = '' , $ separator = ', ' ) { self :: write ( implode ( $ separator , $ words ) , $ style ) ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
8303	public function assertBool ( $ config , $ key ) { if ( array_key_exists ( $ key , $ config ) && ! is_bool ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be a boolean value." ) ; } return $ this ; }
11540	protected function resolveAddOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'page' , 'language' , 'country' , 'slot' , 'blockname' , 'type' , 'position' , 'direction' , ) ) ; $ this -> optionsResolver -> resolve ( $ options ) ; $ this -> optionsResolved = true ; }
1761	protected static function readPhpFileWithoutTags ( $ strName ) { @ trigger_error ( 'Using System::readPhpFileWithoutTags() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\PhpFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new PhpFileLoader ( ) ; return $ loader -> load ( $ strName ) ; }
6523	public function isCompatibleForOverride ( Field $ other ) { if ( ! $ this -> overridable ) { return false ; } if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> required !== $ other -> required ) { return false ; } return true ; }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
11463	public static function exception ( $ Throwable ) { while ( @ ob_end_clean ( ) ) ; try { if ( PHP_SAPI == 'cli' ) { $ message = BaseException :: displayConsoleException ( $ Throwable ) ; if ( @ fwrite ( STDERR , $ message ) === false ) echo $ message ; } else { @ header ( "HTTP/1.1 500 Internal Server Error" ) ; @ header ( 'Content-Type: text/html' ) ; echo BaseException :: displayException ( $ Throwable ) ; } } catch ( \ Throwable $ e ) { $ class = get_class ( $ e ) ; $ message = $ e -> getMessage ( ) ; echo "Uncaught $class inside exception-handler: \"$message\"" ; } exit ( 1 ) ; }
10525	public function setFieldValue ( $ field , $ value ) { $ type = $ this -> getFieldFormType ( $ field ) ; switch ( $ type ) { case 'select' : return $ this -> selectOptionForm ( $ field , $ value ) ; case 'checkbox' : case 'checkboxGroup' : return $ this -> checkOptionForm ( $ field ) ; default : return $ this -> fillFieldForm ( $ field , $ value ) ; } }
3098	public function getStateMessage ( $ testSession ) { if ( $ testSession instanceof AssessmentTestSession ) { switch ( $ testSession -> getState ( ) ) { case AssessmentTestSessionState :: SUSPENDED : return $ this -> getPausedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: CLOSED : return $ this -> getTerminatedStateMessage ( $ testSession ) ; case AssessmentTestSessionState :: INITIAL : return $ this -> getInitialStateMessage ( $ testSession ) ; default : return $ this -> getRunningStateMessages ( $ testSession ) ; } } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerMessageService' , 'getStateMessage' , 0 , 'qtism\runtime\tests\AssessmentTestSession' , $ testSession ) ; } }
8417	public function rollBack ( ) : bool { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( $ this -> transactionLevel > 0 ) { -- $ this -> transactionLevel ; if ( $ this -> transactionLevel == 0 ) { return $ this -> providerDatabase -> rollBack ( $ this -> GetMasterLink ( ) ) ; } return $ this -> providerDatabase -> rollBackSavePoint ( $ this -> GetMasterLink ( ) , 'LEVEL' . $ this -> transactionLevel ) ; } return false ; }
12398	public function select ( $ select = null ) { $ this -> scope -> select = Parser :: select ( $ select ) ; return $ this ; }
1848	protected function getMetaFields ( $ objArticle ) { $ meta = StringUtil :: deserialize ( $ this -> news_metaFields ) ; if ( ! \ is_array ( $ meta ) ) { return array ( ) ; } global $ objPage ; $ return = array ( ) ; foreach ( $ meta as $ field ) { switch ( $ field ) { case 'date' : $ return [ 'date' ] = Date :: parse ( $ objPage -> datimFormat , $ objArticle -> date ) ; break ; case 'author' : if ( ( $ objAuthor = $ objArticle -> getRelated ( 'author' ) ) instanceof UserModel ) { $ return [ 'author' ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'by' ] . ' <span itemprop="author">' . $ objAuthor -> name . '</span>' ; } break ; case 'comments' : if ( $ objArticle -> noComments || $ objArticle -> source != 'default' ) { break ; } $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( ! isset ( $ bundles [ 'ContaoCommentsBundle' ] ) ) { break ; } $ intTotal = CommentsModel :: countPublishedBySourceAndParent ( 'tl_news' , $ objArticle -> id ) ; $ return [ 'ccount' ] = $ intTotal ; $ return [ 'comments' ] = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'commentCount' ] , $ intTotal ) ; break ; } } return $ return ; }
1178	protected function getValidatorInstance ( array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ factory = $ this -> app -> make ( ValidationFactory :: class ) ; $ data = $ this -> getValidationData ( $ rules , $ customAttributes ) ; $ validator = $ factory -> make ( $ data , $ rules , $ messages , $ customAttributes ) ; $ validator -> addCustomAttributes ( $ customAttributes ) ; return $ validator ; }
6188	public function render ( $ data , $ type = null ) { if ( empty ( $ type ) or $ type === 'html' ) { return Response :: Create ( $ this -> renderInclude ( $ data ) ) ; } elseif ( $ type === 'jsonp' ) { return $ this -> renderJSONP ( $ data ) ; } else { return $ this -> renderJSON ( $ data ) ; } }
9063	private function getKeys ( ) : array { $ result = [ ] ; $ rows = $ this -> connection -> query ( " SELECT [INDEX_NAME], [COLUMN_NAME], [INDEX_TYPE], [NON_UNIQUE], [SEQ_IN_INDEX] FROM [information_schema.STATISTICS] WHERE [TABLE_SCHEMA] = %s AND [TABLE_NAME] = %s AND [INDEX_NAME] != %s" , $ this -> database , $ this -> name , 'PRIMARY' ) ; foreach ( $ rows as $ row ) { $ name = $ row -> INDEX_NAME ; if ( isset ( $ result [ $ name ] ) ) { $ obj = $ result [ $ name ] ; } else { $ obj = new Key ; } $ obj -> name = $ name ; $ obj -> addColumn ( $ row -> SEQ_IN_INDEX , $ row -> COLUMN_NAME ) ; $ obj -> type = $ row -> INDEX_TYPE ; $ obj -> unique = ! $ row -> NON_UNIQUE ; $ result [ $ name ] = $ obj ; } return $ result ; }
1644	public function simplify ( Polyline $ polyline ) : Polyline { $ counterPoints = $ polyline -> getNumberOfPoints ( ) ; if ( $ counterPoints < 3 ) { return clone $ polyline ; } $ result = new Polyline ( ) ; $ bearingCalc = new BearingEllipsoidal ( ) ; $ points = $ polyline -> getPoints ( ) ; $ index = 0 ; $ result -> addPoint ( $ points [ $ index ] ) ; do { $ index ++ ; if ( $ index === ( $ counterPoints - 1 ) ) { $ result -> addPoint ( $ points [ $ index ] ) ; break ; } $ bearing1 = $ bearingCalc -> calculateBearing ( $ points [ $ index - 1 ] , $ points [ $ index ] ) ; $ bearing2 = $ bearingCalc -> calculateBearing ( $ points [ $ index ] , $ points [ $ index + 1 ] ) ; $ bearingDifference = min ( fmod ( $ bearing1 - $ bearing2 + 360 , 360 ) , fmod ( $ bearing2 - $ bearing1 + 360 , 360 ) ) ; if ( $ bearingDifference > $ this -> bearingAngle ) { $ result -> addPoint ( $ points [ $ index ] ) ; } } while ( $ index < $ counterPoints ) ; return $ result ; }
11013	protected function importDataFile ( string $ dataFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { $ query = $ this -> db -> createQueryBuilder ( ) ; $ query -> select ( 'count(*) AS count' ) -> from ( $ controlTableName ) ; $ data = $ query -> execute ( ) -> fetchAll ( ) ; $ contentCount = ( int ) $ data [ 0 ] [ 'count' ] ; if ( $ contentCount > 0 ) { $ this -> output -> writeln ( '<comment>Data already exists in the database, skipping data import for file <info>' . $ dataFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ dataFile ) ; }
10344	protected function extractStep ( $ definition ) { if ( ( $ position = strpos ( $ definition , '/' ) ) !== false ) { return ( int ) substr ( $ definition , $ position + 1 ) ; } return false ; }
12770	public function authorize ( RecordInterface & $ user , $ remember = false ) { if ( parent :: authorize ( $ user , $ remember ) ) { if ( $ remember ) { $ token = $ user [ $ this -> dbHashEmailField ] . ( time ( ) + ( $ this -> cookieTime ) ) . $ user [ $ this -> dbHashPasswordField ] ; $ user [ $ this -> dbAccessToken ] = $ token ; $ user -> save ( ) ; $ expiry = time ( ) + ( $ this -> cookieTime ) ; $ cookieData = array ( "token" => $ token , "expiry" => $ expiry ) ; setcookie ( '_cookie_accessToken' , serialize ( $ cookieData ) , $ expiry ) ; } } }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
9951	public function duplicateConditionalStyle ( array $ pCellStyle , $ pRange = '' ) { foreach ( $ pCellStyle as $ cellStyle ) { if ( ! ( $ cellStyle instanceof Conditional ) ) { throw new Exception ( 'Style is not a conditional style' ) ; } } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> setConditionalStyles ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row , $ pCellStyle ) ; } } return $ this ; }
5952	public function setTransition ( $ transition ) { if ( $ transition instanceof SlideTransition ) { $ this -> transition = $ transition ; } elseif ( is_array ( $ transition ) ) { $ this -> transition = new SlideTransition ( $ transition ) ; } else { $ this -> transition = null ; trigger_error ( 'Argument must be an object of class SlideTransition. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
8912	protected function _fetch_primary_key ( ) { if ( $ this -> is_base_model_instance ( ) ) { return ; } if ( $ this -> primary_key == NULL && $ this -> _database ) { $ this -> primary_key = $ this -> execute_query ( "SHOW KEYS FROM `" . $ this -> _database -> dbprefix ( $ this -> _table ) . "` WHERE Key_name = 'PRIMARY'" ) -> row ( ) -> Column_name ; } }
1648	public function calculateFinalBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ initialBearing = $ this -> calculateBearing ( $ point2 , $ point1 ) ; return fmod ( $ initialBearing + 180 , 360 ) ; }
485	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
12390	public function setEntityPrototype ( $ entityPrototype ) { if ( ! is_object ( $ entityPrototype ) ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object, %s provided instead' , __METHOD__ , is_object ( $ entityPrototype ) ? get_class ( $ entityPrototype ) : gettype ( $ entityPrototype ) ) ) ; } $ this -> entityPrototype = $ entityPrototype ; return $ this ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
11492	public function remove ( string $ key ) { if ( $ this -> contains ( $ key ) ) { $ res = $ _SESSION [ $ key ] ; unset ( $ _SESSION [ $ key ] ) ; return $ res ; } else { return null ; } }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
3387	public function sendResetLinkEmail ( Request $ request ) { $ this -> validateEmail ( $ request ) ; $ user = $ this -> broker ( ) -> getUser ( $ request -> only ( 'email' ) ) ; if ( $ user && is_null ( $ user -> confirmed_at ) ) { session ( [ 'confirmation_user_id' => $ user -> getKey ( ) ] ) ; throw ValidationException :: withMessages ( [ 'confirmation' => [ __ ( 'confirmation::confirmation.not_confirmed_reset_password' , [ 'resend_link' => route ( 'auth.resend_confirmation' ) ] ) ] ] ) ; } $ response = $ this -> broker ( ) -> sendResetLink ( $ request -> only ( 'email' ) ) ; return $ response == Password :: RESET_LINK_SENT ? $ this -> sendResetLinkResponse ( $ response ) : $ this -> sendResetLinkFailedResponse ( $ request , $ response ) ; }
12568	public function preview ( $ msgType , $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { $ message = ( new MessageBuilder ( ) ) -> msgType ( $ msgType ) -> message ( $ message ) -> to ( $ to ) -> buildPreview ( $ by ) ; return $ this -> post ( self :: API_PREVIEW , $ message ) ; }
75	public function seek ( $ offset ) { $ this -> rewind ( ) ; for ( $ i = 0 ; $ i < $ offset ; $ i ++ , $ this -> next ( ) ) ; }
9323	protected function registerMarkdownParser ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.docparser' , function ( $ app ) { $ environment = $ app [ 'commonmark.environment' ] ; return new DocParser ( $ environment ) ; } ) ; $ app -> alias ( 'commonmark.docparser' , DocParser :: class ) ; }
3961	private function variantCssClass ( ) { if ( $ this -> isVariant ( ) ) { return 'variant' ; } if ( $ this -> isVariantBase ( ) ) { $ result = 'varbase' ; if ( 0 !== $ this -> getVariants ( null ) -> getCount ( ) ) { $ result .= ' varbase-with-variants' ; } return $ result ; } return '' ; }
12624	public function useHeaders ( $ name ) { $ headers = $ this -> httpHeaders -> getHeaders ( $ name ) ; $ this -> mergeOptions ( array ( 'headers' => $ headers ) ) ; }
7262	protected function assertAdjustmentMode ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ mode = $ adjustment -> getMode ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment mode '$mode'." ) ; } }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
10626	public static function docroot ( ) { if ( ! empty ( $ _SERVER [ 'DOCUMENT_ROOT' ] ) ) { $ docroot = str_replace ( '\\' , '/' , $ _SERVER [ 'DOCUMENT_ROOT' ] ) ; } else { $ docroot = str_replace ( '\\' , '/' , dirname ( __FILE__ ) ) ; } return $ docroot ; }
4311	public function output ( $ options = array ( ) ) { $ cfgRestore = $ this -> config -> setCfg ( $ options ) ; if ( ! $ this -> cfg [ 'output' ] ) { $ this -> config -> setCfg ( $ cfgRestore ) ; return null ; } $ outputAs = $ this -> output -> getCfg ( 'outputAs' ) ; if ( \ is_string ( $ outputAs ) ) { $ this -> output -> setCfg ( 'outputAs' , $ outputAs ) ; } $ channels = $ this -> getChannels ( true ) ; $ channels [ ] = $ this ; $ headers = array ( ) ; foreach ( $ channels as $ channel ) { $ event = $ channel -> eventManager -> publish ( 'debug.output' , $ channel , array ( 'headers' => array ( ) , 'return' => '' , 'isTarget' => $ channel === $ this , ) ) ; $ headers = \ array_merge ( $ headers , $ event [ 'headers' ] ) ; } if ( ! $ this -> getCfg ( 'outputHeaders' ) || ! $ headers ) { $ this -> data [ 'headers' ] = \ array_merge ( $ this -> data [ 'headers' ] , $ event [ 'headers' ] ) ; } elseif ( \ headers_sent ( $ file , $ line ) ) { \ trigger_error ( 'PHPDebugConsole: headers already sent: ' . $ file . ', line ' . $ line , E_USER_NOTICE ) ; } else { foreach ( $ headers as $ nameVal ) { \ header ( $ nameVal [ 0 ] . ': ' . $ nameVal [ 1 ] ) ; } } if ( ! $ this -> parentInstance ) { $ this -> data [ 'outputSent' ] = true ; } $ this -> config -> setCfg ( $ cfgRestore ) ; return $ event [ 'return' ] ; }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
2791	public function hasOks ( $ output ) { $ result = preg_match_all ( "%##teamcity\[testFinished%" , $ output ) ; if ( $ result ) { $ this -> okCount += $ result ; return $ this -> okCount ; } return false ; }
10109	private function writeMergedCells ( ) { $ mergeCells = $ this -> phpSheet -> getMergeCells ( ) ; $ countMergeCells = count ( $ mergeCells ) ; if ( $ countMergeCells == 0 ) { return ; } $ maxCountMergeCellsPerRecord = 1027 ; $ record = 0x00E5 ; $ i = 0 ; $ j = 0 ; $ recordData = '' ; foreach ( $ mergeCells as $ mergeCell ) { ++ $ i ; ++ $ j ; $ range = Coordinate :: splitRange ( $ mergeCell ) ; list ( $ first , $ last ) = $ range [ 0 ] ; list ( $ firstColumn , $ firstRow ) = Coordinate :: coordinateFromString ( $ first ) ; list ( $ lastColumn , $ lastRow ) = Coordinate :: coordinateFromString ( $ last ) ; $ recordData .= pack ( 'vvvv' , $ firstRow - 1 , $ lastRow - 1 , Coordinate :: columnIndexFromString ( $ firstColumn ) - 1 , Coordinate :: columnIndexFromString ( $ lastColumn ) - 1 ) ; if ( $ j == $ maxCountMergeCellsPerRecord or $ i == $ countMergeCells ) { $ recordData = pack ( 'v' , $ j ) . $ recordData ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; $ recordData = '' ; $ j = 0 ; } } }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
5948	protected function waitForReadyRead ( $ time = 0 ) { if ( ! $ this -> isConnected ( ) || $ this -> config [ "blocking" ] ) { return ; } do { $ read = array ( $ this -> stream ) ; $ null = null ; if ( $ time ) { Signal :: getInstance ( ) -> emit ( strtolower ( $ this -> getAdapterType ( ) ) . "WaitTimeout" , $ time , $ this -> getAdapter ( ) ) ; } $ time = $ time + $ this -> config [ "timeout" ] ; } while ( @ stream_select ( $ read , $ null , $ null , $ this -> config [ "timeout" ] ) == 0 ) ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
9712	private function writeSupbookInternal ( ) { $ record = 0x01AE ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> spreadsheet -> getSheetCount ( ) , 0x0401 ) ; return $ this -> writeData ( $ header . $ data ) ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
5444	protected function reduce ( $ raw ) { if ( $ action = $ this -> regexes [ $ this -> mode -> getCurrent ( ) ] -> match ( $ raw , $ match ) ) { $ unparsed_character_count = strpos ( $ raw , $ match ) ; $ unparsed = substr ( $ raw , 0 , $ unparsed_character_count ) ; $ raw = substr ( $ raw , $ unparsed_character_count + strlen ( $ match ) ) ; return array ( $ raw , $ unparsed , $ match , $ action ) ; } return true ; }
12769	public function getDb ( ) { if ( is_null ( $ this -> _db ) ) { if ( ! isset ( $ this -> dbConfig [ 'class' ] ) ) { $ this -> dbConfig [ 'class' ] = 'cascade\components\dataInterface\connectors\db\Connection' ; } $ this -> _db = Yii :: createObject ( $ this -> dbConfig ) ; $ this -> _db -> open ( ) ; } if ( empty ( $ this -> _db ) || ! $ this -> _db -> isActive ) { throw new Exception ( "Unable to connect to foreign database." ) ; } return $ this -> _db ; }
7613	public function sendEmail ( ) { $ user = User :: findOne ( [ 'status' => User :: STATUS_ACTIVE , 'email' => $ this -> email , ] ) ; if ( $ user ) { $ user -> generatePasswordResetToken ( ) ; if ( $ user -> save ( ) ) { return \ Yii :: $ app -> mailer -> compose ( '@auth/views/mail/passwordResetToken' , [ 'user' => $ user ] ) -> setFrom ( [ \ Yii :: $ app -> getModule ( 'auth' ) -> supportEmail => \ Yii :: $ app -> name ] ) -> setTo ( $ this -> email ) -> setSubject ( Yii :: t ( 'auth.reset-password' , 'Password reset for {name}' , [ 'name' => \ Yii :: $ app -> name ] ) ) -> send ( ) ; } } return false ; }
5614	public function paintMethodEnd ( $ message ) { parent :: paintCaseEnd ( $ message ) ; $ node = $ this -> _stack -> pop ( ) ; $ current = $ this -> _stack -> peek ( ) ; if ( $ node -> isFailed ( ) ) { $ current -> fail ( ) ; } $ current -> putChild ( $ node ) ; }
8840	public function setExitCode ( $ exitCode ) { \ Assert \ that ( $ exitCode ) -> integer ( ) -> min ( 0 ) ; $ this -> exitCode = $ exitCode ; return $ this ; }
10569	protected function getOrder ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter , array $ default = [ ] ) : array { $ order = [ ] ; $ params = $ request -> getQueryParams ( ) ; if ( isset ( $ params [ $ sortParameter ] ) ) { if ( isset ( $ params [ self :: ORDER ] ) ) { $ order [ $ params [ $ sortParameter ] ] = strcasecmp ( self :: DESC , $ params [ self :: ORDER ] ) !== 0 ; } else { $ param = $ params [ $ sortParameter ] ; foreach ( ( is_array ( $ param ) ? $ param : [ $ param ] ) as $ s ) { $ this -> parseSort ( $ s , $ order ) ; } } } else { foreach ( preg_grep ( self :: REGEX_DOJO_SORT , array_keys ( $ params ) ) as $ s ) { $ this -> parseSort ( substr ( $ s , 5 , - 1 ) , $ order ) ; } } return empty ( $ order ) ? $ default : $ order ; }
4056	private function convertLegend ( array $ property , bool $ trans , $ condition , array & $ legend , array & $ result ) { if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } $ legend = [ 'label' => $ trans ? unserialize ( $ property [ 'legendtitle' ] , [ 'allowed_classes' => false ] ) : [ '' => $ property [ 'legendtitle' ] ] , 'hide' => ( bool ) $ property [ 'legendhide' ] , 'properties' => [ ] , 'condition' => $ condition ( $ property ) ] ; }
6954	private function getGridForCountry ( CountryInterface $ country ) { if ( isset ( $ this -> grids [ $ country -> getId ( ) ] ) ) { return $ this -> grids [ $ country -> getId ( ) ] ; } $ grid = [ ] ; $ prices = $ this -> priceRepository -> findByCountry ( $ country ) ; foreach ( $ prices as $ price ) { $ method = $ price -> getMethod ( ) ; if ( ! isset ( $ grid [ $ method -> getId ( ) ] ) ) { $ gateway = $ this -> gatewayRegistry -> getGateway ( $ method -> getGatewayName ( ) ) ; $ grid [ $ method -> getId ( ) ] = [ 'method' => $ method , 'max_weight' => $ gateway -> getMaxWeight ( ) , 'prices' => [ ] , ] ; } $ grid [ $ method -> getId ( ) ] [ 'prices' ] [ ] = [ 'weight' => $ price -> getWeight ( ) , 'price' => $ price -> getNetPrice ( ) , ] ; } foreach ( $ grid as & $ method ) { usort ( $ method [ 'prices' ] , function ( $ a , $ b ) { if ( 0 === bccomp ( $ a [ 'weight' ] , $ b [ 'weight' ] , 3 ) ) { return 0 ; } return $ a [ 'weight' ] > $ b [ 'weight' ] ? 1 : - 1 ; } ) ; $ max = end ( $ method [ 'prices' ] ) [ 'weight' ] ; if ( 0 == $ method [ 'max_weight' ] || $ method [ 'max_weight' ] > $ max ) { $ method [ 'max_weight' ] = $ max ; } unset ( $ method ) ; } return $ this -> grids [ $ country -> getId ( ) ] = $ grid ; }
9090	function isMultipart ( ) { foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getType ( ) == 'file' || $ field -> getValueType ( ) == 'file' || $ field -> getDataType ( ) ) { return true ; } } return false ; }
8723	public function translateOrNew ( $ locale ) { if ( is_null ( $ instance = $ this -> translate ( $ locale ) ) ) { return $ this -> newModelInstance ( ) ; } return $ instance ; }
3683	private function getFilterUrlBuilder ( ) : FilterUrlBuilder { if ( null === $ this -> filterUrlBuilder ) { return $ this -> filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; } return $ this -> filterUrlBuilder ; }
11287	protected function _getCustomValue ( $ attributeName , $ query , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = $ this -> _getRelation ( $ attributeName , $ query , $ loadMap ) ; if ( ! $ result ) { $ result = $ query -> fetch ( ) ; } return $ result ; }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
7803	protected function statementBody ( $ text ) { $ accountNumber = $ this -> accountNumber ( $ text ) ; $ account = $ this -> reader -> createAccount ( $ accountNumber ) ; if ( ! ( $ account instanceof AccountInterface ) ) { return null ; } $ account -> setNumber ( $ accountNumber ) ; $ number = $ this -> statementNumber ( $ text ) ; $ statement = $ this -> reader -> createStatement ( $ account , $ number ) ; if ( ! ( $ statement instanceof StatementInterface ) ) { return null ; } $ statement -> setAccount ( $ account ) -> setNumber ( $ this -> statementNumber ( $ text ) ) -> setOpeningBalance ( $ this -> openingBalance ( $ text ) ) -> setClosingBalance ( $ this -> closingBalance ( $ text ) ) ; foreach ( $ this -> splitTransactions ( $ text ) as $ chunk ) { $ statement -> addTransaction ( $ this -> transaction ( $ chunk ) ) ; } return $ statement ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
12977	protected function getComponentDefaults ( $ mappingName , array $ mappingConfig ) { if ( strpos ( $ mappingName , '::' ) ) { list ( $ componentName , $ componentType ) = explode ( '::' , $ mappingName ) ; } else { $ componentName = $ mappingName ; $ componentType = $ this -> detectComponentType ( $ componentName ) ; if ( $ componentType === false and $ componentName === 'app' ) { $ componentType = 'app' ; } } if ( ( $ componentPath = $ this -> getComponentPath ( $ componentName , $ componentType ) ) === false ) { return false ; } $ configPath = $ mappingConfig [ 'dir' ] ; if ( $ configPath === false ) { $ configPath = $ this -> getConfigPath ( ) ; } if ( $ mappingConfig [ 'type' ] === false ) { $ mappingConfig [ 'type' ] = $ this -> detectMetadataDriver ( $ componentPath , $ configPath ) ; } if ( $ mappingConfig [ 'type' ] === false ) { return false ; } if ( $ mappingConfig [ 'dir' ] === false ) { if ( in_array ( $ mappingConfig [ 'type' ] , array ( 'annotation' , 'staticphp' ) ) ) { $ mappingConfig [ 'dir' ] = $ this -> getClassPath ( ) . $ this -> getObjectName ( ) ; } else { $ mappingConfig [ 'dir' ] = $ configPath ; } } if ( is_array ( $ mappingConfig [ 'dir' ] ) ) { foreach ( $ mappingConfig [ 'dir' ] as & $ path ) { $ path = $ componentPath . $ path ; } } else { $ mappingConfig [ 'dir' ] = $ componentPath . $ mappingConfig [ 'dir' ] ; } if ( $ mappingConfig [ 'prefix' ] === false ) { $ mappingConfig [ 'prefix' ] = $ this -> detectComponentNamespace ( $ componentName , $ componentType ) ; } $ mappingConfig [ 'is_component' ] = false ; return $ mappingConfig ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
1698	private function loadFrontendUser ( string $ username , BackendUser $ backendUser ) : ? FrontendUser { try { $ frontendUser = $ this -> userProvider -> loadUserByUsername ( $ username ) ; if ( ! $ frontendUser instanceof FrontendUser ) { throw new UsernameNotFoundException ( 'User is not a front end user' ) ; } } catch ( UsernameNotFoundException $ e ) { if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'Could not find a front end user with the username "%s"' , $ username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , '' ) ] ) ; } return null ; } $ allowedGroups = StringUtil :: deserialize ( $ backendUser -> amg , true ) ; $ frontendGroups = StringUtil :: deserialize ( $ frontendUser -> groups , true ) ; if ( ! $ backendUser -> isAdmin && ! \ count ( array_intersect ( $ frontendGroups , $ allowedGroups ) ) ) { return null ; } return $ frontendUser ; }
2650	public function validateServiceVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/validate' ; $ result = $ this -> _fetch ( $ url , 'GET' ) ; if ( $ result -> status == 'error' ) { throw new LocalizedException ( __ ( 'Failed to validate service version: ' . $ result -> msg ) ) ; } }
8709	protected function qualifyColumns ( $ columns ) { foreach ( $ columns as & $ column ) { if ( ! in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { continue ; } $ primary = $ this -> qualifyTranslationColumn ( $ column ) ; $ fallback = $ this -> qualifyTranslationColumn ( $ column , true ) ; if ( $ this -> model -> shouldFallback ( ) ) { $ column = new Expression ( $ this -> compileIfNull ( $ primary , $ fallback , $ column ) ) ; } else { $ column = $ primary ; } } return $ columns ; }
3463	public function handle ( ServerRequestInterface $ request ) : ResponseInterface { $ response = $ this -> getMiddlewarePipe ( ) -> handle ( $ request ) ; return $ response ; }
12220	public function exceptionHandler ( $ exception ) { $ request = ( isset ( $ this -> container [ 'latestRequest' ] ) ? $ this -> container [ 'latestRequest' ] : $ this -> container [ 'request' ] ) ; $ response = ( isset ( $ this -> container [ 'latestResponse' ] ) ? $ this -> container [ 'latestResponse' ] : $ this -> container [ 'response' ] ) ; if ( ! ( $ exception instanceof Exception ) ) { $ exception = new InternalServerError ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception -> getPrevious ( ) ) ; } $ this -> logException ( $ exception ) ; $ response = $ response -> withBody ( new Stream ( 'php://memory' , 'w+' ) ) ; $ response = $ response -> withStatus ( $ exception -> getStatusCode ( ) ) ; $ body = $ this -> prepareErrorBody ( $ exception ) ; $ response = $ response -> withUnserializedBody ( $ body ) ; $ this -> container [ 'pipeline' ] -> prepareErrorQueue ( ) ; $ this -> container [ 'pipeline' ] ( $ request , $ response ) ; }
9407	protected function callback ( $ middleware , ResponseInterface $ response ) { $ middleware = is_string ( $ middleware ) ? new $ middleware : $ middleware ; $ callback = function ( $ request , $ next = null ) use ( $ middleware ) { return $ middleware ( $ request , $ next ) ; } ; if ( $ this -> approach ( $ middleware ) == self :: SINGLE_PASS ) { $ callback = function ( $ request , $ next = null ) use ( $ middleware , $ response ) { return $ middleware ( $ request , $ response , $ next ) ; } ; } return $ callback ; }
7885	public function getData ( $ date , $ level = null ) { if ( ! is_string ( $ level ) ) { $ level = 'all' ; } $ data = LogViewer :: data ( $ date , $ level ) ; $ paginator = new Paginator ( $ data , $ this -> perPage ) ; $ path = ( new \ ReflectionClass ( $ paginator ) ) -> getProperty ( 'path' ) ; $ path -> setAccessible ( true ) ; $ path -> setValue ( $ paginator , URL :: route ( 'logviewer.index' ) . '/' . $ date . '/' . $ level ) ; if ( count ( $ data ) > $ paginator -> perPage ( ) ) { $ log = array_slice ( $ data , $ paginator -> firstItem ( ) - 1 , $ paginator -> perPage ( ) ) ; } else { $ log = $ data ; } return View :: make ( 'logviewer::data' , compact ( 'paginator' , 'log' ) ) ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
10157	private function readBoolErr ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; $ boolErr = ord ( $ recordData [ 6 ] ) ; $ isError = ord ( $ recordData [ 7 ] ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; switch ( $ isError ) { case 0 : $ value = ( bool ) $ boolErr ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_BOOL ) ; break ; case 1 : $ value = Xls \ ErrorCode :: lookup ( $ boolErr ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_ERROR ) ; break ; } if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } }
6484	private static function filterQueryString ( ? string $ queryString ) : ? string { if ( $ queryString === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~!\$&\'\(\)\*\+,;=%:@\/\?]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ queryString ) ; }
12513	public static function copy ( $ src , $ dest , $ force = false , $ delete = false ) { $ src = Path :: clean ( $ src ) ; $ dest = Path :: clean ( $ dest ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mirror ( $ src , $ dest , null , [ 'override' => $ force , 'delete' => $ delete , 'copy_on_windows' => true ] ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'CANNOT_FIND_SOURCE' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
5897	public function listVideoTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new VideoTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12579	public function previewImageByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_IMAGE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
4556	public function setOrganizationUuid ( ? string $ organizationUuid ) { $ this -> organizationUuid = $ organizationUuid ; $ this -> _organizationUuid = true ; return $ this ; }
6355	public function setTimestamp ( $ ts = false ) { $ m = [ ] ; $ da = [ ] ; $ strtime = '' ; if ( ! $ ts || $ ts === "\0\0\0\0\0\0\0\0\0\0\0\0\0\0" ) { $ uts = self :: time ( ) ; $ strtime = "@$uts" ; } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4}):(\d\d):(\d\d) (\d\d):(\d\d):(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)$/D' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(-?\d{1,13})$/D' , $ ts , $ m ) ) { $ strtime = "@{$m[1]}" ; } elseif ( preg_match ( '/^(-?\d{1,13})(\.\d+)$/D' , $ ts , $ m ) ) { $ strtime = 'unixmicro' ; } elseif ( preg_match ( '/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}.\d{6}$/' , $ ts ) ) { $ strtime = preg_replace ( '/(\d\d)\.(\d\d)\.(\d\d)(\.(\d+))?/' , "$1:$2:$3" , str_replace ( '+00:00' , 'UTC' , $ ts ) ) ; } elseif ( preg_match ( '/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})(?:\.*\d*)?Z?$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d*[\+\- ](\d\d)$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^(\d{4})\-(\d\d)\-(\d\d) (\d\d):(\d\d):(\d\d)\.*\d* GMT$/' , $ ts , $ da ) ) { } elseif ( preg_match ( '/^[ \t\r\n]*([A-Z][a-z]{2},[ \t\r\n]*)?' . '\d\d?[ \t\r\n]*[A-Z][a-z]{2}[ \t\r\n]*\d{2}(?:\d{2})?' . '[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d[ \t\r\n]*:[ \t\r\n]*\d\d/S' , $ ts ) ) { $ strtime = strtok ( $ ts , ';' ) ; } elseif ( preg_match ( '/^[A-Z][a-z]{5,8}, \d\d-[A-Z][a-z]{2}-\d{2} \d\d:\d\d:\d\d/' , $ ts ) ) { $ strtime = $ ts ; } elseif ( preg_match ( '/^[A-Z][a-z]{2} [A-Z][a-z]{2} +\d{1,2} \d\d:\d\d:\d\d \d{4}/' , $ ts ) ) { $ strtime = $ ts ; } else { throw new TimestampException ( __METHOD__ . ": Invalid timestamp - $ts" ) ; } if ( ! $ strtime ) { $ da = array_map ( 'intval' , $ da ) ; $ da [ 0 ] = "%04d-%02d-%02dT%02d:%02d:%02d.00+00:00" ; $ strtime = call_user_func_array ( "sprintf" , $ da ) ; } try { if ( $ strtime === 'unixmicro' ) { $ final = DateTime :: createFromFormat ( 'U.u' , $ ts , new DateTimeZone ( 'GMT' ) ) ; } else { $ final = new DateTime ( $ strtime , new DateTimeZone ( 'GMT' ) ) ; } } catch ( Exception $ e ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' , $ e -> getCode ( ) , $ e ) ; } if ( $ final === false ) { throw new TimestampException ( __METHOD__ . ': Invalid timestamp format.' ) ; } $ this -> timestamp = $ final ; }
5913	public function addUserToGroup ( $ id , array $ groupIds ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'groupIds' => $ groupIds ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/groups' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
5146	public function accessInboxFor ( $ address ) { $ inbox = array ( ) ; $ addressPlusDelimiters = '<' . $ address . '>' ; foreach ( $ this -> fetchedEmails as & $ email ) { $ email -> Headers = $ this -> getHeaders ( $ email -> id ) -> headers ; if ( ! isset ( $ email -> Headers -> bcc ) ) { if ( strpos ( $ email -> Headers -> to , $ addressPlusDelimiters ) || strpos ( $ email -> Headers -> cc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } else if ( strpos ( $ email -> Headers -> bcc , $ addressPlusDelimiters ) ) { array_push ( $ inbox , $ email ) ; } } $ this -> setCurrentInbox ( $ inbox ) ; }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
4783	public function getModule ( ) { if ( ! is_object ( $ this -> _module ) ) { $ this -> _module = Yii :: $ app -> getModule ( $ this -> _module ) ; } return $ this -> _module ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
2073	public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; }
7976	public function addSecondaryDnsDomains ( $ domain2add , $ ip ) { self :: getClient ( ) -> addSecondaryDnsDomains ( $ this -> getDomain ( ) , $ domain2add , $ ip ) ; return true ; }
1531	public static function create ( ValidatorInterface $ validator ) : self { $ ex = new self ( $ validator -> getErrors ( ) ) ; $ ex -> validator = $ validator ; return $ ex ; }
12467	public function renderFormAction ( $ id , Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ entity = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> find ( $ id ) ; if ( ! $ entity ) { throw $ this -> createNotFoundException ( 'Unable to find CustomFieldsGroups entity.' ) ; } $ form = $ this -> createForm ( 'custom_field' , null , array ( 'group' => $ entity ) ) ; $ form -> add ( 'submit_dump' , 'submit' , array ( 'label' => 'POST AND DUMP' ) ) ; $ form -> add ( 'submit_render' , 'submit' , array ( 'label' => 'POST AND RENDER' ) ) ; $ form -> handleRequest ( $ request ) ; $ this -> get ( 'twig.loader' ) -> addPath ( __DIR__ . '/../Tests/Fixtures/App/app/Resources/views/' , $ namespace = 'test' ) ; if ( $ form -> isSubmitted ( ) ) { if ( $ form -> get ( 'submit_render' ) -> isClicked ( ) ) { return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:render_for_test.html.twig' , array ( 'fields' => $ form -> getData ( ) , 'customFieldsGroup' => $ entity ) ) ; } var_dump ( $ form -> getData ( ) ) ; var_dump ( json_enccode ( $ form -> getData ( ) ) ) ; } return $ this -> render ( '@test/CustomField/simple_form_render.html.twig' , array ( 'form' => $ form -> createView ( ) ) ) ; }
4269	public function dir_readdir ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ readdir ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
12145	public function set ( $ name , $ value = null ) { if ( $ value == null ) { return false ; } $ this -> settings [ $ name ] = $ value ; }
2722	public function aroundSendPurgeRequest ( PurgeCache $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> isFastlyEnabled ( ) !== true ) { $ proceed ( ... $ args ) ; } }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
8954	public function createWay ( $ changeset , $ tags , $ nds ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'way/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ ndList = '' ; if ( ! empty ( $ nds ) ) { foreach ( $ nds as $ value ) { $ ndList .= '<nd ref="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <way changeset="' . $ changeset . '">' . $ tagList . $ ndList . '</way> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
5722	public function save ( $ data , $ form ) { $ origStage = Versioned :: get_stage ( ) ; Versioned :: set_stage ( 'Stage' ) ; $ action = $ this -> owner -> doSave ( $ data , $ form ) ; Versioned :: set_stage ( $ origStage ) ; return $ action ; }
3311	protected function getTokenFormApi ( ) { $ http = $ this -> getHttp ( ) ; $ token = $ http -> parseJson ( $ http -> post ( self :: API_TOKEN_URI , [ 'grant_type' => 'client_credentials' , 'client_id' => $ this -> getAppKey ( ) , 'client_secret' => $ this -> getSecretKey ( ) ] ) ) ; if ( empty ( $ token [ $ this -> tokenSucessKey ] ) ) { throw new RuntimeException ( 'Request AccessToken fail. response: ' . json_encode ( $ token , JSON_UNESCAPED_UNICODE ) ) ; } return $ token ; }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
8214	protected function getTubeStats ( $ tube ) { try { $ stats = $ this -> getPheanstalk ( ) -> statsTube ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { throw new \ RuntimeException ( "Tube '$tube' doesn't exist." ) ; } throw $ e ; } return $ stats ; }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
2002	public static function getVersion ( string $ packageName ) : string { $ version = Versions :: getVersion ( $ packageName ) ; return static :: parseVersion ( $ version ) ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
4230	public static function getParsed ( $ what ) { $ hash = null ; if ( \ is_object ( $ what ) ) { $ hash = self :: getHash ( $ what ) ; if ( isset ( self :: $ cache [ $ hash ] ) ) { return self :: $ cache [ $ hash ] ; } } $ comment = self :: getCommentContent ( $ what ) ; if ( \ is_array ( $ comment ) ) { return $ comment ; } $ return = array ( 'summary' => null , 'description' => null , ) ; if ( \ preg_match ( '/^@/m' , $ comment , $ matches , PREG_OFFSET_CAPTURE ) ) { $ pos = $ matches [ 0 ] [ 1 ] ; $ strTags = \ substr ( $ comment , $ pos ) ; $ return = \ array_merge ( $ return , self :: parseTags ( $ strTags ) ) ; $ comment = $ pos > 0 ? \ substr ( $ comment , 0 , $ pos - 1 ) : '' ; } $ comment = \ preg_replace ( '/^\\\@/m' , '@' , $ comment ) ; $ comment = \ str_replace ( '{@*}' , '*/' , $ comment ) ; $ split = \ preg_split ( '/(\.[\r\n]+|[\r\n]{2})/' , $ comment , 2 , PREG_SPLIT_DELIM_CAPTURE ) ; $ split = \ array_replace ( array ( '' , '' , '' ) , $ split ) ; $ return = \ array_merge ( $ return , \ array_filter ( array ( 'summary' => \ trim ( $ split [ 0 ] . $ split [ 1 ] ) , 'desc' => \ trim ( $ split [ 2 ] ) , ) ) ) ; if ( $ hash ) { self :: $ cache [ $ hash ] = $ return ; } return $ return ; }
12980	protected function configureBehavior ( $ behavior , EventSubscriber $ es ) { switch ( $ behavior ) { case 'translatable' : $ es -> setTranslatableLocale ( \ Config :: get ( 'language' , 'en' ) ) ; $ es -> setDefaultLocale ( \ Config :: get ( 'language_fallback' , 'en' ) ) ; break ; } }
715	public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; }
10312	function getRecipientsCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeDeletedRecipients = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeDeletedRecipients ) ) $ params [ 'exclude_deleted_recipients' ] = ( $ excludeDeletedRecipients == true ) ? "true" : "false" ; return $ this -> get ( 'reports/recipients/count' , $ params ) ; }
576	public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; }
6715	protected function getFormatFromUri ( $ requestedUri ) { $ uriParts = explode ( '?' , $ requestedUri , 2 ) ; $ uriWithoutGet = reset ( $ uriParts ) ; $ uriAndFormat = explode ( '.' , $ uriWithoutGet ) ; if ( count ( $ uriAndFormat ) >= 2 ) { return end ( $ uriAndFormat ) ; } return null ; }
5610	public function paintCaseStart ( $ message ) { parent :: paintCaseStart ( $ message ) ; $ node = new TreemapNode ( 'TestCase' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
120	protected function hasAuth ( ) { if ( null !== $ this -> hasAuth ) { return $ this -> hasAuth ; } if ( false === $ this -> createAuthFromConfig ( ) ) { $ this -> createAuthFromUrl ( ) ; } return $ this -> hasAuth ; }
3590	public function allowsMeta ( $ key ) { $ allowed = $ this -> getAllowedMeta ( ) ; return empty ( $ allowed ) || in_array ( $ key , $ allowed ) ; }
114	private function openBrowser ( $ url ) { $ url = ProcessExecutor :: escape ( $ url ) ; $ process = new ProcessExecutor ( $ this -> getIO ( ) ) ; if ( Platform :: isWindows ( ) ) { return $ process -> execute ( 'start "web" explorer "' . $ url . '"' , $ output ) ; } $ linux = $ process -> execute ( 'which xdg-open' , $ output ) ; $ osx = $ process -> execute ( 'which open' , $ output ) ; if ( 0 === $ linux ) { $ process -> execute ( 'xdg-open ' . $ url , $ output ) ; } elseif ( 0 === $ osx ) { $ process -> execute ( 'open ' . $ url , $ output ) ; } else { $ this -> getIO ( ) -> writeError ( 'No suitable browser opening command found, open yourself: ' . $ url ) ; } }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
9826	private function writeRelationship ( XMLWriter $ objWriter , $ pId , $ pType , $ pTarget , $ pTargetMode = '' ) { if ( $ pType != '' && $ pTarget != '' ) { $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId' . $ pId ) ; $ objWriter -> writeAttribute ( 'Type' , $ pType ) ; $ objWriter -> writeAttribute ( 'Target' , $ pTarget ) ; if ( $ pTargetMode != '' ) { $ objWriter -> writeAttribute ( 'TargetMode' , $ pTargetMode ) ; } $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
7726	public function postback ( $ text , $ title , $ postback ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'postback' , 'title' => $ title , 'payload' => $ postback ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
3568	public function replicate ( ) { return function ( $ next , $ copy , $ args ) { $ metaAttributes = $ args -> get ( 'original' ) -> getMetaAttributes ( ) -> replicate ( $ args -> get ( 'except' ) ) ; $ copy -> setRelation ( 'metaAttributes' , $ metaAttributes ) ; return $ next ( $ copy , $ args ) ; } ; }
12403	public function replace ( $ id , $ document = null ) { return Parser :: replace ( $ id , $ document , $ this -> connection ) ; }
3267	protected function openFile ( int $ mode ) : SplFileObject { $ path = $ this -> getPath ( ) ; if ( ! is_file ( $ path ) && ! @ touch ( $ path ) ) { throw new Exception ( 'Could not create file: ' . $ path ) ; } if ( ! is_readable ( $ path ) || ! is_writable ( $ path ) ) { throw new Exception ( 'File does not have permission for read and write: ' . $ path ) ; } if ( $ this -> getConfig ( ) -> useGzip ( ) ) { $ path = 'compress.zlib://' . $ path ; } $ res = $ this -> fileAccessMode [ $ mode ] ; $ file = new SplFileObject ( $ path , $ res [ 'mode' ] ) ; if ( $ mode === self :: FILE_READ ) { $ file -> setFlags ( SplFileObject :: DROP_NEW_LINE | SplFileObject :: SKIP_EMPTY | SplFileObject :: READ_AHEAD ) ; } if ( ! $ this -> getConfig ( ) -> useGzip ( ) && ! $ file -> flock ( $ res [ 'operation' ] ) ) { $ file = null ; throw new Exception ( 'Could not lock file: ' . $ path ) ; } return $ file ; }
11769	public function getConnectionByRole ( $ role ) { if ( $ role === 'master' ) { return $ this -> getMaster ( ) ; } elseif ( $ role === 'slave' ) { return $ this -> pickSlave ( ) ; } elseif ( $ role === 'sentinel' ) { return $ this -> getSentinelConnection ( ) ; } }
11597	public static function setCacheType ( string $ sCacheName ) { if ( $ sCacheName === 'file' ) { self :: $ _sTypeOfCache = 'file' ; } else if ( $ sCacheName === 'memcache' ) { self :: $ _sTypeOfCache = 'memcache' ; } else if ( $ sCacheName === 'apc' ) { self :: $ _sTypeOfCache = 'apc' ; } else if ( $ sCacheName === 'redis' ) { self :: $ _sTypeOfCache = 'redis' ; } else { self :: $ _sTypeOfCache = 'mock' ; } }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10762	public function setAlternativeAccount ( $ iban1 , $ swift1 = null , $ iban2 = null , $ swift2 = null ) { if ( $ swift1 !== null ) { $ iban1 .= '+' . $ swift1 ; } if ( $ iban2 !== null ) { if ( $ swift2 !== null ) { $ iban2 .= '+' . $ swift2 ; } $ iban1 .= ',' . $ iban2 ; } return $ this -> add ( 'ALT-ACC' , $ iban1 ) ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
2618	public function getSiteLocation ( ) { $ countryId = $ this -> scopeConfig -> getValue ( 'general/store_information/country_id' ) ; if ( $ countryId ) { $ country = $ this -> countryFactory -> create ( ) -> loadByCode ( $ countryId ) ; $ countryName = $ country -> getName ( ) ; } else { $ countryName = 'Unknown country' ; } $ regionId = $ this -> scopeConfig -> getValue ( 'general/store_information/region_id' ) ; $ regionName = 'Unknown region' ; if ( $ regionId ) { $ region = $ this -> regionFactory -> create ( ) ; $ region = $ region -> load ( $ regionId ) ; if ( $ region -> getId ( ) ) { $ regionName = $ region -> getName ( ) ; } } $ postCode = $ this -> scopeConfig -> getValue ( 'general/store_information/postcode' ) ; if ( ! $ postCode ) { $ postCode = 'Unknown zip code' ; } return $ countryName . ' | ' . $ regionName . ' | ' . $ postCode ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
2182	public function listImageSizeItem ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'media' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
11882	private function prepareFieldOptions ( CustomField $ customField , $ type ) { $ options = $ customField -> getOptions ( ) ; $ fieldOptions = array ( ) ; $ fieldOptions [ 'required' ] = False ; $ fieldOptions [ 'label' ] = $ this -> translatableStringHelper -> localize ( $ customField -> getName ( ) ) ; if ( $ options [ self :: MIN ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new GreaterThanOrEqual ( array ( 'value' => $ options [ self :: MIN ] ) ) ; } if ( $ options [ self :: MAX ] !== NULL ) { $ fieldOptions [ 'constraints' ] [ ] = new LessThanOrEqual ( array ( 'value' => $ options [ self :: MAX ] ) ) ; } if ( $ type === 'number' ) { $ fieldOptions [ 'scale' ] = $ options [ self :: SCALE ] ; } if ( ! empty ( $ options [ self :: POST_TEXT ] ) ) { $ fieldOptions [ 'post_text' ] = $ options [ self :: POST_TEXT ] ; } return $ fieldOptions ; }
2869	public function renderArray ( array $ data , $ noDataLabel = 'No Data' , $ header = null ) { $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' ) ; $ html = $ block -> renderArray ( $ data , $ noDataLabel , $ header ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ html ) ; }
11400	public function fromData ( $ data ) { $ this -> fromdata = $ data ; $ resource = fopen ( 'php://memory' , 'r+' ) ; fwrite ( $ resource , $ data ) ; rewind ( $ resource ) ; $ this -> setResource ( $ resource ) ; return $ this ; }
7252	protected function validatePaymentTermAndOutstandingLimit ( SaleInterface $ sale , Constraint $ constraint ) { if ( 0 >= $ sale -> getOutstandingLimit ( ) ) { return ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { if ( null !== $ customer = $ sale -> getCustomer ( ) ) { if ( $ customer -> hasParent ( ) ) { $ term = $ customer -> getParent ( ) -> getPaymentTerm ( ) ; } else { $ term = $ customer -> getPaymentTerm ( ) ; } } } if ( null === $ term ) { $ this -> context -> buildViolation ( $ constraint -> outstanding_limit_require_term ) -> atPath ( 'outstandingLimit' ) -> addViolation ( ) ; } }
7902	protected function getFullFileName ( Provider $ provider ) { $ folder = $ this -> folder ? rtrim ( $ this -> folder , '/' ) . '/' : '' ; if ( $ this -> filename ) { $ filename = $ this -> filename ; } else { $ filename = md5 ( uniqid ( microtime ( true ) , true ) ) ; } return $ folder . $ filename . '.' . $ provider -> getExtension ( ) ; }
3647	protected function process ( string $ value , bool $ trim = true , bool $ clean = true ) { if ( $ trim ) { $ value = trim ( $ value ) ; } if ( $ clean ) { $ value = $ this -> security -> clean ( $ value ) ; } return $ value ; }
10202	public function setHorizontal ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: HORIZONTAL_GENERAL ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'horizontal' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> horizontal = $ pValue ; } return $ this ; }
4686	public function addSelect ( string $ expression , ... $ args ) : self { if ( ! is_string ( $ expression ) ) { throw new InvalidArgumentException ( 'Select expression has to be a string.' ) ; } $ this -> dirty ( ) ; $ this -> select [ ] = $ expression ; $ this -> pushArgs ( 'select' , $ args ) ; return $ this ; }
4054	private function fetchGroupSort ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ information ) use ( $ inputScreenId , $ metaModel ) { $ information [ 'isdefault' ] = ( bool ) $ information [ 'isdefault' ] ; $ information [ 'ismanualsort' ] = ( bool ) $ information [ 'ismanualsort' ] ; $ information [ 'rendergrouplen' ] = ( int ) $ information [ 'rendergrouplen' ] ; if ( $ information [ 'ismanualsort' ] ) { $ information [ 'rendergrouptype' ] = 'none' ; } if ( ! empty ( $ information [ 'rendersortattr' ] ) ) { if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ information [ 'rendersortattr' ] ) ) ) { @ trigger_error ( sprintf ( 'Unknown attribute "%1$s" in group sorting "%2$s.%3$s"' , $ information [ 'rendersortattr' ] , $ inputScreenId , $ information [ 'id' ] ) , E_USER_WARNING ) ; return $ information ; } $ information [ 'col_name' ] = $ attribute -> getColName ( ) ; } return $ information ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dca_sortgroup' ) -> where ( 'pid=:screenId' ) -> setParameter ( 'screenId' , $ inputScreenId ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
7647	public function stream_open ( $ path , $ mode , $ options , & $ opened_path ) { $ this -> fileName = $ path ; $ this -> temporaryFileName = tempnam ( sys_get_temp_dir ( ) , 'azure' ) ; $ fh = @ fopen ( $ this -> temporaryFileName , $ mode ) ; if ( $ fh === false ) { return false ; } fclose ( $ fh ) ; if ( strpbrk ( $ mode , 'wax+' ) ) { $ this -> writeMode = true ; } else { $ this -> writeMode = false ; } if ( ! $ this -> writeMode || strpbrk ( $ mode , 'ra+' ) ) { $ this -> getStorageClient ( $ this -> fileName ) -> getBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } $ this -> temporaryFileHandle = fopen ( $ this -> temporaryFileName , $ mode ) ; return true ; }
3103	public function load ( ) { $ storage = $ this -> getStorage ( ) ; if ( $ storage ) { $ data = $ storage -> get ( $ this -> userId , $ this -> getStorageKey ( ) ) ; if ( $ data ) { $ this -> state = json_decode ( $ data , true ) ; } else { $ this -> state = [ ] ; } $ success = is_array ( $ this -> state ) ; } else { $ success = false ; } return $ success ; }
785	protected function generateEtag ( $ seed ) { $ etag = '"' . rtrim ( base64_encode ( sha1 ( $ seed , true ) ) , '=' ) . '"' ; return $ this -> weakEtag ? 'W/' . $ etag : $ etag ; }
9868	private function writePrintOptions ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'printOptions' ) ; $ objWriter -> writeAttribute ( 'gridLines' , ( $ pSheet -> getPrintGridlines ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'gridLinesSet' , 'true' ) ; if ( $ pSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ) { $ objWriter -> writeAttribute ( 'horizontalCentered' , 'true' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getVerticalCentered ( ) ) { $ objWriter -> writeAttribute ( 'verticalCentered' , 'true' ) ; } $ objWriter -> endElement ( ) ; }
4893	protected function array_compare ( $ array1 , $ array2 , $ maxDepth = 2 ) { $ result = array ( ) ; $ arraykeys = array_unique ( array_merge ( array_keys ( $ array1 ) , array_keys ( $ array2 ) ) ) ; foreach ( $ arraykeys as $ key ) { if ( ! empty ( $ key ) && is_string ( $ key ) && $ key [ 0 ] != "\0" && substr ( $ key , 0 , 8 ) != 'Doctrine' ) { if ( array_key_exists ( $ key , $ array1 ) && ! array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , '' ) ; } if ( ! array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ result [ $ key ] = array ( '' , $ array2 [ $ key ] ) ; } if ( array_key_exists ( $ key , $ array1 ) && array_key_exists ( $ key , $ array2 ) ) { $ subResult = null ; if ( is_array ( $ array1 [ $ key ] ) && is_array ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ subResult = $ this -> array_compare ( $ array1 [ $ key ] , $ array2 [ $ key ] , $ maxDepth - 1 ) ; } } elseif ( is_object ( $ array1 [ $ key ] ) && is_object ( $ array2 [ $ key ] ) ) { if ( 0 < $ maxDepth ) { $ hydrator = new EntityHydrator ( ) ; $ a1 = $ hydrator -> extract ( $ array1 [ $ key ] ) ; $ a2 = $ hydrator -> extract ( $ array2 [ $ key ] ) ; $ subResult = $ this -> array_compare ( $ a1 , $ a2 , $ maxDepth - 1 ) ; } } else { if ( $ array1 [ $ key ] != $ array2 [ $ key ] ) { $ result [ $ key ] = array ( $ array1 [ $ key ] , $ array2 [ $ key ] ) ; } } if ( ! empty ( $ subResult ) ) { foreach ( $ subResult as $ subKey => $ subValue ) { if ( ! empty ( $ subKey ) && is_string ( $ subKey ) ) { $ result [ $ key . '.' . $ subKey ] = $ subValue ; } } } } } } return $ result ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
5876	public function getImageFileExtensions ( array $ settings ) { $ languageService = $ this -> getLanguageService ( ) ; $ extensions = GeneralUtility :: trimExplode ( ',' , strtolower ( $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'GFX' ] [ 'imagefile_ext' ] ) , true ) ; if ( $ key = array_search ( 'pdf' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } if ( $ key = array_search ( 'svg' , $ extensions ) ) { unset ( $ extensions [ $ key ] ) ; } asort ( $ extensions ) ; $ elements = [ ] ; foreach ( $ extensions as $ extension ) { $ label = $ languageService -> sL ( 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang.xlf:extension.' . $ extension ) ; $ label = $ label ? $ label : '.' . $ extension ; $ elements [ ] = [ $ label , $ extension ] ; } $ settings [ 'items' ] = array_merge ( $ settings [ 'items' ] , $ elements ) ; }
1884	public static function count ( array $ arrOptions ) { $ strQuery = "SELECT COUNT(*) AS count FROM " . $ arrOptions [ 'table' ] ; if ( $ arrOptions [ 'column' ] !== null ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } return $ strQuery ; }
876	private function isCommentWithFixableIndentation ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isComment ( ) ) { return false ; } if ( 0 === strpos ( $ tokens [ $ index ] -> getContent ( ) , '/*' ) ) { return true ; } $ firstCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ firstCommentIndex , false ) ; if ( null === $ i ) { break ; } $ firstCommentIndex = $ i ; } $ lastCommentIndex = $ index ; while ( true ) { $ i = $ this -> getSiblingContinuousSingleLineComment ( $ tokens , $ lastCommentIndex , true ) ; if ( null === $ i ) { break ; } $ lastCommentIndex = $ i ; } if ( $ firstCommentIndex === $ lastCommentIndex ) { return true ; } for ( $ i = $ firstCommentIndex + 1 ; $ i < $ lastCommentIndex ; ++ $ i ) { if ( ! $ tokens [ $ i ] -> isWhitespace ( ) && ! $ tokens [ $ i ] -> isComment ( ) ) { return false ; } } return true ; }
8798	public function registerDirectives ( BladeCompiler $ blade ) { $ keywords = [ "namespace" , "use" , ] ; foreach ( $ keywords as $ keyword ) { $ blade -> directive ( $ keyword , function ( $ parameter ) use ( $ keyword ) { $ parameter = trim ( $ parameter , "()" ) ; return "<?php {$keyword} {$parameter} ?>" ; } ) ; } $ assetify = function ( $ file , $ type ) { $ file = trim ( $ file , "()" ) ; if ( in_array ( substr ( $ file , 0 , 1 ) , [ "'" , '"' ] , true ) ) { $ file = trim ( $ file , "'\"" ) ; } else { return "{{ {$file} }}" ; } if ( substr ( $ file , 0 , 1 ) !== "/" ) { $ file = "/{$type}/{$file}" ; } if ( substr ( $ file , ( strlen ( $ type ) + 1 ) * - 1 ) !== ".{$type}" ) { $ file .= ".{$type}" ; } return $ file ; } ; $ blade -> directive ( "css" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "css" ) ; return '<link rel="stylesheet" type="text/css" href="' . $ file . '"/>' ; } ) ; $ blade -> directive ( "js" , function ( $ parameter ) use ( $ assetify ) { $ file = $ assetify ( $ parameter , "js" ) ; return '<script type="text/javascript" src="' . $ file . '"></script>' ; } ) ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
9033	protected function mapField ( $ field ) { if ( ! $ this -> classMetadata -> hasField ( $ field ) ) { $ this -> classMetadata -> mapField ( [ 'fieldName' => $ field , 'type' => 'datetime' , 'nullable' => true , ] ) ; } }
9963	public function removeRow ( $ pRow , $ pNumRows = 1 ) { if ( $ pRow >= 1 ) { $ highestRow = $ this -> getHighestDataRow ( ) ; $ objReferenceHelper = ReferenceHelper :: getInstance ( ) ; $ objReferenceHelper -> insertNewBefore ( 'A' . ( $ pRow + $ pNumRows ) , 0 , - $ pNumRows , $ this ) ; for ( $ r = 0 ; $ r < $ pNumRows ; ++ $ r ) { $ this -> getCellCollection ( ) -> removeRow ( $ highestRow ) ; -- $ highestRow ; } } else { throw new Exception ( 'Rows to be deleted should at least start from row 1.' ) ; } return $ this ; }
8947	public function uploadTrace ( $ file , $ description , $ tags , $ public , $ visibility , $ username , $ password ) { $ parameters = array ( 'file' => $ file , 'description' => $ description , 'tags' => $ tags , 'public' => $ public , 'visibility' => $ visibility , ) ; $ base = 'gpx/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'Content-Type' ] = 'multipart/form-data' ; $ header = array_merge ( $ header , $ parameters ) ; $ header = array_merge ( $ header , array ( 'Authorization' => 'Basic ' . base64_encode ( $ username . ':' . $ password ) ) ) ; return $ this -> sendRequest ( $ path , 'POST' , $ header , array ( ) ) ; }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
9138	public static function formatCamelCaseWithAcronyms ( array $ parts ) { $ camelCase = array_map ( function ( $ p ) { return static :: ucfirstAndLowerNonAcronym ( $ p ) ; } , $ parts ) ; if ( static :: isAcronym ( $ camelCase [ 0 ] ) ) { return implode ( '' , $ camelCase ) ; } return lcfirst ( implode ( '' , $ camelCase ) ) ; }
6924	protected function getFindOneBySaleQuery ( ) { if ( null !== $ this -> findOneBySaleQuery ) { return $ this -> findOneBySaleQuery ; } $ qb = $ this -> createQueryBuilder ( 'r' ) ; $ e = $ qb -> expr ( ) ; return $ this -> findOneBySaleQuery = $ qb -> andWhere ( $ e -> orX ( $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':net_mode' ) , $ e -> lte ( 'r.baseTotal' , ':net_base' ) ) , $ e -> andX ( $ e -> eq ( 'r.vatMode' , ':ati_mode' ) , $ e -> lte ( 'r.baseTotal' , ':ati_base' ) ) ) ) -> andWhere ( $ e -> orX ( 'r.methods IS EMPTY' , $ e -> isMemberOf ( ':method' , 'r.methods' ) ) ) -> andWhere ( $ e -> orX ( 'r.countries IS EMPTY' , $ e -> isMemberOf ( ':country' , 'r.countries' ) ) ) -> andWhere ( $ e -> orX ( 'r.customerGroups IS EMPTY' , $ e -> isMemberOf ( ':group' , 'r.customerGroups' ) ) ) -> andWhere ( $ e -> orX ( 'r.startAt IS NULL' , $ e -> lte ( 'r.startAt' , ':date' ) ) ) -> andWhere ( $ e -> orX ( 'r.endAt IS NULL' , $ e -> gte ( 'r.endAt' , ':date' ) ) ) -> getQuery ( ) -> setMaxResults ( 1 ) -> useQueryCache ( true ) ; }
7228	protected function parseHeader ( $ curl , $ header ) { if ( preg_match ( "/^([^:\s]+)\:\s+(.*)$/" , $ header , $ matches ) ) { $ matches [ 2 ] = trim ( $ matches [ 2 ] ) ; $ this -> lastHeader [ $ matches [ 1 ] ] = $ matches [ 2 ] ; $ this -> lastResultType = $ matches [ 1 ] === "Content-Type" ? $ matches [ 2 ] : $ this -> lastResultType ; } return strlen ( $ header ) ; }
2796	public function setAdapterOptionsFromString ( $ optionString ) { $ this -> adapterOptions = array_merge ( $ this -> adapterOptions , explode ( ' ' , $ optionString ) ) ; return $ this ; }
6202	public function methodFail ( $ errors = null ) { if ( $ errors === null ) { return $ this -> methodResult ( false ) ; } if ( ! is_array ( $ errors ) ) { $ errors = [ $ errors ] ; } return $ this -> methodResult ( false , [ 'errors' => $ errors ] ) ; }
249	public function regenerateID ( $ deleteOldSession = false ) { if ( $ this -> getIsActive ( ) ) { if ( YII_DEBUG && ! headers_sent ( ) ) { session_regenerate_id ( $ deleteOldSession ) ; } else { @ session_regenerate_id ( $ deleteOldSession ) ; } } }
9935	public function setOperator ( $ pOperator ) { if ( empty ( $ pOperator ) ) { $ pOperator = self :: AUTOFILTER_COLUMN_RULE_EQUAL ; } if ( ( ! in_array ( $ pOperator , self :: $ operators ) ) && ( ! in_array ( $ pOperator , self :: $ topTenValue ) ) ) { throw new PhpSpreadsheetException ( 'Invalid operator for column AutoFilter Rule.' ) ; } $ this -> operator = $ pOperator ; return $ this ; }
10614	public function createMigrateRepository ( array $ args ) { $ db = $ this -> app -> db ; $ repo = new Repository ( $ db ) ; $ resolver = $ this -> app -> resolver -> getResolver ( "migrations" ) ; $ mods = [ ] ; foreach ( $ resolver -> getSearchPath ( ) as $ name => $ path ) { $ module = new Module ( $ name , $ path , $ db ) ; if ( $ name === "wedeto.db" ) array_unshift ( $ mods , $ module ) ; else array_push ( $ mods , $ module ) ; } foreach ( $ mods as $ module ) $ repo -> addModule ( $ module ) ; return $ repo ; }
3787	protected function getMetaModelById ( $ modelId ) { $ services = $ this -> getServiceContainer ( ) ; $ modelFactory = $ services -> getFactory ( ) ; $ name = $ modelFactory -> translateIdToMetaModelName ( $ modelId ) ; return $ modelFactory -> getMetaModel ( $ name ) ; }
4847	public static function unregister ( ) { if ( isset ( self :: $ autoloadFn ) ) { spl_autoload_unregister ( self :: $ autoloadFn ) ; self :: $ autoloadFn = null ; } self :: $ aliases = [ ] ; }
12471	protected function setDatabaseFactoryNamespaces ( ) { $ this -> replaceIn ( $ this -> laravel -> databasePath ( ) . '/factories/ModelFactory.php' , $ this -> currentRoot , $ this -> argument ( 'name' ) ) ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
10978	protected function setVerificationCode ( $ code = null ) { $ this -> { Config :: get ( 'verifier.store_column' ) } = $ code ; if ( $ code ) { $ this -> { Config :: get ( 'verifier.flag_column' ) } = false ; } else { $ this -> { Config :: get ( 'verifier.flag_column' ) } = true ; } $ this -> save ( ) ; }
9051	protected function getMessage ( $ level , $ message , array $ context = array ( ) ) : MemoryStream { self :: checkLevel ( $ level ) ; $ ms = new MemoryStream ( ) ; $ ms -> write ( strftime ( "%Y-%m-%d %H:%M:%S" , time ( ) ) ) ; $ ms -> interpolate ( "\t[{level}]: " , array ( 'level' => sprintf ( "%6.6s" , $ level ) ) ) ; $ ms -> interpolate ( $ message , $ context ) ; $ ms -> write ( "\n" ) ; return $ ms ; }
10625	protected function beforeBuild ( ) { $ this -> type = 'CREATE' ; if ( $ this -> temporary ) { $ this -> type .= ' TEMPORARY' ; } $ this -> type .= ' TABLE' ; if ( $ this -> if_not_exists ) { $ this -> type .= ' IF NOT EXISTS' ; } $ this -> type .= ' ' . $ this -> quote ( $ this -> tbl_name ) ; return ; }
6145	public function checkFragment ( $ fragment = null ) { if ( $ fragment === null ) { $ fragment = $ this -> fragment ; } if ( strlen ( $ fragment ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ fragment ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI fragment validation failed" ) ; } return ( $ status == 1 ) ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
9381	public function set ( $ id , $ concrete , $ share = false ) { return $ this -> add ( $ id , $ concrete , $ share ) ; }
7002	public function action ( Callable $ action = null ) { if ( $ action ) $ this -> action = $ action ; return $ this -> action ; }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
3174	private function getTimeConstraint ( TestSession $ session , QtiComponent $ source , $ navigationMode ) { $ constraint = new QtiTimeConstraint ( $ source , $ session -> getTimerDuration ( $ source -> getIdentifier ( ) ) , $ navigationMode , true , true , $ session -> getTimerTarget ( ) ) ; $ constraint -> setTimer ( $ session -> getTimer ( ) ) ; return $ constraint ; }
5034	public function hydrate ( $ value ) { if ( ! is_array ( $ value ) ) { return null ; } $ entity = $ this -> getTargetEntity ( ) ; foreach ( $ value as $ key => $ v ) { $ entity -> { "set$key" } ( $ v ) ; } return $ entity ; }
6727	public function set_movie_votes ( $ post_id , $ total_votes ) { $ total_votes = $ total_votes ? : 'N/B' ; if ( ! add_post_meta ( $ post_id , 'imdbVotes' , $ total_votes , true ) ) { update_post_meta ( $ post_id , 'imdbVotes' , $ total_votes ) ; } }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
4814	private function createFrom ( $ filepath ) { if ( file_exists ( $ filepath ) ) { $ anyDataSet = XmlUtil :: createXmlDocumentFromFile ( $ filepath ) ; $ this -> collection = array ( ) ; $ rows = $ anyDataSet -> getElementsByTagName ( "row" ) ; foreach ( $ rows as $ row ) { $ sr = new Row ( ) ; $ fields = $ row -> getElementsByTagName ( "field" ) ; foreach ( $ fields as $ field ) { $ attr = $ field -> attributes -> getNamedItem ( "name" ) ; if ( is_null ( $ attr ) ) { throw new \ InvalidArgumentException ( 'Malformed anydataset file ' . basename ( $ filepath ) ) ; } $ sr -> addField ( $ attr -> nodeValue , $ field -> nodeValue ) ; } $ sr -> acceptChanges ( ) ; $ this -> collection [ ] = $ sr ; } $ this -> currentRow = count ( $ this -> collection ) - 1 ; } }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
8016	public function close ( ) { $ uri = $ this -> current ( ) -> getNextUri ( ) ; if ( ! is_null ( $ uri ) ) { $ this -> client -> deleteAsync ( $ uri ) -> wait ( ) ; } $ this -> closed = true ; }
8657	private function convertCancelFeedSubmissions ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CancelFeedSubmissions' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionIdList ( ) ) { $ feedSubmissionIdList = $ request -> getFeedSubmissionIdList ( ) ; foreach ( $ feedSubmissionIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'FeedSubmissionIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10506	private function registerLogMenu ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogMenu :: class , Utilities \ LogMenu :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.menu' , Contracts \ Utilities \ LogMenu :: class ) ; }
6516	public function register ( Container $ container ) { $ container [ 'doctrine.orm.em' ] = $ this -> getOrmEmDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.config' ] = $ this -> getOrmEmConfigDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.default_options' ] = $ this -> getOrmEmDefaultOptions ( ) ; $ container [ 'doctrine.orm.ems' ] = $ this -> getOrmEmsDefinition ( $ container ) ; $ container [ 'doctrine.orm.ems.config' ] = $ this -> getOrmEmsConfigServiceProvider ( $ container ) ; $ container [ 'doctrine.orm.ems.options.initializer' ] = $ this -> getOrmEmsOptionsInitializerDefinition ( $ container ) ; $ container [ 'doctrine.orm.entity.listener_resolver.default' ] = $ this -> getOrmEntityListenerResolverDefinition ( $ container ) ; $ container [ 'doctrine.orm.manager_registry' ] = $ this -> getOrmManagerRegistryDefintion ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.annotation' ] = $ this -> getOrmMappingDriverFactoryAnnotation ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.class_map' ] = $ this -> getOrmMappingDriverFactoryClassMap ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.php' ] = $ this -> getOrmMappingDriverFactoryPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_xml' ] = $ this -> getOrmMappingDriverFactorySimpleXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_yaml' ] = $ this -> getOrmMappingDriverFactorySimpleYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.static_php' ] = $ this -> getOrmMappingDriverFactoryStaticPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.xml' ] = $ this -> getOrmMappingDriverFactoryXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.yaml' ] = $ this -> getOrmMappingDriverFactoryYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver_chain' ] = $ this -> getOrmMappingDriverChainDefinition ( $ container ) ; $ container [ 'doctrine.orm.repository.factory.default' ] = $ this -> getOrmRepositoryFactoryDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.naming.default' ] = $ this -> getOrmNamingStrategyDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.quote.default' ] = $ this -> getOrmQuoteStrategyDefinition ( $ container ) ; }
1066	private function doTypesConflict ( OutputType $ type1 , OutputType $ type2 ) { if ( $ type1 instanceof ListOfType ) { return $ type2 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof ListOfType ) { return $ type1 instanceof ListOfType ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type1 instanceof NonNull ) { return $ type2 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( $ type2 instanceof NonNull ) { return $ type1 instanceof NonNull ? $ this -> doTypesConflict ( $ type1 -> getWrappedType ( ) , $ type2 -> getWrappedType ( ) ) : true ; } if ( Type :: isLeafType ( $ type1 ) || Type :: isLeafType ( $ type2 ) ) { return $ type1 !== $ type2 ; } return false ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
11464	public static function error ( $ severity , $ message , $ file , $ line ) { if ( error_reporting ( ) == 0 ) return ; elseif ( error_reporting ( ) && $ severity ) { $ ErrorException = new PHPErrorException ( $ message , 0 , $ severity , $ file , $ line ) ; if ( assert_options ( ASSERT_ACTIVE ) ) { foreach ( $ ErrorException -> getStackTrace ( ) as $ element ) { if ( isset ( $ element [ 'function' ] ) && $ element [ 'function' ] == 'assert' ) { self :: exception ( $ ErrorException ) ; } } } $ recoverable = [ E_WARNING , E_NOTICE , E_USER_WARNING , E_USER_NOTICE , E_STRICT , E_DEPRECATED , E_USER_DEPRECATED ] ; if ( in_array ( $ severity , $ recoverable ) ) { return ; } throw $ ErrorException ; } }
9475	public function stripQuotes ( $ string ) { if ( strlen ( $ string ) < 2 || substr ( $ string , 0 , 1 ) !== '"' || substr ( $ string , - 1 , 1 ) !== '"' ) { return $ string ; } return substr ( $ string , 1 , - 1 ) ; }
3702	protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; }
10470	public function lookupUser ( $ user_id ) { $ request = new UserRequest ( $ user_id ) ; $ this -> emit ( 'request.user' , array ( $ user_id ) ) ; $ response = $ this -> post ( $ request ) ; return new UserResponse ( $ response ) ; }
7224	public function exec ( $ keepAlive = false ) { $ this -> lastResult = curl_exec ( $ this -> curl ) ; $ this -> info = curl_getinfo ( $ this -> curl ) ; if ( ! $ keepAlive ) curl_close ( $ this -> curl ) ; return $ this -> lastResult !== false ; }
1134	public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; }
4723	public function setAttribute ( $ attribute , $ value = null ) { $ this -> attributes -> set ( $ attribute , $ value ) ; return $ this ; }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
5572	public function authenticate ( $ username , $ password ) { if ( ! $ this -> page -> getRealm ( ) ) { return false ; } $ url = $ this -> page -> getUrl ( ) ; if ( ! $ url ) { return false ; } $ this -> user_agent -> setIdentity ( $ url -> getHost ( ) , $ this -> page -> getRealm ( ) , $ username , $ password ) ; return $ this -> retry ( ) ; }
5278	public function orWhere ( $ column , $ param1 = null , $ param2 = null ) { return $ this -> where ( $ column , $ param1 , $ param2 , 'or' ) ; }
6533	protected function getConnectionFactory ( $ type ) { if ( false === isset ( $ this -> connectionFactories [ $ type ] ) ) { throw new \ InvalidArgumentException ( "Missing connection factory \"$type\"" ) ; } return $ this -> connectionFactories [ $ type ] ; }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
4635	private function attachMailListeners ( EventsCapableInterface $ service , ContainerInterface $ container , array $ mailOptions ) : void { $ listeners = ( array ) ( $ mailOptions [ 'mail_listeners' ] ?? [ ] ) ; if ( empty ( $ listeners ) ) { return ; } $ definitions = [ ] ; $ eventManager = $ service -> getEventManager ( ) ; foreach ( $ listeners as $ listener ) { $ this -> addDefinitions ( $ definitions , $ listener , $ eventManager ) ; } if ( ! empty ( $ definitions ) ) { ( new LazyListenerAggregate ( $ definitions , $ container ) ) -> attach ( $ eventManager ) ; } }
8247	public function userDataEncodePassword ( & $ userData , Password $ newPassword ) { $ encoderName = $ this -> config [ "encoder" ] ; $ encoder = $ this -> picoAuth -> getContainer ( ) -> get ( $ encoderName ) ; $ userData [ 'pwhash' ] = $ encoder -> encode ( $ newPassword -> get ( ) ) ; $ userData [ 'encoder' ] = $ encoderName ; if ( isset ( $ userData [ 'pwreset' ] ) ) { unset ( $ userData [ 'pwreset' ] ) ; } }
7125	static public function equals ( AddressInterface $ source , AddressInterface $ target ) { if ( ! ( $ source -> getCompany ( ) === $ target -> getCompany ( ) && $ source -> getGender ( ) === $ target -> getGender ( ) && $ source -> getFirstName ( ) === $ target -> getFirstName ( ) && $ source -> getLastName ( ) === $ target -> getLastName ( ) && $ source -> getStreet ( ) === $ target -> getStreet ( ) && $ source -> getComplement ( ) === $ target -> getComplement ( ) && $ source -> getSupplement ( ) === $ target -> getSupplement ( ) && $ source -> getExtra ( ) === $ target -> getExtra ( ) && $ source -> getCity ( ) === $ target -> getCity ( ) && $ source -> getPostalCode ( ) === $ target -> getPostalCode ( ) && $ source -> getDigicode1 ( ) === $ target -> getDigicode1 ( ) && $ source -> getDigicode2 ( ) === $ target -> getDigicode2 ( ) && $ source -> getIntercom ( ) === $ target -> getIntercom ( ) ) ) { return false ; } $ sourceCountryId = $ source -> getCountry ( ) ? $ source -> getCountry ( ) -> getId ( ) : null ; $ targetCountryId = $ target -> getCountry ( ) ? $ target -> getCountry ( ) -> getId ( ) : null ; if ( $ sourceCountryId != $ targetCountryId ) { return false ; } $ sourceStateId = $ source -> getState ( ) ? $ source -> getState ( ) -> getId ( ) : null ; $ targetStateId = $ target -> getState ( ) ? $ target -> getState ( ) -> getId ( ) : null ; if ( $ sourceStateId != $ targetStateId ) { return false ; } $ sourcePhone = ( string ) $ source -> getPhone ( ) ; $ targetPhone = ( string ) $ target -> getPhone ( ) ; if ( $ sourcePhone !== $ targetPhone ) { return false ; } $ sourceMobile = ( string ) $ source -> getMobile ( ) ; $ targetMobile = ( string ) $ target -> getMobile ( ) ; if ( $ sourceMobile !== $ targetMobile ) { return false ; } return true ; }
6115	public function serverGetPortById ( $ sid ) { if ( ! array_key_exists ( ( string ) $ sid , $ this -> serverList ( ) ) ) { throw new Ts3Exception ( "invalid serverID" , 0x400 ) ; } return $ this -> serverList [ intval ( ( string ) $ sid ) ] [ "virtualserver_port" ] ; }
12752	public function sendConfirmationMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> confirmationSubject , 'confirmation' , [ 'user' => $ user , 'token' => $ token ] ) ; }
8604	public function getSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_GetSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_GetSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_GetSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10918	public function getUserEntity ( $ identity , $ credential ) { $ credential = $ this -> preProcessCredential ( $ credential ) ; $ userObject = NULL ; $ fields = $ this -> getOptions ( ) -> getAuthIdentityFields ( ) ; while ( ! is_object ( $ userObject ) && count ( $ fields ) > 0 ) { $ mode = array_shift ( $ fields ) ; switch ( $ mode ) { case 'username' : $ userObject = $ this -> getMapper ( ) -> findByUsername ( $ identity ) ; break ; case 'email' : $ userObject = $ this -> getMapper ( ) -> findByEmail ( $ identity ) ; break ; } } if ( ! $ userObject ) { return null ; } $ bcrypt = new Bcrypt ( ) ; $ bcrypt -> setCost ( $ this -> getOptions ( ) -> getPasswordCost ( ) ) ; if ( ! $ bcrypt -> verify ( $ credential , $ userObject -> getPassword ( ) ) ) { return null ; } return $ userObject ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
5898	public function retrieveVideoTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new VideoTemplate ( $ result ) ; return $ result ; }
2995	protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; }
3627	protected function getDeviceNetworkInfo ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ connection_info = $ this -> last_status -> track -> { $ serial_number } ; return ( object ) array ( 'online' => $ connection_info -> online , 'last_connection' => date ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'last_connection_UTC' => gmdate ( DATETIME_FORMAT , $ connection_info -> last_connection / 1000 ) , 'wan_ip' => @ $ connection_info -> last_ip , 'local_ip' => $ this -> last_status -> device -> { $ serial_number } -> local_ip , 'mac_address' => $ this -> last_status -> device -> { $ serial_number } -> mac_address ) ; }
3488	private static function tryResolveBySpomkyLabsJoseSystem ( ) : ? SpomkyLabsJoseSignatureGenerator { $ requiredClasses = [ JWKFactory :: class , JWSFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new SpomkyLabsJoseSignatureGenerator ( ) ; }
12108	public function changePageFromRequest ( $ id , $ request ) { $ this -> getPage ( $ id ) ; $ page = $ this -> createPageObject ( null , null , $ request ) ; $ this -> pages [ $ id ] = $ page ; $ this -> persist ( ) ; return $ page ; }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
299	public function beforeSave ( $ insert ) { $ event = new ModelEvent ( ) ; $ this -> trigger ( $ insert ? self :: EVENT_BEFORE_INSERT : self :: EVENT_BEFORE_UPDATE , $ event ) ; return $ event -> isValid ; }
9869	private function writePageMargins ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageMargins' ) ; $ objWriter -> writeAttribute ( 'left' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getLeft ( ) ) ) ; $ objWriter -> writeAttribute ( 'right' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getRight ( ) ) ) ; $ objWriter -> writeAttribute ( 'top' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getTop ( ) ) ) ; $ objWriter -> writeAttribute ( 'bottom' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getBottom ( ) ) ) ; $ objWriter -> writeAttribute ( 'header' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getHeader ( ) ) ) ; $ objWriter -> writeAttribute ( 'footer' , StringHelper :: formatNumber ( $ pSheet -> getPageMargins ( ) -> getFooter ( ) ) ) ; $ objWriter -> endElement ( ) ; }
10441	protected function getLineType ( $ line ) { if ( preg_match ( '/^###\s+@[0-9]+=.*$/' , $ line ) ) { return self :: LINE_TYPE_PARAM ; } elseif ( preg_match ( '/^###/' , $ line ) ) { return self :: LINE_TYPE_QUERY ; } elseif ( preg_match ( '/^#[0-9]/' , $ line ) ) { return self :: LINE_TYPE_META ; } elseif ( preg_match ( '/Errcode|ERROR/' , $ line ) ) { return self :: LINE_TYPE_ERROR ; } return self :: LINE_TYPE_UNKNOWN ; }
4796	protected function execute ( ) { if ( ! isset ( $ this -> rows ) ) { $ result = false ; $ exception = null ; $ parameters = array ( ) ; foreach ( array_merge ( $ this -> select , array ( $ this , $ this -> group , $ this -> having ) , $ this -> order , $ this -> unionOrder ) as $ val ) { if ( ( $ val instanceof NotORM_Literal || $ val instanceof self ) && $ val -> parameters ) { $ parameters = array_merge ( $ parameters , $ val -> parameters ) ; } } try { $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } catch ( PDOException $ exception ) { } if ( ! $ result ) { if ( ! $ this -> select && $ this -> accessed ) { $ this -> accessed = '' ; $ this -> access = array ( ) ; $ result = $ this -> query ( $ this -> __toString ( ) , $ parameters ) ; } elseif ( $ exception ) { throw $ exception ; } } $ this -> rows = array ( ) ; if ( $ result ) { $ result -> setFetchMode ( PDO :: FETCH_ASSOC ) ; foreach ( $ result as $ key => $ row ) { if ( isset ( $ row [ $ this -> primary ] ) ) { $ key = $ row [ $ this -> primary ] ; if ( ! is_string ( $ this -> access ) ) { $ this -> access [ $ this -> primary ] = true ; } } if ( $ this -> notORM -> isKeepPrimaryKeyIndex ) { $ this -> rows [ $ key ] = $ row ; } else { $ this -> rows [ ] = $ row ; } } } $ this -> data = $ this -> rows ; } }
6994	public function prePersist ( UploadableInterface $ uploadable ) { if ( ! $ this -> enabled ) { return ; } $ uploadable -> setCreatedAt ( new \ DateTime ( ) ) -> setUpdatedAt ( new \ DateTime ( ) ) ; $ this -> uploader -> prepare ( $ uploadable ) ; }
333	public function add ( $ key , $ value , $ duration = 0 , $ dependency = null ) { if ( $ dependency !== null && $ this -> serializer !== false ) { $ dependency -> evaluateDependency ( $ this ) ; } if ( $ this -> serializer === null ) { $ value = serialize ( [ $ value , $ dependency ] ) ; } elseif ( $ this -> serializer !== false ) { $ value = call_user_func ( $ this -> serializer [ 0 ] , [ $ value , $ dependency ] ) ; } $ key = $ this -> buildKey ( $ key ) ; return $ this -> addValue ( $ key , $ value , $ duration ) ; }
11683	protected function _pushMessage ( $ message , $ type = 'error' , array $ interpolateParams = [ ] ) { $ this -> _messages [ ] = [ 'message' => vsprintf ( $ message , $ interpolateParams ) , 'type' => $ type , ] ; return $ this ; }
5025	protected function renderMarkup ( FileUpload $ element ) { $ markup = '<div class="%s" id="%s-dropzone"> %s __input__</div>' ; return sprintf ( $ markup , $ this -> getDropZoneClass ( $ element ) , $ element -> getAttribute ( 'id' ) , $ this -> renderFileList ( $ element ) ) ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
10938	private static function populateEntries ( $ heading , $ data , $ key ) { foreach ( LogLevels :: all ( ) as $ level ) { if ( self :: hasLogLevel ( $ heading [ $ key ] , $ level ) ) { self :: $ parsed [ ] = [ 'level' => $ level , 'header' => $ heading [ $ key ] , 'stack' => $ data [ $ key ] , ] ; } } }
370	protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
1420	protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; }
6325	public function stop ( ) { $ fp = @ fopen ( $ this -> _file , 'w' ) ; fwrite ( $ fp , ob_get_contents ( ) ) ; fclose ( $ fp ) ; ob_end_flush ( ) ; }
10712	public function create ( array $ attributes = [ ] ) { $ model = $ this -> newModel ( ) ; $ model -> fill ( $ attributes ) ; $ this -> save ( $ model ) ; return $ model ; }
12216	protected function yieldConfigurationFiles ( CompilerContext $ context ) : Generator { $ configDirs = [ ] ; foreach ( $ context -> getProjectSearchPaths ( SearchPathAttribute :: SEARCH_PATH_USER_CONFIG ) as $ configDir ) { $ configDirs [ ] = ( string ) $ configDir ; } $ pattern = $ this -> info [ static :: INFO_PATTERN_KEY ] ; $ defaultFile = $ this -> info [ static :: INFO_CUSTOM_FILENAME_KEY ] ?? NULL ; foreach ( $ context -> getSourceCodeManager ( ) -> yieldSourceFiles ( $ pattern , $ configDirs ) as $ fileName => $ file ) { if ( basename ( $ fileName ) == $ defaultFile ) continue ; yield $ fileName => $ file ; } }
6465	public function isMultipart ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/multipart\//i" , $ contentType ) === 1 ; }
1441	protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; }
5753	public function getRoleIdsForRoles ( array $ roles ) : array { if ( count ( $ roles ) == 0 ) { throw new \ InvalidArgumentException ( "Roles array must be populated." ) ; } $ roleIds = [ ] ; foreach ( $ roles as $ role ) { if ( null === $ roleIds [ ] = $ this -> getRoleIdForRole ( $ role ) ) { throw new \ InvalidArgumentException ( "Role $role does not exist" ) ; } } return $ roleIds ; }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
1356	protected function getSortColumn ( $ field , Model $ model ) { if ( isset ( $ this -> sortColumns [ $ field ] ) ) { return $ this -> sortColumns [ $ field ] ; } return $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; }
9623	public function getConnectionConfig ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } $ config = $ this -> config -> get ( "database.connections.$connection" ) ; if ( ! $ config ) { if ( ! is_string ( $ connection ) ) { $ connection = gettype ( $ connection ) ; } throw new \ InvalidArgumentException ( "No config found for connection: $connection" ) ; } return $ config ; }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
11170	private function refreshSession ( ) { $ mapper = Neuron_GameServer_Mappers_UpdateMapper :: getInstance ( ) ; if ( ! isset ( $ _SESSION [ 'ngpu_lastlog' ] ) ) { $ _SESSION [ 'ngpu_lastlog' ] = $ mapper -> getLastLogId ( $ this -> objProfile ) ; $ _SESSION [ 'ngpu_data' ] = array ( ) ; } else { $ lastLogId = $ _SESSION [ 'ngpu_lastlog' ] ; $ updates = $ mapper -> getUpdates ( $ this -> objProfile , $ lastLogId ) ; foreach ( $ updates as $ v ) { $ _SESSION [ 'ngpu_data' ] [ $ v [ 'key' ] ] = $ v [ 'value' ] ; $ lastLogId = max ( $ v [ 'id' ] , $ lastLogId ) ; } $ _SESSION [ 'ngpu_lastlog' ] = $ lastLogId ; } }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
9335	public function rad ( ) { if ( $ this -> original -> type == self :: TYPE_RAD ) { return $ this -> original -> value ; } return $ this -> float_rad ; }
3096	public function process ( ) { $ this -> validate ( ) ; $ itemIdentifier = $ this -> hasRequestParameter ( 'itemDefinition' ) ? $ this -> getRequestParameter ( 'itemDefinition' ) : null ; if ( ! is_array ( $ itemIdentifier ) ) { $ itemIdentifier = [ $ itemIdentifier ] ; } try { if ( ! $ this -> getRunnerService ( ) -> getTestConfig ( ) -> getConfigValue ( 'itemCaching.enabled' ) ) { common_Logger :: w ( 'Attempt to disclose the next items without the configuration' ) ; throw new common_exception_Unauthorized ( ) ; } $ response = [ ] ; foreach ( $ itemIdentifier as $ itemId ) { $ response [ 'items' ] [ ] = $ this -> getItemData ( $ itemId ) ; } if ( isset ( $ response [ 'items' ] ) ) { $ response [ 'success' ] = true ; } } catch ( \ Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
