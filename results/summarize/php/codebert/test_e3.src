6127	public function setExpireDate ( $ expireDate ) { if ( $ expireDate instanceof DateTime ) { $ this -> expireDate = $ expireDate ; } else { try { $ this -> expireDate = new DateTime ( $ expireDate ) ; } catch ( \ Exception $ e ) { $ this -> expireDate = null ; } } return $ this ; }
4554	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; foreach ( $ this -> removed as $ property ) { if ( array_key_exists ( $ property , $ payload ) ) { $ event -> markAsInvalid ( ) ; break ; } } }
172	private static function matchPathname ( $ path , $ basePath , $ pattern , $ firstWildcard , $ flags ) { if ( isset ( $ pattern [ 0 ] ) && $ pattern [ 0 ] === '/' ) { $ pattern = StringHelper :: byteSubstr ( $ pattern , 1 , StringHelper :: byteLength ( $ pattern ) ) ; if ( $ firstWildcard !== false && $ firstWildcard !== 0 ) { $ firstWildcard -- ; } } $ namelen = StringHelper :: byteLength ( $ path ) - ( empty ( $ basePath ) ? 0 : StringHelper :: byteLength ( $ basePath ) + 1 ) ; $ name = StringHelper :: byteSubstr ( $ path , - $ namelen , $ namelen ) ; if ( $ firstWildcard !== 0 ) { if ( $ firstWildcard === false ) { $ firstWildcard = StringHelper :: byteLength ( $ pattern ) ; } if ( $ firstWildcard > $ namelen ) { return false ; } if ( strncmp ( $ pattern , $ name , $ firstWildcard ) ) { return false ; } $ pattern = StringHelper :: byteSubstr ( $ pattern , $ firstWildcard , StringHelper :: byteLength ( $ pattern ) ) ; $ name = StringHelper :: byteSubstr ( $ name , $ firstWildcard , $ namelen ) ; if ( empty ( $ pattern ) && empty ( $ name ) ) { return true ; } } $ matchOptions = [ 'filePath' => true ] ; if ( $ flags & self :: PATTERN_CASE_INSENSITIVE ) { $ matchOptions [ 'caseSensitive' ] = false ; } return StringHelper :: matchWildcard ( $ pattern , $ name , $ matchOptions ) ; }
520	protected function migrateUp ( $ class ) { if ( $ class === self :: BASE_MIGRATION ) { return true ; } $ this -> stdout ( "*** applying $class\n" , Console :: FG_YELLOW ) ; $ start = microtime ( true ) ; $ migration = $ this -> createMigration ( $ class ) ; if ( $ migration -> up ( ) !== false ) { $ this -> addMigrationHistory ( $ class ) ; $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** applied $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_GREEN ) ; return true ; } $ time = microtime ( true ) - $ start ; $ this -> stdout ( "*** failed to apply $class (time: " . sprintf ( '%.3f' , $ time ) . "s)\n\n" , Console :: FG_RED ) ; return false ; }
197	public function setDownloadHeaders ( $ attachmentName , $ mimeType = null , $ inline = false , $ contentLength = null ) { $ headers = $ this -> getHeaders ( ) ; $ disposition = $ inline ? 'inline' : 'attachment' ; $ headers -> setDefault ( 'Pragma' , 'public' ) -> setDefault ( 'Accept-Ranges' , 'bytes' ) -> setDefault ( 'Expires' , '0' ) -> setDefault ( 'Cache-Control' , 'must-revalidate, post-check=0, pre-check=0' ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; if ( $ mimeType !== null ) { $ headers -> setDefault ( 'Content-Type' , $ mimeType ) ; } if ( $ contentLength !== null ) { $ headers -> setDefault ( 'Content-Length' , $ contentLength ) ; } return $ this ; }
1517	public function readRelationship ( StoreInterface $ store , FetchRelationship $ request ) { $ record = $ request -> getRecord ( ) ; $ result = $ this -> beforeReadingRelationship ( $ record , $ request ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } $ related = $ store -> queryRelationship ( $ record , $ request -> getRelationshipName ( ) , $ request -> getParameters ( ) ) ; $ records = ( $ related instanceof PageInterface ) ? $ related -> getData ( ) : $ related ; $ result = $ this -> afterReadingRelationship ( $ record , $ records , $ request ) ; if ( $ this -> isInvokedResult ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> relationship ( $ related ) ; }
9422	public function getMetadata ( $ key = null ) { isset ( $ this -> stream ) && $ this -> meta = stream_get_meta_data ( $ this -> stream ) ; $ metadata = isset ( $ this -> meta [ $ key ] ) ? $ this -> meta [ $ key ] : null ; return is_null ( $ key ) ? $ this -> meta : $ metadata ; }
4368	public function & offsetGet ( $ key ) { if ( $ this -> hasValue ( $ key ) ) { return $ this -> values [ $ key ] ; } $ null = null ; return $ null ; }
12211	public function addSnippet ( string $ snptName ) : void { $ this -> snippets [ $ snptName ] = ViewFactory :: createSnippet ( $ snptName ) ; }
12450	static function run_check_templates ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.tpl' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } $ ezp = @ $ opts [ 'ezublish' ] [ 'install_dir_LS' ] ; if ( $ ezp == '' ) { $ ezp = '../..' ; } if ( ! file_exists ( $ ezp . '/bin/php/eztemplatecheck.php' ) ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$ezp does not seem to be a valid eZ Publish install" ) ; } $ rootpath = pakeFinder :: type ( 'directory' ) -> name ( $ opts [ 'extension' ] [ 'name' ] ) -> in ( self :: getBuildDir ( $ opts ) ) ; $ rootpath = dirname ( $ rootpath [ 0 ] ) ; $ out = pake_sh ( "cd " . escapeshellarg ( $ ezp ) . " && " . escapeshellarg ( $ php ) . " bin/php/eztemplatecheck.php " . escapeshellarg ( $ rootpath ) ) ; if ( strpos ( $ out , 'Some templates did not validate' ) !== false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( $ out ) ; } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
10209	private function performRequest ( $ curlSession , $ deserializationType = null ) { $ response = curl_exec ( $ curlSession ) ; $ response = $ response ? $ response : null ; try { $ result = new MaileonAPIResult ( $ response , $ curlSession , $ this -> throwException , $ deserializationType ) ; $ this -> printDebugInformation ( $ curlSession , $ result ) ; curl_close ( $ curlSession ) ; return $ result ; } catch ( MaileonAPIException $ e ) { if ( $ this -> debug ) { $ this -> printDebugInformation ( $ curlSession , null , $ this -> throwException ? null : $ e ) ; } curl_close ( $ curlSession ) ; if ( $ this -> throwException ) { throw $ e ; } return null ; } }
6879	public function finish ( ) { parent :: finish ( ) ; if ( $ this -> isRowActionsEnabled ( ) && ! $ this -> hasValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME ) ) { $ this -> addValueViewer ( static :: ROW_ACTIONS_COLUMN_NAME , null ) ; } if ( $ this -> isNestedViewEnabled ( ) && ! $ this -> hasValueViewer ( $ this -> getColumnNameForNestedView ( ) ) ) { $ this -> addValueViewer ( $ this -> getColumnNameForNestedView ( ) , DataGridColumn :: create ( ) -> setIsVisible ( false ) ) ; } if ( $ this -> isRowsReorderingEnabled ( ) ) { $ reorderingColumns = $ this -> getRowsPositioningColumns ( ) ; $ allowedColumnTypes = [ Column :: TYPE_INT , Column :: TYPE_FLOAT , Column :: TYPE_UNIX_TIMESTAMP ] ; foreach ( $ reorderingColumns as $ columnName ) { if ( ! $ this -> hasValueViewer ( $ columnName ) ) { throw new NotFoundException ( "Column '$columnName' provided for reordering was not found within declared data grid columns" ) ; } $ valueViewer = $ this -> getValueViewer ( $ columnName ) ; if ( ! $ valueViewer -> isLinkedToDbColumn ( ) && $ valueViewer -> getTableColumn ( ) -> isItExistsInDb ( ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering must be linked to a column that exists in database" ) ; } $ colType = $ valueViewer -> getTableColumn ( ) -> getType ( ) ; if ( ! in_array ( $ colType , $ allowedColumnTypes , true ) ) { throw new \ UnexpectedValueException ( "Column '$columnName' provided for reordering should be of a numeric type (int, float, unix ts)." . "'{$colType}' type is not acceptable'" ) ; } $ valueViewer -> setIsSortable ( true ) ; } } }
11745	public function getShakeInfo ( $ ticket , $ needPoi = null ) { $ params = [ 'ticket' => $ ticket , ] ; if ( $ needPoi !== null ) { $ params [ 'need_poi' ] = intval ( $ needPoi ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_GET_SHAKE_INFO , $ params ] ) ; }
12970	private function getReflectionAndClassObject ( ) { if ( $ this -> isCalledAfterOn ) { $ this -> isCalledAfterOn = false ; $ classObj = $ this -> classObjOn ; $ reflection = $ this -> reflectionOn ; unset ( $ this -> classObjOn ) ; unset ( $ this -> reflectionOn ) ; return [ $ reflection , $ classObj ] ; } return [ $ this -> reflection , $ this -> classObj ] ; }
2809	public function getVisiblePanels ( ) { if ( $ this -> visiblePanels === null ) { $ this -> visiblePanels = array ( ) ; $ panels = $ this -> getSortedChildBlocks ( ) ; foreach ( $ panels as $ panel ) { if ( ! $ panel instanceof Sheep_Debug_Block_Panel ) { continue ; } $ this -> visiblePanels [ ] = $ panel ; } } return $ this -> visiblePanels ; }
8504	public function confirmTransportRequest ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ConfirmTransportInputRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ConfirmTransportRequest' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ConfirmTransportRequestResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4839	public function request ( $ method , $ endpoint , $ params = array ( ) ) { if ( ! isset ( $ params [ 'http_authorization' ] ) ) { if ( ! isset ( $ this -> account_details [ 'access_token' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ params [ 'http_bearer' ] = $ this -> account_details [ 'access_token' ] ; } if ( isset ( $ this -> account_details [ 'ua_tag' ] ) ) { $ params [ 'ua_tag' ] = $ this -> account_details [ 'ua_tag' ] ; } if ( substr ( $ endpoint , 0 , 6 ) == '/oauth' ) { $ url = $ this -> base_url . $ endpoint ; } else { $ url = $ this -> base_url . self :: $ api_path . $ endpoint ; } return call_user_func ( GoCardless :: getClass ( 'Request' ) . '::' . $ method , $ url , $ params ) ; }
1629	public function getMonolog ( ) { foreach ( $ this -> loggers as $ logger ) { if ( is_callable ( [ $ logger , 'getMonolog' ] ) ) { $ monolog = $ logger -> getMonolog ( ) ; if ( $ monolog === null ) { continue ; } return $ monolog ; } } }
10107	private function writeColinfo ( $ col_array ) { if ( isset ( $ col_array [ 0 ] ) ) { $ colFirst = $ col_array [ 0 ] ; } if ( isset ( $ col_array [ 1 ] ) ) { $ colLast = $ col_array [ 1 ] ; } if ( isset ( $ col_array [ 2 ] ) ) { $ coldx = $ col_array [ 2 ] ; } else { $ coldx = 8.43 ; } if ( isset ( $ col_array [ 3 ] ) ) { $ xfIndex = $ col_array [ 3 ] ; } else { $ xfIndex = 15 ; } if ( isset ( $ col_array [ 4 ] ) ) { $ grbit = $ col_array [ 4 ] ; } else { $ grbit = 0 ; } if ( isset ( $ col_array [ 5 ] ) ) { $ level = $ col_array [ 5 ] ; } else { $ level = 0 ; } $ record = 0x007D ; $ length = 0x000C ; $ coldx *= 256 ; $ ixfe = $ xfIndex ; $ reserved = 0x0000 ; $ level = max ( 0 , min ( $ level , 7 ) ) ; $ grbit |= $ level << 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vvvvvv' , $ colFirst , $ colLast , $ coldx , $ ixfe , $ grbit , $ reserved ) ; $ this -> append ( $ header . $ data ) ; }
7288	public function setColumnForLinksLabels ( $ columnNameOrClosure ) { if ( ! is_string ( $ columnNameOrClosure ) && ! ( $ columnNameOrClosure instanceof DbExpr ) ) { throw new \ InvalidArgumentException ( '$columnNameOrClosure argument must be a string or a closure' ) ; } $ this -> columnForLinksLabels = $ columnNameOrClosure ; return $ this ; }
1586	public function pointer ( string $ key , string $ prefix = '' ) : string { $ prefix = rtrim ( $ prefix , '/' ) ; if ( 'type' === $ key ) { return $ prefix . '/type' ; } if ( 'id' === $ key ) { return $ prefix . '/id' ; } $ parts = collect ( explode ( '.' , $ key ) ) ; $ field = $ parts -> first ( ) ; if ( $ this -> isAttribute ( $ field ) ) { return $ prefix . '/attributes/' . $ parts -> implode ( '/' ) ; } if ( $ this -> isRelationship ( $ field ) ) { $ name = 1 < $ parts -> count ( ) ? $ field . '/' . $ parts -> put ( 0 , 'data' ) -> implode ( '/' ) : $ field ; return $ prefix . "/relationships/{$name}" ; } return $ prefix ? $ prefix : '/' ; }
3931	private function getOrCreateProperty ( PropertiesDefinitionInterface $ definition , $ propName ) { if ( $ definition -> hasProperty ( $ propName ) ) { return $ definition -> getProperty ( $ propName ) ; } $ property = new DefaultProperty ( $ propName ) ; $ definition -> addProperty ( $ property ) ; return $ property ; }
3903	public function renameColumn ( $ strNewColumnName ) { $ this -> tableManipulator -> checkColumnName ( $ strNewColumnName ) ; $ schemaManager = $ this -> connection -> getSchemaManager ( ) ; $ columns = $ schemaManager -> listTableIndexes ( $ this -> getMetaModel ( ) -> getTableName ( ) ) ; if ( $ this -> getColName ( ) && isset ( $ columns [ $ this -> getColName ( ) ] ) ) { $ this -> tableManipulator -> renameColumn ( $ this -> getMetaModel ( ) -> getTableName ( ) , $ this -> getColName ( ) , $ strNewColumnName , $ this -> getSQLDataType ( ) ) ; } else { $ strBackupColName = $ this -> getColName ( ) ; $ this -> set ( 'colname' , $ strNewColumnName ) ; $ this -> createColumn ( ) ; $ this -> set ( 'colname' , $ strBackupColName ) ; } }
12031	function addCreateAndExecuteMethod ( ) { $ methodGenerator = new MethodGenerator ( 'createAndExecute' ) ; $ body = '' ; $ body .= $ this -> generateCreateFragment ( ) ; $ body .= $ this -> generateExecuteFragment ( ) ; $ body .= PHP_EOL ; $ body .= 'return $response;' . PHP_EOL ; ; $ docBlock = new DocBlockGenerator ( 'Create and execute the operation, returning the raw response from the server.' , null ) ; $ tags [ ] = new GenericTag ( 'return' , '\Amp\Artax\Response' ) ; $ docBlock -> setTags ( $ tags ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
3340	public function getFilesChunk ( $ options = array ( ) , $ reverse = false ) { $ data = $ this -> __preparedRequest ( 'file_list' , 'GET' , $ options ) ; $ files_raw = ( array ) $ data -> results ; $ resultArr = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ resultArr [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return $ this -> __preparePagedParams ( $ data , $ reverse , $ resultArr ) ; }
5433	public function isAbstractMethodInParents ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ parent = $ interface -> getParentClass ( ) ; while ( $ parent ) { if ( ! $ parent -> hasMethod ( $ name ) ) { return false ; } if ( $ parent -> getMethod ( $ name ) -> isAbstract ( ) ) { return true ; } $ parent = $ parent -> getParentClass ( ) ; } return false ; }
4250	private function getMeta ( $ method , $ meta ) { $ firePhpMeta = array ( 'Type' => isset ( $ this -> firephpMethods [ $ method ] ) ? $ this -> firephpMethods [ $ method ] : $ this -> firephpMethods [ 'log' ] , ) ; if ( isset ( $ meta [ 'file' ] ) ) { $ firePhpMeta [ 'File' ] = $ meta [ 'file' ] ; $ firePhpMeta [ 'Line' ] = $ meta [ 'line' ] ; } if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ firePhpMeta [ 'Collapsed' ] = $ method == 'groupCollapsed' ? 'true' : 'false' ; } return $ firePhpMeta ; }
6084	public function uploadNewVersion ( $ id , $ pathname , $ revisionComment , $ filename = null , $ progress = null , $ chunkSize = 10485760 ) { $ chunk = 0 ; $ chunksTotal = ceil ( filesize ( $ pathname ) / $ chunkSize ) ; $ fileId = sha1 ( uniqid ( 'uploadVersion' , true ) ) ; $ filename = $ filename ? : pathinfo ( $ filename , PATHINFO_BASENAME ) ; $ fp = fopen ( $ pathname , 'r' ) ; if ( false === $ fp ) { throw new UploadException ( 'Could not open file "' . $ pathname . '" for reading.' ) ; } if ( $ chunkSize > 10485760 ) { $ this -> logger -> warning ( 'Using a chunk size larger then 10MB is not recommended. Uploading is not guaranteed to work properly.' ) ; } while ( $ chunkData = fread ( $ fp , $ chunkSize ) ) { $ result = $ this -> uploadNewVersionChunked ( $ chunkData , $ id , $ revisionComment , $ filename , $ chunk , $ chunksTotal , $ fileId ) ; if ( is_callable ( $ progress ) ) { try { call_user_func ( $ progress , $ chunk + 1 , $ chunksTotal ) ; } catch ( \ Exception $ e ) { $ this -> logger -> warning ( 'Could not report progress due to callback error.' , [ 'message' => $ e -> getMessage ( ) ] ) ; } } $ this -> logger -> info ( 'Upload progress!' , [ 'part' => $ chunk + 1 , 'total' => $ chunksTotal ] ) ; if ( isset ( $ result [ 'mediaId' ] ) ) { return new MediaResponse ( $ result ) ; } if ( isset ( $ result [ 'success' ] ) && false == $ result [ 'success' ] ) { throw new UploadException ( $ result [ 'error' ] [ 'message' ] , $ result [ 'error' ] [ 'code' ] ) ; } $ fileId = $ result [ 'fileId' ] ; ++ $ chunk ; } if ( $ chunk == $ chunksTotal - 1 ) { throw new UploadException ( 'Uploaded all chunks, but something went wrong.' ) ; } if ( false === $ chunkData ) { throw new UploadException ( 'Could not read chunk ' . $ chunk . ' from file "' . $ pathname . '".' ) ; } throw new UploadException ( 'Unknown upload error!' ) ; }
2371	public static function splitCsv ( $ strString , $ strDelimiter = ',' ) { $ arrValues = preg_split ( '/' . $ strDelimiter . '(?=(?:[^"]*"[^"]*")*(?![^"]*"))/' , $ strString ) ; foreach ( $ arrValues as $ k => $ v ) { $ arrValues [ $ k ] = trim ( $ v , ' "' ) ; } return $ arrValues ; }
9192	public function init ( ) { if ( $ this -> isInitialized ( ) ) return true ; $ sm = $ this -> getServiceManager ( ) ; $ defaultListeners = $ sm -> get ( 'yimaTheme.Manager.ListenerAggregate' ) ; if ( $ defaultListeners instanceof self ) $ defaultListeners -> manager = $ this ; $ sharedEvents = $ this -> getEventManager ( ) -> getSharedManager ( ) ; $ sharedEvents -> attachAggregate ( $ defaultListeners ) ; $ this -> isInitialized = true ; return $ this ; }
5139	public function add ( $ middleware , string $ pathConstraint = null ) : void { if ( is_string ( $ middleware ) ) { $ middleware = $ this -> getContainer ( ) -> get ( $ middleware ) ; } if ( ! $ middleware instanceof MiddlewareInterface ) { throw new InvalidArgumentException ( 'Middleware must be an instance of ' . MiddlewareInterface :: class ) ; } $ this -> middleware [ ] = new Middleware ( $ middleware , $ pathConstraint ) ; }
12380	public static function fromReflectionParam ( ReflectionParameter $ param , ReflectionFunctionAbstract $ func = null , Exception $ previous = null , $ afterMessage = null ) { $ message = static :: makeMessage ( $ param , $ func ) ; if ( $ previous ) { $ message .= ' - ' . $ previous -> getMessage ( ) ; } if ( $ afterMessage ) { $ message .= ' - ' . $ afterMessage ; } return new static ( $ message , 0 , $ previous ) ; }
3565	public function getAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( is_null ( $ value ) ) { $ value = $ this -> getMeta ( $ key ) ; } return $ next ( $ value , $ args ) ; } ; }
5865	protected function reportAdditionalStorageClaimed ( $ bytes ) { $ legacyFileName = PATH_site . 'typo3conf/.tx_imageautoresize' ; $ fileName = PATH_site . 'typo3temp/.tx_imageautoresize' ; if ( file_exists ( $ legacyFileName ) && ! file_exists ( $ fileName ) ) { @ rename ( $ legacyFileName , $ fileName ) ; } $ data = [ ] ; if ( file_exists ( $ fileName ) ) { $ data = json_decode ( file_get_contents ( $ fileName ) , true ) ; if ( ! is_array ( $ data ) ) { $ data = [ ] ; } } $ data [ 'bytes' ] = $ bytes + ( isset ( $ data [ 'bytes' ] ) ? ( int ) $ data [ 'bytes' ] : 0 ) ; $ data [ 'images' ] = 1 + ( isset ( $ data [ 'images' ] ) ? ( int ) $ data [ 'images' ] : 0 ) ; GeneralUtility :: writeFile ( $ fileName , json_encode ( $ data ) ) ; }
10547	public function setResolver ( Resolver $ resolver ) { $ this -> resolver = $ resolver ; $ this -> setVariable ( 'resolver' , $ resolver ) ; return $ this ; }
6887	private function httpGet ( $ path , array $ query = array ( ) ) { $ url = new Uri ( $ this -> baseUrl . $ path ) ; foreach ( $ query as $ name => $ value ) { $ url = Uri :: withQueryValue ( $ url , $ name , $ value ) ; } $ request = new Request ( 'GET' , $ url , $ this -> buildHeaders ( ) ) ; try { $ response = $ this -> getHttpClient ( ) -> sendRequest ( $ request ) ; } catch ( \ RuntimeException $ e ) { throw new Exception \ PostcodeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } if ( $ response -> getStatusCode ( ) != 200 ) { throw $ this -> createErrorException ( $ response ) ; } return $ response ; }
12502	public static function replace ( $ id , $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; $ connection -> method = 'PUT' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; return self :: sendQuery ( $ connection ) ; }
502	public function registerClientScript ( ) { $ id = $ this -> grid -> options [ 'id' ] ; $ options = Json :: encode ( [ 'name' => $ this -> name , 'class' => $ this -> cssClass , 'multiple' => $ this -> multiple , 'checkAll' => $ this -> grid -> showHeader ? $ this -> getHeaderCheckBoxName ( ) : null , ] ) ; $ this -> grid -> getView ( ) -> registerJs ( "jQuery('#$id').yiiGridView('setSelectionColumn', $options);" ) ; }
12726	public function getContent ( array $ contentData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ contentData ) ) { throw new ContentException ( "The field '$mandatoryField' is missing in the given content data" ) ; } } try { $ title = "" ; if ( isset ( $ contentData [ self :: FIELD_TITLE ] ) ) { $ title = $ contentData [ self :: FIELD_TITLE ] ; } $ summary = "" ; if ( isset ( $ contentData [ self :: FIELD_SUMMARY ] ) ) { $ summary = $ contentData [ self :: FIELD_SUMMARY ] ; } $ description = "" ; if ( isset ( $ contentData [ self :: FIELD_DESCRIPTION ] ) ) { $ description = $ contentData [ self :: FIELD_DESCRIPTION ] ; } $ content = new Content ( $ title , $ summary , $ description ) ; return $ content ; } catch ( \ Exception $ contentException ) { throw new ContentException ( sprintf ( "Failed to create a content model from the given data: %s" , $ contentException -> getMessage ( ) ) , $ contentException ) ; } }
4744	public function isReviewOptInError ( ) { $ formSent = \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getRequestParameter ( 'rvw_oegdproptin' ) !== null ; $ review = oxNew ( \ OxidEsales \ Eshop \ Application \ Controller \ ReviewController :: class ) ; $ result = false ; if ( $ formSent && ! $ review -> validateOptIn ( ) ) { $ result = true ; } return $ result ; }
12250	public function getAttribute ( $ strName , $ varDefault = false ) { if ( isset ( $ this -> attributes ( ) -> $ strName ) && ( ( ( string ) $ this -> attributes ( ) -> $ strName ) !== '' ) ) { return ( string ) $ this -> attributes ( ) -> $ strName ; } else { return $ varDefault ; } }
2027	public static function findPublishedRegularWithoutGuestsByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( empty ( $ arrOptions [ 'includeRoot' ] ) ) { $ arrColumns [ ] = "$t.type!='root'" ; } if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
6557	protected function mapLogLevelToStyle ( $ logLevel ) { if ( isset ( $ this -> logLevelStyleMapping [ $ logLevel ] ) ) { return $ this -> logLevelStyleMapping [ $ logLevel ] ; } return Simple :: DEFAULT_STYLE ; }
1320	private function curlOptions ( ) { $ options = [ CURLOPT_CONNECTTIMEOUT => $ this -> connectionTimeout , CURLOPT_HEADER => true , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYHOST => 2 , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_TIMEOUT => $ this -> timeout , CURLOPT_USERAGENT => $ this -> userAgent , ] ; if ( $ this -> useCAFile ( ) ) { $ options [ CURLOPT_CAINFO ] = __DIR__ . DIRECTORY_SEPARATOR . 'cacert.pem' ; } if ( $ this -> gzipEncoding ) { $ options [ CURLOPT_ENCODING ] = 'gzip' ; } if ( ! empty ( $ this -> proxy ) ) { $ options [ CURLOPT_PROXY ] = $ this -> proxy [ 'CURLOPT_PROXY' ] ; $ options [ CURLOPT_PROXYUSERPWD ] = $ this -> proxy [ 'CURLOPT_PROXYUSERPWD' ] ; $ options [ CURLOPT_PROXYPORT ] = $ this -> proxy [ 'CURLOPT_PROXYPORT' ] ; $ options [ CURLOPT_PROXYAUTH ] = CURLAUTH_BASIC ; $ options [ CURLOPT_PROXYTYPE ] = CURLPROXY_HTTP ; } return $ options ; }
11209	public function login ( $ subject ) { $ caller = $ this -> identifier -> identify ( $ subject ) ; if ( $ this -> authenticator -> authenticate ( $ subject , $ caller ) ) { $ this -> driver -> setLoginToken ( $ caller -> getLoginToken ( ) ) ; $ this -> currentCaller = $ caller ; return true ; } return false ; }
6836	private function isIdentityValid ( SaleInterface $ cart ) { return 0 < strlen ( $ cart -> getEmail ( ) ) && 0 < strlen ( $ cart -> getGender ( ) ) && 0 < strlen ( $ cart -> getFirstName ( ) ) && 0 < strlen ( $ cart -> getLastName ( ) ) ; }
11849	protected function getSettingsFromRealSource ( $ namespace ) { $ arraySettings = $ this -> getSettingsArray ( $ namespace ) ; $ namespaceOptions = $ this -> options -> getNamespaceOptions ( $ namespace ) ; $ entity = clone ( $ namespaceOptions -> getEntityPrototype ( ) ) ; if ( ! empty ( $ arraySettings ) ) { $ hydrator = $ this -> namespaceHydratorProvider -> getHydrator ( $ namespace ) ; $ entity = $ hydrator -> hydrate ( $ arraySettings , $ entity ) ; } return $ entity ; }
4021	protected function validator ( $ varInput ) { $ blnHasError = false ; foreach ( $ this -> arrSubFields as $ strFieldName => & $ arrSubField ) { if ( ! $ this -> validateWidget ( $ arrSubField , $ strFieldName , 'value' , $ varInput ) ) { $ blnHasError = true ; } foreach ( $ this -> arrFlagFields as $ strFlag => $ arrFlagField ) { if ( ! $ this -> validateWidget ( $ arrFlagField , $ strFieldName , $ strFlag , $ varInput ) ) { $ blnHasError = true ; } } } unset ( $ arrSubField ) ; if ( $ blnHasError ) { $ this -> blnSubmitInput = false ; $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'general' ] ) ; } return $ varInput ; }
5632	protected function removeTrailingSlash ( $ path ) { if ( substr ( $ path , - 1 ) == DIRECTORY_SEPARATOR ) { return substr ( $ path , 0 , - 1 ) ; } elseif ( substr ( $ path , - 1 ) == '/' ) { return substr ( $ path , 0 , - 1 ) ; } else { return $ path ; } }
11481	public function save ( BlockManagerApprover $ approver , array $ options , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ filesystem = new Filesystem ( ) ; $ pageDir = $ this -> pagesDir . '/' . $ options [ "page" ] ; $ filesystem -> copy ( $ pageDir . '/' . $ this -> pageFile , $ pageDir . '/page.json' , true ) ; $ pageDir .= '/' . $ options [ "language" ] . '_' . $ options [ "country" ] ; if ( $ this -> seoFile != "seo.json" ) { $ sourceFile = $ pageDir . '/' . $ this -> seoFile ; $ values = json_decode ( file_get_contents ( $ sourceFile ) , true ) ; if ( array_key_exists ( "current_permalink" , $ values ) ) { $ values [ "changed_permalinks" ] [ ] = $ values [ "current_permalink" ] ; unset ( $ values [ "current_permalink" ] ) ; file_put_contents ( $ sourceFile , json_encode ( $ values ) ) ; } $ filesystem -> copy ( $ sourceFile , $ pageDir . '/seo.json' , true ) ; } $ approvedBlocks = $ this -> saveBlocks ( $ approver , $ pageDir , $ options ) ; if ( $ saveCommonSlots ) { $ slotsDir = $ this -> baseDir . '/slots' ; $ approvedCommonBlocks = $ this -> saveBlocks ( $ approver , $ slotsDir , $ options ) ; $ approvedBlocks = array_merge ( $ approvedBlocks , $ approvedCommonBlocks ) ; } Dispatcher :: dispatch ( PageEvents :: PAGE_SAVED , new PageSavedEvent ( $ pageDir , null , $ approvedBlocks ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully saved in production' , $ options [ "page" ] ) ) ; }
3265	protected function preserveLines ( $ data , bool $ reverse ) { $ search = [ "\n" , "\r" ] ; $ replace = [ '\\n' , '\\r' ] ; if ( $ reverse ) { $ search = [ '\\n' , '\\r' ] ; $ replace = [ "\n" , "\r" ] ; } if ( is_string ( $ data ) ) { $ data = str_replace ( $ search , $ replace , $ data ) ; } elseif ( is_array ( $ data ) ) { foreach ( $ data as & $ value ) { $ value = $ this -> preserveLines ( $ value , $ reverse ) ; } unset ( $ value ) ; } return $ data ; }
4345	public function getCfgLazy ( $ name ) { if ( ! isset ( $ this -> cfgLazy [ $ name ] ) ) { return array ( ) ; } $ return = $ this -> cfgLazy [ $ name ] ; unset ( $ this -> cfgLazy [ $ name ] ) ; return $ return ; }
1716	public function isAllowed ( $ int , $ row ) { if ( $ this -> isAdmin ) { return true ; } if ( ! $ row [ 'includeChmod' ] ) { $ pid = $ row [ 'pid' ] ; $ row [ 'chmod' ] = false ; $ row [ 'cuser' ] = false ; $ row [ 'cgroup' ] = false ; $ objParentPage = PageModel :: findById ( $ pid ) ; while ( $ objParentPage !== null && $ row [ 'chmod' ] === false && $ pid > 0 ) { $ pid = $ objParentPage -> pid ; $ row [ 'chmod' ] = $ objParentPage -> includeChmod ? $ objParentPage -> chmod : false ; $ row [ 'cuser' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cuser : false ; $ row [ 'cgroup' ] = $ objParentPage -> includeChmod ? $ objParentPage -> cgroup : false ; $ objParentPage = PageModel :: findById ( $ pid ) ; } if ( $ row [ 'chmod' ] === false ) { $ row [ 'chmod' ] = Config :: get ( 'defaultChmod' ) ; } if ( $ row [ 'cuser' ] === false ) { $ row [ 'cuser' ] = ( int ) Config :: get ( 'defaultUser' ) ; } if ( $ row [ 'cgroup' ] === false ) { $ row [ 'cgroup' ] = ( int ) Config :: get ( 'defaultGroup' ) ; } } $ chmod = StringUtil :: deserialize ( $ row [ 'chmod' ] ) ; $ chmod = \ is_array ( $ chmod ) ? $ chmod : array ( $ chmod ) ; $ permission = array ( 'w' . $ int ) ; if ( \ in_array ( $ row [ 'cgroup' ] , $ this -> groups ) ) { $ permission [ ] = 'g' . $ int ; } if ( $ row [ 'cuser' ] == $ this -> id ) { $ permission [ ] = 'u' . $ int ; } return \ count ( array_intersect ( $ permission , $ chmod ) ) > 0 ; }
8572	private function _convertListRecommendations ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListRecommendations' ; if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetRecommendationCategory ( ) ) { $ parameters [ 'RecommendationCategory' ] = $ request -> getRecommendationCategory ( ) ; } if ( $ request -> isSetCategoryQueryList ( ) ) { $ parameters [ 'CategoryQueryList' ] = $ request -> getCategoryQueryList ( ) ; } return $ parameters ; }
10774	protected function loginByCookie ( ) { $ value = Yii :: $ app -> getRequest ( ) -> getCookies ( ) -> getValue ( $ this -> identityCookie [ 'name' ] ) ; if ( $ value === null ) { return ; } $ data = json_decode ( $ value , true ) ; if ( count ( $ data ) !== 3 || ! isset ( $ data [ 0 ] , $ data [ 1 ] , $ data [ 2 ] ) ) { return ; } list ( $ id , $ authKey , $ duration ) = $ data ; $ class = $ this -> identityClass ; $ identity = $ class :: findIdentity ( $ id ) ; if ( $ identity === null ) { return ; } elseif ( ! $ identity instanceof IdentityInterface ) { throw new InvalidValueException ( "$class::findIdentity() must return an object implementing IdentityInterface." ) ; } if ( $ identity -> validateAuthKey ( $ authKey ) ) { if ( $ this -> beforeLogin ( $ identity , true , $ duration ) ) { $ this -> switchIdentity ( $ identity , $ this -> autoRenewCookie ? $ duration : 0 ) ; $ ip = Yii :: $ app -> getRequest ( ) -> getUserIP ( ) ; Yii :: info ( "User '$id' logged in from $ip via cookie." , __METHOD__ ) ; $ this -> afterLogin ( $ identity , true , $ duration ) ; } } else { Yii :: warning ( "Invalid auth key attempted for user '$id': $authKey" , __METHOD__ ) ; } }
10751	public function init ( UserEntity $ user , ServiceManager $ sm ) { $ main = $ sm -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ this -> hashId = $ userRepository -> getEncryptedId ( $ user -> getUserId ( ) ) ; $ this -> name = $ user -> getName ( ) ; $ this -> surname = $ user -> getSurname ( ) ; $ this -> email = $ user -> getEmail ( ) ; $ this -> gender = $ user -> getGender ( ) ; $ this -> dateBorn = $ this -> getDateBorn ( $ user , $ sm ) ; $ this -> nicename = $ user -> getNicename ( ) ; $ this -> mobile = $ this -> getMobile ( $ user ) ; $ this -> isAdmin = 'god' == $ user -> getRole ( ) ; $ this -> fullname = $ this -> getFullname ( $ user ) ; $ this -> role = $ user -> getRole ( ) ; $ this -> state = $ user -> getState ( ) ; $ this -> stateFormatted = $ this -> getStateFormatted ( $ user ) ; $ this -> editAddress = '/#/edituseerrr' ; $ this -> isActive = $ user -> getState ( ) == UserEntity :: USER_STATE_ACTIVE ; $ this -> isDeactive = $ user -> getState ( ) == UserEntity :: USER_STATE_DEACTIVE ; $ this -> isDeleted = $ user -> getState ( ) == UserEntity :: USER_STATE_DELETED ; $ this -> isBanned = $ user -> getState ( ) == UserEntity :: USER_STATE_BANNED ; $ this -> count = 'disabled' ; return $ this ; }
2697	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ activateVcl = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ service = $ this -> api -> checkServiceDetails ( ) ; $ enabled = false ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ vclPath = Config :: VCL_AUTH_SNIPPET_PATH ; $ snippets = $ this -> config -> getVclSnippets ( $ vclPath ) ; $ status = true ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> getSnippet ( $ activeVersion , $ name ) ; if ( ! $ status ) { break ; } } if ( ! $ status ) { $ this -> api -> checkAuthDictionaryPopulation ( $ activeVersion ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ snippetData = [ 'name' => Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key , 'type' => $ key , 'dynamic' => "0" , 'content' => $ value , 'priority' => 10 ] ; $ this -> api -> uploadSnippet ( $ clone -> number , $ snippetData ) ; } $ enabled = true ; } else { $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ this -> api -> removeSnippet ( $ clone -> number , $ name ) ; } } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activateVcl === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } $ this -> sendWebhook ( $ enabled , $ clone ) ; $ comment = [ 'comment' => 'Magento Module turned ON Basic Authentication' ] ; if ( ! $ enabled ) { $ comment = [ 'comment' => 'Magento Module turned OFF Basic Authentication' ] ; } $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
5171	private function getAvailableRatios ( ) : array { return [ self :: RATIO_SQUARE , self :: RATIO_RECTANGLE , self :: RATIO_HEADLINE , self :: RATIO_VERTICAL , self :: RATIO_COVER , ] ; }
12900	public function offsetGet ( $ offset ) { if ( $ offset === 'headers' ) { $ headers = [ 'HTTP/' . $ this -> getResponse ( ) -> getProtocolVersion ( ) . ' ' . $ this -> getResponse ( ) -> getStatusCode ( ) . ' ' . $ this -> getResponse ( ) -> getReasonPhrase ( ) ] ; foreach ( $ this -> getResponse ( ) -> getHeaders ( ) as $ header => $ values ) { foreach ( $ values as $ value ) { $ headers [ ] = $ header . ': ' . $ value ; } } return $ headers ; } }
3960	public function parseAttribute ( $ strAttributeName , $ strOutputFormat = 'text' , $ objSettings = null ) { return $ this -> internalParseAttribute ( $ this -> getAttribute ( $ strAttributeName ) , $ strOutputFormat , $ objSettings ) ; }
347	public static function removeCssClass ( & $ options , $ class ) { if ( isset ( $ options [ 'class' ] ) ) { if ( is_array ( $ options [ 'class' ] ) ) { $ classes = array_diff ( $ options [ 'class' ] , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = $ classes ; } } else { $ classes = preg_split ( '/\s+/' , $ options [ 'class' ] , - 1 , PREG_SPLIT_NO_EMPTY ) ; $ classes = array_diff ( $ classes , ( array ) $ class ) ; if ( empty ( $ classes ) ) { unset ( $ options [ 'class' ] ) ; } else { $ options [ 'class' ] = implode ( ' ' , $ classes ) ; } } } }
756	protected function renderImage ( $ code ) { if ( isset ( $ this -> imageLibrary ) ) { $ imageLibrary = $ this -> imageLibrary ; } else { $ imageLibrary = Captcha :: checkRequirements ( ) ; } if ( $ imageLibrary === 'gd' ) { return $ this -> renderImageByGD ( $ code ) ; } elseif ( $ imageLibrary === 'imagick' ) { return $ this -> renderImageByImagick ( $ code ) ; } throw new InvalidConfigException ( "Defined library '{$imageLibrary}' is not supported" ) ; }
2736	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ countries = $ this -> countryHelper -> toOptionArray ( ) ; if ( ! $ countries ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Could not fetch list countries.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'countries' => $ countries ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
8699	private function factoryElement ( $ type ) { switch ( $ type ) { case \ SVGCreator \ Element :: CIRCLE : return new \ SVGCreator \ Elements \ Circle ( ) ; break ; case \ SVGCreator \ Element :: DEFS : return new \ SVGCreator \ Elements \ Defs ( ) ; break ; case \ SVGCreator \ Element :: GROUP : return new \ SVGCreator \ Elements \ Group ( ) ; break ; case \ SVGCreator \ Element :: LINE : return new \ SVGCreator \ Elements \ Line ( ) ; break ; case \ SVGCreator \ Element :: MARKER : return new \ SVGCreator \ Elements \ Marker ( ) ; break ; case \ SVGCreator \ Element :: PATH : return new \ SVGCreator \ Elements \ Path ( ) ; break ; case \ SVGCreator \ Element :: RECT : return new \ SVGCreator \ Elements \ Rect ( ) ; break ; case \ SVGCreator \ Element :: SVG : return new \ SVGCreator \ Elements \ Svg ( ) ; break ; case \ SVGCreator \ Element :: TEXT : return new \ SVGCreator \ Elements \ Text ( ) ; break ; case \ SVGCreator \ Element :: POLYGON : return new \ SVGCreator \ Elements \ Polygon ( ) ; break ; default : throw new \ SVGCreator \ SVGException ( "The tag " . $ type . " is not implemented yet" , 1 ) ; break ; } }
228	public function getTableNames ( $ schema = '' , $ refresh = false ) { if ( ! isset ( $ this -> _tableNames [ $ schema ] ) || $ refresh ) { $ this -> _tableNames [ $ schema ] = $ this -> findTableNames ( $ schema ) ; } return $ this -> _tableNames [ $ schema ] ; }
985	public function getCharge ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not get charge information without charge ID.' ) ; } return $ this -> api -> rest ( 'GET' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; }
8834	private function getObserver ( ) : ProcessObserverInterface { if ( 1 === count ( $ this -> observerList ) ) { $ observer = $ this -> observerList [ 0 ] ; } elseif ( count ( $ this -> observerList ) ) { $ observer = new AggregateLogger ( $ this -> observerList ) ; } else { $ observer = new NullProcessObserver ( ) ; } return $ observer ; }
1482	public function encoder ( $ options = 0 , $ depth = 512 ) { if ( $ options instanceof Encoding ) { $ options = $ options -> getOptions ( ) ; } if ( ! $ options instanceof EncoderOptions ) { $ options = new EncoderOptions ( $ options , $ this -> getUrl ( ) -> toString ( ) , $ depth ) ; } return $ this -> factory -> createEncoder ( $ this -> getContainer ( ) , $ options ) ; }
3759	public function buildWidget ( BuildWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) -> getName ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; Helper :: prepareLanguageAwareWidget ( $ event -> getEnvironment ( ) , $ event -> getProperty ( ) , $ metaModel , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_langcode' , [ ] , 'contao_tl_metamodel_attribute' ) , $ this -> translator -> trans ( 'tl_metamodel_attribute.name_value' , [ ] , 'contao_tl_metamodel_attribute' ) , false , StringUtil :: deserialize ( $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) -> getName ( ) ) , true ) ) ; }
11148	public function getMultipleDisplayObjects ( $ areas ) { $ out = array ( ) ; foreach ( $ areas as $ v ) { if ( ! ( $ v instanceof Neuron_GameServer_Map_Area ) ) { throw new Neuron_Exceptions_InvalidParameter ( "Parameters must be an array of area objects." ) ; } foreach ( $ this -> getDisplayObjects ( $ v ) as $ v ) { if ( ! $ v instanceof Neuron_GameServer_Map_MapObject ) { throw new Neuron_Core_Error ( "All map objects MUST implement Neuron_GameServer_Map_MapObject" ) ; } $ out [ ] = $ v ; } } return $ out ; }
9863	private function writeCols ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getColumnDimensions ( ) ) > 0 ) { $ objWriter -> startElement ( 'cols' ) ; $ pSheet -> calculateColumnWidths ( ) ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ colDimension ) { $ objWriter -> startElement ( 'col' ) ; $ objWriter -> writeAttribute ( 'min' , Coordinate :: columnIndexFromString ( $ colDimension -> getColumnIndex ( ) ) ) ; $ objWriter -> writeAttribute ( 'max' , Coordinate :: columnIndexFromString ( $ colDimension -> getColumnIndex ( ) ) ) ; if ( $ colDimension -> getWidth ( ) < 0 ) { $ objWriter -> writeAttribute ( 'width' , '9.10' ) ; } else { $ objWriter -> writeAttribute ( 'width' , StringHelper :: formatNumber ( $ colDimension -> getWidth ( ) ) ) ; } if ( $ colDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ colDimension -> getAutoSize ( ) ) { $ objWriter -> writeAttribute ( 'bestFit' , 'true' ) ; } if ( $ colDimension -> getWidth ( ) != $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) { $ objWriter -> writeAttribute ( 'customWidth' , 'true' ) ; } if ( $ colDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ colDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ colDimension -> getOutlineLevel ( ) ) ; } $ objWriter -> writeAttribute ( 'style' , $ colDimension -> getXfIndex ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
2163	public function run40Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `scripts` text NULL" ) ; $ objLayout = $ this -> Database -> query ( "SELECT id, addJQuery, jquery, addMooTools, mootools FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrScripts = array ( ) ; if ( $ objLayout -> addJQuery ) { $ jquery = StringUtil :: deserialize ( $ objLayout -> jquery ) ; if ( ! empty ( $ jquery ) && \ is_array ( $ jquery ) ) { if ( ( $ key = array_search ( 'j_slider' , $ jquery ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ jquery [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET jquery=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ jquery ) ) , $ objLayout -> id ) ; } } } if ( $ objLayout -> addMooTools ) { $ mootools = StringUtil :: deserialize ( $ objLayout -> mootools ) ; if ( ! empty ( $ mootools ) && \ is_array ( $ mootools ) ) { if ( ( $ key = array_search ( 'moo_slider' , $ mootools ) ) !== false ) { $ arrScripts [ ] = 'js_slider' ; unset ( $ mootools [ $ key ] ) ; $ this -> Database -> prepare ( "UPDATE tl_layout SET mootools=? WHERE id=?" ) -> execute ( serialize ( array_values ( $ mootools ) ) , $ objLayout -> id ) ; } } } if ( ! empty ( $ arrScripts ) ) { $ this -> Database -> prepare ( "UPDATE tl_layout SET scripts=? WHERE id=?" ) -> execute ( serialize ( array_values ( array_unique ( $ arrScripts ) ) ) , $ objLayout -> id ) ; } } }
2807	public function purgeProfilesAction ( ) { $ count = $ this -> getService ( ) -> purgeAllProfiles ( ) ; $ this -> getSession ( ) -> addSuccess ( $ this -> __ ( '%d request profiles were deleted' , $ count ) ) ; $ this -> _redirect ( '/' ) ; }
12750	public function getUserAlias4User ( UserInterface $ user ) { if ( ! isset ( $ this -> userAliasCache [ $ user -> getUsername ( ) ] ) ) { $ userAliasEntityTmp = $ this -> getUserAliasEntity4User ( $ user ) ; if ( ! $ userAliasEntityTmp ) { $ userAliasEntityTmp = false ; } $ this -> userAliasCache [ $ user -> getUsername ( ) ] = $ userAliasEntityTmp ; } $ userAliasEntity = $ this -> userAliasCache [ $ user -> getUsername ( ) ] ; if ( $ userAliasEntity ) { $ result = $ userAliasEntity -> getCharName ( ) ; } else { $ result = $ user -> getUsername ( ) ; } return $ result ; }
5203	public function close ( ) { if ( isset ( $ this -> channel ) ) $ this -> channel -> close ( ) ; if ( isset ( $ this -> AMQPConnection ) ) $ this -> AMQPConnection -> close ( ) ; }
9011	public function tinytext ( string $ charset = null ) : self { $ this -> type = 'tinytext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
5338	public function buildSoapClient ( $ service ) { $ director = new Soap \ SoapClientDirector ( $ this -> username , $ this -> mode , $ this -> endpoint ) ; switch ( $ service ) { case 'DomainService' : return $ director -> build ( new Soap \ Builder \ DomainSoapClientBuilder ) ; case 'ColocationService' : return $ director -> build ( new Soap \ Builder \ ColocationSoapClientBuilder ) ; case 'ForwardService' : return $ director -> build ( new Soap \ Builder \ ForwardSoapClientBuilder ) ; case 'VpsService' : return $ director -> build ( new Soap \ Builder \ VpsSoapClientBuilder ) ; case 'WebhostingService' : return $ director -> build ( new Soap \ Builder \ WebHostingSoapClientBuilder ) ; case 'HaipService' : return $ director -> build ( new Soap \ Builder \ HaipSoapClientBuilder ) ; default : throw new \ InvalidArgumentException ( sprintf ( 'Undefined soap client service builder called: [%s]' , $ service ) ) ; } }
2515	public function pnrRetrieve ( RequestOptions \ PnrRetrieveOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_Retrieve' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
5363	public function generate ( Registry $ registry ) { $ context = $ this -> createContext ( $ registry , 'Client' ) ; $ files = [ ] ; foreach ( $ registry -> getSchemas ( ) as $ schema ) { $ context -> setCurrentSchema ( $ schema ) ; $ files = array_merge ( $ files , $ this -> modelGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ files = array_merge ( $ files , $ this -> normalizerGenerator -> generate ( $ schema , $ schema -> getRootName ( ) , $ context ) ) ; $ clients = $ this -> clientGenerator -> generate ( $ schema -> getParsed ( ) , $ schema -> getNamespace ( ) , $ context , $ schema -> getOrigin ( ) . '#' ) ; foreach ( $ clients as $ node ) { $ files [ ] = new File ( $ schema -> getDirectory ( ) . DIRECTORY_SEPARATOR . 'Resource' . DIRECTORY_SEPARATOR . $ node -> stmts [ 2 ] -> name . '.php' , $ node , '' ) ; } } return $ files ; }
3877	public function build ( ) { if ( ! $ this -> isEmpty ( ) ) { return new SimpleQuery ( sprintf ( 'SELECT id FROM %s WHERE %s' , $ this -> tableName , $ this -> getProcedure ( ) ) , $ this -> getParameters ( ) , 'id' , $ this -> connection ) ; } return null ; }
252	public function removeAllFlashes ( ) { $ counters = $ this -> get ( $ this -> flashParam , [ ] ) ; foreach ( array_keys ( $ counters ) as $ key ) { unset ( $ _SESSION [ $ key ] ) ; } unset ( $ _SESSION [ $ this -> flashParam ] ) ; }
911	public function addBlank ( ) { $ matched = Preg :: match ( '/^([ \t]*\*)[^\r\n]*(\r?\n)$/' , $ this -> content , $ matches ) ; if ( 1 !== $ matched ) { return ; } $ this -> content .= $ matches [ 1 ] . $ matches [ 2 ] ; }
1988	public static function getRootPageFromUrl ( ) { $ host = Environment :: get ( 'host' ) ; $ logger = System :: getContainer ( ) -> get ( 'monolog.logger.contao' ) ; $ accept_language = Environment :: get ( 'httpAcceptLanguage' ) ; if ( ! empty ( $ _GET [ 'language' ] ) && Config :: get ( 'addLanguageToUrl' ) ) { $ strUri = Environment :: get ( 'url' ) . '/' . Input :: get ( 'language' ) . '/' ; $ strError = 'No root page found (host "' . $ host . '", language "' . Input :: get ( 'language' ) . '")' ; } else { if ( Config :: get ( 'addLanguageToUrl' ) && Config :: get ( 'doNotRedirectEmpty' ) ) { $ accept_language = '-' ; } $ strUri = Environment :: get ( 'url' ) . '/' ; $ strError = 'No root page found (host "' . Environment :: get ( 'host' ) . '", languages "' . implode ( ', ' , Environment :: get ( 'httpAcceptLanguage' ) ) . '")' ; } try { $ objRequest = Request :: create ( $ strUri ) ; $ objRequest -> headers -> set ( 'Accept-Language' , $ accept_language ) ; $ arrParameters = System :: getContainer ( ) -> get ( 'contao.routing.nested_matcher' ) -> matchRequest ( $ objRequest ) ; $ objRootPage = $ arrParameters [ 'pageModel' ] ?? null ; if ( ! $ objRootPage instanceof PageModel ) { throw new MissingMandatoryParametersException ( 'Every Contao route must have a "pageModel" parameter' ) ; } } catch ( RoutingExceptionInterface $ exception ) { $ logger -> log ( LogLevel :: ERROR , $ strError , array ( 'contao' => new ContaoContext ( __METHOD__ , 'ERROR' ) ) ) ; throw new NoRootPageFoundException ( 'No root page found' , 0 , $ exception ) ; } if ( Environment :: get ( 'relativeRequest' ) == '' ) { if ( Config :: get ( 'addLanguageToUrl' ) && ! Config :: get ( 'doNotRedirectEmpty' ) ) { $ arrParams = array ( '_locale' => $ objRootPage -> language ) ; $ strUrl = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_index' , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; static :: redirect ( $ strUrl , 301 ) ; } elseif ( $ objRootPage -> type !== 'root' && ! \ in_array ( $ objRootPage -> alias , array ( 'index' , '/' ) ) ) { static :: redirect ( $ objRootPage -> getAbsoluteUrl ( ) , 302 ) ; } } if ( $ objRootPage -> type != 'root' ) { return PageModel :: findByPk ( $ objRootPage -> rootId ) ; } return $ objRootPage ; }
7408	public function merge ( $ ta ) : self { $ this -> _massageBlockInput ( $ in ) ; $ ret = clone $ this ; foreach ( $ ta as $ k => $ v ) { if ( is_int ( $ k ) ) { $ ret [ ] = $ v ; } else { $ ret [ $ k ] = $ v ; } } return $ ret ; }
8219	protected function getIp ( $ config ) { $ remoteAddr = $ _SERVER [ 'REMOTE_ADDR' ] ; if ( filter_var ( $ remoteAddr , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) ) { $ netmask = ( isset ( $ config [ "netmask_IPv4" ] ) ) ? $ config [ "netmask_IPv4" ] : self :: DEFAULT_NETMASK_IPV4 ; } else { $ netmask = ( isset ( $ config [ "netmask_IPv6" ] ) ) ? $ config [ "netmask_IPv6" ] : self :: DEFAULT_NETMASK_IPV6 ; } $ ipSubnet = $ this -> getSubnet ( $ remoteAddr , $ netmask ) ; return $ ipSubnet ; }
1803	protected function getPickerInputField ( $ value , $ attributes = '' ) { $ id = is_numeric ( $ value ) ? $ value : md5 ( $ value ) ; switch ( $ this -> strPickerFieldType ) { case 'checkbox' : return ' <input type="checkbox" name="picker[]" id="picker_' . $ id . '" class="tl_tree_checkbox" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; case 'radio' : return ' <input type="radio" name="picker" id="picker_' . $ id . '" class="tl_tree_radio" value="' . StringUtil :: specialchars ( \ call_user_func ( $ this -> objPickerCallback , $ value ) ) . '" onfocus="Backend.getScrollOffset()"' . Widget :: optionChecked ( $ value , $ this -> arrPickerValue ) . $ attributes . '>' ; } return '' ; }
3466	public function put ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: put ( $ route ) ) ; }
9150	public function fetchAll ( $ columns = null , \ Closure $ Closure = null ) { $ select = $ this -> getSelect ( ) ; if ( $ columns ) { $ select -> columns ( $ columns ) ; } if ( $ Closure ) { $ Closure ( $ select ) ; } return $ this -> select ( $ select ) ; }
5156	private function getFilename ( string $ name ) : string { return sprintf ( "%s/%s.%s" , $ this -> directory , strtolower ( str_replace ( [ '/' , '\\' ] , '-' , $ name ) ) , self :: EXTENSION ) ; }
10804	public function getBackOfficeUsersAction ( ) { $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ users = $ melisPageHistoricTable -> getUsers ( ) -> toArray ( ) ; return new JsonModel ( array ( 'users' => $ users , ) ) ; }
12443	public function add ( InvokerInterface $ invoker , $ taskArgs = [ ] ) { $ taskArgs = ( is_array ( $ taskArgs ) ? $ taskArgs : array_slice ( func_get_args ( ) , 1 ) ) ; array_unshift ( $ this -> tasks , compact ( 'invoker' , 'taskArgs' ) ) ; return $ this ; }
7100	private function equalComparison ( UnitCandidate $ a , UnitCandidate $ b , $ property , $ quantity ) { if ( $ a -> { $ property } == $ quantity && $ b -> { $ property } != $ quantity ) { return - 1 ; } if ( $ a -> { $ property } != $ quantity && $ b -> { $ property } == $ quantity ) { return 1 ; } return false ; }
12546	public function once ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> once ( $ event , $ callback , $ priority ) ; }
12853	public function import ( Package $ package , $ id = null ) { $ id = is_null ( $ id ) ? $ package -> id : $ id ; $ this -> symbols = array_merge ( $ package -> symbols , $ this -> symbols ) ; $ this -> macros = array_merge ( $ package -> macros , $ this -> macros ) ; $ this -> packages [ $ id ] = $ package ; }
5051	public function triggerUntil ( callable $ callback , $ eventName , $ target = null , $ argv = [ ] ) { $ event = $ eventName instanceof EventInterface ? $ eventName : $ this -> getEvent ( $ eventName , $ target , $ argv ) ; return $ this -> triggerListeners ( $ event , $ callback ) ; }
8594	public function listOrdersByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrdersByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6604	public function makeAccessToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateAccessTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'user_id' ] = $ params [ 'user_id' ] ; $ this -> credentials [ 'screen_name' ] = $ params [ 'screen_name' ] ; return $ this ; }
5071	protected function traverseHeaderTags ( \ DOMDocument $ domDocument , $ topLevel , $ depth ) { $ xpath = new \ DOMXPath ( $ domDocument ) ; $ xpathQuery = sprintf ( "//*[%s]" , implode ( ' or ' , array_map ( function ( $ v ) { return sprintf ( 'local-name() = "%s"' , $ v ) ; } , $ this -> determineHeaderTags ( $ topLevel , $ depth ) ) ) ) ; $ nodes = [ ] ; foreach ( $ xpath -> query ( $ xpathQuery ) as $ node ) { $ nodes [ ] = $ node ; } return new \ ArrayIterator ( $ nodes ) ; }
8361	public static function init ( RawRequest $ request = null ) { if ( self :: $ isInit === false ) { self :: $ translations = array ( ) ; $ settings = Config :: getSettings ( ) ; if ( isset ( $ settings [ 'locale' ] ) === false || isset ( $ settings [ 'locale' ] [ 'default' ] ) === false ) { throw new BadUse ( 'locale.default isn\'t defined in settings' ) ; } self :: $ currentLanguage = $ settings [ 'locale' ] [ 'default' ] ; if ( $ request != null ) { if ( Session :: has ( '_stray_language' ) === true ) { self :: $ currentLanguage = Session :: get ( '_stray_language' ) ; } else { $ domain = HttpHelper :: extractDomain ( $ request ) ; if ( isset ( $ settings [ 'locale' ] [ 'hosts' ] ) === true && isset ( $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ) === true ) { self :: $ currentLanguage = $ settings [ 'locale' ] [ 'hosts' ] [ $ domain ] ; } Session :: set ( '_stray_language' , self :: $ currentLanguage ) ; } } self :: $ isInit = true ; } }
2472	public function findSingle ( Criterion $ filter , array $ languageFilter = array ( ) ) { $ query = new Query ( ) ; $ query -> filter = $ filter ; $ query -> query = new Criterion \ MatchAll ( ) ; $ query -> offset = 0 ; $ query -> limit = 1 ; $ this -> coreFilter -> apply ( $ query , $ languageFilter , DocumentMapper :: DOCUMENT_TYPE_IDENTIFIER_CONTENT ) ; $ result = $ this -> resultExtractor -> extract ( $ this -> gateway -> findContent ( $ query , $ languageFilter ) ) ; if ( ! $ result -> totalCount ) { throw new NotFoundException ( 'Content' , 'findSingle() found no content for given $filter' ) ; } elseif ( $ result -> totalCount > 1 ) { throw new InvalidArgumentException ( 'totalCount' , 'findSingle() found more then one item for given $filter' ) ; } $ first = reset ( $ result -> searchHits ) ; return $ first -> valueObject ; }
2438	public function appendData ( $ varData ) { if ( \ is_object ( $ varData ) ) { $ varData = get_object_vars ( $ varData ) ; } if ( ! \ is_array ( $ varData ) ) { throw new \ Exception ( 'Array or object required to append session data' ) ; } foreach ( $ varData as $ k => $ v ) { if ( \ in_array ( $ k , $ this -> mappedKeys ) ) { $ this -> session -> set ( $ k , $ v ) ; } else { $ this -> sessionBag -> set ( $ k , $ v ) ; } } }
4919	public function attachInputFilterDefaults ( InputFilterInterface $ inputFilter , FieldsetInterface $ fieldset ) { parent :: attachInputFilterDefaults ( $ inputFilter , $ fieldset ) ; foreach ( $ inputFilter -> getInputs ( ) as $ name => $ input ) { if ( ! $ input instanceof InputFilterInterface ) { $ required = $ input -> isRequired ( ) ; $ inputExists = $ fieldset -> has ( $ name ) ; if ( ! $ inputExists && $ required ) { $ fieldsetName = '' ; if ( $ fieldset -> hasAttribute ( 'name' ) ) { $ fieldsetName = 'in Fieldset "' . $ fieldset -> getAttribute ( 'name' ) . '" ' ; } throw new \ RuntimeException ( 'input for "' . $ name . '" ' . $ fieldsetName . 'is required but a input-field with this name is not defined' ) ; } } } }
275	protected function renderDataCellContent ( $ model , $ key , $ index ) { if ( $ this -> content !== null ) { return call_user_func ( $ this -> content , $ model , $ key , $ index , $ this ) ; } return $ this -> grid -> emptyCell ; }
2567	protected function checkAllNotEmpty ( ) { $ foundEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( empty ( $ arg ) ) { $ foundEmpty = true ; break ; } } return ! $ foundEmpty ; }
6339	private function getDocumentStream ( $ xmlDocument ) { foreach ( $ this -> streamAdapters as $ streamAdapter ) { if ( $ streamAdapter -> supports ( $ xmlDocument ) ) { return $ streamAdapter -> convert ( $ xmlDocument ) ; } } throw new RuntimeException ( sprintf ( 'Suitable XML document stream adapter is not registered for XML document of type "%s".' , is_object ( $ xmlDocument ) ? get_class ( $ xmlDocument ) : gettype ( $ xmlDocument ) ) ) ; }
3503	private function prepareCurlResourceByRequest ( Request $ request ) : void { curl_setopt ( $ this -> resource , CURLOPT_URL , $ request -> getUrl ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_POSTFIELDS , $ request -> getContent ( ) ) ; if ( $ request -> getCertificate ( ) ) { curl_setopt ( $ this -> resource , CURLOPT_SSLCERT , $ request -> getCertificate ( ) ) ; curl_setopt ( $ this -> resource , CURLOPT_SSLCERTPASSWD , $ request -> getCertificatePassPhrase ( ) ) ; } $ inlineHeaders = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ inlineHeaders [ ] = sprintf ( '%s: %s' , $ name , $ value ) ; } curl_setopt ( $ this -> resource , CURLOPT_HTTPHEADER , $ inlineHeaders ) ; }
1411	public function resourceIdNotSupported ( string $ id , string $ path = '/data' ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_CONFLICT , $ this -> trans ( 'resource_id_not_supported' , 'code' ) , $ this -> trans ( 'resource_id_not_supported' , 'title' ) , $ this -> trans ( 'resource_id_not_supported' , 'detail' , compact ( 'id' ) ) , $ this -> pointer ( $ path , 'id' ) ) ; }
2982	public function addBundle ( $ bundle ) { if ( ! $ this -> getFilename ( ) ) { return false ; } $ src = file ( $ this -> getFilename ( ) ) ; $ method = $ this -> reflected -> getMethod ( 'registerBundles' ) ; $ lines = array_slice ( $ src , $ method -> getStartLine ( ) - 1 , $ method -> getEndLine ( ) - $ method -> getStartLine ( ) + 1 ) ; if ( false !== strpos ( implode ( '' , $ lines ) , $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already defined in "AppKernel::registerBundles()".' , $ bundle ) ) ; } $ this -> setCode ( token_get_all ( '<?php ' . implode ( '' , $ lines ) ) , $ method -> getStartLine ( ) ) ; while ( $ token = $ this -> next ( ) ) { if ( T_VARIABLE !== $ token [ 0 ] || '$bundles' !== $ token [ 1 ] ) { continue ; } $ this -> next ( ) ; $ token = $ this -> next ( ) ; if ( T_ARRAY !== $ token [ 0 ] && '[' !== $ this -> value ( $ token ) ) { return false ; } while ( $ token = $ this -> next ( ) ) { if ( ')' !== $ this -> value ( $ token ) && ']' !== $ this -> value ( $ token ) ) { continue ; } if ( ';' !== $ this -> value ( $ this -> peek ( ) ) ) { continue ; } $ this -> next ( ) ; $ leadingContent = implode ( '' , array_slice ( $ src , 0 , $ this -> line ) ) ; $ leadingContent = rtrim ( rtrim ( $ leadingContent ) , ';' ) ; $ closingSymbolRegex = '#(\)|])$#' ; preg_match ( $ closingSymbolRegex , $ leadingContent , $ matches ) ; $ closingSymbol = $ matches [ 0 ] ; $ leadingContent = rtrim ( preg_replace ( $ closingSymbolRegex , '' , rtrim ( $ leadingContent ) ) ) ; if ( '(' !== substr ( $ leadingContent , - 1 ) && '[' !== substr ( $ leadingContent , - 1 ) ) { $ leadingContent = rtrim ( $ leadingContent , ',' ) . ',' ; } $ lines = array_merge ( array ( $ leadingContent , "\n" ) , array ( str_repeat ( ' ' , 12 ) , sprintf ( 'new %s(),' , $ bundle ) , "\n" ) , array ( str_repeat ( ' ' , 8 ) , $ closingSymbol . ';' , "\n" ) , array_slice ( $ src , $ this -> line ) ) ; Generator :: dump ( $ this -> getFilename ( ) , implode ( '' , $ lines ) ) ; return true ; } } }
9593	public function checkboxListFilled ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> checkboxFilledCssClass ) ; return self :: checkboxList ( $ items , $ options ) ; }
9280	public function deleteByWhere ( $ where = null , array $ options = array ( ) ) { $ delete = $ this -> sql -> delete ( ) ; if ( $ where instanceof Where ) { $ delete -> where ( $ where ) ; } elseif ( is_string ( $ where ) && ! empty ( $ where ) ) { $ delete -> where ( $ where ) ; } $ delete -> where ( $ where ) ; $ limit = array_key_exists ( 'limit' , $ options ) ? ( int ) $ limit : null ; if ( ! is_null ( $ limit ) && ( int ) $ limit > 0 ) { $ delete -> limit ( $ limit ) ; } $ stmt = $ this -> sql -> prepareStatementForSqlObject ( $ delete ) ; return $ stmt -> execute ( ) ; }
8864	public function augmentSQL ( SQLQuery & $ query ) { $ stage = Versioned :: current_stage ( ) ; if ( $ stage == 'Live' || ! Permission :: check ( "VIEW_DRAFT_CONTENT" ) ) { $ query -> addWhere ( "PublishDate < '" . Convert :: raw2sql ( SS_Datetime :: now ( ) ) . "'" ) ; } }
12655	public function addTextContainer ( $ name , $ content , $ language ) { $ allTexts = $ this -> getPageTexts ( $ language ) ; if ( isset ( $ allTexts [ $ name ] ) ) { throw new \ Exception ( "Text container name already used." ) ; } $ this -> contents [ $ language ] [ $ name ] = array ( 'id' => $ name , 'name' => $ name , 'content' => $ content , 'outdated' => false ) ; $ this -> writeTextsToFile ( $ language ) ; if ( $ language === $ this -> baseLang ) { $ this -> setExtraLanguagesOutdated ( $ name , $ content ) ; } return $ this -> contents [ $ language ] [ $ name ] ; }
3863	private function getCaptionText ( $ langKey ) { $ tableName = $ this -> getMetaModel ( ) -> getTableName ( ) ; if ( isset ( $ this -> objView ) && isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> objView -> get ( 'id' ) ] [ $ langKey ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ langKey ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ langKey ] ; }
1853	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'trans' !== $ chunks [ 0 ] ) { return false ; } $ parameters = isset ( $ chunks [ 3 ] ) ? explode ( ':' , $ chunks [ 3 ] ) : [ ] ; return $ this -> translator -> trans ( $ chunks [ 1 ] , $ parameters , $ chunks [ 2 ] ?? null ) ; }
11433	public function query ( $ keyword , $ categories , array $ other = [ ] ) { $ params = [ 'query' => $ keyword , 'category' => implode ( ',' , ( array ) $ categories ) , 'appid' => $ this -> getAccessToken ( ) -> getAppId ( ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , array_merge ( $ params , $ other ) ] ) ; }
12522	public function renderWidget ( array $ fields , $ customFieldOrClass , $ documentType = 'html' , $ slug = null ) { return $ this -> container -> get ( 'chill.custom_field.helper' ) -> renderCustomField ( $ fields , $ customFieldOrClass , $ documentType , $ slug ) ; }
10051	private function resolveVisibleFields ( ) { $ result = [ ] ; $ columns = $ this -> model -> getColumns ( ) ; foreach ( $ columns as $ column ) { $ result [ ] = $ column -> getName ( ) ; } return $ result ; }
6405	public function consume ( $ remaining_taf ) { $ chunk_regexp = $ this -> getRegexp ( ) ; if ( preg_match ( $ chunk_regexp , $ remaining_taf , $ matches ) ) { $ found = $ matches ; } else { $ found = null ; } $ new_remaining_taf = preg_replace ( $ chunk_regexp , '' , $ remaining_taf , 1 ) ; return array ( 'found' => $ found , 'remaining' => $ new_remaining_taf , ) ; }
4810	private function is_scheduled ( $ name ) { $ crons = _get_cron_array ( ) ; if ( empty ( $ crons ) ) { return false ; } foreach ( $ crons as $ cron ) { if ( isset ( $ cron [ $ name ] ) ) { return true ; } } return false ; }
9943	public function setCellValueExplicit ( $ pCoordinate , $ pValue , $ pDataType ) { $ this -> getCell ( $ pCoordinate ) -> setValueExplicit ( $ pValue , $ pDataType ) ; return $ this ; }
9778	function writable ( ) : self { if ( ! $ this -> hasFlag ( 'directory' ) && ! $ this -> hasFlag ( 'file' ) ) throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , isWritable ( ) ) ; }
8246	protected function getPasswordEncoder ( $ userData = null ) { if ( isset ( $ userData [ 'encoder' ] ) && is_string ( $ userData [ 'encoder' ] ) ) { $ name = $ userData [ 'encoder' ] ; } else { $ name = $ this -> config [ "encoder" ] ; } $ container = $ this -> picoAuth -> getContainer ( ) ; if ( ! $ container -> has ( $ name ) ) { throw new \ RuntimeException ( "Specified LocalAuth encoder is not resolvable." ) ; } return $ container -> get ( $ name ) ; }
3683	private function getFilterUrlBuilder ( ) : FilterUrlBuilder { if ( null === $ this -> filterUrlBuilder ) { return $ this -> filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; } return $ this -> filterUrlBuilder ; }
9023	public function hasConfirmation ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> confirmationWords ) ) { $ result = true ; } } return $ result ; }
10156	private function readSharedFmla ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ cellRange = substr ( $ recordData , 0 , 6 ) ; $ cellRange = $ this -> readBIFF5CellRangeAddressFixed ( $ cellRange ) ; $ no = ord ( $ recordData [ 7 ] ) ; $ formula = substr ( $ recordData , 8 ) ; $ this -> sharedFormulas [ $ this -> baseCell ] = $ formula ; }
5092	public function assemble ( ) { $ command = 'CREATE ' . $ this -> getPartIfSet ( self :: PART_TEMP ) . 'TABLE ' . $ this -> getPartIfSet ( self :: PART_IF_NOT_EXIST ) . $ this -> parts [ self :: PART_DB ] . $ this -> parts [ self :: PART_NAME ] ; if ( $ this -> parts [ self :: PART_LIKE ] ) { return $ command . ' ' . $ this -> parts [ self :: PART_LIKE ] ; } if ( ! $ this -> columnsList -> isEmpty ( ) ) { $ command .= '(' ; $ columns = $ this -> columnsList -> assemble ( ) ; $ keys = $ this -> indexes -> assemble ( ) ; $ combined = array_merge ( $ columns , $ keys ) ; $ command .= implode ( ',' , $ combined ) ; $ command .= ') ' . $ this -> getPartIfSet ( self :: PART_ENGINE , 'ENGINE=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'CHARSET=' ) . $ this -> getPartIfSet ( self :: PART_CHARSET , 'AUTO_INCREMENT=' ) . $ this -> getPartIfSet ( self :: PART_COMMENT , 'COMMENT=' ) ; } if ( $ this -> parts [ self :: PART_AS ] ) { $ command .= " {$this->getAsExpression()}" ; } return $ command ; }
2864	public function getLastFilePosition ( $ filePath ) { if ( ! file_exists ( $ filePath ) ) { return 0 ; } $ f = fopen ( $ filePath , 'r' ) ; fseek ( $ f , - 1 , SEEK_END ) ; return ftell ( $ f ) ; }
12756	protected function deleteFieldsForCFGroup ( $ customFieldsGroup ) { $ em = $ this -> getContainer ( ) -> get ( 'doctrine.orm.default_entity_manager' ) ; foreach ( $ customFieldsGroup -> getCustomFields ( ) as $ field ) { $ em -> remove ( $ field ) ; } }
3569	public function __issetHook ( ) { return function ( $ next , $ isset , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ isset ) { $ isset = ( bool ) $ this -> hasMeta ( $ key ) ; } return $ next ( $ isset , $ args ) ; } ; }
7776	protected function getRuleArgs ( $ rule ) { if ( ! $ this -> ruleHasArgs ( $ rule ) ) { return [ ] ; } list ( $ ruleName , $ argsWithBracketAtTheEnd ) = explode ( '(' , $ rule ) ; $ args = rtrim ( $ argsWithBracketAtTheEnd , ')' ) ; $ args = preg_replace ( '/\s+/' , '' , $ args ) ; $ args = explode ( ',' , $ args ) ; return $ args ; }
10283	public static function buildRange ( array $ pRange ) { if ( empty ( $ pRange ) || ! is_array ( $ pRange [ 0 ] ) ) { throw new Exception ( 'Range does not contain any information' ) ; } $ imploded = [ ] ; $ counter = count ( $ pRange ) ; for ( $ i = 0 ; $ i < $ counter ; ++ $ i ) { $ pRange [ $ i ] = implode ( ':' , $ pRange [ $ i ] ) ; } $ imploded = implode ( ',' , $ pRange ) ; return $ imploded ; }
1931	public function attachFileFromString ( $ strContent , $ strFilename , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( new \ Swift_Attachment ( $ strContent , $ strFilename , $ strMime ) ) ; }
223	protected function normalizeNumericStringValue ( $ value ) { $ powerPosition = strrpos ( $ value , 'E' ) ; if ( $ powerPosition !== false ) { $ valuePart = substr ( $ value , 0 , $ powerPosition ) ; $ powerPart = substr ( $ value , $ powerPosition + 1 ) ; } else { $ powerPart = null ; $ valuePart = $ value ; } $ separatorPosition = strrpos ( $ valuePart , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ valuePart , 0 , $ separatorPosition ) ; $ fractionalPart = substr ( $ valuePart , $ separatorPosition + 1 ) ; } else { $ integerPart = $ valuePart ; $ fractionalPart = null ; } $ integerPart = preg_replace ( '/^\+?(-?)0*(\d+)$/' , '$1$2' , $ integerPart ) ; $ integerPart = preg_replace ( '/^\+?(-?)0*$/' , '${1}0' , $ integerPart ) ; if ( $ fractionalPart !== null ) { $ fractionalPart = rtrim ( $ fractionalPart , '0' ) ; if ( empty ( $ fractionalPart ) ) { $ fractionalPart = $ powerPart !== null ? '0' : null ; } } $ normalizedValue = $ integerPart ; if ( $ fractionalPart !== null ) { $ normalizedValue .= '.' . $ fractionalPart ; } elseif ( $ normalizedValue === '-0' ) { $ normalizedValue = '0' ; } if ( $ powerPart !== null ) { $ normalizedValue .= 'E' . $ powerPart ; } return $ normalizedValue ; }
11793	public function setCc ( $ mail = '' , $ name = null ) { $ this -> cc = Helper :: deduplicate ( array_merge ( $ this -> cc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
9901	public function parse ( $ formula ) { $ this -> currentCharacter = 0 ; $ this -> formula = $ formula ; $ this -> lookAhead = isset ( $ formula [ 1 ] ) ? $ formula [ 1 ] : '' ; $ this -> advance ( ) ; $ this -> parseTree = $ this -> condition ( ) ; return true ; }
4511	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } }
1511	public function getRelationshipUri ( string $ type , $ id , string $ field , array $ params = [ ] ) : string { return $ this -> url ( [ $ type , $ id , 'relationships' , $ field ] , $ params ) ; }
6927	protected function notify ( $ type , $ resource ) { $ notify = $ this -> builder -> create ( $ type , $ resource ) ; if ( ! $ this -> builder -> build ( $ notify ) ) { return ; } $ this -> queue -> add ( $ notify ) ; }
11846	final public function reset ( $ column ) { if ( $ this -> isDirty ( $ column ) ) { $ this -> _data [ $ column ] = $ this -> _cleanData [ $ column ] ; unset ( $ this -> _modifiedFields [ $ column ] ) ; } }
10536	public function extractHeaders ( ) { $ headers = [ ] ; $ requestHeaders = array_keys ( $ this -> cors ) ; foreach ( $ requestHeaders as $ headerField ) { $ serverField = $ this -> headerizeToPhp ( $ headerField ) ; $ headerData = isset ( $ _SERVER [ $ serverField ] ) ? $ _SERVER [ $ serverField ] : null ; if ( $ headerData !== null ) { $ headers [ $ headerField ] = $ headerData ; } } return $ headers ; }
7262	protected function assertAdjustmentMode ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ mode = $ adjustment -> getMode ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment mode '$mode'." ) ; } }
1801	protected function switchToEdit ( $ id ) { $ arrKeys = array ( ) ; $ arrUnset = array ( 'act' , 'id' , 'table' ) ; foreach ( array_keys ( $ _GET ) as $ strKey ) { if ( ! \ in_array ( $ strKey , $ arrUnset ) ) { $ arrKeys [ $ strKey ] = $ strKey . '=' . Input :: get ( $ strKey ) ; } } $ strUrl = TL_SCRIPT . '?' . implode ( '&' , $ arrKeys ) ; return $ strUrl . ( ! empty ( $ arrKeys ) ? '&' : '' ) . ( Input :: get ( 'table' ) ? 'table=' . Input :: get ( 'table' ) . '&amp;' : '' ) . 'act=edit&amp;id=' . rawurlencode ( $ id ) ; }
9584	public function getRouteForRequest ( Request $ request ) { $ method = $ request -> getMethod ( ) ; $ path = $ request -> getPathInfo ( ) ? : '/' ; $ result = $ this -> getDispatcher ( ) -> dispatch ( $ method , $ path ) ; if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: NOT_FOUND ) { throw new NotFoundHttpException ( "No route match for path $path" ) ; } else if ( $ result [ 0 ] == \ FastRoute \ Dispatcher :: METHOD_NOT_ALLOWED ) { throw new MethodNotAllowedHttpException ( $ result [ 1 ] , "Method $method not allowed for path $path" ) ; } else if ( $ result [ 0 ] !== \ FastRoute \ Dispatcher :: FOUND ) { throw new \ RuntimeException ( 'Unknown result from FastRoute: ' . $ result [ 0 ] ) ; } return $ this -> matchRoute ( $ result [ 1 ] , $ result [ 2 ] , $ request ) ; }
10155	private function readMulRk ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ colFirst = self :: getUInt2d ( $ recordData , 2 ) ; $ colLast = self :: getUInt2d ( $ recordData , $ length - 2 ) ; $ columns = $ colLast - $ colFirst + 1 ; $ offset = 4 ; for ( $ i = 1 ; $ i <= $ columns ; ++ $ i ) { $ columnString = Coordinate :: stringFromColumnIndex ( $ colFirst + $ i ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , $ offset ) ; $ numValue = self :: getIEEE754 ( self :: getInt4d ( $ recordData , $ offset + 2 ) ) ; $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } $ cell -> setValueExplicit ( $ numValue , DataType :: TYPE_NUMERIC ) ; } $ offset += 6 ; } }
11979	public function transformCard ( AbstractMessage $ message ) { $ type = $ message -> getType ( ) ; return [ 'msgtype' => $ type , $ type => [ 'card_id' => $ message -> get ( 'card_id' ) , ] , ] ; }
11708	public function actionCreate ( ) { $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'create' , ] ) ; $ this -> performAjaxValidation ( $ user ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been created' ) ) ; return $ this -> redirect ( [ 'index' ] ) ; } return $ this -> render ( 'create' , [ 'user' => $ user ] ) ; }
5276	public function orderBy ( $ columns , $ direction = 'asc' ) { if ( is_string ( $ columns ) ) { $ columns = $ this -> argument_to_array ( $ columns ) ; } foreach ( $ columns as $ key => $ column ) { if ( is_numeric ( $ key ) ) { $ this -> statements [ 'orders' ] [ $ column ] = $ direction ; } else { $ this -> statements [ 'orders' ] [ $ key ] = $ column ; } } return $ this ; }
11196	public function __isset ( $ name ) { $ value = $ this -> find ( $ name ) ; if ( $ value !== null && ! ( $ value instanceof \ Exception ) ) { return true ; } return false ; }
11553	public function dispatch ( DispatchConfirmationInterface $ dispatchConfirmation ) { try { $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENTS_DISPATCH , $ event ) ; $ adapter = $ this -> getAdapter ( $ dispatchConfirmation -> getConsignments ( ) -> first ( ) ) ; $ adapter -> dispatch ( $ dispatchConfirmation ) ; $ this -> dispatchConfirmationRepository -> saveDispatchConfirmation ( $ dispatchConfirmation ) ; foreach ( $ dispatchConfirmation -> getConsignments ( ) as $ consignment ) { $ consignment -> setDispatchConfirmation ( $ dispatchConfirmation ) ; $ previousStatus = $ consignment -> getStatus ( ) ; foreach ( $ consignment -> getParcels ( ) as $ parcel ) { $ parcel -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; } $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_DISPATCHED ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; $ this -> dispatchOnConsignmentStatusChange ( $ consignment , $ previousStatus ) ; } $ event = new EventDispatchConfirmation ( $ dispatchConfirmation ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENTS_DISPATCH , $ event ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignments dispatching.' , null , $ e ) ; } }
499	protected function writeInteger ( $ fileHandle , $ integer ) { return $ this -> writeBytes ( $ fileHandle , pack ( $ this -> useBigEndian ? 'N' : 'V' , ( int ) $ integer ) ) ; }
3483	public function withMutableContent ( bool $ mutableContent ) : Aps { $ cloned = clone $ this ; $ cloned -> mutableContent = $ mutableContent ; return $ cloned ; }
3216	function chunkedUploadStart ( $ data ) { Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( ) , $ data ) ; if ( $ response -> statusCode === 404 ) { throw new Exception_BadResponse ( "Got a 404, but we didn't send up an 'upload_id'" ) ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) throw new Exception_BadResponse ( "Got an offset-correcting 400 response, but we didn't send an offset" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ uploadId , $ byteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ len = strlen ( $ data ) ; if ( $ byteOffset !== $ len ) throw new Exception_BadResponse ( "We sent $len bytes, but server returned an offset of $byteOffset" ) ; return $ uploadId ; }
9993	private function createCSSStyle ( Style $ pStyle ) { $ css = array_merge ( $ this -> createCSSStyleAlignment ( $ pStyle -> getAlignment ( ) ) , $ this -> createCSSStyleBorders ( $ pStyle -> getBorders ( ) ) , $ this -> createCSSStyleFont ( $ pStyle -> getFont ( ) ) , $ this -> createCSSStyleFill ( $ pStyle -> getFill ( ) ) ) ; return $ css ; }
6716	protected function getRequestChainFromUri ( $ requestedUri ) { $ requestedUri = preg_replace ( '/[\?\.].*$/' , '' , $ requestedUri ) ; $ requestChain = explode ( '/' , $ requestedUri ) ; if ( ! $ requestChain [ 0 ] ) { unset ( $ requestChain [ 0 ] ) ; } return array_values ( $ requestChain ) ; }
6726	public function get_movie_votes ( $ post_id ) { $ votes = get_post_meta ( $ post_id , 'imdbTotalVotes' , true ) ; if ( ! empty ( $ votes ) ) { return json_decode ( $ votes , true ) ; } return false ; }
7077	static public function getSaleEditableDocumentTypes ( SaleInterface $ sale ) { $ types = [ ] ; foreach ( DocumentTypes :: getTypes ( ) as $ type ) { if ( ! static :: isSaleSupportsDocumentType ( $ sale , $ type ) ) { continue ; } foreach ( $ sale -> getAttachments ( ) as $ attachment ) { if ( $ attachment -> getType ( ) === $ type ) { continue 2 ; } } $ types [ ] = $ type ; } return $ types ; }
12618	public function setFileSource ( $ value ) { if ( isset ( $ this -> module -> sourceFiles [ $ value ] ) ) { $ this -> _fileSource = $ this -> module -> sourceFiles [ $ value ] ; } else { $ this -> _fileSource = false ; } }
8659	private function convertGetFeedSubmissionCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedTypeList ( ) ) { $ feedTypeList = $ request -> getFeedTypeList ( ) ; foreach ( $ feedTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'FeedTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetFeedProcessingStatusList ( ) ) { $ feedProcessingStatusList = $ request -> getFeedProcessingStatusList ( ) ; foreach ( $ feedProcessingStatusList -> getStatus ( ) as $ statusIndex => $ status ) { $ parameters [ 'FeedProcessingStatusList' . '.' . 'Status' . '.' . ( $ statusIndex + 1 ) ] = $ status ; } } if ( $ request -> isSetSubmittedFromDate ( ) ) { $ parameters [ 'SubmittedFromDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedFromDate ( ) ) ; } if ( $ request -> isSetSubmittedToDate ( ) ) { $ parameters [ 'SubmittedToDate' ] = $ this -> getFormattedTimestamp ( $ request -> getSubmittedToDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
11919	public function attr ( $ keys = [ ] ) { if ( ! is_array ( $ keys ) ) { $ keys = [ $ keys ] ; } $ out = '' ; foreach ( $ keys as $ key ) { $ value = $ this -> getValue ( $ key ) -> attr ( ) ; if ( ! empty ( $ value ) ) { $ out .= ' ' . $ value ; } } return ltrim ( $ out , ' ' ) ; }
1133	public function setDefaultLeftAndRight ( ) { $ withHighestRight = $ this -> newNestedSetQuery ( ) -> reOrderBy ( $ this -> getRightColumnName ( ) , 'desc' ) -> take ( 1 ) -> sharedLock ( ) -> first ( ) ; $ maxRgt = 0 ; if ( ! is_null ( $ withHighestRight ) ) $ maxRgt = $ withHighestRight -> getRight ( ) ; $ this -> setAttribute ( $ this -> getLeftColumnName ( ) , $ maxRgt + 1 ) ; $ this -> setAttribute ( $ this -> getRightColumnName ( ) , $ maxRgt + 2 ) ; }
1377	protected function validateIdMember ( $ value , string $ path ) : bool { if ( ! is_string ( $ value ) ) { $ this -> memberNotString ( $ path , 'id' ) ; return false ; } if ( empty ( $ value ) ) { $ this -> memberEmpty ( $ path , 'id' ) ; return false ; } return true ; }
12482	private function mapByGeneration ( $ mapByDepthDesc , $ mapById ) { $ result = [ ] ; foreach ( $ mapByDepthDesc as $ depth => $ ids ) { foreach ( $ ids as $ custId ) { $ entry = $ mapById [ $ custId ] ; $ path = $ entry -> getPath ( ) ; $ parents = $ this -> hlpTree -> getParentsFromPathReversed ( $ path ) ; $ level = 0 ; foreach ( $ parents as $ parentId ) { $ level += 1 ; if ( ! isset ( $ result [ $ parentId ] ) ) { $ result [ $ parentId ] = [ ] ; } if ( ! isset ( $ result [ $ parentId ] [ $ level ] ) ) { $ result [ $ parentId ] [ $ level ] = [ ] ; } $ result [ $ parentId ] [ $ level ] [ ] = $ custId ; } } } return $ result ; }
6907	public function removeExtraRecipient ( Recipient $ recipient ) { if ( $ this -> extraRecipients -> contains ( $ recipient ) ) { $ this -> extraRecipients -> removeElement ( $ recipient ) ; } return $ this ; }
753	public function init ( ) { $ this -> fontFile = Yii :: getAlias ( $ this -> fontFile ) ; if ( ! is_file ( $ this -> fontFile ) ) { throw new InvalidConfigException ( "The font file does not exist: {$this->fontFile}" ) ; } }
6043	public function addUsage ( $ sessionId , MediaUsage $ mediaUsage ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'mediaUsage' => $ mediaUsage ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/usage' , $ parameters ) ; $ result = new MediaUsageResponse ( $ result ) ; return $ result ; }
9699	public function text ( $ paragraphs = null ) { $ this -> paragraphs = $ paragraphs ; $ this -> params [ 'plaintext' ] = true ; return $ this -> generate ( ) ; }
705	public function getDefaultRoleInstances ( ) { $ result = [ ] ; foreach ( $ this -> defaultRoles as $ roleName ) { $ result [ $ roleName ] = $ this -> createRole ( $ roleName ) ; } return $ result ; }
5550	public function getRequestData ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequestData ( ) ; } return $ this -> frameset -> getRequestData ( ) ; }
808	private function sortAlphabetically ( array $ first , array $ second ) { $ firstNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ) ; $ secondNamespace = str_replace ( '\\' , ' ' , $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ) ; return strcasecmp ( $ firstNamespace , $ secondNamespace ) ; }
7553	protected function match_tags ( $ tags ) { $ res = false ; foreach ( $ tags as $ tag => $ match ) { if ( ! is_array ( $ match ) ) { $ match = array ( 'match' => $ match , 'operator' => 'or' , 'compare' => 'total' , 'case_sensitive' => false ) ; } else { if ( is_int ( $ tag ) ) { $ tag = $ match [ 'tag' ] ; } if ( ! isset ( $ match [ 'match' ] ) ) { $ match [ 'match' ] = true ; } if ( ! isset ( $ match [ 'operator' ] ) ) { $ match [ 'operator' ] = 'or' ; } if ( ! isset ( $ match [ 'compare' ] ) ) { $ match [ 'compare' ] = 'total' ; } if ( ! isset ( $ match [ 'case_sensitive' ] ) ) { $ match [ 'case_sensitive' ] = false ; } } if ( ( $ match [ 'operator' ] === 'and' ) && ( ! $ res ) ) { return false ; } elseif ( ! ( $ res && ( $ match [ 'operator' ] === 'or' ) ) ) { if ( $ match [ 'compare' ] === 'total' ) { $ a = $ this -> tag ; } elseif ( $ match [ 'compare' ] === 'namespace' ) { $ a = $ this -> getNamespace ( ) ; } elseif ( $ match [ 'compare' ] === 'name' ) { $ a = $ this -> getTag ( ) ; } if ( $ match [ 'case_sensitive' ] ) { $ res = ( ( $ a === $ tag ) === $ match [ 'match' ] ) ; } else { $ res = ( ( strcasecmp ( $ a , $ tag ) === 0 ) === $ match [ 'match' ] ) ; } } } return $ res ; }
5218	protected static function hostname ( ) { return function ( Binder $ binder ) { if ( DIRECTORY_SEPARATOR === '\\' ) { $ fq = php_uname ( 'n' ) ; if ( isset ( $ _SERVER [ 'USERDNSDOMAIN' ] ) ) { $ fq .= '.' . $ _SERVER [ 'USERDNSDOMAIN' ] ; } } else { $ fq = exec ( 'hostname -f' ) ; } $ binder -> bindConstant ( 'stubbles.hostname.nq' ) -> to ( php_uname ( 'n' ) ) ; $ binder -> bindConstant ( 'stubbles.hostname.fq' ) -> to ( $ fq ) ; } ; }
12310	private function findFile ( $ uriPath ) { return array_reduce ( $ this -> paths , function ( $ file , $ path ) use ( $ uriPath ) { if ( false !== $ file ) { return $ file ; } $ file = $ path . $ uriPath ; if ( is_file ( $ file ) && is_readable ( $ file ) ) { return $ file ; } return false ; } , false ) ; }
2772	public function init ( array $ options = [ ] ) : string { $ argsAndOptions = [ $ this -> directory , $ options ] ; return $ this -> run ( 'init' , $ argsAndOptions , false ) ; }
11412	public function batchTagUsers ( array $ openIds , $ tagId ) { $ params = [ 'openid_list' => $ openIds , 'tagid' => $ tagId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_TAG , $ params ] ) ; }
9760	function containOnly ( string $ type ) : self { return $ this -> expect ( $ this -> target , containsOnly ( $ type ) ) ; }
1671	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new self ( $ strParent ) ; } $ this -> Files -> rcopy ( $ this -> strFolder , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFolder , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return true ; }
1866	public function addSenderNamePlaceholder ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> pid ) { $ objChannel = $ this -> Database -> prepare ( "SELECT senderName FROM tl_newsletter_channel WHERE id=?" ) -> execute ( $ dc -> activeRecord -> pid ) ; $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'placeholder' ] = $ objChannel -> senderName ; } return $ varValue ; }
998	public function getTypeMap ( ) { if ( ! $ this -> fullyLoaded ) { $ this -> resolvedTypes = $ this -> collectAllTypes ( ) ; $ this -> fullyLoaded = true ; } return $ this -> resolvedTypes ; }
7479	public function getContent ( ) { $ this -> absolute ( ) ; if ( ! is_file ( $ this -> data ) ) { Exception :: i ( ) -> setMessage ( self :: ERROR_PATH_IS_NOT_FILE ) -> addVariable ( $ this -> data ) -> trigger ( ) ; } return file_get_contents ( $ this -> data ) ; }
4387	public function getConfigFE ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ basket ) { $ list = [ ] ; $ feconfig = $ this -> feConfig ; try { $ code = $ this -> getServiceItem ( ) -> getCode ( ) ; $ service = $ basket -> getService ( \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT , $ code ) ; foreach ( $ service -> getAttributeItems ( ) as $ item ) { if ( isset ( $ feconfig [ $ item -> getCode ( ) ] ) ) { $ feconfig [ $ item -> getCode ( ) ] [ 'default' ] = $ item -> getValue ( ) ; } } } catch ( \ Aimeos \ MShop \ Order \ Exception $ e ) { ; } $ addresses = $ basket -> getAddress ( \ Aimeos \ MShop \ Order \ Item \ Base \ Address \ Base :: TYPE_PAYMENT ) ; if ( ( $ address = current ( $ addresses ) ) !== false ) { if ( $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] == '' && ( $ fn = $ address -> getFirstname ( ) ) !== '' && ( $ ln = $ address -> getLastname ( ) ) !== '' ) { $ feconfig [ 'novalnetsepa.holder' ] [ 'default' ] = $ fn . ' ' . $ ln ; } } foreach ( $ feconfig as $ key => $ config ) { $ list [ $ key ] = new \ Aimeos \ MW \ Criteria \ Attribute \ Standard ( $ config ) ; } return $ list ; }
12459	public function indexAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ cfGroups = $ em -> getRepository ( 'ChillCustomFieldsBundle:CustomFieldsGroup' ) -> findAll ( ) ; $ defaultGroups = $ this -> getDefaultGroupsId ( ) ; $ makeDefaultFormViews = array ( ) ; foreach ( $ cfGroups as $ group ) { if ( ! in_array ( $ group -> getId ( ) , $ defaultGroups ) ) { $ makeDefaultFormViews [ $ group -> getId ( ) ] = $ this -> createMakeDefaultForm ( $ group ) -> createView ( ) ; } } return $ this -> render ( 'ChillCustomFieldsBundle:CustomFieldsGroup:index.html.twig' , array ( 'entities' => $ cfGroups , 'default_groups' => $ defaultGroups , 'make_default_forms' => $ makeDefaultFormViews ) ) ; }
1130	public function makeFirstChildOf ( $ node ) { if ( $ node -> children ( ) -> count ( ) == 0 ) return $ this -> makeChildOf ( $ node ) ; return $ this -> moveToLeftOf ( $ node -> children ( ) -> first ( ) ) ; }
10499	public function gte ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value !== null && $ this -> value >= $ value ) { return true ; } return false ; }
2337	private function setLegacyOptions ( Table $ table ) : void { if ( ! $ table -> hasOption ( 'engine' ) ) { $ table -> addOption ( 'engine' , 'MyISAM' ) ; } if ( ! $ table -> hasOption ( 'charset' ) ) { $ table -> addOption ( 'charset' , 'utf8' ) ; } if ( ! $ table -> hasOption ( 'collate' ) ) { $ table -> addOption ( 'collate' , 'utf8_general_ci' ) ; } }
7608	public function renderListItems ( array $ aDropdownOptions ) { if ( ! isset ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( __METHOD__ . ' expects "items" option' ) ; } if ( ! is_array ( $ aDropdownOptions [ 'items' ] ) ) { throw new LogicException ( '"items" option expects an array, "' . gettype ( $ aDropdownOptions [ 'items' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] = array ( 'class' => 'dropdown-menu' ) ; } else { if ( ! is_array ( $ aDropdownOptions [ 'list_attributes' ] ) ) { throw new \ LogicException ( '"list_attributes" option expects an array, "' . gettype ( $ aDropdownOptions [ 'list_attributes' ] ) . '" given' ) ; } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] = 'dropdown-menu' ; } elseif ( ! preg_match ( '/(\s|^)dropdown-menu(\s|$)/' , $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'class' ] .= ' dropdown-menu' ; } } if ( empty ( $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'role' ] = 'menu' ; } if ( ! empty ( $ aDropdownOptions [ 'name' ] ) ) { $ aDropdownOptions [ 'list_attributes' ] [ 'aria-labelledby' ] = $ aDropdownOptions [ 'name' ] ; } $ sItems = '' ; foreach ( $ aDropdownOptions [ 'items' ] as $ sKey => $ aItemOptions ) { if ( ! is_array ( $ aItemOptions ) ) { if ( ! is_scalar ( $ aItemOptions ) ) { throw new \ LogicException ( 'item option expects an array or a scalar value, "' . gettype ( $ aItemOptions ) . '" given' ) ; } $ aItemOptions = $ aItemOptions === self :: TYPE_ITEM_DIVIDER ? array ( 'type' => self :: TYPE_ITEM_DIVIDER ) : array ( 'label' => $ aItemOptions , 'type' => self :: TYPE_ITEM_LINK , 'item_attributes' => array ( 'href' => is_string ( $ sKey ) ? $ sKey : null ) ) ; } else { if ( ! isset ( $ aItemOptions [ 'label' ] ) ) { $ aItemOptions [ 'label' ] = is_string ( $ sKey ) ? $ sKey : null ; } if ( ! isset ( $ aItemOptions [ 'type' ] ) ) { $ aItemOptions [ 'type' ] = self :: TYPE_ITEM_LINK ; } } $ sItems .= $ this -> renderItem ( $ aItemOptions ) . "\n" ; } return sprintf ( static :: $ dropdownListFormat , $ this -> createAttributesString ( $ aDropdownOptions [ 'list_attributes' ] ) , $ sItems ) ; }
1430	protected function deserializeSoftDelete ( $ value , $ field , $ record ) { if ( collect ( [ true , false , 1 , 0 , '1' , '0' ] ) -> containsStrict ( $ value ) ) { return $ value ? Carbon :: now ( ) : null ; } return $ this -> deserializeAttribute ( $ value , $ field , $ record ) ; }
4044	private function removeInvariantAttributes ( IItem $ nativeItem , ICollection $ renderSetting ) { $ model = $ nativeItem -> getMetaModel ( ) ; if ( $ model -> hasVariants ( ) && ! $ nativeItem -> isVariantBase ( ) ) { $ renderSetting = clone $ renderSetting ; foreach ( array_keys ( $ model -> getInVariantAttributes ( ) ) as $ strAttrName ) { $ renderSetting -> setSetting ( $ strAttrName , null ) ; } } return $ renderSetting ; }
8356	public function generateModels ( ) { $ definition = $ this -> getDefinition ( ) ; foreach ( $ definition as $ modelName => $ modelDefinition ) { $ type = 'model' ; if ( isset ( $ modelDefinition [ 'type' ] ) === true && in_array ( $ modelDefinition [ 'type' ] , [ 'enum' , 'model' ] ) === true ) { $ type = $ modelDefinition [ 'type' ] ; } if ( $ type == 'enum' ) { $ this -> generateEnum ( $ modelName , $ modelDefinition ) ; } else { $ this -> generateModel ( $ modelName , $ modelDefinition ) ; } } }
4692	public function andHaving ( string $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> having = $ this -> having ? '(' . $ this -> having . ') AND (' . $ expression . ')' : $ expression ; $ this -> pushArgs ( 'having' , $ args ) ; return $ this ; }
5334	protected function sign ( $ privateKey , $ parameters ) { if ( preg_match ( '/-----BEGIN (RSA )?PRIVATE KEY-----(.*)-----END (RSA )?PRIVATE KEY-----/si' , $ privateKey , $ matches ) ) { $ key = $ matches [ 2 ] ; $ key = preg_replace ( '/\s*/s' , '' , $ key ) ; $ key = chunk_split ( $ key , 64 , "\n" ) ; $ key = "-----BEGIN PRIVATE KEY-----\n" . $ key . '-----END PRIVATE KEY-----' ; $ digest = $ this -> sha512Asn1 ( $ this -> encodeParameters ( $ parameters ) ) ; if ( @ openssl_private_encrypt ( $ digest , $ signature , $ key ) ) { return base64_encode ( $ signature ) ; } throw new \ InvalidArgumentException ( 'Unable to sign the request, this has to do with the provided (invalid) private key.' ) ; } throw new \ InvalidArgumentException ( 'Invalid private key.' ) ; }
4933	public function loadEntities ( $ entity , $ id = null ) { $ params = $ this -> options ; $ params [ 'id' ] = $ id ; $ params [ 'repositories' ] = $ this -> repositories ; $ event = $ this -> loadEntitiesEvents -> getEvent ( $ entity , $ this , $ params ) ; $ responses = $ this -> loadEntitiesEvents -> triggerEventUntil ( function ( $ response ) { return ( is_array ( $ response ) || $ response instanceof \ Traversable ) && count ( $ response ) ; } , $ event ) ; $ entities = $ responses -> last ( ) ; return $ entities ; }
7106	protected function calculateTotalByState ( PaymentSubjectInterface $ subject , $ state ) { PaymentStates :: isValidState ( $ state , true ) ; $ currency = $ subject -> getCurrency ( ) -> getCode ( ) ; $ total = 0 ; foreach ( $ subject -> getPayments ( ) as $ payment ) { if ( $ payment -> getState ( ) === $ state ) { $ total += $ this -> convertPaymentAmount ( $ payment , $ currency ) ; } } return $ total ; }
4537	public function prePersist ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Uuidentifiable ) { return ; } $ this -> idService -> generateUuid ( $ entity ) ; }
8007	protected function validateSupportedAlgorithm ( $ algorithm ) { if ( ! in_array ( $ algorithm , $ this -> supported_algorithms , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Algorithm "%s" not supported' , $ algorithm ) ) ; } return $ algorithm ; }
4261	public function removeSubscriberInterface ( SubscriberInterface $ interface ) { $ subscribers = $ this -> getInterfaceSubscribers ( $ interface ) ; foreach ( $ subscribers as $ row ) { $ this -> unsubscribe ( $ row [ 0 ] , $ row [ 1 ] , $ row [ 2 ] ) ; } return $ subscribers ; }
5725	protected function saveAndRedirect ( $ data , $ form , $ redirectLink ) { $ new_record = $ this -> owner -> record -> ID == 0 ; $ controller = Controller :: curr ( ) ; $ list = $ this -> owner -> gridField -> getList ( ) ; if ( $ list instanceof ManyManyList ) { $ extraData = ( isset ( $ data [ 'ManyMany' ] ) ) ? $ data [ 'ManyMany' ] : null ; } else { $ extraData = null ; } if ( ! $ this -> owner -> record -> canEdit ( ) ) { return $ controller -> httpError ( 403 ) ; } try { $ form -> saveInto ( $ this -> owner -> record ) ; $ this -> owner -> record -> write ( ) ; $ list -> add ( $ this -> owner -> record , $ extraData ) ; } catch ( ValidationException $ e ) { $ form -> sessionMessage ( $ e -> getResult ( ) -> message ( ) , 'bad' ) ; $ responseNegotiator = new PjaxResponseNegotiator ( array ( 'CurrentForm' => function ( ) use ( $ form ) { return $ form -> forTemplate ( ) ; } , 'default' => function ( ) use ( $ controller ) { return $ controller -> redirectBack ( ) ; } ) ) ; if ( $ controller -> getRequest ( ) -> isAjax ( ) ) { $ controller -> getRequest ( ) -> addHeader ( 'X-Pjax' , 'CurrentForm' ) ; } return $ responseNegotiator -> respond ( $ controller -> getRequest ( ) ) ; } return Controller :: curr ( ) -> redirect ( $ redirectLink ) ; }
5705	public function shouldDisplay ( ) { if ( $ this -> gridFieldRequest -> getRequest ( ) -> param ( 'ID' ) == 'new' ) { return false ; } return $ this -> gridFieldRequest -> record -> canCreate ( ) ; }
12934	public function move ( $ baseDir , array $ options , $ username ) { $ this -> resolveMoveOptions ( $ options ) ; if ( array_key_exists ( "targetSlot" , $ options ) ) { $ options [ "slot" ] = $ options [ "targetSlot" ] ; $ block = $ this -> moveBlockToAnotherSlot ( $ baseDir , $ options , $ username ) ; return $ block ; } $ options [ "slot" ] = $ options [ "sourceSlot" ] ; $ block = $ this -> moveBlockToSameSlot ( $ baseDir , $ options , $ username ) ; return $ block ; }
8198	public function next ( ) { if ( ! isset ( $ this -> tokens [ ++ $ this -> current ] ) ) { throw new Twig_Error_Syntax ( 'Unexpected end of template.' , $ this -> tokens [ $ this -> current - 1 ] -> getLine ( ) , $ this -> source ) ; } return $ this -> tokens [ $ this -> current - 1 ] ; }
10070	public function make ( $ tag , $ props = null , $ content = null ) { $ tag = parent :: make ( $ tag , $ props , $ content ) ; $ tag = $ this -> decorators -> apply ( $ tag , $ this ) ; return $ tag ; }
1081	private function loc ( Token $ startToken ) { if ( empty ( $ this -> lexer -> options [ 'noLocation' ] ) ) { return new Location ( $ startToken , $ this -> lexer -> lastToken , $ this -> lexer -> source ) ; } return null ; }
9540	private function getParameterClosure ( $ parameter ) { $ parameterClosure = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { @ $ parameterClosure = $ this -> parameterCluster -> prefixes [ $ prefix ] [ substr ( $ parameter , strlen ( $ prefix ) , strlen ( $ parameter ) - strlen ( $ prefix ) ) ] ; } } return $ parameterClosure ; }
5303	protected static function hexToUnicode ( $ char ) { if ( ! is_string ( $ char ) || ! preg_match ( '(^[0-9a-f]{2,6}$)i' , $ char ) ) { throw new \ InvalidArgumentException ( '$char must be one single unicode character as hex string' ) ; } return mb_convert_encoding ( '&#x' . strtolower ( $ char ) . ';' , 'UTF-8' , 'HTML-ENTITIES' ) ; }
360	function normalizeRequirement ( $ requirement , $ requirementKey = 0 ) { if ( ! is_array ( $ requirement ) ) { $ this -> usageError ( 'Requirement must be an array!' ) ; } if ( ! array_key_exists ( 'condition' , $ requirement ) ) { $ this -> usageError ( "Requirement '{$requirementKey}' has no condition!" ) ; } else { $ evalPrefix = 'eval:' ; if ( is_string ( $ requirement [ 'condition' ] ) && strpos ( $ requirement [ 'condition' ] , $ evalPrefix ) === 0 ) { $ expression = substr ( $ requirement [ 'condition' ] , strlen ( $ evalPrefix ) ) ; $ requirement [ 'condition' ] = $ this -> evaluateExpression ( $ expression ) ; } } if ( ! array_key_exists ( 'name' , $ requirement ) ) { $ requirement [ 'name' ] = is_numeric ( $ requirementKey ) ? 'Requirement #' . $ requirementKey : $ requirementKey ; } if ( ! array_key_exists ( 'mandatory' , $ requirement ) ) { if ( array_key_exists ( 'required' , $ requirement ) ) { $ requirement [ 'mandatory' ] = $ requirement [ 'required' ] ; } else { $ requirement [ 'mandatory' ] = false ; } } if ( ! array_key_exists ( 'by' , $ requirement ) ) { $ requirement [ 'by' ] = 'Unknown' ; } if ( ! array_key_exists ( 'memo' , $ requirement ) ) { $ requirement [ 'memo' ] = '' ; } return $ requirement ; }
12361	public function getPublisherForMessage ( Message $ message ) { $ attributes = $ message -> getAttributes ( ) ; if ( ! isset ( $ attributes [ 'headers' ] ) || ! isset ( $ attributes [ 'headers' ] [ $ this -> headerName ] ) ) { throw MissingPublisherException :: noHeaderInMessage ( $ message , $ this -> headerName ) ; } $ value = $ attributes [ 'headers' ] [ $ this -> headerName ] ; foreach ( $ this -> valueMap as $ hash => $ values ) { if ( ! in_array ( $ value , $ values , true ) ) { continue ; } return $ this -> publishers [ $ hash ] ; } throw MissingPublisherException :: noKnownPublisherFor ( $ message ) ; }
6983	public function validateAndReturnErrors ( $ dataOrRequest , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { $ messages = Set :: flatten ( $ messages ) ; if ( $ dataOrRequest instanceof Request ) { $ dataOrRequest = $ dataOrRequest -> all ( ) ; } $ validator = $ this -> getValidationFactory ( ) -> make ( $ dataOrRequest , $ rules , $ messages , $ customAttributes ) ; if ( $ validator -> fails ( ) ) { return $ validator -> getMessageBag ( ) -> toArray ( ) ; } return [ ] ; }
6737	public function uninstallation ( ) { $ this -> model -> delete_post_meta ( ) ; $ this -> model -> delete_options ( ) ; $ this -> model -> remove_tables ( ) ; }
1076	private static function isMissingVariable ( $ valueNode , $ variables ) { return $ valueNode instanceof VariableNode && ( count ( $ variables ) === 0 || ! array_key_exists ( $ valueNode -> name -> value , $ variables ) ) ; }
10189	public function writeVBARelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ objWriter -> startElement ( 'Relationship' ) ; $ objWriter -> writeAttribute ( 'Id' , 'rId1' ) ; $ objWriter -> writeAttribute ( 'Type' , 'http://schemas.microsoft.com/office/2006/relationships/vbaProjectSignature' ) ; $ objWriter -> writeAttribute ( 'Target' , 'vbaProjectSignature.bin' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
5645	public function shouldInvoke ( $ test_case_name , $ method ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { if ( ! $ this -> reporters [ $ i ] -> shouldInvoke ( $ test_case_name , $ method ) ) { return false ; } } return true ; }
8209	protected function parseArguments ( ) { $ this -> parseConnection ( $ this -> option ( 'connection' ) ) ; if ( $ this -> option ( 'host' ) ) { $ this -> host = $ this -> option ( 'host' ) ; } if ( $ this -> option ( 'port' ) ) { $ this -> port = ( int ) $ this -> option ( 'port' ) ; } $ this -> parseCommandArguments ( ) ; }
1541	public function withQualifiedKeyName ( $ keyName ) { $ parts = explode ( '.' , $ keyName ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withIdentifierColumn ( $ parts [ 1 ] ) ; return $ this ; }
10387	public function newApp ( ) : ApplicationInterface { $ app = new CalgamoApplication ( $ this -> filesystem ) ; $ app -> requireModule ( CalgamoLogExceptionHandlerModule :: class ) ; $ app -> requireModule ( CalgamoRouterModule :: class ) ; $ app -> requireModule ( CalgamoDiModule :: class ) ; $ app -> requireModule ( Wa72SimpleLoggerModule :: class ) ; return $ app ; }
12103	private function phpSizeToBytes ( $ size ) { if ( is_numeric ( $ size ) ) { return $ size ; } $ suffix = substr ( $ size , - 1 ) ; $ value = substr ( $ size , 0 , - 1 ) ; switch ( strtolower ( $ suffix ) ) { case 'p' : $ value *= 1024 ; case 't' : $ value *= 1024 ; case 'g' : $ value *= 1024 ; case 'm' : $ value *= 1024 ; case 'k' : $ value *= 1024 ; break ; } return $ value ; }
5375	protected function createInputTag ( $ attributes ) { if ( ! isset ( $ attributes [ 'type' ] ) ) { return new SimpleTextTag ( $ attributes ) ; } $ type = strtolower ( trim ( $ attributes [ 'type' ] ) ) ; $ map = array ( 'submit' => 'SimpleSubmitTag' , 'image' => 'SimpleImageSubmitTag' , 'checkbox' => 'SimpleCheckboxTag' , 'radio' => 'SimpleRadioButtonTag' , 'text' => 'SimpleTextTag' , 'hidden' => 'SimpleTextTag' , 'password' => 'SimpleTextTag' , 'file' => 'SimpleUploadTag' ) ; if ( array_key_exists ( $ type , $ map ) ) { $ tag_class = $ map [ $ type ] ; return new $ tag_class ( $ attributes ) ; } return false ; }
949	public function sanitizeShopDomain ( $ domain ) { if ( empty ( $ domain ) ) { return ; } $ configEndDomain = Config :: get ( 'shopify-app.myshopify_domain' ) ; $ domain = strtolower ( preg_replace ( '/https?:\/\//i' , '' , trim ( $ domain ) ) ) ; if ( strpos ( $ domain , $ configEndDomain ) === false && strpos ( $ domain , '.' ) === false ) { $ domain .= ".{$configEndDomain}" ; } return parse_url ( "http://{$domain}" , PHP_URL_HOST ) ; }
11028	protected function address ( ) { $ this -> parts [ '{address}' ] = $ this -> form -> field ( $ this -> model , 'address' ) -> textInput ( [ 'name' => $ this -> getSubmitModelName ( 'address' ) , 'id' => $ this -> fieldIds [ 'address' ] ] ) ; }
2101	public static function getNumericDatimFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> datimFormat != '' && static :: isNumericFormat ( $ objPage -> datimFormat ) ) { return $ objPage -> datimFormat ; } } return Config :: get ( 'datimFormat' ) ; }
10817	public static function info ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'info' , $ length , $ separator ) ; }
9980	private function writeComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment , array $ pAuthors ) { $ objWriter -> startElement ( 'comment' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pCellReference ) ; $ objWriter -> writeAttribute ( 'authorId' , $ pAuthors [ $ pComment -> getAuthor ( ) ] ) ; $ objWriter -> startElement ( 'text' ) ; $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> writeRichText ( $ objWriter , $ pComment -> getText ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
6575	public function getSessionCookie ( ) : ? SetCookie { try { if ( $ this -> isStarted ( ) ) { return new SetCookie ( $ this -> getName ( ) , $ this -> getDataHolder ( ) -> getId ( ) , ( time ( ) + $ this -> getExpire ( ) * 60 ) , $ this -> getCookiePath ( ) ?? '/' , $ this -> getCookieHost ( ) ?? '' , $ this -> getCookieSecure ( ) , $ this -> isCookieHttpOnly ( ) ) ; } else { return SetCookie :: thatDeletesCookie ( $ this -> getName ( ) ) ; } } catch ( \ Throwable $ exception ) { throw new SessionManagerException ( "Error while preparing the session cookie" , $ this , null , $ exception ) ; } }
9151	public function getSelectOptions ( ) { $ filter = new UnderscoreToCamelCase ( ) ; $ funcName = "get" . ucfirst ( $ filter -> filter ( $ this -> getUserColumn ( ) ) ) ; $ resultSet = $ this -> fetchAll ( array ( 'user_id' , $ this -> getUserColumn ( ) ) , function ( Select $ select ) { $ select -> where -> notEqualTo ( 'user_id' , $ this -> getCurrentUser ( ) -> getId ( ) ) ; } ) ; $ options = array ( ) ; foreach ( $ resultSet as $ user ) { $ options [ $ user -> getId ( ) ] = $ user -> $ funcName ( ) ; } return $ options ; }
4223	public function getCfg ( $ key = null ) { if ( ! \ strlen ( $ key ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ key ] ) ) { return $ this -> cfg [ $ key ] ; } return null ; }
1009	public static function defaultFieldResolver ( $ source , $ args , $ context , ResolveInfo $ info ) { $ fieldName = $ info -> fieldName ; $ property = null ; if ( is_array ( $ source ) || $ source instanceof ArrayAccess ) { if ( isset ( $ source [ $ fieldName ] ) ) { $ property = $ source [ $ fieldName ] ; } } elseif ( is_object ( $ source ) ) { if ( isset ( $ source -> { $ fieldName } ) ) { $ property = $ source -> { $ fieldName } ; } } return $ property instanceof Closure ? $ property ( $ source , $ args , $ context , $ info ) : $ property ; }
735	protected function getDirectPermissionsByUser ( $ userId ) { $ permissions = [ ] ; foreach ( $ this -> getAssignments ( $ userId ) as $ name => $ assignment ) { $ permission = $ this -> items [ $ assignment -> roleName ] ; if ( $ permission -> type === Item :: TYPE_PERMISSION ) { $ permissions [ $ name ] = $ permission ; } } return $ permissions ; }
4341	public function end ( ) { \ unregister_tick_function ( array ( $ this , 'tickFunction' ) ) ; while ( $ this -> funcStack ) { $ this -> popStack ( ) ; } \ uasort ( $ this -> data , function ( $ valA , $ valB ) { return ( $ valA [ 'totalTime' ] < $ valB [ 'totalTime' ] ) ? 1 : - 1 ; } ) ; $ data = \ array_map ( function ( $ row ) { $ row [ 'totalTime' ] = \ round ( $ row [ 'totalTime' ] , 6 ) ; $ row [ 'ownTime' ] = \ round ( $ row [ 'ownTime' ] , 6 ) ; return $ row ; } , $ this -> data ) ; $ this -> data = array ( ) ; $ this -> funcStack = array ( ) ; $ this -> isProfiling = false ; $ this -> rootStack = array ( ) ; return $ data ; }
10552	public function resolveApp ( ) { $ this -> determineVirtualHost ( ) ; $ path = $ this -> vhost -> getPath ( $ this -> request -> url ) ; $ resolved = $ this -> resolver -> resolve ( "app" , $ path ) ; if ( $ resolved !== null ) { if ( $ resolved [ 'ext' ] ) { $ mime = new FileType ( $ resolved [ 'ext' ] , "" ) ; if ( ! empty ( $ mime ) ) { $ str = $ mime -> getMimeType ( ) . ";q=1.5," . ( string ) $ this -> request -> accept ; $ this -> request -> setAccept ( new Accept ( $ str ) ) ; } $ this -> suffix = $ resolved [ 'ext' ] ; } $ this -> route = $ resolved [ 'route' ] ; $ this -> app = $ resolved [ 'path' ] ; $ this -> arguments = new Dictionary ( $ resolved [ 'remainder' ] ) ; } else { $ this -> route = null ; $ this -> app = null ; $ this -> arguments = new Dictionary ( ) ; } }
1122	public function leaves ( ) { $ grammar = $ this -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ this -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ this -> getQualifiedLeftColumnName ( ) ) ; return $ this -> descendants ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) ; }
617	private function parseArray ( $ value , & $ i = 0 ) { $ result = [ ] ; $ len = strlen ( $ value ) ; for ( ++ $ i ; $ i < $ len ; ++ $ i ) { switch ( $ value [ $ i ] ) { case '{' : $ result [ ] = $ this -> parseArray ( $ value , $ i ) ; break ; case '}' : break 2 ; case $ this -> delimiter : if ( empty ( $ result ) ) { $ result [ ] = null ; } if ( in_array ( $ value [ $ i + 1 ] , [ $ this -> delimiter , '}' ] , true ) ) { $ result [ ] = null ; } break ; default : $ result [ ] = $ this -> parseString ( $ value , $ i ) ; } } return $ result ; }
12119	private function getCustomersMap ( ) { $ customers = $ this -> daoCustDwnl -> get ( ) ; $ result = $ this -> hlpTree -> mapById ( $ customers , ECustomer :: A_CUSTOMER_REF ) ; return $ result ; }
8026	public function remove ( ProcessDetails $ processDetails ) { $ pid = $ processDetails -> getPid ( ) ; if ( $ this -> hasProcess ( $ pid ) === FALSE ) { throw new \ InvalidArgumentException ( sprintf ( 'Could not remove process. Process (%d) not in list.' , $ processDetails -> getPid ( ) ) , 1400761297 ) ; } if ( isset ( $ this -> freeProcessIds [ $ pid ] ) ) { unset ( $ this -> freeProcessIds [ $ pid ] ) ; } if ( isset ( $ this -> sockets [ $ pid ] ) ) { unset ( $ this -> sockets [ $ pid ] ) ; } unset ( $ this -> processDetails [ $ pid ] ) ; return $ this ; }
9788	public function setConditions ( $ pValue ) { if ( ! is_array ( $ pValue ) ) { $ pValue = [ $ pValue ] ; } $ this -> condition = $ pValue ; return $ this ; }
12141	public function SignupUser ( $ moniker , $ mailer_id = null ) { $ endpoint = '/user/signup' ; $ postdata = array ( "moniker" => $ moniker , "mailer_id" => $ mailer_id ) ; return $ this -> executePostRequest ( $ endpoint , $ postdata ) ; }
1578	public static function create ( array $ data ) : self { if ( ! isset ( $ data [ 'type' ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a resource type.' ) ; } return new self ( $ data [ 'type' ] , $ data [ 'id' ] ?? null , $ data [ 'attributes' ] ?? [ ] , $ data [ 'relationships' ] ?? [ ] , $ data [ 'meta' ] ?? [ ] , $ data [ 'links' ] ?? [ ] ) ; }
2964	public function performRequest ( $ method , $ path , array $ params = [ ] ) { $ request = $ this -> buildRequest ( $ method , $ path , $ params ) ; try { $ response = $ this -> httpClient -> send ( $ request ) ; $ content = json_decode ( $ response -> getBody ( ) -> getContents ( ) , true ) ; } catch ( ClientException $ ex ) { if ( $ ex -> getResponse ( ) -> getStatusCode ( ) == 401 ) { if ( $ this -> isPsr7Version ( ) ) { $ uri = $ request -> getUri ( ) ; } else { $ uri = $ request -> getUrl ( ) ; } $ message = sprintf ( 'Unauthorized %s Request to %s' , $ request -> getMethod ( ) , $ uri ) ; throw new UnauthorizedRequestException ( $ message ) ; } throw $ ex ; } return $ this -> createResponseFromData ( $ content ) ; }
10246	public static function ascToUcs ( $ ascii ) { $ rawname = '' ; $ iMax = strlen ( $ ascii ) ; for ( $ i = 0 ; $ i < $ iMax ; ++ $ i ) { $ rawname .= $ ascii [ $ i ] . "\x00" ; } return $ rawname ; }
4438	public function create ( string $ className , string $ performMethod = 'perform' ) { if ( class_exists ( $ className ) == false ) { throw new InvalidArgumentException ( "Could not find job class {$className}." ) ; } if ( method_exists ( $ className , $ performMethod ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Job class "%s" does not contain perform method "%s".' , $ className , $ performMethod ) ) ; } $ instance = new $ className ; if ( $ instance instanceof EventsManagerAwareInterface ) { $ instance -> setEventsManager ( $ this -> getEventsManager ( ) ) ; } return $ instance ; }
4411	public function process ( ContainerBuilder $ container ) { if ( ! $ container -> has ( 'netgen_admin_ui.menu_plugin.registry' ) ) { return ; } $ menuPluginRegistry = $ container -> findDefinition ( 'netgen_admin_ui.menu_plugin.registry' ) ; $ menuPlugins = $ container -> findTaggedServiceIds ( 'netgen_admin_ui.menu_plugin' ) ; $ flattenedMenuPlugins = array ( ) ; foreach ( $ menuPlugins as $ identifier => $ menuPlugin ) { $ flattenedMenuPlugins [ $ identifier ] = isset ( $ menuPlugin [ 0 ] [ 'priority' ] ) ? $ menuPlugin [ 0 ] [ 'priority' ] : 0 ; } arsort ( $ flattenedMenuPlugins ) ; foreach ( array_keys ( $ flattenedMenuPlugins ) as $ menuPlugin ) { $ menuPluginRegistry -> addMethodCall ( 'addMenuPlugin' , array ( new Reference ( $ menuPlugin ) ) ) ; } }
12175	public function addOptionalScalarArgument ( $ name , $ type , $ default ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , false , $ default ) ) ; }
9259	public function addNamedRoute ( $ name , $ httpMethod , $ routeData , $ handler ) { $ handler = array ( 'name' => $ name , 'handler' => $ handler , ) ; $ this -> addRoute ( $ httpMethod , $ routeData , $ handler ) ; }
3481	private static function includeConfigurationFile ( ) { static $ included = false ; if ( $ included ) { return ; } $ file = __DIR__ . '/config.php' ; if ( ! file_exists ( $ file ) ) { print sprintf ( 'The configuration file "%s" was not found.%sPlease copy %s/config.php.dist to %s/config.php and modify new file for set own parameters.%s' , $ file , PHP_EOL , __DIR__ , __DIR__ , PHP_EOL ) ; exit ( 1 ) ; } $ included = true ; include_once $ file ; }
7700	function MsWord_InitHeaderFooter ( ) { if ( $ this -> MsWord_HeaderFooter !== false ) return ; $ types_ok = array ( 'default' => true , 'first' => false , 'even' => false ) ; $ idx = $ this -> FileGetIdx ( 'word/settings.xml' ) ; if ( $ idx !== false ) { $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'even' ] = ( strpos ( $ Txt , '<w:evenAndOddHeaders/>' ) !== false ) ; unset ( $ Txt ) ; } $ idx = $ this -> FileGetIdx ( 'word/document.xml' ) ; if ( $ idx === false ) return false ; $ Txt = $ this -> TbsStoreGet ( $ idx , 'GetHeaderFooterFile' ) ; $ types_ok [ 'first' ] = ( strpos ( $ Txt , '<w:titlePg/>' ) !== false ) ; $ places = array ( 'header' , 'footer' ) ; $ files = array ( ) ; $ rels = $ this -> OpenXML_Rels_GetObj ( 'word/document.xml' , '' ) ; foreach ( $ places as $ place ) { $ p = 0 ; $ entity = 'w:' . $ place . 'Reference' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ entity , $ p ) ) { $ p = $ loc -> PosEnd ; $ type = $ loc -> GetAttLazy ( 'w:type' ) ; if ( isset ( $ types_ok [ $ type ] ) && $ types_ok [ $ type ] ) { $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( isset ( $ rels -> TargetLst [ $ rid ] ) ) { $ target = $ rels -> TargetLst [ $ rid ] ; $ files [ ] = array ( 'file' => ( 'word/' . $ target ) , 'type' => $ type , 'place' => $ place ) ; } } } } $ this -> MsWord_HeaderFooter = $ files ; }
2902	public function downloadAction ( ) { $ type = $ this -> getRequest ( ) -> getParam ( 'type' , 'xml' ) ; $ configNode = Mage :: app ( ) -> getConfig ( ) -> getNode ( ) ; switch ( $ type ) { case 'txt' ; $ this -> downloadAsText ( $ configNode ) ; break ; case 'xml' : default : $ this -> downloadAsXml ( $ configNode ) ; } }
3010	public function setConsumer ( $ consumerKey , $ consumerSecret ) { $ this -> apiKey = $ consumerKey ; $ this -> requestHandler -> setConsumer ( $ consumerKey , $ consumerSecret ) ; }
331	public function mset ( $ items , $ duration = 0 , $ dependency = null ) { return $ this -> multiSet ( $ items , $ duration , $ dependency ) ; }
5958	public function clientGetById ( $ clid ) { if ( ! array_key_exists ( ( string ) $ clid , $ this -> clientList ( ) ) ) { throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; } return $ this -> clientList [ intval ( ( string ) $ clid ) ] ; }
1836	public static function findMultipleByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ arrRegistered = array ( ) ; $ arrUnregistered = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( empty ( $ arrOptions ) ) { $ arrRegistered [ $ intId ] = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ intId ) ; } if ( ! isset ( $ arrRegistered [ $ intId ] ) ) { $ arrUnregistered [ ] = $ intId ; } } if ( ! empty ( $ arrUnregistered ) ) { $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'column' => array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrUnregistered ) ) . ")" ) , 'value' => null , 'order' => Database :: getInstance ( ) -> findInSet ( "$t.id" , $ arrIds ) , 'return' => 'Collection' ) , $ arrOptions ) ; $ objMissing = static :: find ( $ arrOptions ) ; if ( $ objMissing !== null ) { while ( $ objMissing -> next ( ) ) { $ intId = $ objMissing -> { static :: $ strPk } ; $ arrRegistered [ $ intId ] = $ objMissing -> current ( ) ; } } } $ arrRegistered = array_filter ( array_values ( $ arrRegistered ) ) ; if ( empty ( $ arrRegistered ) ) { return null ; } return static :: createCollection ( $ arrRegistered , static :: $ strTable ) ; }
9789	public function setBottomRightPosition ( $ cell , $ xOffset = null , $ yOffset = null ) { $ this -> bottomRightCellRef = $ cell ; if ( $ xOffset !== null ) { $ this -> setBottomRightXOffset ( $ xOffset ) ; } if ( $ yOffset !== null ) { $ this -> setBottomRightYOffset ( $ yOffset ) ; } return $ this ; }
5740	protected static function logDuration ( Request $ request , Response $ response , $ startTime ) { $ duration = microtime ( true ) - $ startTime ; $ tags = [ "status_code" => $ response -> getStatusCode ( ) ] ; if ( ! config ( 'datadog-helper.middleware_disable_url_tag' , false ) ) { $ tags [ "url" ] = $ request -> getSchemeAndHttpHost ( ) . $ request -> getRequestUri ( ) ; } Datadog :: timing ( 'request_time' , $ duration , 1 , $ tags ) ; }
3620	public function setFanEveryDaySchedule ( $ start_hour , $ end_hour , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ data = json_encode ( array ( 'fan_duty_start_time' => $ start_hour * 3600 , 'fan_duty_end_time' => $ end_hour * 3600 ) ) ; return $ this -> doPOST ( "/v2/put/device." . $ serial_number , $ data ) ; }
986	public function confirmationUrl ( ) { $ charge = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}.json" , [ "{$this->plan->typeAsString()}" => $ this -> chargeParams ( ) ] ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ charge -> confirmation_url ; }
500	protected function readString ( $ fileHandle , $ length , $ offset = null ) { if ( $ offset !== null ) { fseek ( $ fileHandle , $ offset ) ; } return $ this -> readBytes ( $ fileHandle , $ length ) ; }
7019	private function formatH ( & $ str ) { if ( strstr ( $ str , '%H' ) ) $ str = str_replace ( '%H' , sprintf ( '%02d' , $ this -> hour ) , $ str ) ; }
8040	public function buildEventDates ( array $ data ) { $ dates = [ ] ; $ eventLength = $ this -> calculateEventLength ( $ data ) ; $ allDay = array_key_exists ( 'all_day' , $ data ) ; foreach ( $ data [ 'repeat_dates' ] as $ date ) { if ( strlen ( $ date ) > 0 ) { $ date = strtotime ( $ date . ' ' . $ data [ 'start' ] [ 'time' ] ) ; if ( false === $ date ) { throw new InvalidDateStringException ( 'Invalid date string!' ) ; } $ eventStart = $ this -> carbon -> copy ( ) -> setTimestamp ( $ date ) ; $ eventEnds = $ allDay ? null : $ eventStart -> copy ( ) -> addSeconds ( $ eventLength ) ; $ dates [ ] = [ 'start' => $ eventStart -> toDateTimeString ( ) , 'end' => ( null !== $ eventEnds ) ? $ eventEnds -> toDateTimeString ( ) : null , ] ; } } return $ dates ; }
10919	public static function getArray ( $ language ) { $ fileName = __DIR__ . '/stop-words/' . $ language . '.txt' ; if ( file_exists ( $ fileName ) ) { return array_map ( 'trim' , file ( $ fileName ) ) ; } return [ ] ; }
1428	public static function createMany ( array $ input ) { $ errors = new ErrorCollection ( ) ; foreach ( $ input as $ item ) { $ errors -> add ( self :: create ( $ item ) ) ; } return $ errors ; }
9368	protected function globals ( Configuration $ config ) { $ cookies = $ config -> get ( 'app.http.cookies' , array ( ) ) ; $ files = $ config -> get ( 'app.http.files' , array ( ) ) ; $ get = $ config -> get ( 'app.http.get' , array ( ) ) ; $ post = $ config -> get ( 'app.http.post' , array ( ) ) ; $ server = $ config -> get ( 'app.http.server' , $ this -> server ( ) ) ; return array ( $ server , $ cookies , $ get , $ files , $ post ) ; }
6972	private function buildEntity ( ClassMetadata $ metadata , $ data ) { $ class = $ metadata -> getName ( ) ; $ entity = new $ class ; foreach ( $ data as $ propertyPath => $ value ) { if ( $ metadata -> hasField ( $ propertyPath ) ) { $ builtValue = $ this -> buildFieldValue ( $ metadata , $ propertyPath , $ value ) ; } elseif ( $ metadata -> hasAssociation ( $ propertyPath ) ) { $ builtValue = $ this -> buildAssociationValue ( $ metadata , $ propertyPath , $ value ) ; } else { throw new \ Exception ( "Unexpected property path '$propertyPath' for class '$class'." ) ; } $ this -> accessor -> setValue ( $ entity , $ propertyPath , $ builtValue ) ; } return $ entity ; }
3120	public function remove ( $ tag , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; $ removed = 0 ; foreach ( $ this -> points as $ idx => $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { unset ( $ this -> points [ $ idx ] ) ; $ removed ++ ; } } return $ removed ; }
3429	protected function propsMustBeSelected ( ) { return in_array ( 'PROPS' , $ this -> select ) || in_array ( 'PROPERTIES' , $ this -> select ) || in_array ( 'PROPERTY_VALUES' , $ this -> select ) ; }
7621	public function permissionMatchesRequest ( $ permissionUrl = '' , $ requestUrl = '' , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ ) { $ requiredResourceType = $ resourceType ; if ( $ requiredResourceType == Storage :: RESOURCE_BLOB ) { $ requiredResourceType .= Storage :: RESOURCE_CONTAINER ; } $ parsedPermissionUrl = parse_url ( $ permissionUrl ) ; $ permissionParts = explode ( '&' , $ parsedPermissionUrl [ 'query' ] ) ; $ parsedRequestUrl = parse_url ( $ requestUrl ) ; $ matches = true ; foreach ( $ permissionParts as $ part ) { list ( $ property , $ value ) = explode ( '=' , $ part , 2 ) ; if ( $ property == 'sr' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredResourceType ) !== false ) ; } if ( $ property == 'sp' ) { $ matches = $ matches && ( strpbrk ( $ value , $ requiredPermission ) !== false ) ; } } $ matches = $ matches && ( strpos ( $ parsedRequestUrl [ 'path' ] , $ parsedPermissionUrl [ 'path' ] ) !== false ) ; return $ matches ; }
8644	public function getReportRequestCount ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestCountRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestCountRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestCount ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestCountResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3566	public function setAttribute ( ) { return function ( $ next , $ value , $ args ) { $ key = $ args -> get ( 'key' ) ; if ( ! $ this -> hasColumn ( $ key ) && $ this -> allowsMeta ( $ key ) && ! $ this -> hasSetMutator ( $ key ) ) { return $ this -> setMeta ( $ key , $ value ) ; } return $ next ( $ value , $ args ) ; } ; }
100	public function set ( $ prefix , $ paths ) { if ( ! $ prefix ) { $ this -> fallbackDirsPsr0 = ( array ) $ paths ; } else { $ this -> prefixesPsr0 [ $ prefix [ 0 ] ] [ $ prefix ] = ( array ) $ paths ; } }
5024	private function findLeaf ( NodeInterface $ leaf , $ value ) { $ parts = is_array ( $ value ) ? $ value : explode ( $ this -> shouldUseNames ( ) ? ' | ' : '-' , $ value ) ; $ value = array_shift ( $ parts ) ; foreach ( $ leaf -> getChildren ( ) as $ item ) { $ compare = $ this -> shouldUseNames ( ) ? $ item -> getName ( ) : $ item -> getValue ( ) ; if ( $ compare == $ value ) { if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ item , $ parts ) ; } return $ item ; } } if ( $ value && $ this -> shouldCreateLeafs ( ) ) { $ nodeClass = get_class ( $ leaf ) ; $ node = new $ nodeClass ( $ value ) ; $ leaf -> addChild ( $ node ) ; if ( count ( $ parts ) ) { return $ this -> findLeaf ( $ node , $ parts ) ; } return $ node ; } return null ; }
6267	public static function open ( $ fileName ) { return Reader :: haveExtension ( ) ? new Writer \ DBA ( $ fileName ) : new Writer \ PHP ( $ fileName ) ; }
115	public function execute ( $ command , $ url , $ cwd = null , $ path = null , $ verbose = false ) { $ this -> config -> prohibitUrlByConfig ( $ url , $ this -> io ) ; return $ this -> executeWithAuthRetry ( $ command , $ cwd , $ url , $ path , $ verbose ) ; }
3817	private function fetchExisting ( $ table , $ parentId ) { $ this -> startSort = 0 ; $ this -> knownAttributes = [ ] ; $ alreadyExisting = $ this -> connection -> createQueryBuilder ( ) -> select ( '*' ) -> from ( $ table ) -> where ( 'pid=:pid' ) -> setParameter ( 'pid' , $ parentId ) -> orderBy ( 'sorting' ) -> execute ( ) ; foreach ( $ alreadyExisting -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ this -> knownAttributes [ $ item [ 'attr_id' ] ] = $ item ; $ this -> startSort = $ item [ 'sorting' ] ; } return $ this -> knownAttributes ; }
683	private function normalizeComplexFilter ( array $ filter ) { $ result = [ ] ; foreach ( $ filter as $ key => $ value ) { if ( isset ( $ this -> filterControls [ $ key ] ) ) { $ key = $ this -> filterControls [ $ key ] ; } elseif ( isset ( $ this -> attributeMap [ $ key ] ) ) { $ key = $ this -> attributeMap [ $ key ] ; } if ( is_array ( $ value ) ) { $ result [ $ key ] = $ this -> normalizeComplexFilter ( $ value ) ; } else { $ result [ $ key ] = $ value ; } } return $ result ; }
4460	private function fork ( & $ socket ) : int { $ pair = [ ] ; $ domain = ( strtoupper ( substr ( PHP_OS , 0 , 3 ) ) == 'WIN' ? AF_INET : AF_UNIX ) ; if ( \ socket_create_pair ( $ domain , SOCK_STREAM , 0 , $ pair ) === false ) { $ error = socket_strerror ( socket_last_error ( $ pair [ 0 ] ?? null ) ) ; $ this -> logger -> error ( '{type}: unable to create socket pair; ' . $ error , $ this -> logContext ) ; exit ( 0 ) ; } $ pid = pcntl_fork ( ) ; if ( $ pid === - 1 ) { throw new RuntimeException ( 'Unable to fork child worker.' ) ; } if ( $ pid !== 0 ) { $ this -> childProcesses ++ ; $ socket = $ pair [ 0 ] ; socket_close ( $ pair [ 1 ] ) ; socket_set_option ( $ socket , SOL_SOCKET , SO_RCVTIMEO , [ 'sec' => 0 , 'usec' => 10000 ] ) ; return $ pid ; } $ socket = $ pair [ 1 ] ; socket_close ( $ pair [ 0 ] ) ; register_shutdown_function ( $ this -> handleChildErrors ( $ socket ) ) ; return $ pid ; }
12960	public function query ( $ sql , $ return = false ) { $ query = $ this -> getDb ( ) -> query ( $ sql , true ) ; if ( $ return ) { return $ query ; } }
6668	public function respond ( ) { if ( is_null ( $ this -> preparedResponse ) ) { $ this -> prepareResponse ( ) ; } if ( $ this -> status instanceof Status ) { header ( $ this -> status -> getHttpHeader ( ) ) ; } header ( "Content-Type: {$this->writer->getContentType()}" ) ; echo $ this -> preparedResponse ; return $ this ; }
3242	public function getDisplayNameAttribute ( ) { if ( $ this -> hasObject ) return $ this -> object -> displayName ; return isset ( $ this -> itemName ) ? $ this -> attributes [ $ this -> itemName ] : ( array_key_exists ( 'name' , $ this -> attributes ) ? $ this -> attributes [ 'name' ] : '' ) ; }
7628	public function getContainerAcl ( $ containerName = '' , $ signedIdentifiers = false ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ response = $ this -> performRequest ( $ containerName , array ( 'restype' => 'container' , 'comp' => 'acl' ) , 'GET' , array ( ) , false , null , self :: RESOURCE_CONTAINER , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } if ( $ signedIdentifiers == false ) { $ accessType = $ response -> getHeader ( Storage :: PREFIX_STORAGE_HEADER . 'blob-public-access' ) ; if ( strtolower ( $ accessType ) == 'true' ) { $ accessType = self :: ACL_PUBLIC_CONTAINER ; } return $ accessType ; } $ result = $ this -> parseResponse ( $ response ) ; if ( ! $ result ) { return array ( ) ; } $ entries = null ; if ( $ result -> SignedIdentifier ) { if ( count ( $ result -> SignedIdentifier ) > 1 ) { $ entries = $ result -> SignedIdentifier ; } else { $ entries = array ( $ result -> SignedIdentifier ) ; } } $ returnValue = array ( ) ; foreach ( $ entries as $ entry ) { $ returnValue [ ] = new SignedIdentifier ( $ entry -> Id , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Start ? $ entry -> AccessPolicy -> Start : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Expiry ? $ entry -> AccessPolicy -> Expiry : '' : '' , $ entry -> AccessPolicy ? $ entry -> AccessPolicy -> Permission ? $ entry -> AccessPolicy -> Permission : '' : '' ) ; } return $ returnValue ; }
7564	protected function parse_compare ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { switch ( $ this -> doc [ $ this -> pos ++ ] ) { case '$' : return ( $ this -> token = self :: TOK_COMPARE_ENDS ) ; case '%' : return ( $ this -> token = self :: TOK_COMPARE_REGEX ) ; case '^' : return ( $ this -> token = self :: TOK_COMPARE_STARTS ) ; case '<' : return ( $ this -> token = self :: TOK_COMPARE_SMALLER_THAN ) ; } } return false ; }
12922	public function getForeignDataItems ( ) { if ( ! isset ( $ this -> _foreignDataItems ) ) { $ this -> _foreignDataItems = [ ] ; $ this -> trigger ( self :: EVENT_LOAD_FOREIGN_DATA_ITEMS ) ; } return $ this -> _foreignDataItems ; }
5229	public static function forName ( $ name ) { $ enum = new \ ReflectionClass ( get_called_class ( ) ) ; try { return $ enum -> getStaticPropertyValue ( $ name ) ; } catch ( \ ReflectionException $ re ) { throw new \ InvalidArgumentException ( $ re -> getMessage ( ) ) ; } }
9388	public function prefix ( $ prefix = '' , $ namespace = '' ) { $ namespace === '' && $ namespace = ( string ) $ this -> namespace ; $ prefix && $ prefix [ 0 ] !== '/' && $ prefix = '/' . $ prefix ; $ namespace = str_replace ( '\\\\' , '\\' , $ namespace . '\\' ) ; $ this -> prefix = ( string ) $ prefix ; $ this -> namespace = ltrim ( $ namespace , '\\' ) ; return $ this ; }
2737	private function setServiceID ( $ serviceId ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_SERVICE_ID , $ serviceId ) ; $ this -> output -> writeln ( '<info>Service ID updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
5842	public function getAdditionalFields ( array & $ taskInfo , $ task , \ TYPO3 \ CMS \ Scheduler \ Controller \ SchedulerModuleController $ parentObject ) { $ editCommand = version_compare ( TYPO3_branch , '9.5' , '>=' ) ? $ parentObject -> getCurrentAction ( ) === Action :: EDIT : $ parentObject -> CMD === 'edit' ; if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ this -> defaultDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_directories' ] = $ task -> directories ; } } if ( ! isset ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ this -> defaultExcludeDirectories ; if ( $ editCommand ) { $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] = $ task -> excludeDirectories ; } } $ additionalFields = [ ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_directories]' ; $ fieldId = 'scheduler_batchResize_directories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_directories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.directories' , ] ; $ fieldName = 'tx_scheduler[scheduler_batchResize_excludeDirectories]' ; $ fieldId = 'scheduler_batchResize_excludeDirectories' ; $ fieldValue = trim ( $ taskInfo [ 'scheduler_batchResize_excludeDirectories' ] ) ; $ fieldHtml = '<textarea class="form-control" rows="4" name="' . $ fieldName . '" id="' . $ fieldId . '">' . htmlspecialchars ( $ fieldValue ) . '</textarea>' ; $ additionalFields [ $ fieldId ] = [ 'code' => $ fieldHtml , 'label' => 'LLL:EXT:image_autoresize/Resources/Private/Language/locallang_mod.xlf:label.batchResize.excludeDirectories' , ] ; return $ additionalFields ; }
8505	public function createInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_CreateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'CreateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_CreateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4013	protected function calculate ( ) { if ( ! $ this -> isDirty ( ) ) { return ; } $ this -> isDirty = false ; $ this -> calculatedOffset = null ; $ this -> calculatedLimit = null ; if ( $ this -> isLimited ( ) ) { if ( $ this -> getLimit ( ) ) { $ this -> calculatedLimit = $ this -> getLimit ( ) ; } if ( $ this -> getOffset ( ) ) { $ this -> calculatedOffset = $ this -> getOffset ( ) ; } } if ( $ this -> getPerPage ( ) > 0 ) { $ this -> calculatePaginated ( ) ; return ; } if ( $ this -> calculatedLimit === null ) { $ this -> calculatedLimit = 0 ; } if ( $ this -> calculatedOffset === null ) { $ this -> calculatedOffset = 0 ; } }
1426	protected function convertIncludePath ( $ path ) { if ( array_key_exists ( $ path , $ this -> includePaths ) ) { return $ this -> includePaths [ $ path ] ? : null ; } return collect ( explode ( '.' , $ path ) ) -> map ( function ( $ segment ) { return $ this -> modelRelationForField ( $ segment ) ; } ) -> implode ( '.' ) ; }
3278	public function getAll ( ) : array { $ data = [ ] ; $ file = $ this -> getDatabase ( ) -> readFromFile ( ) ; foreach ( $ file as $ line ) { $ data [ $ line -> getKey ( ) ] = $ this -> decodeData ( $ line -> getData ( ) ) ; } return $ data ; }
6406	protected function forceScriptCache ( $ fileName ) { if ( ( PHP_SAPI !== 'cli' && ini_get ( 'opcache.enable' ) ) || ini_get ( 'opcache.enable_cli' ) ) { opcache_invalidate ( $ fileName , true ) ; opcache_compile_file ( $ fileName ) ; } if ( ini_get ( 'apc.enabled' ) ) { apc_delete_file ( $ fileName ) ; apc_bin_loadfile ( $ fileName ) ; } }
494	public function flush ( $ final = false ) { $ messages = $ this -> messages ; $ this -> messages = [ ] ; if ( $ this -> dispatcher instanceof Dispatcher ) { $ this -> dispatcher -> dispatch ( $ messages , $ final ) ; } }
2444	public static function decrypt ( $ varValue , $ strKey = null ) { if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: decrypt ( $ v ) ; } return $ varValue ; } elseif ( $ varValue == '' ) { return '' ; } if ( static :: $ resTd === null ) { static :: initialize ( ) ; } $ varValue = base64_decode ( $ varValue ) ; $ ivsize = mcrypt_enc_get_iv_size ( static :: $ resTd ) ; $ iv = substr ( $ varValue , 0 , $ ivsize ) ; $ varValue = substr ( $ varValue , $ ivsize ) ; if ( $ varValue == '' ) { return '' ; } if ( ! $ strKey ) { $ strKey = System :: getContainer ( ) -> getParameter ( 'contao.encryption_key' ) ; } mcrypt_generic_init ( static :: $ resTd , md5 ( $ strKey ) , $ iv ) ; $ strDecrypted = mdecrypt_generic ( static :: $ resTd , $ varValue ) ; mcrypt_generic_deinit ( static :: $ resTd ) ; return $ strDecrypted ; }
7084	public function delete_cookie ( $ name ) { unset ( $ _COOKIE [ $ name ] ) ; return setcookie ( $ name , null , - 86400 , $ this -> cookie_path , $ this -> cookie_domain , $ this -> cookie_secure , $ this -> cookie_httponly ) ; }
963	public function postProcess ( ) { if ( ! $ this -> shop -> trashed ( ) ) { return ; } $ this -> shop -> restore ( ) ; $ this -> shop -> charges ( ) -> restore ( ) ; $ this -> shop -> save ( ) ; }
10364	public function offsetSet ( $ item , $ node ) { if ( $ item !== null ) { throw new ValueException ( $ item , 'null' ) ; } return $ this -> nodes [ ] = $ node ; }
6582	public static function getSession ( ServerRequestInterface $ request ) : SessionDataHolder { $ session = $ request -> getAttribute ( static :: REQ_ATTR ) ; if ( ! $ session instanceof SessionDataHolder ) { throw new SessionMiddlewareException ( "No session object is available in the request attributes" ) ; } return $ session ; }
11153	public function getBoolean ( $ probability = 0.5 ) { if ( ( \ is_int ( $ probability ) || \ is_float ( $ probability ) ) === false || $ probability < 0 || $ probability > 1 ) { throw new InvalidArgumentException ( 'Invalid probability' ) ; } if ( $ probability == 0 ) { $ result = false ; } else { $ random = $ this -> generator -> getFloat ( 0 , 1 ) ; $ result = ( $ probability >= $ random ) ; } return $ result ; }
6753	public static function installWebServer ( ) { $ appPath = __DIR__ . '/../../../..' ; self :: createFolderIfNotExists ( "$appPath/web" ) ; self :: createCopy ( __DIR__ , 'app.php' , "$appPath/web" , 'app.php' ) ; self :: createCopy ( __DIR__ , 'app_dev.php' , "$appPath/web" , 'app_dev.php' ) ; }
6187	public function assign ( $ name , $ value ) { if ( ! isset ( $ this -> view ) ) { throw new ViewException ( 'Please Define view engine in app/View.php' , 500 ) ; } return $ this -> view -> assign ( $ name , $ value ) ; }
4365	public function onErrorHighPri ( Event $ error ) { $ this -> throttleDataRead ( ) ; $ hash = $ error [ 'hash' ] ; $ error [ 'email' ] = ( $ error [ 'type' ] & $ this -> cfg [ 'emailMask' ] ) && $ error [ 'isFirstOccur' ] && $ this -> cfg [ 'emailTo' ] ; $ error [ 'stats' ] = array ( 'tsEmailed' => 0 , 'countSince' => 0 , 'emailedTo' => '' , ) ; if ( isset ( $ this -> throttleData [ 'errors' ] [ $ hash ] ) ) { $ stats = \ array_intersect_key ( $ this -> throttleData [ 'errors' ] [ $ hash ] , $ error [ 'stats' ] ) ; $ error [ 'stats' ] = \ array_merge ( $ error [ 'stats' ] , $ stats ) ; } return ; }
381	public function createServerInformationLink ( ) { $ serverUrls = [ 'http://httpd.apache.org/' => [ 'apache' ] , 'http://nginx.org/' => [ 'nginx' ] , 'http://lighttpd.net/' => [ 'lighttpd' ] , 'http://gwan.com/' => [ 'g-wan' , 'gwan' ] , 'http://iis.net/' => [ 'iis' , 'services' ] , 'https://secure.php.net/manual/en/features.commandline.webserver.php' => [ 'development' ] , ] ; if ( isset ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) ) { foreach ( $ serverUrls as $ url => $ keywords ) { foreach ( $ keywords as $ keyword ) { if ( stripos ( $ _SERVER [ 'SERVER_SOFTWARE' ] , $ keyword ) !== false ) { return '<a href="' . $ url . '" target="_blank">' . $ this -> htmlEncode ( $ _SERVER [ 'SERVER_SOFTWARE' ] ) . '</a>' ; } } } } return '' ; }
5130	protected function withString ( string $ string , string $ name = 'query' ) : self { $ string = ltrim ( ( string ) $ string , '#' ) ; $ clone = clone $ this ; $ clone -> { $ name } = $ this -> filterQuery ( $ string ) ; return $ clone ; }
8547	public function setPayWithAmazonEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PayWithAmazonEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6894	protected function compareStockUnitByPrice ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasPrice = 0 < $ u1 -> getNetPrice ( ) ; $ u2HasPrice = 0 < $ u2 -> getNetPrice ( ) ; if ( ! $ u1HasPrice && $ u2HasPrice ) { return 1 ; } if ( $ u1HasPrice && ! $ u2HasPrice ) { return - 1 ; } if ( $ u1 -> getNetPrice ( ) != $ u2 -> getNetPrice ( ) ) { return $ u1 -> getNetPrice ( ) > $ u2 -> getNetPrice ( ) ? 1 : - 1 ; } return 0 ; }
12965	public function getIcon ( ) { if ( is_null ( $ this -> _icon ) && isset ( $ this -> object ) ) { $ this -> _icon = [ 'class' => $ this -> object -> objectType -> icon , 'title' => $ this -> objectTypeDescriptor ] ; } return $ this -> _icon ; }
12455	public function hasToolbar ( ) { $ fileSkeleton = '/Resources/views/Editor/Toolbar/_toolbar_%s_buttons.html.twig' ; return file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'left' ) ) || file_exists ( $ this -> pluginDir . sprintf ( $ fileSkeleton , 'right' ) ) ; }
6369	public static function compose ( callable $ g , callable $ f ) : callable { return function ( $ input ) use ( $ g , $ f ) { return Functions :: call ( $ g , Functions :: call ( $ f , $ input ) ) ; } ; }
3479	public function withActionLocalized ( Localized $ localized ) : Alert { $ cloned = clone $ this ; $ cloned -> actionLocalized = $ localized ; return $ cloned ; }
831	private function fixConstructor ( Tokens $ tokens , $ className , $ classStart , $ classEnd ) { $ php4 = $ this -> findFunction ( $ tokens , $ className , $ classStart , $ classEnd ) ; if ( null === $ php4 ) { return ; } if ( ! empty ( $ php4 [ 'modifiers' ] [ T_ABSTRACT ] ) || ! empty ( $ php4 [ 'modifiers' ] [ T_STATIC ] ) ) { return ; } $ php5 = $ this -> findFunction ( $ tokens , '__construct' , $ classStart , $ classEnd ) ; if ( null === $ php5 ) { $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; $ this -> fixInfiniteRecursion ( $ tokens , $ php4 [ 'bodyIndex' ] , $ php4 [ 'endIndex' ] ) ; return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , '__construct' , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php4 [ 'bodyIndex' ] - 1 , $ php4 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php4 [ 'startIndex' ] ; $ i <= $ php4 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } return ; } list ( $ seq , $ case ) = $ this -> getWrapperMethodSequence ( $ tokens , $ className , $ php4 [ 'startIndex' ] , $ php4 [ 'bodyIndex' ] ) ; if ( null !== $ tokens -> findSequence ( $ seq , $ php5 [ 'bodyIndex' ] - 1 , $ php5 [ 'endIndex' ] , $ case ) ) { for ( $ i = $ php5 [ 'startIndex' ] ; $ i <= $ php5 [ 'endIndex' ] ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens [ $ php4 [ 'nameIndex' ] ] = new Token ( [ T_STRING , '__construct' ] ) ; } }
2123	public function addMultiple ( array $ arrFiles , $ strVersion = null , $ strMedia = 'screen' ) { foreach ( $ arrFiles as $ strFile ) { $ this -> add ( $ strFile , $ strVersion , $ strMedia ) ; } }
4000	protected function loadMetaModel ( $ nameOrId ) { if ( is_numeric ( $ nameOrId ) ) { $ tableName = $ this -> getServiceContainer ( ) -> getFactory ( ) -> translateIdToMetaModelName ( $ nameOrId ) ; } elseif ( is_string ( $ nameOrId ) ) { $ tableName = $ nameOrId ; } if ( isset ( $ tableName ) ) { return $ this -> getServiceContainer ( ) -> getFactory ( ) -> getMetaModel ( $ tableName ) ; } return null ; }
4486	public function broadcast ( Message $ message , ? string $ platform = null ) { if ( null !== $ platform && ! isset ( $ this -> arns [ $ platform ] ) ) { throw new PlatformNotConfiguredException ( "There is no configured ARN for $platform" ) ; } if ( $ platform ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } else { foreach ( $ this -> arns as $ platform => $ arn ) { $ this -> broadcastToPlatform ( $ message , $ platform ) ; } } }
10383	protected static function compress_files ( $ content ) { $ var = array ( "\r\n" , "\r" , "\n" , "\t" , ' ' , ' ' , ' ' ) ; $ content = preg_replace ( '!/\*[^*]*\*+([^/][^*]*\*+)*/!' , '' , $ content ) ; $ content = str_replace ( $ var , '' , $ content ) ; $ content = str_replace ( '{ ' , '{' , $ content ) ; $ content = str_replace ( ' }' , '}' , $ content ) ; $ content = str_replace ( '; ' , ';' , $ content ) ; return $ content ; }
3940	private function setEmptyValue ( PropertyInterface $ property , array $ propInfo ) { if ( ! array_key_exists ( 'empty_value' , $ propInfo ) || ! ( $ property instanceof EmptyValueAwarePropertyInterface ) ) { return ; } $ property -> setEmptyValue ( $ propInfo [ 'empty_value' ] ) ; }
7915	public function registerClientScript ( ) { if ( $ this -> closeIcon !== false ) { $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( "dosamigos.semantic.initMessageCloseButtons();" ) ; } }
7805	protected function openingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '60F|60M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createOpeningBalance ( ) , $ line ) ; } }
9841	public function createSealedJsonRequest ( string $ method , string $ uri , array $ arrayToJsonify , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSealedRequest ( $ method , $ uri , $ body , $ key , $ headers ) ; }
5469	public function overlayMessage ( $ compare , $ dumper ) { $ this -> dumper = $ dumper ; return sprintf ( $ this -> message , $ this -> testMessage ( $ compare ) ) ; }
8853	public function getCurrentCategory ( ) { $ category = $ this -> request -> param ( "Category" ) ; if ( $ category ) { return $ this -> dataRecord -> Categories ( ) -> filter ( "URLSegment" , $ category ) -> first ( ) ; } return null ; }
823	private function getPreviousUnsetCall ( Tokens $ tokens , $ index ) { $ previousUnsetSemicolon = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( null === $ previousUnsetSemicolon ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetSemicolon ] -> equals ( ';' ) ) { return $ previousUnsetSemicolon ; } $ previousUnsetBraceEnd = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetSemicolon ) ; if ( null === $ previousUnsetBraceEnd ) { return $ index ; } if ( ! $ tokens [ $ previousUnsetBraceEnd ] -> equals ( ')' ) ) { return $ previousUnsetBraceEnd ; } $ previousUnsetBraceStart = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ previousUnsetBraceEnd ) ; $ previousUnset = $ tokens -> getPrevMeaningfulToken ( $ previousUnsetBraceStart ) ; if ( null === $ previousUnset ) { return $ index ; } if ( ! $ tokens [ $ previousUnset ] -> isGivenKind ( T_UNSET ) ) { return $ previousUnset ; } return [ $ previousUnset , $ previousUnsetBraceStart , $ previousUnsetBraceEnd , $ previousUnsetSemicolon , ] ; }
370	protected function isEmpty ( $ value ) { return $ value === '' || $ value === [ ] || $ value === null || is_string ( $ value ) && trim ( $ value ) === '' ; }
6035	public function setCommands ( array $ commands ) { $ this -> commands = [ ] ; foreach ( $ commands as $ item ) { $ this -> addCommand ( $ item ) ; } return $ this ; }
4900	public static function loadDotEnv ( ) { $ dotenv = new Dotenv ( ) ; if ( is_file ( getcwd ( ) . '/.env.dist' ) ) { $ dotenv -> load ( getcwd ( ) . '/.env.dist' ) ; } if ( is_file ( $ file = getcwd ( ) . '/.env' ) ) { $ dotenv -> load ( $ file ) ; } if ( false === getenv ( 'TIMEZONE' ) ) { putenv ( 'TIMEZONE=Europe/Berlin' ) ; } date_default_timezone_set ( getenv ( 'TIMEZONE' ) ) ; }
8575	public function setItemChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10375	protected static function validate ( $ type , $ data , $ admin ) { $ place = ( isset ( $ data [ 'place' ] ) ) ? $ data [ 'place' ] : 'front' ; $ place = $ admin && 'admin' == $ place || ! $ admin && 'front' == $ place ; if ( ! $ place || self :: set_params ( $ type , $ data ) === false ) { return false ; } return true ; }
1449	protected function relationshipRules ( $ record , string $ field ) : array { return collect ( $ this -> rules ( $ record ) ) -> filter ( function ( $ v , $ key ) use ( $ field ) { return Str :: startsWith ( $ key , $ field ) ; } ) -> all ( ) ; }
2280	protected static function httpAcceptLanguage ( ) { $ arrAccepted = array ( ) ; $ arrLanguages = array ( ) ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i' , $ _SERVER [ 'HTTP_ACCEPT_LANGUAGE' ] , $ arrAccepted ) ; foreach ( $ arrAccepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(-[A-Z]{2})?$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } $ locale = $ chunks [ 0 ] ; if ( preg_match ( '/^[a-z]{2}$/' , $ locale ) ) { $ arrLanguages [ ] = $ locale ; } } return \ array_slice ( array_unique ( $ arrLanguages ) , 0 , 8 ) ; }
7697	function MsPowerpoint_SearchInSlides ( $ str , $ returnFirstFound = true ) { $ this -> MsPowerpoint_InitSlideLst ( ) ; $ files = array ( ) ; foreach ( $ this -> OpenXmlSlideLst as $ i => $ s ) $ files [ $ i + 1 ] = $ s [ 'idx' ] ; $ find = $ this -> TbsSearchInFiles ( $ files , $ str , $ returnFirstFound ) ; return $ find ; }
12348	protected function getConnectionInitializer ( OptionsInterface $ options , $ callable ) { if ( ! is_callable ( $ callable ) ) { $ class = get_called_class ( ) ; throw new \ InvalidArgumentException ( "$class expects a valid callable" ) ; } $ option = $ this ; return function ( $ parameters = null ) use ( $ callable , $ options , $ option ) { $ connection = call_user_func ( $ callable , $ options , $ parameters ) ; if ( ! $ connection instanceof AggregateConnectionInterface ) { $ class = get_class ( $ option ) ; throw new \ InvalidArgumentException ( "$class expects a valid connection type returned by callable initializer" ) ; } return $ connection ; } ; }
12865	public function clearQuota ( ) { $ appid = $ this -> getAccessToken ( ) -> getAppId ( ) ; return $ this -> parseJSON ( 'json' , [ self :: API_CLEAR_QUOTA , compact ( 'appid' ) ] ) ; }
8111	protected function queueNextRun ( ) { $ nextRun = new ContentReviewNotificationJob ( ) ; $ nextRunTime = mktime ( Config :: inst ( ) -> get ( __CLASS__ , 'next_run_hour' ) , Config :: inst ( ) -> get ( __CLASS__ , 'next_run_minute' ) , 0 , date ( "m" ) , date ( "d" ) + Config :: inst ( ) -> get ( __CLASS__ , 'next_run_in_days' ) , date ( "Y" ) ) ; singleton ( QueuedJobService :: class ) -> queueJob ( $ nextRun , date ( "Y-m-d H:i:s" , $ nextRunTime ) ) ; }
1049	public static function getVariableValues ( Schema $ schema , $ varDefNodes , array $ inputs ) { $ errors = [ ] ; $ coercedValues = [ ] ; foreach ( $ varDefNodes as $ varDefNode ) { $ varName = $ varDefNode -> variable -> name -> value ; $ varType = TypeInfo :: typeFromAST ( $ schema , $ varDefNode -> type ) ; if ( Type :: isInputType ( $ varType ) ) { if ( array_key_exists ( $ varName , $ inputs ) ) { $ value = $ inputs [ $ varName ] ; $ coerced = Value :: coerceValue ( $ value , $ varType , $ varDefNode ) ; $ coercionErrors = $ coerced [ 'errors' ] ; if ( empty ( $ coercionErrors ) ) { $ coercedValues [ $ varName ] = $ coerced [ 'value' ] ; } else { $ messagePrelude = sprintf ( 'Variable "$%s" got invalid value %s; ' , $ varName , Utils :: printSafeJson ( $ value ) ) ; foreach ( $ coercionErrors as $ error ) { $ errors [ ] = new Error ( $ messagePrelude . $ error -> getMessage ( ) , $ error -> getNodes ( ) , $ error -> getSource ( ) , $ error -> getPositions ( ) , $ error -> getPath ( ) , $ error , $ error -> getExtensions ( ) ) ; } } } else { if ( $ varType instanceof NonNull ) { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" of required type "%s" was not provided.' , $ varName , $ varType ) , [ $ varDefNode ] ) ; } elseif ( $ varDefNode -> defaultValue ) { $ coercedValues [ $ varName ] = AST :: valueFromAST ( $ varDefNode -> defaultValue , $ varType ) ; } } } else { $ errors [ ] = new Error ( sprintf ( 'Variable "$%s" expected value of type "%s" which cannot be used as an input type.' , $ varName , Printer :: doPrint ( $ varDefNode -> type ) ) , [ $ varDefNode -> type ] ) ; } } if ( ! empty ( $ errors ) ) { return [ $ errors , null ] ; } return [ null , $ coercedValues ] ; }
10702	public static function getPasswordComplexity ( $ password , $ minLength ) { $ group = [ 'upper' => '/[A-Z]/' , 'lower' => '/[a-z]/' , 'number' => '/[0-9]/' , 'special' => '/[^A-Za-z0-9]/' , ] ; $ score = 0 ; $ length = \ strlen ( $ password ) ; if ( $ length < $ minLength ) { return 0 ; } foreach ( $ group as $ pattern ) { if ( preg_match ( $ pattern , $ password ) ) { $ score ++ ; } } if ( $ score < 3 ) { $ score -- ; } if ( $ length > $ minLength ) { $ score += ( int ) floor ( ( $ length - $ minLength ) / 2 ) ; } return $ score ; }
8426	public function getAllInactiveQuery ( Production $ production ) : Query { $ qb = $ this -> createQueryBuilder ( 'p' ) ; return $ qb -> join ( 'p.groups' , 'g' ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'g' , ':group' ) ) -> andWhere ( $ qb -> expr ( ) -> isNull ( 'p.parent' ) ) -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> eq ( 'p.active' , ':active' ) , $ qb -> expr ( ) -> lt ( 'p.expiry' , ':now' ) ) ) -> setParameter ( 'group' , $ production ) -> setParameter ( 'active' , false ) -> setParameter ( 'now' , new \ DateTime ( ) ) -> addOrderBy ( 'p.updated' , 'DESC' ) -> getQuery ( ) ; }
10121	private function writeMarginBottom ( ) { $ record = 0x0029 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getBottom ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
6510	protected function initHandler ( HandlerInterface $ handler ) { if ( $ this -> formatter != null ) { $ handler -> setFormatter ( $ this -> formatter ) ; } foreach ( $ this -> processors as $ processor ) { $ handler -> pushProcessor ( $ processor ) ; } return $ handler ; }
9304	public function setFailureLogLifetime ( $ time ) { if ( ! is_numeric ( $ time ) ) { throw new \ InvalidArgumentException ( '`failureLogLifetime` expects integer value!' ) ; } $ this -> options [ 'failureLogLifetime' ] = ( int ) $ time ; return $ this ; }
7092	protected function add ( $ url , $ method , Callable $ action ) { $ url = $ this -> base !== "" && $ url === "/" ? $ this -> base : $ this -> base . $ url ; $ route = new Route ( $ url , $ method , $ action ) ; $ this -> routes [ ] = $ route ; return $ route ; }
8653	private function convertUpdateReportAcknowledgements ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'UpdateReportAcknowledgements' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportIdList ( ) ) { $ reportIdList = $ request -> getReportIdList ( ) ; foreach ( $ reportIdList -> getId ( ) as $ idIndex => $ id ) { $ parameters [ 'ReportIdList' . '.' . 'Id' . '.' . ( $ idIndex + 1 ) ] = $ id ; } } if ( $ request -> isSetAcknowledged ( ) ) { $ parameters [ 'Acknowledged' ] = $ request -> getAcknowledged ( ) ? "true" : "false" ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
7920	private function openZipFile ( $ zipFile ) { $ zipArchive = new \ ZipArchive ; if ( $ zipArchive -> open ( $ zipFile ) !== true ) { throw new \ Exception ( 'Error opening ' . $ zipFile ) ; } return $ zipArchive ; }
4202	private function addMethodsPhpDoc ( Event $ abs ) { $ inheritedFrom = null ; if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { if ( \ array_intersect_key ( $ abs [ 'methods' ] , \ array_flip ( array ( '__call' , '__callStatic' ) ) ) ) { $ reflector = $ abs [ 'reflector' ] ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ parsed = $ this -> phpDoc -> getParsed ( $ reflector ) ; if ( isset ( $ parsed [ 'method' ] ) ) { $ inheritedFrom = $ reflector -> getName ( ) ; $ abs [ 'phpDoc' ] [ 'method' ] = $ parsed [ 'method' ] ; break ; } } } if ( empty ( $ abs [ 'phpDoc' ] [ 'method' ] ) ) { return ; } } foreach ( $ abs [ 'phpDoc' ] [ 'method' ] as $ phpDocMethod ) { $ className = $ inheritedFrom ? $ inheritedFrom : $ abs [ 'className' ] ; $ abs [ 'methods' ] [ $ phpDocMethod [ 'name' ] ] = array ( 'implements' => null , 'inheritedFrom' => $ inheritedFrom , 'isAbstract' => false , 'isDeprecated' => false , 'isFinal' => false , 'isStatic' => $ phpDocMethod [ 'static' ] , 'params' => \ array_map ( function ( $ param ) use ( $ className ) { $ info = $ this -> phpDocParam ( $ param , $ className ) ; return array ( 'constantName' => $ info [ 'constantName' ] , 'defaultValue' => $ info [ 'defaultValue' ] , 'desc' => null , 'name' => $ param [ 'name' ] , 'optional' => false , 'type' => $ param [ 'type' ] , ) ; } , $ phpDocMethod [ 'param' ] ) , 'phpDoc' => array ( 'summary' => $ phpDocMethod [ 'desc' ] , 'description' => null , 'return' => array ( 'type' => $ phpDocMethod [ 'type' ] , 'desc' => null , ) ) , 'visibility' => 'magic' , ) ; } unset ( $ abs [ 'phpDoc' ] [ 'method' ] ) ; return ; }
10556	public function make ( Log $ log , $ trans = true ) { $ items = [ ] ; $ route = 'dashboard.systems.logs.show' ; foreach ( $ log -> tree ( $ trans ) as $ level => $ item ) { $ items [ $ level ] = array_merge ( $ item , [ 'url' => route ( $ route , [ $ log -> date , $ level ] ) , 'icon' => $ this -> styler -> icon ( $ level ) ? : '' , ] ) ; } return $ items ; }
8409	public static function clear ( ) { $ keys = array_keys ( $ _COOKIE ) ; foreach ( $ keys as $ key ) { setcookie ( $ key , '' , time ( ) - 1 ) ; } }
3859	public function addFilterRule ( $ objFilterRule ) { if ( ! $ this -> objFilter ) { $ this -> objFilter = $ this -> objMetaModel -> getEmptyFilter ( ) ; } $ this -> objFilter -> addFilterRule ( $ objFilterRule ) ; return $ this ; }
4673	public function getTemplateFile ( $ template ) { $ file = $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } foreach ( $ this -> paths as $ path ) { $ file = $ path . "/" . $ template . $ this -> suffix ; if ( is_file ( $ file ) ) { return $ file ; } } throw new Exception ( "Could not find template file '$template'." ) ; }
4843	public static function sortPairs ( $ a , $ b ) { $ keys = strcmp ( $ a [ 0 ] , $ b [ 0 ] ) ; if ( $ keys !== 0 ) { return $ keys ; } return strcmp ( $ a [ 1 ] , $ b [ 1 ] ) ; }
9019	public function getKeywords ( $ string , $ amount = 10 ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ keywords = $ analysis -> getKeyValuesByFrequency ( ) ; return array_slice ( $ keywords , 0 , $ amount ) ; }
10028	function getContactsByExternalId ( $ externalId , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/externalid/' . utf8_encode ( $ externalId ) , $ queryParameters ) ; }
3330	public function fromPath ( $ path , $ mime_type = false ) { if ( function_exists ( 'curl_file_create' ) ) { if ( $ mime_type ) { $ f = curl_file_create ( $ path , $ mime_type ) ; } else { $ f = curl_file_create ( $ path ) ; } } else { if ( $ mime_type ) { $ f = '@' . $ path . ';type=' . $ mime_type ; } else { $ f = '@' . $ path ; } } $ data = array ( 'UPLOADCARE_PUB_KEY' => $ this -> api -> getPublicKey ( ) , 'file' => $ f , ) ; $ ch = $ this -> __initRequest ( 'base' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ data = $ this -> __runRequest ( $ ch ) ; $ uuid = $ data -> file ; return new File ( $ uuid , $ this -> api ) ; }
2006	protected function removeRecipient ( $ strEmail , $ arrRemove ) { if ( ( $ objRemove = NewsletterRecipientsModel :: findByEmailAndPids ( $ strEmail , $ arrRemove ) ) !== null ) { while ( $ objRemove -> next ( ) ) { $ strHash = md5 ( $ objRemove -> email ) ; if ( ( $ objBlacklist = NewsletterBlacklistModel :: findByHashAndPid ( $ strHash , $ objRemove -> pid ) ) === null ) { $ objBlacklist = new NewsletterBlacklistModel ( ) ; $ objBlacklist -> pid = $ objRemove -> pid ; $ objBlacklist -> hash = $ strHash ; $ objBlacklist -> save ( ) ; } $ objRemove -> delete ( ) ; } } $ objChannels = NewsletterChannelModel :: findByIds ( $ arrRemove ) ; $ arrChannels = $ objChannels -> fetchEach ( 'title' ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'removeRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ strEmail , $ arrRemove ) ; } } $ arrData = array ( ) ; $ arrData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrData [ 'channel' ] = $ arrData [ 'channels' ] = implode ( "\n" , $ arrChannels ) ; $ objEmail = new Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_subject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = StringUtil :: parseSimpleTokens ( $ this -> nl_unsubscribe , $ arrData ) ; $ objEmail -> sendTo ( $ strEmail ) ; if ( ( $ objTarget = $ this -> objModel -> getRelated ( 'jumpTo' ) ) instanceof PageModel ) { $ this -> redirect ( $ objTarget -> getFrontendUrl ( ) ) ; } System :: getContainer ( ) -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'nl_removed' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_removed' ] ) ; $ this -> reload ( ) ; }
8120	public function canSubmitReview ( $ record ) { if ( ! $ record -> canEdit ( ) || ! $ record -> hasMethod ( 'canBeReviewedBy' ) || ! $ record -> canBeReviewedBy ( Security :: getCurrentUser ( ) ) ) { return false ; } return true ; }
12753	public function sendRecoveryMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> recoverySubject , 'recovery' , [ 'user' => $ user , 'token' => $ token ] ) ; }
11541	public function editProfile ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getEditProfileForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __FUNCTION__ , $ this , compact ( 'user' ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __FUNCTION__ . '.post' , $ this , compact ( 'user' ) ) ; return $ user ; }
12025	private function generateExecuteFragment ( ) { $ body = '' ; if ( $ this -> operationDefinition -> getNeedsSigning ( ) ) { $ body .= '$request = $this->api->signRequest($request);' . PHP_EOL ; } $ body .= '$response = $this->api->execute($request, $this);' . PHP_EOL ; $ body .= '$this->response = $response;' . PHP_EOL ; return $ body ; }
11001	public function setLocale ( $ locale ) { $ locale = WF :: cast_array ( $ locale ) ; foreach ( $ locale as $ l ) $ this -> locales [ ] = new Locale ( $ l ) ; $ this -> locales = array_unique ( $ this -> locales ) ; return $ this ; }
611	public function set ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; unset ( $ this -> _singletons [ $ class ] ) ; return $ this ; }
3953	public function get ( $ strAttributeName ) { return array_key_exists ( $ strAttributeName , $ this -> arrData ) ? $ this -> arrData [ $ strAttributeName ] : null ; }
7651	public function rename ( $ path_from , $ path_to ) { if ( $ this -> getContainerName ( $ path_from ) != $ this -> getContainerName ( $ path_to ) ) { throw new BlobException ( 'Container name can not be changed.' ) ; } if ( $ this -> getFileName ( $ path_from ) == $ this -> getContainerName ( $ path_to ) ) { return true ; } $ this -> getStorageClient ( $ path_from ) -> copyBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) , $ this -> getContainerName ( $ path_to ) , $ this -> getFileName ( $ path_to ) ) ; $ this -> getStorageClient ( $ path_from ) -> deleteBlob ( $ this -> getContainerName ( $ path_from ) , $ this -> getFileName ( $ path_from ) ) ; clearstatcache ( true , $ path_from ) ; clearstatcache ( true , $ path_to ) ; return true ; }
666	public function renderItems ( ) { $ models = $ this -> dataProvider -> getModels ( ) ; $ keys = $ this -> dataProvider -> getKeys ( ) ; $ rows = [ ] ; foreach ( array_values ( $ models ) as $ index => $ model ) { $ key = $ keys [ $ index ] ; if ( ( $ before = $ this -> renderBeforeItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ before ; } $ rows [ ] = $ this -> renderItem ( $ model , $ key , $ index ) ; if ( ( $ after = $ this -> renderAfterItem ( $ model , $ key , $ index ) ) !== null ) { $ rows [ ] = $ after ; } } return implode ( $ this -> separator , $ rows ) ; }
12631	public function prepare ( Order $ order ) { $ order -> notify_url = $ order -> get ( 'notify_url' , $ this -> merchant -> notify_url ) ; if ( is_null ( $ order -> spbill_create_ip ) ) { $ order -> spbill_create_ip = ( $ order -> trade_type === Order :: NATIVE ) ? get_server_ip ( ) : get_client_ip ( ) ; } return $ this -> request ( $ this -> wrapApi ( self :: API_PREPARE_ORDER ) , $ order -> all ( ) ) ; }
1993	protected function prepareMetaDescription ( $ strText ) { $ strText = $ this -> replaceInsertTags ( $ strText , false ) ; $ strText = strip_tags ( $ strText ) ; $ strText = str_replace ( "\n" , ' ' , $ strText ) ; $ strText = StringUtil :: substr ( $ strText , 320 ) ; return trim ( $ strText ) ; }
5902	public function retrieveGroup ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/groups/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Group ( $ result ) ; return $ result ; }
10570	protected function parseSort ( string $ sort , array & $ sorts ) { if ( strlen ( trim ( $ sort ) ) === 0 ) { return ; } if ( substr ( $ sort , 0 , 1 ) == "[" ) { $ json = json_decode ( $ sort ) ; if ( is_array ( $ json ) ) { foreach ( $ json as $ s ) { if ( is_object ( $ s ) ) { $ sorts [ $ s -> property ] = strcasecmp ( self :: DESC , $ s -> direction ) !== 0 ; } } return ; } } if ( substr ( $ sort , - 4 ) == ",asc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 4 ) ] = true ; } elseif ( substr ( $ sort , - 5 ) == ",desc" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 5 ) ] = false ; } elseif ( substr ( $ sort , - 10 ) == ":ascending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 10 ) ] = true ; } elseif ( substr ( $ sort , - 11 ) == ":descending" ) { $ sorts [ substr ( $ sort , 0 , strlen ( $ sort ) - 11 ) ] = false ; } else { foreach ( explode ( ',' , $ sort ) as $ s ) { if ( substr ( $ s , 0 , 1 ) === '-' ) { $ sorts [ substr ( $ s , 1 ) ] = false ; } elseif ( substr ( $ s , 0 , 1 ) === '+' ) { $ sorts [ substr ( $ s , 1 ) ] = true ; } else { $ sorts [ $ s ] = true ; } } } }
11814	protected function step1 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/license" ) ; $ this -> view -> setData ( "step" , "1" ) ; $ this -> view -> setData ( "title" , t ( "Installation | EULA" ) ) ; return ; }
9400	public function export ( ) { foreach ( $ this -> messages as $ message ) { list ( $ msg , $ level , $ catagory , $ timestamp , $ traces ) = $ message ; $ errStr = '' ; $ options = [ 'level' => yii \ log \ Logger :: getLevelName ( $ level ) , 'extra' => [ ] , ] ; $ templateData = null ; if ( is_array ( $ msg ) ) { $ errStr = isset ( $ msg [ 'msg' ] ) ? $ msg [ 'msg' ] : '' ; if ( isset ( $ msg [ 'data' ] ) ) $ options [ 'extra' ] = $ msg [ 'data' ] ; } else { $ errStr = $ msg ; } $ traces = array_map ( function ( $ v ) { return "{$v['file']}" . PHP_EOL . "{$v['class']}::{$v['function']} [{$v['line']}]" ; } , $ traces ) ; if ( ! empty ( $ traces ) ) $ options [ 'extra' ] [ 'traces' ] = $ traces ; $ this -> client -> captureMessage ( $ errStr , array ( ) , $ options , false ) ; } }
5431	protected function onlyParents ( $ interfaces ) { $ parents = array ( ) ; $ blacklist = array ( ) ; foreach ( $ interfaces as $ interface ) { foreach ( $ interfaces as $ possible_parent ) { if ( $ interface -> getName ( ) == $ possible_parent -> getName ( ) ) { continue ; } if ( $ interface -> isSubClassOf ( $ possible_parent ) ) { $ blacklist [ $ possible_parent -> getName ( ) ] = true ; } } if ( ! isset ( $ blacklist [ $ interface -> getName ( ) ] ) ) { $ parents [ ] = $ interface -> getName ( ) ; } } return $ parents ; }
11366	public static function formatText ( $ txt = '' , $ type = 'plain' , $ spaces = false ) { switch ( $ type ) { case 'ascii' : $ _txt = '' ; if ( $ spaces == true ) { $ txt = str_replace ( ' ' , '_' , $ txt ) ; } for ( $ i = 0 ; $ i < strlen ( $ txt ) ; $ i ++ ) { $ _txt .= self :: charAscii ( $ txt [ $ i ] ) ; } $ txt = $ _txt ; break ; default : break ; } $ mailer = Mailer :: getInstance ( ) ; $ limit = $ mailer -> getOption ( 'wordwrap_limit' ) ; $ formated = '' ; foreach ( explode ( "\n" , $ txt ) as $ _line ) { $ _line = trim ( $ _line ) ; if ( strlen ( $ _line ) > $ limit ) { $ _line = wordwrap ( $ _line , $ limit , Mailer :: $ LINE_ENDING ) ; } if ( strlen ( $ _line ) ) { $ formated .= $ _line . Mailer :: $ LINE_ENDING ; } } return $ formated ; }
12392	public function getPages ( $ startPage , $ endPage , $ urlStub ) { $ pages = [ ] ; for ( $ x = $ startPage ; $ x <= $ endPage ; $ x ++ ) { $ pages [ ] = $ urlStub . $ x ; } return $ pages ; }
11615	public function delete ( $ account ) { $ accessTokenField = sprintf ( '%s=%s' , $ this -> accessToken -> getQueryName ( ) , $ this -> accessToken -> getToken ( ) ) ; $ url = sprintf ( self :: API_DELETE . '?%s&kf_account=%s' , $ accessTokenField , $ account ) ; $ contents = $ this -> getHttp ( ) -> parseJSON ( file_get_contents ( $ url ) ) ; $ this -> checkAndThrow ( $ contents ) ; return new Collection ( $ contents ) ; }
7501	public function clearCache ( string $ namespace = null ) { if ( null !== $ namespace ) { $ this -> cacheStore -> remove ( self :: APP_CACHE_PREFIX . $ namespace , array ( ) ) ; return ; } $ this -> cacheStore -> clear ( ) ; }
12948	public function removeTagValues ( $ tags ) { $ this -> _tagsList = array_diff ( $ this -> getTagValues ( ) , $ this -> parseTags ( $ tags ) ) ; $ this -> updateOwnerTags ( ) ; }
10524	protected function _unsetData ( $ key ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerUnset ( $ store , $ key ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ key ) ; } }
5327	public function end ( string $ profile ) { Craft :: endProfile ( $ profile , Craft :: t ( 'twig-profiler' , self :: CATEGORY_PREFIX ) . TwigProfiler :: $ renderingTemplate ) ; }
850	public function getTokenOfKindSibling ( $ index , $ direction , array $ tokens = [ ] , $ caseSensitive = true ) { if ( ! self :: isLegacyMode ( ) ) { $ tokens = array_filter ( $ tokens , function ( $ token ) { return $ this -> isTokenKindFound ( $ this -> extractTokenKind ( $ token ) ) ; } ) ; } if ( ! \ count ( $ tokens ) ) { return null ; } while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( $ token -> equalsAny ( $ tokens , $ caseSensitive ) ) { return $ index ; } } }
8777	public function assets ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ASSETS_FOLDER . '/' . $ data : $ this -> url . '/' . ASSETS_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
12120	public function onViewCreate ( ContentfulViewEvent $ e ) { $ viewMeta = $ e -> getView ( ) -> cfMeta ; $ updated = $ viewMeta [ 'updatedAt' ] ; $ this -> itemIds [ $ viewMeta [ 'itemId' ] ] = true ; if ( $ this -> lastModifiedContent === null ) { $ this -> lastModifiedContent = $ updated ; } else { if ( $ this -> lastModifiedContent < $ updated ) { $ this -> lastModifiedContent = $ updated ; } } }
5535	public function divideMapNodes ( $ map , $ aspect ) { $ aspect = ! $ aspect ; $ divisions = $ map -> getSize ( ) ; $ total = $ map -> getTotalSize ( ) ; foreach ( $ map -> getChildren ( ) as $ node ) { if ( ! $ node -> isLeaf ( ) ) { $ dist = $ node -> getTotalSize ( ) / $ total * 100 ; } else { $ dist = 1 / $ total * 100 ; } if ( $ aspect ) { $ horiz = $ dist ; $ vert = 100 ; } else { $ horiz = 100 ; $ vert = $ dist ; } $ this -> paintRectangleStart ( $ node , $ horiz , $ vert ) ; $ this -> divideMapNodes ( $ node , $ aspect ) ; $ this -> paintRectangleEnd ( ) ; } }
6673	public function update_rating ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_after_update_post ( $ post , $ update ) ) { if ( isset ( $ _POST [ 'efg-update-rating' ] ) ) { for ( $ i = 1 ; $ i <= 10 ; $ i ++ ) { if ( ! isset ( $ _POST [ "efg-rating-$i" ] ) ) { return false ; } $ votes [ "$i" ] = ( int ) $ _POST [ "efg-rating-$i" ] ; } $ this -> set_rating_and_votes ( $ post_id , $ votes ) ; } } return true ; }
1886	public function getItemsAsArray ( ) { $ arrLinks = array ( ) ; $ intNumberOfLinks = floor ( $ this -> intNumberOfLinks / 2 ) ; $ intFirstOffset = $ this -> intPage - $ intNumberOfLinks - 1 ; if ( $ intFirstOffset > 0 ) { $ intFirstOffset = 0 ; } $ intLastOffset = $ this -> intPage + $ intNumberOfLinks - $ this -> intTotalPages ; if ( $ intLastOffset < 0 ) { $ intLastOffset = 0 ; } $ intFirstLink = $ this -> intPage - $ intNumberOfLinks - $ intLastOffset ; if ( $ intFirstLink < 1 ) { $ intFirstLink = 1 ; } $ intLastLink = $ this -> intPage + $ intNumberOfLinks - $ intFirstOffset ; if ( $ intLastLink > $ this -> intTotalPages ) { $ intLastLink = $ this -> intTotalPages ; } for ( $ i = $ intFirstLink ; $ i <= $ intLastLink ; $ i ++ ) { if ( $ i == $ this -> intPage ) { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => null , 'title' => null ) ; } else { $ arrLinks [ ] = array ( 'page' => $ i , 'href' => $ this -> linkToPage ( $ i ) , 'title' => StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goToPage' ] , $ i ) ) ) ; } } return $ arrLinks ; }
473	public function batchInsert ( $ table , $ columns , $ rows ) { $ time = $ this -> beginCommand ( "insert into $table" ) ; $ this -> db -> createCommand ( ) -> batchInsert ( $ table , $ columns , $ rows ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
1181	protected function createFormRequest ( $ class ) { list ( $ class , $ params ) = $ this -> parseFormRequestName ( $ class ) ; $ request = $ this -> app -> __get ( 'request' ) ; $ formRequest = $ this -> app -> build ( $ class , $ params ) ; if ( $ session = $ request -> getSession ( ) ) { $ formRequest -> setLaravelSession ( $ session ) ; } $ formRequest -> setUserResolver ( $ request -> getUserResolver ( ) ) ; $ formRequest -> setRouteResolver ( $ request -> getRouteResolver ( ) ) ; $ formRequest -> setContainer ( $ this -> app ) ; $ formRequest -> query = $ request -> query ; return $ formRequest ; }
5319	public function isSuccessExit ( ) { $ this -> exitCode = pcntl_wexitstatus ( $ this -> status ) ; return ( pcntl_wifexited ( $ this -> status ) && ( $ this -> exitCode === 0 ) ) ; }
10031	function synchronizeContacts ( $ contacts , $ permission = null , $ syncMode = null , $ useExternalId = false , $ ignoreInvalidContacts = false , $ reimportUnsubscribedContacts = true , $ overridePermission = true , $ updateOnly = false , $ preferMaileonId = false ) { $ queryParameters = array ( 'permission' => ( $ permission == null ) ? 1 : $ permission -> getCode ( ) , 'sync_mode' => ( $ syncMode == null ) ? 2 : $ syncMode -> getCode ( ) , 'use_external_id' => ( $ useExternalId == TRUE ) ? "true" : "false" , 'ignore_invalid_contacts' => ( $ ignoreInvalidContacts == TRUE ) ? "true" : "false" , 'reimport_unsubscribed_contacts' => ( $ reimportUnsubscribedContacts == TRUE ) ? "true" : "false" , 'override_permission' => ( $ overridePermission == TRUE ) ? "true" : "false" , 'update_only' => ( $ updateOnly == TRUE ) ? "true" : "false" , 'prefer_maileon_id' => ( $ preferMaileonId == TRUE ) ? "true" : "false" ) ; $ cleanedContacts = new Contacts ( ) ; foreach ( $ contacts as $ contact ) { $ cleanedContact = new Contact ( $ contact -> id , $ contact -> email , null , $ contact -> external_id , null , $ contact -> standard_fields , $ contact -> custom_fields ) ; $ cleanedContacts -> addContact ( $ cleanedContact ) ; } return $ this -> post ( "contacts" , $ cleanedContacts -> toXMLString ( ) , $ queryParameters ) ; }
2654	public function hasSnippet ( $ version , $ name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/snippet/' . $ name ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET , '' , false , null , false ) ; if ( $ result == false ) { return false ; } return true ; }
11290	protected function _getModels ( $ attributeName , $ relatedObjName = false , $ query = false , $ loadMap = false ) { $ def = $ this -> model_attributes [ $ attributeName ] ; $ result = [ ] ; if ( $ relatedObjName ) { if ( isset ( $ def [ 'via' ] ) ) { $ result = $ this -> _getModelsFromTableColumn ( $ attributeName , $ relatedObjName , $ def [ 'via' ] , $ query , $ loadMap ) ; } else if ( isset ( $ def [ 'using' ] ) ) { $ result = $ this -> getModelsFromCustomRelationship ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } else { $ result = $ this -> _getModelsFromRelationTable ( $ attributeName , $ relatedObjName , $ query , $ loadMap ) ; } } if ( $ result == null ) { $ this -> $ attributeName = new \ Cora \ Collection ( ) ; $ result = $ this -> model_data [ $ attributeName ] ; } return $ result ; }
7356	public static function isValidFormat ( $ format , $ throw = false ) { if ( in_array ( $ format , static :: getFormats ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Unknown format '$format'." ) ; } return false ; }
11000	public function selectLocaleFromAcceptHeader ( Accept $ header ) { $ my_locales = [ ] ; foreach ( $ this -> locales as $ supported_locale ) { $ list = $ supported_locale -> getFallbackList ( ) ; foreach ( $ list as $ locale ) $ my_locales [ $ locale -> getLocale ( ) ] = $ supported_locale -> getLocale ( ) ; } $ best = $ header -> getBestResponseType ( array_keys ( $ my_locales ) ) ; return empty ( $ best ) ? null : ( $ my_locales [ $ best ] ?? null ) ; }
2167	protected static function generateHelperObject ( $ value ) { $ return = new \ stdClass ( ) ; if ( ! \ is_array ( $ value ) ) { $ return -> value = rtrim ( $ value , "\x00" ) ; $ return -> isUuid = ( \ strlen ( $ value ) == 16 && ! is_numeric ( $ return -> value ) && strncmp ( $ return -> value , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value ) && $ return -> value > 0 ) ; } else { $ return -> value = array_map ( function ( $ var ) { return rtrim ( $ var , "\x00" ) ; } , $ value ) ; $ return -> isUuid = ( \ strlen ( $ value [ 0 ] ) == 16 && ! is_numeric ( $ return -> value [ 0 ] ) && strncmp ( $ return -> value [ 0 ] , Config :: get ( 'uploadPath' ) . '/' , \ strlen ( Config :: get ( 'uploadPath' ) ) + 1 ) !== 0 ) ; $ return -> isNumeric = ( is_numeric ( $ return -> value [ 0 ] ) && $ return -> value [ 0 ] > 0 ) ; } return $ return ; }
12623	public function fire ( $ eventName , $ infoClass = null ) { if ( isset ( $ this -> events [ $ eventName ] ) ) { foreach ( $ this -> events [ $ eventName ] as $ bind => $ data ) { call_user_func_array ( [ $ data [ 'object' ] , $ data [ 'methodName' ] ] , [ $ infoClass ] ) ; } } }
11273	public function sendRequest ( RequestInterface $ request ) { $ this -> lastOperation = new Operation ( $ request ) ; $ response = parent :: sendRequest ( $ request ) ; $ this -> lastOperation -> setResponse ( $ response ) ; return $ response ; }
11974	private function firstParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( is_numeric ( $ params [ 0 ] ) && $ params [ 0 ] > 0 && $ params [ 0 ] <= $ this -> maxDieRolls ) ; }
12950	public function beforeDelete ( ) { $ this -> _tagsForDelete = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsForDelete = ( new Query ( ) ) -> select ( current ( $ relation -> link ) ) -> from ( $ relation -> via -> from [ 0 ] ) -> where ( [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> column ( $ this -> owner -> getDb ( ) ) ; } }
4985	public function setParam ( $ key , $ value ) { $ this -> params [ $ key ] = $ value ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParam' ) ) { $ form [ '__instance__' ] -> setParam ( $ key , $ value ) ; } } return $ this ; }
9777	function within ( $ start , $ finish ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , logicalAnd ( greaterThanOrEqual ( $ start ) , lessThanOrEqual ( $ finish ) ) ) ; }
641	public function addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete = null , $ update = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addForeignKey ( $ name , $ table , $ columns , $ refTable , $ refColumns , $ delete , $ update ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
6481	private function createDefaultResponseContentNegotiationResult ( string $ type , ? string $ language , array $ acceptCharsetHeaders ) : ContentNegotiationResult { $ selectedMediaTypeFormatter = null ; foreach ( $ this -> mediaTypeFormatters as $ mediaTypeFormatter ) { if ( $ mediaTypeFormatter -> canWriteType ( $ type ) ) { $ selectedMediaTypeFormatter = $ mediaTypeFormatter ; break ; } } if ( $ selectedMediaTypeFormatter === null ) { return new ContentNegotiationResult ( null , null , null , $ language ) ; } $ encoding = $ this -> encodingMatcher -> getBestEncodingMatch ( $ selectedMediaTypeFormatter , $ acceptCharsetHeaders , null ) ; return new ContentNegotiationResult ( $ selectedMediaTypeFormatter , $ selectedMediaTypeFormatter -> getDefaultMediaType ( ) , $ encoding , $ language ) ; }
5341	protected function call ( $ service , $ method , array $ parameters = [ ] ) { return $ this -> getSoapClient ( $ service , $ method , $ parameters ) -> __call ( $ method , $ parameters ) ; }
10277	public static function getDefaultRowHeightByFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { switch ( $ font -> getName ( ) ) { case 'Arial' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; case 'Calibri' : switch ( $ font -> getSize ( ) ) { case 11 : $ rowHeight = 15 ; break ; case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 12 ; break ; case 8 : $ rowHeight = 11.25 ; break ; case 7 : $ rowHeight = 9 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6.00 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } break ; case 'Verdana' : switch ( $ font -> getSize ( ) ) { case 10 : $ rowHeight = 12.75 ; break ; case 9 : $ rowHeight = 11.25 ; break ; case 8 : $ rowHeight = 10.50 ; break ; case 7 : $ rowHeight = 9.00 ; break ; case 6 : case 5 : $ rowHeight = 8.25 ; break ; case 4 : $ rowHeight = 6.75 ; break ; case 3 : $ rowHeight = 6 ; break ; case 2 : case 1 : $ rowHeight = 5.25 ; break ; default : $ rowHeight = 12.75 * $ font -> getSize ( ) / 10 ; break ; } break ; default : $ rowHeight = 15 * $ font -> getSize ( ) / 11 ; break ; } return $ rowHeight ; }
1346	public function isDeleteResource ( ) : bool { return $ this -> isMethod ( 'delete' ) && $ this -> getRoute ( ) -> isResource ( ) && $ this -> getRoute ( ) -> isNotRelationship ( ) ; }
4161	public function modifyRelationship ( $ action , $ user ) { if ( true === in_array ( $ action , $ this -> _actions ) && isset ( $ user ) ) { return $ this -> _makeCall ( 'users/' . $ user . '/relationship' , array ( 'action' => $ action ) , 'POST' ) ; } throw new InvalidParameterException ( 'Error: modifyRelationship() - This method requires an action command and the target user id.' ) ; }
7720	static function f_Misc_UpdateArray ( & $ array , $ numerical , $ v , $ d ) { if ( ! is_array ( $ v ) ) { if ( is_null ( $ v ) ) { $ array = array ( ) ; return ; } else { $ v = array ( $ v => $ d ) ; } } foreach ( $ v as $ p => $ a ) { if ( $ numerical === true ) { if ( is_string ( $ p ) ) { $ i = array_search ( $ p , $ array , true ) ; if ( $ i === false ) { if ( ! is_null ( $ a ) ) $ array [ ] = $ p ; } else { if ( is_null ( $ a ) ) array_splice ( $ array , $ i , 1 ) ; } } else { $ i = array_search ( $ a , $ array , true ) ; if ( $ i == false ) $ array [ ] = $ a ; } } else { if ( is_null ( $ a ) ) { unset ( $ array [ $ p ] ) ; } elseif ( $ numerical === 'frm' ) { self :: f_Misc_FormatSave ( $ a , $ p ) ; } else { $ array [ $ p ] = $ a ; } } } }
6600	public function unlinkFiles ( $ fileName ) { $ folder = $ this -> getWebrootFolder ( ) ; if ( $ fileName ) { if ( @ file_exists ( $ folder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ fileName ) ; } if ( @ file_exists ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ this -> thumbFolder . '/' . $ fileName ) ; } if ( is_array ( $ this -> sizes ) ) { $ i = 0 ; foreach ( $ this -> sizes as $ size ) { if ( @ file_exists ( $ folder . '/' . $ i . '/' . $ fileName ) ) { unlink ( $ folder . '/' . $ i . '/' . $ fileName ) ; } $ i ++ ; } } } }
4532	public function setFirstResult ( ? int $ firstResult ) { $ this -> firstResult = $ firstResult ; $ this -> _firstResult = null !== $ firstResult ; return $ this ; }
8075	private function handle ( Response $ response ) { $ stream = stream_for ( $ response -> getBody ( ) ) ; $ data = json_decode ( $ stream -> getContents ( ) ) ; return $ data ; }
12773	public function __async_authorize ( $ hashEmail = null , $ hashPassword = null ) { $ result = array ( 'status' => '0' ) ; if ( ! isset ( $ hashEmail ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _POST [ $ this -> dbHashEmailField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashEmailField ] ) ) { $ hashEmail = $ _GET [ $ this -> dbHashEmailField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashEmailField . '] field is not passed' ; } } if ( ! isset ( $ hashPassword ) ) { if ( isset ( $ _POST ) && isset ( $ _POST [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _POST [ $ this -> dbHashPasswordField ] ; } elseif ( isset ( $ _GET ) && isset ( $ _GET [ $ this -> dbHashPasswordField ] ) ) { $ hashPassword = $ _GET [ $ this -> dbHashPasswordField ] ; } else { $ result [ 'email_error' ] = "\n" . '[' . $ this -> dbHashPasswordField . '] field is not passed' ; } } if ( isset ( $ hashEmail ) && isset ( $ hashPassword ) ) { $ hashEmail = $ this -> hash ( $ hashEmail ) ; $ hashPassword = $ this -> hash ( $ hashPassword ) ; $ authorizeResult = $ this -> authorizeWithEmail ( $ hashEmail , $ hashPassword ) ; if ( $ authorizeResult -> code == EmailStatus :: SUCCESS_EMAIL_AUTHORIZE ) { $ result [ 'status' ] = '1' ; } $ result [ self :: RESPONSE_STATUS_TEXTFIELD ] = $ authorizeResult -> text ; $ result [ self :: RESPONSE_STATUS_FIELD ] = $ authorizeResult -> code ; $ result = array_merge ( $ result , $ authorizeResult -> response ) ; } return $ result ; }
5696	protected function getFormActionFromRequest ( HTTPRequest $ r ) { $ action = $ r -> requestVar ( 'action' ) ; $ formAction = $ this -> record -> findActionByName ( $ action ) ; if ( ! $ formAction instanceof BetterButtonNestedForm ) { throw new Exception ( "Action $action doesn't exist or is not a BetterButtonNestedForm" ) ; } return $ formAction ; }
7423	protected function registerWidget ( $ name = null , $ id = null ) { if ( $ name === null ) { $ name = $ this -> getDefaultJsWidgetName ( ) ; } $ this -> _registerBundle ( ) ; if ( ! $ this -> isAjaxCrud && $ this -> getUpdateUrl ( ) ) { if ( $ id === null ) { $ id = $ this -> options [ 'id' ] ; } $ options = empty ( $ this -> clientOptions ) ? '' : Json :: htmlEncode ( [ 'updateUrl' => Url :: to ( $ this -> getUpdateUrl ( ) ) ] ) ; $ js = "jQuery('#$id').$name($options);" ; $ this -> getView ( ) -> registerJs ( $ js ) ; } }
7453	protected function renderLTR ( ) : string { $ trail = '' ; if ( $ this -> before ) { $ trail .= '<span class="before">' . $ this -> before . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , $ this -> links ) ; if ( $ this -> after ) { $ trail .= ' <span class="after">' . $ this -> after . '</span>' ; } return $ trail ; }
4499	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ result = [ ] ; foreach ( \ func_get_args ( ) as $ array ) { foreach ( $ array as $ key => $ value ) { if ( \ is_int ( $ key ) ) { $ result [ ] = $ value ; } elseif ( isset ( $ result [ $ key ] ) && \ is_array ( $ result [ $ key ] ) && \ is_array ( $ value ) ) { $ result [ $ key ] = $ this -> arrayMergeDeep ( $ result [ $ key ] , $ value ) ; } else { $ result [ $ key ] = $ value ; } } } return $ result ; }
10539	protected function _setMany ( $ data ) { $ data = $ this -> _normalizeIterable ( $ data ) ; $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSetMany ( $ store , $ data ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } }
11883	public function getTicketCacheKey ( ) { if ( is_null ( $ this -> ticketCacheKey ) ) { return $ this -> ticketCachePrefix . $ this -> getAccessToken ( ) -> getAppId ( ) ; } return $ this -> ticketCacheKey ; }
2218	public function getFields ( ) { $ arrFields = $ GLOBALS [ 'TL_FFL' ] ; foreach ( array_keys ( $ arrFields ) as $ key ) { $ arrFields [ $ key ] = $ GLOBALS [ 'TL_LANG' ] [ 'FFL' ] [ $ key ] [ 0 ] ; } return $ arrFields ; }
11563	public function LineBreaks ( $ text , $ lang = "" ) { $ this -> text = $ text ; $ word = "" ; $ lang = $ lang ? $ lang : $ this -> lang ; list ( $ weekWords , $ units , $ shortcuts ) = $ this -> getWeekWordsUnitsAndShortcuts ( $ lang ) ; $ this -> text = preg_replace ( "#\t+#mu" , " " , $ this -> text ) ; $ this -> text = preg_replace ( "#[ ]{2,}#mu" , " " , $ this -> text ) ; for ( $ i = 0 , $ l = count ( $ weekWords ) ; $ i < $ l ; $ i += 1 ) { $ word = $ weekWords [ $ i ] ; $ this -> processWeakWord ( $ word ) ; $ word = mb_strtoupper ( mb_substr ( $ word , 0 , 1 ) ) . mb_substr ( $ word , 1 ) ; $ this -> processWeakWord ( $ word ) ; } for ( $ i = 0 , $ l = count ( $ units ) ; $ i < $ l ; $ i += 1 ) { $ word = $ units [ $ i ] ; $ regExp = "#([0-9])\\s(" . $ word . ")#mu" ; $ this -> text = preg_replace ( $ regExp , "$1&nbsp;$2" , $ this -> text ) ; } foreach ( $ shortcuts as $ sourceShortcut => $ targetShortcut ) { $ this -> text = str_replace ( $ sourceShortcut , $ targetShortcut , $ this -> text ) ; } $ this -> text = preg_replace ( "#([0-9])\s([0-9])#" , "$1&nbsp;$2" , $ this -> text ) ; return $ this -> text ; }
2021	public static function findPublishedByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
8360	private function startProcessQueue ( ) { $ this -> logger -> info ( 'Starting queue in process mode' ) ; $ dispatcher = new ProcessDispatcher ( $ this -> client , $ this -> logger , $ this -> queue , \ array_merge ( $ this -> queueConfig , [ 'process' => $ this -> config [ 'process' ] ] ) , [ 'configFile' => $ this -> configName ] ) ; $ dispatcher -> start ( ) ; }
3087	public function validateAdaptiveAssessmentSection ( SectionPartCollection $ sectionsParts , $ ref , $ testAdminId ) { $ engine = $ this -> getEngine ( $ ref ) ; $ adaptSection = $ engine -> setupSection ( $ testAdminId ) ; if ( method_exists ( $ adaptSection , 'getItemReferences' ) ) { $ itemReferences = $ adaptSection -> getItemReferences ( ) ; $ dependencies = $ sectionsParts -> getKeys ( ) ; if ( $ catDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some CAT service items: ' . implode ( ', ' , $ catDiff ) , $ catDiff ) ; } if ( $ packageDiff = array_diff ( $ dependencies , $ itemReferences ) ) { throw new AdaptiveSectionInjectionException ( 'Missed some package items: ' . implode ( ', ' , $ packageDiff ) , $ packageDiff ) ; } } }
12165	private function createAuthorityPermissionsTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority_permissions`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority_permissions` ( `authority_permission_key` bigint(20) NOT NULL AUTO_INCREMENT, `authority_id` bigint(20) NOT NULL, `permission_area_uri` varchar(255) NOT NULL, `permission` varchar(45) NOT NULL DEFAULT '1', `permission_type` varchar(45) NOT NULL, `permission_title` varchar(45) NOT NULL, PRIMARY KEY (`authority_permission_key`), UNIQUE KEY `UNIQUE` (`permission_area_uri`,`permission_type`,`authority_id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority_permissions` (`authority_permission_key`, `authority_id`, `permission_area_uri`, `permission`, `permission_type`, `permission_title`) VALUES (1, 4, '^/admin(/[a-z0-9-]*)*', 'allow', 'special', 'Console'), (2, 1, '^/admin/setup/install(/[a-z0-9-]*)*', 'allow', 'execute', 'Installer'), (3, 4, '^/page(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (4, 2, '^/member(/[a-z0-9-]*)*', 'allow', 'execute', 'Member Pages'), (5, 1, '^/member/sign([a-z0-9-]*)*', 'allow', 'execute', 'Authentication'), (6, 2, '^/message(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (7, 1, '^/search(/[a-z0-9-]*)*', 'allow', 'execute', 'Search'), (8, 4, '^/listing(/[a-z0-9-]*)*', 'allow', 'special', 'Directory'), (9, 2, '^/notification(/[a-z0-9-]*)*', 'allow', 'execute', 'Messages'), (10, 1, '^/post(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (11, 1, '^/event(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (12, 1, '^/stream(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (13, 1, '^/group(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (14, 1, '^/file(/[a-z0-9-]*)*', 'allow', 'view', 'Content'), (16, 2, '^/post(/[a-z0-9-]*)*', 'allow', 'execute', 'Content'), (15, 1, '^/page(/[a-z0-9-]*)*', 'allow', 'view', 'Content');" ) ; }
12294	public function delete ( $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } return $ resource -> delete ( ) ; }
2236	public function generate ( $ blnNoMarkup = false ) { if ( TL_MODE == 'FE' && ! BE_USER_LOGGED_IN && ( ! $ this -> published || ( $ this -> start != '' && $ this -> start > time ( ) ) || ( $ this -> stop != '' && $ this -> stop < time ( ) ) ) ) { return '' ; } $ this -> type = 'article' ; $ this -> blnNoMarkup = $ blnNoMarkup ; if ( System :: getContainer ( ) -> has ( 'fos_http_cache.http.symfony_response_tagger' ) ) { $ responseTagger = System :: getContainer ( ) -> get ( 'fos_http_cache.http.symfony_response_tagger' ) ; $ responseTagger -> addTags ( array ( 'contao.db.tl_article.' . $ this -> id ) ) ; } return parent :: generate ( ) ; }
2987	public function addResource ( $ bundle , $ format , $ prefix = '/' , $ path = 'routing' ) { $ current = '' ; $ code = sprintf ( "%s:\n" , $ this -> getImportedResourceYamlKey ( $ bundle , $ prefix ) ) ; if ( file_exists ( $ this -> file ) ) { $ current = file_get_contents ( $ this -> file ) ; if ( false !== strpos ( $ current , '@' . $ bundle ) ) { throw new \ RuntimeException ( sprintf ( 'Bundle "%s" is already imported.' , $ bundle ) ) ; } } elseif ( ! is_dir ( $ dir = dirname ( $ this -> file ) ) ) { Generator :: mkdir ( $ dir ) ; } if ( 'annotation' == $ format ) { $ code .= sprintf ( " resource: \"@%s/Controller/\"\n type: annotation\n" , $ bundle ) ; } else { $ code .= sprintf ( " resource: \"@%s/Resources/config/%s.%s\"\n" , $ bundle , $ path , $ format ) ; } $ code .= sprintf ( " prefix: %s\n" , $ prefix ) ; $ code .= "\n" ; $ code .= $ current ; if ( false === Generator :: dump ( $ this -> file , $ code ) ) { return false ; } return true ; }
3538	public function queryLdapUserObject ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } if ( $ this -> ldapUserObject == null ) { if ( $ this -> username == null ) { throw new \ yii \ base \ Exception ( 'Please set username attribute before calling queryLdapUserObject() function.' ) ; } $ userObjectsFound = static :: getAdldapProvider ( ) -> search ( ) -> where ( 'sAMAccountname' , '=' , $ this -> username ) -> get ( ) ; if ( count ( $ userObjectsFound ) != 1 ) { $ this -> ldapUserObject = null ; } else { $ this -> ldapUserObject = $ userObjectsFound [ 0 ] ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'queryLdapUserObject' , static :: YII2_PROFILE_NAME . 'queryLdapUserObject' ) ; } return $ this -> ldapUserObject ; }
755	public function validate ( $ input , $ caseSensitive ) { $ code = $ this -> getVerifyCode ( ) ; $ valid = $ caseSensitive ? ( $ input === $ code ) : strcasecmp ( $ input , $ code ) === 0 ; $ session = Yii :: $ app -> getSession ( ) ; $ session -> open ( ) ; $ name = $ this -> getSessionKey ( ) . 'count' ; $ session [ $ name ] += 1 ; if ( $ valid || $ session [ $ name ] > $ this -> testLimit && $ this -> testLimit > 0 ) { $ this -> getVerifyCode ( true ) ; } return $ valid ; }
4577	public function getXml ( $ id , Parameters $ parameters = null ) { if ( null !== $ id ) { $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_OBJECT_XML ) ; } else { $ key = $ parameters -> getKey ( ) ; $ tenantId = $ parameters -> getTenantId ( ) ; switch ( true ) { case null !== $ key && null !== $ tenantId : $ resource = str_replace ( [ '{key}' , '{tenant-id}' ] , [ $ key , $ tenantId ] , static :: RESOURCE_OBJECT_XML_BY_KEY_AND_TENANT_ID ) ; break ; case null !== $ key : $ resource = str_replace ( '{key}' , $ key , static :: RESOURCE_OBJECT_XML_BY_KEY ) ; break ; default : throw new LogicException ( '"Key" and/or "TenantId" parameters are not defined.' ) ; } } $ options = [ 'headers' => [ 'Accept' => 'application/json' ] ] ; $ object = $ this -> execute ( 'GET' , $ resource , $ options ) ; $ model = new Xml ; $ model -> setId ( $ object -> id ) -> setXml ( new SimpleXMLElement ( $ object -> bpmn20Xml ) ) ; return $ model ; }
6487	protected function createHeadersFromSuperglobals ( array $ server ) : HttpHeaders { $ headers = new HttpHeaders ( ) ; foreach ( $ server as $ name => $ values ) { $ containsMultipleValues = isset ( self :: $ headersThatPermitMultipleValues [ $ name ] ) && count ( $ explodedValues = preg_split ( '/,(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/' , $ values ) ) > 1 ; if ( $ containsMultipleValues ) { foreach ( $ explodedValues as $ value ) { $ this -> addHeaderValue ( $ headers , $ name , $ value , true ) ; } } else { $ this -> addHeaderValue ( $ headers , $ name , $ values , false ) ; } } return $ headers ; }
7363	protected function updatePaymentTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ paid = $ this -> paymentCalculator -> calculatePaidTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ paid , $ sale -> getPaidTotal ( ) , $ currency ) ) { $ sale -> setPaidTotal ( $ paid ) ; $ changed = true ; } $ pending = $ this -> paymentCalculator -> calculateOfflinePendingTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ pending , $ sale -> getPendingTotal ( ) , $ currency ) ) { $ sale -> setPendingTotal ( $ pending ) ; $ changed = true ; } $ acceptedOutstanding = $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ acceptedOutstanding , $ sale -> getOutstandingAccepted ( ) , $ currency ) ) { $ sale -> setOutstandingAccepted ( $ acceptedOutstanding ) ; $ changed = true ; } $ expiredOutstanding = $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ expiredOutstanding , $ sale -> getOutstandingExpired ( ) , $ currency ) ) { $ sale -> setOutstandingExpired ( $ expiredOutstanding ) ; $ changed = true ; } if ( $ changed && $ this -> outstandingReleaser -> releaseFund ( $ sale ) ) { $ sale -> setOutstandingAccepted ( $ this -> paymentCalculator -> calculateOutstandingAcceptedTotal ( $ sale ) ) ; $ sale -> setOutstandingExpired ( $ this -> paymentCalculator -> calculateOutstandingExpiredTotal ( $ sale ) ) ; } return $ changed ; }
3605	private function isCacheSupport ( JsonRequest $ jsonRequest ) { try { return $ jsonRequest -> getId ( ) && null !== $ this -> getMethod ( $ jsonRequest ) -> getCache ( ) && ! $ this -> isDebug ( ) && $ this -> getCache ( ) ; } catch ( \ Exception $ e ) { return false ; } }
4954	public function initialize ( $ instance , ServiceLocatorInterface $ serviceLocator ) { if ( ! $ instance instanceof HeadscriptProviderInterface ) { return ; } $ scripts = $ instance -> getHeadscripts ( ) ; if ( ! is_array ( $ scripts ) || empty ( $ scripts ) ) { return ; } $ services = $ serviceLocator ; $ helpers = $ services -> get ( 'ViewHelperManager' ) ; $ basepath = $ helpers -> get ( 'basepath' ) ; $ headscript = $ helpers -> get ( 'headscript' ) ; foreach ( $ scripts as $ script ) { $ headscript -> appendFile ( $ basepath ( $ script ) ) ; } }
1295	public function has ( string $ name , string $ locale = null , bool $ checkLinksAreResolved = true ) : bool { $ field = $ this -> sys -> getContentType ( ) -> getField ( $ name , true ) ; if ( ! $ field ) { return false ; } if ( ! \ array_key_exists ( $ field -> getId ( ) , $ this -> fields ) ) { return false ; } try { $ result = $ this -> getUnresolvedField ( $ field , $ locale ) ; if ( $ checkLinksAreResolved ) { $ this -> resolveFieldLinks ( $ result , $ locale ) ; } } catch ( \ Exception $ exception ) { return false ; } return true ; }
12229	public function replaceSelf ( SimpleXMLElement $ new ) { $ old = dom_import_simplexml ( $ this ) ; $ new = $ old -> ownerDocument -> importNode ( dom_import_simplexml ( $ new ) , true ) ; $ node = $ old -> parentNode -> replaceChild ( $ new , $ old ) ; return simplexml_import_dom ( $ node , get_class ( $ this ) ) ; }
221	protected function normalizeNumericValue ( $ value ) { if ( empty ( $ value ) ) { return 0 ; } if ( is_string ( $ value ) && is_numeric ( $ value ) ) { $ value = ( float ) $ value ; } if ( ! is_numeric ( $ value ) ) { throw new InvalidArgumentException ( "'$value' is not a numeric value." ) ; } return $ value ; }
6961	public static function J ( $ year ) { $ jd = static :: J2000 ( ) -> jd + ( $ year - 2000 ) * static :: DaysJulianYear ; $ epoch = new static ( $ jd ) ; $ epoch -> type = YearType :: Julian ( ) ; return $ epoch ; }
2687	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ configPaths = [ 'geoip_country_mapping' => \ Fastly \ Cdn \ Model \ Config :: XML_FASTLY_GEOIP_COUNTRY_MAPPING ] ; foreach ( $ configPaths as $ path ) { $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ output -> writeln ( 'Warning : This function is used for converting serialized data to JSON' . ' (recommended for Magento versions above 2.2)' ) ; } $ oldData = $ this -> scopeConfig -> getValue ( $ path ) ; try { $ oldData = unserialize ( $ oldData ) ; } catch ( \ Exception $ e ) { $ oldData = false ; } if ( $ oldData === false ) { $ output -> writeln ( 'Invalid serialization format, unable to unserialize config data : ' . $ path ) ; return ; } $ oldData = ( is_array ( $ oldData ) ) ? $ oldData : [ ] ; $ newData = json_encode ( $ oldData ) ; if ( false === $ newData ) { throw new \ InvalidArgumentException ( 'Unable to encode data.' ) ; } $ this -> configWriter -> save ( $ path , $ newData ) ; $ this -> cacheManager -> clean ( [ \ Magento \ Framework \ App \ Cache \ Type \ Config :: TYPE_IDENTIFIER ] ) ; $ output -> writeln ( 'Config Cache Flushed' ) ; } }
3706	public function getMetaModelFrontendFilter ( HybridFilterBlock $ objFilterConfig ) { $ this -> objFilterConfig = $ objFilterConfig ; $ this -> formId .= $ this -> objFilterConfig -> id ; return $ this -> getFilters ( ) ; }
10250	public function getDln ( $ state_code = null , $ min = 900000001 , $ max = 999999999 ) { $ dln = new Entities \ DriverLicense ( ) ; $ dln -> number = rand ( $ min , $ max ) ; $ dln -> state = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) ; $ dln -> expiration = $ this -> getExpiration ( ) ; return $ dln ; }
4220	private function getLogArgs ( $ cleared ) { $ cleared = \ array_filter ( $ cleared ) ; if ( ! $ cleared ) { return array ( ) ; } $ count = \ count ( $ cleared ) ; $ glue = $ count == 2 ? ' and ' : ', ' ; if ( $ count > 2 ) { $ cleared [ $ count - 1 ] = 'and ' . $ cleared [ $ count - 1 ] ; } $ msg = 'Cleared ' . \ implode ( $ glue , $ cleared ) ; if ( $ this -> channelName ) { return array ( $ msg . ' %c(%s)' , 'background-color:#c0c0c0; padding:0 .33em;' , $ this -> channelName , ) ; } return array ( $ msg ) ; }
5880	protected static function accessProtectedProperty ( $ object , $ propertyName ) { $ className = get_class ( $ object ) ; if ( ! isset ( static :: $ reflectedClasses [ $ className ] ) ) { static :: $ reflectedClasses [ $ className ] = new \ ReflectionClass ( $ className ) ; } $ class = static :: $ reflectedClasses [ $ className ] ; $ property = $ class -> getProperty ( $ propertyName ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ object ) ; }
2099	public static function getNumericDateFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> dateFormat != '' && static :: isNumericFormat ( $ objPage -> dateFormat ) ) { return $ objPage -> dateFormat ; } } return Config :: get ( 'dateFormat' ) ; }
8293	protected function errorHandler ( \ Exception $ e , $ url = "" ) { $ this -> errorOccurred = true ; $ this -> requestFile = $ this -> pluginDir . '/content/error.md' ; if ( $ this -> config [ "debug" ] === true ) { $ this -> addOutput ( "_exception" , ( string ) $ e ) ; } $ this -> logger -> critical ( "Exception on url '{url}': {e}" , array ( "url" => $ url , "e" => $ e ) ) ; header ( $ _SERVER [ 'SERVER_PROTOCOL' ] . ' 500 Internal Server Error' , true , 500 ) ; $ this -> requestUrl = "500" ; }
1918	public static function findByIds ( $ arrIds , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.id IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ")" ) , null , $ arrOptions ) ; }
9251	public function addCompilerPass ( CompilerPassInterface $ pass , $ type = PassConfig :: TYPE_BEFORE_OPTIMIZATION ) { $ this -> compilerPasses [ ] = array ( $ pass , $ type ) ; }
5238	private function methodBindingName ( \ ReflectionMethod $ method ) { $ annotations = annotationsOf ( $ method ) ; if ( $ annotations -> contain ( 'List' ) ) { return $ annotations -> firstNamed ( 'List' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Map' ) ) { return $ annotations -> firstNamed ( 'Map' ) -> getValue ( ) ; } if ( $ annotations -> contain ( 'Named' ) ) { return $ annotations -> firstNamed ( 'Named' ) -> getName ( ) ; } if ( $ annotations -> contain ( 'Property' ) ) { return $ annotations -> firstNamed ( 'Property' ) -> getValue ( ) ; } return null ; }
9181	public function forget ( $ args = [ ] ) { if ( ! empty ( $ args ) ) { if ( is_array ( $ args ) ) { $ args = implode ( '_' , $ args ) ; } if ( empty ( $ this -> forgetful ) ) { $ this -> forgetful = get_class_methods ( $ this ) ; } foreach ( $ this -> forgetful as $ method ) { $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' ) ; $ this -> forgetByKey ( $ cacheKey ) ; $ cacheKey = str_replace ( '\\' , '_' , get_class ( $ this ) . '_' . $ method . '_' . $ args ) ; $ this -> forgetByKey ( $ cacheKey ) ; } } else { $ key = $ this -> getRememberKey ( ) ; $ this -> forgetByKey ( $ key ) ; } return $ this ; }
10348	public function rewind ( ) { if ( $ this -> yearOffset !== 0 ) { $ this -> generateTimetable ( 0 ) ; } else { reset ( $ this -> minutes ) ; reset ( $ this -> hours ) ; reset ( $ this -> monthAndDays ) ; } }
9454	protected function doParse ( StringReader $ string ) { $ val = null ; $ type = substr ( $ string -> read ( 2 ) , 0 , 1 ) ; switch ( $ type ) { case 'a' : $ count = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; $ val = [ ] ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ array_key = $ this -> doParse ( $ string ) ; $ array_value = $ this -> doParse ( $ string ) ; $ val [ $ array_key ] = $ array_value ; } $ string -> read ( 1 ) ; break ; case 'O' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ class = $ string -> read ( 2 + $ len ) ; $ string -> read ( 1 ) ; $ properties = [ '__class_name' => $ class ] ; $ len = ( int ) $ string -> readUntil ( ':' ) ; $ string -> read ( 1 ) ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ prop_key = $ this -> doParse ( $ string ) ; $ prop_value = $ this -> doParse ( $ string ) ; if ( substr ( $ prop_key , 0 , strlen ( self :: PROTECTED_PREFIX ) ) == self :: PROTECTED_PREFIX ) { $ prop_key = substr ( $ prop_key , strlen ( self :: PROTECTED_PREFIX ) ) ; } if ( substr ( $ prop_key , 0 , 1 ) == "\0" ) { list ( , $ private_class , $ private_property_name ) = explode ( "\0" , $ prop_key ) ; $ prop_key = $ private_property_name ; } $ properties [ $ prop_key ] = $ prop_value ; } $ string -> read ( 1 ) ; $ val = ( object ) $ properties ; break ; case 's' : $ len = ( int ) $ string -> readUntil ( ':' ) ; $ val = $ string -> read ( $ len + 2 ) ; $ string -> read ( 1 ) ; break ; case 'i' : $ val = ( int ) $ string -> readUntil ( ';' ) ; break ; case 'd' : $ val = ( float ) $ string -> readUntil ( ';' ) ; break ; case 'b' : $ bool = $ string -> read ( 2 ) ; $ val = substr ( $ bool , 0 , 1 ) == '1' ; break ; case 'N' : $ val = null ; break ; default : throw new \ Exception ( sprintf ( 'Unable to unserialize type "%s"' , $ type ) ) ; } return $ val ; }
11980	protected function query ( $ api , $ from , $ to ) { $ params = [ 'begin_date' => $ from , 'end_date' => $ to , ] ; return $ this -> parseJSON ( 'json' , [ $ api , $ params ] ) ; }
8130	public function addSuggestions ( $ name , array $ items ) { if ( ! $ alternatives = self :: computeAlternatives ( $ name , $ items ) ) { return ; } $ this -> appendMessage ( sprintf ( ' Did you mean "%s"?' , implode ( '", "' , $ alternatives ) ) ) ; }
3391	public function confirm ( $ confirmation_code ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> where ( 'confirmation_code' , $ confirmation_code ) -> firstOrFail ( ) ; $ user -> confirmation_code = null ; $ user -> confirmed_at = now ( ) ; $ user -> save ( ) ; event ( new Confirmed ( $ user ) ) ; return $ this -> confirmed ( $ user ) ? : redirect ( $ this -> redirectAfterConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_successful' ) ) ; }
11234	protected function checkValue ( $ value , $ subject , $ reference ) { if ( is_null ( $ value ) ) { return $ subject ; } elseif ( $ subject != $ reference ) { throw new RuntimeException ( Message :: get ( Message :: MSG_REF_MALFORMED , $ reference ) , Message :: MSG_REF_MALFORMED ) ; } else { return $ value ; } }
7283	public function updateCustomerGroupAndCurrency ( ) { if ( ! $ this -> hasCart ( ) || $ this -> cart -> isLocked ( ) ) { return $ this ; } if ( null !== $ customer = $ this -> cart -> getCustomer ( ) ) { if ( $ this -> cart -> getCustomerGroup ( ) !== $ customer -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } } if ( null === $ this -> cart -> getCustomerGroup ( ) ) { $ this -> cart -> setCustomerGroup ( $ this -> customerProvider -> getCustomerGroup ( ) ) ; } if ( null === $ this -> cart -> getCurrency ( ) ) { $ this -> cart -> setCurrency ( $ this -> currencyProvider -> getCurrency ( ) ) ; } return $ this ; }
9726	public function logWrite ( IWriter $ writer , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ reflection = new ReflectionClass ( $ writer ) ; $ format = $ reflection -> getShortName ( ) ; $ message = "Write {$format} format to <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
6364	public function nullsFirst ( ) : Ordering { return Ordering :: from ( Collections :: comparatorFrom ( function ( $ object1 , $ object2 ) { return $ object1 === null ? - 1 : ( $ object2 === null ? 1 : $ this -> compare ( $ object1 , $ object2 ) ) ; } ) ) ; }
2805	public function viewAction ( ) { $ token = ( string ) $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) ; return $ this -> _getRefererUrl ( ) ; } $ requestInfo = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestInfo -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; return $ this -> _getRefererUrl ( ) ; } $ section = $ this -> getRequest ( ) -> getParam ( 'panel' , 'request' ) ; if ( ! in_array ( $ section , array ( 'request' , 'performance' , 'events' , 'db' , 'logging' , 'email' , 'layout' , 'config' ) ) ) { $ section = 'request' ; } Mage :: register ( 'sheep_debug_request_info' , $ requestInfo ) ; $ blockName = 'sheep_debug_' . $ section ; $ blockTemplate = "sheep_debug/view/panel/{$section}.phtml" ; $ this -> loadLayout ( ) ; $ layout = $ this -> getLayout ( ) ; $ sectionBlock = $ layout -> createBlock ( 'sheep_debug/view' , $ blockName , array ( 'template' => $ blockTemplate ) ) ; $ layout -> getBlock ( 'sheep_debug_content' ) -> insert ( $ sectionBlock ) ; $ layout -> getBlock ( 'root' ) -> setHeaderTitle ( $ this -> __ ( 'Profile for request %s (%s)' , $ requestInfo -> getRequestPath ( ) , $ requestInfo -> getToken ( ) ) ) ; $ this -> renderLayout ( ) ; }
1420	protected function pointer ( string $ path , ? string $ member = null ) : array { $ withoutMember = is_null ( $ member ) || '' === $ member ; $ pointer = ! $ withoutMember ? sprintf ( '%s/%s' , rtrim ( $ path , '/' ) , $ member ) : $ path ; return [ Error :: SOURCE_POINTER => $ pointer ] ; }
7695	function MsPowerpoint_InitSlideLst ( $ Master = false ) { if ( $ Master ) { $ RefLst = & $ this -> OpenXmlSlideMasterLst ; } else { $ RefLst = & $ this -> OpenXmlSlideLst ; } if ( $ RefLst !== false ) return $ RefLst ; $ PresFile = 'ppt/presentation.xml' ; $ prefix = ( $ Master ) ? 'slideMasters/' : 'slides/' ; $ o = $ this -> OpenXML_Rels_GetObj ( 'ppt/presentation.xml' , $ prefix ) ; $ Txt = $ this -> FileRead ( $ PresFile ) ; if ( $ Txt === false ) return false ; $ p = 0 ; $ i = 0 ; $ lst = array ( ) ; $ tag = ( $ Master ) ? 'p:sldMasterId' : 'p:sldId' ; while ( $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , $ tag , $ p ) ) { $ i ++ ; $ rid = $ loc -> GetAttLazy ( 'r:id' ) ; if ( $ rid === false ) { $ this -> RaiseError ( "(Init Slide List) attribute 'r:id' is missing for slide #$i in '$PresFile'." ) ; } elseif ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ f = 'ppt/' . $ o -> TargetLst [ $ rid ] ; $ lst [ ] = array ( 'file' => $ f , 'idx' => $ this -> FileGetIdx ( $ f ) , 'rid' => $ rid ) ; } else { $ this -> RaiseError ( "(Init Slide List) Slide corresponding to rid=$rid is not found in the Rels file of '$PresFile'." ) ; } $ p = $ loc -> PosEnd ; } $ RefLst = $ lst ; return $ RefLst ; }
10397	protected function processDiscriminatorMap ( ClassMetadataInfo $ metadata ) { $ newMap = [ ] ; foreach ( $ metadata -> discriminatorMap as $ mapId => $ mappedEntityName ) { $ newKey = $ this -> doReplacement ( $ mapId ) ; $ newMap [ $ newKey ] = $ mappedEntityName ; } $ metadata -> discriminatorMap = $ newMap ; }
6416	public static function skip ( IteratorAggregate $ iterable , int $ numberToSkip ) : IteratorAggregate { return new CallableIterable ( function ( ) use ( $ iterable , $ numberToSkip ) { $ iterator = Iterators :: from ( $ iterable -> getIterator ( ) ) ; Iterators :: advance ( $ iterator , $ numberToSkip ) ; return $ iterator ; } ) ; }
2543	public function analyzeWithErrCodeAndMsgQueryFixedCat ( SendResult $ response , $ qErr , $ qMsg , $ category ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; $ errorMsgNodeList = $ domXpath -> query ( $ qMsg ) ; if ( $ errorCodeNodeList -> length > 0 || $ errorMsgNodeList -> length > 0 ) { $ analyzeResponse -> status = $ category ; $ errorCode = ( $ errorCodeNodeList -> length > 0 ) ? $ errorCodeNodeList -> item ( 0 ) -> nodeValue : null ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCode , $ this -> makeMessageFromMessagesNodeList ( $ errorMsgNodeList ) ) ; } return $ analyzeResponse ; }
3872	protected function getJumpTosFor ( $ metaModels , $ filter , $ view , $ rootPage = null ) { $ entries = array ( ) ; $ items = $ metaModels -> findByFilter ( $ filter ) ; foreach ( $ items as $ item ) { $ jumpTo = $ item -> buildJumpToLink ( $ view ) ; $ event = new GetPageDetailsEvent ( $ jumpTo [ 'page' ] ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; $ pageDetails = $ event -> getPageDetails ( ) ; if ( $ pageDetails === null || ( $ rootPage !== null && $ pageDetails [ 'rootId' ] != $ rootPage ) ) { continue ; } $ url = $ this -> getBaseUrl ( $ pageDetails , $ jumpTo [ 'url' ] ) ; $ entries [ ] = $ url -> getUrl ( ) ; } return $ entries ; }
2719	private function isHostInDomainList ( $ host ) { $ urlTypes = [ UrlInterface :: URL_TYPE_LINK , UrlInterface :: URL_TYPE_DIRECT_LINK , UrlInterface :: URL_TYPE_WEB , UrlInterface :: URL_TYPE_MEDIA , UrlInterface :: URL_TYPE_STATIC ] ; $ secureScheme = [ true , false ] ; foreach ( $ this -> storeManager -> getStores ( ) as $ store ) { foreach ( $ urlTypes as $ urlType ) { foreach ( $ secureScheme as $ scheme ) { $ shopHost = \ Zend_Uri :: factory ( $ store -> getBaseUrl ( $ urlType , $ scheme ) ) -> getHost ( ) ; if ( $ host === $ shopHost ) { return true ; } } } } return false ; }
2590	public function setArrivalDate ( \ DateTime $ arrivalDate ) { $ this -> arrivalDate = ( $ arrivalDate -> format ( 'dmy' ) !== '000000' ) ? $ arrivalDate -> format ( 'dmy' ) : null ; $ time = $ arrivalDate -> format ( 'Hi' ) ; if ( $ time !== '0000' ) { $ this -> arrivalTime = $ time ; } }
11097	public static function secondsBetweenDates ( $ start , $ end , $ absolute = true , $ timezone = 'Europe/Prague' ) { $ timezoneObj = new \ DateTimeZone ( $ timezone ) ; $ date = new DateTime ( $ end , $ timezoneObj ) ; $ diff = $ date -> diff ( new DateTime ( $ start , $ timezoneObj ) , $ absolute ) ; return ( $ diff -> invert ? - 1 : 1 ) * ( ( $ diff -> days * 86400 ) + ( $ diff -> h * 3600 ) + ( $ diff -> i * 60 ) + $ diff -> s ) ; }
3854	public function setMetaModel ( $ intMetaModel , $ intView ) { $ this -> intMetaModel = $ intMetaModel ; $ this -> intView = $ intView ; $ this -> prepareMetaModel ( ) ; $ this -> prepareView ( ) ; return $ this ; }
7097	public function normalizeStock ( StockSubjectInterface $ subject , $ format = null , array $ context = [ ] ) { $ translator = $ this -> constantHelper -> getTranslator ( ) ; $ formatter = $ this -> getFormatter ( ) ; if ( null !== $ eda = $ subject -> getEstimatedDateOfArrival ( ) ) { $ eda = $ formatter -> date ( $ eda ) ; } else { $ eda = $ translator -> trans ( 'ekyna_core.value.undefined' ) ; } $ stockUnits = $ this -> findStockUnits ( $ subject ) ; return [ 'mode_label' => $ this -> constantHelper -> renderStockSubjectModeLabel ( $ subject ) , 'mode_badge' => $ this -> constantHelper -> renderStockSubjectModeBadge ( $ subject ) , 'state_label' => $ this -> constantHelper -> renderStockSubjectStateLabel ( $ subject ) , 'state_badge' => $ this -> constantHelper -> renderStockSubjectStateBadge ( $ subject ) , 'in' => $ formatter -> number ( $ subject -> getInStock ( ) ) , 'available' => $ formatter -> number ( $ subject -> getAvailableStock ( ) ) , 'virtual' => $ formatter -> number ( $ subject -> getVirtualStock ( ) ) , 'floor' => $ formatter -> number ( $ subject -> getStockFloor ( ) ) , 'geocode' => $ subject -> getGeocode ( ) , 'replenishment' => $ formatter -> number ( $ subject -> getReplenishmentTime ( ) ) , 'eda' => $ eda , 'moq' => $ formatter -> number ( $ subject -> getMinimumOrderQuantity ( ) ) , 'quote_only' => $ subject -> isQuoteOnly ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'end_of_life' => $ subject -> isEndOfLife ( ) ? $ translator -> trans ( 'ekyna_core.value.yes' ) : $ translator -> trans ( 'ekyna_core.value.no' ) , 'stock_units' => $ this -> normalizer -> normalize ( $ stockUnits , $ format , $ context ) , ] ; }
9630	public function verifyAndMoveUploadedFile ( $ originSize , $ tmpDestination , $ publicDestination ) { $ remoteTempSize = $ this -> getSize ( $ tmpDestination ) ; $ this -> logger -> debug ( 'Temp size: ' . $ remoteTempSize ) ; $ this -> logger -> debug ( 'Origin size: ' . $ originSize ) ; if ( $ remoteTempSize <= 0 ) { throw new VerifySizeException ( 'Uploaded file has size ' . $ remoteTempSize ) ; } if ( $ remoteTempSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Uploaded file has wrong size. Expected %s, got %s.' , $ originSize , $ remoteTempSize ) ) ; } $ this -> logger -> info ( 'OK: Uploaded temp file has right size.' ) ; if ( ! $ this -> move ( $ tmpDestination , $ publicDestination ) ) { throw new FtpException ( 'Error renaming uploaded file from temp to public.' ) ; } $ remotePublicSize = $ this -> getSize ( $ publicDestination ) ; $ this -> logger -> debug ( 'Renamed size: ' . $ remotePublicSize ) ; if ( $ remotePublicSize <= 0 ) { throw new VerifySizeException ( 'Renamed file has size ' . $ remotePublicSize ) ; } if ( $ remotePublicSize !== $ originSize ) { throw new VerifySizeException ( sprintf ( 'Renamed file has wrong size. Expected %s, got %s.' , $ originSize , $ remotePublicSize ) ) ; } $ this -> logger -> info ( 'OK: Renamed file has right size.' ) ; return true ; }
4728	private function setCache ( $ singular , $ plural = null ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( $ plural === null ) { $ plural = $ singular ; } else { $ plural = StringHelper :: strtolower ( $ plural ) ; } $ this -> cache [ $ singular ] = $ plural ; }
3989	public function getScreen ( $ tableName ) { $ inputScreens = $ this -> getInputScreens ( ) ; if ( isset ( $ inputScreens [ $ tableName ] ) ) { return $ inputScreens [ $ tableName ] ; } return null ; }
6032	public function getDeployedFile ( $ templateId , $ templateType = self :: TEMPLATE_IMAGE , $ siteId = null ) { foreach ( $ this -> deployedFiles as $ deployedFile ) { if ( null === $ siteId || $ siteId == $ deployedFile -> getDeployMentSiteId ( ) ) { if ( self :: TEMPLATE_VIDEO == $ templateType ) { if ( $ templateId == $ deployedFile -> getVideoTemplateId ( ) && null === $ deployedFile -> getImageTemplateId ( ) ) { return $ deployedFile ; } } elseif ( self :: TEMPLATE_IMAGE == $ templateType && $ templateId == $ deployedFile -> getImageTemplateId ( ) || ( null === $ templateId && null === $ deployedFile -> getImageTemplateId ( ) && null === $ deployedFile -> getVideoTemplateId ( ) ) ) { return $ deployedFile ; } } } throw new NotFoundException ( 'No DeploymentFile with the id "' . $ templateId . '" exists.' ) ; }
1791	private function prepareDomain ( RequestContext $ context , array & $ parameters , int & $ referenceType ) : void { if ( isset ( $ parameters [ '_ssl' ] ) ) { $ context -> setScheme ( true === $ parameters [ '_ssl' ] ? 'https' : 'http' ) ; } if ( isset ( $ parameters [ '_domain' ] ) && '' !== $ parameters [ '_domain' ] ) { $ this -> addHostToContext ( $ context , $ parameters , $ referenceType ) ; } unset ( $ parameters [ '_domain' ] , $ parameters [ '_ssl' ] ) ; }
10128	private function writeBreaks ( ) { $ vbreaks = [ ] ; $ hbreaks = [ ] ; foreach ( $ this -> phpSheet -> getBreaks ( ) as $ cell => $ breakType ) { $ coordinates = Coordinate :: coordinateFromString ( $ cell ) ; switch ( $ breakType ) { case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_COLUMN : $ vbreaks [ ] = Coordinate :: columnIndexFromString ( $ coordinates [ 0 ] ) - 1 ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_ROW : $ hbreaks [ ] = $ coordinates [ 1 ] ; break ; case \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet :: BREAK_NONE : default : break ; } } if ( ! empty ( $ hbreaks ) ) { sort ( $ hbreaks , SORT_NUMERIC ) ; if ( $ hbreaks [ 0 ] == 0 ) { array_shift ( $ hbreaks ) ; } $ record = 0x001b ; $ cbrk = count ( $ hbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ hbreaks as $ hbreak ) { $ data .= pack ( 'vvv' , $ hbreak , 0x0000 , 0x00ff ) ; } $ this -> append ( $ header . $ data ) ; } if ( ! empty ( $ vbreaks ) ) { $ vbreaks = array_slice ( $ vbreaks , 0 , 1000 ) ; sort ( $ vbreaks , SORT_NUMERIC ) ; if ( $ vbreaks [ 0 ] == 0 ) { array_shift ( $ vbreaks ) ; } $ record = 0x001a ; $ cbrk = count ( $ vbreaks ) ; $ length = 2 + 6 * $ cbrk ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ cbrk ) ; foreach ( $ vbreaks as $ vbreak ) { $ data .= pack ( 'vvv' , $ vbreak , 0x0000 , 0xffff ) ; } $ this -> append ( $ header . $ data ) ; } }
324	public static function camel2words ( $ name , $ ucwords = true ) { $ label = mb_strtolower ( trim ( str_replace ( [ '-' , '_' , '.' , ] , ' ' , preg_replace ( '/(?<!\p{Lu})(\p{Lu})|(\p{Lu})(?=\p{Ll})/u' , ' \0' , $ name ) ) ) , self :: encoding ( ) ) ; return $ ucwords ? StringHelper :: mb_ucwords ( $ label , self :: encoding ( ) ) : $ label ; }
7142	private function registerActions ( ContainerBuilder $ container ) { if ( class_exists ( 'Ekyna\Component\Payum\Payzen\PayzenGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.convert_payment' , $ definition ) ; $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Payzen\Action\FraudLevelAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'payzen' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.payzen.fraud_level' , $ definition ) ; } if ( class_exists ( 'Ekyna\Component\Payum\Sips\SipsGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Sips\Action\ConvertAction' ) ; $ definition -> addTag ( 'payum.action' , [ 'factory' => 'atos_sips' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.sips.convert_payment' , $ definition ) ; } if ( class_exists ( 'Payum\Paypal\ExpressCheckout\Nvp\PaypalExpressCheckoutGatewayFactory' ) ) { $ definition = new Definition ( 'Ekyna\Component\Commerce\Bridge\Payum\Paypal\Action\EcNvpConvertAction' ) ; $ definition -> setArgument ( 0 , new Reference ( 'ekyna_commerce.common.amount_calculator' ) ) ; if ( $ container -> has ( 'ekyna_setting.manager' ) && class_exists ( 'Ekyna\Bundle\AdminBundle\Settings\GeneralSettingsSchema' ) ) { $ definition -> setArgument ( 1 , new Expression ( "service('ekyna_setting.manager').getParameter('general.site_name')" ) ) ; } $ definition -> addTag ( 'payum.action' , [ 'factory' => 'paypal_express_checkout' , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.paypal_ec_nvp.convert_payment' , $ definition ) ; } $ actions = [ 'capture_payment' => Action \ CaptureAction :: class , 'notify_payment' => Action \ NotifyAction :: class , 'status_payment' => Action \ StatusAction :: class , ] ; foreach ( $ actions as $ name => $ class ) { $ definition = new Definition ( $ class ) ; $ definition -> addTag ( 'payum.action' , [ 'all' => true , 'prepend' => true ] ) ; $ container -> setDefinition ( 'ekyna_commerce.payum.action.' . $ name , $ definition ) ; } }
6490	public function getDrupalSelector ( $ name ) { $ selectors = $ this -> getDrupalParameter ( 'selectors' ) ; if ( ! isset ( $ selectors [ $ name ] ) ) { throw new \ Exception ( sprintf ( 'No such selector configured: %s' , $ name ) ) ; } return $ selectors [ $ name ] ; }
12864	public function postDispatch ( Zend_Controller_Request_Abstract $ request ) { $ methods = implode ( ', ' , array_unique ( $ this -> _methods ) ) ; $ headers = implode ( ', ' , array_unique ( $ this -> _headers ) ) ; if ( $ this -> _credentials ) { header ( 'Access-Control-Allow-Credentials: true' , true ) ; } header ( "Access-Control-Allow-Origin: {$this->_origin}" , true ) ; header ( "Access-Control-Allow-Methods: {$methods}" , true ) ; header ( "Access-Control-Allow-Headers: {$headers}" , true ) ; header ( "Access-Control-Max-Age: {$this->_maxAge}" , true ) ; header ( 'X-XSS-Protection: 1; mode=block' , true ) ; header ( 'X-Frame-Options: SAMEORIGIN' , true ) ; }
10016	public function addExternalSheet ( Worksheet $ pSheet , $ iSheetIndex = null ) { if ( $ this -> sheetNameExists ( $ pSheet -> getTitle ( ) ) ) { throw new Exception ( "Workbook already contains a worksheet named '{$pSheet->getTitle()}'. Rename the external sheet first." ) ; } $ countCellXfs = count ( $ this -> cellXfCollection ) ; foreach ( $ pSheet -> getParent ( ) -> getCellXfCollection ( ) as $ cellXf ) { $ this -> addCellXf ( clone $ cellXf ) ; } $ pSheet -> rebindParent ( $ this ) ; foreach ( $ pSheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ pSheet -> getCell ( $ coordinate ) ; $ cell -> setXfIndex ( $ cell -> getXfIndex ( ) + $ countCellXfs ) ; } return $ this -> addSheet ( $ pSheet , $ iSheetIndex ) ; }
8743	public function start ( ) { $ this -> eventDispatcher -> addListener ( 'key:stop:listening' , function ( ) { $ this -> isListening = false ; } ) ; $ this -> resetListener ( ) -> overrideReadlineHandler ( ) -> runLoop ( ) -> restoreReadlineHandler ( ) ; }
3404	public function lock ( Output $ output ) { if ( ! $ this -> lock ) { return ; } $ this -> lock = $ this -> getApplication ( ) -> getLockFactory ( ) -> createLock ( $ this -> getName ( ) ) ; if ( ! $ this -> lock -> acquire ( ) ) { $ output -> error ( "Another instance of this command (" . $ this -> getName ( ) . ") is currently running" ) ; exit ( Application :: STATUS_LOCKED ) ; } }
391	protected static function filterValidAliases ( Query $ query ) { $ tables = $ query -> getTablesUsedInFrom ( ) ; $ aliases = array_diff ( array_keys ( $ tables ) , $ tables ) ; return array_map ( function ( $ alias ) { return preg_replace ( '/{{([\w]+)}}/' , '$1' , $ alias ) ; } , array_values ( $ aliases ) ) ; }
11346	public function renderFields ( ) { $ html = '' ; foreach ( $ this -> fields as $ field ) { $ html .= $ this -> formatter -> renderField ( $ field ) ; } return $ html ; }
5502	protected function dieOnNoMethod ( $ method , $ task ) { if ( $ this -> is_strict && ! method_exists ( $ this , $ method ) ) { $ errormsg = sprintf ( 'Cannot %s. Method %s() not in class %s.' , $ task , $ method , get_class ( $ this ) ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
6396	public function run ( ) : void { $ thrownException = null ; try { $ this -> lock -> lock ( ) ; try { $ this -> runnable -> run ( ) ; } catch ( Exception $ e ) { self :: getLogger ( ) -> error ( $ e ) ; $ thrownException = $ e ; } $ this -> lock -> unLock ( ) ; } catch ( LockException $ e ) { throw new RunException ( 'Lock error during running.' , 0 , $ e ) ; } if ( $ thrownException !== null ) { throw new RunException ( 'Error during execution wrapped Runnable object.' , 0 , $ thrownException ) ; } }
962	public function buildAuthUrl ( $ mode = null ) { return $ this -> api -> getAuthUrl ( Config :: get ( 'shopify-app.api_scopes' ) , URL :: secure ( Config :: get ( 'shopify-app.api_redirect' ) ) , $ mode ?? 'offline' ) ; }
4014	protected function getHelpWizard ( $ key , $ field ) { if ( empty ( $ field [ 'eval' ] [ 'helpwizard' ] ) ) { return '' ; } $ event = new GenerateHtmlEvent ( 'about.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] , 'style="vertical-align:text-bottom;"' ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: IMAGE_GET_HTML , $ event ) ; return sprintf ( ' <a href="%shelp.php?table=%s&amp;field=%s_%s" title="%s" rel="lightbox[help 610 80%]">%s</a>' , TL_PATH . 'contao/' , $ this -> strTable , $ this -> strName , $ key , StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'helpWizard' ] ) , $ event -> getHtml ( ) ) ; }
9822	public function writeRelationships ( Spreadsheet $ spreadsheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'Relationships' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/package/2006/relationships' ) ; $ customPropertyList = $ spreadsheet -> getProperties ( ) -> getCustomProperties ( ) ; if ( ! empty ( $ customPropertyList ) ) { $ this -> writeRelationship ( $ objWriter , 4 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties' , 'docProps/custom.xml' ) ; } $ this -> writeRelationship ( $ objWriter , 3 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties' , 'docProps/app.xml' ) ; $ this -> writeRelationship ( $ objWriter , 2 , 'http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties' , 'docProps/core.xml' ) ; $ this -> writeRelationship ( $ objWriter , 1 , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument' , 'xl/workbook.xml' ) ; if ( $ spreadsheet -> hasRibbon ( ) ) { $ this -> writeRelationShip ( $ objWriter , 5 , 'http://schemas.microsoft.com/office/2006/relationships/ui/extensibility' , $ spreadsheet -> getRibbonXMLData ( 'target' ) ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2174	private function setUpDatabaseConnection ( ) : Response { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } if ( false !== getenv ( 'DATABASE_URL' ) ) { return $ this -> render ( 'misconfigured_database_url.html.twig' ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ this -> getContainerParameter ( 'database_host' ) , 'database_port' => $ this -> getContainerParameter ( 'database_port' ) , 'database_user' => $ this -> getContainerParameter ( 'database_user' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ this -> getContainerParameter ( 'database_name' ) , ] , ] ; if ( 'tl_database_login' !== $ request -> request -> get ( 'FORM_SUBMIT' ) ) { return $ this -> render ( 'database.html.twig' , $ parameters ) ; } $ parameters = [ 'parameters' => [ 'database_host' => $ request -> request -> get ( 'dbHost' ) , 'database_port' => $ request -> request -> get ( 'dbPort' ) , 'database_user' => $ request -> request -> get ( 'dbUser' ) , 'database_password' => $ this -> getContainerParameter ( 'database_password' ) , 'database_name' => $ request -> request -> get ( 'dbName' ) , ] , ] ; if ( '*****' !== $ request -> request -> get ( 'dbPassword' ) ) { $ parameters [ 'parameters' ] [ 'database_password' ] = $ request -> request -> get ( 'dbPassword' ) ; } if ( false !== strpos ( $ parameters [ 'parameters' ] [ 'database_name' ] , '.' ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_dot_in_dbname' ) ] ) ) ; } $ installTool = $ this -> container -> get ( 'contao.install_tool' ) ; $ installTool -> setConnection ( ConnectionFactory :: create ( $ parameters ) ) ; if ( ! $ installTool -> canConnectToDatabase ( $ parameters [ 'parameters' ] [ 'database_name' ] ) ) { return $ this -> render ( 'database.html.twig' , array_merge ( $ parameters , [ 'database_error' => $ this -> trans ( 'database_could_not_connect' ) ] ) ) ; } $ dumper = new ParameterDumper ( $ this -> getContainerParameter ( 'kernel.project_dir' ) ) ; $ dumper -> setParameters ( $ parameters ) ; $ dumper -> dump ( ) ; $ this -> purgeSymfonyCache ( ) ; return $ this -> getRedirectResponse ( ) ; }
8950	private function addRouters ( ) { $ builder = $ this -> getContainerBuilder ( ) ; $ router = $ builder -> getDefinition ( 'router' ) ; $ routerFactories = array ( ) ; foreach ( $ builder -> findByTag ( self :: TAG_ROUTER ) as $ serviceName => $ priority ) { if ( is_bool ( $ priority ) ) { $ priority = 100 ; } $ routerFactories [ $ priority ] [ $ serviceName ] = $ serviceName ; } if ( ! empty ( $ routerFactories ) ) { krsort ( $ routerFactories , SORT_NUMERIC ) ; foreach ( $ routerFactories as $ priority => $ items ) { $ routerFactories [ $ priority ] = $ items ; } foreach ( $ routerFactories as $ priority => $ items ) { foreach ( $ items as $ serviceName ) { $ factory = new Nette \ DI \ Statement ( array ( '@' . $ serviceName , 'createRouter' ) ) ; $ router -> addSetup ( 'offsetSet' , array ( NULL , $ factory ) ) ; } } } }
12857	function giveBuiltInQueue ( iQueueDriver $ queueDriver ) { if ( $ this -> builtinQueue ) throw new exImmutable ( sprintf ( 'Built-in Queue (%s) is given.' , \ Poirot \ Std \ flatten ( $ this -> builtinQueue ) ) ) ; $ this -> builtinQueue = $ queueDriver ; return $ this ; }
4096	public function build ( ) { $ built = array ( ) ; if ( $ this -> fieldname ) { $ built [ $ this -> fieldname ] = array ( ) ; foreach ( array ( "from" , "to" , "includeLower" , "includeUpper" , "boost" ) as $ opt ) { if ( $ this -> $ opt !== null ) $ built [ $ this -> fieldname ] [ $ opt ] = $ this -> $ opt ; } if ( count ( $ built [ $ this -> fieldname ] ) == 0 ) throw new \ ElasticSearch \ Exception ( "Empty RangeQuery cant be created" ) ; } return $ built ; }
2688	private function fastlyRotate ( $ angle ) { $ angle = ( int ) $ angle ; $ orient = null ; if ( $ angle == 90 ) { $ orient = 'r' ; } if ( $ angle == - 90 || $ angle == 270 ) { $ orient = 'l' ; } if ( $ angle == 180 ) { $ orient = 3 ; } if ( $ orient !== null ) { $ this -> fastlyParameters [ 'orient' ] = $ orient ; } return $ this ; }
5781	private function getSectionForAdministrator ( array $ section , string $ sectionName ) : array { if ( isset ( $ section [ 'authorization' ] ) && ! $ this -> container -> authorization -> isAuthorized ( $ section [ 'authorization' ] ) ) { return [ ] ; } $ updatedSection = [ ] ; foreach ( $ section as $ key => $ value ) { if ( $ key != 'subSections' ) { $ updatedSection [ $ key ] = $ value ; } } $ updatedSubSections = [ ] ; if ( isset ( $ section [ 'subSections' ] ) ) { foreach ( $ section [ 'subSections' ] as $ subSectionName => $ subSection ) { $ updatedSubSection = $ this -> getSectionForAdministrator ( $ subSection , $ subSectionName ) ; if ( count ( $ updatedSubSection ) > 0 ) { $ updatedSubSections [ $ subSectionName ] = $ updatedSubSection ; } } } if ( count ( $ updatedSubSections ) > 0 ) { $ updatedSection [ 'subSections' ] = $ updatedSubSections ; } return $ updatedSection ; }
3425	public function getById ( $ id ) { if ( ! $ id || $ this -> queryShouldBeStopped ) { return false ; } $ this -> sort = [ ] ; $ this -> filter [ 'ID' ] = $ id ; return $ this -> getList ( ) -> first ( null , false ) ; }
7808	public function setCurlNumRetries ( $ retries ) { if ( ! is_numeric ( $ retries ) || $ retries < 0 ) { throw new \ InvalidArgumentException ( 'Retries value must be numeric and a non-negative number.' ) ; } $ this -> curlNumRetries = $ retries ; return $ this ; }
11344	public function removeField ( $ name ) { for ( $ i = 0 ; $ i < count ( $ this -> fields ) ; $ i ++ ) { if ( $ this -> fields [ $ i ] -> getName ( ) == $ name ) { array_splice ( $ this -> fields , $ i , 1 ) ; break ; } } }
8820	public function getClientIP ( ) { $ ip = null ; $ client = $ this -> server ( 'HTTP_CLIENT_IP' ) ; $ forward = $ this -> server ( 'HTTP_X_FORWARDED_FOR' ) ; $ remote = $ this -> server ( 'REMOTE_ADDR' ) ; if ( filter_var ( $ client , FILTER_VALIDATE_IP ) ) { $ ip = $ client ; } elseif ( filter_var ( $ forward , FILTER_VALIDATE_IP ) ) { $ ip = $ forward ; } else { $ ip = $ remote ; } return $ ip ; }
5653	private function longestFlag ( $ flag_sets ) { $ longest = 0 ; foreach ( $ flag_sets as $ flags ) { foreach ( $ flags as $ flag ) { $ longest = max ( $ longest , strlen ( $ this -> renderFlag ( $ flag ) ) ) ; } } return $ longest ; }
9013	public function mediumtext ( string $ charset = null ) : self { $ this -> type = 'mediumtext' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
6185	public function clear ( $ type = 'all' ) { if ( $ type === 'all' ) { $ this -> driver -> remove ( 'flash_messages' ) ; } else { $ flashMessages = $ this -> driver -> get ( 'flash_messages' ) ; unset ( $ flashMessages [ $ type ] ) ; $ this -> driver -> set ( 'flash_messages' , $ flashMessages ) ; } return true ; }
7748	private function isAccessible ( \ ReflectionClass $ class , $ methodName , $ parameters ) { if ( $ class -> hasMethod ( $ methodName ) ) { $ method = $ class -> getMethod ( $ methodName ) ; if ( $ method -> isPublic ( ) && $ method -> getNumberOfRequiredParameters ( ) === $ parameters ) { return true ; } } return false ; }
4801	public function injectSpecialBindings ( string $ sql , array $ bindings ) : string { foreach ( self :: SPECIAL_BINDINGS as $ special ) { $ specialPlaceholder = ":" . $ special ; if ( ! array_key_exists ( $ special , $ bindings ) ) { continue ; } $ replacement = $ this -> escapeSpecialBinding ( $ bindings [ $ special ] , $ special ) ; $ sql = str_replace ( $ specialPlaceholder , $ replacement , $ sql ) ; unset ( $ bindings [ $ special ] ) ; } foreach ( $ bindings as $ key => $ value ) { if ( is_array ( $ value ) ) { $ inString = "" ; foreach ( $ value as $ i => $ innerValue ) { $ newKey = $ key . "__" . $ i ; $ keyParamString = ":$newKey" ; $ inString .= "$keyParamString, " ; } $ inString = rtrim ( $ inString , " ," ) ; $ sql = str_replace ( ":$key" , $ inString , $ sql ) ; } } return $ sql ; }
682	protected function validateOperatorCondition ( $ operator , $ condition , $ attribute = null ) { if ( $ attribute === null ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireAttribute' , [ 'operator' => $ operator ] ) ) ; return ; } $ internalOperator = $ this -> filterControls [ $ operator ] ; $ operatorTypes = $ this -> operatorTypes [ $ internalOperator ] ; if ( $ operatorTypes !== '*' ) { $ attributeTypes = $ this -> getSearchAttributeTypes ( ) ; $ attributeType = $ attributeTypes [ $ attribute ] ; if ( ! in_array ( $ attributeType , $ operatorTypes , true ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'unsupportedOperatorType' , [ 'attribute' => $ attribute , 'operator' => $ operator ] ) ) ; return ; } } if ( in_array ( $ internalOperator , $ this -> multiValueOperators , true ) ) { if ( ! is_array ( $ condition ) ) { $ this -> addError ( $ this -> filterAttributeName , $ this -> parseErrorMessage ( 'operatorRequireMultipleOperands' , [ 'operator' => $ operator ] ) ) ; } else { foreach ( $ condition as $ v ) { $ this -> validateAttributeValue ( $ attribute , $ v ) ; } } } else { $ this -> validateAttributeValue ( $ attribute , $ condition ) ; } }
357	function checkPhpExtensionVersion ( $ extensionName , $ version , $ compare = '>=' ) { if ( ! extension_loaded ( $ extensionName ) ) { return false ; } $ extensionVersion = phpversion ( $ extensionName ) ; if ( empty ( $ extensionVersion ) ) { return false ; } if ( strncasecmp ( $ extensionVersion , 'PECL-' , 5 ) === 0 ) { $ extensionVersion = substr ( $ extensionVersion , 5 ) ; } return version_compare ( $ extensionVersion , $ version , $ compare ) ; }
5309	protected function getPathFromCircle ( SimpleXMLElement $ circle ) { $ mult = 0.55228475 ; return 'M' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'C' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . $ circle [ 'cx' ] . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . 'C' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . ( $ circle [ 'cy' ] + $ circle [ 'r' ] * $ mult ) . ' ' . ( $ circle [ 'cx' ] - $ circle [ 'r' ] ) . ' ' . $ circle [ 'cy' ] . 'Z' ; }
12002	static public function generate ( $ length = 16 , $ algorithm = 'sha256' ) { if ( ! in_array ( $ algorithm , self :: $ allowedAlgorithm ) ) { throw new Exception ( "Hash algorithm $algorithm doesn't exists!" ) ; } $ salt = hash ( $ algorithm , time ( ) ) ; return substr ( hash ( $ algorithm , ( mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) % $ length ) . $ salt . mt_rand ( self :: RAND_MIN , self :: RAND_MAX ) ) , self :: CUT_LEN , $ length ) ; }
8496	public function getFulfillmentPreview ( $ request ) { if ( ! ( $ request instanceof FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ) ) { $ request = new FBAOutboundServiceMWS_Model_GetFulfillmentPreviewRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetFulfillmentPreview' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAOutboundServiceMWS_Model_GetFulfillmentPreviewResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6110	public function fileList ( $ cpw = "" , $ path = "/" , $ recursive = false ) { return $ this -> getParent ( ) -> channelFileList ( $ this -> getId ( ) , $ cpw , $ path , $ recursive ) ; }
12876	private function setNamespace ( $ serviceName = null ) { if ( $ serviceName === null ) { $ this -> storage -> getOptions ( ) -> setNamespace ( $ this -> defaultNamespace ) ; } else { $ this -> storage -> getOptions ( ) -> setNamespace ( $ serviceName ) ; } }
9716	private function writeCountry ( ) { $ record = 0x008C ; $ length = 4 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , $ this -> countryCode , $ this -> countryCode ) ; return $ this -> writeData ( $ header . $ data ) ; }
12095	public function shortText ( $ text , $ length ) { $ text = trim ( $ text ) ; $ charset = mb_detect_encoding ( $ text ) ; if ( mb_strlen ( $ text , $ charset ) > $ length ) { $ text = mb_substr ( $ text , 0 , $ length , $ charset ) . '...' ; } else { $ text = $ text ; } return $ text ; }
8696	public function handle ( ) { $ config = $ this -> option ( 'config' ) ; if ( ! $ config ) { throw new Exception ( 'Config option is required.' ) ; } $ configPath = realpath ( $ config ) ; if ( ! file_exists ( $ configPath ) ) { throw new Exception ( 'Configuration file not found.' ) ; } $ config = require ( $ configPath ) ; $ this -> info ( sprintf ( 'Configuring with file "%s".' , $ configPath ) ) ; $ this -> getRbacService ( ) -> configure ( $ config ) ; $ this -> info ( 'Configuration done.' ) ; }
2622	public function sendConfigurationRequest ( $ configuredFlag ) { if ( $ configuredFlag ) { $ configuredState = self :: FASTLY_CONFIGURED_FLAG ; } else { $ configuredState = self :: FASTLY_NOT_CONFIGURED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ configuredState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ configuredState , 'dt' => ucfirst ( $ configuredState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ configuredState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
7424	public function render ( $ menu = 'Default' , $ debug = false , $ class = null ) { $ response = $ this -> initiateSubRequest ( ) ; return $ response -> getContent ( ) ; }
7504	public function getTf ( string $ key , array $ args = null , array $ replacements = null , string ... $ namespaces ) { if ( empty ( $ namespaces ) ) { $ namespaces = $ this -> meta -> getNamespaces ( ) ; } $ translatedText = $ this -> textService -> tf ( $ namespaces , $ key , $ args , ... $ this -> meta -> getN2nLocales ( ) ) ; $ replacedText = HtmlBuilderMeta :: replace ( $ translatedText , $ replacements , $ this -> view ) ; return new Raw ( $ replacedText ) ; }
7309	public static function now ( $ timezone = null ) { $ now = explode ( ' ' , microtime ( ) ) ; $ unix = $ now [ 1 ] ; $ micro = Time :: sec ( $ now [ 0 ] ) ; $ jd = ( $ unix / 86400.0 ) + static :: UJD ; if ( $ timezone == null ) { $ timezone = TimeZone :: UTC ( ) ; } if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } return static :: jd ( $ jd ) -> add ( $ micro ) -> setTimezone ( $ timezone ) ; }
10328	public function getNestingLevel ( ) { $ nestingLevel = 0 ; $ parent = $ this -> getParent ( ) ; while ( $ parent instanceof SpgrContainer ) { ++ $ nestingLevel ; $ parent = $ parent -> getParent ( ) ; } return $ nestingLevel ; }
6658	public function jsonSerialize ( ) { $ serialized = [ 'message' => $ this -> getPublicMessage ( ) , 'code' => $ this -> getCode ( ) , ] ; if ( $ this -> getPrevious ( ) instanceof $ this ) { $ previous = $ this -> getPrevious ( ) ; $ serialized [ 'previous' ] = $ previous -> jsonSerialize ( ) ; } return $ serialized ; }
2855	public function getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ databaseHandles = array ( ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ layoutResourceModel = Mage :: getResourceModel ( 'core/layout' ) ; $ bind = array ( 'store_id' => $ storeId , 'area' => $ area , 'package' => $ designPackage -> getPackageName ( ) , 'theme' => $ designPackage -> getTheme ( 'layout' ) , 'layout_update_handle' => $ handle ) ; $ readAdapter = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_read' ) ; $ select = $ readAdapter -> select ( ) -> from ( array ( 'layout_update' => $ layoutResourceModel -> getMainTable ( ) ) , array ( 'layout_update_id' , 'xml' ) ) -> join ( array ( 'link' => $ layoutResourceModel -> getTable ( 'core/layout_link' ) ) , 'link.layout_update_id=layout_update.layout_update_id' , '' ) -> where ( 'link.store_id IN (0, :store_id)' ) -> where ( 'link.area = :area' ) -> where ( 'link.package = :package' ) -> where ( 'link.theme = :theme' ) -> where ( 'layout_update.handle = :layout_update_handle' ) -> order ( 'layout_update.sort_order ' . Varien_Db_Select :: SQL_ASC ) ; $ result = $ readAdapter -> fetchAssoc ( $ select , $ bind ) ; if ( count ( $ result ) ) { foreach ( $ result as $ dbLayoutUpdate ) { $ databaseHandles [ $ dbLayoutUpdate [ 'layout_update_id' ] ] = $ dbLayoutUpdate [ 'xml' ] ; } } return $ databaseHandles ; }
5557	protected function tagUrlsWithFrame ( $ urls , $ frame ) { $ tagged = array ( ) ; foreach ( $ urls as $ url ) { if ( ! $ url -> getTarget ( ) ) { $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ frame ) ) ; } $ tagged [ ] = $ url ; } return $ tagged ; }
1134	public function storeNewParent ( ) { if ( $ this -> isDirty ( $ this -> getParentColumnName ( ) ) && ( $ this -> exists || ! $ this -> isRoot ( ) ) ) static :: $ moveToNewParentId = $ this -> getParentId ( ) ; else static :: $ moveToNewParentId = FALSE ; }
6480	private function getSetCookieHeaderValue ( Cookie $ cookie ) : string { $ headerValue = "{$cookie->getName()}=" . urlencode ( $ cookie -> getValue ( ) ) ; if ( ( $ expiration = $ cookie -> getExpiration ( ) ) !== null ) { $ headerValue .= '; Expires=' . $ expiration -> format ( self :: EXPIRATION_DATE_FORMAT ) ; } if ( ( $ maxAge = $ cookie -> getMaxAge ( ) ) !== null ) { $ headerValue .= "; Max-Age=$maxAge" ; } if ( ( $ domain = $ cookie -> getDomain ( ) ) !== null ) { $ headerValue .= '; Domain=' . urlencode ( $ domain ) ; } if ( ( $ path = $ cookie -> getPath ( ) ) !== null ) { $ headerValue .= '; Path=' . urlencode ( $ path ) ; } if ( $ cookie -> isSecure ( ) ) { $ headerValue .= '; Secure' ; } if ( $ cookie -> isHttpOnly ( ) ) { $ headerValue .= '; HttpOnly' ; } if ( ( $ sameSite = $ cookie -> getSameSite ( ) ) !== null ) { $ headerValue .= '; SameSite=' . urlencode ( $ sameSite ) ; } return $ headerValue ; }
5777	public function null_eq ( string $ name , $ arg ) { if ( $ arg === null ) { $ this -> sql .= "$name is null" ; } else { $ this -> args [ ] = $ arg ; $ argNum = count ( $ this -> args ) ; $ this -> sql .= "$name = \$$argNum" ; } return $ this ; }
10737	public function parse ( string $ string ) : self { $ pattern = '/^[\[\(]-?(\d*[\.]?\d+|INF), -?(\d*[\.]?\d+|INF)[\]\)]$/' ; if ( ! preg_match ( $ pattern , $ string ) ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval; see the README for details" ) ; } $ this -> isLowerInclusive = substr ( $ string , 0 , 1 ) === '[' ; $ this -> isUpperInclusive = substr ( $ string , - 1 , 1 ) === ']' ; $ endpoints = explode ( $ this -> separator , substr ( $ string , 1 , - 1 ) ) ; foreach ( $ endpoints as & $ endpoint ) { if ( $ endpoint === self :: INFINITY_NEGATIVE ) { $ endpoint = - INF ; } elseif ( $ endpoint === self :: INFINITY_POSITIVE ) { $ endpoint = INF ; } else { $ endpoint = + $ endpoint ; } } if ( $ endpoints [ 1 ] < $ endpoints [ 0 ] ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the upper bound appears to be greater " . "than the lower bound" ) ; } if ( $ endpoints [ 0 ] == $ endpoints [ 1 ] && $ this -> isLowerInclusive !== $ this -> isUpperInclusive ) { throw new InvalidArgumentException ( __METHOD__ . "() expects parameter one, string, to be a valid " . "interval, however, the endpoints are the same but the " . "boundaries are different" ) ; } $ this -> lower = $ endpoints [ 0 ] ; $ this -> upper = $ endpoints [ 1 ] ; return $ this ; }
4690	public function addGroupBy ( $ expression , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group [ ] = $ expression ; $ this -> pushArgs ( 'group' , $ args ) ; return $ this ; }
3516	public function setLocale ( $ locale ) { if ( $ this -> useCookies ) { Cookie :: queue ( $ this -> cookiePrefix . 'lang_locale' , $ locale ) ; } parent :: setLocale ( $ locale ) ; }
1943	public function onReplaceInsertTags ( string $ tag ) { $ chunks = explode ( '::' , $ tag ) ; if ( 'asset' !== $ chunks [ 0 ] ) { return false ; } $ url = $ this -> packages -> getUrl ( $ chunks [ 1 ] , $ chunks [ 2 ] ?? null ) ; return ltrim ( $ url , '/' ) ; }
10331	public function load ( $ url ) { if ( ! is_string ( $ url ) ) { throw new \ InvalidArgumentException ( 'The url argument must be of type string' ) ; } $ this -> url = $ url ; set_error_handler ( function ( ) { throw new \ Exception ( func_get_arg ( 1 ) ) ; } ) ; $ errorReason = '' ; try { $ urlData = parse_url ( $ this -> url ) ; if ( isset ( $ urlData [ 'host' ] ) ) { $ hostname = $ urlData [ 'host' ] ; if ( substr ( $ hostname , 0 , 4 ) === 'www.' ) { $ hostname = substr ( $ hostname , 4 ) ; } foreach ( self :: $ providers as $ name => $ domains ) { $ done = false ; foreach ( $ domains as $ domain ) { if ( preg_match ( '/^' . str_replace ( [ '.' , '*' ] , [ '\.' , '.*' ] , $ domain ) . '$/' , $ hostname ) ) { include_once __DIR__ . DIRECTORY_SEPARATOR . 'VideoEmbed' . DIRECTORY_SEPARATOR . 'Internal' . DIRECTORY_SEPARATOR . 'Providers' . DIRECTORY_SEPARATOR . $ name . '.php' ; call_user_func ( [ '\IvoPetkov\VideoEmbed\Internal\Providers\\' . $ name , 'load' ] , $ this -> url , $ this ) ; $ done = true ; break ; } } if ( $ done ) { break ; } } } } catch ( \ Exception $ e ) { $ errorReason = $ e -> getMessage ( ) ; } restore_error_handler ( ) ; if ( $ this -> html === null ) { throw new \ Exception ( 'Cannot retrieve information about ' . $ this -> url . ' (reason: ' . ( isset ( $ errorReason { 0 } ) ? $ errorReason : 'unknown' ) . ')' ) ; } }
4785	function offsetExists ( $ key ) { $ this -> access ( $ key ) ; $ return = array_key_exists ( $ key , $ this -> row ) ; if ( ! $ return ) { $ this -> access ( $ key , true ) ; } return $ return ; }
1815	public function tableImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=table' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a> ' . Contao \ Image :: getHtml ( 'demagnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_shrink' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(0.9)"' ) . Contao \ Image :: getHtml ( 'magnify.svg' , '' , 'title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_expand' ] ) . '" style="cursor:pointer" onclick="Backend.tableWizardResize(1.1)"' ) ; }
714	public function float ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_FLOAT , $ precision ) ; }
4375	protected function buildGroupMethod ( $ method , $ args = array ( ) , $ meta = array ( ) ) { $ str = '' ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ label = \ array_shift ( $ args ) ; $ levelClass = isset ( $ meta [ 'level' ] ) ? 'level-' . $ meta [ 'level' ] : null ; if ( ! empty ( $ meta [ 'isMethodName' ] ) ) { $ label = $ this -> markupClassname ( $ label ) ; } foreach ( $ args as $ k => $ v ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ argStr = \ implode ( ', ' , $ args ) ; $ str .= $ this -> debug -> utilities -> buildTag ( 'div' , array ( 'class' => array ( 'group-header' , $ method == 'groupCollapsed' ? 'collapsed' : 'expanded' , $ levelClass , ) , 'data-channel' => $ meta [ 'channel' ] , ) , '<span class="group-label">' . $ label . ( ! empty ( $ argStr ) ? '(</span>' . $ argStr . '<span class="group-label">)' : '' ) . '</span>' ) . "\n" ; $ str .= '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => array ( 'm_group' , $ levelClass , ) , ) ) . '>' ; } elseif ( $ method == 'groupEnd' ) { $ str = '</div>' ; } return $ str ; }
10796	public function classifiedAnswer ( array $ data ) { $ id = isset ( $ data [ 'id' ] ) ? $ data [ 'id' ] : null ; if ( empty ( $ id ) ) { throw new \ Exception ( "Errore si sistema." ) ; } $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ documentRepository = $ main -> getDocumentEntityRepository ( ) ; $ classified = $ documentRepository -> getEntity ( $ id ) ; $ classifiedModel = $ this -> getServiceLocator ( ) -> get ( 'document.model.classifiedAdminListing' ) ; $ classifiedModel -> init ( $ classified , $ this -> getServiceLocator ( ) ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.classifiedanswer' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ data = array_merge ( $ form -> getData ( ) , array ( 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) , 'to' => $ classifiedModel -> email , 'fullname' => $ classifiedModel -> fullname , 'title' => $ classifiedModel -> title , 'address' => $ classifiedModel -> address ) ) ; $ event = new ClassifiedAnswerEvent ( __FUNCTION__ , null , $ data ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; }
8121	public function ReviewContentForm ( HTTPRequest $ request ) { $ id = $ request -> param ( 'ID' ) ? : $ request -> postVar ( 'ID' ) ; return $ this -> getReviewContentForm ( $ id ) ; }
10477	protected function displayExceptions ( Exception $ e ) { $ this -> display [ ] = 'Cerbero\Auth\Exceptions\DisplayException' ; foreach ( $ this -> display as $ exception ) { if ( $ e instanceof $ exception ) { return back ( ) -> withInput ( ) -> withError ( $ e -> getMessage ( ) ) ; } } }
25	public function getContents ( $ originUrl , $ fileUrl , $ progress = true , $ options = array ( ) ) { return $ this -> get ( $ originUrl , $ fileUrl , $ options , null , $ progress ) ; }
5096	public function queryExists ( ) { foreach ( $ this -> selects as $ select ) { $ result = $ select -> queryExists ( ) ; if ( is_null ( $ result ) || $ result ) { return $ result ; } } return false ; }
11529	public function replaceVariables ( $ string , $ replaces = [ ] ) { $ callback = function ( $ match ) use ( $ replaces ) { $ variable = trim ( $ match [ 0 ] , '{}' ) ; if ( array_key_exists ( $ variable , $ replaces ) ) { return $ replaces [ $ variable ] ; } return $ variable ; } ; return preg_replace_callback ( '/{.*?}/' , $ callback , $ string ) ; }
5633	public function collect ( & $ test , $ path ) { $ path = $ this -> removeTrailingSlash ( $ path ) ; if ( $ handle = opendir ( $ path ) ) { while ( ( $ entry = readdir ( $ handle ) ) !== false ) { if ( $ this -> isHidden ( $ entry ) ) { continue ; } $ this -> handle ( $ test , $ path . DIRECTORY_SEPARATOR . $ entry ) ; } closedir ( $ handle ) ; } }
8146	public function parse ( Twig_TokenStream $ stream ) { if ( null === $ this -> parser ) { $ this -> parser = new Twig_Parser ( $ this ) ; } return $ this -> parser -> parse ( $ stream ) ; }
637	public function truncateTable ( $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> truncateTable ( $ table ) ; return $ this -> setSql ( $ sql ) ; }
2058	public function makeRedirectPageMandatory ( Contao \ DataContainer $ dc ) { $ objPage = $ this -> Database -> prepare ( "SELECT * FROM " . $ dc -> table . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objPage -> numRows && $ objPage -> type == 'logout' ) { $ GLOBALS [ 'TL_DCA' ] [ 'tl_page' ] [ 'fields' ] [ 'jumpTo' ] [ 'eval' ] [ 'mandatory' ] = true ; } }
7004	public function format ( $ format ) { $ this -> format = $ format ; $ format = preg_replace ( '/([a-zA-Z])/' , '%$1' , $ format ) ; $ format = preg_replace ( '/\\\\%(.)/' , '\\\\$1' , $ format ) ; $ this -> format_d ( $ format ) ; $ this -> formatD ( $ format ) ; $ this -> format_j ( $ format ) ; $ this -> format_l ( $ format ) ; $ this -> formatL ( $ format ) ; $ this -> formatN ( $ format ) ; $ this -> formatS ( $ format ) ; $ this -> format_w ( $ format ) ; $ this -> format_z ( $ format ) ; $ this -> formatW ( $ format ) ; $ this -> formatF ( $ format ) ; $ this -> format_m ( $ format ) ; $ this -> formatM ( $ format ) ; $ this -> format_n ( $ format ) ; $ this -> format_t ( $ format ) ; $ this -> formatY ( $ format ) ; $ this -> format_y ( $ format ) ; $ this -> format_a ( $ format ) ; $ this -> formatA ( $ format ) ; $ this -> format_g ( $ format ) ; $ this -> formatG ( $ format ) ; $ this -> format_h ( $ format ) ; $ this -> formatH ( $ format ) ; $ this -> format_i ( $ format ) ; $ this -> format_s ( $ format ) ; $ this -> format_u ( $ format ) ; $ this -> format_e ( $ format ) ; $ this -> formatO ( $ format ) ; $ this -> formatP ( $ format ) ; $ this -> formatZ ( $ format ) ; $ this -> format_r ( $ format ) ; $ this -> format_c ( $ format ) ; $ this -> formatC ( $ format ) ; return str_replace ( '\\' , '' , $ format ) ; }
2487	protected function search ( array $ parameters ) { $ queryString = $ this -> generateQueryString ( $ parameters ) ; $ response = $ this -> client -> request ( 'POST' , $ this -> endpointRegistry -> getEndpoint ( $ this -> endpointResolver -> getEntryEndpoint ( ) ) , '/select' , new Message ( [ 'Content-Type' => 'application/x-www-form-urlencoded' , ] , $ queryString ) ) ; $ result = json_decode ( $ response -> body ) ; if ( ! isset ( $ result -> response ) ) { throw new RuntimeException ( '->response not set: ' . var_export ( array ( $ result , $ parameters ) , true ) ) ; } return $ result ; }
3376	private function createInstance ( $ file , $ w = null , $ h = null ) { $ container = $ this -> container ; $ webDir = $ container -> getParameter ( 'gregwar_image.web_dir' ) ; $ handlerClass = $ this -> handlerClass ; $ image = new $ handlerClass ( $ file , $ w , $ h , $ this -> throwException , $ this -> fallbackImage ) ; $ image -> setCacheDir ( $ this -> cacheDirectory ) ; $ image -> setCacheDirMode ( $ this -> cacheDirMode ) ; $ image -> setActualCacheDir ( $ webDir . '/' . $ this -> cacheDirectory ) ; if ( $ container -> has ( 'templating.helper.assets' ) ) { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ container -> get ( 'templating.helper.assets' ) -> getUrl ( $ file ) ; } ) ; } else { $ image -> setFileCallback ( function ( $ file ) use ( $ container ) { return $ this -> assetsPackages -> getUrl ( $ file ) ; } ) ; } return $ image ; }
10358	public static function error ( int $ code , string $ message , string $ file , int $ line ) : bool { if ( ( error_reporting ( ) & $ code ) !== 0 ) { if ( DEVELOPMENT == false && $ code == 8 ) { $ error [ 'code' ] = $ code ; $ error [ 'message' ] = $ message ; $ error [ 'file' ] = $ file ; $ error [ 'line' ] = $ line ; $ error [ 'type' ] = 'ErrorException: ' ; $ codes = array ( E_USER_NOTICE => 'Notice' , ) ; $ error [ 'type' ] .= in_array ( $ error [ 'code' ] , array_keys ( $ codes ) ) ? $ codes [ $ error [ 'code' ] ] : 'Unknown Error' ; ErrorHandler :: writeLogs ( "{$error['type']}: {$error['message']} in {$error['file']} at line {$error['line']}" ) ; } else { throw new \ ErrorException ( $ message , $ code , 0 , $ file , $ line ) ; } } return true ; }
12844	protected function loadAnswerMatching ( ) { if ( $ this -> input -> hasOption ( 'load-choice-matching' ) ) { $ fs = new Filesystem ( ) ; $ filename = $ this -> input -> getOption ( 'load-choice-matching' ) ; if ( ! $ fs -> exists ( $ filename ) ) { $ this -> logger -> warning ( "The file $filename is not found. Choice matching not loaded" ) ; } else { $ this -> logger -> debug ( "Loading $filename as choice matching" ) ; $ this -> cacheAnswersMapping = \ json_decode ( \ file_get_contents ( $ filename ) , true ) ; } } }
980	public function api ( ) { if ( ! $ this -> api ) { $ shopDomain = $ this -> shopify_domain ; $ token = $ this -> session ( ) -> getToken ( ) ; $ this -> api = ShopifyApp :: api ( ) ; $ this -> api -> setSession ( $ shopDomain , $ token ) ; } return $ this -> api ; }
2359	public function isPreviewMode ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return $ token instanceof FrontendPreviewToken && $ token -> showUnpublished ( ) ; }
10785	public function runQuery ( \ Peyote \ Query $ query ) { return $ this -> run ( $ query -> compile ( ) , $ query -> getParams ( ) ) ; }
11723	public function collectActivity ( PostActionEvent $ event ) { $ this -> activity [ ] = array ( 'action_name' => $ event -> getAction ( ) -> getName ( ) , 'group_name' => $ event -> getAction ( ) -> getGroup ( ) -> getName ( ) , 'service_name' => $ event -> getAction ( ) -> getGroup ( ) -> getService ( ) -> getName ( ) , 'execution_time' => round ( $ event -> getExecutionTime ( ) * 1000 , 2 ) , 'arguments' => $ event -> getArguments ( ) , 'extra_data' => $ event -> getExtraData ( ) , ) ; $ this -> totalExecutionTime += $ event -> getExecutionTime ( ) ; $ this -> totalCallCount += 1 ; }
6208	public function load ( $ data ) { if ( ! is_array ( $ data ) && ! $ data instanceof \ stdClass ) { return ; } foreach ( $ data as $ key => $ value ) { $ this -> set ( $ key , $ value ) ; } }
1657	public function get ( $ name ) { foreach ( $ this -> arguments as $ argument ) { if ( $ argument [ 'name' ] == $ name ) { if ( isset ( $ this -> mapArgumentName [ $ name ] ) ) { return $ this -> { $ this -> mapArgumentName [ $ name ] } ( $ argument ) ; } else { return $ argument ; } } } }
8387	public function distinct ( $ distinct ) { if ( is_array ( $ distinct ) === true ) { $ this -> distinct = implode ( ', ' , $ distinct ) ; } else { $ this -> distinct = $ distinct ; } return $ this ; }
7420	protected function getNumList ( ) : array { preg_match_all ( '/\/\d+/u' , $ this -> request -> route ( ) , $ numList ) ; $ numList = $ numList [ 0 ] ; $ numList = array_map ( function ( $ val ) { return intval ( ltrim ( $ val , '/' ) ) ; } , $ numList ) ; return $ numList ; }
5708	public function transformToButton ( ) { parent :: transformToButton ( ) ; if ( $ this -> gridFieldRequest -> recordIsPublished ( ) ) { $ this -> setTitle ( _t ( 'SiteTree.BUTTONPUBLISHED' , 'Published' ) ) ; } if ( $ this -> gridFieldRequest -> record -> stagesDiffer ( 'Stage' , 'Live' ) && $ this -> gridFieldRequest -> recordIsDeletedFromStage ( ) ) { $ this -> addExtraClass ( 'ss-ui-alternate' ) ; } return $ this ; }
8069	public function bind ( $ username , $ password ) { if ( $ this -> tls ) { if ( ! ldap_start_tls ( $ this -> connection ) ) { throw new ConnectionException ( 'Unable to Connect to LDAP using TLS.' ) ; } } try { $ this -> bound = ldap_bind ( $ this -> connection , $ username , $ password ) ; } catch ( ErrorException $ e ) { $ this -> bound = false ; } return $ this -> bound ; }
1257	public static function createRuntime ( ) { switch ( $ compileDir = getenv ( self :: COMPILE_DIR ) ) { case false : return new AstRuntime ( ) ; case 'on' : return new CompilerRuntime ( ) ; default : return new CompilerRuntime ( $ compileDir ) ; } }
1199	public function addVoter ( VoterInterface $ voter ) { @ trigger_error ( sprintf ( 'The %s() method is deprecated since version 2.3 and will be removed in 3.0. Pass voters in the constructor instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; if ( $ this -> voters instanceof \ Traversable ) { $ this -> voters = iterator_to_array ( $ this -> voters ) ; } $ this -> voters [ ] = $ voter ; }
3943	public static function prepareLanguageAwareWidget ( EnvironmentInterface $ environment , PropertyInterface $ property , IMetaModel $ metaModel , $ languageLabel , $ valueLabel , $ isTextArea , $ arrValues ) { if ( ! $ metaModel -> isTranslated ( ) ) { $ extra = $ property -> getExtra ( ) ; $ extra [ 'tl_class' ] .= empty ( $ extra [ 'tl_class' ] ) ? 'w50' : ' w50' ; $ property -> setWidgetType ( 'text' ) -> setExtra ( $ extra ) ; return ; } $ fallback = $ metaModel -> getFallbackLanguage ( ) ; $ languages = self :: buildLanguageArray ( $ metaModel , $ environment -> getTranslator ( ) ) ; $ neededKeys = array_keys ( $ languages ) ; if ( array_diff_key ( array_keys ( $ arrValues ) , $ neededKeys ) ) { foreach ( $ neededKeys as $ langCode ) { $ arrValues [ $ langCode ] = '' ; } } $ rowClasses = array ( ) ; foreach ( array_keys ( $ arrValues ) as $ langCode ) { $ rowClasses [ ] = ( $ langCode == $ fallback ) ? 'fallback_language' : 'normal_language' ; } $ extra = $ property -> getExtra ( ) ; $ extra [ 'minCount' ] = $ extra [ 'maxCount' ] = count ( $ languages ) ; $ extra [ 'disableSorting' ] = true ; $ extra [ 'tl_class' ] = 'clr' ; $ extra [ 'columnFields' ] = array ( 'langcode' => array ( 'label' => $ languageLabel , 'exclude' => true , 'inputType' => 'justtextoption' , 'options' => $ languages , 'eval' => array ( 'rowClasses' => $ rowClasses , 'valign' => 'center' , 'style' => 'min-width:75px;display:block;' ) ) , 'value' => array ( 'label' => $ valueLabel , 'exclude' => true , 'inputType' => $ isTextArea ? 'textarea' : 'text' , 'eval' => array ( 'rowClasses' => $ rowClasses , 'style' => 'width:400px;' , 'rows' => 3 ) ) , ) ; $ property -> setWidgetType ( 'multiColumnWizard' ) -> setExtra ( $ extra ) ; }
11876	public static function getDump ( $ var , $ maxSize = null ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Dump de variable' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; if ( count ( $ trace ) > 2 ) { $ dump .= static :: getContext ( $ trace [ 1 ] , $ trace [ 2 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ 1 ] ) ; } if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\common\sgbd\Query' ) { $ dump .= '<div class="dump_segment">Requête SQL</div>'; $ dump .= '<div class="dump_segment_content"><pre>' . $ var -> getSql ( ) . '</pre></div>' ; } $ dump .= '<div class="dump_segment">Exploration de la variable</div>' ; $ dump .= '<div class="dump_segment_content"><pre>' ; if ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\Query' ) { $ dump .= static :: getDumpQueryResult ( $ var -> getQueryResults ( ) ) ; } elseif ( is_object ( $ var ) && get_class ( $ var ) == 'sylab\framework\query\QueryResult' ) { $ dump .= static :: getDumpQueryResult ( $ var ) ; } else { $ dump .= static :: getDumpContent ( $ var , $ maxSize ) ; } $ dump .= '</pre></div>' ; $ dump .= static :: getFooter ( ) ; return $ dump ; }
12702	public function get ( $ id ) { if ( isset ( $ this -> singletons [ $ id ] ) ) { return $ this -> singletons [ $ id ] ; } $ methodName = 'get' . Util :: mapIdToCamelCase ( $ id ) ; if ( method_exists ( $ this , $ methodName ) ) { return $ this -> $ methodName ( ) ; } throw new \ InvalidArgumentException ( "Unknown service '$id' in container '" . get_called_class ( ) . "'" ) ; }
329	public function buildKey ( $ key ) { if ( is_string ( $ key ) ) { $ key = ctype_alnum ( $ key ) && StringHelper :: byteLength ( $ key ) <= 32 ? $ key : md5 ( $ key ) ; } else { if ( $ this -> _igbinaryAvailable ) { $ serializedKey = igbinary_serialize ( $ key ) ; } else { $ serializedKey = serialize ( $ key ) ; } $ key = md5 ( $ serializedKey ) ; } return $ this -> keyPrefix . $ key ; }
2267	public function getFieldNames ( $ strTable , $ blnNoCache = false ) { $ arrNames = array ( ) ; $ arrFields = $ this -> listFields ( $ strTable , $ blnNoCache ) ; foreach ( $ arrFields as $ arrField ) { if ( $ arrField [ 'type' ] != 'index' ) { $ arrNames [ ] = $ arrField [ 'name' ] ; } } return $ arrNames ; }
4458	public function fire ( AbstractUserEvent $ event ) { $ status = null ; $ type = $ event :: getEntityName ( ) ; if ( isset ( $ this -> events [ $ type ] ) ) { $ queue = $ this -> events [ $ type ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } $ eventName = $ event -> getName ( ) ; if ( isset ( $ this -> events [ $ eventName ] ) ) { $ queue = $ this -> events [ $ eventName ] ; $ status = $ this -> fireQueue ( $ queue , $ event ) ; } return $ status ; }
8792	public function tag ( $ tag , $ content , array $ attributes = [ ] ) { $ content = is_array ( $ content ) ? implode ( PHP_EOL , $ content ) : $ content ; return $ this -> toHtmlString ( '<' . $ tag . $ this -> attributes ( $ attributes ) . '>' . PHP_EOL . $ this -> toHtmlString ( $ content ) . PHP_EOL . '</' . $ tag . '>' . PHP_EOL ) ; }
3240	public function setCallbacks ( $ order ) { $ this -> callbackSuccess = route ( config ( 'shop.callback_route' ) , [ 'status' => 'success' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; $ this -> callbackFail = route ( config ( 'shop.callback_route' ) , [ 'status' => 'fail' , 'id' => $ order -> id , 'token' => $ this -> token , ] ) ; }
10921	public function setHeaders ( array $ headers ) { $ columnNumber = 0 ; foreach ( $ headers as $ header ) { $ this -> updateWidth ( $ columnNumber , $ this -> length ( $ header ) ) ; if ( ! in_array ( $ header , $ this -> headers ) ) { $ this -> headers [ ] = $ header ; } $ columnNumber ++ ; } }
4547	public function check ( $ alias = null ) { if ( null === $ alias ) { $ statuses = new Statuses ; $ statuses -> setHealthy ( true ) ; foreach ( $ this -> checkCollection as $ check ) { $ status = $ check -> execute ( ) ; $ statuses -> getCollection ( ) -> add ( $ status ) ; if ( ! $ status -> getHealthy ( ) ) { $ statuses -> setHealthy ( false ) ; } } return $ statuses ; } else { $ check = $ this -> checkCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ check ) { throw new InvalidAliasException ( 'Check alias does not exist.' ) ; } $ status = $ check -> execute ( ) ; return $ status ; } }
12391	public function setHydrator ( $ hydrator ) { if ( ! is_string ( $ hydrator ) && ! $ hydrator instanceof HydratorInterface ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object of instance Zend\Stdlib\Hydrator\HydratorInterface or string, %s provided instead' , __METHOD__ , is_object ( $ hydrator ) ? get_class ( $ hydrator ) : gettype ( $ hydrator ) ) ) ; } $ this -> hydrator = $ hydrator ; return $ this ; }
2953	protected function extractData ( $ text , $ template ) { preg_match ( '/' . $ template . '/s' , $ text , $ matches ) ; $ keys = array_filter ( array_keys ( $ matches ) , 'is_string' ) ; $ matches = array_intersect_key ( $ matches , array_flip ( $ keys ) ) ; if ( ! empty ( $ matches ) ) { return $ this -> cleanExtractedData ( $ matches ) ; } return false ; }
7221	protected function createLabel ( $ content , $ type , $ format , $ size ) { $ label = new OrderShipmentLabel ( ) ; $ label -> setContent ( $ content ) -> setType ( $ type ) -> setFormat ( $ format ) -> setSize ( $ size ) ; return $ label ; }
1263	private function createAcceptRequest ( $ shipmentDigest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'ShipmentAcceptRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'ShipAccept' ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipmentDigest' , $ shipmentDigest ) ) ; return $ xml -> saveXML ( ) ; }
3000	public function reset ( $ key = null ) { if ( $ key ) { $ key = ucfirst ( $ key ) ; $ this -> smtp -> clear ( $ key ) ; if ( isset ( $ this -> recipients [ $ key ] ) ) unset ( $ this -> recipients [ $ key ] ) ; } else { $ this -> recipients = array ( ) ; $ this -> initSMTP ( ) ; } }
8599	private function _convertCreateSubscription ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateSubscription' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetSubscription ( ) ) { $ SubscriptionCreateSubscriptionInput = $ request -> getSubscription ( ) ; foreach ( $ SubscriptionCreateSubscriptionInput -> getNotificationType ( ) as $ NotificationTypeSubscriptionIndex => $ NotificationTypeSubscription ) { $ parameters [ 'Subscription' . '.' . 'NotificationType' . '.' . ( $ NotificationTypeSubscriptionIndex + 1 ) ] = $ NotificationTypeSubscription ; } } return $ parameters ; }
978	protected function validateShop ( Request $ request ) { $ shopParam = ShopifyApp :: sanitizeShopDomain ( $ request -> get ( 'shop' ) ) ; $ shop = ShopifyApp :: shop ( $ shopParam ) ; $ session = new ShopSession ( $ shop ) ; if ( $ shop === null || $ shop -> trashed ( ) || empty ( $ session -> getToken ( true ) ) || ( $ shopParam && $ shopParam !== $ shop -> shopify_domain ) === true ) { $ session -> forget ( ) ; Session :: put ( 'return_to' , $ request -> fullUrl ( ) ) ; return Redirect :: route ( 'authenticate' , [ 'shop' => $ shopParam ] ) ; } return true ; }
493	private function indexBuckets ( $ buckets , $ indexBy ) { $ result = [ ] ; foreach ( $ buckets as $ key => $ models ) { $ result [ $ key ] = [ ] ; foreach ( $ models as $ model ) { $ index = is_string ( $ indexBy ) ? $ model [ $ indexBy ] : call_user_func ( $ indexBy , $ model ) ; $ result [ $ key ] [ $ index ] = $ model ; } } return $ result ; }
11108	public function logRequest ( APIRequest $ request ) : void { $ item = $ this -> cacheItemPool -> getItem ( $ this -> deriveCacheKey ( $ request ) ) ; if ( $ requestCount = $ item -> get ( ) ) { $ item -> set ( $ requestCount + 1 ) ; } else { $ item -> set ( 1 ) -> expiresAfter ( $ this -> perXSeconds ) ; } $ this -> cacheItemPool -> save ( $ item ) ; }
10257	public function getAddress ( $ state_code = null , $ zip = null ) { $ address = new Entities \ Address ; if ( ! empty ( $ zip ) && ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ zip ) ) { $ result = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } elseif ( ! empty ( $ state_code ) ) { $ result = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) ; } else { $ result = Zipcode :: orderByRaw ( Database :: random ( ) ) -> first ( ) ; } $ address -> line_1 = $ this -> getStreet ( ) ; if ( $ this -> getBool ( true , false ) ) { $ address -> line_2 = $ this -> getApartment ( ) ; } else { $ address -> line_2 = null ; } $ address -> city = $ result -> city ; $ address -> zip = $ result -> zip ; $ address -> county = $ result -> county ; $ address -> state = new Entities \ State ; $ address -> state -> code = $ result -> state_code ; $ address -> state -> name = $ result -> state ; return $ address ; }
5812	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = array ( ) ; foreach ( singleton ( 'FusionService' ) -> getFusionTagTypes ( ) as $ type => $ field ) { $ types [ $ type ] = $ type ; } $ types = array_intersect ( $ this -> owner -> many_many ( ) , $ types ) ; if ( empty ( $ types ) ) { $ tagging = array ( ) ; foreach ( $ this -> owner -> FusionTags ( ) as $ tag ) { $ tagging [ ] = $ tag -> Title ; } } else { $ this -> owner -> FusionTags ( ) -> removeAll ( ) ; $ tagging = array ( ) ; foreach ( $ types as $ relationship => $ type ) { foreach ( $ this -> owner -> $ relationship ( ) as $ tag ) { $ fusion = FusionTag :: get ( ) -> byID ( $ tag -> FusionTagID ) ; $ this -> owner -> FusionTags ( ) -> add ( $ fusion ) ; $ tagging [ ] = $ fusion -> Title ; } } } $ this -> owner -> Tagging = implode ( ' ' , $ tagging ) ; }
2698	public function upgrade ( ModuleDataSetupInterface $ setup , ModuleContextInterface $ context ) { $ version = $ context -> getVersion ( ) ; if ( ! $ version ) { return ; } $ oldConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/geoip_country_mapping' , ] ; $ newConfigPaths = [ 'stale_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_ttl' , 'stale_error_ttl' => 'system/full_page_cache/fastly/fastly_advanced_configuration/stale_error_ttl' , 'purge_catalog_category' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_category' , 'purge_catalog_product' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_catalog_product' , 'purge_cms_page' => 'system/full_page_cache/fastly/fastly_advanced_configuration/purge_cms_page' , 'soft_purge' => 'system/full_page_cache/fastly/fastly_advanced_configuration/soft_purge' , 'enable_geoip' => 'system/full_page_cache/fastly/fastly_advanced_configuration/enable_geoip' , 'geoip_action' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_action' , 'geoip_country_mapping' => 'system/full_page_cache/fastly/fastly_advanced_configuration/geoip_country_mapping' ] ; $ setup -> startSetup ( ) ; if ( version_compare ( $ version , '1.0.8' , '<=' ) ) { $ this -> upgrade108 ( $ oldConfigPaths , $ newConfigPaths ) ; } if ( version_compare ( $ version , '1.0.9' , '<=' ) ) { $ this -> upgrade109 ( $ setup ) ; } $ magVer = $ this -> productMetadata -> getVersion ( ) ; if ( version_compare ( $ version , '1.0.10' , '<=' ) && version_compare ( $ magVer , '2.2' , '>=' ) ) { $ this -> upgrade1010 ( $ newConfigPaths ) ; $ setup -> endSetup ( ) ; } elseif ( version_compare ( $ magVer , '2.2' , '<' ) ) { $ setup -> endSetup ( ) ; } }
11811	protected function loadLocalObject ( ) { if ( $ this -> _isLoadingLocalObject ) { throw new RecursionException ( 'Ran into recursion while loading local object' ) ; } $ this -> _isLoadingLocalObject = true ; if ( isset ( $ this -> foreignObject ) && ! isset ( $ this -> _localObject ) ) { $ keyTranslation = $ this -> dataSource -> getKeyTranslation ( $ this -> foreignObject ) ; if ( ! empty ( $ keyTranslation ) && ( $ localObject = $ keyTranslation -> object ) ) { $ this -> localObject = $ localObject ; } } $ this -> _isLoadingLocalObject = false ; }
525	protected function migrateToVersion ( $ version ) { $ originalVersion = $ version ; $ migrations = $ this -> getNewMigrations ( ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { $ this -> actionUp ( $ i + 1 ) ; return ExitCode :: OK ; } } $ migrations = array_keys ( $ this -> getMigrationHistory ( null ) ) ; foreach ( $ migrations as $ i => $ migration ) { if ( strpos ( $ migration , $ version ) === 0 ) { if ( $ i === 0 ) { $ this -> stdout ( "Already at '$originalVersion'. Nothing needs to be done.\n" , Console :: FG_YELLOW ) ; } else { $ this -> actionDown ( $ i ) ; } return ExitCode :: OK ; } } throw new Exception ( "Unable to find the version '$originalVersion'." ) ; }
1707	private function hasCookie ( Response $ response ) : bool { $ cookies = $ response -> headers -> getCookies ( ) ; foreach ( $ cookies as $ cookie ) { if ( self :: COOKIE_NAME === $ cookie -> getName ( ) ) { return true ; } } return false ; }
9438	public function reset ( ) { $ this -> rho = null ; $ this -> theta = null ; $ this -> r = null ; $ this -> i = null ; return $ this ; }
4133	public function initializeObject ( $ obj ) { if ( $ obj instanceof PersistentCollection ) { $ obj -> initialize ( ) ; } else if ( $ obj instanceof Proxy \ Proxy ) { $ obj -> __doctrineLoad__ ( ) ; } }
12155	public function getInitialRole ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = $ roleItem -> level < 400 ; if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
7413	public function getResponse ( string & $ packageRoot , Request & $ request ) : Response { $ packageRoot = rtrim ( $ packageRoot , '/' ) ; $ route = preg_replace ( '/\/\d+/u' , '/D' , $ request -> route ( ) ) ; $ path = $ packageRoot . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ; if ( file_exists ( $ path ) ) { require $ path ; $ controllerClass = $ request -> package ( ) . '\\Route_' . str_replace ( '/' , '_' , $ route ) . '\\' . $ request -> method ( ) ; if ( class_exists ( $ controllerClass ) ) { $ controller = new $ controllerClass ( $ packageRoot , $ request ) ; } else { throw new RouteException ( sprintf ( 'Route: the class "%s" does not exist' , $ controllerClass ) ) ; } $ handler = filter_input_array ( INPUT_POST ) [ 'handler' ] ?? filter_input_array ( INPUT_GET ) [ 'handler' ] ?? 'index' ; if ( method_exists ( $ controllerClass , $ handler ) ) { $ controller -> invoke ( $ handler ) ; return $ controller -> getResponse ( ) ; } else { throw new RouteException ( sprintf ( 'Route: the method "%s" does not exist' , $ handler ) ) ; } } else { throw new RouteException ( sprintf ( 'Route: path "%s" does not exist' , $ request -> package ( ) . '/Route/' . $ route . '/' . $ request -> method ( ) . '.php' ) ) ; } }
602	public function tokenize ( ) { $ this -> length = mb_strlen ( $ this -> sql , 'UTF-8' ) ; $ this -> offset = 0 ; $ this -> _substrings = [ ] ; $ this -> _buffer = '' ; $ this -> _token = new SqlToken ( [ 'type' => SqlToken :: TYPE_CODE , 'content' => $ this -> sql , ] ) ; $ this -> _tokenStack = new \ SplStack ( ) ; $ this -> _tokenStack -> push ( $ this -> _token ) ; $ this -> _token [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _token [ 0 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; while ( ! $ this -> isEof ( ) ) { if ( $ this -> isWhitespace ( $ length ) || $ this -> isComment ( $ length ) ) { $ this -> addTokenFromBuffer ( ) ; $ this -> advance ( $ length ) ; continue ; } if ( $ this -> tokenizeOperator ( $ length ) || $ this -> tokenizeDelimitedString ( $ length ) ) { $ this -> advance ( $ length ) ; continue ; } $ this -> _buffer .= $ this -> substring ( 1 ) ; $ this -> advance ( 1 ) ; } $ this -> addTokenFromBuffer ( ) ; if ( $ this -> _token -> getHasChildren ( ) && ! $ this -> _token [ - 1 ] -> getHasChildren ( ) ) { unset ( $ this -> _token [ - 1 ] ) ; } return $ this -> _token ; }
4639	private function attachFiles ( Message $ message , Email $ email ) { if ( ! $ email -> hasAttachments ( ) ) { return ; } $ attachments = $ email -> getComputedAttachments ( ) ; $ mimeMessage = $ message -> getBody ( ) ; $ oldParts = $ mimeMessage -> getParts ( ) ; $ attachmentParts = [ ] ; $ info = null ; foreach ( $ attachments as $ key => $ attachment ) { if ( is_array ( $ attachment ) && isset ( $ attachment [ 'parser_name' ] , $ attachment [ 'value' ] ) ) { $ attachment = Attachment :: fromArray ( $ attachment ) ; } $ parserName = $ this -> resolveParserNameFromAttachment ( $ attachment ) ; if ( ! $ this -> attachmentParserManager -> has ( $ parserName ) ) { throw new Exception \ ServiceNotCreatedException ( sprintf ( 'The attachment parser "%s" could not be found' , $ parserName ) ) ; } $ parser = $ this -> attachmentParserManager -> get ( $ parserName ) ; $ attachmentValue = $ attachment instanceof Attachment ? $ attachment -> getValue ( ) : $ attachment ; $ part = $ parser -> parse ( $ attachmentValue , is_string ( $ key ) ? $ key : null ) ; $ part -> charset = $ email -> getCharset ( ) ; $ attachmentParts [ ] = $ part ; } $ body = new Mime \ Message ( ) ; $ body -> setParts ( array_merge ( $ oldParts , $ attachmentParts ) ) ; $ message -> setBody ( $ body ) ; }
9225	private function preprocessData ( $ data ) { if ( is_array ( $ data ) && ! array_key_exists ( self :: PARAM_PER_PAGE , $ data ) ) { $ data [ self :: PARAM_PER_PAGE ] = CanvasArray :: MAXIMUM_PER_PAGE ; } return $ data ; }
8116	public function canBeReviewedBy ( Member $ member = null ) { if ( ! $ this -> owner -> obj ( "NextReviewDate" ) -> exists ( ) ) { return false ; } if ( $ this -> owner -> obj ( "NextReviewDate" ) -> InFuture ( ) ) { return false ; } $ options = $ this -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options || ( ! $ options -> hasExtension ( __CLASS__ ) && ! $ options -> hasExtension ( ContentReviewDefaultSettings :: class ) ) ) { return false ; } if ( $ options -> OwnerGroups ( ) -> count ( ) == 0 && $ options -> OwnerUsers ( ) -> count ( ) == 0 ) { return false ; } if ( ! $ member ) { return true ; } if ( $ member -> inGroups ( $ options -> OwnerGroups ( ) ) ) { return true ; } if ( $ options -> OwnerUsers ( ) -> find ( "ID" , $ member -> ID ) ) { return true ; } return false ; }
12082	public function getMedia ( $ objectType = 'media' , $ objectURI = NULL , $ objectId = NULL ) { return $ this -> getAllMedia ( $ objectType , $ objectURI , $ objectId ) ; }
5566	public function get ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } return $ this -> load ( $ url , new SimpleGetEncoding ( $ parameters ) ) ; }
6516	public function register ( Container $ container ) { $ container [ 'doctrine.orm.em' ] = $ this -> getOrmEmDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.config' ] = $ this -> getOrmEmConfigDefinition ( $ container ) ; $ container [ 'doctrine.orm.em.default_options' ] = $ this -> getOrmEmDefaultOptions ( ) ; $ container [ 'doctrine.orm.ems' ] = $ this -> getOrmEmsDefinition ( $ container ) ; $ container [ 'doctrine.orm.ems.config' ] = $ this -> getOrmEmsConfigServiceProvider ( $ container ) ; $ container [ 'doctrine.orm.ems.options.initializer' ] = $ this -> getOrmEmsOptionsInitializerDefinition ( $ container ) ; $ container [ 'doctrine.orm.entity.listener_resolver.default' ] = $ this -> getOrmEntityListenerResolverDefinition ( $ container ) ; $ container [ 'doctrine.orm.manager_registry' ] = $ this -> getOrmManagerRegistryDefintion ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.annotation' ] = $ this -> getOrmMappingDriverFactoryAnnotation ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.class_map' ] = $ this -> getOrmMappingDriverFactoryClassMap ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.php' ] = $ this -> getOrmMappingDriverFactoryPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_xml' ] = $ this -> getOrmMappingDriverFactorySimpleXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.simple_yaml' ] = $ this -> getOrmMappingDriverFactorySimpleYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.static_php' ] = $ this -> getOrmMappingDriverFactoryStaticPhp ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.xml' ] = $ this -> getOrmMappingDriverFactoryXml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver.factory.yaml' ] = $ this -> getOrmMappingDriverFactoryYaml ( $ container ) ; $ container [ 'doctrine.orm.mapping_driver_chain' ] = $ this -> getOrmMappingDriverChainDefinition ( $ container ) ; $ container [ 'doctrine.orm.repository.factory.default' ] = $ this -> getOrmRepositoryFactoryDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.naming.default' ] = $ this -> getOrmNamingStrategyDefinition ( $ container ) ; $ container [ 'doctrine.orm.strategy.quote.default' ] = $ this -> getOrmQuoteStrategyDefinition ( $ container ) ; }
178	public static function filter ( $ array , $ filters ) { $ result = [ ] ; $ forbiddenVars = [ ] ; foreach ( $ filters as $ var ) { $ keys = explode ( '.' , $ var ) ; $ globalKey = $ keys [ 0 ] ; $ localKey = isset ( $ keys [ 1 ] ) ? $ keys [ 1 ] : null ; if ( $ globalKey [ 0 ] === '!' ) { $ forbiddenVars [ ] = [ substr ( $ globalKey , 1 ) , $ localKey , ] ; continue ; } if ( ! array_key_exists ( $ globalKey , $ array ) ) { continue ; } if ( $ localKey === null ) { $ result [ $ globalKey ] = $ array [ $ globalKey ] ; continue ; } if ( ! isset ( $ array [ $ globalKey ] [ $ localKey ] ) ) { continue ; } if ( ! array_key_exists ( $ globalKey , $ result ) ) { $ result [ $ globalKey ] = [ ] ; } $ result [ $ globalKey ] [ $ localKey ] = $ array [ $ globalKey ] [ $ localKey ] ; } foreach ( $ forbiddenVars as $ var ) { list ( $ globalKey , $ localKey ) = $ var ; if ( array_key_exists ( $ globalKey , $ result ) ) { unset ( $ result [ $ globalKey ] [ $ localKey ] ) ; } } return $ result ; }
6401	public function getResource ( $ resource ) : ? string { Preconditions :: checkState ( $ this -> isPsr0Compatible ( ) , "Class '%s' must be PSR-0 compatible!" , $ this -> getName ( ) ) ; $ slashedFileName = $ this -> getSlashedFileName ( ) ; $ filePath = $ resource [ 0 ] == '/' ? str_replace ( "/{$this->getSlashedName()}.php" , '' , $ slashedFileName ) . $ resource : dirname ( $ slashedFileName ) . '/' . $ resource ; return is_file ( $ filePath ) ? $ filePath : null ; }
4508	public function decoded ( JWTDecodedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ request -> getClientIp ( ) ) { $ event -> markAsInvalid ( ) ; } }
1946	public function getCustomSections ( $ strKey = null ) { @ trigger_error ( 'Using FrontendTemplate::getCustomSections() has been deprecated and will no longer work in Contao 5.0. Use FrontendTemplate::sections() instead.' , E_USER_DEPRECATED ) ; if ( $ strKey != '' && ! isset ( $ this -> positions [ $ strKey ] ) ) { return '' ; } $ tag = 'div' ; if ( $ strKey == 'main' ) { $ tag = 'section' ; } $ sections = '' ; foreach ( $ this -> positions [ $ strKey ] as $ sect ) { if ( isset ( $ this -> sections [ $ sect [ 'id' ] ] ) ) { $ sections .= "\n" . '<' . $ tag . ' id="' . StringUtil :: standardize ( $ sect [ 'id' ] , true ) . '">' . "\n" . '<div class="inside">' . "\n" . $ this -> sections [ $ sect [ 'id' ] ] . "\n" . '</div>' . "\n" . '</' . $ tag . '>' . "\n" ; } } if ( $ sections == '' ) { return '' ; } return '<div class="custom">' . "\n" . $ sections . "\n" . '</div>' . "\n" ; }
10744	public function getArray ( $ keys , array $ default = [ ] ) : array { $ result = $ this -> get ( $ keys , $ default ) ; if ( ! is_array ( $ result ) ) { $ result = $ default ; } return $ result ; }
6223	public function getMenuPresence ( ) { return [ 'id' => 'simple-acl' , 'type' => MenuPresenceType :: GROUP , 'label' => 'Access Control' , 'children' => [ [ 'id' => 'simple-acl-users' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Users' , 'permissions' => 'acl.users.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.index' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-create-user' , 'type' => MenuPresenceType :: ACTION , 'label' => 'New User' , 'permissions' => 'acl.users.create' , 'action' => $ this -> core -> prefixRoute ( 'acl.users.create' ) , 'parameters' => [ ] , ] , [ 'id' => 'simple-acl-roles' , 'type' => MenuPresenceType :: ACTION , 'label' => 'Roles' , 'permissions' => 'acl.roles.show' , 'action' => $ this -> core -> prefixRoute ( 'acl.roles.index' ) , 'parameters' => [ ] , ] , ] ] ; }
1593	protected function validateTypeAndId ( ) : bool { if ( ! ( $ this -> validateType ( ) && $ this -> validateId ( ) ) ) { return false ; } $ type = $ this -> dataGet ( 'type' ) ; $ id = $ this -> dataGet ( 'id' ) ; if ( $ id && ! $ this -> isNotFound ( $ type , $ id ) ) { $ this -> resourceExists ( $ type , $ id ) ; return false ; } return true ; }
2946	public function setRolesById ( $ roles ) { $ roles = is_array ( $ roles ) ? $ roles : [ $ roles ] ; return $ this -> roles ( ) -> sync ( $ roles ) ; }
2018	private function setImagineService ( array $ config , ContainerBuilder $ container ) : void { $ imagineServiceId = $ config [ 'image' ] [ 'imagine_service' ] ; if ( null === $ imagineServiceId ) { $ class = $ this -> getImagineImplementation ( ) ; $ imagineServiceId = 'contao.image.imagine.' . ContainerBuilder :: hash ( $ class ) ; $ container -> setDefinition ( $ imagineServiceId , new Definition ( $ class ) ) ; } $ container -> setAlias ( 'contao.image.imagine' , $ imagineServiceId ) -> setPublic ( true ) ; }
12160	public function getDetailsWidget ( $ objectModel = null ) { if ( is_null ( $ objectModel ) && isset ( Yii :: $ app -> request -> object ) ) { $ objectModel = Yii :: $ app -> request -> object ; } elseif ( is_null ( $ objectModel ) ) { $ objectModel = $ this -> dummyModel ; } $ detailsSection = $ this -> getDetailsSection ( ) ; if ( $ detailsSection === false ) { return false ; } if ( $ detailsSection === true ) { $ detailsSection = '_self' ; } $ detailsWidgetClass = self :: classNamespace ( ) . '\widgets\\' . 'Details' ; $ widgetClass = $ this -> fallbackDetailsWidgetClass ; @ class_exists ( $ detailsWidgetClass ) ; if ( class_exists ( $ detailsWidgetClass , false ) ) { $ widgetClass = $ detailsWidgetClass ; } $ widget = [ 'class' => $ widgetClass ] ; $ widget [ 'owner' ] = $ this ; $ widgetItem = [ 'widget' => $ widget , 'locations' => [ 'self' ] , 'priority' => 1 ] ; $ widgetItem [ 'section' ] = Yii :: $ app -> collectors [ 'sections' ] -> getOne ( $ detailsSection ) ; return $ widgetItem ; }
2380	public static function trimsplit ( $ strPattern , $ strString ) { if ( \ strlen ( $ strPattern ) == 1 ) { $ arrFragments = array_map ( 'trim' , explode ( $ strPattern , $ strString ) ) ; } else { $ arrFragments = array_map ( 'trim' , preg_split ( '/' . $ strPattern . '/ui' , $ strString ) ) ; } if ( \ count ( $ arrFragments ) < 2 && ! \ strlen ( $ arrFragments [ 0 ] ) ) { $ arrFragments = array ( ) ; } return $ arrFragments ; }
3051	protected function retrieveItemIndex ( ) { $ this -> itemIndex = new QtiTestCompilerIndex ( ) ; try { $ directories = $ this -> getCompilationDirectory ( ) ; $ data = $ directories [ 'private' ] -> read ( taoQtiTest_models_classes_QtiTestService :: TEST_COMPILED_INDEX ) ; if ( $ data ) { $ this -> itemIndex -> unserialize ( $ data ) ; } } catch ( \ Exception $ e ) { \ common_Logger :: d ( 'Ignoring file not found exception for Items Index' ) ; } }
8019	public function getClient ( ) { if ( $ this -> _client === null ) { $ settings = [ 'key' => $ this -> key , 'secret' => $ this -> secret ] ; if ( $ this -> enableV4 ) $ settings [ 'signature' ] = 'v4' ; $ this -> _client = S3Client :: factory ( $ settings ) ; } return $ this -> _client ; }
9684	public function getStorage ( ) { if ( null === $ this -> storage ) { $ this -> setStorage ( new Storage \ File ( array ( 'dir' => DATA_PATH ) ) ) ; } return $ this -> storage ; }
12512	public function login ( ) { if ( $ this -> validate ( ) ) { return \ Yii :: $ app -> getUser ( ) -> login ( $ this -> user , $ this -> rememberMe ? $ this -> module -> rememberFor : 0 ) ; } else { return false ; } }
1953	public static function findActiveBySourceAndParent ( $ strSource , $ intParent , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.source=? AND $t.parent=? AND $t.active='1'" ) , array ( $ strSource , $ intParent ) , $ arrOptions ) ; }
5885	protected function renderDropdown ( ) { $ config = $ this -> dropdown ; $ config [ 'clientOptions' ] = false ; $ config [ 'view' ] = $ this -> getView ( ) ; return Dropdown :: widget ( $ config ) ; }
2607	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ ioOptions = $ this -> api -> getImageOptimizationDefaultConfigOptions ( $ activeVersion ) -> data -> attributes ; if ( ! $ ioOptions ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch image optimization default config options.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'io_options' => $ ioOptions ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
6751	private function createQualifiedTransformerClass ( ) { $ reflection = new ReflectionClass ( __CLASS__ ) ; $ name = $ reflection -> getName ( ) ; $ qualifiedTransformerClass = $ name . "Transformer" ; $ this -> setTransformer ( $ qualifiedTransformerClass ) ; }
3726	public static function createFromQueryBuilder ( QueryBuilder $ builder , $ columnName = 'id' ) { return new self ( $ builder -> getSQL ( ) , $ builder -> getParameters ( ) , $ columnName , $ builder -> getConnection ( ) , $ builder -> getParameterTypes ( ) ) ; }
3527	private function fetch ( ) { $ data = FortniteClient :: sendFortnitePostRequest ( FortniteClient :: FORTNITE_API . 'game/v2/profile/' . $ this -> account_id . '/client/QueryProfile?profileId=athena&rvn=-1' , $ this -> access_token , new \ StdClass ( ) ) ; return $ data -> profileChanges [ 0 ] -> profile ; }
3049	protected function initCompilationDirectory ( ) { $ fileStorage = \ tao_models_classes_service_FileStorage :: singleton ( ) ; $ directoryIds = explode ( '|' , $ this -> getTestCompilationUri ( ) ) ; $ directories = array ( 'private' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 0 ] ) , 'public' => $ fileStorage -> getDirectoryById ( $ directoryIds [ 1 ] ) ) ; $ this -> compilationDirectory = $ directories ; }
2069	public function cutPage ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { return ( $ this -> User -> hasAccess ( $ row [ 'type' ] , 'alpty' ) && $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_PAGE_HIERARCHY , $ row ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
2408	public function flushAllData ( ) { @ trigger_error ( 'Using Template::flushAllData() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; if ( \ function_exists ( 'fastcgi_finish_request' ) ) { fastcgi_finish_request ( ) ; } elseif ( PHP_SAPI !== 'cli' ) { $ status = ob_get_status ( true ) ; $ level = \ count ( $ status ) ; while ( $ level -- > 0 && ( ! empty ( $ status [ $ level ] [ 'del' ] ) || ( isset ( $ status [ $ level ] [ 'flags' ] ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_REMOVABLE ) && ( $ status [ $ level ] [ 'flags' ] & PHP_OUTPUT_HANDLER_FLUSHABLE ) ) ) ) { ob_end_flush ( ) ; } flush ( ) ; } }
12724	public function resetSelf ( ) { $ this -> where = '' ; $ this -> select = '*' ; $ this -> limit = 20 ; $ this -> offset = 0 ; $ this -> orderBy = array ( ) ; $ this -> groupBy = array ( ) ; $ this -> prepend = '' ; $ this -> listWordsField = null ; $ this -> alternativesField = null ; $ this -> join = null ; }
2708	public function afterSave ( \ Magento \ Config \ Model \ Config $ subject ) { if ( $ this -> purge ) { $ this -> api -> cleanBySurrogateKey ( [ 'text' ] ) ; } }
12134	public function index ( QuestionRequest $ request ) { $ view = $ this -> response -> theme -> listView ( ) ; if ( $ this -> response -> typeIs ( 'json' ) ) { $ function = camel_case ( 'get-' . $ view ) ; return $ this -> repository -> setPresenter ( \ Litecms \ Forum \ Repositories \ Presenter \ QuestionPresenter :: class ) -> $ function ( ) ; } $ user_id = user_id ( ) ; $ questions = $ this -> repository -> questions ( $ user_id ) ; return $ this -> response -> title ( trans ( 'forum::question.names' ) ) -> view ( 'forum::question.index' , true ) -> data ( compact ( 'questions' , 'view' ) ) -> output ( ) ; }
3850	public function getServiceContainer ( ) { if ( ! $ this -> serviceContainer ) { $ this -> useDefaultServiceContainer ( ) ; } if ( is_callable ( $ this -> serviceContainer ) ) { return $ this -> serviceContainer = $ this -> serviceContainer -> __invoke ( ) ; } return $ this -> serviceContainer ; }
3968	protected function createAttributeInstance ( ModelInterface $ model = null ) { if ( null === $ model ) { return null ; } return $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ this -> getMetaModelByModelPid ( $ model ) ) ; }
2771	public function cloneRepository ( string $ repository , array $ options = [ ] ) : string { $ argsAndOptions = [ $ repository , $ this -> directory , $ options ] ; return $ this -> run ( 'clone' , $ argsAndOptions , false ) ; }
4316	private function getDefaultServices ( ) { return array ( 'abstracter' => function ( Debug $ debug ) { return new Debug \ Abstracter ( $ debug , $ debug -> config -> getCfgLazy ( 'abstracter' ) ) ; } , 'config' => function ( Debug $ debug ) { return new Debug \ Config ( $ debug , $ debug -> cfg ) ; } , 'errorEmailer' => function ( Debug $ debug ) { return new ErrorEmailer ( $ debug -> config -> getCfgLazy ( 'errorEmailer' ) ) ; } , 'errorHandler' => function ( Debug $ debug ) { if ( ErrorHandler :: getInstance ( ) ) { return ErrorHandler :: getInstance ( ) ; } else { $ errorHandler = new ErrorHandler ( $ debug -> eventManager ) ; $ errorHandler -> setCfg ( 'onEUserError' , 'log' ) ; return $ errorHandler ; } } , 'eventManager' => function ( ) { return new EventManager ( ) ; } , 'internal' => function ( Debug $ debug ) { return new Debug \ Internal ( $ debug ) ; } , 'logger' => function ( Debug $ debug ) { return new Debug \ Logger ( $ debug ) ; } , 'methodClear' => function ( Debug $ debug ) { return new Debug \ MethodClear ( $ debug , $ debug -> data ) ; } , 'methodTable' => function ( ) { return new Debug \ MethodTable ( ) ; } , 'output' => function ( Debug $ debug ) { $ output = new Debug \ Output ( $ debug , $ debug -> config -> getCfgLazy ( 'output' ) ) ; $ debug -> eventManager -> addSubscriberInterface ( $ output ) ; return $ output ; } , 'utf8' => function ( ) { return new Debug \ Utf8 ( ) ; } , 'utilities' => function ( ) { return new Debug \ Utilities ( ) ; } , ) ; }
11756	public function unmarkElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UNMARK_ELECT , $ params ] ) ; }
2868	public function preDispatch ( ) { parent :: preDispatch ( ) ; if ( ! Mage :: helper ( 'sheep_debug' ) -> isAllowed ( ) ) { $ this -> setFlag ( '' , 'no-dispatch' , true ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) ; } }
3432	protected function normalizeSelect ( ) { if ( $ this -> fieldsMustBeSelected ( ) ) { $ this -> select = array_merge ( $ this -> standardFields , $ this -> select ) ; } if ( $ this -> propsMustBeSelected ( ) ) { $ this -> select [ ] = 'IBLOCK_ID' ; $ this -> select [ ] = 'UF_*' ; } $ this -> select [ ] = 'ID' ; return $ this -> clearSelectArray ( ) ; }
7773	protected function validateAgainstRule ( $ field , $ value , $ rule , array $ args ) { $ ruleToCall = $ this -> getRuleToCall ( $ rule ) ; $ passed = call_user_func_array ( $ ruleToCall , [ $ value , $ this -> input , $ args ] ) ; if ( ! $ passed ) { $ this -> handleError ( $ field , $ value , $ rule , $ args ) ; return $ this -> canSkipRule ( $ ruleToCall , $ value ) ; } return true ; }
12716	protected function getConcreteFromInterface ( $ interface ) { if ( ! $ this -> isAbstractExists ( $ interface ) ) { throw Internal \ Exception \ ReflectionExceptionFactory :: runtime ( sprintf ( "%s has no concrete implementation in the class binding stack." , $ interface ) ) ; } try { return $ this -> getResolvedSingleton ( $ interface ) ; } catch ( \ Exception $ e ) { } $ concrete = $ this -> bindings [ $ interface ] [ 'concrete' ] ; $ object = $ concrete instanceof \ Closure ? $ concrete ( $ this ) : $ this -> build ( $ concrete ) ; if ( $ this -> isShared ( $ interface ) ) { $ this -> markAsResolved ( $ interface , $ object , 'singleton' ) ; } else { $ this -> markAsResolved ( $ interface , $ object ) ; } return $ object ; }
6038	protected function initTransport ( $ options , $ transport = "TCP" ) { if ( ! is_array ( $ options ) ) { throw new Ts3Exception ( "transport parameters must provided in an array" ) ; } if ( $ transport == "TCP" ) $ this -> transport = new TCP ( $ options ) ; else $ this -> transport = new UDP ( $ options ) ; }
8543	public function setShipmentEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2001	private function getFiles ( FileUpload $ uploader ) : array { $ files = $ uploader -> uploadTo ( 'system/tmp' ) ; if ( \ count ( $ files ) < 1 ) { throw new \ RuntimeException ( $ this -> translator -> trans ( 'ERR.all_fields' , [ ] , 'contao_default' ) ) ; } foreach ( $ files as & $ file ) { $ extension = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( 'csv' !== $ extension ) { throw new \ RuntimeException ( sprintf ( $ this -> translator -> trans ( 'ERR.filetype' , [ ] , 'contao_default' ) , $ extension ) ) ; } $ file = $ this -> projectDir . '/' . $ file ; } return $ files ; }
7970	public function deleteBlacklist ( $ domain , $ number ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ number ) throw new BadMethodCallException ( 'Parameter $number is missing.' ) ; try { $ r = $ this -> delete ( 'sms/' . $ domain . '/blacklists/' . $ number ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r ; }
8162	public function unblock ( ) { $ this -> status = User :: STATUS_ACTIVE ; if ( $ this -> save ( FALSE ) ) return TRUE ; return FALSE ; }
8179	public function login ( ) { return $ this -> validate ( ) ? Yii :: $ app -> user -> login ( $ this -> getUser ( ) , $ this -> rememberMe ? UserModule :: $ rememberMeDuration : 0 ) : FALSE ; }
5926	public function listCategories ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/categories' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new CategoryResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
11879	public static function getTrace ( ) { $ trace = debug_backtrace ( ) ; $ dump = '' ; $ dump .= static :: getHeader ( 'Trace du contexte' ) ; $ dump .= '<div class="dump_segment">Contexte</div>' ; $ nb = count ( $ trace ) ; for ( $ i = 1 ; $ i < $ nb ; $ i ++ ) { if ( $ i < $ nb - 1 ) { $ dump .= static :: getContext ( $ trace [ $ i ] , $ trace [ $ i + 1 ] ) ; } else { $ dump .= static :: getContext ( $ trace [ $ i ] ) ; } } $ dump .= static :: getFooter ( ) ; return $ dump ; }
7577	protected function setFileFieldValue ( $ value ) { if ( version_compare ( PHP_VERSION , '5.5.0' ) >= 0 ) { if ( ! ( $ value instanceof \ CURLFile ) ) { $ value = ltrim ( $ value , "@" ) ; $ value = new \ CURLFile ( $ value ) ; } } else { if ( strpos ( $ value , '@' ) !== 0 ) { $ value = '@' . $ value ; } } return $ value ; }
3534	public static function createNewUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } $ userObjectDb = new static ( ) ; $ userObjectDb -> username = $ username ; $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; if ( $ userObjectDb -> queryLdapUserObject ( ) == null ) { $ userObjectDb = null ; } else { $ roles = $ userObjectDb -> updateGroupAssignment ( ) ; if ( count ( $ roles ) > 0 || static :: getGroupAssigmentOptions ( 'LOGIN_POSSIBLE_WITH_ROLE_ASSIGNED_MATCHING_REGEX' , $ userObjectDb -> individualGroupAssignmentOptions ) == null ) { $ userObjectDb -> generateAuthKey ( ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> save ( ) ; } else { $ userObjectDb = null ; } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createNewUser' , static :: YII2_PROFILE_NAME . 'createNewUser' ) ; } return $ userObjectDb ; }
9569	public function setContainer ( ContainerInterface $ container ) { $ this -> container = $ container ; $ container -> instance ( 'Autarky\Application' , $ this ) ; $ container -> instance ( 'Symfony\Component\HttpFoundation\RequestStack' , $ this -> requests ) ; }
11863	public function setHandledDataItem ( $ value ) { if ( isset ( $ this -> _pairedDataItem ) ) { $ this -> pairedDataItem -> handledDataItem = $ value ; } if ( ! $ this -> _handledDataItem && $ value ) { $ this -> dataSource -> reduceRemaining ( $ this ) ; } $ this -> clean ( ) ; return $ this -> _handledDataItem = $ value ; }
10650	private function getValidator ( $ scope = 'create' ) { $ rules = $ this -> buildValidationRules ( $ scope ) ; $ custom_messages = $ this -> buildMessages ( $ scope ) ; $ validation_values = $ this -> buildValidationValues ( ) ; return Validator :: make ( $ validation_values , $ rules , $ custom_messages ) ; }
685	public function getCurrencySymbol ( $ currencyCode = null ) { $ locale = $ this -> locale ; if ( $ currencyCode !== null ) { $ locale .= '@currency=' . $ currencyCode ; } $ formatter = new \ NumberFormatter ( $ locale , \ NumberFormatter :: CURRENCY ) ; return $ formatter -> getSymbol ( \ NumberFormatter :: CURRENCY_SYMBOL ) ; }
8188	public function getBlockNames ( array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return array_keys ( $ this -> blocks ) ; } $ names = array_merge ( array_keys ( $ blocks ) , array_keys ( $ this -> blocks ) ) ; if ( false !== $ parent = $ this -> getParent ( $ context ) ) { $ names = array_merge ( $ names , $ parent -> getBlockNames ( $ context ) ) ; } return array_unique ( $ names ) ; }
1997	public function dump ( ) : void { if ( empty ( $ this -> parameters [ 'parameters' ] [ 'secret' ] ) || 'ThisTokenIsNotSoSecretChangeIt' === $ this -> parameters [ 'parameters' ] [ 'secret' ] ) { $ this -> parameters [ 'parameters' ] [ 'secret' ] = bin2hex ( random_bytes ( 32 ) ) ; } if ( isset ( $ this -> parameters [ 'parameters' ] [ 'database_port' ] ) ) { $ this -> parameters [ 'parameters' ] [ 'database_port' ] = ( int ) $ this -> parameters [ 'parameters' ] [ 'database_port' ] ; } $ this -> filesystem -> dumpFile ( $ this -> rootDir . '/app/config/parameters.yml' , "# This file has been auto-generated during installation\n" . Yaml :: dump ( $ this -> getEscapedValues ( ) ) ) ; }
2463	public static function findSentByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ arrColumns [ ] = "$t.sent=1" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.date DESC" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
7354	protected function getUrl ( $ name , $ subject , $ path ) { if ( $ subject instanceof SubjectRelativeInterface ) { if ( null === $ subject = $ this -> resolve ( $ subject , false ) ) { return null ; } } if ( ! $ subject instanceof SubjectInterface ) { throw new InvalidArgumentException ( "Expected instance of " . SubjectInterface :: class ) ; } $ event = new SubjectUrlEvent ( $ subject , $ path ) ; $ this -> eventDispatcher -> dispatch ( $ name , $ event ) ; return $ event -> getUrl ( ) ; }
7043	public function handleSrcTableNames ( GetPropertyOptionsEvent $ event ) { if ( ( $ event -> getPropertyName ( ) !== 'tag_srctable' ) || ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_attribute' ) ) { return ; } $ sqlTable = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.sql-table' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ translated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.translated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ untranslated = $ this -> translator -> trans ( 'tl_metamodel_attribute.tag_table_type.untranslated' , [ ] , 'contao_tl_metamodel_attribute' ) ; $ result = $ this -> getMetaModelTableNames ( $ translated , $ untranslated ) ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableNames ( ) as $ table ) { if ( 0 !== \ strpos ( $ table , 'mm_' ) ) { $ result [ $ sqlTable ] [ $ table ] = $ table ; } } if ( \ is_array ( $ result [ $ translated ] ) ) { \ asort ( $ result [ $ translated ] ) ; } if ( \ is_array ( $ result [ $ untranslated ] ) ) { \ asort ( $ result [ $ untranslated ] ) ; } if ( \ is_array ( $ result [ $ sqlTable ] ) ) { \ asort ( $ result [ $ sqlTable ] ) ; } $ event -> setOptions ( $ result ) ; }
11334	public function getFormattedValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formattedValue = $ this -> format -> get ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formattedValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formattedValue = $ this -> value ; } if ( is_object ( $ formattedValue ) ) { $ formattedValue = $ formattedValue -> viewLink ; } return $ formattedValue ; }
4788	function insert ( $ data ) { $ rows = func_get_args ( ) ; $ return = $ this -> insert_multi ( $ rows ) ; if ( ! $ return ) { return false ; } if ( ! is_array ( $ data ) ) { return $ return ; } if ( $ this -> notORM -> driver == "pgsql" ) { if ( ! isset ( $ data [ $ this -> primary ] ) ) { $ pgss = $ this -> query ( "SELECT pg_get_serial_sequence('" . $ this -> table . "', '" . $ this -> primary . "') pgss" , $ this -> parameters ) -> fetch ( ) ; if ( isset ( $ pgss [ 'pgss' ] ) ) { $ rs = $ this -> query ( "select last_value id from " . $ pgss [ 'pgss' ] , $ this -> parameters ) -> fetch ( ) ; $ data [ $ this -> primary ] = $ rs [ 'id' ] ; $ this -> sequence = $ rs [ 'id' ] ; } } } else { if ( ! isset ( $ data [ $ this -> primary ] ) && ( $ id = $ this -> notORM -> connection -> lastInsertId ( $ this -> notORM -> structure -> getSequence ( $ this -> table ) ) ) ) { $ data [ $ this -> primary ] = $ id ; } } return new $ this -> notORM -> rowClass ( $ data , $ this ) ; }
2150	public function activateAccount ( $ objUser ) { $ arrNewsletters = StringUtil :: deserialize ( $ objUser -> newsletter , true ) ; if ( ! \ is_array ( $ arrNewsletters ) ) { return ; } foreach ( $ arrNewsletters as $ intNewsletter ) { $ intNewsletter = ( int ) $ intNewsletter ; if ( $ intNewsletter < 1 ) { continue ; } $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='1' WHERE pid=? AND email=?" ) -> execute ( $ intNewsletter , $ objUser -> email ) ; } }
7636	public function getBlobInstance ( $ containerName = '' , $ blobName = '' , $ snapshotId = null , $ leaseId = null , $ additionalHeaders = array ( ) ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; Assertion :: notEmpty ( $ blobName , 'Blob name is not specified.' ) ; self :: assertValidRootContainerBlobName ( $ containerName , $ blobName ) ; $ query = array ( ) ; if ( ! is_null ( $ snapshotId ) ) { $ query [ 'snapshot' ] = $ snapshotId ; } $ headers = array ( ) ; if ( ! is_null ( $ leaseId ) ) { $ headers [ 'x-ms-lease-id' ] = $ leaseId ; } foreach ( $ additionalHeaders as $ key => $ value ) { $ headers [ $ key ] = $ value ; } $ resourceName = self :: createResourceName ( $ containerName , $ blobName ) ; $ response = $ this -> performRequest ( $ resourceName , $ query , 'HEAD' , $ headers , false , null , self :: RESOURCE_BLOB , self :: PERMISSION_READ ) ; if ( ! $ response -> isSuccessful ( ) ) { throw new BlobException ( $ this -> getErrorMessage ( $ response , 'Resource could not be accessed.' ) ) ; } $ metadata = $ this -> parseMetadataHeaders ( $ response -> getHeaders ( ) ) ; return new BlobInstance ( $ containerName , $ blobName , $ snapshotId , $ response -> getHeader ( 'Etag' ) , $ response -> getHeader ( 'Last-modified' ) , $ this -> getBaseUrl ( ) . '/' . $ containerName . '/' . $ blobName , $ response -> getHeader ( 'Content-Length' ) , $ response -> getHeader ( 'Content-Type' ) , $ response -> getHeader ( 'Content-Encoding' ) , $ response -> getHeader ( 'Content-Language' ) , $ response -> getHeader ( 'Cache-Control' ) , $ response -> getHeader ( 'x-ms-blob-type' ) , $ response -> getHeader ( 'x-ms-lease-status' ) , false , $ metadata ) ; }
12751	public function sendWelcomeMessage ( User $ user , Token $ token = null ) { return $ this -> sendMessage ( $ user -> email , $ this -> welcomeSubject , 'welcome' , [ 'user' => $ user , 'token' => $ token ] ) ; }
4060	public static function compare ( $ expected , $ actual , $ strict = true ) { try { self :: calculateDiff ( $ expected , $ actual , $ strict ) ; } catch ( \ Exception $ exception ) { $ instance = new DifferentValuesException ( $ expected , $ actual , $ strict , 'The values differ.' , 0 , $ exception ) ; throw $ instance ; } }
11606	public function getPHPHint ( $ namespaceContext = NULL ) { if ( ! isset ( $ this -> class ) ) { return '\stdClass' ; } if ( isset ( $ namespaceContext ) && trim ( $ this -> class -> getNamespace ( ) , '\\' ) === trim ( $ namespaceContext , '\\' ) ) { return $ this -> class -> getName ( ) ; } return '\\' . $ this -> class -> getFQN ( ) ; }
11440	public function getInfos ( $ echoable = false ) { if ( true === $ echoable ) { return join ( "\n<br />" , $ this -> infos ) ; } else { return $ this -> infos ; } }
9765	function exist ( ) : self { if ( $ this -> hasFlag ( 'directory' ) ) $ constraint = directoryExists ( ) ; else if ( $ this -> hasFlag ( 'file' ) ) $ constraint = fileExists ( ) ; else throw new \ BadMethodCallException ( 'This assertion is not a file or directory one.' ) ; return $ this -> expect ( $ this -> target , $ constraint ) ; }
10813	public function callMethodInWrappedInst ( $ method , $ args ) { $ i = $ this -> getWrappedInst ( ) ; if ( method_exists ( $ i , $ method ) ) { return call_user_method_array ( $ method , $ i , $ args ) ; } throw new UnknownMethodException ( 'Calling unknown method: ' . get_class ( $ i ) . "::$method()" ) ; }
3571	public function queryHook ( ) { return function ( $ next , $ query , $ bag ) { $ method = $ bag -> get ( 'method' ) ; $ args = $ bag -> get ( 'args' ) ; $ column = $ args -> get ( 'column' ) ; if ( ! $ this -> hasColumn ( $ column ) && $ this -> allowsMeta ( $ column ) && $ this -> isMetaQueryable ( $ method ) ) { return call_user_func_array ( [ $ this , 'metaQuery' ] , [ $ query , $ method , $ args ] ) ; } if ( in_array ( $ method , [ 'select' , 'addSelect' ] ) ) { call_user_func_array ( [ $ this , 'metaSelect' ] , [ $ query , $ args ] ) ; } return $ next ( $ query , $ bag ) ; } ; }
2459	public function move ( ) { if ( $ this -> intId && Input :: get ( 'sid' ) && ( ! $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'root' ] || ! \ in_array ( $ this -> intId , $ this -> root ) ) ) { $ objRow = $ this -> Database -> prepare ( "SELECT * FROM " . $ this -> strTable . " WHERE id=? OR id=?" ) -> limit ( 2 ) -> execute ( $ this -> intId , Input :: get ( 'sid' ) ) ; $ row = $ objRow -> fetchAllAssoc ( ) ; if ( $ row [ 0 ] [ 'pid' ] == $ row [ 1 ] [ 'pid' ] ) { $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 0 ] [ 'sorting' ] , $ row [ 1 ] [ 'id' ] ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " SET sorting=? WHERE id=?" ) -> execute ( $ row [ 1 ] [ 'sorting' ] , $ row [ 0 ] [ 'id' ] ) ; $ this -> invalidateCacheTags ( $ this ) ; } } $ this -> redirect ( $ this -> getReferer ( ) ) ; }
1667	protected function disableTwoFactor ( BackendUser $ user , $ return ) { if ( ! $ user -> useTwoFactor ) { return ; } $ user -> secret = null ; $ user -> useTwoFactor = '' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; }
5764	public function routeIndexResetFilter ( Request $ request , Response $ response , $ args ) { return $ this -> indexViewObjects ( $ response , true ) ; }
9527	private function parseEvery ( ) { $ results = [ ] ; $ i = 0 ; while ( $ i < count ( $ this -> argv ) ) { $ parameter = $ this -> argv [ $ i ] ; if ( $ this -> parseSingle ( $ i , $ parameter , $ results ) === false ) { break ; } } return $ results ; }
3062	public function canMoveBackward ( ) { $ moveBack = false ; $ session = $ this -> getTestSession ( ) ; if ( $ this -> isAdaptive ( ) ) { $ positionInCatSession = array_search ( $ this -> getCurrentCatItemId ( ) , $ this -> getShadowTest ( ) ) ; if ( $ positionInCatSession === 0 ) { if ( $ session -> getRoute ( ) -> getPosition ( ) !== 0 ) { $ moveBack = $ session -> getPreviousRouteItem ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> getRoute ( ) -> current ( ) -> getTestPart ( ) -> getNavigationMode ( ) === NavigationMode :: NONLINEAR ; } } else { $ moveBack = $ session -> canMoveBackward ( ) ; if ( $ moveBack ) { $ moveBack = $ this -> getServiceManager ( ) -> get ( SectionPauseService :: SERVICE_ID ) -> canMoveBackward ( $ session ) ; } } return $ moveBack ; }
9486	protected function checkFieldsSet ( $ fields ) { foreach ( $ fields as $ field ) { if ( property_exists ( $ this , $ field ) && $ this -> $ field === null ) { throw new \ Exception ( "'$field' is required" ) ; } } }
3218	function chunkedUploadFinish ( $ uploadId , $ path , $ writeMode ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Path :: checkArgNonRoot ( "path" , $ path ) ; WriteMode :: checkArg ( "writeMode" , $ writeMode ) ; $ params = array_merge ( array ( "upload_id" => $ uploadId ) , $ writeMode -> getExtraParams ( ) ) ; $ response = $ this -> doPost ( $ this -> contentHost , $ this -> appendFilePath ( "1/commit_chunked_upload" , $ path ) , $ params ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; return RequestUtil :: parseResponseJson ( $ response -> body ) ; }
8880	private function isValidFullPath ( string $ path ) : bool { $ valid = false ; if ( '/' === substr ( $ path , 0 , 1 ) && is_executable ( $ path ) ) { $ valid = true ; } return $ valid ; }
8466	public static function setUrlParams ( $ url = false ) { $ url = $ url !== false ? $ url : self :: getCurrentPage ( ) ; if ( strpos ( $ url , '?' ) == false && strpos ( $ url , '&' ) != false ) { $ url = preg_replace ( '/&/' , '?' , $ url , 1 ) ; $ parts = parse_url ( $ url ) ; $ query = isset ( $ parts [ 'query' ] ) ? $ parts [ 'query' ] : '' ; parse_str ( $ query , $ query ) ; } foreach ( isset ( $ query ) ? $ query : [ ] as $ key => $ value ) { $ _GET [ $ key ] = $ value ; } return explode ( '?' , $ url ) [ 0 ] ; }
3671	private function getFolderUrlFragments ( string $ alias , string $ host , string $ locale = null ) : ? array { $ pages = $ this -> getPageCandidates ( $ alias ) ; if ( null === $ pages ) { return null ; } if ( isset ( $ pages [ $ host ] ) ) { $ languages = $ pages [ $ host ] ; } else { $ languages = $ pages [ '*' ] ? : [ ] ; } unset ( $ pages ) ; $ pages = [ ] ; if ( ! $ this -> isLocalePrepended ) { $ pages = current ( $ languages ) ; } elseif ( $ locale && isset ( $ languages [ $ locale ] ) ) { $ pages = $ languages [ $ locale ] ; } if ( empty ( $ pages ) ) { return null ; } $ page = $ pages [ 0 ] ; if ( $ alias == $ page -> alias ) { $ arrFragments = [ $ alias ] ; } else { $ arrFragments = explode ( '/' , substr ( $ alias , ( \ strlen ( $ page -> alias ) + 1 ) ) ) ; array_unshift ( $ arrFragments , $ page -> alias ) ; } return $ arrFragments ; }
6371	public static function add ( $ classname , $ columns = array ( ) , $ title = null ) { if ( $ title ) { Deprecation :: notice ( 1.1 , "Title is no longer used, instead set ClassName.PluralName in translations" ) ; } self :: config ( ) -> objects [ $ classname ] = $ columns ; $ cols_string = '"' . implode ( '","' , $ columns ) . '"' ; }
11627	public function lock ( ) { $ lock_file = $ this -> getLockFile ( ) ; if ( file_exists ( $ lock_file ) ) { $ this -> pid = file_get_contents ( $ lock_file ) ; if ( $ this -> isrunning ( ) ) { error_log ( "==" . $ this -> pid . "== Already in progress..." ) ; return false ; } else error_log ( "==" . $ this -> pid . "== Previous job died abruptly..." ) ; } $ this -> pid = getmypid ( ) ; $ s = file_put_contents ( $ lock_file , $ this -> pid ) ; error_log ( "==" . $ this -> pid . "== Lock acquired, processing the job..." ) ; return $ this -> pid ; }
3210	function disableOAuth1AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/disable_access_token" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; }
2344	protected function createIfNotExists ( ) { if ( file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { return ; } if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } if ( ! $ this -> resFile = $ this -> Files -> fopen ( $ this -> strFile , 'wb' ) ) { throw new \ Exception ( sprintf ( 'Cannot create file "%s"' , $ this -> strFile ) ) ; } }
3026	private function parseResponse ( $ response ) { $ response -> json = json_decode ( $ response -> body ) ; if ( $ response -> status < 400 ) { return $ response -> json -> response ; } else { throw new RequestException ( $ response ) ; } }
3212	static function loadFromJsonFileWithRaw ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new AppInfoLoadException ( "File doesn't exist: \"$path\"" ) ; } $ str = Util :: stripUtf8Bom ( file_get_contents ( $ path ) ) ; $ jsonArr = json_decode ( $ str , true , 10 ) ; if ( is_null ( $ jsonArr ) ) { throw new AppInfoLoadException ( "JSON parse error: \"$path\"" ) ; } $ appInfo = self :: loadFromJson ( $ jsonArr ) ; return array ( $ jsonArr , $ appInfo ) ; }
7	private function parseVersion ( $ version ) { if ( preg_match ( '{^v?(\d{1,3})(\.\d+)?(\.\d+)?(\.\d+)?}i' , $ version , $ matches ) ) { $ version = $ matches [ 1 ] . ( ! empty ( $ matches [ 2 ] ) ? $ matches [ 2 ] : '.0' ) . ( ! empty ( $ matches [ 3 ] ) ? $ matches [ 3 ] : '.0' ) . ( ! empty ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '.0' ) ; return $ version ; } return null ; }
1732	public function generate ( ) { $ objArticle = ArticleModel :: findPublishedById ( $ this -> article ) ; if ( $ objArticle === null ) { return '' ; } $ objParent = PageModel :: findPublishedById ( $ objArticle -> pid ) ; if ( $ objParent === null ) { return '' ; } $ this -> objArticle = $ objArticle ; $ this -> objParent = $ objParent ; return parent :: generate ( ) ; }
718	public function timestamp ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_TIMESTAMP , $ precision ) ; }
10903	public function delete ( ) : bool { return ( bool ) $ this -> medoo -> delete ( $ this -> getTable ( ) , [ 'id' => $ this -> getId ( ) ] ) ; }
2366	public static function censor ( $ strString , $ varWords , $ strReplace = '' ) { foreach ( ( array ) $ varWords as $ strWord ) { $ strString = preg_replace ( '/\b(' . str_replace ( '\*' , '\w*?' , preg_quote ( $ strWord , '/' ) ) . ')\b/i' , $ strReplace , $ strString ) ; } return $ strString ; }
2063	public function purgeSearchIndex ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> id ) { return ; } $ objResult = $ this -> Database -> prepare ( "SELECT id FROM tl_search WHERE pid=?" ) -> execute ( $ dc -> id ) ; while ( $ objResult -> next ( ) ) { $ this -> Database -> prepare ( "DELETE FROM tl_search WHERE id=?" ) -> execute ( $ objResult -> id ) ; $ this -> Database -> prepare ( "DELETE FROM tl_search_index WHERE pid=?" ) -> execute ( $ objResult -> id ) ; } }
8974	public function setOutputFormat ( $ format ) { $ output = array ( 'xml' , 'html' , 'text' , 'text-main' ) ; if ( ! in_array ( $ format , $ output ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Available output format: %s' , implode ( ', ' , $ output ) ) ) ; } $ this -> outputFormat = $ format ; return $ this ; }
11556	protected function findParameter ( $ namespace , $ name , $ namespaceParameters ) { foreach ( $ namespaceParameters as $ namespaceParameter ) { if ( $ namespaceParameter -> getNamespace ( ) === $ namespace && $ namespaceParameter -> getName ( ) === $ name ) { return $ namespaceParameter ; } } return null ; }
1351	protected function allowed ( string $ resourceType , string $ fields ) : bool { return $ this -> notAllowed ( $ resourceType , $ fields ) -> isEmpty ( ) ; }
2336	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; $ response = $ event -> getResponse ( ) ; $ isSecure = $ request -> isSecure ( ) ; $ basePath = $ request -> getBasePath ( ) ? : '/' ; foreach ( $ this -> tokenStorage -> getUsedTokens ( ) as $ key => $ value ) { $ cookieKey = $ this -> cookiePrefix . $ key ; if ( $ request -> cookies -> has ( $ cookieKey ) && $ value === $ request -> cookies -> get ( $ cookieKey ) ) { continue ; } $ expires = null === $ value ? 1 : 0 ; $ response -> headers -> setCookie ( new Cookie ( $ cookieKey , $ value , $ expires , $ basePath , null , $ isSecure , true , false , Cookie :: SAMESITE_LAX ) ) ; } }
12650	protected function readFileContents ( $ language ) { $ fileName = $ this -> getFileName ( $ language ) ; $ fs = $ this -> env -> getFileSystem ( ) ; if ( ! $ fs -> fileExists ( $ fileName ) ) { return array ( ) ; } $ content = json_decode ( preg_replace ( '/^.*?define\((.*)\);\s*/s' , '$1' , $ fs -> getFile ( $ fileName ) ) , true ) ; if ( $ language === $ this -> baseLang ) { $ content = $ content [ 'root' ] ; } $ outdateInfo = [ ] ; $ fileName = $ this -> getOutdateInfoFileName ( $ language ) ; if ( $ fs -> fileExists ( $ fileName ) ) { $ outdateInfo = json_decode ( $ fs -> getFile ( $ fileName ) , true ) ; } foreach ( $ content as $ id => $ text ) { $ outdated = isset ( $ outdateInfo [ $ id ] ) ? $ outdateInfo [ $ id ] : true ; $ content [ $ id ] = array ( 'id' => $ id , 'name' => $ id , 'content' => $ text , 'outdated' => $ outdated ) ; } return $ content ; }
8	public function fix ( $ packageName , ConstraintInterface $ constraint = null ) { $ this -> addJob ( $ packageName , 'install' , $ constraint , true ) ; }
7500	public function requestJson ( $ method , $ url , $ options = array ( ) ) { $ options [ 'headers' ] [ ] = 'Content-Type: application/json' ; $ options [ 'headers' ] [ ] = 'Content-Length: ' . strlen ( $ options [ 'body' ] ) ; $ this -> request ( $ method , $ url , $ options ) ; }
10481	public function getDocuments ( ) { return new SyncStorageImportIterator ( [ 'sync_storage' => $ this -> getSyncStorage ( ) , 'shop_id' => $ this -> getShopId ( ) , 'document_type' => $ this -> getDocumentType ( ) , ] , $ this -> getElasticsearchManager ( ) -> getRepository ( $ this -> getDocumentClass ( ) ) , $ this -> getDoctrineManager ( ) , $ this -> getEntityClass ( ) ) ; }
4724	public function render ( ) { $ html = new Text ( ) ; $ html -> append ( '<' ) -> append ( $ this -> getName ( ) ) ; foreach ( $ this -> attributes as $ name => $ value ) { $ html -> append ( ' ' ) -> append ( $ name ) -> append ( '=' ) -> append ( '"' ) -> append ( $ value ) -> append ( '"' ) ; } if ( $ this -> text -> isEmpty ( ) ) { if ( $ this -> type == self :: TYPE_BLOCK ) { return ( string ) $ html -> append ( '>' ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; } else { return ( string ) $ html -> append ( $ this -> emptyTagSuffix ) ; } } return ( string ) $ html -> append ( '>' ) -> append ( $ this -> text ) -> append ( '</' ) -> append ( $ this -> getName ( ) ) -> append ( '>' ) ; }
640	public function dropPrimaryKey ( $ name , $ table ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropPrimaryKey ( $ name , $ table ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
11192	public function exists ( $ uri = false , $ httpMethod = false ) { if ( $ uri && $ httpMethod ) { $ this -> routeProcess ( $ uri , $ httpMethod ) ; } if ( ! isset ( $ this -> controllerPath ) ) { return false ; } return true ; }
3646	public function clean ( $ value , bool $ trim = true , bool $ clean = true ) { if ( is_bool ( $ value ) || is_int ( $ value ) || is_float ( $ value ) ) { return $ value ; } $ final = null ; if ( $ value !== null ) { if ( is_array ( $ value ) ) { $ all = $ value ; $ final = [ ] ; foreach ( $ all as $ key => $ value ) { if ( $ value !== null ) { $ final [ $ key ] = $ this -> clean ( $ value , $ trim , $ clean ) ; } } } else { if ( $ value !== null ) { $ final = $ this -> process ( ( string ) $ value , $ trim , $ clean ) ; } } } return $ final ; }
3542	public static function getExtensionOptions ( $ optionName ) { if ( isset ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && is_array ( Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] ) ) { return Yii :: $ app -> params [ 'yii2-adldap-extension-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: EXTENSION_OPTIONS_DEFAULT ) ) { return static :: EXTENSION_OPTIONS_DEFAULT [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Extension-Option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
10438	public function offsetSet ( $ attributeName , $ attribute ) { if ( ! is_string ( $ attributeName ) || ! is_string ( $ attribute ) ) { throw new ValueException ( $ attribute , 'string' ) ; } $ this -> attributes [ $ attributeName ] = $ attribute ; }
11691	public function getData ( $ origin ) { return array_reduce ( $ this -> structure -> getChildren ( ) , function ( $ acc , $ childDef ) { return array_merge ( $ acc , array ( $ childDef [ 'name' ] => $ childDef [ 'name' ] ) ) ; } , $ this -> getMetadataValues ( ) ) ; }
5553	public function getRequest ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getRequest ( ) ; } return $ this -> frameset -> getRequest ( ) ; }
12972	protected function createEntityManager ( ) { if ( $ cache = $ this -> getConfig ( 'cache_driver' , 'array' ) ) { $ cache = 'doctrine.cache.' . $ cache ; $ cache = DiC :: resolve ( $ cache ) ; } if ( $ this -> getConfig ( 'auto_config' , false ) ) { $ dev = $ this -> getConfig ( 'dev_mode' , \ Fuel :: $ env === \ Fuel :: DEVELOPMENT ) ; $ proxy_dir = $ this -> getConfig ( 'proxy_dir' ) ; $ config = Setup :: createConfiguration ( $ dev , $ proxy_dir , $ cache ) ; } else { $ config = new Configuration ; $ config -> setProxyDir ( $ this -> getConfig ( 'proxy_dir' ) ) ; $ config -> setProxyNamespace ( $ this -> getConfig ( 'proxy_namespace' ) ) ; $ config -> setAutoGenerateProxyClasses ( $ this -> getConfig ( 'auto_generate_proxy_classes' , false ) ) ; if ( $ cache ) { $ config -> setMetadataCacheImpl ( $ cache ) ; $ config -> setQueryCacheImpl ( $ cache ) ; $ config -> setResultCacheImpl ( $ cache ) ; } } $ config -> newDefaultAnnotationDriver ( array ( ) ) ; $ this -> registerMapping ( $ config ) ; $ conn = DiC :: multiton ( 'dbal' , $ this -> getConfig ( 'dbal' ) , [ $ this -> getConfig ( 'dbal' ) ] ) ; $ evm = $ conn -> getEventManager ( ) ; $ this -> registerBehaviors ( $ evm , $ config ) ; return $ this -> entityManager = EntityManager :: create ( $ conn , $ config , $ evm ) ; }
9920	private function findSimpleRelations ( Model $ model ) { foreach ( $ model -> getColumns ( ) as $ column ) { if ( ends_with ( $ column -> getName ( ) , self :: ID_SUFFIX ) ) { $ this -> defineRelation ( $ model , $ column -> getName ( ) ) ; } } }
2731	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ backends = $ this -> api -> getBackends ( $ activeVersion ) ; if ( ! $ backends ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Backend details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'backends' => $ backends ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1229	private function expr ( $ rbp = 0 ) { $ left = $ this -> { "nud_{$this->token['type']}" } ( ) ; while ( $ rbp < self :: $ bp [ $ this -> token [ 'type' ] ] ) { $ left = $ this -> { "led_{$this->token['type']}" } ( $ left ) ; } return $ left ; }
958	public function remainingTrialDaysFromCancel ( ) { if ( ! $ this -> isTrial ( ) ) { return ; } $ cancelledDate = Carbon :: parse ( $ this -> cancelled_on ) ; $ trialEndsDate = Carbon :: parse ( $ this -> trial_ends_on ) ; if ( $ this -> isCancelled ( ) && $ cancelledDate -> lte ( $ trialEndsDate ) ) { return $ this -> trial_days - ( $ this -> trial_days - $ cancelledDate -> diffInDays ( $ trialEndsDate ) ) ; } return 0 ; }
6973	private function buildFieldValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ type = $ metadata -> getTypeOfField ( $ propertyPath ) ; switch ( $ type ) { case 'smallint' : case 'integer' : case 'bigint' : if ( ! is_int ( $ value ) ) { throw new \ Exception ( 'Expected integer.' ) ; } return intval ( $ value ) ; case 'boolean' : if ( ! is_bool ( $ value ) ) { throw new \ Exception ( 'Expected boolean.' ) ; } return ( bool ) $ value ; case 'float' : case 'double' : case 'decimal' : if ( ! is_numeric ( $ value ) ) { throw new \ Exception ( 'Expected float.' ) ; } return floatval ( $ value ) ; case 'datetime' : return new \ DateTime ( $ value ) ; case 'string' : return ( string ) $ value ; } throw new \ Exception ( "Unsupported field type '$type' for path '$propertyPath'." ) ; }
7013	private function format_m ( & $ str ) { if ( strstr ( $ str , '%m' ) ) $ str = str_replace ( '%m' , sprintf ( '%02d' , $ this -> month ) , $ str ) ; }
1538	public function willSeeOne ( $ request ) : bool { if ( $ this -> route -> isRelationship ( ) ) { return false ; } if ( $ this -> route -> isResource ( ) ) { return true ; } return $ request -> isMethod ( 'POST' ) ; }
7314	public function setTime ( $ hour , $ min , $ sec ) { $ status = IAU :: Tf2d ( '+' , ( int ) $ hour , ( int ) $ min , ( float ) $ sec , $ days ) ; $ this -> checkTime ( $ status ) ; $ this -> dayFrac = $ days ; return $ this ; }
8747	public function select ( ) { $ read = [ $ this -> stream ] ; $ write = null ; $ except = null ; $ this -> selected = @ stream_select ( $ read , $ write , $ except , 0 , $ this -> timeout ) ; return $ this ; }
1823	public function listImageSize ( $ row ) { $ html = '<div class="tl_content_left">' ; $ html .= $ row [ 'name' ] ; if ( $ row [ 'width' ] || $ row [ 'height' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">' . $ row [ 'width' ] . 'x' . $ row [ 'height' ] . '</span>' ; } if ( $ row [ 'zoom' ] ) { $ html .= ' <span style="color:#999;padding-left:3px">(' . ( int ) $ row [ 'zoom' ] . '%)</span>' ; } $ html .= "</div>\n" ; return $ html ; }
2842	public function getBlocksAsTree ( ) { $ blocks = $ this -> getRequestInfo ( ) -> getBlocks ( ) ; $ tree = new Varien_Data_Tree ( ) ; $ rootNodes = array ( ) ; foreach ( $ blocks as $ block ) { $ parentNode = $ tree -> getNodeById ( $ block -> getParentName ( ) ) ; $ node = new Varien_Data_Tree_Node ( array ( 'name' => $ block -> getName ( ) , 'class' => $ block -> getClass ( ) , 'template' => $ block -> getTemplateFile ( ) , 'duration' => $ block -> getRenderedDuration ( ) , 'count' => $ block -> getRenderedCount ( ) ) , 'name' , $ tree , $ parentNode ) ; $ tree -> addNode ( $ node , $ parentNode ) ; if ( ! $ parentNode ) { $ rootNodes [ ] = $ node ; } } return $ rootNodes ; }
3559	protected function mutateValue ( $ value , $ dir = 'setter' ) { $ mutator = $ this -> getMutator ( $ value , $ dir , $ this -> attributes [ 'meta_type' ] ) ; if ( method_exists ( $ this , $ mutator ) ) { return $ this -> { $ mutator } ( $ value ) ; } return static :: $ attributeMutator -> mutate ( $ value , $ mutator ) ; }
2781	public function getCommandLine ( ) { if ( $ this -> executeRaw ) { return $ this -> getCommand ( ) ; } $ command = array_merge ( [ $ this -> getCommand ( ) ] , $ this -> buildOptions ( ) , $ this -> args ) ; return array_filter ( $ command , 'strlen' ) ; }
7316	public function setTimezone ( $ timezone ) { if ( is_string ( $ timezone ) ) { $ timezone = TimeZone :: parse ( $ timezone ) ; } else { if ( $ timezone instanceof TimeZone == false ) { throw new \ InvalidArgumentException ( ) ; } } $ jd = $ this -> toJD ( ) ; $ tzOffset = $ timezone -> offset ( $ jd ) - $ this -> timezone -> offset ( $ jd ) ; $ this -> add ( Time :: hours ( $ tzOffset ) ) ; $ this -> timezone = $ timezone ; $ this -> timezone0 = $ timezone ; return $ this ; }
7261	protected function assertAdjustmentType ( Model \ AdjustmentInterface $ adjustment , string $ expected ) : void { if ( $ expected !== $ type = $ adjustment -> getType ( ) ) { throw new Exception \ InvalidArgumentException ( "Unexpected adjustment type '$type'." ) ; } }
813	private function fixSpaceAboveClassElement ( Tokens $ tokens , $ classStartIndex , $ elementIndex ) { static $ methodAttr = [ T_PRIVATE , T_PROTECTED , T_PUBLIC , T_ABSTRACT , T_FINAL , T_STATIC ] ; $ firstElementAttributeIndex = $ elementIndex ; for ( $ i = $ elementIndex ; $ i > $ classStartIndex ; -- $ i ) { $ nonWhiteAbove = $ tokens -> getNonWhitespaceSibling ( $ i , - 1 ) ; if ( null !== $ nonWhiteAbove && $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( $ methodAttr ) ) { $ firstElementAttributeIndex = $ nonWhiteAbove ; } else { break ; } } if ( $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_COMMENT ) ) { if ( 1 === $ firstElementAttributeIndex - $ nonWhiteAbove ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; return ; } if ( substr_count ( $ tokens [ $ nonWhiteAbove + 1 ] -> getContent ( ) , "\n" ) > 1 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; return ; } if ( $ tokens [ $ nonWhiteAbove - 1 ] -> isWhitespace ( ) && substr_count ( $ tokens [ $ nonWhiteAbove - 1 ] -> getContent ( ) , "\n" ) > 0 ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbove = $ this -> findCommentBlockStart ( $ tokens , $ nonWhiteAbove ) ; $ nonWhiteAboveComment = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAboveComment , $ nonWhiteAbove , $ nonWhiteAboveComment === $ classStartIndex ? 1 : 2 ) ; } else { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 2 ) ; } return ; } if ( false === $ tokens [ $ nonWhiteAbove ] -> isGivenKind ( T_DOC_COMMENT ) ) { $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , $ nonWhiteAbove === $ classStartIndex ? 1 : 2 ) ; return ; } $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbove , $ firstElementAttributeIndex , 1 ) ; $ nonWhiteAbovePHPDoc = $ tokens -> getNonWhitespaceSibling ( $ nonWhiteAbove , - 1 ) ; $ this -> correctLineBreaks ( $ tokens , $ nonWhiteAbovePHPDoc , $ nonWhiteAbove , $ nonWhiteAbovePHPDoc === $ classStartIndex ? 1 : 2 ) ; }
10159	private function readLabel ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; $ row = self :: getUInt2d ( $ recordData , 0 ) ; $ column = self :: getUInt2d ( $ recordData , 2 ) ; $ columnString = Coordinate :: stringFromColumnIndex ( $ column + 1 ) ; if ( ( $ this -> getReadFilter ( ) !== null ) && $ this -> getReadFilter ( ) -> readCell ( $ columnString , $ row + 1 , $ this -> phpSheet -> getTitle ( ) ) ) { $ xfIndex = self :: getUInt2d ( $ recordData , 4 ) ; if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( substr ( $ recordData , 6 ) ) ; $ value = $ string [ 'value' ] ; } else { $ string = $ this -> readByteStringLong ( substr ( $ recordData , 6 ) ) ; $ value = $ string [ 'value' ] ; } if ( $ this -> readEmptyCells || trim ( $ value ) !== '' ) { $ cell = $ this -> phpSheet -> getCell ( $ columnString . ( $ row + 1 ) ) ; $ cell -> setValueExplicit ( $ value , DataType :: TYPE_STRING ) ; if ( ! $ this -> readDataOnly ) { $ cell -> setXfIndex ( $ this -> mapCellXfIndex [ $ xfIndex ] ) ; } } } }
8592	public function setFilterOptions ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FilterOptions' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6086	public function listTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/moodboards/templates' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MoodboardTemplateResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3944	public static function searchFiles ( $ folder , $ extension ) { $ scanResult = array ( ) ; $ result = array ( ) ; if ( is_dir ( TL_ROOT . '/' . $ folder ) ) { $ scanResult = scan ( TL_ROOT . '/' . $ folder ) ; } foreach ( $ scanResult as $ value ) { if ( ! is_file ( TL_ROOT . '/' . $ folder . '/' . $ value ) ) { $ result += self :: searchFiles ( $ folder . '/' . $ value , $ extension ) ; } else { if ( preg_match ( '/' . $ extension . '$/i' , $ value ) ) { $ result [ $ folder ] [ $ folder . '/' . $ value ] = $ value ; } } } return $ result ; }
8316	public function startPasswordResetSession ( $ user ) { $ this -> session -> migrate ( true ) ; $ this -> session -> set ( "pwreset" , array ( 'user' => $ user , 'validity' => time ( ) + $ this -> config [ "resetTimeout" ] ) ) ; }
12629	public function sendToDevice ( $ deviceId , $ openId , $ content ) { $ params = [ 'device_type' => $ this -> deviceType , 'device_id' => $ deviceId , 'open_id' => $ openId , 'content' => base64_encode ( $ content ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_TRANS_MSG , $ params ] ) ; }
6709	protected function useActualParameters ( ) { $ this -> setParameters ( $ this -> urlToParameters ( $ this -> getRequestedUri ( ) ) ) ; $ this -> setParameters ( $ _REQUEST ) ; $ this -> setParameters ( $ this -> parseHeader ( $ _SERVER ) ) ; $ this -> setParameters ( $ this -> stringToArray ( $ this -> readBody ( ) ) ) ; return $ this -> getParameters ( ) ; }
1726	protected function checkAccountStatus ( ) { @ trigger_error ( 'Using User::checkAccountStatus() has been deprecated and will no longer work in Contao 5.0. Use Symfony security instead.' , E_USER_DEPRECATED ) ; try { $ userChecker = System :: getContainer ( ) -> get ( 'contao.security.user_checker' ) ; $ userChecker -> checkPreAuth ( $ this ) ; $ userChecker -> checkPostAuth ( $ this ) ; } catch ( AuthenticationException $ exception ) { return false ; } return true ; }
8224	protected function logRateLimitReached ( $ actionName , $ blockType , $ entityId , $ config ) { $ this -> getLogger ( ) -> notice ( "Rate limit of {cnt} reached: {action} for {entity} ({type})." , array ( 'cnt' => $ config [ "count" ] , 'action' => $ actionName , 'entity' => $ entityId , 'type' => $ blockType ) ) ; }
8631	public function setReportInfoList ( $ reportInfo ) { if ( ! $ this -> _isNumericArray ( $ reportInfo ) ) { $ reportInfo = array ( $ reportInfo ) ; } $ this -> fields [ 'ReportInfo' ] [ 'FieldValue' ] = $ reportInfo ; return $ this ; }
9336	public function turn ( ) { if ( $ this -> original -> type == self :: TYPE_TURN ) { return $ this -> original -> value ; } return $ this -> float_rad / ( 2 * pi ( ) ) ; }
11463	public static function exception ( $ Throwable ) { while ( @ ob_end_clean ( ) ) ; try { if ( PHP_SAPI == 'cli' ) { $ message = BaseException :: displayConsoleException ( $ Throwable ) ; if ( @ fwrite ( STDERR , $ message ) === false ) echo $ message ; } else { @ header ( "HTTP/1.1 500 Internal Server Error" ) ; @ header ( 'Content-Type: text/html' ) ; echo BaseException :: displayException ( $ Throwable ) ; } } catch ( \ Throwable $ e ) { $ class = get_class ( $ e ) ; $ message = $ e -> getMessage ( ) ; echo "Uncaught $class inside exception-handler: \"$message\"" ; } exit ( 1 ) ; }
6942	protected function scheduleSubjectStockUnitChangeEvent ( StockUnitInterface $ stockUnit ) { $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSubjectStockUnitChangeEventName ( ) , new SubjectStockUnitEvent ( $ stockUnit ) ) ; }
9686	public function implode ( $ value , $ glue = null ) { $ new_collection = new Collection ( $ this -> toArray ( ) ) ; $ first = $ new_collection -> first ( ) ; if ( is_array ( $ first ) || is_object ( $ first ) ) { return implode ( $ glue , $ new_collection -> pluck ( $ value ) -> all ( ) ) ; } return implode ( $ value , $ new_collection -> all ( ) ) ; }
4662	public function sendNow ( ) { $ config = $ this -> getManager ( ) -> getDI ( ) -> getConfig ( ) ; $ message = $ this -> getMessage ( ) ; $ username = $ config -> email -> username ; $ password = $ config -> email -> password ; $ host = $ config -> email -> host ; $ port = $ config -> email -> port ; $ transport = \ Swift_SmtpTransport :: newInstance ( $ host , $ port ) ; $ transport -> setUsername ( $ username ) ; $ transport -> setPassword ( $ password ) ; $ swift = \ Swift_Mailer :: newInstance ( $ transport ) ; $ failures = [ ] ; $ swift -> send ( $ message , $ failures ) ; }
6041	public function search ( $ sessionId , Search $ search , $ hits ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'sessionId' => $ sessionId , 'search' => $ search , 'hits' => $ hits ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/events/search' , $ parameters , true ) ; return $ result ; }
9099	public function serve ( ServiceCallback $ callback ) { $ this -> bind ( ) ; $ this -> listen ( ) ; $ runOn = true ; while ( $ runOn ) { $ clientHandle = @ socket_accept ( $ this -> handle ) ; if ( ! is_resource ( $ clientHandle ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ address = null ; $ port = 0 ; if ( ! @ socket_getpeername ( $ clientHandle , $ address , $ port ) ) { $ code = socket_last_error ( $ clientHandle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } $ client = new ClientSocket ( new Endpoint ( $ address , $ port ) , $ clientHandle ) ; $ runOn = boolval ( $ callback -> callback ( $ client ) ) ; } }
5039	public function set ( $ key , ImageInterface $ image , $ check = true ) { $ images = $ this -> getImages ( ) ; if ( $ check && ( $ img = $ this -> get ( $ key ) ) ) { $ images -> removeElement ( $ img ) ; } $ image -> setBelongsTo ( $ this -> id ) ; $ image -> setKey ( $ key ) ; $ images -> add ( $ image ) ; return $ this ; }
11241	public function rule ( $ fieldName , $ checks , $ humanName = false ) { $ checkFailures = 0 ; if ( $ humanName == false ) { $ humanName = ucfirst ( $ fieldName ) ; } $ fieldData = $ this -> getValue ( $ fieldName ) ; if ( ! is_array ( $ checks ) ) { $ checks = explode ( '|' , $ checks ) ; } foreach ( $ checks as $ check ) { $ checkName = $ check ; if ( isset ( $ this -> customChecks -> $ check ) ) { $ customCheckDef = $ this -> customChecks -> $ check ; $ customType = $ customCheckDef [ 0 ] ; $ arguments = array ( $ fieldData , $ customCheckDef [ 1 ] , $ customCheckDef [ 2 ] , $ customCheckDef [ 3 ] , $ customCheckDef [ 4 ] ) ; $ checkResult = call_user_func_array ( array ( $ this , $ customType ) , $ arguments ) ; } else { $ checkArgs = explode ( '[' , $ check , 2 ) ; if ( count ( $ checkArgs ) > 1 ) { $ check = $ checkArgs [ 0 ] ; $ checkName = $ checkArgs [ 0 ] ; $ checkArgs [ 1 ] = '[' . $ checkArgs [ 1 ] ; $ args = array ( ) ; preg_match_all ( "/\[([^\]]*)\]/" , $ checkArgs [ 1 ] , $ args ) ; $ this -> matchedArg = $ args [ 1 ] [ 0 ] ; $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData , $ args [ 1 ] ) ; } else { $ check = '_' . $ checkName ; $ checkResult = $ this -> $ check ( $ fieldData ) ; } } if ( $ checkResult == false ) { $ this -> errors [ ] = sprintf ( $ this -> lang -> $ checkName , $ humanName , $ this -> matchedArg ) ; $ this -> matchedArg = false ; $ checkFailures ++ ; } } return $ checkFailures == 0 ? true : false ; }
7789	public function setTransactionClass ( $ transactionClass ) { if ( ! is_callable ( $ transactionClass ) && ! class_exists ( $ transactionClass ) ) { throw new \ InvalidArgumentException ( '$transactionClass must be a valid classname or a PHP callable' ) ; } $ this -> transactionClass = $ transactionClass ; return $ this ; }
5348	public function installOperatingSystem ( $ vpsName , $ operatingSystemName , $ hostname ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystem' , [ $ vpsName , $ operatingSystemName , $ hostname ] ) ; }
8365	public function createPostTimelineEntry ( EntityPublishedEvent $ event ) : void { $ post = $ event -> getObject ( ) ; if ( ! $ post instanceof Post ) { return ; } $ author = $ this -> user_provider -> loadUserByUsername ( $ post -> getAuthor ( ) ) ; $ post_component = $ this -> action_manager -> findOrCreateComponent ( $ post ) ; $ author_component = $ this -> action_manager -> findOrCreateComponent ( $ author ) ; foreach ( $ post -> getGroups ( ) as $ group ) { $ group_component = $ this -> action_manager -> findOrCreateComponent ( $ group ) ; if ( null === $ post -> getParent ( ) ) { $ verb = 'post' ; } else { $ verb = 'reply' ; } $ action = $ this -> action_manager -> create ( $ author_component , $ verb , [ 'directComplement' => $ post_component , 'indirectComplement' => $ group_component , ] ) ; $ this -> action_manager -> updateAction ( $ action ) ; } }
4659	public function getChainStrategy ( ) { $ strategy = new ChainBuildStrategy ( ) ; $ strategy -> pushStrategy ( $ this -> getTravisCiStrategy ( ) ) ; $ strategy -> pushStrategy ( $ this -> getJoliCiStrategy ( ) ) ; return $ strategy ; }
8328	public function getCaptchaResult ( $ captchaId ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , "/res.php?key={$this->apiKey}&action=get&id={$captchaId}&json=1" ) ; $ responseData = json_decode ( $ response -> getBody ( ) -> __toString ( ) , true ) ; if ( JSON_ERROR_NONE !== json_last_error ( ) ) { throw new InvalidArgumentException ( 'json_decode error: ' . json_last_error_msg ( ) ) ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_CAPCHA_NOT_READY ) { return false ; } if ( $ responseData [ 'status' ] === self :: STATUS_CODE_OK ) { $ this -> getLogger ( ) -> info ( "Got OK response: `{$responseData['request']}`." ) ; return $ responseData [ 'request' ] ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseData [ 'request' ] ) ? : $ responseData [ 'request' ] , $ responseData [ 'status' ] ) ; }
1018	private function arrayMergeDeep ( array $ array1 , array $ array2 ) : array { $ merged = $ array1 ; foreach ( $ array2 as $ key => & $ value ) { if ( is_numeric ( $ key ) ) { if ( ! in_array ( $ value , $ merged , true ) ) { $ merged [ ] = $ value ; } } elseif ( is_array ( $ value ) && isset ( $ merged [ $ key ] ) && is_array ( $ merged [ $ key ] ) ) { $ merged [ $ key ] = $ this -> arrayMergeDeep ( $ merged [ $ key ] , $ value ) ; } else { $ merged [ $ key ] = $ value ; } } return $ merged ; }
1861	public function chmod ( $ strFile , $ varMode ) { $ this -> validate ( $ strFile ) ; return chmod ( $ this -> strRootDir . '/' . $ strFile , $ varMode ) ; }
3630	protected function validateItems ( array $ items , $ type ) { foreach ( $ items as $ item ) { $ this -> validateItem ( $ item , $ type ) ; } }
11509	protected function parseMessageFromRequest ( $ content ) { $ content = strval ( $ content ) ; $ dataSet = json_decode ( $ content , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ content = XML :: build ( $ dataSet ) ; } if ( $ this -> isSafeMode ( ) ) { if ( ! $ this -> encryptor ) { throw new RuntimeException ( 'Safe mode Encryptor is necessary, please use Guard::setEncryptor(Encryptor $encryptor) set the encryptor instance.' ) ; } $ message = $ this -> encryptor -> decryptMsg ( $ this -> request -> get ( 'msg_signature' ) , $ this -> request -> get ( 'nonce' ) , $ this -> request -> get ( 'timestamp' ) , $ content ) ; } else { $ message = XML :: parse ( $ content ) ; } return $ message ; }
11015	public static function sec2time ( $ seconds ) { $ sec = intval ( $ seconds ) ; $ dtF = new \ DateTime ( "@0" ) ; $ dtT = new \ DateTime ( "@$sec" ) ; return $ dtF -> diff ( $ dtT ) -> format ( '%a days, %h hours, %i minutes and %s seconds' ) ; }
12291	public function findPost ( $ search ) { $ qb = $ this -> getQueryBuilder ( ) -> select ( 'p, pTrans' ) -> join ( 'p.translations' , 'pTrans' ) ; if ( ! empty ( $ search ) ) { $ qb -> where ( 'pTrans.title LIKE :search' ) -> orWhere ( 'pTrans.description LIKE :search' ) -> setParameter ( 'search' , '%' . $ search . '%' ) ; } $ qb -> orderBy ( 'p.published' , 'DESC' ) ; return $ qb -> getQuery ( ) -> getResult ( ) ; }
2178	private function addDefaultsToContext ( array $ context ) : array { $ context = array_merge ( $ this -> context , $ context ) ; if ( ! isset ( $ context [ 'request_token' ] ) ) { $ context [ 'request_token' ] = $ this -> getRequestToken ( ) ; } if ( ! isset ( $ context [ 'language' ] ) ) { $ context [ 'language' ] = $ this -> container -> get ( 'translator' ) -> getLocale ( ) ; } if ( ! isset ( $ context [ 'ua' ] ) ) { $ context [ 'ua' ] = $ this -> getUserAgentString ( ) ; } if ( ! isset ( $ context [ 'path' ] ) ) { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ context [ 'host' ] = $ request -> getHost ( ) ; $ context [ 'path' ] = $ request -> getBasePath ( ) ; } return $ context ; }
12068	public function fetchProject ( Project $ project ) { $ response = $ this -> getResponse ( 'get' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
3063	protected function saveAdaptiveResults ( CatSession $ catSession ) { $ testResult = $ catSession -> getTestResult ( ) ; $ testResult = empty ( $ testResult ) ? [ ] : [ $ testResult ] ; return $ this -> storeResult ( array_merge ( $ testResult , $ catSession -> getItemResults ( ) ) ) ; }
3203	protected function validate_css_property_value ( $ value , $ compare_type , $ compare_value ) { switch ( $ compare_type ) { case '!=' : return $ value !== $ compare_value ; case '>' : return $ value > $ compare_value ; default : return false ; } }
2247	public static function generateMargin ( $ arrValues , $ strType = 'margin' ) { if ( ! \ is_array ( $ arrValues ) ) { $ arrValues = array ( 'top' => '' , 'right' => '' , 'bottom' => '' , 'left' => '' , 'unit' => '' ) ; } $ top = $ arrValues [ 'top' ] ; $ right = $ arrValues [ 'right' ] ; $ bottom = $ arrValues [ 'bottom' ] ; $ left = $ arrValues [ 'left' ] ; if ( $ top != '' && $ right != '' && $ bottom != '' && $ left != '' ) { if ( $ top == $ right && $ top == $ bottom && $ top == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top == $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } elseif ( $ top != $ bottom && $ right == $ left ) { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ';' ; } else { return $ strType . ':' . $ top . $ arrValues [ 'unit' ] . ' ' . $ right . $ arrValues [ 'unit' ] . ' ' . $ bottom . $ arrValues [ 'unit' ] . ' ' . $ left . $ arrValues [ 'unit' ] . ';' ; } } $ return = array ( ) ; $ arrDir = compact ( 'top' , 'right' , 'bottom' , 'left' ) ; foreach ( $ arrDir as $ k => $ v ) { if ( $ v != '' ) { $ return [ ] = $ strType . '-' . $ k . ':' . $ v . $ arrValues [ 'unit' ] . ';' ; } } return implode ( $ return ) ; }
7452	protected function renderRTL ( ) : string { $ trail = '' ; if ( $ this -> after ) { $ trail .= '<span class="after">' . $ this -> after . '</span> ' ; } $ trail .= \ join ( ' <span class="sep delimiter">' . $ this -> delimiter . '</span> ' , \ array_reverse ( $ this -> links ) ) ; if ( $ this -> before ) { $ trail .= ' <span class="before">' . $ this -> before . '</span>' ; } return $ trail ; }
2587	protected function loadCreatePnr ( PnrCreatePnrOptions $ params ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; $ tattooCounter = 0 ; if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; }
6652	public function addExtraData ( array $ extraData = [ ] ) { foreach ( $ extraData as $ key => $ data ) { $ this -> extraData [ $ key ] = $ data ; } }
1987	private function filterOptions ( array $ allowedSizes ) : array { if ( empty ( $ allowedSizes ) ) { return [ ] ; } $ filteredSizes = [ ] ; foreach ( $ this -> options as $ group => $ sizes ) { if ( 'image_sizes' === $ group ) { $ this -> filterImageSizes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } else { $ this -> filterResizeModes ( $ sizes , $ allowedSizes , $ filteredSizes , $ group ) ; } } return $ filteredSizes ; }
11406	public function actionCreate ( ) { $ model = new Item ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) && $ model -> save ( ) ) { return $ this -> redirect ( [ 'index' ] ) ; } else { return $ this -> render ( 'create' , [ 'model' => $ model , ] ) ; } }
10289	protected function executeTasks ( array $ tasks ) { foreach ( $ tasks as $ scheduled => $ taskList ) { foreach ( $ taskList as $ cronjob ) { if ( ( $ task = $ this -> taskFactory -> factory ( $ cronjob -> task , $ scheduled , $ this -> logger ) ) !== false ) { $ this -> logger -> setTask ( $ task -> getId ( ) ) ; $ this -> logger -> log ( 'Start task execution.' ) ; $ status = $ task -> execute ( ) ; switch ( $ status ) { case Executor :: SUCCESS : $ this -> logger -> log ( 'Finished task execution.' ) ; break ; case Executor :: ERROR : $ this -> logger -> log ( 'Error occured during task execution.' , Logger :: WARNING ) ; break ; case Executor :: RESCHEDULE : $ this -> logger -> log ( 'Task will be rescheduled for ' . $ task -> reScheduleTime . ' seconds.' ) ; $ this -> rescheduled [ $ scheduled + $ task -> reScheduleTime ] = $ cronjob ; break ; default : $ this -> logger -> log ( 'Invalid status returned by task.' , Logger :: ERROR ) ; break ; } $ this -> logger -> setTask ( ) ; } } } }
3548	public function create ( $ request ) { $ model = $ this -> repository -> create ( $ request -> all ( ) ) ; $ model -> { $ this -> getShortRelationName ( ) } ( ) -> sync ( $ request -> get ( $ this -> getRelationName ( ) , [ ] ) ) ; $ event_class = "Acoustep\EntrustGui\Events\\" . ucwords ( $ this -> getModelName ( ) ) . 'CreatedEvent' ; $ event = new $ event_class ; $ this -> dispatcher -> fire ( $ event -> setModel ( $ model ) ) ; return $ model ; }
7056	protected static function dayOfYear ( $ y , $ m , $ d ) { $ l = ( ( int ) $ y % 4 == 0 && ( int ) $ y % 100 != 0 ) || ( int ) $ y % 400 == 0 ; $ k = $ l ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ m / 9 ) - $ k * intval ( ( ( int ) $ m + 9 ) / 12 ) + ( int ) $ d - 30 ; return ( int ) $ n ; }
3142	public function skip ( RunnerServiceContext $ context , $ scope , $ ref ) { return $ this -> move ( $ context , 'skip' , $ scope , $ ref ) ; }
12706	public static function getAllCommands ( ) : array { $ commands = [ ] ; foreach ( get_declared_classes ( ) as $ class ) { if ( is_subclass_of ( $ class , 'Senhung\CLI\Command' ) ) { $ commandObject = new $ class ; $ command = $ commandObject -> getCommand ( ) ; $ commands [ $ command ] = $ class ; } } return $ commands ; }
4770	public function renderWidget ( string $ widgetGroup = '' , array $ widgetId = [ ] ) { $ widgets = $ this -> widgetBuilder -> build ( $ this -> widgets -> getWidgets ( ) , $ widgetGroup , $ widgetId ) ; return $ this -> engine -> render ( $ widgets ) ; }
12128	public function run ( InputInterface $ input , OutputInterface $ output ) { $ this -> returnCode = static :: RETURN_SUCCESS ; $ this -> doPreRun ( $ input , $ output ) ; if ( ! $ this -> executeDependencies ( $ input , $ output ) ) { $ this -> returnCode = static :: RETURN_ERROR ; } else { $ this -> returnCode = ( int ) $ this -> execute ( $ input , $ output ) ; } $ this -> doPostRun ( $ input , $ output , $ this -> returnCode ) ; return $ this -> returnCode ; }
6464	public function isJson ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/application\/json/i" , $ contentType ) === 1 ; }
11479	protected function send ( RequestInterface $ request ) : ResponseInterface { $ request = $ request -> withHeader ( "Authorization" , sprintf ( "Bearer %s" , $ this -> apiToken ) ) ; $ request = $ request -> withHeader ( "Content-Type" , "application/json" ) ; $ request = $ request -> withHeader ( "Accept" , "application/json" ) ; try { $ response = $ this -> client -> send ( $ request ) ; } catch ( GuzzleException $ e ) { if ( $ e -> getCode ( ) === 401 ) { throw new ClientException ( "Authorization failed. Did you specify the right api token?" , $ request , null , $ e ) ; } throw new ClientException ( sprintf ( "Failed to execute request (code %d): %s" , $ e -> getCode ( ) , $ e -> getMessage ( ) ) , $ request , null , $ e ) ; } return $ response ; }
6721	private function handleTokenResponse ( $ response ) { $ params = ( $ response instanceof OAuthToken ) ? $ response -> getParams ( ) : $ response ; $ status = ArrayHelper :: getValue ( $ params , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ token = ArrayHelper :: getValue ( $ params , 'data' ) ; if ( is_null ( $ token ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ token ; } else { $ message = ArrayHelper :: getValue ( $ params , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
2013	public static function addNamespaces ( $ names ) { @ trigger_error ( 'Using ClassLoader::addNamespaces() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ names as $ name ) { self :: addNamespace ( $ name ) ; } }
1353	protected function invalid ( ) : Collection { if ( ! is_array ( $ this -> value ) ) { return collect ( ) ; } return collect ( $ this -> value ) -> map ( function ( $ value , $ key ) { return $ this -> notAllowed ( $ key , $ value ) ; } ) -> flatMap ( function ( Collection $ fields , $ type ) { return $ fields -> map ( function ( $ field ) use ( $ type ) { return "{$type}.{$field}" ; } ) ; } ) ; }
4033	public function push ( $ url , $ table , $ icon ) { $ this -> elements [ ] = [ 'url' => $ url , 'text' => $ this -> getLabel ( $ table ) , 'icon' => $ this -> iconBuilder -> getBackendIcon ( $ icon ) ] ; }
8137	public function getCacheFilename ( $ name ) { @ trigger_error ( sprintf ( 'The %s method is deprecated since version 1.22 and will be removed in Twig 2.0.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ key = $ this -> cache -> generateKey ( $ name , $ this -> getTemplateClass ( $ name ) ) ; return ! $ key ? false : $ key ; }
3488	private static function tryResolveBySpomkyLabsJoseSystem ( ) : ? SpomkyLabsJoseSignatureGenerator { $ requiredClasses = [ JWKFactory :: class , JWSFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new SpomkyLabsJoseSignatureGenerator ( ) ; }
6194	protected function loadControllers ( $ path ) { $ this -> app -> config [ 'controller' ] = array_unique ( array_merge ( $ this -> app -> config [ 'controller' ] ?? [ ] , $ path ) ) ; }
10057	public function hasItem ( $ key ) { if ( isset ( $ this -> data [ $ key ] ) ) { $ item = $ this -> data [ $ key ] ; if ( $ item -> isHit ( ) === true && ( $ item -> getExpires ( ) === null || $ item -> getExpires ( ) > new DateTime ( ) ) ) { return true ; } } return false ; }
2725	private function canPurgeObject ( \ Magento \ Framework \ DataObject \ IdentityInterface $ object ) { if ( $ object instanceof \ Magento \ Catalog \ Model \ Category && ! $ this -> config -> canPurgeCatalogCategory ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Catalog \ Model \ Product && ! $ this -> config -> canPurgeCatalogProduct ( ) ) { return false ; } if ( $ object instanceof \ Magento \ Cms \ Model \ Page && ! $ this -> config -> canPurgeCmsPage ( ) ) { return false ; } return true ; }
1128	public function isSelfOrAncestorOf ( $ other ) { return ( $ this -> getLeft ( ) <= $ other -> getLeft ( ) && $ this -> getRight ( ) > $ other -> getLeft ( ) && $ this -> inSameScope ( $ other ) ) ; }
1590	protected function invokeMany ( iterable $ hooks , ... $ arguments ) { foreach ( $ hooks as $ hook ) { $ result = $ this -> invoke ( $ hook , ... $ arguments ) ; if ( ! is_null ( $ result ) ) { return $ result ; } } return null ; }
7865	protected function drawBordered ( $ content ) { $ left = $ this -> geometry -> getLeftBordersWith ( static :: BORDER_X ) ; $ right = $ this -> geometry -> getRightBordersWith ( static :: BORDER_X ) ; $ this -> drawRow ( $ left . $ content . $ right ) ; }
7931	public function appendToCollection ( array $ data ) { list ( $ data ) = $ this -> fireEvent ( 'append-to-collection' , [ $ data ] ) ; $ files = [ ] ; if ( isset ( $ data [ 'files' ] [ 'js' ] ) && is_array ( $ data [ 'files' ] [ 'js' ] ) ) $ files [ 'js' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'js' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; if ( isset ( $ data [ 'files' ] [ 'css' ] ) && is_array ( $ data [ 'files' ] [ 'css' ] ) ) $ files [ 'css' ] = $ this -> resolveFilesList ( $ data [ 'files' ] [ 'css' ] , isset ( $ data [ 'revision' ] ) ? $ data [ 'revision' ] : null ) ; $ this -> collection [ ] = [ 'order' => isset ( $ data [ 'order' ] ) ? $ data [ 'order' ] : 0 , 'name' => isset ( $ data [ 'name' ] ) ? $ data [ 'name' ] : uniqid ( ) , 'files' => $ files , 'group' => isset ( $ data [ 'group' ] ) ? $ data [ 'group' ] : $ this -> defaultGroup , 'require' => isset ( $ data [ 'require' ] ) ? $ data [ 'require' ] : [ ] ] ; return $ this ; }
11127	protected function renderView ( $ view , $ data ) { try { return parent :: renderView ( $ view , $ data ) ; } catch ( \ InvalidArgumentException $ e ) { return static :: applyDataToView ( $ view , $ data ) ; } }
8286	protected function loadDefaultConfig ( array $ config ) { $ configurator = new PluginConfigurator ; $ validConfig = $ configurator -> validate ( isset ( $ config [ self :: PLUGIN_NAME ] ) ? $ config [ self :: PLUGIN_NAME ] : null ) ; return $ validConfig ; }
3065	protected function convertCatVariables ( array $ variables ) { $ runnerService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerService :: SERVICE_ID ) ; $ convertedVariables = [ ] ; foreach ( $ variables as $ variable ) { switch ( $ variable -> getVariableType ( ) ) { case ResultVariable :: TRACE_VARIABLE : $ getVariableMethod = 'getTraceVariable' ; break ; case ResultVariable :: RESPONSE_VARIABLE : $ getVariableMethod = 'getResponseVariable' ; break ; case ResultVariable :: OUTCOME_VARIABLE : $ getVariableMethod = 'getOutcomeVariable' ; break ; case ResultVariable :: TEMPLATE_VARIABLE : default : $ getVariableMethod = null ; break ; } if ( is_null ( $ getVariableMethod ) ) { \ common_Logger :: w ( 'Variable of type ' . $ variable -> getVariableType ( ) . ' is not implemented in ' . __METHOD__ ) ; throw new \ common_exception_NotImplemented ( ) ; } $ convertedVariables [ ] = call_user_func_array ( array ( $ runnerService , $ getVariableMethod ) , array ( $ variable -> getId ( ) , $ variable -> getValue ( ) ) ) ; } return $ convertedVariables ; }
10228	private function resolveModelName ( $ model ) { if ( $ model instanceof Controller ) { $ exploded = explode ( '\\' , get_class ( $ model ) ) ; $ controllerName = array_pop ( $ exploded ) ; return str_singular ( str_replace ( 'Controller' , '' , $ controllerName ) ) ; } else if ( $ model instanceof Eloquent ) { return get_class ( $ model ) ; } else { return $ model ; } }
7196	public function handleReleasedChange ( OrderInterface $ order ) { if ( $ this -> persistenceHelper -> isChanged ( $ order , 'sample' ) ) { if ( $ order -> isReleased ( ) && ! $ order -> isSample ( ) ) { throw new IllegalOperationException ( "Can't turn 'sample' into false if order is released." ) ; } } if ( ! $ this -> persistenceHelper -> isChanged ( $ order , 'released' ) ) { return false ; } if ( ! $ order -> isSample ( ) && $ order -> isReleased ( ) ) { $ order -> setReleased ( false ) ; return true ; } if ( ! OrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } foreach ( $ order -> getItems ( ) as $ item ) { $ this -> applySaleItemRecursively ( $ item ) ; } return false ; }
2576	protected function mergeOptions ( $ existingOptions , $ newOptions ) { if ( ! empty ( $ newOptions ) ) { $ existingOptions = array_merge ( $ existingOptions , $ newOptions ) ; } return $ existingOptions ; }
10601	public function editQuery ( $ name , $ value ) { $ parts = explode ( '&' , $ this -> _urlParts [ 'query' ] ) ; $ return = [ ] ; foreach ( $ parts as $ p ) { $ paramData = explode ( '=' , $ p ) ; if ( $ paramData [ 0 ] === $ name ) { $ paramData [ 1 ] = $ value ; } $ return [ ] = implode ( '=' , $ paramData ) ; } $ this -> _urlParts [ 'query' ] = implode ( '&' , $ return ) ; return $ this ; }
3677	private function fieldExists ( $ strTableName , $ strColumnName ) { $ columns = $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ strTableName ) ; return isset ( $ columns [ $ strColumnName ] ) ; }
10718	public function paginate ( $ page = 1 , $ perPage = null , $ columns = [ '*' ] ) { $ perPage = $ perPage ? : $ this -> defaultPageSize ; $ query = $ this -> getQuery ( ) ; $ total = $ query -> getQuery ( ) -> getCountForPagination ( $ columns ) ; $ query -> getQuery ( ) -> forPage ( $ page , $ perPage ) ; $ results = $ query -> get ( $ columns ) ; $ results = new LengthAwarePaginator ( $ results , $ total , $ perPage , $ page ) ; return $ this -> returnResults ( $ results ) ; }
1867	private function validateSessionLifetime ( User $ user ) : void { if ( ! $ this -> session -> isStarted ( ) ) { return ; } $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ timeout = ( int ) $ config -> get ( 'sessionTimeout' ) ; if ( $ timeout > 0 && ( time ( ) - $ this -> session -> getMetadataBag ( ) -> getLastUsed ( ) ) < $ timeout ) { return ; } if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has been logged out automatically due to inactivity' , $ user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ user -> username ) ] ) ; } throw new UsernameNotFoundException ( sprintf ( 'User "%s" has been logged out automatically due to inactivity.' , $ user -> username ) ) ; }
8725	public function translationModel ( ) { $ translation = new TranslationModel ( ) ; $ translation -> setConnection ( $ this -> getI18nConnection ( ) ) ; $ translation -> setTable ( $ this -> getI18nTable ( ) ) ; $ translation -> setKeyName ( $ this -> getForeignKey ( ) ) ; $ translation -> setLocaleKey ( $ this -> getLocaleKey ( ) ) ; if ( $ attributes = $ this -> translatableAttributes ( ) ) { $ translation -> fillable ( array_intersect ( $ attributes , $ this -> getFillable ( ) ) ) ; } return $ translation ; }
11535	public function bootstrap ( $ app ) { Yii :: beginProfile ( get_called_class ( ) ) ; Yii :: $ app -> modules = static :: getModules ( ) ; Yii :: $ app -> on ( \ yii \ base \ Application :: EVENT_BEFORE_REQUEST , [ $ this , 'beforeRequest' ] ) ; Yii :: endProfile ( get_called_class ( ) ) ; Yii :: trace ( "Registered " . count ( static :: getModules ( ) ) . " modules in " . get_called_class ( ) ) ; }
10572	protected function sendCacheControlHeader ( ) { if ( $ this -> sessionCacheLimiter !== null ) { if ( $ this -> sessionCacheLimiter === '' && ! headers_sent ( ) && Yii :: $ app -> getSession ( ) -> getIsActive ( ) ) { header_remove ( 'Expires' ) ; header_remove ( 'Cache-Control' ) ; header_remove ( 'Last-Modified' ) ; header_remove ( 'Pragma' ) ; } session_cache_limiter ( $ this -> sessionCacheLimiter ) ; } $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Pragma' ) ; if ( $ this -> cacheControlHeader !== null ) { $ headers -> set ( 'Cache-Control' , $ this -> cacheControlHeader ) ; } }
9717	private function writeRecalcId ( ) { $ record = 0x01C1 ; $ length = 8 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'VV' , 0x000001C1 , 0x00001E667 ) ; return $ this -> writeData ( $ header . $ data ) ; }
10864	protected function generateHashes ( ) : array { $ dirLength = strlen ( $ this -> dir ) ; foreach ( $ this -> createIterator ( ) as $ file ) { if ( ! $ file -> isFile ( ) ) { continue ; } $ realpath = $ file -> getRealPath ( ) ; $ path = $ file -> getPath ( ) . DIRECTORY_SEPARATOR . $ file -> getFilename ( ) ; if ( $ realpath !== $ path ) { continue ; } $ path = substr ( $ realpath , $ dirLength ) ; $ lowerPath = strtolower ( $ path ) ; if ( isset ( $ this -> hashes [ $ lowerPath ] ) ) { $ message = "duplicate file encountered: $path ($lowerPath)" ; throw new \ RuntimeException ( $ message ) ; } $ this -> hashes [ $ lowerPath ] = sha1_file ( $ realpath ) ; } ksort ( $ this -> hashes ) ; return $ this -> hashes ; }
9224	public function setupToken ( $ token ) { if ( ! empty ( $ token ) ) { $ this -> headers [ 'Authorization' ] = "Bearer $token" ; return true ; } else { if ( $ this -> throw_exceptions ) { throw new CanvasPest_Exception ( 'API authorization token must be a non-zero-length string' , CanvasPest_Exception :: INVALID_TOKEN ) ; } return false ; } }
4866	public function delete ( JobInterface $ job , array $ options = [ ] ) { $ result = $ this -> mongoCollection -> deleteOne ( [ '_id' => $ job -> getId ( ) ] ) ; return ( bool ) $ result -> getDeletedCount ( ) ; }
484	public function dropIndex ( $ name , $ table ) { $ time = $ this -> beginCommand ( "drop index $name on $table" ) ; $ this -> db -> createCommand ( ) -> dropIndex ( $ name , $ table ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7451	public function boot ( \ Neos \ Flow \ Core \ Bootstrap $ bootstrap ) { $ dispatcher = $ bootstrap -> getSignalSlotDispatcher ( ) ; $ dispatcher -> connect ( 'Neos\Flow\Configuration\ConfigurationManager' , 'configurationManagerReady' , function ( $ configurationManager ) { $ configurationManager -> registerConfigurationType ( 'Menus' ) ; } ) ; }
1589	protected function invoke ( string $ hook , ... $ arguments ) { if ( ! method_exists ( $ this , $ hook ) ) { return null ; } $ result = $ this -> { $ hook } ( ... $ arguments ) ; return $ this -> isInvokedResult ( $ result ) ? $ result : null ; }
10379	protected static function is_modified_file ( $ filepath ) { $ actual = filemtime ( $ filepath ) ; $ last = isset ( self :: $ files [ $ filepath ] ) ? self :: $ files [ $ filepath ] : 0 ; if ( $ actual !== $ last ) { self :: $ files [ $ filepath ] = $ actual ; self :: $ changes = true ; return self :: $ changes ; } return false ; }
6047	public function listObjectTypes ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ObjectType ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
6411	public static function any ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: any ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
6318	public function query ( $ sql ) { $ rows = array ( ) ; foreach ( $ this -> getConnection ( ) -> query ( $ sql ) as $ row ) { $ rows [ ] = $ row ; } return $ rows ; }
5305	protected function getPathPart ( SimpleXMLElement $ xmlElement , $ onlyFilled ) { $ path = '' ; if ( $ xmlElement === null ) { $ xmlElement = $ this -> xmlDocument ; } foreach ( $ xmlElement -> children ( ) as $ child ) { $ childName = $ child -> getName ( ) ; if ( ! empty ( $ child [ 'transform' ] ) ) { throw new \ Exception ( 'Transforms are currently not supported!' ) ; } if ( $ childName === 'g' ) { $ path .= ' ' . $ this -> getPathPart ( $ child , $ onlyFilled ) ; } else { if ( $ onlyFilled && ( string ) $ child [ 'fill' ] === 'none' ) { continue ; } if ( $ childName === 'polygon' ) { $ path .= ' ' . $ this -> getPathFromPolygon ( $ child ) ; } elseif ( $ childName === 'rect' ) { $ path .= ' ' . $ this -> getPathFromRect ( $ child ) ; } elseif ( $ childName === 'circle' ) { $ path .= ' ' . $ this -> getPathFromCircle ( $ child ) ; } elseif ( $ childName === 'ellipse' ) { $ path .= ' ' . $ this -> getPathFromEllipse ( $ child ) ; } elseif ( $ childName === 'path' ) { $ pathPart = trim ( $ child [ 'd' ] ) ; if ( substr ( $ pathPart , 0 , 1 ) === 'm' ) { $ pathPart = 'M' . substr ( $ pathPart , 1 ) ; } $ path .= ' ' . $ pathPart ; } } } return trim ( $ path ) ; }
8445	public function getUser ( IncomingMessage $ matchingMessage ) { $ sender_id = $ matchingMessage -> getRecipient ( ) ; $ user = Collection :: make ( $ this -> payload -> get ( 'users' ) ) -> first ( function ( $ user ) use ( $ sender_id ) { return $ user [ 'id' ] === $ sender_id ; } ) ; return new User ( $ user [ 'id' ] , null , null , $ user [ 'name' ] , $ user ) ; }
2479	protected function getSearchFields ( Criterion $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier = null , $ name = null ) { return $ this -> fieldNameResolver -> getFieldTypes ( $ criterion , $ fieldDefinitionIdentifier , $ fieldTypeIdentifier , $ name ) ; }
1724	public static function generateRandomSecret ( Event $ event ) : void { $ extra = $ event -> getComposer ( ) -> getPackage ( ) -> getExtra ( ) ; if ( ! isset ( $ extra [ 'incenteev-parameters' ] ) || ! self :: canGenerateSecret ( $ extra [ 'incenteev-parameters' ] ) ) { return ; } if ( ! \ function_exists ( 'random_bytes' ) ) { self :: loadRandomCompat ( $ event ) ; } putenv ( static :: RANDOM_SECRET_NAME . '=' . bin2hex ( random_bytes ( 32 ) ) ) ; }
4405	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ configResolver = $ this -> container -> get ( 'ezpublish.config.resolver' ) ; $ kernelRootDir = $ this -> container -> getParameter ( 'kernel.root_dir' ) ; $ siteAccessGroup = $ input -> getOption ( 'site-access-group' ) ; $ varDir = $ configResolver -> getParameter ( 'var_dir' , null , $ siteAccessGroup ) ; $ repository = $ configResolver -> getParameter ( 'repository' , null , $ siteAccessGroup ) ; $ configFile = $ kernelRootDir . '/config/ngadminui.yml' ; if ( $ fileSystem -> exists ( $ configFile ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>ngadminui.yml</comment> configuration file already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ languages = $ languageService -> loadLanguages ( ) ; $ settings = array ( 'parameters' => array ( 'netgen_admin_ui.' . $ siteAccessName . '.is_admin_ui_siteaccess' => true , 'eztags.' . $ siteAccessName . '.routing.enable_tag_router' => false , 'ezsettings.' . $ siteAccessName . '.treemenu.http_cache' => false , ) , 'ezpublish' => array ( 'siteaccess' => array ( 'list' => array ( $ siteAccessName , ) , 'groups' => array ( 'ngadminui' => array ( $ siteAccessName , ) , ) , 'match' => array ( 'Map\URI' => array ( $ siteAccessName => $ siteAccessName , ) , ) , ) , 'system' => array ( $ siteAccessName => array ( 'user' => array ( 'layout' => '@NetgenAdminUI/pagelayout_login.html.twig' , 'login_template' => '@NetgenAdminUI/user/login.html.twig' , ) , 'languages' => array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languages ) , 'var_dir' => $ varDir , 'repository' => $ repository , ) , ) , ) , 'ez_publish_legacy' => array ( 'system' => array ( $ siteAccessName => array ( 'templating' => array ( 'view_layout' => '@NetgenAdminUI/pagelayout_legacy.html.twig' , 'module_layout' => '@NetgenAdminUI/pagelayout_module.html.twig' , ) , ) , ) , ) , ) ; file_put_contents ( $ configFile , Yaml :: dump ( $ settings , 7 ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>ngadminui.yml</comment> configuration file!' , '' , ) ) ; }
4294	public static function getType ( $ val , & $ typeMore = null ) { if ( \ is_string ( $ val ) ) { $ type = 'string' ; if ( \ is_numeric ( $ val ) ) { $ typeMore = 'numeric' ; } elseif ( $ val === self :: UNDEFINED ) { $ type = 'undefined' ; } elseif ( $ val === self :: RECURSION ) { $ type = 'recursion' ; } } elseif ( \ is_array ( $ val ) ) { if ( \ in_array ( self :: ABSTRACTION , $ val , true ) ) { $ type = $ val [ 'type' ] ; $ typeMore = 'abstraction' ; } elseif ( AbstractArray :: isCallable ( $ val ) ) { $ type = 'callable' ; $ typeMore = 'raw' ; } else { $ type = 'array' ; $ typeMore = 'raw' ; } } elseif ( \ is_bool ( $ val ) ) { $ type = 'bool' ; $ typeMore = \ json_encode ( $ val ) ; } elseif ( \ is_float ( $ val ) ) { $ type = 'float' ; } elseif ( \ is_int ( $ val ) ) { $ type = 'int' ; } elseif ( \ is_null ( $ val ) ) { $ type = 'null' ; } elseif ( \ is_object ( $ val ) ) { $ type = 'object' ; $ typeMore = 'raw' ; } elseif ( \ is_resource ( $ val ) || \ strpos ( \ print_r ( $ val , true ) , 'Resource' ) === 0 ) { $ type = 'resource' ; $ typeMore = 'raw' ; } return $ type ; }
1464	private function guessKey ( ) { if ( $ this -> query instanceof EloquentBuilder || $ this -> query instanceof Relation ) { return $ this -> query -> getModel ( ) -> getRouteKeyName ( ) ; } return 'id' ; }
5212	public function getConstant ( $ name ) { return $ this -> getBinding ( ConstantBinding :: TYPE , $ name ) -> getInstance ( $ this , $ name ) ; }
1611	private function _createDocument ( $ withUrlSet = true ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) $ document -> formatOutput = true ; if ( $ withUrlSet ) { $ urlSet = $ document -> createElement ( 'urlset' ) ; $ urlSet -> setAttribute ( 'xmlns' , 'http://www.sitemaps.org/schemas/sitemap/0.9' ) ; $ urlSet -> setAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ document -> appendChild ( $ urlSet ) ; $ this -> _urlSet = $ urlSet ; } $ this -> _document = $ document ; }
1424	protected function load ( $ record , EncodingParametersInterface $ parameters ) { $ relationshipPaths = $ this -> getRelationshipPaths ( $ parameters -> getIncludePaths ( ) ) ; $ record -> loadMissing ( $ relationshipPaths ) ; }
4149	protected function buildMultipart ( $ mimeBoundary , $ filename ) { $ binary = $ this -> getBinaryFile ( $ filename ) ; $ details = pathinfo ( $ filename ) ; $ type = $ this -> supportedMimes ( $ details [ 'extension' ] ) ; $ data = '--' . $ mimeBoundary . static :: EOL ; $ data .= 'Content-Disposition: form-data; name="media"; filename="' . $ details [ 'basename' ] . '"' . static :: EOL ; $ data .= 'Content-Type: application/octet-stream' . static :: EOL . static :: EOL ; $ data .= $ binary . static :: EOL ; $ data .= '--' . $ mimeBoundary . '--' . static :: EOL . static :: EOL ; unset ( $ mimeBoundary , $ filename , $ binary , $ details , $ type ) ; return $ data ; }
1336	protected function queryAllOrOne ( $ query , EncodingParametersInterface $ parameters ) { $ filters = collect ( $ parameters -> getFilteringParameters ( ) ) ; if ( $ this -> isSearchOne ( $ filters ) ) { return $ this -> queryOne ( $ query , $ parameters ) ; } return $ this -> queryAll ( $ query , $ parameters ) ; }
388	public function getAttributeOrder ( $ attribute ) { $ orders = $ this -> getAttributeOrders ( ) ; return isset ( $ orders [ $ attribute ] ) ? $ orders [ $ attribute ] : null ; }
8326	public function sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ this -> getLogger ( ) -> info ( "Try send google key (recaptcha) on {$this->serverBaseUri}/in.php" ) ; if ( $ this -> softId && ! isset ( $ extra [ Extra :: SOFT_ID ] ) ) { $ extra [ Extra :: SOFT_ID ] = $ this -> softId ; } $ response = $ this -> getHttpClient ( ) -> request ( 'POST' , "/in.php" , [ RequestOptions :: QUERY => array_merge ( $ extra , [ 'method' => 'userrecaptcha' , 'key' => $ this -> apiKey , 'googlekey' => $ googleKey , 'pageurl' => $ pageUrl ] ) ] ) ; $ responseText = $ response -> getBody ( ) -> __toString ( ) ; if ( strpos ( $ responseText , 'OK|' ) !== false ) { $ this -> lastCaptchaId = explode ( "|" , $ responseText ) [ 1 ] ; $ this -> getLogger ( ) -> info ( "Sending success. Got captcha id `{$this->lastCaptchaId}`." ) ; return $ this -> lastCaptchaId ; } throw new ErrorResponseException ( $ this -> getErrorMessage ( $ responseText ) ? : "Unknown error: `{$responseText}`." ) ; }
10930	public function countRowsFrom ( string $ tableName , string $ pkName ) : int { $ strSQL = "SELECT COUNT($pkName) as count FROM $tableName;" ; return $ this -> getCountOf ( $ strSQL ) ; }
2560	private function checkAndCreateMopDetailedData ( $ fopType ) { if ( is_null ( $ this -> paymentModule -> mopDetailedData ) ) { $ this -> paymentModule -> mopDetailedData = new MopDetailedData ( $ fopType ) ; } }
11822	public function render_admin_header ( ) { $ page = filter_input ( INPUT_GET , 'page' ) ; if ( $ this -> page != $ page ) { return ; } echo '<style type="text/css">' ; echo $ this -> twig -> render ( 'list_table.css.twig' , array ( ) ) ; echo '</style>' ; }
11576	public function actionConnect ( $ account_id ) { $ account = $ this -> finder -> findAccountById ( $ account_id ) ; if ( $ account === null || $ account -> getIsConnected ( ) ) { throw new NotFoundHttpException ; } $ user = \ Yii :: createObject ( [ 'class' => User :: className ( ) , 'scenario' => 'connect' ] ) ; if ( $ user -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ user -> create ( ) ) { $ account -> user_id = $ user -> id ; $ account -> save ( false ) ; \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; return $ this -> goBack ( ) ; } return $ this -> render ( 'connect' , [ 'model' => $ user , 'account' => $ account ] ) ; }
12884	public function getKeyTranslation ( Model $ foreignObject , $ key = null ) { if ( isset ( $ key ) ) { return $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; } foreach ( $ this -> keys as $ keyName => $ keyField ) { if ( ! empty ( $ foreignObject -> { $ keyField } ) ) { $ key = $ this -> generateKey ( $ foreignObject , $ keyName , $ foreignObject -> { $ keyField } ) ; $ result = $ this -> internalGetKeyTranslation ( $ foreignObject , $ key ) ; if ( ! empty ( $ result ) ) { return $ result ; } } } return false ; }
6953	private function resolvePrice ( array $ entry , $ weight ) { $ price = $ count = 0 ; if ( $ weight > $ entry [ 'max_weight' ] ) { $ count = floor ( $ weight / $ entry [ 'max_weight' ] ) ; $ weight = round ( fmod ( $ weight , $ count ) , 3 ) ; } if ( 0 < $ count ) { $ max = end ( $ entry [ 'prices' ] ) [ 'price' ] ; $ price = $ count * $ max ; } foreach ( $ entry [ 'prices' ] as $ p ) { if ( 1 === bccomp ( $ p [ 'weight' ] , $ weight , 3 ) ) { $ price += $ p [ 'price' ] ; break ; } } return $ price ; }
10899	public function save ( bool $ validate = true ) : self { if ( $ validate && $ this -> validate ( ) ) { throw new Exception ( 'Entity ' . $ this -> __getEntityName ( ) . ' data is not valid' ) ; } $ scheme = \ array_keys ( $ this -> getScheme ( ) ) ; foreach ( $ this -> data as $ key => $ value ) { if ( ! \ in_array ( $ key , $ scheme , true ) ) { unset ( $ this -> data [ $ key ] ) ; } } if ( $ this -> getId ( ) ) { $ this -> medoo -> update ( $ this -> getTable ( ) , $ this -> data , [ 'id' => $ this -> getId ( ) ] ) ; } else { $ this -> medoo -> insert ( $ this -> getTable ( ) , $ this -> data ) ; $ this -> setId ( $ this -> medoo -> id ( ) ) ; } $ this -> sentry -> breadcrumbs -> record ( [ 'message' => 'Entity ' . $ this -> __getEntityName ( ) . '::save()' , 'data' => [ 'query' => $ this -> medoo -> last ( ) ] , 'category' => 'Database' , 'level' => 'info' , ] ) ; return $ this ; }
63	public function rmdir ( $ path ) { $ deleted = @ rmdir ( $ path ) ; if ( ! $ deleted ) { if ( Platform :: isWindows ( ) ) { usleep ( 350000 ) ; $ deleted = @ rmdir ( $ path ) ; } if ( ! $ deleted ) { $ error = error_get_last ( ) ; $ message = 'Could not delete ' . $ path . ': ' . @ $ error [ 'message' ] ; if ( Platform :: isWindows ( ) ) { $ message .= "\nThis can be due to an antivirus or the Windows Search Indexer locking the file while they are analyzed" ; } throw new \ RuntimeException ( $ message ) ; } } return true ; }
9309	public function show ( $ id , $ params = [ ] ) { $ data = [ 'id' => $ id ] + $ params ; return $ this -> query ( __FUNCTION__ , $ data ) ; }
10685	public function get ( $ parameter ) { switch ( $ parameter ) { case "dev" : return $ this -> dev ?? true ; case "config" : return $ this -> config ; case "injector" : return $ this -> injector ; case "pathConfig" : return $ this -> path_config ; case "request" : return $ this -> request ; case "resolver" : return $ this -> resolver ; case "moduleManager" : return $ this -> module_manager ; case "auth" : return $ this -> injector -> getInstance ( Authentication :: class ) ; case "db" : return $ this -> injector -> getInstance ( DB :: class ) ; case "dispatcher" : return $ this -> injector -> getInstance ( Dispatcher :: class ) ; case "template" : return $ this -> injector -> getInstance ( Template :: class ) ; case "mailer" : return $ this -> injector -> getInstance ( SMTPSender :: class ) ; case "i18n" : return $ this -> injector -> getInstance ( I18n :: class ) ; case "processChain" : return $ this -> injector -> getInstance ( ProcessChain :: class ) ; } throw new InvalidArgumentException ( "No such object: $parameter" ) ; }
4225	public function onShutdown ( Event $ event ) { if ( ! $ this -> registered ) { return ; } $ error = $ event [ 'error' ] ? : \ error_get_last ( ) ; if ( ! $ error ) { return ; } if ( \ in_array ( $ error [ 'type' ] , $ this -> errCategories [ 'fatal' ] ) ) { \ error_reporting ( E_ALL | E_STRICT ) ; $ this -> handleError ( $ error [ 'type' ] , $ error [ 'message' ] , $ error [ 'file' ] , $ error [ 'line' ] ) ; } foreach ( $ this -> data [ 'errors' ] as $ error ) { if ( $ error [ 'category' ] === 'fatal' ) { $ event [ 'error' ] = $ error ; break ; } } return ; }
7157	private function setSubjectState ( StockSubjectInterface $ subject , $ state ) { if ( $ subject -> getStockState ( ) != $ state ) { $ subject -> setStockState ( $ state ) ; return true ; } return false ; }
2716	public function addTextInput ( $ id , $ label , $ comment , $ required = true ) { $ this -> children [ $ id ] = [ 'id' => $ id , 'type' => 'text' , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => count ( $ this -> children ) , 'label' => $ label , 'comment' => $ comment , 'validate' => ( $ required == true ) ? 'required-entry' : '' , '_elementType' => 'field' , 'path' => self :: BASE_CONFIG_PATH . '/' . $ this -> id ] ; }
373	public function getOptionValues ( $ actionID ) { $ properties = [ ] ; foreach ( $ this -> options ( $ this -> action -> id ) as $ property ) { $ properties [ $ property ] = $ this -> $ property ; } return $ properties ; }
8018	public function getUrl ( $ name , $ expires = NULL ) { return $ this -> getClient ( ) -> getObjectUrl ( $ this -> bucket , $ name , $ expires ) ; }
10964	public static function getHost ( ) { $ host = null ; if ( isset ( $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_X_FORWARDED_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ host = $ _SERVER [ 'HTTP_HOST' ] ; } elseif ( isset ( $ _SERVER [ 'SERVER_NAME' ] ) ) { $ host = $ _SERVER [ 'SERVER_NAME' ] ; } else { $ host = gethostname ( ) ; } return $ host ; }
1973	public static function findMultipleByPaths ( $ arrPaths , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPaths ) || ! \ is_array ( $ arrPaths ) ) { return null ; } $ t = static :: $ strTable ; if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.path" , $ arrPaths ) ; } return static :: findBy ( array ( "$t.path IN(" . implode ( ',' , array_fill ( 0 , \ count ( $ arrPaths ) , '?' ) ) . ")" ) , $ arrPaths , $ arrOptions ) ; }
2937	public function restore ( $ filePath = null ) { if ( is_null ( $ filePath ) ) { $ latestBackup = $ this -> getLatestBackup ( ) ; if ( is_null ( $ latestBackup ) ) { throw new NoBackupAvailableException ( "There are no available backups!" ) ; } $ filePath = $ latestBackup [ 'filepath' ] ; } if ( ! is_file ( $ filePath ) ) { throw new FileNotFoundException ( "File does not exist at path {$filePath}" ) ; } copy ( $ filePath , $ this -> filePath ) ; $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; }
8535	public function setId ( $ id ) { if ( ! $ this -> isNumericArray ( $ id ) ) { $ id = array ( $ id ) ; } $ this -> fields [ 'Id' ] [ 'FieldValue' ] = $ id ; return $ this ; }
1188	public function validatorClosure ( ) { return function ( $ attribute , $ value , $ parameters , BaseValidator $ validator ) { $ remoteValidator = new Validator ( $ validator ) ; $ remoteValidator -> validate ( $ value , $ parameters ) ; return $ attribute ; } ; }
11033	public function init ( ) { $ this -> _file = \ Yii :: getAlias ( $ this -> path . '/config/' . self :: FILENAME ) ; $ this -> loadFromFile ( ) ; }
11770	public function switchTo ( NodeConnectionInterface $ connection ) { if ( $ connection && $ connection === $ this -> current ) { return ; } if ( $ connection !== $ this -> master && ! in_array ( $ connection , $ this -> slaves , true ) ) { throw new \ InvalidArgumentException ( 'Invalid connection or connection not found.' ) ; } $ connection -> connect ( ) ; if ( $ this -> current ) { $ this -> current -> disconnect ( ) ; } $ this -> current = $ connection ; }
5619	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; $ msg = '<span class="fail">Fail</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; $ msg .= implode ( '-&gt;' , $ breadcrumb ) ; $ msg .= '-&gt;' . htmlentities ( $ message ) . '<br />' ; echo "add_fail('$msg');\n" ; }
5623	protected function parseRequest ( $ raw ) { $ this -> raw = $ raw ; $ request = new SimpleGetEncoding ( ) ; foreach ( explode ( '&' , $ raw ) as $ pair ) { if ( preg_match ( '/(.*?)=(.*)/' , $ pair , $ matches ) ) { $ request -> add ( urldecode ( $ matches [ 1 ] ) , urldecode ( $ matches [ 2 ] ) ) ; } elseif ( $ pair ) { $ request -> add ( urldecode ( $ pair ) , '' ) ; } } return $ request ; }
10717	public function newModel ( ) { $ model = app ( ) -> make ( $ this -> modelClass ) ; if ( ! $ model instanceof Model ) { throw new RepositoryException ( "Class {$this->modelClass} must be an instance of Illuminate\\Database\\Eloquent\\Model" ) ; } return $ model ; }
12098	public function niceDate ( \ DateTime $ date ) { $ now = $ this -> system -> getDate ( ) ; if ( $ now -> format ( 'Y-m-d' ) === $ date -> format ( 'Y-m-d' ) ) { return $ date -> format ( 'H:i' ) ; } elseif ( $ now -> format ( 'Y-m' ) === $ date -> format ( 'Y-m' ) && $ date -> format ( 'd' ) + 1 == $ now -> format ( 'd' ) ) { return sprintf ( $ this -> translate ( 'yesterday, %s' ) , $ date -> format ( 'H:i' ) ) ; } return $ date -> format ( 'd-m-Y' ) ; }
11823	public function replace ( $ middleware , $ with ) { $ this -> pipeline = $ this -> pipeline -> replace ( $ middleware , $ with ) ; return $ this ; }
3999	protected function getCount ( $ strType , $ intID ) { switch ( $ strType ) { case 'mod' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_module' , $ intID ) ; break ; case 'ce' : $ objMetaModelResult = $ this -> getMetaModelDataFrom ( 'tl_content' , $ intID ) ; break ; default : return false ; } if ( $ objMetaModelResult != null ) { return $ this -> getCountFor ( $ objMetaModelResult -> metamodel , $ objMetaModelResult -> metamodel_filtering ) ; } return false ; }
12836	public function makeDirectory ( $ path , $ mode = 0755 , $ recursive = false ) { if ( ! file_exists ( $ path ) ) { return mkdir ( $ path , $ mode , $ recursive ) ; } return true ; }
8199	public function expect ( $ type , $ value = null , $ message = null ) { $ token = $ this -> tokens [ $ this -> current ] ; if ( ! $ token -> test ( $ type , $ value ) ) { $ line = $ token -> getLine ( ) ; throw new Twig_Error_Syntax ( sprintf ( '%sUnexpected token "%s" of value "%s" ("%s" expected%s).' , $ message ? $ message . '. ' : '' , Twig_Token :: typeToEnglish ( $ token -> getType ( ) ) , $ token -> getValue ( ) , Twig_Token :: typeToEnglish ( $ type ) , $ value ? sprintf ( ' with value "%s"' , $ value ) : '' ) , $ line , $ this -> source ) ; } $ this -> next ( ) ; return $ token ; }
8165	public function compile ( Twig_NodeInterface $ node , $ indentation = 0 ) { $ this -> lastLine = null ; $ this -> source = '' ; $ this -> debugInfo = array ( ) ; $ this -> sourceOffset = 0 ; $ this -> sourceLine = 1 ; $ this -> indentation = $ indentation ; $ this -> varNameSalt = 0 ; if ( $ node instanceof Twig_Node_Module ) { $ this -> filename = $ node -> getTemplateName ( ) ; } $ node -> compile ( $ this ) ; return $ this ; }
6993	static protected function getCacheKeyForOptimizedUiTemplatesBasedOnUserRole ( $ group ) : string { if ( static :: getAuthModule ( ) -> getAccessPolicyClassName ( ) === CmfAccessPolicy :: class ) { $ userId = 'any' ; } else { $ userId = 'not_authenticated' ; $ user = static :: getUser ( ) ; if ( $ user && $ user -> existsInDb ( ) ) { if ( $ user :: hasColumn ( 'is_superadmin' ) ) { $ userId = '__superadmin__' ; } else if ( $ user :: hasColumn ( 'role' ) ) { $ userId = $ user -> role ; } else { $ userId = 'user' ; } } } return static :: url_prefix ( ) . '_templates_' . static :: getShortLocale ( ) . '_' . $ group . '_user_' . $ userId ; }
11499	public static function bulkInsert ( array $ batch ) { $ table = new static ( ) ; if ( 1 === sizeof ( $ batch ) ) { return $ table -> insert ( array_shift ( $ batch ) ) ; } $ adapter = $ table -> getAdapter ( ) ; $ counter = 0 ; $ sqlBinds = [ ] ; $ values = [ ] ; foreach ( $ batch as $ i => $ row ) { $ placeholders = [ ] ; foreach ( $ row as $ column => $ value ) { ++ $ counter ; if ( $ adapter -> supportsParameters ( 'positional' ) ) { $ placeholders [ ] = '?' ; $ values [ ] = $ value ; } elseif ( $ adapter -> supportsParameters ( 'named' ) ) { $ name = ":col{$i}{$counter}" ; $ placeholders [ ] = $ name ; $ values [ $ name ] = $ value ; } else { throw new Zend_Db_Adapter_Exception ( sprintf ( '%s doesn\'t support positional or named binding' , get_class ( $ table ) ) ) ; } } $ sqlBinds [ ] = '(' . implode ( ',' , $ placeholders ) . ')' ; } $ columns = array_keys ( $ row ) ; array_walk ( $ columns , function ( & $ index ) use ( $ adapter ) { $ index = $ adapter -> quoteIdentifier ( $ index , true ) ; } ) ; $ spec = $ adapter -> quoteIdentifier ( ( $ table -> _schema ? "{$table->_schema}." : '' ) . $ table -> _name ) ; $ sql = sprintf ( 'INSERT INTO %s (%s) VALUES %s' , $ spec , implode ( ',' , $ columns ) , implode ( ',' , $ sqlBinds ) ) ; $ stmt = $ adapter -> prepare ( $ sql ) ; $ stmt -> execute ( $ values ) ; return $ stmt -> rowCount ( ) ; }
8362	public static function registerTranslations ( $ baseDir , $ localesDir , $ prefix = null ) { if ( self :: $ isInit === true ) { $ dir = $ baseDir . DIRECTORY_SEPARATOR . $ localesDir ; if ( is_dir ( $ dir ) === false ) { throw new InvalidDirectory ( 'directory "' . $ dir . '" can\'t be identified' ) ; } $ language = self :: $ currentLanguage ; if ( ( $ pos = strpos ( $ language , '-' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( ( $ pos = strpos ( $ language , '_' ) ) !== false ) { $ pos = ( int ) $ pos ; $ language = substr ( $ language , 0 , $ pos ) ; } if ( is_readable ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) === true ) { $ newOnes = Config :: get ( $ dir . DIRECTORY_SEPARATOR . $ language . '.yml' ) ; if ( is_array ( $ newOnes ) === true ) { if ( $ prefix != null ) { $ newOnes = array ( $ prefix => $ newOnes ) ; } self :: $ translations = array_merge ( self :: $ translations , $ newOnes ) ; } } else { Logger :: get ( ) -> notice ( 'can\'t find language "' . $ language . '" in directory "' . $ dir . '"' ) ; } } }
8008	public static function forStringAndEncodings ( $ string , $ from_encoding , $ to_encoding , $ code = self :: CODE_FOR_STRING_AND_ENCODING_INFO , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . sprintf ( self :: MESSAGE_EXTENSION_FOR_STRING_FORMAT , $ string ) . sprintf ( self :: MESSAGE_EXTENSION_FOR_ENCODING_INFO_FORMAT , $ from_encoding , $ to_encoding ) ; return new static ( $ message , $ code , $ previous ) ; }
4344	protected function pushStack ( $ funcName ) { $ this -> funcStack [ ] = array ( 'function' => $ funcName , 'tsStart' => $ this -> timeLastTick , 'subTime' => 0 , ) ; if ( ! isset ( $ this -> data [ $ funcName ] ) ) { $ this -> data [ $ funcName ] = array ( 'calls' => 0 , 'totalTime' => 0 , 'ownTime' => 0 , ) ; } $ this -> data [ $ funcName ] [ 'calls' ] ++ ; }
8989	public function getTemplate ( $ data_type , $ type ) { $ options = ( array ) $ this -> config -> getType ( $ data_type , $ type ) ; return new UI \ Template ( $ data_type , $ type , $ options ) ; }
7810	public function getPackageVersion ( ) { $ package_config = file_get_contents ( dirname ( __FILE__ ) . "./../composer.json" ) ; if ( $ package_config ) { $ package_config_object = json_decode ( $ package_config ) ; if ( is_object ( $ package_config_object ) && isset ( $ package_config_object -> version ) ) { return $ package_config_object -> version ; } } return null ; }
11486	protected function resolveNonClassArg ( ReflectionParameter $ param , array $ params , ReflectionFunctionAbstract $ func ) { $ name = '$' . $ param -> getName ( ) ; if ( $ params && array_key_exists ( $ name , $ params ) ) { $ argument = $ params [ $ name ] ; if ( is_array ( $ argument ) && isset ( $ this -> factories [ $ argument [ 0 ] ] ) ) { $ argument = $ this -> callFactory ( $ argument [ 0 ] , $ argument [ 1 ] ) ; } return $ argument ; } if ( $ param -> isDefaultValueAvailable ( ) ) { return $ param -> getDefaultValue ( ) ; } throw Exception \ UnresolvableArgumentException :: fromReflectionParam ( $ param , $ func ) ; }
3873	private function getBaseUrl ( $ pageDetails , $ path = null , $ ignoreSSL = false ) { $ url = new UrlBuilder ( ) ; if ( $ pageDetails [ 'domain' ] ) { $ url -> setHost ( $ pageDetails [ 'domain' ] ) ; } else { $ url -> setHost ( \ Environment :: get ( 'host' ) ) ; } if ( $ pageDetails [ 'rootUseSSL' ] && ! $ ignoreSSL ) { $ url -> setScheme ( 'https' ) ; } else { $ url -> setScheme ( 'http' ) ; } $ fullPath = array ( ) ; $ fullPath [ ] = TL_PATH ; if ( $ path === null ) { $ event = new GenerateFrontendUrlEvent ( $ pageDetails , null , $ pageDetails [ 'language' ] , true ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GENERATE_FRONTEND_URL , $ event ) ; $ fullPath [ ] = $ event -> getUrl ( ) ; } else { $ fullPath [ ] = $ path ; } $ url -> setPath ( implode ( '/' , $ fullPath ) ) ; return $ url ; }
3954	public function getVariants ( $ objFilter ) { if ( $ this -> isVariantBase ( ) ) { return $ this -> getMetaModel ( ) -> findVariants ( array ( $ this -> get ( 'id' ) ) , $ objFilter ) ; } return null ; }
1674	public function synchronize ( ) { if ( ! $ this -> isUnsynchronized ( ) ) { return ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFolder . '/.nosync' ) ) { throw new \ RuntimeException ( sprintf ( 'Cannot synchronize the folder "%s" because one of its parent folders is unsynchronized' , $ this -> strFolder ) ) ; } ( new File ( $ this -> strFolder . '/.nosync' ) ) -> delete ( ) ; }
8238	protected function outputModulesConfiguration ( ParameterBag $ post ) { $ modulesClasses = array ( ) ; $ modulesNames = array ( ) ; foreach ( $ this -> modules as $ key => $ value ) { if ( $ post -> has ( $ key ) ) { $ modulesClasses [ ] = $ value ; $ modulesNames [ ] = $ key ; } } $ config = array ( self :: CONFIG_PLUGIN_KEY => array ( self :: CONFIG_MODULES_KEY => $ modulesClasses ) ) ; $ yaml = \ Symfony \ Component \ Yaml \ Yaml :: dump ( $ config , 2 , 4 ) ; $ this -> picoAuth -> addOutput ( "installer_modules_config" , $ yaml ) ; $ this -> picoAuth -> addOutput ( "installer_modules_names" , $ modulesNames ) ; }
9894	public function add ( $ item ) { if ( $ item instanceof ShippingMethodInterface ) { $ this -> items [ ] = $ item ; } else { $ this -> items [ ] = new Item ( $ item ) ; } }
7398	public function setStatusCode ( int $ statusCode , string $ version = '1.1' , string $ statusText = '' ) : bool { if ( ! headers_sent ( ) ) { $ statusCode = intval ( $ statusCode ) ; if ( '' == $ statusText ) { $ statusTexts = [ 100 => 'Continue' , 101 => 'Switching Protocols' , 102 => 'Processing' , 200 => 'OK' , 201 => 'Created' , 202 => 'Accepted' , 203 => 'Non-Authoritative Information' , 204 => 'No Content' , 205 => 'Reset Content' , 206 => 'Partial Content' , 207 => 'Multi-Status' , 208 => 'Already Reported' , 226 => 'IM Used' , 300 => 'Multiple Choices' , 301 => 'Moved Permanently' , 302 => 'Found' , 303 => 'See Other' , 304 => 'Not Modified' , 305 => 'Use Proxy' , 307 => 'Temporary Redirect' , 308 => 'Permanent Redirect' , 400 => 'Bad Request' , 401 => 'Unauthorized' , 402 => 'Payment Required' , 403 => 'Forbidden' , 404 => 'Not Found' , 405 => 'Method Not Allowed' , 406 => 'Not Acceptable' , 407 => 'Proxy Authentication Required' , 408 => 'Request Timeout' , 409 => 'Conflict' , 410 => 'Gone' , 411 => 'Length Required' , 412 => 'Precondition Failed' , 413 => 'Payload Too Large' , 414 => 'URI Too Long' , 415 => 'Unsupported Media Type' , 416 => 'Range Not Satisfiable' , 417 => 'Expectation Failed' , 418 => 'I\'m a teapot' , 422 => 'Unprocessable Entity' , 423 => 'Locked' , 424 => 'Failed Dependency' , 425 => 'Reserved for WebDAV advanced collections expired proposal' , 426 => 'Upgrade Required' , 428 => 'Precondition Required' , 429 => 'Too Many Requests' , 431 => 'Request Header Fields Too Large' , 500 => 'Internal Server Error' , 501 => 'Not Implemented' , 502 => 'Bad Gateway' , 503 => 'Service Unavailable' , 504 => 'Gateway Timeout' , 505 => 'HTTP Version Not Supported' , 506 => 'Variant Also Negotiates (Experimental)' , 507 => 'Insufficient Storage' , 508 => 'Loop Detected' , 510 => 'Not Extended' , 511 => 'Network Authentication Required' , ] ; $ statusText = $ statusTexts [ $ statusCode ] ; } header ( sprintf ( 'HTTP/%s %s %s' , $ version , $ statusCode , $ statusText ) , true , $ statusCode ) ; return true ; } return false ; }
8102	public function getStatement ( $ sql , $ args = false ) { $ query = $ this -> buildQuery ( $ sql , $ args ) ; if ( $ connection = $ this -> db -> getConnection ( ) ) { if ( $ stmt = $ connection -> prepare ( $ query ) ) { $ this -> log -> report ( "SQL Statement: {$query}" ) ; $ stmt -> setFetchMode ( \ PDO :: FETCH_INTO , new Collection ( ) ) ; if ( $ args ) { $ this -> log -> report ( "SQL Data Sent: [" . implode ( ', ' , $ args ) . "]" ) ; $ stmt -> execute ( $ args ) ; } if ( $ stmt -> errorCode ( ) > 0 ) { $ error = $ stmt -> errorInfo ( ) ; $ this -> log -> error ( "PDO({$error[0]})[{$error[1]}] {$error[2]}" ) ; return false ; } return $ stmt ; } else { $ this -> log -> error ( 'Failed to create a PDO statement with: ' . $ query ) ; return false ; } } else { return false ; } }
5962	public function serverGroupPermList ( $ sgid , $ permsid = false ) { return $ this -> execute ( "servergrouppermlist" , array ( "sgid" => $ sgid , $ permsid ? "-permsid" : null ) ) -> toAssocArray ( $ permsid ? "permsid" : "permid" ) ; }
2091	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ objTemplate = new BackendTemplate ( 'be_wildcard' ) ; $ objTemplate -> wildcard = '### ' . Utf8 :: strtoupper ( $ GLOBALS [ 'TL_LANG' ] [ 'CTE' ] [ 'form' ] [ 0 ] ) . ' ###' ; $ objTemplate -> id = $ this -> id ; $ objTemplate -> link = $ this -> title ; $ objTemplate -> href = 'contao/main.php?do=form&amp;table=tl_form_field&amp;id=' . $ this -> id ; return $ objTemplate -> parse ( ) ; } if ( $ this -> customTpl != '' && TL_MODE == 'FE' ) { $ this -> strTemplate = $ this -> customTpl ; } return parent :: generate ( ) ; }
1187	protected function createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) { if ( is_null ( $ this -> resolver ) ) { return new BaseValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; } return call_user_func ( $ this -> resolver , $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; }
1676	public function getModel ( ) { if ( $ this -> objModel === null && Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { $ this -> objModel = FilesModel :: findByPath ( $ this -> strFolder ) ; } return $ this -> objModel ; }
7345	public function modifySubmitedValueBeforeValidation ( $ value , array $ data ) { if ( $ this -> hasSubmittedValueModifier ( ) ) { return call_user_func ( $ this -> getSubmittedValueModifier ( ) , $ value , $ data ) ; } else { return $ value ; } }
11989	public function sort ( $ entityName , $ values ) { $ values = json_decode ( $ values ) ; for ( $ i = 0 ; $ i < count ( $ values ) ; $ i ++ ) { $ this -> entityManager -> getRepository ( $ entityName ) -> createQueryBuilder ( 'e' ) -> update ( ) -> set ( 'e.order' , $ i ) -> where ( 'e.id = :id' ) -> setParameter ( 'id' , $ values [ $ i ] -> id ) -> getQuery ( ) -> execute ( ) ; } }
3132	public function init ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; if ( $ session -> getState ( ) === AssessmentTestSessionState :: INITIAL ) { $ session -> beginTestSession ( ) ; $ event = new TestInitEvent ( $ session ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; \ common_Logger :: i ( "Assessment Test Session begun." ) ; if ( $ context -> isAdaptive ( ) ) { \ common_Logger :: t ( "Very first item is adaptive." ) ; $ nextCatItemId = $ context -> selectAdaptiveNextItem ( ) ; $ context -> persistCurrentCatItemId ( $ nextCatItemId ) ; $ context -> persistSeenCatItemIds ( $ nextCatItemId ) ; } } elseif ( $ session -> getState ( ) === AssessmentTestSessionState :: SUSPENDED ) { $ session -> resume ( ) ; } $ session -> initItemTimer ( ) ; if ( $ session -> isTimeout ( ) === false ) { TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; } $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> clearEvents ( $ session -> getSessionId ( ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'init' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
8424	public function generate ( Request $ request ) { if ( count ( $ request -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/generate mapping_name' . PHP_EOL ; } else { $ mapping = $ request -> getArgs ( ) [ 0 ] ; $ schema = Schema :: getSchema ( $ mapping ) ; $ schema -> generateModels ( ) ; } }
1921	private function getIndexLength ( Table $ table , string $ column ) : ? int { $ col = $ table -> getColumn ( $ column ) ; if ( null === ( $ length = $ col -> getLength ( ) ) ) { return null ; } if ( $ length <= 191 ) { return null ; } if ( $ col -> hasPlatformOption ( 'collation' ) ) { $ collation = $ col -> getPlatformOption ( 'collation' ) ; } else { $ collation = $ table -> getOption ( 'collate' ) ; } $ defaultLength = $ this -> getDefaultIndexLength ( $ table ) ; $ bytes = 0 === strncmp ( $ collation , 'utf8mb4' , 7 ) ? 4 : 3 ; $ indexLength = ( int ) floor ( $ defaultLength / $ bytes ) ; if ( $ length <= $ indexLength ) { return null ; } return $ indexLength ; }
4975	private function findOrCreateChild ( $ tree , $ id ) { foreach ( $ tree -> getChildren ( ) as $ node ) { if ( $ id && $ node -> getId ( ) == $ id ) { return $ node ; } } $ nodeClass = get_class ( $ tree ) ; $ node = new $ nodeClass ( ) ; $ tree -> addChild ( $ node ) ; return $ node ; }
11937	protected function find ( $ params ) { $ debug = false ; $ q = new Query ( ) ; $ q -> select ( '*' ) ; $ q -> from ( $ this -> _tableName ) ; foreach ( $ params as $ k => $ v ) { if ( $ k === 'join' ) { foreach ( $ v as $ join ) { if ( ! isset ( $ join [ 'type' ] ) ) { $ join [ 'type' ] = 'INNER JOIN' ; } if ( ! isset ( $ join [ 'params' ] ) ) { $ join [ 'params' ] = [ ] ; } $ q -> join ( $ join [ 'type' ] , $ join [ 'table' ] , $ join [ 'on' ] , $ join [ 'params' ] ) ; } $ debug = true ; } elseif ( in_array ( $ k , [ 'where' ] ) ) { $ q -> { $ k } ( $ v ) ; } else { $ q -> { $ k } = $ v ; } } if ( $ debug ) { } return $ q ; }
7383	public static function toValues ( $ input , array $ include = [ ] ) { if ( ! is_array ( $ input ) && ! is_object ( $ input ) ) { throw new InvalidArgumentException ( 'input must be an associative array or traversable object' ) ; } $ sqlStrs = [ ] ; if ( count ( $ include ) ) { foreach ( $ include as $ i ) { if ( array_key_exists ( $ i , $ input ) ) { $ sqlStrs [ ] = '`' . $ i . '` = VALUES(`' . $ i . '`)' ; } } } else { foreach ( $ input as $ k => & $ v ) { $ sqlStrs [ ] = '`' . $ k . '` = VALUES(`' . $ k . '`)' ; } } return implode ( ",\n" , $ sqlStrs ) ; }
8841	public function generateURLSegment ( $ increment = null ) { $ filter = new URLSegmentFilter ( ) ; $ this -> owner -> URLSegment = $ filter -> filter ( $ this -> owner -> Title ) ; if ( is_int ( $ increment ) ) $ this -> owner -> URLSegment .= '-' . $ increment ; $ duplicate = DataList :: create ( $ this -> owner -> ClassName ) -> filter ( array ( "URLSegment" => $ this -> owner -> URLSegment , "BlogID" => $ this -> owner -> BlogID ) ) ; if ( $ this -> owner -> ID ) $ duplicate = $ duplicate -> exclude ( "ID" , $ this -> owner -> ID ) ; if ( $ duplicate -> count ( ) > 0 ) { $ increment = is_int ( $ increment ) ? $ increment + 1 : 0 ; $ this -> owner -> generateURLSegment ( ( int ) $ increment ) ; } return $ this -> owner -> URLSegment ; }
7222	protected function clearShipment ( Shipment \ ShipmentInterface $ shipment ) { if ( empty ( $ shipment -> getTrackingNumber ( ) ) && ! $ shipment -> hasLabels ( ) ) { return false ; } $ shipment -> setTrackingNumber ( null ) ; foreach ( $ shipment -> getLabels ( ) as $ label ) { $ shipment -> removeLabel ( $ label ) ; } return true ; }
4883	public function generatePublicAlias ( $ subject , $ currentAlias = '' ) { $ alias = $ this -> strategyWrapper -> generatePublicAlias ( $ subject , $ currentAlias ) ; if ( $ alias !== null && method_exists ( $ subject , 'getLanguage' ) ) { if ( in_array ( $ subject -> getLanguage ( ) , $ this -> localesToPrefix ) ) { $ alias = sprintf ( '%s%s%s' , $ this -> basePath , $ subject -> getLanguage ( ) , $ alias ) ; } } return $ alias ; }
10237	public static function getInstance ( Spreadsheet $ spreadsheet = null ) { if ( $ spreadsheet !== null ) { $ instance = $ spreadsheet -> getCalculationEngine ( ) ; if ( isset ( $ instance ) ) { return $ instance ; } } if ( ! isset ( self :: $ instance ) || ( self :: $ instance === null ) ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
6436	public function getUserProfile ( ) { $ credentials = array ( 'identifier' => $ this -> options [ 'consumer_key' ] , 'secret' => $ this -> options [ 'consumer_secret' ] ) ; $ server = new \ League \ OAuth1 \ Client \ Server \ Xing ( $ credentials ) ; $ user = $ server -> getUserDetails ( $ this -> access_token ) ; return array ( 'userid' => $ user -> uid , 'name' => $ user -> display_name , 'imageurl' => $ user -> imageUrl ) ; }
10153	private function readVcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isVerticalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setVerticalCentered ( $ isVerticalCentered ) ; } }
8763	public function delete ( $ server_filename ) { $ upload_path = config ( 'dropzoner.upload-path' ) ; $ full_path = $ upload_path . $ server_filename ; if ( \ File :: exists ( $ full_path ) ) { \ File :: delete ( $ full_path ) ; } event ( new ImageWasDeleted ( $ server_filename ) ) ; return response ( ) -> json ( [ 'error' => false , 'code' => 200 ] , 200 ) ; }
12677	public function approveRemoval ( $ sourceDir , array $ options , $ username ) { $ this -> init ( $ sourceDir , $ options , $ username ) ; $ targetFilename = sprintf ( '%s/blocks/%s.json' , $ this -> productionDir , $ options [ 'blockname' ] ) ; if ( ! file_exists ( $ targetFilename ) ) { return ; } Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVING_REMOVAL , new BlockApprovingRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; $ this -> filesystem -> remove ( $ targetFilename ) ; $ slotDefinition = $ this -> getSlotDefinition ( $ this -> productionDir ) ; $ blocks = $ slotDefinition [ "blocks" ] ; $ key = array_search ( $ options [ 'blockname' ] , $ blocks ) ; unset ( $ blocks [ $ key ] ) ; $ slotDefinition [ "blocks" ] = $ blocks ; $ this -> saveSlotDefinition ( $ this -> productionDir , $ slotDefinition , $ username ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_APPROVED_REMOVAL , new BlockApprovedRemovalEvent ( $ this -> serializer , $ targetFilename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been approved for removal on the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
9435	public function theta ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set theta value, because algebraic form is in use.' ) ; } $ this -> theta = new \ stdClass ( ) ; $ this -> theta -> min = $ float_min ; $ this -> theta -> max = $ float_max ; return $ this ; }
8633	public function setOrderChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'OrderChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2729	public function beforeToHtml ( Image $ subject ) { if ( $ this -> config -> isImageOptimizationPixelRatioEnabled ( ) !== true ) { return ; } $ srcSet = [ ] ; $ imageUrl = $ subject -> getData ( 'image_url' ) ; $ pixelRatios = $ this -> config -> getImageOptimizationRatios ( ) ; $ pixelRatiosArray = explode ( ',' , $ pixelRatios ) ; $ glue = ( strpos ( $ imageUrl , '?' ) !== false ) ? '&' : '?' ; foreach ( $ pixelRatiosArray as $ pr ) { $ ratio = 'dpr=' . $ pr . ' ' . $ pr . 'x' ; $ srcSet [ ] = $ imageUrl . $ glue . $ ratio ; } $ subject -> setData ( 'custom_attributes' , 'srcset="' . implode ( ',' , $ srcSet ) . '"' ) ; }
8642	public function getReportRequestListByNextToken ( $ request ) { if ( ! $ request instanceof MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ) { $ request = new MarketplaceWebService_Model_GetReportRequestListByNextTokenRequest ( $ request ) ; } $ httpResponse = $ this -> invoke ( $ this -> convertGetReportRequestListByNextToken ( $ request ) ) ; $ response = MarketplaceWebService_Model_GetReportRequestListByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6140	public function checkUser ( $ username = null ) { if ( $ username === null ) { $ username = $ this -> user ; } if ( strlen ( $ username ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ username ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI username validation failed" ) ; } return ( $ status == 1 ) ; }
2788	public static function getMutation ( array & $ tokens , $ index ) { $ num = ( integer ) $ tokens [ $ index ] [ 1 ] ; if ( $ num == 0 ) { $ replace = 1 ; } elseif ( $ num == 1 ) { $ replace = 0 ; } else { $ replace = $ num + 1 ; } $ tokens [ $ index ] = [ T_LNUMBER , ( string ) $ replace ] ; }
2092	protected function initializeSession ( $ formId ) { if ( Input :: post ( 'FORM_SUBMIT' ) != $ formId ) { return ; } $ arrMessageBox = array ( 'TL_ERROR' , 'TL_CONFIRM' , 'TL_INFO' ) ; $ _SESSION [ 'FORM_DATA' ] = \ is_array ( $ _SESSION [ 'FORM_DATA' ] ) ? $ _SESSION [ 'FORM_DATA' ] : array ( ) ; foreach ( $ arrMessageBox as $ tl ) { if ( \ is_array ( $ _SESSION [ $ formId ] [ $ tl ] ) ) { $ _SESSION [ $ formId ] [ $ tl ] = array_unique ( $ _SESSION [ $ formId ] [ $ tl ] ) ; foreach ( $ _SESSION [ $ formId ] [ $ tl ] as $ message ) { $ objTemplate = new FrontendTemplate ( 'form_message' ) ; $ objTemplate -> message = $ message ; $ objTemplate -> class = strtolower ( $ tl ) ; $ this -> Template -> fields .= $ objTemplate -> parse ( ) . "\n" ; } $ _SESSION [ $ formId ] [ $ tl ] = array ( ) ; } } }
9079	private static function parseUri ( Request & $ request , $ uri , $ defaultController , $ defaultAction ) { $ contextUri = $ uri ; if ( null != $ request -> getContextPrefix ( ) && '/' != $ request -> getContextPrefix ( ) ) { $ contextUri = str_replace ( $ request -> getContextPrefix ( ) , '' , $ uri ) ; } $ parts = array ( ) ; if ( $ contextUri != '' ) { while ( isset ( $ contextUri [ 0 ] ) && $ contextUri [ 0 ] == '/' ) { $ contextUri = substr ( $ contextUri , 1 ) ; } $ parts = explode ( '/' , $ contextUri ) ; } if ( count ( $ parts ) > 0 ) { $ request -> setController ( ucfirst ( trim ( $ parts [ 0 ] ) ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getController ( ) ) { $ request -> setController ( $ defaultController ) ; } } if ( count ( $ parts ) > 0 ) { $ request -> setAction ( trim ( $ parts [ 0 ] ) ) ; array_shift ( $ parts ) ; if ( ! $ request -> getAction ( ) ) { $ request -> setAction ( $ defaultAction ) ; } } return $ parts ; }
6146	public function setStatusCode ( int $ value = null ) { if ( is_null ( $ value ) ) { return $ this ; } $ this -> statusCode = $ value ; return $ this ; }
6662	public function get ( $ url , $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new HttpClientException ( HttpClientErrorMessages :: INVALID_QUERY_PARAMS ) ; } $ params = $ this -> filterParams ( $ params ) ; $ this -> lastRequestParams = $ params ; $ this -> lastRequestUrl = $ this -> buildUrl ( $ url , $ params ) ; return $ this -> curlAgent -> get ( $ this -> lastRequestUrl , $ this -> rawResponse ) ; }
6017	public function updateSite ( $ id , DeploymentSite $ deploymentSite ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'deploymentSite' => $ deploymentSite ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
8031	public function getProcessDetails ( $ pid ) { if ( $ this -> hasProcess ( $ pid ) === FALSE ) { return NULL ; } return $ this -> processDetails [ $ pid ] ; }
1435	public static function underscore ( $ value ) { if ( isset ( self :: $ underscored [ $ value ] ) ) { return self :: $ underscored [ $ value ] ; } return self :: $ underscored [ $ value ] = str_replace ( '-' , '_' , self :: decamelize ( $ value ) ) ; }
12159	public function getTitle ( ) { if ( ! is_object ( $ this -> _title ) ) { $ this -> _title = new Noun ( $ this -> _title ) ; } return $ this -> _title ; }
7793	public function getStatements ( $ text ) { if ( ! $ this -> parsers ) { $ this -> addParsers ( $ this -> getDefaultParsers ( ) ) ; } foreach ( $ this -> parsers as $ class ) { $ parser = new $ class ( $ this ) ; if ( $ parser -> accept ( $ text ) ) { return $ parser -> parse ( $ text ) ; } } throw new \ RuntimeException ( 'No suitable parser found.' ) ; }
2308	public function setImportantPart ( array $ importantPart = null ) { if ( $ importantPart !== null ) { if ( ! isset ( $ importantPart [ 'x' ] ) || ! isset ( $ importantPart [ 'y' ] ) || ! isset ( $ importantPart [ 'width' ] ) || ! isset ( $ importantPart [ 'height' ] ) ) { throw new \ InvalidArgumentException ( 'Malformed array for setting the important part!' ) ; } $ this -> importantPart = array ( 'x' => max ( 0 , min ( $ this -> fileObj -> viewWidth - 1 , ( int ) $ importantPart [ 'x' ] ) ) , 'y' => max ( 0 , min ( $ this -> fileObj -> viewHeight - 1 , ( int ) $ importantPart [ 'y' ] ) ) , ) ; $ this -> importantPart [ 'width' ] = max ( 1 , min ( $ this -> fileObj -> viewWidth - $ this -> importantPart [ 'x' ] , ( int ) $ importantPart [ 'width' ] ) ) ; $ this -> importantPart [ 'height' ] = max ( 1 , min ( $ this -> fileObj -> viewHeight - $ this -> importantPart [ 'y' ] , ( int ) $ importantPart [ 'height' ] ) ) ; } else { $ this -> importantPart = null ; } return $ this ; }
3125	protected function cloneTimePoint ( TimePoint $ point , $ type , $ timestamp = null ) { if ( is_null ( $ timestamp ) ) { $ timestamp = $ point -> getTimestamp ( ) ; } \ common_Logger :: d ( "Create missing TimePoint at " . $ timestamp ) ; return new TimePoint ( $ point -> getTags ( ) , $ timestamp , $ type , $ point -> getTarget ( ) ) ; }
273	public function asXml ( $ data ) { $ response = Yii :: $ app -> getResponse ( ) ; $ response -> format = Response :: FORMAT_XML ; $ response -> data = $ data ; return $ response ; }
2509	protected function findBuilderForMessage ( $ messageName ) { $ builder = null ; if ( array_key_exists ( $ messageName , $ this -> messageBuilders ) && $ this -> messageBuilders [ $ messageName ] instanceof ConvertInterface ) { $ builder = $ this -> messageBuilders [ $ messageName ] ; } else { $ section = substr ( $ messageName , 0 , strpos ( $ messageName , '_' ) ) ; $ message = substr ( $ messageName , strpos ( $ messageName , '_' ) + 1 ) ; $ builderClass = __NAMESPACE__ . '\\Converter\\' . $ section . '\\' . $ message . "Conv" ; if ( class_exists ( $ builderClass ) ) { $ builder = new $ builderClass ( ) ; $ builder -> setParams ( $ this -> params ) ; $ this -> messageBuilders [ $ messageName ] = $ builder ; } } return $ builder ; }
10728	public function getMonth ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'month' ] ; } }
3840	private function parsePanelRow ( $ fields , PanelRowInterface $ panelRow ) { foreach ( $ fields as $ field ) { switch ( $ field ) { case 'sort' : $ this -> parsePanelSort ( $ panelRow ) ; break ; case 'limit' : $ this -> parsePanelLimit ( $ panelRow ) ; break ; case 'filter' : $ this -> parsePanelFilter ( $ panelRow ) ; break ; case 'search' : $ this -> parsePanelSearch ( $ panelRow ) ; break ; case 'submit' : $ this -> parsePanelSubmit ( $ panelRow ) ; break ; default : break ; } } }
2575	protected function loadRequestCreatorParams ( $ params ) { if ( isset ( $ params [ 'requestCreatorParams' ] ) ) { if ( $ params [ 'requestCreatorParams' ] instanceof RequestCreatorParams ) { $ this -> requestCreatorParams = $ params [ 'requestCreatorParams' ] ; } elseif ( is_array ( $ params [ 'requestCreatorParams' ] ) ) { $ this -> requestCreatorParams = new RequestCreatorParams ( $ params [ 'requestCreatorParams' ] ) ; } } }
11286	protected function _getQueryObjectForRelation ( $ attribute ) { $ def = $ this -> model_attributes [ $ attribute ] ; if ( ! isset ( $ def [ 'model' ] ) && ! isset ( $ def [ 'models' ] ) ) { return $ this -> getDbAdaptor ( ) ; } $ relatedObj = isset ( $ def [ 'models' ] ) ? $ this -> fetchRelatedObj ( $ def [ 'models' ] ) : $ this -> fetchRelatedObj ( $ def [ 'model' ] ) ; $ query = $ relatedObj -> getDbAdaptor ( ) ; if ( ! isset ( $ def [ 'via' ] ) && ! isset ( $ def [ 'using' ] ) ) { $ relTable = $ this -> getRelationTableName ( $ relatedObj , $ attribute , $ this -> model_attributes [ $ attribute ] ) ; if ( ! $ query -> tableExists ( $ relTable ) ) { $ query = $ this -> getDbAdaptor ( ) ; } } return $ query ; }
10194	public static function getLastQuery ( $ connection = "" ) { $ last_query = "" ; $ pretty_queries = self :: getPrettyQueryLog ( $ connection ) ; if ( ! empty ( $ pretty_queries ) ) { $ last_query = $ pretty_queries [ count ( $ pretty_queries ) - 1 ] ; } return $ last_query ; }
6524	public function getHandlerMethodName ( $ withMajor = true ) { if ( true === $ withMajor ) { return lcfirst ( $ this -> classShortName ) ; } return lcfirst ( str_replace ( 'V' . $ this -> id -> getVersion ( ) -> getMajor ( ) , '' , $ this -> classShortName ) ) ; }
4295	public function alert ( $ message , $ class = 'danger' , $ dismissible = false ) { array ( $ class , $ dismissible ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'message' => null , 'class' => 'danger' , 'dismissible' => false , ) , array ( 'class' , 'dismissible' ) ) ; \ extract ( $ args ) ; $ this -> setLogDest ( 'alerts' ) ; $ this -> appendLog ( 'alert' , array ( $ message ) , $ meta ) ; $ this -> setLogDest ( 'auto' ) ; }
9678	public function allNumberFormats ( Spreadsheet $ spreadsheet ) { $ aNumFmts = [ ] ; $ aStyles = $ this -> allStyles ( $ spreadsheet ) ; foreach ( $ aStyles as $ style ) { if ( $ style -> getNumberFormat ( ) -> getBuiltInFormatCode ( ) === false && ! isset ( $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] ) ) { $ aNumFmts [ $ style -> getNumberFormat ( ) -> getHashCode ( ) ] = $ style -> getNumberFormat ( ) ; } } return $ aNumFmts ; }
9170	public function updateCompany ( \ Unite \ Contacts \ Http \ Requests \ UpdateRequest $ request ) { $ this -> service -> saveCompanyProfile ( $ request -> all ( ) ) ; return $ this -> successJsonResponse ( ) ; }
1384	protected function isNotFound ( string $ type , string $ id ) : bool { return ! $ this -> store -> exists ( ResourceIdentifier :: create ( $ type , $ id ) ) ; }
6677	public static function toRelativeTime ( $ fromTime , $ toTime = 'now' , $ format = 'days' ) { $ startTime = new DateTime ( $ fromTime ) ; $ endTime = new DateTime ( $ toTime ) ; return $ startTime -> diff ( $ endTime ) -> $ format ; }
1655	public function handleConnectedSocks ( ConnectionInterface $ stream , $ host , $ port , Deferred $ deferred , $ uri ) { $ reader = new StreamReader ( ) ; $ stream -> on ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> on ( 'error' , $ onError = function ( Exception $ e ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy caused a stream error (EIO)' , defined ( 'SOCKET_EIO' ) ? SOCKET_EIO : 5 , $ e ) ) ; } ) ; $ stream -> on ( 'close' , $ onClose = function ( ) use ( $ deferred , $ uri ) { $ deferred -> reject ( new RuntimeException ( 'Connection to ' . $ uri . ' failed because connection to proxy was lost while waiting for response from proxy (ECONNRESET)' , defined ( 'SOCKET_ECONNRESET' ) ? SOCKET_ECONNRESET : 104 ) ) ; } ) ; if ( $ this -> protocolVersion === 5 ) { $ promise = $ this -> handleSocks5 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } else { $ promise = $ this -> handleSocks4 ( $ stream , $ host , $ port , $ reader , $ uri ) ; } $ promise -> then ( function ( ) use ( $ deferred , $ stream , $ reader , $ onError , $ onClose ) { $ stream -> removeListener ( 'data' , array ( $ reader , 'write' ) ) ; $ stream -> removeListener ( 'error' , $ onError ) ; $ stream -> removeListener ( 'close' , $ onClose ) ; $ deferred -> resolve ( $ stream ) ; } , function ( Exception $ error ) use ( $ deferred , $ stream , $ uri ) { if ( ! $ error instanceof RuntimeException ) { $ error = new RuntimeException ( 'Connection to ' . $ uri . ' failed because proxy returned invalid response (EBADMSG)' , defined ( 'SOCKET_EBADMSG' ) ? SOCKET_EBADMSG : 71 , $ error ) ; } $ deferred -> reject ( $ error ) ; $ stream -> close ( ) ; } ) ; }
11474	public function setObject ( $ object ) { if ( is_null ( $ this -> _objectType ) ) { $ this -> objectType = $ object -> objectType ; } $ this -> _object = $ object ; }
5512	public function expectMaximumCallCount ( $ method , $ count , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set maximum call count' ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> max_counts [ strtolower ( $ method ) ] = new MaximumCallCountExpectation ( $ method , $ count , $ message ) ; }
990	public static function validate ( Schema $ schema , DocumentNode $ ast , ? array $ rules = null , ? TypeInfo $ typeInfo = null ) { if ( $ rules === null ) { $ rules = static :: allRules ( ) ; } if ( is_array ( $ rules ) === true && count ( $ rules ) === 0 ) { return [ ] ; } $ typeInfo = $ typeInfo ? : new TypeInfo ( $ schema ) ; return static :: visitUsingRules ( $ schema , $ typeInfo , $ ast , $ rules ) ; }
3761	private function getLegend ( PaletteInterface $ palette , $ legendName ) { if ( $ palette -> hasLegend ( $ legendName ) ) { return $ palette -> getLegend ( $ legendName ) ; } $ legend = new Legend ( $ legendName ) ; $ palette -> addLegend ( $ legend ) ; return $ legend ; }
1221	private function reduce ( $ from , array $ values , array $ types , callable $ reduce ) { $ i = - 1 ; return array_reduce ( $ values , function ( $ carry , $ item ) use ( $ from , $ types , $ reduce , & $ i ) { if ( ++ $ i > 0 ) { $ this -> validateSeq ( $ from , $ types , $ carry , $ item ) ; } return $ reduce ( $ carry , $ item , $ i ) ; } ) ; }
5564	protected function loadFrame ( $ frames , $ url , $ parameters ) { $ page = $ this -> fetch ( $ url , $ parameters ) ; $ this -> page -> setFrame ( $ frames , $ page ) ; return $ page -> getRaw ( ) ; }
9674	public function allConditionalStyles ( Spreadsheet $ spreadsheet ) { $ aStyles = [ ] ; $ sheetCount = $ spreadsheet -> getSheetCount ( ) ; for ( $ i = 0 ; $ i < $ sheetCount ; ++ $ i ) { foreach ( $ spreadsheet -> getSheet ( $ i ) -> getConditionalStylesCollection ( ) as $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditionalStyle ) { $ aStyles [ ] = $ conditionalStyle ; } } } return $ aStyles ; }
12919	public function setFilters ( ) { $ this -> activeQueryLog ( ) -> setFields ( ) -> setCriteriaByQueryString ( ) -> setCriteria ( ) -> setIncludes ( ) -> setLimit ( ) -> setOrder ( ) -> setGroup ( ) ; }
1175	protected function jsConvertRules ( $ attribute , $ rules , $ includeRemote ) { $ jsRules = [ ] ; foreach ( $ rules as $ rawRule ) { list ( $ rule , $ parameters ) = $ this -> validator -> parseRule ( $ rawRule ) ; list ( $ jsAttribute , $ jsRule , $ jsParams ) = $ this -> rules -> getRule ( $ attribute , $ rule , $ parameters , $ rawRule ) ; if ( $ this -> isValidatable ( $ jsRule , $ includeRemote ) ) { $ jsRules [ $ jsAttribute ] [ $ jsRule ] [ ] = [ $ rule , $ jsParams , $ this -> messages -> getMessage ( $ attribute , $ rule , $ parameters ) , $ this -> validator -> isImplicit ( $ rule ) , ] ; } } return $ jsRules ; }
3426	public function sort ( $ by , $ order = 'ASC' ) { $ this -> sort = is_array ( $ by ) ? $ by : [ $ by => $ order ] ; return $ this ; }
5195	protected function getMethodResult ( $ method , array $ arguments ) { if ( ! is_callable ( [ 'Elasticsearch\Client' , $ method ] ) ) { trigger_error ( sprintf ( 'Call to undefined or protected/private method %s::%s()' , get_called_class ( ) , $ method ) , E_USER_ERROR ) ; } if ( empty ( $ this -> results [ $ method ] ) ) { throw new \ Exception ( sprintf ( "ElasticsearchMock results is empty for %s" , $ method ) ) ; } $ this -> calls [ $ method ] [ ] = $ arguments ; return array_shift ( $ this -> results [ $ method ] ) ; }
2317	public function computeResize ( ) { $ resizeCoordinates = System :: getContainer ( ) -> get ( 'contao.image.resize_calculator' ) -> calculate ( $ this -> prepareResizeConfig ( ) , new ImageDimensions ( new Box ( $ this -> fileObj -> viewWidth , $ this -> fileObj -> viewHeight ) , $ this -> fileObj -> viewWidth !== $ this -> fileObj -> width ) , $ this -> prepareImportantPart ( ) ) ; return array ( 'width' => $ resizeCoordinates -> getCropSize ( ) -> getWidth ( ) , 'height' => $ resizeCoordinates -> getCropSize ( ) -> getHeight ( ) , 'target_x' => - $ resizeCoordinates -> getCropStart ( ) -> getX ( ) , 'target_y' => - $ resizeCoordinates -> getCropStart ( ) -> getY ( ) , 'target_width' => $ resizeCoordinates -> getSize ( ) -> getWidth ( ) , 'target_height' => $ resizeCoordinates -> getSize ( ) -> getHeight ( ) , ) ; }
9113	public function setUp ( ) { $ this -> controllers = array ( ) ; $ this -> views = array ( ) ; $ this -> viewControls = array ( ) ; $ this -> setDefaults ( ) ; $ this -> init ( ) ; $ this -> setLogger ( new NullLogger ( ) ) ; return $ this ; }
9425	public function f ( ) { if ( is_null ( $ this -> arr_f ) ) { $ arr = $ this -> frequency ( ) ; array_walk ( $ arr , function ( & $ v , $ k , $ n ) { $ v = $ v / $ n ; } , count ( $ this ) ) ; $ this -> arr_f = $ arr ; } return $ this -> arr_f ; }
9061	private function getTableData ( $ table ) : self { if ( $ table instanceof Table ) { return $ table ; } elseif ( is_subclass_of ( $ table , Mapper :: class ) ) { $ mapper = $ this -> container -> getByType ( $ table ) ; return $ mapper -> getStructure ( ) ; } else { throw new InvalidArgumentException ; } }
1375	private function runCommandsWithParameters ( Collection $ commands , array $ parameters ) { foreach ( $ commands -> keys ( ) as $ command ) { if ( 0 !== $ this -> call ( $ command , $ parameters ) ) { return false ; } } return true ; }
4453	public function isPaused ( ) : bool { $ stat = json_decode ( $ this -> client -> queues ( $ this -> name ) , true ) ; return isset ( $ stat [ 'name' ] ) && $ stat [ 'name' ] === $ this -> name && $ stat [ 'paused' ] == true ; }
4198	public function onEnd ( Event $ event ) { $ obj = $ event -> getSubject ( ) ; if ( $ obj instanceof \ DOMNodeList ) { $ event [ 'properties' ] [ 'length' ] = \ array_merge ( static :: $ basePropInfo , array ( 'type' => 'integer' , 'value' => $ obj -> length , ) ) ; } elseif ( $ obj instanceof \ Exception ) { if ( isset ( $ event [ 'properties' ] [ 'xdebug_message' ] ) ) { $ event [ 'properties' ] [ 'xdebug_message' ] [ 'isExcluded' ] = true ; } } elseif ( $ obj instanceof \ mysqli && ! $ event [ 'collectPropertyValues' ] ) { $ propsAlwaysAvail = array ( 'client_info' , 'client_version' , 'connect_errno' , 'connect_error' , 'errno' , 'error' , 'stat' ) ; $ reflectionObject = $ event [ 'reflector' ] ; foreach ( $ propsAlwaysAvail as $ name ) { $ reflectionProperty = $ reflectionObject -> getProperty ( $ name ) ; $ event [ 'properties' ] [ $ name ] [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } }
2527	protected function getEndpointFromWsdl ( $ wsdlFilePath , $ messageName ) { $ wsdlId = $ this -> getWsdlIdFor ( $ messageName ) ; return WsdlAnalyser :: exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , self :: XPATH_ENDPOINT ) ; }
12387	private static function showErrors ( ) { if ( count ( static :: $ errors ) > 0 ) { $ errorsList = '' ; foreach ( static :: $ errors as $ error ) { $ errorsList .= 'Tipo: ' . $ error [ 'type' ] . '<br>' ; $ errorsList .= 'Mensaje: ' . $ error [ 'message' ] . '<br>' ; $ errorsList .= 'Archivo: ' . $ error [ 'file' ] . '<br>' ; $ errorsList .= 'Line: ' . $ error [ 'line' ] . '<br><br>' ; } static :: viewException ( 1 , $ errorsList ) ; } }
12791	public static function createLayout ( string $ layoutName , View $ view ) : ? Layout { $ layoutsRoot = AppHelper :: getInstance ( ) -> getComponentRoot ( 'layouts' ) ; $ layoutFile = $ layoutsRoot . \ DIRECTORY_SEPARATOR . strtolower ( $ layoutName ) . '.php' ; if ( is_readable ( $ layoutFile ) ) { return new Layout ( $ layoutFile , $ view ) ; } return null ; }
9423	public function getSize ( ) { if ( is_null ( $ this -> size ) === true ) { $ stats = fstat ( $ this -> stream ) ; $ this -> size = $ stats [ 'size' ] ; } return $ this -> size ; }
6761	public function find ( $ criteria ) { if ( ! $ criteria ) { error_log ( "collection error: no criteria specified" ) ; return null ; } else if ( is_callable ( $ criteria ) ) { foreach ( $ this -> models as $ model ) if ( $ criteria ( $ model ) ) return $ model ; } else if ( is_a ( $ criteria , "SnooPHP\Model\Model" ) ) { foreach ( $ this -> models as $ i => $ model ) if ( $ model == $ criteria ) return $ i ; } return null ; }
7118	protected function getGetAvailableSumBySubjectQuery ( ) { if ( null !== $ this -> getAvailableSumBySubjectQuery ) { return $ this -> getAvailableSumBySubjectQuery ; } $ as = $ this -> getAlias ( ) ; $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; $ qb -> andWhere ( $ qb -> expr ( ) -> gte ( $ as . '.availableStock' , 0 ) ) -> select ( 'SUM(' . $ as . '.availableStock) as available' ) ; return $ this -> getAvailableSumBySubjectQuery = $ qb -> getQuery ( ) ; }
10518	protected function getProductPhoto ( MediaInterface $ media , ProductInterface $ modelData , $ values ) { $ mainPhoto = $ this -> isMainPhoto ( $ media , $ values [ 'main' ] ) ; $ productPhoto = new ProductPhoto ( ) ; $ productPhoto -> setPhoto ( $ media ) ; $ productPhoto -> setMainPhoto ( $ mainPhoto ) ; $ productPhoto -> setProduct ( $ modelData ) ; if ( $ mainPhoto ) { $ modelData -> setPhoto ( $ media ) ; } return $ productPhoto ; }
4067	public function get ( $ strName ) { return isset ( $ this -> arrBase [ $ strName ] ) ? $ this -> arrBase [ $ strName ] : null ; }
4981	public function convertToPhpValue ( $ value ) { if ( ! is_array ( $ value ) || ! isset ( $ value [ 'date' ] ) || ! $ value [ 'date' ] instanceof \ MongoDate || ! isset ( $ value [ 'tz' ] ) ) { return null ; } $ timestamp = $ value [ 'date' ] -> sec ; $ date = new \ DateTime ( '@' . $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ value [ 'tz' ] ) ) ; return $ date ; }
2311	public function getResizedPath ( ) { $ path = $ this -> resizedPath ; $ webDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.web_dir' ) ) ; if ( strncmp ( $ path , $ webDir . '/' , \ strlen ( $ webDir ) + 1 ) === 0 ) { $ path = substr ( $ path , \ strlen ( $ webDir ) + 1 ) ; } return $ path ; }
1165	protected function parseAttributeName ( $ data ) { parse_str ( $ data , $ attrParts ) ; $ attrParts = is_null ( $ attrParts ) ? [ ] : $ attrParts ; $ newAttr = array_keys ( array_dot ( $ attrParts ) ) ; return array_pop ( $ newAttr ) ; }
8558	public function setFinancialEventGroupList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FinancialEventGroupList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6141	public function checkPass ( $ password = null ) { if ( $ password === null ) { $ password = $ this -> pass ; } if ( strlen ( $ password ) == 0 ) { return true ; } $ pattern = "/^(" . $ this -> regex [ "alphanum" ] . "|" . $ this -> regex [ "mark" ] . "|" . $ this -> regex [ "escaped" ] . "|[;:&=+$,])+$/" ; $ status = @ preg_match ( $ pattern , $ password ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI password validation failed" ) ; } return ( $ status == 1 ) ; }
11958	public function remove ( $ element ) { if ( ! $ this -> contains ( $ element ) ) { return false ; } $ this -> offsetUnset ( $ this -> indexOf ( $ element ) ) ; return true ; }
2141	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ this -> scopeMatcher -> isContaoMasterRequest ( $ event ) ) { return ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token || $ this -> authenticationTrustResolver -> isAnonymous ( $ token ) ) { return ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof User ) { return ; } $ sessionBag = $ this -> getSessionBag ( $ event -> getRequest ( ) ) ; $ data = $ sessionBag -> all ( ) ; $ this -> connection -> update ( $ user -> getTable ( ) , [ 'session' => serialize ( $ data ) ] , [ 'id' => $ user -> id ] ) ; }
11807	public function lists ( $ column , $ key = null ) { return $ this -> buildQuery ( [ $ column ] ) -> lists ( $ column , $ key ) ; }
12221	private function logException ( Exception $ exception ) { if ( in_array ( $ exception -> getStatusCode ( ) , $ this -> doNotLog ) ) { return ; } $ message = sprintf ( 'Uncaught exception of type %s thrown in file %s at line %s%s.' , get_class ( $ exception ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) , $ exception -> getMessage ( ) ? sprintf ( ' with message "%s"' , $ exception -> getMessage ( ) ) : '' ) ; $ this -> container [ 'log' ] -> error ( $ message , array ( 'exception' => $ exception , 'Exception message' => $ message , 'Exception line' => $ exception -> getLine ( ) , 'Exception trace' => $ exception -> getTraceAsString ( ) , ) ) ; }
5036	public function indexAction ( ) { $ events = $ this -> adminControllerEvents ; $ event = $ events -> getEvent ( AdminControllerEvent :: EVENT_DASHBOARD , $ this ) ; $ events -> trigger ( $ event , $ this ) ; $ model = new ViewModel ( ) ; $ widgets = [ ] ; foreach ( $ event -> getViewModels ( ) as $ name => $ child ) { $ model -> addChild ( $ child , $ name ) ; $ widgets [ ] = $ name ; } $ model -> setVariable ( 'widgets' , $ widgets ) ; return $ model ; }
4119	public static function addType ( $ name , $ className ) { if ( isset ( self :: $ _typesMap [ $ name ] ) ) { throw TypeException :: typeExists ( $ name ) ; } self :: $ _typesMap [ $ name ] = $ className ; }
8029	public function registerFreeProcessId ( $ pid ) { $ processDetails = $ this -> getProcessDetails ( $ pid ) ; if ( $ processDetails !== NULL ) { $ this -> registerFreeProcess ( $ processDetails ) ; } return $ this ; }
12955	public function getObject ( $ checkAccess = true ) { $ registryClass = Yii :: $ app -> classes [ 'Registry' ] ; $ return = $ registryClass :: getObject ( $ this -> registry_id , $ checkAccess ) ; if ( get_class ( $ return ) === 'cascade\models\Registry' ) { \ d ( $ this -> registry_id ) ; exit ; } return $ return ; }
12511	private function buildGroup ( $ group ) { if ( is_null ( $ group ) ) { $ group = [ 'filter' => [ 'is_to_all' => true , ] , ] ; } elseif ( is_array ( $ group ) ) { $ group = [ 'touser' => $ group , ] ; } else { $ group = [ 'filter' => [ 'is_to_all' => false , 'group_id' => $ group , ] , ] ; } return $ group ; }
405	public function addCorsHeaders ( $ response , $ headers ) { if ( empty ( $ headers ) === false ) { $ responseHeaders = $ response -> getHeaders ( ) ; foreach ( $ headers as $ field => $ value ) { $ responseHeaders -> set ( $ field , $ value ) ; } } }
8629	public function setParticipation ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Participation' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7521	function parse_asp ( ) { $ start = $ this -> pos ; if ( $ this -> next_pos ( '%>' , false ) !== self :: TOK_UNKNOWN ) { $ this -> pos -= 2 ; } $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> status [ 'last_pos' ] = ++ $ this -> pos ; return true ; }
826	public function isBeforeStructuralElement ( Tokens $ tokens , $ index ) { $ token = $ tokens [ $ index ] ; if ( ! $ token -> isGivenKind ( [ T_COMMENT , T_DOC_COMMENT ] ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ nextIndex = $ index ; do { $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ nextIndex ) ; } while ( null !== $ nextIndex && $ tokens [ $ nextIndex ] -> equals ( '(' ) ) ; if ( null === $ nextIndex || $ tokens [ $ nextIndex ] -> equals ( '}' ) ) { return false ; } $ nextToken = $ tokens [ $ nextIndex ] ; if ( $ this -> isStructuralElement ( $ nextToken ) ) { return true ; } if ( $ this -> isValidControl ( $ tokens , $ token , $ nextIndex ) ) { return true ; } if ( $ this -> isValidVariable ( $ tokens , $ nextIndex ) ) { return true ; } if ( $ this -> isValidLanguageConstruct ( $ tokens , $ token , $ nextIndex ) ) { return true ; } return false ; }
10310	function getUniqueOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; return $ this -> get ( 'reports/opens/unique/count' , $ params ) ; }
11557	protected function detectNamespace ( $ settings ) { foreach ( $ this -> options -> getNamespaces ( ) as $ namespaceOptions ) { $ namespaceEntityClass = $ namespaceOptions -> getEntityClass ( ) ; if ( $ settings instanceof $ namespaceEntityClass ) { return $ namespaceOptions -> getName ( ) ; } } throw new Exception \ InvalidArgumentException ( 'Unknown Settings namespace' ) ; }
3906	public function handle ( GetOptionsEvent $ event ) { if ( ( 'tl_metamodel_dca_combine' !== $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) ) || ( 'rows' !== $ event -> getPropertyName ( ) ) || ! in_array ( $ event -> getSubPropertyName ( ) , [ 'be_group' , 'fe_group' ] ) ) { return ; } $ isBackend = 'be_group' === $ event -> getSubPropertyName ( ) ; $ groups = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' ) -> addSelect ( 'name' ) -> from ( $ isBackend ? 'tl_user_group' : 'tl_member_group' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; $ result [ - 1 ] = $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( $ isBackend ? 'sysadmin' : 'anonymous' , 'tl_metamodel_dca_combine' ) ; foreach ( $ groups as $ group ) { $ result [ $ group [ 'id' ] ] = $ group [ 'name' ] ; } $ event -> setOptions ( $ result ) ; }
8591	public function setStatus ( $ status ) { if ( ! $ this -> isNumericArray ( $ status ) ) { $ status = array ( $ status ) ; } $ this -> fields [ 'Status' ] [ 'FieldValue' ] = $ status ; return $ this ; }
11591	private function upload ( $ path , $ payload ) { return Storage :: disk ( 's3' ) -> put ( $ path , $ payload , $ this -> visibility ) ; }
9725	public function getTemporaryFilename ( $ extension = 'xlsx' ) { $ temporaryFilename = tempnam ( $ this -> getTemporaryFolder ( ) , 'phpspreadsheet-' ) ; unlink ( $ temporaryFilename ) ; return $ temporaryFilename . '.' . $ extension ; }
5154	public function configure ( ) { $ configuration = $ this -> getConfiguration ( ) ; if ( $ configuration instanceof ConfigurationInterface ) { $ this -> configuration -> configure ( $ this ) ; } }
2643	private function _purge ( $ uri , $ type , $ method = \ Zend_Http_Client :: POST , $ payload = null ) { if ( $ method == 'PURGE' ) { $ expiration = time ( ) + self :: PURGE_TOKEN_LIFETIME ; $ zendUri = \ Zend_Uri :: factory ( $ uri ) ; $ path = $ zendUri -> getPath ( ) ; $ stringToSign = $ path . $ expiration ; $ signature = hash_hmac ( 'sha1' , $ stringToSign , $ this -> config -> getServiceId ( ) ) ; $ token = $ expiration . '_' . urlencode ( $ signature ) ; $ headers = [ self :: FASTLY_HEADER_TOKEN . ': ' . $ token ] ; } else { $ headers = [ self :: FASTLY_HEADER_AUTH . ': ' . $ this -> config -> getApiKey ( ) ] ; } if ( $ this -> config -> canUseSoftPurge ( ) ) { array_push ( $ headers , self :: FASTLY_HEADER_SOFT_PURGE . ': 1' ) ; } $ result [ 'status' ] = true ; try { $ client = $ this -> curlFactory -> create ( ) ; $ client -> setConfig ( [ 'timeout' => self :: PURGE_TIMEOUT ] ) ; if ( $ method == 'PURGE' ) { $ client -> addOption ( CURLOPT_CUSTOMREQUEST , 'PURGE' ) ; } $ client -> write ( $ method , $ uri , '1.1' , $ headers , $ payload ) ; $ responseBody = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ responseBody ) ; $ responseMessage = \ Zend_Http_Response :: extractMessage ( $ responseBody ) ; $ client -> close ( ) ; if ( $ responseCode == '429' ) { throw new LocalizedException ( __ ( $ responseMessage ) ) ; } elseif ( $ responseCode != '200' ) { throw new LocalizedException ( __ ( $ responseCode . ': ' . $ responseMessage ) ) ; } } catch ( \ Exception $ e ) { $ this -> logger -> critical ( $ e -> getMessage ( ) , $ uri ) ; $ result [ 'status' ] = false ; $ result [ 'msg' ] = $ e -> getMessage ( ) ; } if ( empty ( $ type ) ) { return $ result ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishPurgeChanges ( ) ) { $ this -> sendWebHook ( '*initiated ' . $ type . '*' ) ; if ( $ this -> config -> canPublishPurgeDebugBacktrace ( ) == false ) { return $ result ; } $ this -> stackTrace ( $ type ) ; } return $ result ; }
10752	protected function getStateFormatted ( UserEntity $ user ) { switch ( $ user -> getState ( ) ) { case UserEntity :: USER_STATE_ACTIVE : $ this -> stateClass = 'success' ; return 'Attivo' ; break ; case UserEntity :: USER_STATE_BANNED : $ this -> stateClass = 'danger' ; return 'Bannato' ; break ; case UserEntity :: USER_STATE_DEACTIVE : $ this -> stateClass = 'warning' ; return 'Disattivo' ; break ; case UserEntity :: USER_STATE_DELETED : $ this -> stateClass = 'danger' ; return 'Eliminato' ; break ; } $ this -> stateClass = 'danger' ; return 'Error with user state' ; }
4717	public function emit ( $ event , $ parameters ) { if ( ! isset ( $ this -> callbacks [ $ event ] ) ) { return ; } if ( ! $ this -> callbacks [ $ event ] [ 0 ] ) { usort ( $ this -> callbacks [ $ event ] [ 1 ] , function ( $ A , $ B ) { if ( $ A [ 0 ] == $ B [ 0 ] ) { return 0 ; } return ( $ A [ 0 ] > $ B [ 0 ] ) ? 1 : - 1 ; } ) ; $ this -> callbacks [ $ event ] [ 0 ] = true ; } foreach ( $ this -> callbacks [ $ event ] [ 1 ] as $ item ) { call_user_func_array ( $ item [ 1 ] , $ this -> buildParameters ( $ parameters ) ) ; } }
1762	public static function convertXlfToPhp ( $ strName , $ strLanguage , $ blnLoad = false ) { @ trigger_error ( 'Using System::convertXlfToPhp() has been deprecated and will no longer work in Contao 5.0. Use the Contao\CoreBundle\Config\Loader\XliffFileLoader instead.' , E_USER_DEPRECATED ) ; $ rootDir = self :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( strpos ( $ strName , $ rootDir . '/' ) === false ) { $ strName = $ rootDir . '/' . $ strName ; } $ loader = new XliffFileLoader ( static :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) , $ blnLoad ) ; return $ loader -> load ( $ strName , $ strLanguage ) ; }
11676	protected function get ( $ locale , $ file , $ key ) { $ this -> load ( $ locale , $ file ) ; if ( array_key_exists ( $ key , $ this -> translations [ $ locale ] [ $ file ] ) === false ) { throw new TranslationKeyNotFound ( $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } $ result = $ this -> translations [ $ locale ] [ $ file ] [ $ key ] ; if ( is_string ( $ result ) === false ) { throw new TranslationKeyIsNotAString ( $ result , $ key , $ this -> getPath ( ) , $ locale , $ file ) ; } return $ result ; }
5465	public function addRealm ( $ url , $ type , $ realm ) { $ this -> realms [ $ url -> getHost ( ) ] [ $ realm ] = new SimpleRealm ( $ type , $ url ) ; }
7012	private function formatF ( & $ str ) { if ( strstr ( $ str , '%F' ) ) $ str = str_replace ( '%F' , $ this -> monthName ( true ) , $ str ) ; }
2556	protected static function loadObFees ( $ obFees , $ obFeeRefs ) { $ opt = [ ] ; if ( ! empty ( $ obFees ) ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_OB_FEES ) ; $ po -> penDisInformation = new PenDisInformation ( PenDisInformation :: QUAL_OB_FEES , $ obFees ) ; if ( ! empty ( $ obFeeRefs ) ) { $ po -> paxSegTstReference = new PaxSegTstReference ( $ obFeeRefs ) ; } $ opt [ ] = $ po ; } return $ opt ; }
8746	public function getListenerInstance ( EventDispatcher $ eventDispatcher = null , StreamableInterface $ stream = null ) { $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Matcher' ) ; $ matcher = $ reflection -> newInstance ( ) ; $ reflection = new \ ReflectionClass ( '\\Iber\\Phkey\\Environment\\' . $ this -> getEnvironment ( ) . '\\Listener' ) ; if ( null === $ eventDispatcher ) { $ eventDispatcher = new EventDispatcher ( ) ; } if ( null === $ stream ) { $ stream = new Stream ( ) ; } $ listener = $ reflection -> newInstance ( $ matcher , $ eventDispatcher , $ stream ) ; return $ listener ; }
9735	public static function indexedColor ( $ pIndex , $ background = false ) { $ pIndex = ( int ) $ pIndex ; if ( self :: $ indexedColors === null ) { self :: $ indexedColors = [ 1 => 'FF000000' , 2 => 'FFFFFFFF' , 3 => 'FFFF0000' , 4 => 'FF00FF00' , 5 => 'FF0000FF' , 6 => 'FFFFFF00' , 7 => 'FFFF00FF' , 8 => 'FF00FFFF' , 9 => 'FF800000' , 10 => 'FF008000' , 11 => 'FF000080' , 12 => 'FF808000' , 13 => 'FF800080' , 14 => 'FF008080' , 15 => 'FFC0C0C0' , 16 => 'FF808080' , 17 => 'FF9999FF' , 18 => 'FF993366' , 19 => 'FFFFFFCC' , 20 => 'FFCCFFFF' , 21 => 'FF660066' , 22 => 'FFFF8080' , 23 => 'FF0066CC' , 24 => 'FFCCCCFF' , 25 => 'FF000080' , 26 => 'FFFF00FF' , 27 => 'FFFFFF00' , 28 => 'FF00FFFF' , 29 => 'FF800080' , 30 => 'FF800000' , 31 => 'FF008080' , 32 => 'FF0000FF' , 33 => 'FF00CCFF' , 34 => 'FFCCFFFF' , 35 => 'FFCCFFCC' , 36 => 'FFFFFF99' , 37 => 'FF99CCFF' , 38 => 'FFFF99CC' , 39 => 'FFCC99FF' , 40 => 'FFFFCC99' , 41 => 'FF3366FF' , 42 => 'FF33CCCC' , 43 => 'FF99CC00' , 44 => 'FFFFCC00' , 45 => 'FFFF9900' , 46 => 'FFFF6600' , 47 => 'FF666699' , 48 => 'FF969696' , 49 => 'FF003366' , 50 => 'FF339966' , 51 => 'FF003300' , 52 => 'FF333300' , 53 => 'FF993300' , 54 => 'FF993366' , 55 => 'FF333399' , 56 => 'FF333333' , ] ; } if ( isset ( self :: $ indexedColors [ $ pIndex ] ) ) { return new self ( self :: $ indexedColors [ $ pIndex ] ) ; } if ( $ background ) { return new self ( self :: COLOR_WHITE ) ; } return new self ( self :: COLOR_BLACK ) ; }
3307	protected function buildRequestParam ( $ images , $ options = [ ] ) { if ( is_array ( $ images ) && ! empty ( $ images [ 0 ] ) ) { $ images = $ images [ 0 ] ; } if ( $ this -> supportUrl && FileConverter :: isUrl ( $ images ) ) { $ options [ 'url' ] = $ images ; } else { $ options [ 'image' ] = FileConverter :: toBase64Encode ( $ images ) ; } return $ options ; }
9372	public function run ( ) { if ( static :: $ container -> has ( self :: ERROR_HANDLER ) ) { $ debugger = static :: $ container -> get ( self :: ERROR_HANDLER ) ; $ debugger -> display ( ) ; } $ request = static :: $ container -> get ( self :: SERVER_REQUEST ) ; echo ( string ) $ this -> emit ( $ request ) -> getBody ( ) ; }
1166	protected function parseParameters ( $ parameters ) { $ newParams = [ 'validate_all' => false ] ; if ( isset ( $ parameters [ 0 ] ) ) { $ newParams [ 'validate_all' ] = ( $ parameters [ 0 ] === 'true' ) ? true : false ; } return $ newParams ; }
9355	public function det ( ) { if ( ! $ this -> isSquare ( ) ) { throw new \ RuntimeException ( 'Cannot compute determinant of non square matrix!' ) ; } if ( $ this -> size -> rows == 2 ) { return $ this -> get ( 0 , 0 ) * $ this -> get ( 1 , 1 ) - $ this -> get ( 0 , 1 ) * $ this -> get ( 1 , 0 ) ; } else { $ int_out = 0 ; $ arr_row = $ this -> arr [ 0 ] ; foreach ( $ arr_row as $ n => $ v ) { $ int_out += pow ( - 1 , $ n + 2 ) * $ v * $ this -> subMatrix ( 0 , $ n ) -> det ( ) ; } return $ int_out ; } }
1306	public function destroy ( $ id , Request $ request ) { $ post = Models :: post ( ) -> with ( 'discussion' ) -> findOrFail ( $ id ) ; if ( $ request -> user ( ) -> id !== ( int ) $ post -> user_id ) { return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'danger' , 'chatter_alert' => trans ( 'chatter::alert.danger.reason.destroy_post' ) , ] ) ; } if ( $ post -> discussion -> posts ( ) -> oldest ( ) -> first ( ) -> id === $ post -> id ) { if ( config ( 'chatter.soft_deletes' ) ) { $ post -> discussion -> posts ( ) -> delete ( ) ; $ post -> discussion ( ) -> delete ( ) ; } else { $ post -> discussion -> posts ( ) -> forceDelete ( ) ; $ post -> discussion ( ) -> forceDelete ( ) ; } return redirect ( '/' . config ( 'chatter.routes.home' ) ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_post' ) , ] ) ; } $ post -> delete ( ) ; $ url = '/' . config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ post -> discussion -> category -> slug . '/' . $ post -> discussion -> slug ; return redirect ( $ url ) -> with ( [ 'chatter_alert_type' => 'success' , 'chatter_alert' => trans ( 'chatter::alert.success.reason.destroy_from_discussion' ) , ] ) ; }
9006	public function build ( $ options = array ( ) ) { if ( is_string ( $ options ) ) { $ options = array ( 'type' => $ options , ) ; } else if ( ! is_array ( $ options ) ) { $ options = array ( 'type' => 'text' , ) ; } if ( empty ( $ options [ 'type' ] ) ) { $ options [ 'type' ] = 'text' ; } if ( empty ( $ options [ 'data_type' ] ) ) { $ options [ 'data_type' ] = 'metadata' ; } $ defaults = ( array ) $ this -> config -> getType ( $ options [ 'data_type' ] , $ options [ 'type' ] ) ; $ options = array_merge ( $ defaults , $ options ) ; $ classname = elgg_extract ( 'class_name' , $ options ) ; if ( class_exists ( $ classname ) ) { return new $ classname ( $ options ) ; } return false ; }
7699	function MsWord_Clean ( & $ Txt ) { $ Txt = str_replace ( '<w:lastRenderedPageBreak/>' , '' , $ Txt ) ; $ this -> XML_DeleteElements ( $ Txt , array ( 'w:proofErr' , 'w:noProof' , 'w:lang' , 'w:lastRenderedPageBreak' ) ) ; $ this -> MsWord_CleanSystemBookmarks ( $ Txt ) ; $ this -> MsWord_CleanRsID ( $ Txt ) ; $ this -> MsWord_CleanDuplicatedLayout ( $ Txt ) ; }
11720	public function countPost ( $ actor ) { $ em = $ this -> container -> get ( 'doctrine' ) -> getManager ( ) ; $ entities = $ em -> getRepository ( 'BlogBundle:Post' ) -> findBy ( array ( 'actor' => $ actor ) ) ; return count ( $ entities ) ; }
7101	static public function getClasses ( $ type ) { switch ( $ type ) { case static :: TYPE_FORM : return [ CartInterface :: class ] ; case static :: TYPE_QUOTE : return [ QuoteInterface :: class ] ; case static :: TYPE_PROFORMA : return [ QuoteInterface :: class , OrderInterface :: class ] ; case static :: TYPE_CONFIRMATION : return [ OrderInterface :: class ] ; case static :: TYPE_VOUCHER : return [ ] ; default : throw new InvalidArgumentException ( "Unexpected type '$type'." ) ; } }
11189	public static function json ( $ jsonStr , $ k = null , $ default = null ) { $ json = json_decode ( $ jsonStr , true ) ; if ( $ k && $ json ) { return self :: get ( $ json , $ k , $ default ) ; } return $ json ; }
6892	protected function resolveSoldDeltaQuantity ( SaleItemInterface $ item ) { $ old = $ new = $ item -> getQuantity ( ) ; if ( $ this -> persistenceHelper -> isChanged ( $ item , 'quantity' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ item , 'quantity' ) ; } $ parent = $ item ; while ( null !== $ parent = $ parent -> getParent ( ) ) { if ( $ this -> persistenceHelper -> isChanged ( $ parent , 'quantity' ) ) { list ( $ parentOld , $ parentNew ) = $ this -> persistenceHelper -> getChangeSet ( $ parent , 'quantity' ) ; } else { $ parentOld = $ parentNew = $ parent -> getQuantity ( ) ; } $ old *= $ parentOld ; $ new *= $ parentNew ; } $ sale = $ item -> getSale ( ) ; $ shippedOld = $ shippedNew = 0 ; $ f = $ t = false ; if ( $ this -> persistenceHelper -> isChanged ( $ sale , 'released' ) ) { list ( $ f , $ t ) = $ this -> persistenceHelper -> getChangeSet ( $ sale , 'released' ) ; } elseif ( $ item -> getSale ( ) -> isReleased ( ) ) { $ f = $ t = true ; } if ( $ f || $ t ) { foreach ( $ item -> getStockAssignments ( ) as $ assignment ) { if ( $ this -> persistenceHelper -> isChanged ( $ assignment , 'shippedQuantity' ) ) { list ( $ o , $ n ) = $ this -> persistenceHelper -> getChangeSet ( $ assignment , 'shippedQuantity' ) ; } else { $ o = $ n = $ assignment -> getShippedQuantity ( ) ; } if ( $ f ) { $ shippedOld += $ o ; } if ( $ t ) { $ shippedNew += $ n ; } } if ( $ f ) { $ old = min ( $ old , $ shippedOld ) ; } if ( $ t ) { $ new = min ( $ new , $ shippedNew ) ; } } return $ new - $ old ; }
11665	private function filterElement ( ElementInterface $ element ) { $ value = $ element -> getValue ( ) ; foreach ( $ this -> filters as $ scope => $ filter ) { $ elementIds = array_map ( 'trim' , explode ( ',' , $ scope ) ) ; if ( $ scope === '*' || in_array ( $ element -> getID ( ) , $ elementIds ) ) { $ value = $ filter -> filter ( $ value ) ; } } $ element -> setValue ( $ value ) ; }
8113	public function getReviewDate ( SiteTree $ page = null ) { if ( $ page === null ) { $ page = $ this -> owner ; } if ( $ page -> obj ( 'NextReviewDate' ) -> exists ( ) ) { return $ page -> obj ( 'NextReviewDate' ) ; } $ options = $ this -> owner -> getOptions ( ) ; if ( ! $ options ) { return false ; } if ( ! $ options -> ReviewPeriodDays ) { return false ; } $ nextReviewUnixSec = strtotime ( ' + ' . $ options -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ date = DBDate :: create ( 'NextReviewDate' ) ; $ date -> setValue ( $ nextReviewUnixSec ) ; return $ date ; }
6204	public function onError ( $ type , $ message , $ file = null , $ line = null , $ context = null ) { if ( ini_get ( 'error_reporting' ) == 0 ) { return true ; } if ( isset ( $ this -> fatalErrors [ $ type ] ) ) { throw new Exception ( $ message ) ; } if ( $ this -> shouldNotifyError ( $ type , $ message , $ file , $ line , $ context ) ) { $ backtrace = debug_backtrace ( ) ; array_shift ( $ backtrace ) ; $ this -> airbrakeClient -> notifyOnError ( $ message , $ backtrace ) ; return true ; } return true ; }
7107	static public function round ( $ amount , $ currency ) { $ precision = static :: getPrecision ( $ currency ) ; $ roundingIncrement = static :: getRoundingIncrement ( $ currency ) ; $ amount = round ( $ amount , $ precision , \ PHP_ROUND_HALF_EVEN ) ; if ( 0 < $ roundingIncrement && 0 < $ precision ) { $ roundingFactor = $ roundingIncrement / pow ( 10 , $ precision ) ; $ amount = round ( $ amount / $ roundingFactor ) * $ roundingFactor ; } return $ amount ; }
764	private function splitStatements ( $ sql , $ params ) { $ semicolonIndex = strpos ( $ sql , ';' ) ; if ( $ semicolonIndex === false || $ semicolonIndex === StringHelper :: byteLength ( $ sql ) - 1 ) { return false ; } $ tokenizer = new SqlTokenizer ( $ sql ) ; $ codeToken = $ tokenizer -> tokenize ( ) ; if ( count ( $ codeToken -> getChildren ( ) ) === 1 ) { return false ; } $ statements = [ ] ; foreach ( $ codeToken -> getChildren ( ) as $ statement ) { $ statements [ ] = [ $ statement -> getSql ( ) , $ this -> extractUsedParams ( $ statement , $ params ) ] ; } return $ statements ; }
11312	public static function buildAuthString ( array $ data ) { $ str = array ( ) ; foreach ( $ data as $ k => $ v ) { $ str [ ] = self :: urlEncode ( $ k ) . '="' . self :: urlEncode ( $ v ) . '"' ; } return implode ( ', ' , $ str ) ; }
2570	protected static function loadNonceBase ( $ handlerParams ) { if ( empty ( $ handlerParams -> authParams -> nonceBase ) ) { $ handlerParams -> authParams -> nonceBase = SomewhatRandomGenerator :: generateSomewhatRandomString ( ) ; } return $ handlerParams ; }
464	public function buildNotCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
5675	protected function describeObjectDifference ( $ first , $ second , $ identical ) { if ( ! is_object ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } return $ this -> describeArrayDifference ( $ this -> getMembers ( $ first ) , $ this -> getMembers ( $ second ) , $ identical ) ; }
3939	private function setEval ( $ property , $ propInfo , $ isTranslated ) { $ extra = isset ( $ propInfo [ 'eval' ] ) ? $ propInfo [ 'eval' ] : [ ] ; if ( $ isTranslated ) { $ extra [ 'tl_class' ] = 'translat-attr' . ( ! empty ( $ extra [ 'tl_class' ] ) ? ' ' . $ extra [ 'tl_class' ] : '' ) ; } $ property -> setExtra ( array_merge ( ( array ) $ property -> getExtra ( ) , $ extra ) ) ; }
2806	public function viewLogAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ log = $ this -> getRequest ( ) -> getParam ( 'log' ) ; if ( ! $ token || ! $ log ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return ; } try { $ content = $ requestProfile -> getLogging ( ) -> getLoggedContent ( $ log ) ; $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( $ content ) ; } catch ( Exception $ e ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 200 ) -> setBody ( 'Unable to retrieve logged content' ) ; } }
209	protected function formatScalarValue ( $ value ) { if ( $ value === true ) { return 'true' ; } if ( $ value === false ) { return 'false' ; } if ( is_float ( $ value ) ) { return StringHelper :: floatToString ( $ value ) ; } return ( string ) $ value ; }
5508	public function returnsByReference ( $ method , & $ reference , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return reference' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleByReference ( $ reference ) ) ; }
12538	public function setRelations ( $ value ) { if ( $ this -> companionObject ) { $ baseObject = $ this -> companionObject ; } else { $ baseObject = $ this -> owner ; } $ fields = $ baseObject -> getFields ( ) ; foreach ( $ value as $ tabId => $ relation ) { if ( ! isset ( $ relation [ '_moduleHandler' ] ) ) { \ d ( "boom" ) ; exit ; continue ; } if ( ! isset ( $ fields [ $ relation [ '_moduleHandler' ] ] ) ) { \ d ( $ relation [ '_moduleHandler' ] ) ; \ d ( array_keys ( $ fields ) ) ; exit ; continue ; } $ baseAttributes = [ ] ; $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> model ; if ( empty ( $ model ) ) { $ model = $ fields [ $ relation [ '_moduleHandler' ] ] -> resetModel ( ) ; } $ model -> attributes = $ relation ; $ model -> _moduleHandler = $ relation [ '_moduleHandler' ] ; $ model -> tabularId = $ relation [ '_moduleHandler' ] ; list ( $ relationship , $ role ) = $ baseObject -> objectType -> getRelationship ( $ model -> _moduleHandler ) ; $ relatedHandler = $ baseObject -> objectType -> getRelatedType ( $ model -> _moduleHandler ) ; if ( ! $ relatedHandler ) { continue ; } if ( ! $ this -> owner -> tabularId && ! $ this -> owner -> isNewRecord && empty ( $ model -> parent_object_id ) && empty ( $ model -> child_object_id ) ) { continue ; } $ this -> _relations [ $ tabId ] = $ model ; } }
10044	private function createSelectAssociationFormItem ( Model $ model , Column $ column , $ item ) { $ result = new SelectFormItem ( ) ; $ relations = $ this -> aujaConfigurator -> getRelationsForModel ( $ model ) ; $ relatedModel = null ; foreach ( $ relations as $ relation ) { $ rightModel = $ relation -> getRight ( ) ; if ( starts_with ( $ column -> getName ( ) , camel_case ( $ rightModel -> getName ( ) ) ) ) { $ relatedModel = $ rightModel ; } } if ( $ relatedModel != null ) { $ displayName = $ this -> aujaConfigurator -> getDisplayName ( $ relatedModel ) ; $ result -> setName ( $ displayName ) ; $ result -> setValue ( $ item -> id ) ; $ items = call_user_func ( array ( $ relatedModel -> getName ( ) , 'all' ) ) ; $ displayField = $ this -> aujaConfigurator -> getDisplayField ( $ relatedModel ) ; foreach ( $ items as $ item ) { $ label = isset ( $ item -> $ displayField ) ? $ item -> $ displayField : '' ; $ value = $ item -> id ; $ option = new SelectOption ( $ label , $ value ) ; $ result -> addOption ( $ option ) ; } } return $ result ; }
9888	static function getPermission ( $ code ) { switch ( $ code ) { case 1 : return self :: $ NONE ; case "none" : return self :: $ NONE ; case 2 : return self :: $ SOI ; case "soi" : return self :: $ SOI ; case 3 : return self :: $ COI ; case "coi" : return self :: $ COI ; case 4 : return self :: $ DOI ; case "doi" : return self :: $ DOI ; case 5 : return self :: $ DOI_PLUS ; case "doi+" : return self :: $ DOI_PLUS ; case 6 : return self :: $ OTHER ; case "other" : return self :: $ OTHER ; default : return self :: $ OTHER ; } }
10576	public static function applyStyle ( $ text , $ style ) { $ foreground = self :: getForeground ( $ style ) ; $ background = self :: getBackground ( $ style ) ; return self :: apply ( $ text , $ foreground , $ background ) ; }
3424	protected function normalizeFilter ( ) { $ this -> substituteField ( $ this -> filter , 'GROUPS' , 'GROUPS_ID' ) ; $ this -> substituteField ( $ this -> filter , 'GROUP_ID' , 'GROUPS_ID' ) ; return $ this -> filter ; }
2709	public function beforeSave ( \ Magento \ Config \ Model \ Config $ subject ) { $ data = $ subject -> getData ( ) ; if ( ! empty ( $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ) ) { $ currentCacheConfig = $ data [ 'groups' ] [ 'full_page_cache' ] [ 'fields' ] [ 'caching_application' ] [ 'value' ] ; $ oldCacheConfig = $ this -> scopeConfig -> getValue ( \ Magento \ PageCache \ Model \ Config :: XML_PAGECACHE_TYPE ) ; if ( $ oldCacheConfig == \ Fastly \ Cdn \ Model \ Config :: FASTLY && $ currentCacheConfig != $ oldCacheConfig ) { $ this -> purge = true ; } } }
7192	private function copyItem ( Model \ SaleItemInterface $ source , Model \ SaleItemInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'designation' , 'description' , 'reference' , 'taxGroup' , 'netPrice' , 'weight' , 'quantity' , 'position' , 'compound' , 'immutable' , 'configurable' , 'private' , 'data' , ] ) ; $ this -> copy ( $ source -> getSubjectIdentity ( ) , $ target -> getSubjectIdentity ( ) , [ 'provider' , 'identifier' , ] ) ; foreach ( $ source -> getAdjustments ( ) as $ sourceAdjustment ) { $ targetAdjustment = $ this -> saleFactory -> createAdjustmentForItem ( $ target ) ; $ target -> addAdjustment ( $ targetAdjustment ) ; $ this -> copyAdjustment ( $ sourceAdjustment , $ targetAdjustment ) ; } foreach ( $ source -> getChildren ( ) as $ sourceChild ) { $ targetChild = $ this -> saleFactory -> createItemForSale ( $ target -> getSale ( ) ) ; $ target -> addChild ( $ targetChild ) ; $ this -> copyItem ( $ sourceChild , $ targetChild ) ; } }
7238	protected function fixDeliveryDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'deliveryDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isDeliveryDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isDeliveryDefault ( ) ) { $ a -> setDeliveryDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultDeliveryAddress ( true ) ) { $ address -> setDeliveryDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
8549	public function setRetrochargeEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RetrochargeEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10063	public function get ( $ key , $ default = null ) { $ meta = $ this -> metaModel :: where ( 'key' , $ key ) -> first ( ) ; return $ meta === null ? $ default : $ meta -> value ; }
8394	public static function before ( string $ path , string $ usage , string $ help , string $ action ) { if ( self :: $ isInit === true ) { self :: $ routes [ ] = array ( 'type' => 'before' , 'path' => $ path , 'usage' => $ usage , 'help' => $ help , 'action' => $ action , 'namespace' => self :: $ namespace ) ; } }
4880	public function getResource ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getResource ( ) ; } return null ; }
8890	public function get ( $ key , $ default = null ) { return $ this -> has ( $ key ) ? $ this -> sm -> get ( $ key ) : $ default ; }
276	private function printHelpMessage ( ) { $ this -> stdout ( $ this -> getHelpSummary ( ) . "\n" ) ; $ helpCommand = Console :: ansiFormat ( 'yii help fixture' , [ Console :: FG_CYAN ] ) ; $ this -> stdout ( "Use $helpCommand to get usage info.\n" ) ; }
5604	public function paintMethodStart ( $ method ) { $ this -> pass = false ; $ this -> fail = false ; $ this -> error = false ; $ this -> method = self :: escapeVal ( $ method ) ; }
1400	public function exception ( \ Exception $ ex ) { if ( $ this -> getCodec ( ) -> willNotEncode ( ) ) { $ this -> codec = $ this -> api -> getDefaultCodec ( ) ; } return $ this -> getErrorResponse ( $ this -> exceptions -> parse ( $ ex ) ) ; }
3300	public function post ( $ url , $ params = [ ] ) { $ key = is_array ( $ params ) ? 'form_params' : 'body' ; return $ this -> request ( 'POST' , $ url , [ $ key => $ params ] ) ; }
8625	public function setTemporarilyUnavailableCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TemporarilyUnavailableCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
706	public function primaryKey ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_PK , $ length ) ; }
1583	public function getRelations ( ) : Collection { return $ this -> getRelationships ( ) -> filter ( function ( array $ relation ) { return array_key_exists ( 'data' , $ relation ) ; } ) -> map ( function ( array $ relation ) { return $ relation [ 'data' ] ; } ) ; }
1872	protected function convertValuesToPaths ( ) { if ( empty ( $ this -> varValue ) ) { return ; } if ( ! \ is_array ( $ this -> varValue ) ) { $ this -> varValue = array ( $ this -> varValue ) ; } elseif ( empty ( $ this -> varValue [ 0 ] ) ) { $ this -> varValue = array ( ) ; } if ( empty ( $ this -> varValue ) ) { return ; } if ( strpos ( $ this -> varValue [ 0 ] , Config :: get ( 'uploadPath' ) . '/' ) === 0 ) { return ; } if ( Input :: get ( 'switch' ) ) { return ; } if ( $ this -> path != '' && strpos ( $ this -> path , Config :: get ( 'uploadPath' ) . '/' ) !== 0 ) { return ; } $ objFiles = FilesModel :: findMultipleByIds ( $ this -> varValue ) ; if ( $ objFiles !== null ) { $ this -> varValue = array_values ( $ objFiles -> fetchEach ( 'path' ) ) ; } }
5758	protected function getFromClause ( ) : string { return "FROM " . self :: TABLE_NAME . " JOIN " . self :: ROLES_JOIN_TABLE_NAME . " ON " . self :: TABLE_NAME . ".id = " . self :: ROLES_JOIN_TABLE_NAME . ".permission_id JOIN " . self :: ROLES_TABLE_NAME . " ON " . self :: ROLES_JOIN_TABLE_NAME . ".role_id=" . self :: ROLES_TABLE_NAME . ".id" ; }
217	public function asImage ( $ value , $ options = [ ] ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return Html :: img ( $ value , $ options ) ; }
5789	protected function setRules ( bool $ skipUniqueForUnchanged = false , array $ record = null ) { $ this -> mapFieldsRules ( $ this -> databaseTableValidation -> getValidationRules ( ) ) ; $ uniqueColumns = $ this -> mapper -> getUniqueColumns ( ) ; if ( count ( $ uniqueColumns ) > 0 ) { $ this -> addUniqueRule ( ) ; foreach ( $ uniqueColumns as $ databaseColumnMapper ) { $ field = $ databaseColumnMapper -> getName ( ) ; if ( ! ( $ skipUniqueForUnchanged && $ this -> inputData [ $ field ] == $ record [ $ field ] ) ) { $ this -> rule ( 'unique' , $ field , $ databaseColumnMapper , $ this ) ; } } } }
9737	public function setWidth ( $ pValue ) { if ( $ this -> resizeProportional && $ pValue != 0 ) { $ ratio = $ this -> height / ( $ this -> width != 0 ? $ this -> width : 1 ) ; $ this -> height = round ( $ ratio * $ pValue ) ; } $ this -> width = $ pValue ; return $ this ; }
8358	public static function niceUrl ( string $ url ) { $ nice = null ; if ( ( $ pos = stripos ( $ url , '.' ) ) !== false ) { list ( $ subDomain , $ url ) = explode ( '.' , $ url ) ; $ request = Http :: getRequest ( ) ; $ nice = $ request -> getRawRequest ( ) -> getScheme ( ) . '://' ; if ( $ subDomain != null ) { $ nice .= $ subDomain . '.' ; } $ nice .= self :: extractDomain ( $ request -> getRawRequest ( ) ) ; } return $ nice . '/' . ltrim ( ( string ) preg_replace ( '/\/+/' , '/' , $ url ) , '/' ) ; }
10847	protected function runCommand ( $ command , $ basePath , $ asset , $ result ) { $ command = Yii :: getAlias ( $ command ) ; $ command = strtr ( $ command , [ '{from}' => escapeshellarg ( "$basePath/$asset" ) , '{to}' => escapeshellarg ( "$basePath/$result" ) , ] ) ; $ descriptor = [ 1 => [ 'pipe' , 'w' ] , 2 => [ 'pipe' , 'w' ] , ] ; $ pipes = [ ] ; $ proc = proc_open ( $ command , $ descriptor , $ pipes , $ basePath ) ; $ stdout = stream_get_contents ( $ pipes [ 1 ] ) ; $ stderr = stream_get_contents ( $ pipes [ 2 ] ) ; foreach ( $ pipes as $ pipe ) { fclose ( $ pipe ) ; } $ status = proc_close ( $ proc ) ; if ( $ status === 0 ) { Yii :: trace ( "Converted $asset into $result:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } elseif ( YII_DEBUG ) { throw new Exception ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" ) ; } else { Yii :: error ( "AssetConverter command '$command' failed with exit code $status:\nSTDOUT:\n$stdout\nSTDERR:\n$stderr" , __METHOD__ ) ; } return $ status === 0 ; }
2442	protected function getUser ( ) : BackendUser { if ( null === $ this -> tokenStorage ) { throw new \ RuntimeException ( 'No token storage provided' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'No token provided' ) ; } $ user = $ token -> getUser ( ) ; if ( ! $ user instanceof BackendUser ) { throw new \ RuntimeException ( 'The token does not contain a back end user object' ) ; } return $ user ; }
9470	protected function loadingGroups ( ) : void { foreach ( $ this -> groups as $ group ) { $ this -> addPattern ( $ group -> toArray ( ) ) ; } }
5028	public function decorateClassMetaData ( ClassMetadata $ c ) { $ parentClassName = $ c -> getName ( ) ; if ( isset ( $ this -> mappings [ $ parentClassName ] ) ) { $ c -> discriminatorMap = array ( ) ; $ c -> discriminatorMap [ strtolower ( Str :: classname ( $ parentClassName ) ) ] = $ parentClassName ; foreach ( $ this -> mappings [ $ parentClassName ] as $ className ) { $ bundlePrefix = Str :: infix ( $ this -> getBundleName ( $ className ) , '-' ) ; $ name = Str :: infix ( Str :: classname ( Str :: rstrip ( $ className , Str :: classname ( $ parentClassName ) ) ) , '-' ) ; $ combinedDiscriminator = sprintf ( '%s-%s' , $ bundlePrefix , $ name ) ; $ c -> discriminatorMap [ $ combinedDiscriminator ] = $ className ; $ c -> subClasses [ ] = $ className ; } $ c -> subClasses = array_unique ( $ c -> subClasses ) ; } }
1614	private function sendCommandInternal ( $ command , $ params ) { $ written = @ fwrite ( $ this -> _socket , $ command ) ; if ( $ written === false ) { throw new SocketException ( "Failed to write to socket.\nRedis command was: " . $ command ) ; } if ( $ written !== ( $ len = mb_strlen ( $ command , '8bit' ) ) ) { throw new SocketException ( "Failed to write to socket. $written of $len bytes written.\nRedis command was: " . $ command ) ; } return $ this -> parseResponse ( implode ( ' ' , $ params ) ) ; }
1661	public function render ( ) { $ mediaObject = [ ] ; $ mediaObject [ 'contentUrl' ] = $ this -> url ; if ( $ this -> name ) { $ mediaObject [ 'name' ] = $ this -> name ; } if ( $ this -> description ) { $ mediaObject [ 'description' ] = $ this -> description ; } if ( $ this -> icon ) { $ mediaObject [ 'icon' ] = [ 'url' => $ this -> icon ] ; } if ( $ this -> image ) { $ mediaObject [ 'largeImage' ] = [ 'url' => $ this -> image ] ; } return $ mediaObject ; }
2131	public function save ( ) { if ( $ this -> strTop == '' ) { $ this -> strTop = '<?php' ; } $ strFile = trim ( $ this -> strTop ) . "\n\n" ; $ strFile .= "### INSTALL SCRIPT START ###\n" ; foreach ( $ this -> arrData as $ k => $ v ) { $ strFile .= "$k = $v\n" ; } $ strFile .= "### INSTALL SCRIPT STOP ###\n" ; $ this -> strBottom = trim ( $ this -> strBottom ) ; if ( $ this -> strBottom != '' ) { $ strFile .= "\n" . $ this -> strBottom . "\n" ; } $ strTemp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objFile = fopen ( $ this -> strRootDir . '/system/tmp/' . $ strTemp , 'wb' ) ; fwrite ( $ objFile , $ strFile ) ; fclose ( $ objFile ) ; if ( ! filesize ( $ this -> strRootDir . '/system/tmp/' . $ strTemp ) ) { System :: log ( 'The local configuration file could not be written. Have your reached your quota limit?' , __METHOD__ , TL_ERROR ) ; return ; } $ this -> Files -> chmod ( 'system/tmp/' . $ strTemp , 0666 & ~ umask ( ) ) ; $ this -> Files -> rename ( 'system/tmp/' . $ strTemp , 'system/config/localconfig.php' ) ; if ( \ function_exists ( 'opcache_invalidate' ) ) { opcache_invalidate ( $ this -> strRootDir . '/system/config/localconfig.php' , true ) ; } if ( \ function_exists ( 'apc_compile_file' ) && ! ini_get ( 'apc.stat' ) ) { apc_compile_file ( $ this -> strRootDir . '/system/config/localconfig.php' ) ; } $ this -> blnIsModified = false ; }
12942	public function create ( $ className , $ username ) { $ reflectionClass = new \ ReflectionClass ( $ className ) ; $ permalinks = $ this -> pagesParser -> contributor ( $ username ) -> parse ( ) -> permalinksByLanguage ( $ this -> configurationHandler -> language ( ) . '_' . $ this -> configurationHandler -> country ( ) ) ; $ permalinksForSelect = ( ! empty ( $ permalinks ) ) ? array_combine ( $ permalinks , $ permalinks ) : array ( ) ; $ params = array ( $ permalinksForSelect ) ; $ form = $ this -> formFactory -> create ( $ reflectionClass -> newInstanceArgs ( $ params ) ) ; return $ form -> createView ( ) ; }
4990	public function disableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array ( ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> disableForm ( $ childForm ) ; } elseif ( isset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ) { unset ( $ this -> forms [ $ k ] [ '__instance__' ] ) ; } } $ this -> activeForms = array_filter ( $ this -> activeForms , function ( $ item ) use ( $ key ) { return ! in_array ( $ item , $ key ) ; } ) ; return $ this ; }
5978	public function objecttypes ( ) { if ( ! $ this -> objecttypes instanceof ObjecttypesController ) { $ this -> objecttypes = new ObjecttypesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> objecttypes -> setLogger ( $ this -> logger ) ; } return $ this -> objecttypes ; }
1399	public function errors ( $ errors , $ defaultStatusCode = null , array $ headers = [ ] ) { if ( $ errors instanceof ErrorResponseInterface ) { return $ this -> getErrorResponse ( $ errors ) ; } if ( is_array ( $ errors ) ) { $ errors = $ this -> api -> getErrors ( ) -> errors ( ... $ errors ) ; } return $ this -> errors ( $ this -> factory -> createErrorResponse ( $ errors , $ defaultStatusCode , $ headers ) ) ; }
1880	protected function isMounted ( $ strFolder ) { if ( $ strFolder == '' ) { return false ; } if ( empty ( $ this -> arrFilemounts ) ) { return true ; } $ path = $ strFolder ; while ( \ is_array ( $ this -> arrFilemounts ) && substr_count ( $ path , '/' ) > 0 ) { if ( \ in_array ( $ path , $ this -> arrFilemounts ) ) { return true ; } $ path = \ dirname ( $ path ) ; } return false ; }
3373	public function indexAction ( ) { $ request = $ this -> getRequest ( ) ; $ this -> httpClient -> setMethod ( Request :: METHOD_POST ) ; $ this -> httpClient -> setParameterPost ( [ 'dsl_text' => $ request -> getPost ( 'dsl_text' ) ] ) ; $ response = $ this -> httpClient -> send ( ) ; if ( ! $ response -> isSuccess ( ) ) { throw new \ UnexpectedValueException ( 'HTTP Request failed' ) ; } $ redirect = $ this -> plugin ( 'redirect' ) ; return $ redirect -> toUrl ( 'https://yuml.me/' . $ response -> getBody ( ) ) ; }
9844	public function createSignedJsonResponse ( int $ status , array $ arrayToJsonify , SigningSecretKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSignedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
5406	protected function findFirstMatch ( $ cookie ) { for ( $ i = 0 ; $ i < count ( $ this -> cookies ) ; $ i ++ ) { $ is_match = $ this -> isMatch ( $ cookie , $ this -> cookies [ $ i ] -> getHost ( ) , $ this -> cookies [ $ i ] -> getPath ( ) , $ this -> cookies [ $ i ] -> getName ( ) ) ; if ( $ is_match ) { return $ i ; } } return count ( $ this -> cookies ) ; }
11928	public function getDataInterface ( ) { if ( ! $ this -> started ) { return $ this -> _interface ; } if ( is_null ( $ this -> _interface ) ) { $ interfaces = ArrayHelper :: map ( Yii :: $ app -> collectors [ 'dataInterfaces' ] -> getAll ( ) , 'systemId' , 'object.name' ) ; $ this -> dataInterface = $ this -> select ( "Choose interface" , $ interfaces ) ; } return $ this -> _interface ; }
6680	public static function getDateTime ( $ format , $ timestamp = 'now' ) { $ date = strtotime ( $ timestamp ) ; if ( ! $ date ) { return $ timestamp ; } return date ( $ format , $ date ) ; }
12066	public function invokeRpcCall ( $ method , $ arguments = [ ] ) { if ( ! is_null ( $ this -> namespace ) ) { $ method = $ this -> namespace . '.' . $ method ; } $ body = XmlRpcBuilder :: createRequest ( $ method , $ arguments ) ; $ guzzle = new \ GuzzleHttp \ Client ( ) ; $ this -> getLogger ( ) -> info ( "sending request for $method to {$this->url}" ) ; $ this -> getLogger ( ) -> debug ( "sending request for $method to {$this->url}, with parameters: " . print_r ( $ arguments , true ) ) ; $ response = $ guzzle -> post ( $ this -> url , [ 'body' => $ body , 'headers' => [ 'User-Agent' => 'Devedge\XmlRpc\Client/' . self :: $ version , 'Content-Type' => 'text/xml' ] ] ) ; if ( $ response -> xml ( ) -> fault -> count ( ) > 0 ) { $ this -> logger -> warning ( "serverside error occured, details: " . $ response -> getBody ( ) ) ; throw XmlRpcParser :: parseFault ( $ response -> xml ( ) -> fault ) ; } return array_shift ( XmlRpcParser :: parseParams ( $ response -> xml ( ) -> params ) ) ; }
5286	private function reset ( ) { $ this -> distinct = false ; $ this -> found_rows = false ; $ this -> limit = null ; $ this -> statements = [ 'select' => [ ] , 'wheres' => [ ] , 'orders' => [ ] , 'values' => [ ] , 'groups' => [ ] , 'having' => '' , ] ; return $ this ; }
3452	public function getAggregateRoot ( string $ aggregateId ) { if ( ! $ this -> disableIdentityMap && isset ( $ this -> identityMap [ $ aggregateId ] ) ) { return $ this -> identityMap [ $ aggregateId ] ; } if ( $ this -> snapshotStore ) { $ eventSourcedAggregateRoot = $ this -> loadFromSnapshotStore ( $ aggregateId ) ; if ( $ eventSourcedAggregateRoot && ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; } $ streamName = $ this -> determineStreamName ( $ aggregateId ) ; if ( $ this -> oneStreamPerAggregate ) { try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 ) ; } catch ( StreamNotFound $ e ) { return null ; } } else { $ metadataMatcher = new MetadataMatcher ( ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_type' , Operator :: EQUALS ( ) , $ this -> aggregateType -> toString ( ) ) ; $ metadataMatcher = $ metadataMatcher -> withMetadataMatch ( '_aggregate_id' , Operator :: EQUALS ( ) , $ aggregateId ) ; try { $ streamEvents = $ this -> eventStore -> load ( $ streamName , 1 , null , $ metadataMatcher ) ; } catch ( StreamNotFound $ e ) { return null ; } } if ( ! $ streamEvents -> valid ( ) ) { return null ; } $ eventSourcedAggregateRoot = $ this -> aggregateTranslator -> reconstituteAggregateFromHistory ( $ this -> aggregateType , $ streamEvents ) ; if ( ! $ this -> disableIdentityMap ) { $ this -> identityMap [ $ aggregateId ] = $ eventSourcedAggregateRoot ; } return $ eventSourcedAggregateRoot ; }
6695	public static function applyVisible ( & $ Nav ) { if ( $ Nav ) { foreach ( $ Nav as & $ one ) { if ( ! isset ( $ one [ 'visible' ] ) ) { if ( isset ( $ one [ 'permission' ] ) ) { $ authItemModel = Yii :: createObject ( AuthItem :: class ) ; $ one [ 'visible' ] = Yii :: $ app -> user -> can ( $ authItemModel :: SUPER_ADMIN ) || Yii :: $ app -> user -> can ( $ one [ 'permission' ] ) ; } else { if ( is_array ( $ one [ 'url' ] ) ) { $ url = explode ( '/' , trim ( $ one [ 'url' ] [ 0 ] , '/' ) ) ; if ( isset ( $ url [ '0' ] ) && isset ( $ url [ '1' ] ) ) { $ one [ 'visible' ] = Yii :: $ app -> user -> can ( 'Super admin' ) || Yii :: $ app -> user -> can ( $ url [ 0 ] . '/' . $ url [ 1 ] ) ; } } } } if ( isset ( $ one [ 'items' ] ) ) { self :: applyVisible ( $ one [ 'items' ] ) ; } } } }
9386	public function retrieve ( $ httpMethod , $ uri ) { $ route = array ( $ httpMethod , $ uri ) ; $ routes = array_map ( function ( $ route ) { return array ( $ route [ 0 ] , $ route [ 1 ] ) ; } , $ this -> routes ) ; $ key = array_search ( $ route , $ routes ) ; return $ key !== false ? $ this -> routes [ $ key ] : null ; }
8315	protected function checkResetLink ( ) { if ( ! $ this -> config [ "enabled" ] || ! ( $ token = $ this -> httpRequest -> query -> get ( "confirm" , false ) ) || ! preg_match ( "/^[a-f0-9]+$/" , $ token ) || strlen ( $ token ) !== 2 * ( $ this -> config [ "tokenIdLen" ] + $ this -> config [ "tokenLen" ] ) ) { return ; } $ this -> session -> remove ( "pwreset" ) ; $ tokenId = substr ( $ token , 0 , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ verifier = substr ( $ token , 2 * $ this -> config [ "tokenIdLen" ] ) ; $ tokenData = $ this -> storage -> getResetToken ( $ tokenId ) ; if ( ! $ tokenData || time ( ) > $ tokenData [ 'valid' ] ) { $ this -> session -> addFlash ( "error" , "Reset link has expired." ) ; $ this -> getLogger ( ) -> warning ( "Bad reset token {t} from {addr}" , [ $ token , $ _SERVER [ 'REMOTE_ADDR' ] ] ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( hash_equals ( $ tokenData [ 'token' ] , hash ( 'sha256' , $ verifier ) ) ) { $ this -> session -> addFlash ( "success" , "Please set a new password." ) ; $ this -> startPasswordResetSession ( $ tokenData [ 'user' ] ) ; $ this -> logResetLinkVisit ( $ tokenData ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
1638	protected function getGuzzle ( array $ config ) { $ options = [ ] ; if ( isset ( $ config [ 'proxy' ] ) && $ config [ 'proxy' ] ) { if ( isset ( $ config [ 'proxy' ] [ 'http' ] ) && php_sapi_name ( ) != 'cli' ) { unset ( $ config [ 'proxy' ] [ 'http' ] ) ; } $ options [ 'proxy' ] = $ config [ 'proxy' ] ; } return Client :: makeGuzzle ( isset ( $ config [ 'endpoint' ] ) ? $ config [ 'endpoint' ] : null , $ options ) ; }
7873	public function credit ( ) : ? array { $ this -> checkConfig ( ) ; $ query = http_build_query ( [ 'userkey' => $ this -> userkey , 'passkey' => $ this -> passkey , ] ) ; $ response = Request :: get ( $ this -> baseUrl . '/smsapibalance.php?' . $ query ) ; $ xml = simplexml_load_string ( $ response -> body ) ; $ body = json_decode ( json_encode ( $ xml ) , true ) ; return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ body [ 'message' ] [ 'text' ] ?? '' , 'data' => $ body , ] ; }
9152	public function view ( $ vars = array ( ) ) { $ output = '' ; $ vars [ 'entity' ] = $ this -> entity ; foreach ( $ this -> fields as $ field ) { if ( ! $ field instanceof Field ) { continue ; } if ( $ field -> getOutputView ( ) === false ) { continue ; } if ( $ field -> getType ( ) == 'hidden' || $ field -> getValueType ( ) == 'hidden' ) { continue ; } if ( $ field -> isHiddenOnProfile ( ) ) { continue ; } $ field_view = $ field -> viewOutput ( $ vars ) ; if ( $ field_view ) { $ output .= elgg_format_element ( 'div' , array ( 'class' => 'prototyper-output' , ) , $ field_view ) ; } } return $ output ; }
9261	public function map ( $ route , $ name , $ handler , array $ methods = array ( 'GET' ) ) { foreach ( $ methods as $ method ) { if ( null === $ name ) { $ this -> addRoute ( $ method , $ route , $ handler ) ; } else { $ this -> addNamedRoute ( $ name , $ method , $ route , $ handler ) ; } } }
4732	protected function set_expiration ( ) { $ this -> exp_variant = time ( ) + ( int ) apply_filters ( 'wp_session_expiration_variant' , 24 * 60 ) ; $ this -> expires = time ( ) + ( int ) apply_filters ( 'wp_session_expiration' , 30 * 60 ) ; }
9967	public function getHyperlink ( $ pCellCoordinate ) { if ( isset ( $ this -> hyperlinkCollection [ $ pCellCoordinate ] ) ) { return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; } $ this -> hyperlinkCollection [ $ pCellCoordinate ] = new Hyperlink ( ) ; return $ this -> hyperlinkCollection [ $ pCellCoordinate ] ; }
12820	public function execute ( callable $ callback , array $ vars ) : Response { $ arguments = $ this -> resolveDependencies ( $ callback , $ vars ) ; return call_user_func_array ( $ callback , $ arguments ) ; }
4182	public static function instance ( ) { switch ( func_num_args ( ) ) { case func_num_args ( ) == 0 : return new static ( ) ; case func_num_args ( ) == 1 : return new static ( func_get_arg ( 0 ) ) ; case func_num_args ( ) == 2 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) ) ; case func_num_args ( ) == 3 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) ) ; case func_num_args ( ) == 4 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) ) ; case func_num_args ( ) == 5 : return new static ( func_get_arg ( 0 ) , func_get_arg ( 1 ) , func_get_arg ( 2 ) , func_get_arg ( 3 ) , func_get_arg ( 4 ) ) ; default : throw new Exception ( 'Unable to instantiate class with given arguments' ) ; } }
9665	public function setHeader ( $ header , $ value ) { if ( strlen ( $ header ) < 1 ) { throw new Exception ( 'Header must be a string.' ) ; } $ this -> customHeaders [ $ header ] = $ value ; return $ this ; }
7027	public function autoLogin ( EntityInterface $ user ) : ? Response { $ controller = $ this -> getController ( ) ; $ request = $ controller -> request ; $ token = $ request -> getQuery ( 't' ) ; if ( empty ( $ token ) ) { return null ; } $ this -> Auth -> logout ( ) ; $ tokenData = $ user -> validateLoginToken ( $ token , $ user -> getKey ( ) , $ user -> getSalt ( ) ) ; if ( ! is_array ( $ tokenData ) ) { return null ; } if ( ! empty ( $ tokenData [ 'addRememberMeCookie' ] ) && $ tokenData [ 'addRememberMeCookie' ] ) { $ this -> addRememberMeCookie ( ( string ) $ user -> id ) ; } $ userData = $ user -> toArray ( ) ; $ userData [ 'user' ] = $ user ; $ this -> Auth -> setUser ( $ userData ) ; if ( ! empty ( $ tokenData [ 'url' ] ) ) { return $ controller -> redirect ( $ tokenData [ 'url' ] ) ; } return $ controller -> redirect ( $ this -> getConfig ( 'defaultRedirect' ) ) ; }
11333	public function setFormat ( $ value ) { if ( is_array ( $ value ) ) { if ( ! isset ( $ value [ 'class' ] ) ) { $ value [ 'class' ] = $ this -> determineFormatClass ( ) ; } $ value [ 'field' ] = $ this ; $ value = Yii :: createObject ( $ value ) ; } $ this -> _format = $ value ; }
10604	public function setQueryParam ( $ name , $ value ) { if ( $ this -> checkQuery ( $ name ) ) { $ this -> editQuery ( $ name , $ value ) ; } else { $ this -> addQuery ( $ name , $ value ) ; } return $ this ; }
2275	public function getLayoutSections ( ) { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
7076	private function addDiscountDetails ( array & $ details , Model \ SaleAdjustmentInterface $ discount ) { $ discountResult = $ discount -> getResult ( ) ; $ details [ 'L_PAYMENTREQUEST_0_NAME' . $ this -> line ] = $ discount -> getDesignation ( ) ; $ details [ 'L_PAYMENTREQUEST_0_AMT' . $ this -> line ] = '-' . $ this -> format ( $ discountResult -> getTotal ( ) ) ; $ this -> line ++ ; return - $ discountResult -> getTotal ( ) ; }
10788	protected function getSearchFacets ( SessionInterface $ session ) { $ facets = $ session -> get ( $ this -> getSessionPrefix ( ) . '_facets' , false ) ; return $ facets ? \ json_decode ( $ facets , true ) : $ this -> getDefaultFacets ( ) ; }
11754	public function lists ( $ msgId , $ index , $ begin , $ count , $ type = 0 ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'begin' => $ begin , 'count' => $ count , 'type' => $ type , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_LIST_COMMENT , $ params ] ) ; }
4569	protected function cast ( $ element ) { if ( $ element instanceof Permission ) { return $ element ; } if ( ! is_array ( $ element ) ) { throw new InvalidArgumentException ( 'Element is not an array.' ) ; } foreach ( [ 'attributes' , 'type' , 'value' , 'title' ] as $ key ) { if ( ! array_key_exists ( $ key , $ element ) ) { throw new InvalidArgumentException ( 'Element is missing key "' . $ key . '".' ) ; } } $ permission = new Permission ( $ element [ 'key' ] , $ element [ 'attributes' ] , $ element [ 'type' ] , $ element [ 'value' ] , $ element [ 'title' ] ) ; return $ permission ; }
12763	public function remove ( $ name , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ this -> exists ( $ name ) ) { $ expire = time ( ) - ( 3600 * 24 * 365 ) ; $ this -> set ( $ name , '' , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } }
9325	protected function registerMarkdown ( ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown' , function ( $ app ) { return new Converter ( $ app [ 'commonmark.docparser' ] , $ app [ 'commonmark.htmlrenderer' ] ) ; } ) ; $ app -> alias ( 'markdown' , Converter :: class ) ; }
1957	public function generate ( ) { if ( $ this -> vimeo == '' ) { return '' ; } if ( TL_MODE == 'BE' ) { $ return = '<p><a href="https://vimeo.com/' . $ this -> vimeo . '" target="_blank" rel="noreferrer noopener">vimeo.com/' . $ this -> vimeo . '</a></p>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
10851	public function executeProcess ( $ command , $ beforeNotice = false , $ afterNotice = false ) : void { $ this -> echo ( 'info' , $ beforeNotice ? ' ' . $ beforeNotice : $ command ) ; $ process = new Process ( $ command , null , null , null , $ this -> option ( 'timeout' ) , null ) ; $ process -> run ( function ( $ type , $ buffer ) { if ( Process :: ERR === $ type ) { $ this -> echo ( 'comment' , $ buffer ) ; } else { $ this -> echo ( 'line' , $ buffer ) ; } } ) ; if ( ! $ process -> isSuccessful ( ) ) { throw new ProcessFailedException ( $ process ) ; } if ( $ this -> progressBar ) { $ this -> progressBar -> advance ( ) ; } if ( $ afterNotice ) { $ this -> echo ( 'info' , $ afterNotice ) ; } }
129	protected function requestContent ( $ origin , $ path ) { $ url = rtrim ( $ origin , '/' ) . '/' . ltrim ( $ path , '/' ) ; $ content = $ this -> rfs -> getContents ( $ origin , $ url , false ) ; if ( ! $ content ) { throw new \ UnexpectedValueException ( 'The PEAR channel at ' . $ url . ' did not respond.' ) ; } return str_replace ( 'http://pear.php.net/rest/' , 'https://pear.php.net/rest/' , $ content ) ; }
5395	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
2578	protected function loadArnk ( Segment \ ArrivalUnknown $ segment ) { $ this -> travelProduct = new TravelProduct ( ) ; $ this -> travelProduct -> productDetails = new ProductDetails ( $ segment -> identification ) ; $ this -> messageAction = new MessageAction ( Business :: FUNC_ARNK ) ; }
1111	public function map ( $ nodeList ) { $ self = $ this ; return $ this -> wrapInTransaction ( function ( ) use ( $ self , $ nodeList ) { forward_static_call ( array ( get_class ( $ self -> node ) , 'unguard' ) ) ; $ result = $ self -> mapTree ( $ nodeList ) ; forward_static_call ( array ( get_class ( $ self -> node ) , 'reguard' ) ) ; return $ result ; } ) ; }
11269	public function getPath ( Neuron_GameServer_Map_Location $ start , Neuron_GameServer_Map_Location $ end ) { $ x1 = $ start [ 0 ] ; $ y1 = $ start [ 1 ] ; $ x2 = $ end [ 0 ] ; $ y2 = $ end [ 1 ] ; if ( ! $ this -> isPassable ( $ x2 , $ y2 ) ) { return false ; } $ astar = $ this -> astar ( $ start , $ end ) ; return $ astar ; }
6470	public function parseAcceptLanguageHeader ( HttpHeaders $ headers ) : array { $ headerValues = [ ] ; if ( ! $ headers -> tryGet ( 'Accept-Language' , $ headerValues ) ) { return [ ] ; } $ parsedHeaderValues = [ ] ; $ numHeaderValues = count ( $ headerValues ) ; for ( $ i = 0 ; $ i < $ numHeaderValues ; $ i ++ ) { $ parsedHeaderParameters = $ this -> parseParameters ( $ headers , 'Accept-Language' , $ i ) ; $ language = $ parsedHeaderParameters -> getKeys ( ) [ 0 ] ; $ parsedHeaderValues [ ] = new AcceptLanguageHeaderValue ( $ language , $ parsedHeaderParameters ) ; } return $ parsedHeaderValues ; }
7187	public function getAssignmentById ( $ id ) { foreach ( $ this -> unit -> getStockAssignments ( ) as & $ assignment ) { if ( $ assignment -> getId ( ) === $ id ) { return $ assignment ; } } return null ; }
11083	public static function passwdGen ( $ length = 8 , $ flag = 'ALPHANUMERIC' ) { switch ( $ flag ) { case 'NUMERIC' : $ str = '0123456789' ; break ; case 'ALPHA' : $ str = 'abcdefghijkmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; case 'ALPHA_LOWER' : $ str = 'abcdefghijkmnopqrstuvwxyz' ; break ; default : $ str = 'abcdefghijkmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' ; break ; } for ( $ i = 0 , $ passwd = '' ; $ i < $ length ; $ i ++ ) { $ passwd .= substr ( $ str , mt_rand ( 0 , \ strlen ( $ str ) - 1 ) , 1 ) ; } return $ passwd ; }
8870	public function detach ( Runner $ runner ) { if ( ! $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t detach not attached runner.' ) ; } $ this -> runners -> detach ( $ runner ) ; return $ this ; }
138	public function update ( RepositoryInterface $ repo , UpdateOperation $ operation ) { $ initial = $ operation -> getInitialPackage ( ) ; $ target = $ operation -> getTargetPackage ( ) ; $ initialType = $ initial -> getType ( ) ; $ targetType = $ target -> getType ( ) ; if ( $ initialType === $ targetType ) { $ installer = $ this -> getInstaller ( $ initialType ) ; $ installer -> update ( $ repo , $ initial , $ target ) ; $ this -> markForNotification ( $ target ) ; } else { $ this -> getInstaller ( $ initialType ) -> uninstall ( $ repo , $ initial ) ; $ this -> getInstaller ( $ targetType ) -> install ( $ repo , $ target ) ; } }
9957	public function protectCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 , $ password , $ alreadyHashed = false ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> protectCells ( $ cellRange , $ password , $ alreadyHashed ) ; }
5560	public function recordEntry ( $ url , $ parameters ) { $ this -> dropFuture ( ) ; array_push ( $ this -> sequence , array ( 'url' => $ url , 'parameters' => $ parameters ) ) ; $ this -> position ++ ; }
1582	public function withRelationships ( $ relationships ) : self { $ copy = clone $ this ; $ copy -> relationships = collect ( $ relationships ) -> all ( ) ; $ copy -> normalize ( ) ; return $ copy ; }
1102	protected function hasChange ( ) { return ! ( $ this -> bound1 ( ) == $ this -> node -> getRight ( ) || $ this -> bound1 ( ) == $ this -> node -> getLeft ( ) ) ; }
1519	public function addToRelationship ( StoreInterface $ store , UpdateRelationship $ request ) { $ result = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doAddToRelationship ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ result ) ) { return $ result ; } return $ this -> reply ( ) -> noContent ( ) ; }
440	public function canGetProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { if ( method_exists ( $ this , 'get' . $ name ) || $ checkVars && property_exists ( $ this , $ name ) ) { return true ; } elseif ( $ checkBehaviors ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name , $ checkVars ) ) { return true ; } } } return false ; }
10494	public function div ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ value == 0 ) { throw new InvalidArgumentException ( 'Division by zero' ) ; } if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value / $ value ) ; }
1922	public static function fromFile ( File $ file ) { $ extension = strtolower ( $ file -> extension ) ; $ function = null ; if ( $ extension === 'jpg' ) { $ extension = 'jpeg' ; } if ( \ in_array ( $ extension , array ( 'gif' , 'jpeg' , 'png' ) ) ) { $ function = 'imagecreatefrom' . $ extension ; } if ( $ function === null || ! \ is_callable ( $ function ) ) { throw new \ InvalidArgumentException ( 'Image type "' . $ file -> extension . '" cannot be processed by GD' ) ; } $ image = $ function ( System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ file -> path ) ; if ( $ image === false ) { throw new \ RuntimeException ( 'Image "' . $ file -> path . '" failed to be processed by GD' ) ; } return new static ( $ image ) ; }
12006	final public function getAuthorityTree ( ) { $ database = $ this -> database ; $ statement = $ database -> select ( ) -> from ( '?authority' ) -> between ( "lft" , '1' , '6' ) -> prepare ( ) ; $ results = $ statement -> execute ( ) ; $ right = array ( ) ; }
5030	public function findPageBy ( $ repository , $ conditions ) { $ ret = $ this -> em -> getRepository ( $ repository ) -> findOneBy ( $ conditions ) ; if ( ! $ ret ) { throw new NotFoundHttpException ; } return $ ret ; }
8527	private function _convertListFinancialEventGroups ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroups' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedAfter ( ) ) { $ parameters [ 'FinancialEventGroupStartedAfter' ] = $ request -> getFinancialEventGroupStartedAfter ( ) ; } if ( $ request -> isSetFinancialEventGroupStartedBefore ( ) ) { $ parameters [ 'FinancialEventGroupStartedBefore' ] = $ request -> getFinancialEventGroupStartedBefore ( ) ; } return $ parameters ; }
3150	public function comment ( RunnerServiceContext $ context , $ comment ) { $ testSession = $ context -> getTestSession ( ) ; $ item = $ testSession -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ occurrence = $ testSession -> getCurrentAssessmentItemRefOccurence ( ) ; $ sessionId = $ testSession -> getSessionId ( ) ; $ transmissionId = "${sessionId}.${item}.${occurrence}" ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ transmitter = new \ taoQtiCommon_helpers_ResultTransmitter ( $ resultStore ) ; $ itemUri = TestRunnerUtils :: getCurrentItemUri ( $ testSession ) ; $ testUri = $ testSession -> getTest ( ) -> getUri ( ) ; $ variable = new ResponseVariable ( 'comment' , Cardinality :: SINGLE , BaseType :: STRING , new QtismString ( $ comment ) ) ; $ transmitter -> transmitItemVariable ( $ variable , $ transmissionId , $ itemUri , $ testUri ) ; return true ; }
1949	public function showRelatedRecords ( $ data , $ row ) { Contao \ System :: loadLanguageFile ( 'tl_opt_in_related' ) ; Contao \ Controller :: loadDataContainer ( 'tl_opt_in_related' ) ; $ objRelated = $ this -> Database -> prepare ( "SELECT * FROM tl_opt_in_related WHERE pid=?" ) -> execute ( $ row [ 'id' ] ) ; while ( $ objRelated -> next ( ) ) { $ arrAdd = array ( ) ; $ arrRow = $ objRelated -> row ( ) ; foreach ( $ arrRow as $ k => $ v ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ 'tl_opt_in_related' ] [ 'fields' ] [ $ k ] [ 'label' ] ; $ arrAdd [ $ label ] = $ v ; } $ data [ 'tl_opt_in_related' ] [ ] = $ arrAdd ; } return $ data ; }
5702	public function isCustomActionAllowed ( $ action ) { $ actions = $ this -> owner -> config ( ) -> better_buttons_actions ; if ( $ actions ) { return in_array ( $ action , $ actions ) ; } return false ; }
598	public function joinWith ( $ with , $ eagerLoading = true , $ joinType = 'LEFT JOIN' ) { $ relations = [ ] ; foreach ( ( array ) $ with as $ name => $ callback ) { if ( is_int ( $ name ) ) { $ name = $ callback ; $ callback = null ; } if ( preg_match ( '/^(.*?)(?:\s+AS\s+|\s+)(\w+)$/i' , $ name , $ matches ) ) { list ( , $ relation , $ alias ) = $ matches ; $ name = $ relation ; $ callback = function ( $ query ) use ( $ callback , $ alias ) { $ query -> alias ( $ alias ) ; if ( $ callback !== null ) { call_user_func ( $ callback , $ query ) ; } } ; } if ( $ callback === null ) { $ relations [ ] = $ name ; } else { $ relations [ $ name ] = $ callback ; } } $ this -> joinWith [ ] = [ $ relations , $ eagerLoading , $ joinType ] ; return $ this ; }
9374	protected function dispatcher ( ResponseInterface $ response , $ stack ) { $ dispatcher = new Dispatcher ( $ stack , $ response ) ; if ( class_exists ( 'Zend\Stratigility\MiddlewarePipe' ) ) { $ pipe = new MiddlewarePipe ; $ dispatcher = new StratigilityDispatcher ( $ pipe , $ stack , $ response ) ; } return $ dispatcher ; }
6966	public function clearIdentity ( ) { $ this -> gender = null ; $ this -> firstName = null ; $ this -> lastName = null ; return $ this ; }
9606	public function multiplyByScalar ( $ scalar ) { $ result = [ ] ; foreach ( $ this -> components ( ) as $ i => $ component ) { $ result [ $ i ] = $ component * $ scalar ; } return new static ( $ result ) ; }
8340	public static function set ( string $ fileName , array $ content ) { try { $ json = Yaml :: dump ( $ content , 2 ) ; if ( file_put_contents ( $ fileName , $ json ) === false ) { throw new FileNotWritable ( 'can\'t write to "' . $ fileName . '"' ) ; } } catch ( DumpException $ e ) { throw new BadUse ( 'Config::set() content parameter can\'t be dump to YAML' ) ; } self :: $ files [ $ fileName ] = $ content ; }
4263	public function unsubscribe ( $ eventName , $ callable ) { if ( ! isset ( $ this -> subscribers [ $ eventName ] ) ) { return ; } if ( $ this -> isClosureFactory ( $ callable ) ) { $ callable [ 0 ] = $ callable [ 0 ] ( ) ; } foreach ( $ this -> subscribers [ $ eventName ] as $ priority => $ subscribers ) { foreach ( $ subscribers as $ k => $ v ) { if ( $ v !== $ callable && $ this -> isClosureFactory ( $ v ) ) { $ v [ 0 ] = $ v [ 0 ] ( ) ; } if ( $ v === $ callable ) { unset ( $ subscribers [ $ k ] , $ this -> sorted [ $ eventName ] ) ; } else { $ subscribers [ $ k ] = $ v ; } } if ( $ subscribers ) { $ this -> subscribers [ $ eventName ] [ $ priority ] = $ subscribers ; } else { unset ( $ this -> subscribers [ $ eventName ] [ $ priority ] ) ; } } }
7385	public function uploadAction ( ) { if ( $ this -> request -> hasFiles ( ) == true ) { $ this -> initializeScaffolding ( ) ; $ form = $ this -> scaffolding -> getForm ( ) ; $ name = key ( $ _FILES ) ; $ uploadElement = $ form -> get ( $ name ) ; $ model = $ uploadElement -> getModel ( ) ; $ path = $ uploadElement -> getPath ( ) ; $ maxFileSize = $ uploadElement -> getMaxFileSize ( ) ; $ minFileSize = $ uploadElement -> getMinFileSize ( ) ; foreach ( $ this -> request -> getUploadedFiles ( ) as $ file ) { $ fileName = $ file -> getName ( ) ; $ fileSize = $ file -> getSize ( ) ; $ fileType = $ file -> getRealType ( ) ; $ fileExtensions = pathinfo ( $ fileName , PATHINFO_EXTENSION ) ; $ allowed = $ uploadElement -> getAllowedExtensions ( ) ; if ( ! empty ( $ allowed ) ) { if ( ! in_array ( $ fileExtensions , $ allowed ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ forbidden = $ uploadElement -> getForbiddenExtensions ( ) ; if ( ! empty ( $ forbidden ) ) { if ( in_array ( $ fileExtensions , $ forbidden ) ) { throw new ForbiddenFileExtensionException ( ) ; } } $ allowedMime = $ uploadElement -> getAllowedMimeTypes ( ) ; if ( ! empty ( $ allowedMime ) ) { if ( ! in_array ( $ fileType , $ allowedMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } $ forbiddenMime = $ uploadElement -> getForbiddenMimeTypes ( ) ; if ( ! empty ( $ forbiddenMime ) ) { if ( in_array ( $ fileType , $ forbiddenMime ) ) { throw new ForbiddenFileMimeTypeException ( ) ; } } if ( ! empty ( $ maxFileSize ) ) { if ( $ fileSize > $ this -> convertFileSizeToBytes ( $ maxFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( ! empty ( $ minFileSize ) ) { if ( $ fileSize < $ this -> convertFileSizeToBytes ( $ minFileSize ) ) { throw new \ Exception ( 's' ) ; } } if ( empty ( $ path ) ) { $ path = 'files/' ; } $ model -> name = $ fileName ; $ model -> mime_type = $ fileType ; $ model -> path = $ path ; $ model -> save ( ) ; $ file -> moveTo ( $ path . $ model -> _id ) ; return $ this -> response -> setJsonContent ( ( string ) $ model -> _id ) ; } } $ this -> view -> setRenderLevel ( View :: LEVEL_NO_RENDER ) ; }
8187	public function hasBlock ( $ name , array $ context = null , array $ blocks = array ( ) ) { if ( null === $ context ) { @ trigger_error ( 'The ' . __METHOD__ . ' method is internal and should never be called; calling it directly is deprecated since version 1.28 and won\'t be possible anymore in 2.0.' , E_USER_DEPRECATED ) ; return isset ( $ this -> blocks [ ( string ) $ name ] ) ; } if ( isset ( $ blocks [ $ name ] ) ) { return $ blocks [ $ name ] [ 0 ] instanceof self ; } if ( isset ( $ this -> blocks [ $ name ] ) ) { return true ; } if ( false !== $ parent = $ this -> getParent ( $ context ) ) { return $ parent -> hasBlock ( $ name , $ context ) ; } return false ; }
7766	public function getContextAction ( $ type ) { $ context = $ this -> get ( 'hydra.api' ) -> getContext ( $ type ) ; if ( null === $ context ) { $ this -> createNotFoundException ( ) ; } return new JsonLdResponse ( $ context ) ; }
7403	public static function reload ( $ file , $ rangePath = null ) { if ( ! empty ( $ rangePath ) ) { self :: $ rangePath = $ rangePath ; } if ( PHP_SAPI === 'cli' ) { $ cilpath = realpath ( dirname ( dirname ( dirname ( dirname ( __FILE__ ) ) ) ) ) . '/config/' ; $ file = $ cilpath . $ file . '.' . self :: $ format ; } else { $ file = self :: $ rangePath . $ file . '.' . self :: $ format ; } $ name = strtolower ( $ file ) ; $ type = pathinfo ( $ file , PATHINFO_EXTENSION ) ; if ( self :: $ format == $ type ) return self :: set ( include $ file ) ; }
11848	private function checkReadOnly ( ) { if ( true === $ this -> _readOnly ) { $ this -> _pushError ( '' , self :: ERR_READ_ONLY , 'This row has been marked read-only' ) ; return false ; } return true ; }
12566	public function sendVideo ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_VIDEO , $ message , $ to ) ; }
11785	public function pagination ( $ begin , $ count ) { $ params = [ 'type' => 2 , 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SEARCH , $ params ] ) ; }
9646	public function build ( ) : Route { return new $ this -> routeClass ( $ this -> methods , $ this -> path , $ this -> target , $ this -> matchers , $ this -> name ) ; }
1503	public function handle ( $ request , Closure $ next , string $ namespace ) { $ api = $ this -> bindApi ( $ namespace , $ request -> getSchemeAndHttpHost ( ) . $ request -> getBaseUrl ( ) ) ; $ this -> substituteBindings ( $ api ) ; $ this -> bindPageResolver ( ) ; return $ next ( $ request ) ; }
6190	public function renderJSON ( $ data , $ status = 200 ) { exit ( Response :: Create ( json_encode ( $ data ) ) -> status ( $ status ) -> headers ( [ 'Content-Type' => 'application/json' ] ) -> display ( ) ) ; }
9961	public function freezePane ( $ cell , $ topLeftCell = null ) { if ( is_string ( $ cell ) && Coordinate :: coordinateIsRange ( $ cell ) ) { throw new Exception ( 'Freeze pane can not be set on a range of cells.' ) ; } if ( $ cell !== null && $ topLeftCell === null ) { $ coordinate = Coordinate :: coordinateFromString ( $ cell ) ; $ topLeftCell = $ coordinate [ 0 ] . $ coordinate [ 1 ] ; } $ this -> freezePane = $ cell ; $ this -> topLeftCell = $ topLeftCell ; return $ this ; }
8241	protected function getDirFiles ( $ searchDir ) { $ files = @ scandir ( $ searchDir , SCANDIR_SORT_NONE ) ; if ( $ files === false ) { throw new \ RuntimeException ( "Cannot list directory contents: {$searchDir}." ) ; } return array_diff ( $ files , array ( '..' , '.' ) ) ; }
848	public function getNonWhitespaceSibling ( $ index , $ direction , $ whitespaces = null ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } $ token = $ this [ $ index ] ; if ( ! $ token -> isWhitespace ( $ whitespaces ) ) { return $ index ; } } }
3890	protected function buildFilterParamsFor ( \ DC_Table $ dataContainer , $ elementName ) { if ( ! $ this -> requestStack -> getCurrentRequest ( ) -> query -> get ( 'act' ) ) { return ; } $ filterId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'c.metamodel_filtering' ) -> from ( static :: $ tableName , 'c' ) -> join ( 'c' , 'tl_metamodel' , 'mm' , 'mm.id=c.metamodel' ) -> where ( 'c.id=:id' ) -> setParameter ( 'id' , $ dataContainer -> id ) -> andWhere ( 'c.type=:type' ) -> setParameter ( 'type' , $ elementName ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_COLUMN ) ; if ( ! $ filterId ) { unset ( $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] ) ; return ; } $ collection = $ this -> filterFactory -> createCollection ( $ filterId ) ; $ dca = $ collection -> getParameterDCA ( ) ; foreach ( $ dca as $ fieldName => $ subField ) { $ options = [ ] ; foreach ( $ subField [ 'options' ] as $ key => $ value ) { $ options [ $ this -> loadCallback ( $ key ) ] = $ value ; } $ dca [ $ fieldName ] [ 'options' ] = $ options ; $ dca [ $ fieldName ] [ 'save_callback' ] [ ] = [ static :: class , 'saveCallback' ] ; $ dca [ $ fieldName ] [ 'load_callback' ] [ ] = [ static :: class , 'loadCallback' ] ; } $ GLOBALS [ 'TL_DCA' ] [ static :: $ tableName ] [ 'fields' ] [ 'metamodel_filterparams' ] [ 'eval' ] [ 'subfields' ] = $ dca ; }
279	private function notifyNotFound ( $ fixtures ) { $ this -> stdout ( "Some fixtures were not found under path:\n" , Console :: BG_RED ) ; $ this -> stdout ( "\t" . $ this -> getFixturePath ( ) . "\n\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "Check that they have correct namespace \"{$this->namespace}\" \n" , Console :: BG_RED ) ; $ this -> outputList ( $ fixtures ) ; $ this -> stdout ( "\n" ) ; }
5967	public function tempPasswordList ( $ resolve = false ) { $ passwords = $ this -> request ( "servertemppasswordlist" ) -> toAssocArray ( "pw_clear" ) ; if ( $ resolve ) { foreach ( $ passwords as $ password => $ array ) { try { $ channel = $ this -> channelGetById ( $ array [ "tcid" ] ) ; $ passwords [ $ password ] [ "tcname" ] = $ channel -> toString ( ) ; $ passwords [ $ password ] [ "tcpath" ] = $ channel -> getPathway ( ) ; } catch ( Ts3Exception $ e ) { if ( $ e -> getCode ( ) != 0xA00 ) { throw $ e ; } } } } return $ passwords ; }
1584	public function withMeta ( $ meta ) : self { $ copy = clone $ this ; $ copy -> meta = collect ( $ meta ) -> all ( ) ; return $ copy ; }
6689	public function setSessionAndRedirect ( $ key , $ value , $ redirectUrl ) { $ this -> getSession ( ) -> set ( $ key , $ value ) ; return $ this -> redirect ( $ redirectUrl ) ; }
12126	public function validate ( string $ sValue = null ) : bool { if ( $ this -> _sType == 'DateTime' ) { if ( preg_match ( '#^[0-9]{4}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}#' , $ sValue ) ) { return true ; } } return false ; }
672	public function upgrade ( ) { $ owner = $ this -> owner ; if ( $ owner -> getIsNewRecord ( ) ) { throw new InvalidCallException ( 'Upgrading the model version is not possible on a new record.' ) ; } $ lock = $ this -> getLockAttribute ( ) ; $ version = $ owner -> $ lock ? : 0 ; $ owner -> updateAttributes ( [ $ lock => $ version + 1 ] ) ; }
10479	protected function inlineContext ( $ selectQuery , $ itemRow ) { $ selectQuery = str_replace ( [ 'OLD.' , 'NEW.' ] , '__ctx__' , $ selectQuery ) ; $ prefixedKeys = array_map ( function ( $ key ) { return '__ctx__' . $ key ; } , array_keys ( $ itemRow ) ) ; $ connection = $ this -> getConnection ( ) ; $ escapedValues = array_map ( function ( $ value ) use ( $ connection ) { return $ connection -> quote ( $ value ) ; } , array_values ( $ itemRow ) ) ; $ sql = str_replace ( $ prefixedKeys , $ escapedValues , $ selectQuery ) ; return $ sql ; }
4471	public function requeue ( ? string $ queue = null , array $ opts = [ ] ) : string { $ opts = array_merge ( [ 'delay' => 0 , 'data' => $ this -> data , 'priority' => $ this -> priority , 'retries' => $ this -> retries , 'tags' => $ this -> tags , 'depends' => $ this -> dependencies , ] , $ opts ) ; $ queueName = $ queue ? : $ this -> queue ; $ data = json_encode ( $ opts [ 'data' ] , JSON_UNESCAPED_SLASHES ) ? : '{}' ; return $ this -> client -> requeue ( $ this -> worker , $ queueName , $ this -> jid , $ this -> klass , $ data , $ opts [ 'delay' ] , 'priority' , $ opts [ 'priority' ] , 'tags' , json_encode ( $ opts [ 'tags' ] , JSON_UNESCAPED_SLASHES ) , 'retries' , $ opts [ 'retries' ] , 'depends' , json_encode ( $ opts [ 'depends' ] , JSON_UNESCAPED_SLASHES ) ) ; }
505	public function init ( ) { parent :: init ( ) ; if ( ! isset ( $ this -> translations [ 'yii' ] ) && ! isset ( $ this -> translations [ 'yii*' ] ) ) { $ this -> translations [ 'yii' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => 'en-US' , 'basePath' => '@yii/messages' , ] ; } if ( ! isset ( $ this -> translations [ 'app' ] ) && ! isset ( $ this -> translations [ 'app*' ] ) ) { $ this -> translations [ 'app' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'sourceLanguage' => Yii :: $ app -> sourceLanguage , 'basePath' => '@app/messages' , ] ; } }
5499	public function respond ( $ step , $ method , $ args ) { $ method = strtolower ( $ method ) ; if ( isset ( $ this -> at [ $ method ] [ $ step ] ) ) { if ( $ this -> at [ $ method ] [ $ step ] -> isMatch ( $ args ) ) { $ action = $ this -> at [ $ method ] [ $ step ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } } if ( isset ( $ this -> always [ $ method ] ) ) { $ action = $ this -> always [ $ method ] -> findFirstAction ( $ args ) ; if ( isset ( $ action ) ) { return $ action -> act ( ) ; } } return ; }
12016	public function unwatch ( ) { if ( ! $ this -> client -> getCommandFactory ( ) -> supportsCommand ( 'UNWATCH' ) ) { throw new NotSupportedException ( 'UNWATCH is not supported by the current command factory.' ) ; } $ this -> state -> unflag ( MultiExecState :: WATCH ) ; $ this -> __call ( 'UNWATCH' , array ( ) ) ; return $ this ; }
4031	private function updateImageWithDisabled ( ModelInterface $ model , $ image ) { $ this -> preCreateInverseImage ( $ model , $ image ) ; if ( $ model -> getProperty ( 'enabled' ) ) { return $ image ; } if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return $ image ; } return substr_replace ( $ image , '_1' , $ intPos , 0 ) ; }
6488	protected function getClientIPAddress ( array $ server ) : ? string { $ serverRemoteAddress = $ server [ 'REMOTE_ADDR' ] ?? null ; if ( $ this -> isUsingTrustedProxy ( $ server ) ) { return $ serverRemoteAddress ?? null ; } $ ipAddresses = [ ] ; if ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ) ) { $ header = $ server [ $ this -> trustedHeaderNames [ 'HTTP_FORWARDED' ] ] ; preg_match_all ( "/for=(?:\"?\[?)([a-z0-9:\.\-\/_]*)/" , $ header , $ matches ) ; $ ipAddresses = $ matches [ 1 ] ; } elseif ( isset ( $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ) { $ ipAddresses = explode ( ',' , $ server [ $ this -> trustedHeaderNames [ 'HTTP_CLIENT_IP' ] ] ) ; $ ipAddresses = array_map ( 'trim' , $ ipAddresses ) ; } if ( $ serverRemoteAddress !== null ) { $ ipAddresses [ ] = $ serverRemoteAddress ; } $ fallbackIPAddresses = count ( $ ipAddresses ) === 0 ? [ ] : [ $ ipAddresses [ 0 ] ] ; foreach ( $ ipAddresses as $ index => $ ipAddress ) { if ( filter_var ( $ ipAddress , FILTER_VALIDATE_IP , FILTER_FLAG_IPV4 ) === false ) { unset ( $ ipAddresses [ $ index ] ) ; } if ( in_array ( $ ipAddress , $ this -> trustedProxyIPAddresses , true ) ) { unset ( $ ipAddresses [ $ index ] ) ; } } $ clientIPAddresses = count ( $ ipAddresses ) === 0 ? $ fallbackIPAddresses : array_reverse ( $ ipAddresses ) ; return $ clientIPAddresses [ 0 ] ?? null ; }
5888	public function getClass ( $ prefix = "ts3_" ) { if ( $ this instanceof Channel && $ this -> isSpacer ( ) ) { return $ prefix . "spacer" ; } elseif ( $ this instanceof Client && $ this [ "client_type" ] ) { return $ prefix . "query" ; } return $ prefix . StringHelper :: factory ( get_class ( $ this ) ) -> toLower ( ) ; }
9877	private function writeFileVersion ( XMLWriter $ objWriter ) { $ objWriter -> startElement ( 'fileVersion' ) ; $ objWriter -> writeAttribute ( 'appName' , 'xl' ) ; $ objWriter -> writeAttribute ( 'lastEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'lowestEdited' , '4' ) ; $ objWriter -> writeAttribute ( 'rupBuild' , '4505' ) ; $ objWriter -> endElement ( ) ; }
10943	public function encode ( $ rawString ) { $ bytes = unpack ( 'C*' , $ rawString ) ; $ byteCount = count ( $ bytes ) ; $ encodedString = '' ; $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; $ chars = $ this -> chars ; $ bitsPerCharacter = $ this -> bitsPerCharacter ; $ rightPadFinalBits = $ this -> rightPadFinalBits ; $ padFinalGroup = $ this -> padFinalGroup ; $ padCharacter = $ this -> padCharacter ; for ( $ c = 0 ; $ c < $ byteCount * 8 / $ bitsPerCharacter ; ++ $ c ) { if ( $ bitsRead + $ bitsPerCharacter > 8 ) { $ oldBitCount = 8 - $ bitsRead ; $ oldBits = $ byte ^ ( $ byte >> $ oldBitCount << $ oldBitCount ) ; $ newBitCount = $ bitsPerCharacter - $ oldBitCount ; if ( ! $ bytes ) { if ( $ rightPadFinalBits ) { $ oldBits <<= $ newBitCount ; } $ encodedString .= $ chars [ $ oldBits ] ; if ( $ padFinalGroup ) { $ lcmMap = array ( 1 => 1 , 2 => 1 , 3 => 3 , 4 => 1 , 5 => 5 , 6 => 3 , 7 => 7 , 8 => 1 ) ; $ bytesPerGroup = $ lcmMap [ $ bitsPerCharacter ] ; $ pads = $ bytesPerGroup * 8 / $ bitsPerCharacter - ceil ( ( strlen ( $ rawString ) % $ bytesPerGroup ) * 8 / $ bitsPerCharacter ) ; $ encodedString .= str_repeat ( $ padCharacter [ 0 ] , $ pads ) ; } break ; } $ byte = array_shift ( $ bytes ) ; $ bitsRead = 0 ; } else { $ oldBitCount = 0 ; $ newBitCount = $ bitsPerCharacter ; } $ bits = $ byte >> 8 - ( $ bitsRead + ( $ newBitCount ) ) ; $ bits ^= $ bits >> $ newBitCount << $ newBitCount ; $ bitsRead += $ newBitCount ; if ( $ oldBitCount ) { $ bits = ( $ oldBits << $ newBitCount ) | $ bits ; } $ encodedString .= $ chars [ $ bits ] ; } return $ encodedString ; }
2025	public static function findPublishedByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , $ varId , $ arrOptions ) ; }
7364	protected function updateInvoiceTotal ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return false ; } $ changed = false ; $ invoice = $ this -> invoiceCalculator -> calculateInvoiceTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ invoice , $ sale -> getInvoiceTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setInvoiceTotal ( $ invoice ) ; $ changed = true ; } $ credit = $ this -> invoiceCalculator -> calculateCreditTotal ( $ sale ) ; if ( 0 != Money :: compare ( $ credit , $ sale -> getCreditTotal ( ) , $ sale -> getCurrency ( ) -> getCode ( ) ) ) { $ sale -> setCreditTotal ( $ credit ) ; $ changed = true ; } return $ changed ; }
7978	public function setSshKey ( $ key ) { self :: getClient ( ) -> setSshKey ( $ this -> pp , $ this -> sn , $ key ) ; }
6308	public function setA ( StringType $ name , Attribute $ attribute ) { if ( $ this -> hasA ( $ name ) ) { $ this -> attributes = $ this -> attributes -> kDiff ( new AttributeMap ( [ $ name ( ) => $ attribute ] ) ) ; } $ this -> attributes = $ this -> attributes -> append ( [ $ name ( ) => $ attribute ] ) ; return $ this ; }
11299	function getFullClassName ( $ class = false ) { if ( $ class == false ) { $ class = $ this ; } $ className = get_class ( $ class ) ; if ( $ pos = strpos ( $ className , '\\' ) ) return substr ( $ className , $ pos + 1 ) ; return $ className ; }
11542	public function confirmEmail ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
11368	public static function deduplicate ( $ array ) { if ( empty ( $ array ) ) { return $ array ; } $ known = array ( ) ; foreach ( $ array as $ _index => $ entry ) { if ( is_array ( $ entry ) ) { foreach ( $ entry as $ i => $ _email ) { if ( ! in_array ( $ _email , $ known ) ) { $ known [ ] = $ _email ; } else { unset ( $ array [ $ _index ] ) ; } } } elseif ( is_string ( $ entry ) ) { if ( ! in_array ( $ entry , $ known ) ) { $ known [ ] = $ entry ; } else { unset ( $ array [ $ _index ] ) ; } } } return $ array ; }
5435	public function getSignature ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; $ method = $ interface -> getMethod ( $ name ) ; $ abstract = ( $ method -> isAbstract ( ) && ! $ interface -> isInterface ( ) && ! $ this -> isAbstractMethodInParents ( $ name ) ) ? 'abstract ' : '' ; if ( $ method -> isPublic ( ) ) { $ visibility = 'public' ; } elseif ( $ method -> isProtected ( ) ) { $ visibility = 'protected' ; } else { $ visibility = 'private' ; } $ static = $ method -> isStatic ( ) ? 'static ' : '' ; $ reference = $ method -> returnsReference ( ) ? '&' : '' ; $ params = $ this -> getParameterSignatures ( $ method ) ; $ returnType = $ this -> getReturnType ( $ method ) ; return "{$abstract}$visibility {$static}function $reference$name($params){$returnType}" ; }
10703	public function loadLanguage ( $ controller , $ language = 'en_US' , $ return = FALSE ) { $ langDirEvent = new GetLanguageDirEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_LANG_DIR , $ langDirEvent ) ; $ langDir = $ langDirEvent -> getLangDir ( ) ; $ retVal = FALSE ; if ( NULL === $ langDir ) { $ retVal = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ language . '_lang.php' ; if ( ! file_exists ( $ file ) ) { $ defaultLangEvent = new GetDefaultLanguageEvent ( ) ; $ this -> dispatcher -> fire ( Events :: EVENT_GET_DEFAULT_LANG , $ defaultLangEvent ) ; $ defaultLang = $ defaultLangEvent -> getDefaultLanguage ( ) ; if ( NULL === $ defaultLang ) { $ retval = FALSE ; } else { $ file = $ langDir . $ controller . DS . $ defaultLang . '_lang.php' ; } } if ( NULL === $ file ) { throw new RawException ( 'Failed to load language file for ' . $ controller ) ; } $ lang = include_once $ file ; $ this -> language = array_merge ( $ this -> language , $ lang ) ; $ retVal = $ lang ; } return $ retVal ; }
7569	public function getJobApiService ( ) { $ apiService = new \ Greenhouse \ GreenhouseToolsPhp \ Services \ JobApiService ( $ this -> _boardToken ) ; $ apiClient = new GuzzleClient ( array ( 'base_uri' => ApiService :: jobBoardBaseUrl ( $ this -> _boardToken ) ) ) ; $ apiService -> setClient ( $ apiClient ) ; return $ apiService ; }
4076	protected function getMetaModelName ( $ nameOrId ) { return isset ( $ this -> tableMap [ $ nameOrId ] ) ? $ this -> tableMap [ $ nameOrId ] : $ nameOrId ; }
3579	protected function metaJoinQuery ( Builder $ query , $ method , ArgumentBag $ args ) { $ alias = $ this -> joinMeta ( $ query , $ args -> get ( 'column' ) ) ; $ method = $ args -> get ( 'function' ) ? : $ method ; return ( in_array ( $ method , [ 'orderBy' , 'lists' , 'pluck' ] ) ) ? $ this -> { "{$method}Meta" } ( $ query , $ args , $ alias ) : $ this -> metaSingleResult ( $ query , $ method , $ alias ) ; }
8748	public function addMethodCall ( $ methodName , array $ arguments = array ( ) ) { $ this -> actions [ ] = $ methodCall = new MethodCall ( $ methodName , $ arguments ) ; return $ methodCall ; }
7484	public function endsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( $ this -> length ( ) - mb_strlen ( $ string , $ this -> encoding ) ) -> __toString ( ) ; }
3111	public function getStorageService ( ) { if ( ! $ this -> storageService ) { $ this -> storageService = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storageService ; }
11378	public function postAction ( ) { if ( ! preg_match ( '/\/page\/(\w+[\-\w]*)\/text\/(..)$/' , $ this -> name , $ matches ) ) { throw new InvalidParameterException ( "Invalid parameters" ) ; } list ( $ dummy , $ pageName , $ language ) = $ matches ; $ request = $ this -> environment -> getRequestHelper ( ) ; $ name = $ request -> getIdentifierParam ( 'name' ) ; $ content = $ request -> getParam ( 'content' , '' ) ; try { $ pageTexts = $ this -> getTextModel ( $ pageName ) ; $ text = $ pageTexts -> addTextContainer ( $ name , $ this -> filter ( $ content ) , $ language ) ; $ this -> environment -> sendJSONResult ( $ text ) ; } catch ( \ Exception $ e ) { throw new InvalidParameterException ( $ e -> getMessage ( ) ) ; } }
5908	public function listUsers ( $ includeDeleted = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'includeDeleted' => $ includeDeleted ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new User ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
1458	protected function previous ( Cursor $ cursor , $ columns ) { $ items = $ this -> whereId ( $ cursor -> getBefore ( ) , $ this -> descending ? '>' : '<' ) -> orderForPrevious ( ) -> get ( $ cursor -> getLimit ( ) , $ columns ) -> reverse ( ) -> values ( ) ; return new CursorPaginator ( $ items , true , $ cursor , $ this -> key ) ; }
5217	protected static function getBindingsForApp ( $ className ) { $ bindings = method_exists ( $ className , '__bindings' ) ? $ className :: __bindings ( ) : [ ] ; if ( ! Runtime :: initialized ( ) ) { $ bindings [ ] = static :: runtime ( ) ; } return $ bindings ; }
2655	public function createCondition ( $ version , array $ condition ) { $ checkIfExists = $ this -> getCondition ( $ version , $ condition [ 'name' ] ) ; $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/condition' ; if ( ! $ checkIfExists ) { $ verb = \ Zend_Http_Client :: POST ; } else { $ verb = \ Zend_Http_Client :: PUT ; $ url .= '/' . $ condition [ 'name' ] ; } $ result = $ this -> _fetch ( $ url , $ verb , $ condition ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to create a REQUEST condition.' ) ) ; } return $ result ; }
4794	function group ( $ columns , $ having = "" ) { $ this -> __destruct ( ) ; $ this -> group = $ columns ; $ this -> having = $ having ; return $ this ; }
5372	public function merge ( $ query ) { if ( is_object ( $ query ) ) { $ this -> request = array_merge ( $ this -> request , $ query -> getAll ( ) ) ; } elseif ( is_array ( $ query ) ) { foreach ( $ query as $ key => $ value ) { $ this -> add ( $ key , $ value ) ; } } }
3406	public function loadCommands ( string $ path , string $ namespace = "" , string $ suffix = "Command" ) : Application { $ commands = [ ] ; $ realpath = ( string ) realpath ( $ path ) ; $ finder = ( new Finder ( ) ) -> files ( ) -> in ( $ path ) -> name ( "/[A-Z].*{$suffix}.php/" ) ; foreach ( $ finder as $ file ) { $ filename = ( string ) $ file -> getRealPath ( ) ; require_once $ filename ; $ class = $ filename ; $ class = str_replace ( $ realpath , "" , $ class ) ; $ class = str_replace ( ".php" , "" , $ class ) ; $ class = str_replace ( "/" , "\\" , $ class ) ; $ command = $ class ; if ( substr ( $ command , 0 , 1 ) == "\\" ) { $ command = substr ( $ command , 1 ) ; } $ command = ( string ) preg_replace_callback ( "/^([A-Z])(.*){$suffix}$/" , function ( $ match ) { return strtolower ( $ match [ 1 ] ) . $ match [ 2 ] ; } , $ command ) ; $ command = preg_replace_callback ( "/(\\\\)?([A-Z])/" , function ( $ match ) { $ result = ( $ match [ 1 ] ) ? ":" : "-" ; $ result .= strtolower ( $ match [ 2 ] ) ; return $ result ; } , $ command ) ; $ class = $ namespace . $ class ; $ reflected = new \ ReflectionClass ( $ class ) ; if ( ! $ reflected -> isInstantiable ( ) ) { continue ; } $ commands [ ] = new $ class ( $ command ) ; } if ( count ( $ commands ) < 1 ) { throw new \ InvalidArgumentException ( "No commands were found in the path (" . $ path . ")" ) ; } $ this -> addCommands ( $ commands ) ; return $ this ; }
1118	public static function allLeaves ( ) { $ instance = new static ; $ grammar = $ instance -> getConnection ( ) -> getQueryGrammar ( ) ; $ rgtCol = $ grammar -> wrap ( $ instance -> getQualifiedRightColumnName ( ) ) ; $ lftCol = $ grammar -> wrap ( $ instance -> getQualifiedLeftColumnName ( ) ) ; return $ instance -> newQuery ( ) -> whereRaw ( $ rgtCol . ' - ' . $ lftCol . ' = 1' ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
7942	public function addSecondaryDnsDomains ( $ domain , $ domain2add , $ ip ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2add = ( string ) $ domain2add ; if ( ! $ domain2add ) throw new BadMethodCallException ( 'Parameter $domain2add is missing.' ) ; $ ip = ( string ) $ ip ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( "domain" => $ domain2add , "ip" => $ ip ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
2276	public function getActivationDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'emailText' ] ) ; } return $ varValue ; }
6174	protected function delete ( $ path , $ file ) { return $ this -> driver -> delete ( $ this -> root . $ path , $ file ) ; }
4758	protected function transformCacheAnnotation ( Cache $ cache ) { return array ( 'expires' => $ cache -> getExpires ( ) , 'maxage' => $ cache -> getMaxAge ( ) , 'smaxage' => $ cache -> getSMaxAge ( ) , 'public' => $ this -> transformBoolean ( $ cache -> isPublic ( ) ) , 'vary' => $ cache -> getVary ( ) , 'lastModified' => $ cache -> getLastModified ( ) , 'etag' => $ cache -> getETag ( ) , ) ; }
2313	public function executeResize ( ) { $ image = $ this -> prepareImage ( ) ; $ resizeConfig = $ this -> prepareResizeConfig ( ) ; if ( ! System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) && $ this -> getTargetPath ( ) && ! $ this -> getForceOverride ( ) && file_exists ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) && $ this -> fileObj -> mtime <= filemtime ( $ this -> strRootDir . '/' . $ this -> getTargetPath ( ) ) ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'executeResize' ] as $ callback ) { $ return = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ this ) ; if ( \ is_string ( $ return ) ) { $ this -> resizedPath = System :: urlEncode ( $ return ) ; return $ this ; } } } $ this -> resizedPath = System :: urlEncode ( $ this -> getTargetPath ( ) ) ; return $ this ; } $ image = System :: getContainer ( ) -> get ( 'contao.image.resizer' ) -> resize ( $ image , $ resizeConfig , ( new ResizeOptions ( ) ) -> setImagineOptions ( System :: getContainer ( ) -> getParameter ( 'contao.image.imagine_options' ) ) -> setTargetPath ( $ this -> targetPath ? $ this -> strRootDir . '/' . $ this -> targetPath : null ) -> setBypassCache ( System :: getContainer ( ) -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; $ this -> resizedPath = $ image -> getUrl ( $ this -> strRootDir ) ; return $ this ; }
836	public static function clearCache ( $ key = null ) { if ( null === $ key ) { self :: $ cache = [ ] ; return ; } if ( self :: hasCache ( $ key ) ) { unset ( self :: $ cache [ $ key ] ) ; } }
2289	protected function activateRecipient ( ) { $ this -> Template = new FrontendTemplate ( 'mod_newsletter' ) ; $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) < 1 || key ( $ arrRelated ) != 'tl_newsletter_recipients' || \ count ( $ arrIds = current ( $ arrRelated ) ) < 1 ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } $ arrRecipients = array ( ) ; foreach ( $ arrIds as $ intId ) { if ( ! $ objRecipient = NewsletterRecipientsModel :: findByPk ( $ intId ) ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objRecipient -> email ) { $ this -> Template -> type = 'error' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ arrRecipients [ ] = $ objRecipient ; } $ time = time ( ) ; $ arrAdd = array ( ) ; $ arrCids = array ( ) ; foreach ( $ arrRecipients as $ objRecipient ) { $ arrAdd [ ] = $ objRecipient -> id ; $ arrCids [ ] = $ objRecipient -> pid ; $ objRecipient -> tstamp = $ time ; $ objRecipient -> active = '1' ; $ objRecipient -> save ( ) ; } $ optInToken -> confirm ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'activateRecipient' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ optInToken -> getEmail ( ) , $ arrAdd , $ arrCids ) ; } } $ this -> Template -> mclass = 'confirm' ; $ this -> Template -> message = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'nl_activate' ] ; }
291	public function populateRelation ( $ name , $ records ) { foreach ( $ this -> _relationsDependencies as & $ relationNames ) { unset ( $ relationNames [ $ name ] ) ; } $ this -> _related [ $ name ] = $ records ; }
1996	protected function adjustPublicationDate ( ) { if ( ! empty ( $ this -> arrItems ) && $ this -> arrItems [ 0 ] -> published > $ this -> published ) { $ this -> published = $ this -> arrItems [ 0 ] -> published ; } }
7648	public function stream_close ( ) { @ fclose ( $ this -> temporaryFileHandle ) ; if ( $ this -> writeMode ) { $ containerExists = $ this -> getStorageClient ( $ this -> fileName ) -> containerExists ( $ this -> getContainerName ( $ this -> fileName ) ) ; if ( ! $ containerExists ) { $ this -> getStorageClient ( $ this -> fileName ) -> createContainer ( $ this -> getContainerName ( $ this -> fileName ) ) ; } try { $ this -> getStorageClient ( $ this -> fileName ) -> putBlob ( $ this -> getContainerName ( $ this -> fileName ) , $ this -> getFileName ( $ this -> fileName ) , $ this -> temporaryFileName ) ; } catch ( BlobException $ ex ) { @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; throw $ ex ; } } @ unlink ( $ this -> temporaryFileName ) ; unset ( $ this -> storageClient ) ; }
10857	public function getMarked ( string $ marker ) : array { if ( ! \ is_subclass_of ( $ marker , Marker :: class ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Marker implementation %s must extend %s' , $ marker , Marker :: class ) ) ; } if ( ! isset ( $ this -> marked [ $ marker ] ) ) { $ this -> cacheMarkers ( $ marker ) ; } return \ array_map ( function ( array $ marked ) { return $ this -> shared [ $ marked [ 0 ] -> typeName ] ?? $ this -> get ( $ marked [ 0 ] -> typeName ) ; } , $ this -> marked [ $ marker ] ) ; }
1612	private function _setCriteriaIdByType ( $ criteria , Element $ type , $ id ) { switch ( $ type :: className ( ) ) { case 'Entry' : $ criteria -> sectionId = $ id ; break ; case 'Category' : $ criteria -> groupId = $ id ; break ; } }
4409	protected function render ( $ template , $ parameters ) { $ twig = new Twig_Environment ( new Twig_Loader_Filesystem ( $ this -> skeletonDirs ) , array ( 'debug' => true , 'cache' => false , 'strict_variables' => true , 'autoescape' => false , ) ) ; return $ twig -> render ( $ template , $ parameters ) ; }
3711	protected function generateElement ( $ table , $ content , $ replace , $ elementId ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE id=? AND type="metamodels_frontendclearall"' , $ table ) ; $ statement = $ this -> connection -> prepare ( $ sql ) ; $ statement -> bindValue ( 1 , $ elementId ) ; $ statement -> execute ( ) ; $ objDbResult = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ; if ( $ objDbResult === false ) { return str_replace ( $ replace , '' , $ content ) ; } if ( $ table == 'tl_module' ) { $ objElement = new ModuleFilterClearAll ( $ objDbResult ) ; } elseif ( $ table == 'tl_content' ) { $ objElement = new ContentElementFilterClearAll ( $ objDbResult ) ; } else { return str_replace ( $ replace , '' , $ content ) ; } return str_replace ( $ replace , $ objElement -> generateReal ( ) , $ content ) ; }
5351	public function setDatabasePassword ( $ domainName , $ database , $ password ) { return $ this -> call ( self :: SERVICE , 'setDatabasePassword' , [ $ domainName , $ database , $ password ] ) ; }
953	public function authenticate ( AuthShop $ request ) { $ validated = $ request -> validated ( ) ; $ shopDomain = ShopifyApp :: sanitizeShopDomain ( $ validated [ 'shop' ] ) ; $ shop = ShopifyApp :: shop ( $ shopDomain ) ; $ auth = new AuthShopHandler ( $ shop ) ; $ session = new ShopSession ( $ shop ) ; if ( ! $ request -> has ( 'code' ) ) { $ authUrl = $ auth -> buildAuthUrl ( $ shop -> hasOfflineAccess ( ) ? Config :: get ( 'shopify-app.api_grant_mode' ) : ShopSession :: GRANT_OFFLINE ) ; return View :: make ( 'shopify-app::auth.fullpage_redirect' , compact ( 'authUrl' , 'shopDomain' ) ) ; } $ access = $ auth -> getAccess ( $ validated [ 'code' ] ) ; $ session -> setDomain ( $ shopDomain ) ; $ session -> setAccess ( $ access ) ; $ auth -> postProcess ( ) ; $ auth -> dispatchJobs ( $ session ) ; return $ this -> returnTo ( ) ; }
7102	public static function site ( string $ uri = '' , $ protocol = null ) : string { $ path = preg_replace ( '~^[-a-z0-9+.]++://[^/]++/?~' , '' , trim ( $ uri , '/' ) ) ; if ( preg_match ( '/[^\x00-\x7F]/S' , $ path ) ) { $ path = preg_replace_callback ( '~([^/]+)~' , '\mii\util\URL::_rawurlencode_callback' , $ path ) ; } return URL :: base ( $ protocol ) . $ path ; }
10150	private function readHeader ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddHeader ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenHeader ( $ string [ 'value' ] ) ; } } }
5123	private function getAttachmentEndPoint ( string $ idArticle , string $ field ) : string { return $ this -> replaceEndPointId ( $ idArticle , $ this -> attachmentUrl [ $ field ] ) ; }
9884	private function writeNamedRanges ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { $ namedRanges = $ spreadsheet -> getNamedRanges ( ) ; foreach ( $ namedRanges as $ namedRange ) { $ this -> writeDefinedNameForNamedRange ( $ objWriter , $ namedRange ) ; } }
4272	public function stream_close ( ) { if ( ! $ this -> handle ) { return ; } self :: restorePrev ( ) ; \ fclose ( $ this -> handle ) ; $ this -> handle = null ; self :: register ( ) ; }
4826	public function getAsDom ( ) { if ( is_null ( $ this -> node ) ) { $ this -> node = XmlUtil :: createXmlDocumentFromStr ( "<row></row>" ) ; $ root = $ this -> node -> getElementsByTagName ( "row" ) -> item ( 0 ) ; foreach ( $ this -> row as $ key => $ value ) { if ( ! is_array ( $ value ) ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ value ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } else { foreach ( $ value as $ valueItem ) { $ field = XmlUtil :: createChild ( $ root , "field" , $ valueItem ) ; XmlUtil :: addAttribute ( $ field , "name" , $ key ) ; } } } } return $ this -> node ; }
2446	public function checkPermission ( ) { switch ( Contao \ Input :: get ( 'act' ) ) { case 'select' : case 'show' : break ; case 'edit' : case 'delete' : case 'toggle' : $ objComment = $ this -> Database -> prepare ( "SELECT id, parent, source FROM tl_comments WHERE id=?" ) -> limit ( 1 ) -> execute ( Contao \ Input :: get ( 'id' ) ) ; if ( $ objComment -> numRows < 1 ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid comment ID ' . Contao \ Input :: get ( 'id' ) . '.' ) ; } if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Not enough permissions to ' . Contao \ Input :: get ( 'act' ) . ' comment ID ' . Contao \ Input :: get ( 'id' ) . ' (parent element: ' . $ objComment -> source . ' ID ' . $ objComment -> parent . ').' ) ; } break ; case 'editAll' : case 'deleteAll' : case 'overrideAll' : $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> all ( ) ; if ( empty ( $ session [ 'CURRENT' ] [ 'IDS' ] ) || ! \ is_array ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ) { break ; } $ objComment = $ this -> Database -> execute ( "SELECT id, parent, source FROM tl_comments WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) . ")" ) ; while ( $ objComment -> next ( ) ) { if ( ! $ this -> isAllowedToEditComment ( $ objComment -> parent , $ objComment -> source ) && ( $ key = array_search ( $ objComment -> id , $ session [ 'CURRENT' ] [ 'IDS' ] ) ) !== false ) { unset ( $ session [ 'CURRENT' ] [ 'IDS' ] [ $ key ] ) ; } } $ session [ 'CURRENT' ] [ 'IDS' ] = array_values ( $ session [ 'CURRENT' ] [ 'IDS' ] ) ; $ objSession -> replace ( $ session ) ; break ; default : if ( \ strlen ( Contao \ Input :: get ( 'act' ) ) ) { throw new Contao \ CoreBundle \ Exception \ AccessDeniedException ( 'Invalid command "' . Contao \ Input :: get ( 'act' ) . '.' ) ; } break ; } }
12315	public function sortAction ( Request $ request ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; if ( $ request -> isXmlHttpRequest ( ) ) { $ this -> get ( 'admin_manager' ) -> sort ( 'BlogBundle:Category' , $ request -> get ( 'values' ) ) ; return new Response ( 0 , 200 ) ; } $ categories = $ em -> getRepository ( 'BlogBundle:Category' ) -> findBy ( array ( 'parentCategory' => NULL ) , array ( 'order' => 'asc' ) ) ; return array ( 'categories' => $ categories ) ; }
2536	protected function getWsdlIdFor ( $ messageName ) { $ msgAndVer = $ this -> getMessagesAndVersions ( ) ; if ( isset ( $ msgAndVer [ $ messageName ] ) && isset ( $ msgAndVer [ $ messageName ] [ 'wsdl' ] ) ) { return $ msgAndVer [ $ messageName ] [ 'wsdl' ] ; } return null ; }
8900	public function update_by ( ) { $ args = func_get_args ( ) ; $ data = array_pop ( $ args ) ; $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ this -> _set_where ( $ args ) ; return $ this -> _update ( $ data ) ; } return FALSE ; }
11217	public static function getMethod ( $ route ) { $ route = Url :: addBackSlash ( $ route ) ; return isset ( self :: $ routes [ $ route ] ) ? self :: $ routes [ $ route ] : null ; }
8309	public function assertIntOrFalse ( $ config , $ key , $ lowest = null , $ highest = null ) { try { $ this -> assertInteger ( $ config , $ key , $ lowest , $ highest ) ; } catch ( ConfigurationException $ e ) { if ( $ config [ $ key ] !== false ) { throw new ConfigurationException ( "Key `{$key}` can be either false or a non-negative integer." ) ; } } return $ this ; }
3908	public function setAcceptedExtensions ( $ acceptedExtensions ) { $ allowedDownload = StringUtil :: trimsplit ( ',' , $ GLOBALS [ 'TL_CONFIG' ] [ 'allowedDownload' ] ) ; if ( ! is_array ( $ acceptedExtensions ) ) { $ acceptedExtensions = StringUtil :: trimsplit ( ',' , $ acceptedExtensions ) ; } $ this -> acceptedExtensions = array_map ( 'strtolower' , array_intersect ( $ allowedDownload , $ acceptedExtensions ) ) ; }
3213	static function checkArgOrNull ( $ argName , $ argValue ) { if ( $ argValue === null ) return ; if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
9673	private function writeNumFmt ( XMLWriter $ objWriter , NumberFormat $ pNumberFormat , $ pId = 0 ) { $ formatCode = $ pNumberFormat -> getFormatCode ( ) ; if ( $ formatCode !== null ) { $ objWriter -> startElement ( 'numFmt' ) ; $ objWriter -> writeAttribute ( 'numFmtId' , ( $ pId + 164 ) ) ; $ objWriter -> writeAttribute ( 'formatCode' , $ formatCode ) ; $ objWriter -> endElement ( ) ; } }
3869	protected function getMetaModel ( $ identifier , $ ignoreError ) { $ factory = $ this -> getMetaModelsFactory ( ) ; if ( is_numeric ( $ identifier ) ) { $ identifier = $ factory -> translateIdToMetaModelName ( $ identifier ) ; } $ metaModels = $ factory -> getMetaModel ( $ identifier ) ; if ( ! $ ignoreError && $ metaModels == null ) { throw new \ RuntimeException ( 'Could not find the MetaModels with the name ' . $ identifier ) ; } return $ metaModels ; }
7641	protected function getErrorMessage ( $ response , $ alternativeError = 'Unknown error.' ) { $ xml = $ this -> parseResponse ( $ response ) ; if ( $ xml && $ xml -> Message ) { return "[" . $ response -> getStatusCode ( ) . "] " . ( string ) $ xml -> Message . "\n" . ( string ) $ xml -> AuthenticationErrorDetail ; } else { return $ alternativeError ; } }
6232	public function setPickupPoint ( $ pickup_point_id ) { $ service = new AdditionalService ( ) ; $ service -> setServiceCode ( 2106 ) ; $ service -> addSpecifier ( 'pickup_point_id' , $ pickup_point_id ) ; $ this -> addAdditionalService ( $ service ) ; }
5895	public function listImageTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/images' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new ImageTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
3407	public function setLockStore ( StoreInterface $ store ) : Factory { $ this -> lockFactory = new Factory ( $ store ) ; return $ this -> lockFactory ; }
7901	protected function runUpload ( $ file ) { $ this -> provider -> setFile ( $ file ) ; if ( ! $ this -> provider -> isValid ( ) ) { throw new InvalidFileException ( "Given file [{$file}] is invalid." ) ; } $ filename = $ this -> getFullFileName ( $ this -> provider ) ; if ( $ this -> filesystem -> disk ( $ this -> disk ) -> put ( $ filename , $ this -> provider -> getContents ( ) , $ this -> getVisibility ( ) ) ) { return $ filename ; } return false ; }
12323	protected function askQuestions ( InputInterface $ input , OutputInterface $ output ) { foreach ( $ this -> questions as $ question ) { if ( ! $ question -> ask ( $ input , $ output ) ) { return static :: RETURN_ERROR ; } } return static :: RETURN_SUCCESS ; }
1338	public static function defaultApi ( string $ name ) : self { if ( empty ( $ name ) ) { throw new \ InvalidArgumentException ( 'Default API name must not be empty.' ) ; } self :: $ defaultApi = $ name ; return new self ( ) ; }
12224	public function paginate ( $ keys = [ ] , $ perPage = null ) { $ this -> buildIfNotBuilded ( ) ; $ keys = $ keys == [ ] ? $ this -> keys ( ) : $ keys ; if ( ! $ keys ) { return $ this -> builder -> paginate ( $ perPage ) ; } return $ this -> builder -> withColumns ( $ keys ) -> paginate ( $ perPage ) ; }
10317	function getUniqueBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; return $ this -> get ( 'reports/bounces/unique/count' , $ params ) ; }
4697	public static function validate ( $ request_data = array ( ) , $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; return false ; } elseif ( empty ( $ request_data [ $ token_name ] ) ) { return false ; } else { if ( static :: compare ( $ request_data [ $ token_name ] , static :: getToken ( $ token_name ) ) ) { static :: generateToken ( $ token_name ) ; return true ; } else { return false ; } } }
8934	public function fetch ( $ name ) { $ template = false ; if ( array_key_exists ( $ name , $ this -> templates ) ) { $ template = $ this -> templates [ $ name ] ; } return $ template ; }
8440	public function createAction ( string $ production_slug , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { $ production_repo = $ this -> em -> getRepository ( Production :: class ) ; if ( null === $ production = $ production_repo -> findOneBy ( [ 'slug' => $ production_slug ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ auth -> isGranted ( 'GROUP_ROLE_USER' , $ production ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; $ post = new Post ( ) ; $ post -> setActive ( true ) ; $ post -> setPinned ( false ) ; $ post -> setAuthor ( $ user -> getUsername ( ) ) ; $ post -> addGroup ( $ production ) ; if ( $ request -> query -> has ( 'reply-to' ) ) { $ repo = $ this -> em -> getRepository ( Post :: class ) ; if ( null === $ parent = $ repo -> findOneBy ( [ 'id' => $ request -> query -> get ( 'reply-to' ) ] ) ) { throw new NotFoundHttpException ( ) ; } if ( ! $ parent -> getGroups ( ) -> contains ( $ production ) ) { throw new AccessDeniedException ( ) ; } if ( null !== $ parent -> getParent ( ) ) { throw new AccessDeniedException ( ) ; } $ post -> setParent ( $ parent ) ; $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> persist ( $ post ) ; $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.created' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/create.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
9636	public function write ( $ path , $ contents , $ blocking = false ) { $ flockFlags = $ blocking ? LOCK_EX : LOCK_EX | LOCK_NB ; $ file = fopen ( $ path , 'c' ) ; if ( ! flock ( $ file , $ flockFlags ) ) { fclose ( $ file ) ; throw new IOException ( "Could not aquire file lock for file: $path" ) ; } ftruncate ( $ file , 0 ) ; fwrite ( $ file , $ contents ) ; fflush ( $ file ) ; flock ( $ file , LOCK_UN | LOCK_NB ) ; fclose ( $ file ) ; }
1084	private function expectKeyword ( $ value ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === Token :: NAME && $ token -> value === $ value ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , 'Expected "' . $ value . '", found ' . $ token -> getDescription ( ) ) ; }
7401	private function getErrors ( Form $ form ) { $ errors = array ( ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { return $ errors ; } $ id = $ form -> createView ( ) -> vars [ 'id' ] ; foreach ( $ form -> getErrors ( ) as $ error ) { if ( ! isset ( $ errors [ $ id ] ) ) { $ errors [ $ id ] = array ( ) ; } $ errors [ $ id ] [ ] = $ error -> getMessage ( ) ; } foreach ( $ form -> all ( ) as $ child ) { $ errors = array_merge ( $ this -> getErrors ( $ child ) , $ errors ) ; } return $ errors ; }
6389	public function readFacetofaceSession ( $ id ) { $ model = $ this -> readObject ( $ id , 'facetoface_sessions' ) ; $ model -> dates = $ this -> readStoreRecords ( 'facetoface_sessions_dates' , [ 'sessionid' => $ id ] ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/facetoface/signup.php?s=' . $ id ; return $ model ; }
10715	public function update ( Model $ model , array $ newAttributes ) { $ results = $ model -> update ( $ newAttributes ) ; if ( ! $ results ) { throw new UpdateFailedRepositoryException ( ) ; } return $ model ; }
1822	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> imageSizes ) || ! \ is_array ( $ this -> User -> imageSizes ) ) { $ imageSizes = array ( ) ; } else { $ imageSizes = $ this -> User -> imageSizes ; } if ( \ in_array ( $ insertId , $ imageSizes ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_image_size' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_image_size' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, themes, imageSizes FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrThemes = Contao \ StringUtil :: deserialize ( $ objGroup -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objGroup -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT themes, imageSizes FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrThemes = Contao \ StringUtil :: deserialize ( $ objUser -> themes ) ; if ( \ is_array ( $ arrThemes ) && \ in_array ( 'image_sizes' , $ arrThemes ) ) { $ arrImageSizes = Contao \ StringUtil :: deserialize ( $ objUser -> imageSizes , true ) ; $ arrImageSizes [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET imageSizes=? WHERE id=?" ) -> execute ( serialize ( $ arrImageSizes ) , $ this -> User -> id ) ; } } $ imageSizes [ ] = $ insertId ; $ this -> User -> imageSizes = $ imageSizes ; } }
10836	private function compileUsing ( array $ join ) { $ sql = array ( ) ; list ( $ using , $ table , $ type , $ column ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "USING({$column})" ) ; return join ( ' ' , $ sql ) ; }
4467	private function reload ( ) : void { $ this -> sha = ( string ) @ sha1_file ( $ this -> corePath ) ; if ( empty ( $ this -> sha ) ) { throw new RuntimeException ( 'Unable to locate qless-core file at path: ' . $ this -> corePath ) ; } $ res = $ this -> redis -> script ( 'exists' , $ this -> sha ) ; if ( $ res [ 0 ] !== 1 ) { $ this -> sha = $ this -> redis -> script ( 'load' , file_get_contents ( $ this -> corePath ) ) ; } }
10261	public function getEmail ( $ person_name = null , $ domain = null ) { $ username = $ this -> getUsername ( $ person_name ) ; $ domains = [ ] ; $ domains [ ] = ! empty ( $ domain ) ? $ domain : $ this -> getDomain ( ) ; $ domains [ ] = 'gmail.com' ; $ domains [ ] = 'yahoo.com' ; $ domains [ ] = 'me.com' ; $ domains [ ] = 'msn.com' ; $ domains [ ] = 'hotmail.com' ; $ domain = $ this -> fromArray ( $ domains ) ; return preg_replace ( '/[^0-9a-z_A-Z.]/' , '' , strtolower ( $ username ) ) . '@' . $ domain ; }
4043	public function addAdditionalParentHeaderFields ( GetParentHeaderEvent $ event ) { $ parentModel = $ event -> getModel ( ) ; if ( ! $ parentModel instanceof Model ) { return ; } $ environment = $ event -> getEnvironment ( ) ; $ definition = $ environment -> getDataDefinition ( ) ; $ item = $ parentModel -> getItem ( ) ; $ metaModel = $ item -> getMetaModel ( ) ; $ renderSetting = $ this -> renderSettingFactory -> createCollection ( $ metaModel , $ definition -> getMetaModelDefinition ( ) -> getActiveRenderSetting ( ) ) ; $ additional = array ( ) ; foreach ( $ renderSetting -> getSettingNames ( ) as $ name ) { $ parsed = $ item -> parseAttribute ( $ name , 'text' , $ renderSetting ) ; $ name = $ item -> getAttribute ( $ name ) -> getName ( ) ; $ additional [ $ name ] = $ parsed [ 'text' ] ; } $ additional = array_merge ( $ additional , $ event -> getAdditional ( ) ) ; $ event -> setAdditional ( $ additional ) ; }
5526	protected function createCodeForSubclass ( $ methods ) { $ code = "" ; if ( ! empty ( $ this -> namespace ) ) { $ code .= 'namespace ' . $ this -> namespace . ";\n" ; } $ code .= 'class ' . $ this -> mock_class . ' extends ' . $ this -> class . " {\n" ; $ code .= " public \$mock;\n" ; $ code .= $ this -> addMethodList ( array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ) ; $ code .= "\n" ; $ code .= " function __construct() {\n" ; $ code .= ' $this->mock = new \\' . $ this -> mock_base . "();\n" ; $ code .= " \$this->mock->disableExpectationNameChecks();\n" ; $ code .= " }\n" ; $ code .= $ this -> createCodeForConstructor ( ) ; $ code .= $ this -> chainMockReturns ( ) ; $ code .= $ this -> chainMockExpectations ( ) ; $ code .= $ this -> chainThrowMethods ( ) ; $ code .= $ this -> createCodeForOverridenMethods ( $ this -> reflection -> getMethods ( ) ) ; $ code .= $ this -> createCodeForNewMethod ( $ methods ) ; $ code .= "}\n" ; return $ code ; }
9628	protected function validateParams ( Route $ route , array $ params , array $ requiredParams ) { $ identifier = $ this -> getRouteIdentifier ( $ route ) ; $ givenParams = array_keys ( $ params ) ; $ missingParams = array_diff ( $ requiredParams , $ givenParams ) ; if ( count ( $ missingParams ) > 0 ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validating params "%s": Required parameters "%s" are missing' , $ identifier , implode ( ', ' , $ missingParams ) ) ) ; } if ( ! $ this -> matchParams ( $ route , $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Error while validing params for target "%s": Params don\'t fulfill their matcher\'s criteria' , $ identifier ) ) ; } }
12627	public function format ( $ format = null ) { if ( null === $ format ) { $ format = $ this -> _format ; } return parent :: format ( $ format ) ; }
10042	public function validatePlugin ( $ plugin ) { if ( $ plugin instanceof Storage \ StorageInterface ) { return ; } throw new Storage \ Exception \ RuntimeException ( sprintf ( 'Plugin of type %s is invalid; must implement %s\Storage\StorageInterfaceInterface' , ( is_object ( $ plugin ) ? get_class ( $ plugin ) : gettype ( $ plugin ) ) , __NAMESPACE__ ) ) ; }
2008	private function loadLanguageFile ( string $ name ) : void { $ system = $ this -> framework -> getAdapter ( System :: class ) ; $ system -> loadLanguageFile ( $ name ) ; }
11144	protected function processClass ( $ class ) { if ( ! class_exists ( '\\' . $ class ) ) { throw new ExtDirectException ( " '{$class}' does not exist!" ) ; } $ annotationReader = new AnnotationReader ( ) ; AnnotationRegistry :: registerLoader ( 'class_exists' ) ; $ reflectionClass = new ReflectionClass ( $ class ) ; $ classAnnotation = $ annotationReader -> getClassAnnotation ( $ reflectionClass , 'ExtDirect\Annotations\Direct' ) ; if ( $ classAnnotation instanceof \ ExtDirect \ Annotations \ Direct ) { $ classAnnotation -> setClassName ( $ class ) ; $ methodCollection = new RemotableCollection ( ) ; foreach ( $ reflectionClass -> getMethods ( ) as $ reflectionMethod ) { $ methodAnnotation = $ annotationReader -> getMethodAnnotation ( $ reflectionMethod , 'ExtDirect\Annotations\Remotable' ) ; if ( $ methodAnnotation instanceof \ ExtDirect \ Annotations \ Remotable ) { $ methodAnnotation -> setMethodName ( $ reflectionMethod -> getName ( ) ) ; $ methodCollection -> add ( $ methodAnnotation ) ; } } $ classAnnotation -> setMethods ( $ methodCollection ) ; return $ classAnnotation ; } return false ; }
6926	protected function didStateChangeTo ( $ resource , $ state ) { if ( empty ( $ stateCs = $ this -> tracker -> getChangeSet ( $ resource , 'state' ) ) ) { return false ; } if ( $ stateCs [ 1 ] === $ state && $ stateCs [ 0 ] !== $ state ) { return true ; } return false ; }
5654	private function renderFlagSet ( $ flags , $ explanation , $ tab_stop ) { $ flag = array_shift ( $ flags ) ; $ text = str_pad ( $ this -> renderFlag ( $ flag ) , $ tab_stop , ' ' ) . $ explanation . "\n" ; foreach ( $ flags as $ flag ) { $ text .= ' ' . $ this -> renderFlag ( $ flag ) . "\n" ; } return $ text ; }
12856	function performPayload ( iPayloadQueued $ processPayload ) { $ triesCount = 0 ; if ( $ processPayload instanceof FailedPayload ) { if ( $ processPayload -> getCountRetries ( ) > $ this -> getMaxTries ( ) ) throw new exPayloadMaxTriesExceed ( $ processPayload , sprintf ( 'Max Tries Exceeds After %s Tries.' , $ processPayload -> getCountRetries ( ) ) , null ) ; } $ payLoadData = $ processPayload -> getData ( ) ; try { if ( ob_get_level ( ) ) ob_end_clean ( ) ; ob_start ( ) ; $ this -> event ( ) -> trigger ( EventHeapOfWorker :: EVENT_PAYLOAD_RECEIVED , [ 'payload' => $ processPayload , 'data' => $ payLoadData , 'worker' => $ this ] ) ; ob_end_flush ( ) ; flush ( ) ; } catch ( \ LogicException $ e ) { throw $ e ; } catch ( \ Exception $ e ) { if ( ! $ processPayload instanceof FailedPayload ) $ failedPayload = new FailedPayload ( $ processPayload , $ triesCount ) ; else $ failedPayload = $ processPayload ; throw new exPayloadPerformFailed ( $ failedPayload , $ e ) ; } }
1514	public function update ( StoreInterface $ store , UpdateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doUpdate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> updated ( $ record ) ; }
5183	public function article ( string $ singleJsonArticle ) : Article { if ( json_decode ( $ singleJsonArticle , true ) ) { $ dataArticle = json_decode ( $ singleJsonArticle , true ) [ 'data' ] ; $ article = new Article ( $ this -> filterString ( $ this -> getValue ( 'title' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'body' , $ dataArticle ) ) , $ this -> filterString ( $ this -> getValue ( 'source' , $ dataArticle ) ) , $ this -> getValue ( 'unique_id' , $ dataArticle ) , $ this -> filterInteger ( $ this -> getValue ( 'type_id' , $ dataArticle [ 'type' ] ) ) , $ this -> filterInteger ( $ this -> getValue ( 'category_id' , $ dataArticle [ 'category' ] ) ) , $ this -> getValue ( 'reporter' , $ dataArticle ) , $ this -> filterString ( $ this -> getValue ( 'lead' , $ dataArticle ) ) , $ this -> getValue ( 'tag_name' , $ dataArticle [ 'tags' ] ) , $ this -> filterString ( $ this -> getValue ( 'published_at' , $ dataArticle ) ) , ( string ) $ this -> filterInteger ( $ this -> getValue ( 'id' , $ dataArticle ) ) ) ; $ attachmentConstants = [ Article :: ATTACHMENT_FIELD_PHOTO , Article :: ATTACHMENT_FIELD_PAGE , Article :: ATTACHMENT_FIELD_GALLERY , Article :: ATTACHMENT_FIELD_VIDEO , ] ; $ attachmentTypes = [ self :: JSON_PHOTO_FIELD , self :: JSON_PAGE_FIELD , self :: JSON_GALLERY_FIELD , self :: JSON_VIDEO_FIELD , ] ; $ attachmentAttributes = $ this -> lookUp ( $ attachmentConstants ) ; return $ this -> generalAttachment ( $ article , $ attachmentConstants , $ attachmentTypes , $ attachmentAttributes , $ dataArticle ) ; } throw new \ Exception ( 'Empty or invalid JSON Response' , 1 ) ; }
383	public function getExceptionName ( $ exception ) { if ( $ exception instanceof \ yii \ base \ Exception || $ exception instanceof \ yii \ base \ InvalidCallException || $ exception instanceof \ yii \ base \ InvalidParamException || $ exception instanceof \ yii \ base \ UnknownMethodException ) { return $ exception -> getName ( ) ; } return null ; }
11604	public function notify ( ) { declare ( ticks = 1 ) ; if ( is_array ( $ this -> _caller ) && ! empty ( $ this -> _caller ) ) { return call_user_func_array ( $ this -> _caller , [ $ this -> _interrupt ] ) ; } else if ( $ this -> _caller instanceof Closure ) { return $ this -> _caller -> call ( $ this , $ this -> _interrupt ) ; } else if ( is_callable ( $ this -> _caller ) ) { $ cl = Closure :: fromCallable ( $ this -> _caller ) ; return $ cl -> call ( $ this , $ this -> _interrupt ) ; } return null ; }
660	public function createCommand ( $ sql = null , $ params = [ ] ) { $ driver = $ this -> getDriverName ( ) ; $ config = [ 'class' => 'yii\db\Command' ] ; if ( $ this -> commandClass !== $ config [ 'class' ] ) { $ config [ 'class' ] = $ this -> commandClass ; } elseif ( isset ( $ this -> commandMap [ $ driver ] ) ) { $ config = ! is_array ( $ this -> commandMap [ $ driver ] ) ? [ 'class' => $ this -> commandMap [ $ driver ] ] : $ this -> commandMap [ $ driver ] ; } $ config [ 'db' ] = $ this ; $ config [ 'sql' ] = $ sql ; $ command = Yii :: createObject ( $ config ) ; return $ command -> bindValues ( $ params ) ; }
3544	protected function writeable ( $ file_path ) { if ( $ this -> option ( 'force' ) ) { return true ; } return ( ! file_exists ( $ file_path ) || $ this -> confirmable ( $ file_path ) ) ; }
11543	public function changePassword ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangePasswordForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ password = $ user -> getPassword ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
6210	public function notifyOnException ( Exception $ e , $ extraParams = null ) { $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => get_class ( $ e ) , 'backtrace' => $ this -> cleanBacktrace ( $ e -> getTrace ( ) ? : debug_backtrace ( ) ) , 'errorMessage' => $ e -> getMessage ( ) . ' in ' . $ this -> cleanFilePath ( $ e -> getFile ( ) ) . ' on line ' . $ e -> getLine ( ) , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
9644	protected function mapParams ( array $ params ) : array { unset ( $ params [ 0 ] ) ; foreach ( $ params as $ name => $ value ) { if ( ! is_string ( $ name ) ) { unset ( $ params [ $ name ] ) ; } else { $ params [ $ name ] = urldecode ( $ value [ 0 ] ) ; } } return $ params ; }
2742	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ serviceId = $ this -> config -> getServiceId ( ) ; $ apiKey = $ this -> config -> getApiKey ( ) ; if ( $ serviceId == null && $ apiKey == null ) { return $ result -> setData ( [ 'status' => true , 'flag' => false ] ) ; } return $ result -> setData ( [ 'status' => true , 'flag' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1563	protected function isDateAttribute ( $ field , $ record ) { if ( empty ( $ this -> dates ) ) { return in_array ( $ this -> modelKeyForField ( $ field , $ record ) , $ record -> getDates ( ) , true ) ; } return in_array ( $ field , $ this -> dates , true ) ; }
8489	public static function getCpuArchitecture ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT Architecture FROM Win32_Processor" ) as $ cpu ) { switch ( $ cpu -> Architecture ) { case 0 : return "x86" ; case 1 : return "MIPS" ; case 2 : return "Alpha" ; case 3 : return "PowerPC" ; case 6 : return "Itanium-based systems" ; case 9 : return "x64" ; } } return "Unknown" ; }
11315	public static function getNormalizedParameters ( array $ data ) { $ params = array ( ) ; $ keys = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_keys ( $ data ) ) ; $ values = array_map ( 'PSX\Oauth\Consumer::urlEncode' , array_values ( $ data ) ) ; $ data = array_combine ( $ keys , $ values ) ; uksort ( $ data , 'strnatcmp' ) ; foreach ( $ data as $ k => $ v ) { if ( $ k != 'oauth_signature' ) { $ params [ ] = $ k . '=' . $ v ; } } return implode ( '&' , $ params ) ; }
3723	public function addMetaModelNames ( $ metaModelNames ) { $ this -> metaModelNames = array_unique ( array_merge ( $ this -> metaModelNames , $ metaModelNames ) ) ; return $ this ; }
5244	private function prefixNamespace ( string $ targetFile ) { $ pattern = sprintf ( '/%1$s\\s+(?!(%2$s)|(Composer(\\\\|;)))/' , 'namespace' , $ this -> namespacePrefix ) ; $ replacement = sprintf ( '%1$s %2$s' , 'namespace' , $ this -> namespacePrefix ) ; $ this -> replace ( $ pattern , $ replacement , $ targetFile ) ; }
9774	function satisfy ( callable $ predicate ) : self { return $ this -> expect ( call_user_func ( $ predicate , $ this -> target ) , isTrue ( ) ) ; }
9339	public function get ( $ key , $ default = null ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ length = count ( $ keys ) ; $ data = $ this -> data ; for ( $ i = 0 ; $ i < $ length ; $ i ++ ) { $ index = $ keys [ $ i ] ; $ data = & $ data [ $ index ] ; } return $ data !== null ? $ data : $ default ; }
6579	public function setParts ( array $ parts ) { $ parts = array_intersect_key ( $ parts , $ this -> params ) ; if ( isset ( $ parts [ 'port' ] ) ) $ parts [ 'port' ] = ( int ) $ parts [ 'port' ] ; if ( isset ( $ parts [ 'query' ] ) ) { $ query = $ this -> _parse_str ( $ parts [ 'query' ] ) ; $ this -> _rksort ( $ query ) ; $ parts [ 'query' ] = $ query ; } array_walk ( $ parts , function ( & $ part , $ key ) { if ( is_string ( $ part ) ) { $ part = strlen ( $ part ) ? $ part : null ; } else { $ part = $ part ? : null ; } } ) ; $ self = clone $ this ; $ self -> params = array_replace ( $ this -> params , $ parts ) ; return $ self ; }
5486	public function submitButton ( SelectorInterface $ selector , $ additional = false ) { $ additional = $ additional ? $ additional : array ( ) ; foreach ( $ this -> buttons as $ button ) { if ( $ selector -> isMatch ( $ button ) ) { $ encoding = $ this -> encode ( ) ; $ button -> write ( $ encoding ) ; if ( $ additional ) { $ encoding -> merge ( $ additional ) ; } return $ encoding ; } } return false ; }
3230	static function loadFromJson ( $ jsonObj ) { $ authHost = null ; if ( array_key_exists ( 'auth_host' , $ jsonObj ) ) { $ authHost = $ jsonObj [ "auth_host" ] ; if ( ! is_string ( $ authHost ) ) { throw new HostLoadException ( "Optional field \"auth_host\" must be a string" ) ; } } $ hostSuffix = null ; if ( array_key_exists ( 'host_suffix' , $ jsonObj ) ) { $ hostSuffix = $ jsonObj [ "host_suffix" ] ; if ( ! is_string ( $ hostSuffix ) ) { throw new HostLoadException ( "Optional field \"host_suffix\" must be a string" ) ; } } if ( $ authHost === null && $ hostSuffix === null ) return null ; if ( $ authHost === null ) { throw new HostLoadException ( "Can't provide \"host_suffix\" without providing \"auth_host\"." ) ; } if ( $ hostSuffix === null ) { throw new HostLoadException ( "Can't provide \"auth_host\" without providing \"host_suffix\"." ) ; } $ api = "api" . $ hostSuffix ; $ content = "content" . $ hostSuffix ; $ web = $ authHost ; return new Host ( $ api , $ content , $ web ) ; }
8802	public function get ( $ key = null ) { return ( is_null ( $ key ) ? $ _SESSION : ( $ this -> has ( $ key ) ? $ _SESSION [ $ key ] : null ) ) ; }
4613	public function withScalarValue ( $ value ) { $ this -> match = $ value ; $ this -> lowerBound = null ; $ this -> upperBound = null ; return $ this ; }
12959	public function update ( $ table , $ data = array ( ) , $ where = '1=1' ) { if ( ! $ this -> getDb ( ) -> update ( $ table , $ data , $ where ) ) { throw new DbException ( "Failed updating " . $ table ) ; } return true ; }
3455	public static function fromAggregateRootClass ( string $ aggregateRootClass ) : AggregateType { if ( ! \ class_exists ( $ aggregateRootClass ) ) { throw new Exception \ InvalidArgumentException ( \ sprintf ( 'Aggregate root class %s can not be found' , $ aggregateRootClass ) ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateRootClass ; return $ self ; }
838	public static function fromArray ( $ array , $ saveIndexes = null ) { $ tokens = new self ( \ count ( $ array ) ) ; if ( null === $ saveIndexes || $ saveIndexes ) { foreach ( $ array as $ key => $ val ) { $ tokens [ $ key ] = $ val ; } } else { $ index = 0 ; foreach ( $ array as $ val ) { $ tokens [ $ index ++ ] = $ val ; } } $ tokens -> generateCode ( ) ; return $ tokens ; }
4618	protected function required ( $ objectName ) { $ method = "get{$objectName}" ; $ class = "Basho\\Riak\\{$objectName}" ; $ value = $ this -> $ method ( ) ; if ( is_null ( $ value ) ) { throw new Builder \ Exception ( "Expected non-empty value for {$objectName}" ) ; } if ( is_object ( $ value ) && $ value instanceof $ class === false ) { throw new Builder \ Exception ( "Expected instance of {$class}, received instance of " . get_class ( $ value ) ) ; } if ( is_array ( $ value ) && count ( $ value ) == 0 ) { throw new Builder \ Exception ( "Expected non-empty array value for {$objectName}" ) ; } }
3678	public function generateAjax ( $ folder , $ strField , $ level , $ mount = false ) { return parent :: generateAjax ( $ folder , $ this -> strField , $ level , $ mount ) ; }
3883	public function getBackendIcon ( $ icon , $ defaultIcon = 'bundles/metamodelscore/images/icons/metamodels.png' ) { $ realIcon = $ this -> convertValueToPath ( $ icon , $ defaultIcon ) ; $ targetPath = $ this -> outputPath . '/' . basename ( $ realIcon ) ; if ( \ file_exists ( $ targetPath ) ) { return $ this -> webPath . '/' . basename ( $ realIcon ) ; } $ this -> imageFactory -> create ( $ realIcon , [ 16 , 16 , 'center_center' ] , $ targetPath ) ; return $ this -> webPath . '/' . basename ( $ realIcon ) ; }
5505	public function returns ( $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleReturn ( $ value ) ) ; }
3742	public function delete ( $ varItem ) { if ( is_object ( $ varItem ) && ( $ varItem instanceof Model ) ) { $ objModelItem = $ varItem -> getItem ( ) ; } else { $ objModelItem = $ this -> getMetaModel ( ) -> findById ( $ varItem ) ; } if ( $ objModelItem ) { $ this -> getMetaModel ( ) -> delete ( $ objModelItem ) ; } }
4498	private function getTrimmedJson ( callable $ inner , int $ limit , string $ error ) : array { $ gcmInner = $ inner ( $ this -> text ) ; $ gcmInnerJson = json_encode ( $ gcmInner , JSON_UNESCAPED_UNICODE ) ; if ( ( $ gcmInnerJsonLength = \ strlen ( $ gcmInnerJson ) ) > $ limit ) { $ cut = $ gcmInnerJsonLength - $ limit ; if ( $ this -> text && ( $ textLength = \ strlen ( $ this -> text ) ) > $ cut && $ this -> allowTrimming ) { $ gcmInner = $ inner ( mb_strcut ( $ this -> text , 0 , $ textLength - $ cut - 3 , 'utf8' ) . '...' ) ; } else { throw new MessageTooLongException ( "$error $gcmInnerJson" ) ; } } return $ gcmInner ; }
9394	public function execute ( ) { if ( $ this -> escape !== false ) { $ this -> options = $ this -> escape ( $ this -> options ) ; } if ( $ this -> builder !== null ) { $ command = $ this -> builder -> build ( $ this -> options ) ; exec ( $ command ) ; } }
5944	public function categories ( $ categoryIds , $ deploymentSiteIds = null , $ ignoreGrouping = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'deploymentSiteIds' => $ deploymentSiteIds , 'ignoreGrouping' => $ ignoreGrouping ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/filters/categories/' . $ categoryIds . '' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FilterItem ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
5960	public function clientGetByDbid ( $ dbid ) { foreach ( $ this -> clientList ( ) as $ client ) { if ( $ client [ "client_database_id" ] == $ dbid ) { return $ client ; } } throw new Ts3Exception ( "invalid clientID" , 0x200 ) ; }
11907	public function doFullBootBuildIfNecessary ( AviatorApp $ app ) { $ beaconUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/watch_beacon' ) ; if ( $ beaconUpdatedAt > LocalDate :: now ( ) -> modifyBySeconds ( 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherBeaconInFuture ( ) ; die ( ) ; } if ( PHP_SAPI !== 'cli' && $ beaconUpdatedAt < LocalDate :: now ( ) -> modifyBySeconds ( - 3 ) -> getTimestamp ( ) ) { echo DebugErrorHandler :: watcherNotRunning ( ) ; exit ( - 1 ) ; } $ needsBuild = ! class_exists ( $ app -> getContainerFqcn ( ) ) ; if ( ! $ needsBuild ) { $ reflect = new \ ReflectionClass ( $ app -> getContainerFqcn ( ) ) ; $ containerFile = $ reflect -> getFileName ( ) ; clearstatcache ( true , $ containerFile ) ; $ fileUpdatedAt = $ this -> getChangedAt ( Aviator :: getInstallDir ( ) . '/tmp/file_update_found' ) ; $ needsBuild = filemtime ( $ containerFile ) < $ fileUpdatedAt ; } if ( $ needsBuild ) { $ this -> doFullBootBuild ( $ app ) ; } }
461	public function buildColumns ( $ columns ) { if ( ! is_array ( $ columns ) ) { if ( strpos ( $ columns , '(' ) !== false ) { return $ columns ; } $ rawColumns = $ columns ; $ columns = preg_split ( '/\s*,\s*/' , $ columns , - 1 , PREG_SPLIT_NO_EMPTY ) ; if ( $ columns === false ) { throw new InvalidArgumentException ( "$rawColumns is not valid columns." ) ; } } foreach ( $ columns as $ i => $ column ) { if ( $ column instanceof ExpressionInterface ) { $ columns [ $ i ] = $ this -> buildExpression ( $ column ) ; } elseif ( strpos ( $ column , '(' ) === false ) { $ columns [ $ i ] = $ this -> db -> quoteColumnName ( $ column ) ; } } return implode ( ', ' , $ columns ) ; }
7488	public function append ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ this -> string .= $ string ; return $ this ; }
11532	public static function cascade ( array $ folders ) { $ result = null ; foreach ( $ folders as $ folder ) { if ( is_dir ( $ folder ) ) { $ result = $ folder ; break ; } } return $ result ; }
6501	private function getRequestTarget ( ) : string { switch ( $ this -> requestTargetType ) { case RequestTargetTypes :: ORIGIN_FORM : $ requestTarget = $ this -> uri -> getPath ( ) ; if ( $ requestTarget === null || $ requestTarget === '' ) { $ requestTarget = '/' ; } if ( ( $ queryString = $ this -> uri -> getQueryString ( ) ) !== null && $ queryString !== '' ) { $ requestTarget .= "?$queryString" ; } return $ requestTarget ; case RequestTargetTypes :: ABSOLUTE_FORM : return ( string ) $ this -> uri ; case RequestTargetTypes :: AUTHORITY_FORM : return $ this -> uri -> getAuthority ( false ) ?? '' ; case RequestTargetTypes :: ASTERISK_FORM : return '*' ; default : return '' ; } }
262	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } if ( $ model -> delete ( ) === false ) { throw new ServerErrorHttpException ( 'Failed to delete the object for unknown reason.' ) ; } Yii :: $ app -> getResponse ( ) -> setStatusCode ( 204 ) ; }
1235	public function elementMeta ( $ elementName ) { $ class = get_class ( $ this ) ; if ( array_key_exists ( $ elementName , self :: $ properties [ $ class ] ) ) { $ info = self :: $ properties [ $ class ] [ $ elementName ] ; $ nameKey = $ info [ 'attribute' ] ? 'attributeName' : 'elementName' ; if ( array_key_exists ( $ nameKey , $ info ) ) { if ( $ info [ $ nameKey ] === $ elementName ) { $ meta = new \ stdClass ( ) ; $ meta -> propertyName = $ elementName ; $ meta -> phpType = $ info [ 'type' ] ; $ meta -> repeatable = $ info [ 'repeatable' ] ; $ meta -> attribute = $ info [ 'attribute' ] ; $ meta -> elementName = $ info [ $ nameKey ] ; $ meta -> strData = '' ; return $ meta ; } } } return null ; }
8847	public function getArchivedBlogPosts ( $ year , $ month = null , $ day = null ) { $ query = $ this -> getBlogPosts ( ) -> dataQuery ( ) ; $ stage = $ query -> getQueryParam ( "Versioned.stage" ) ; if ( $ stage ) $ stage = '_' . Convert :: raw2sql ( $ stage ) ; $ query -> innerJoin ( "BlogPost" , "`SiteTree" . $ stage . "`.`ID` = `BlogPost" . $ stage . "`.`ID`" ) ; $ query -> where ( "YEAR(PublishDate) = '" . Convert :: raw2sql ( $ year ) . "'" ) ; if ( $ month ) { $ query -> where ( "MONTH(PublishDate) = '" . Convert :: raw2sql ( $ month ) . "'" ) ; if ( $ day ) { $ query -> where ( "DAY(PublishDate) = '" . Convert :: raw2sql ( $ day ) . "'" ) ; } } return $ this -> getBlogPosts ( ) -> setDataQuery ( $ query ) ; }
2073	public function getAllTables ( ) { $ arrTables = $ this -> Database -> listTables ( ) ; $ arrViews = Contao \ System :: getContainer ( ) -> get ( 'database_connection' ) -> getSchemaManager ( ) -> listViews ( ) ; if ( ! empty ( $ arrViews ) ) { $ arrTables = array_merge ( $ arrTables , array_keys ( $ arrViews ) ) ; natsort ( $ arrTables ) ; } return array_values ( $ arrTables ) ; }
5677	protected function stringDiffersAt ( $ first , $ second ) { if ( ! $ first || ! $ second ) { return 0 ; } if ( strlen ( $ first ) < strlen ( $ second ) ) { list ( $ first , $ second ) = array ( $ second , $ first ) ; } $ position = 0 ; $ step = strlen ( $ first ) ; while ( $ step > 1 ) { $ step = ( integer ) ( ( $ step + 1 ) / 2 ) ; if ( strncmp ( $ first , $ second , $ position + $ step ) == 0 ) { $ position += $ step ; } } return $ position ; }
5858	protected function notify ( $ callbackNotification , $ message , $ severity ) { $ callableName = '' ; if ( is_callable ( $ callbackNotification , false , $ callableName ) ) { call_user_func ( $ callbackNotification , $ message , $ severity ) ; } }
11335	public function getFormValue ( ) { if ( $ this -> format instanceof BaseFormat ) { $ formValue = $ this -> format -> getFormValue ( ) ; } elseif ( is_callable ( $ this -> format ) || ( is_array ( $ this -> format ) && ! empty ( $ this -> format [ 0 ] ) && is_object ( $ this -> format [ 0 ] ) ) ) { $ formValue = $ this -> evaluateExpression ( $ this -> format , [ $ this -> value ] ) ; } else { $ formValue = $ this -> value ; } return $ formValue ; }
6679	public static function convertDate ( $ dateString , $ fromFormat , $ toFormat ) { $ date = DateTime :: createFromFormat ( $ fromFormat , $ dateString ) ; if ( ! $ date && $ fromFormat == DateFormat :: FORMAT_ORACLE_WITH_MICROSECONDS ) { $ date = DateTime :: createFromFormat ( DateFormat :: FORMAT_ORACLE_DATE_ONLY , $ dateString ) ; } if ( $ date ) { return $ date -> format ( $ toFormat ) ; } return $ dateString ; }
8444	public function matchesRequest ( ) { if ( isset ( $ this -> headers [ 'x-twitter-webhooks-signature' ] ) ) { $ signature = $ this -> headers [ 'x-twitter-webhooks-signature' ] [ 0 ] ; $ hash = hash_hmac ( 'sha256' , json_encode ( $ this -> payload -> all ( ) ) , $ this -> config -> get ( 'consumer_secret' ) , true ) ; return $ signature === 'sha256=' . base64_encode ( $ hash ) ; } return false ; }
7133	protected function getSupplierOrderFromEvent ( ResourceEventInterface $ event ) { $ order = $ event -> getResource ( ) ; if ( ! $ order instanceof SupplierOrderInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderInterface." ) ; } return $ order ; }
6088	public function createMoodboard ( Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
10288	protected function getJobsSince ( $ time ) { $ now = time ( ) ; $ jobs = array ( ) ; foreach ( $ this -> rescheduled as $ scheduled => $ cronjob ) { if ( $ scheduled <= $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; unset ( $ this -> rescheduled [ $ scheduled ] ) ; } } foreach ( $ this -> crontab as $ cronjob ) { $ cronjob -> iterator -> startTime = $ time ; if ( ( $ scheduled = $ cronjob -> iterator -> current ( ) ) < $ now ) { $ jobs [ $ scheduled ] [ ] = $ cronjob ; } } ksort ( $ jobs ) ; return $ jobs ; }
6421	public static function ands ( callable ... $ predicates ) : callable { return function ( $ element ) use ( $ predicates ) { foreach ( $ predicates as $ predicate ) { if ( ! self :: call ( $ predicate , $ element ) ) { return false ; } } return true ; } ; }
11091	public static function gpsDistance ( $ lat1 , $ lon1 , $ lat2 , $ lon2 ) { $ lat1 = deg2rad ( $ lat1 ) ; $ lon1 = deg2rad ( $ lon1 ) ; $ lat2 = deg2rad ( $ lat2 ) ; $ lon2 = deg2rad ( $ lon2 ) ; $ lonDelta = $ lon2 - $ lon1 ; $ a = ( ( cos ( $ lat2 ) * sin ( $ lonDelta ) ) ** 2 ) + ( ( cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ) ** 2 ) ; $ b = sin ( $ lat1 ) * sin ( $ lat2 ) + cos ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lonDelta ) ; return atan2 ( sqrt ( $ a ) , $ b ) * 6371.0088 ; }
4158	function run ( ) { $ now = new DateTime ( 'now' ) ; $ sleep = min ( array_map ( function ( $ entry ) use ( $ now ) { list ( $ expression , $ job ) = $ entry ; return $ expression -> getNextRunDate ( $ now ) -> getTimestamp ( ) ; } , $ this -> entries ) ) ; time_sleep_until ( $ sleep ) ; $ scheduled = 0 ; foreach ( $ this -> entries as $ entry ) { list ( $ expression , $ job ) = $ entry ; if ( $ expression -> isDue ( $ now ) ) { $ this -> queue -> push ( $ job ) ; $ scheduled += 1 ; } } $ this -> queue -> flush ( ) ; return $ scheduled ; }
11191	public function routeProcess ( $ uri = false , $ httpMethod = false ) { if ( ! $ httpMethod ) $ httpMethod = $ _SERVER [ 'REQUEST_METHOD' ] ; $ this -> httpMethod = $ httpMethod ; if ( ! $ uri ) $ uri = $ _SERVER [ 'REQUEST_URI' ] ; $ this -> setPath ( $ uri ) ; $ customPathSearch = $ this -> customFind ( ) ; if ( $ customPathSearch || ( ! $ customPathSearch && $ this -> config [ 'automatic_routing' ] ) ) { $ this -> routeFind ( ) ; } else if ( $ customPathSearch == - 1 ) { $ this -> error ( '403' ) ; } }
6334	private function attachHandlers ( $ parser ) { $ onElementStart = \ Closure :: bind ( function ( $ parser , $ name , $ attributes ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = $ name ; $ this -> dataBuffer = null ; $ this -> stackSize ++ ; $ this -> onElementStart ( $ parser , $ name , $ attributes ) ; } , $ this ) ; $ onElementEnd = \ Closure :: bind ( function ( $ parser , $ name ) { $ name = $ this -> normalize ( $ name ) ; $ this -> currentElement = null ; $ this -> stackSize -- ; if ( null !== $ this -> dataBuffer ) { $ this -> onElementData ( $ parser , $ this -> dataBuffer ) ; } $ this -> dataBuffer = null ; $ this -> onElementEnd ( $ parser , $ name ) ; } , $ this ) ; $ onElementData = \ Closure :: bind ( function ( $ parser , $ data ) { $ this -> dataBuffer .= $ data ; } , $ this ) ; $ onNamespaceDeclarationStart = \ Closure :: bind ( function ( $ parser , $ prefix , $ uri ) { $ this -> namespaces [ $ prefix ] = rtrim ( $ uri , '/' ) ; $ this -> onNamespaceDeclarationStart ( $ parser , $ prefix , $ uri ) ; } , $ this ) ; $ onNamespaceDeclarationEnd = \ Closure :: bind ( function ( $ parser , $ prefix ) { $ this -> onNamespaceDeclarationEnd ( $ parser , $ prefix ) ; } , $ this ) ; xml_set_element_handler ( $ parser , $ onElementStart , $ onElementEnd ) ; xml_set_character_data_handler ( $ parser , $ onElementData ) ; xml_set_start_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationStart ) ; xml_set_end_namespace_decl_handler ( $ parser , $ onNamespaceDeclarationEnd ) ; return $ this ; }
5270	private function translateUpdate ( ) { $ build = array ( "update {$this->table} set" ) ; $ values = array ( ) ; foreach ( $ this -> statements [ 'values' ] as $ key => $ value ) { $ values [ ] = $ key . ' = ' . $ this -> esc_value ( $ value ) ; } if ( ! empty ( $ values ) ) { $ build [ ] = join ( ', ' , $ values ) ; } if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
6606	public function validateAccessTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'access token' ) ; } return true ; }
1439	protected function getStub ( ) { if ( $ this -> isIndependent ) { return $ this -> getStubFor ( 'independent' ) ; } if ( $ this -> isEloquent ( ) ) { return $ this -> getStubFor ( 'eloquent' ) ; } return $ this -> getStubFor ( 'abstract' ) ; }
3485	public static function resolve ( ) : SignatureGeneratorInterface { self :: addDefaultResolvers ( ) ; foreach ( self :: $ resolvers as $ resolver ) { if ( $ generator = $ resolver ( ) ) { return $ generator ; } } throw new \ LogicException ( 'Cannot resolve available JWT Signature Generator.' ) ; }
10314	function getClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ linkIdFilter = null , $ linkUrlFilter = null , $ linkTagFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_id" , $ linkIdFilter ) ; if ( isset ( $ linkUrlFilter ) ) $ params [ 'link_url' ] = $ linkUrlFilter ; $ params = $ this -> appendArrayFields ( $ params , "link_tag" , $ linkTagFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/clicks/count' , $ params ) ; }
6432	public function removeDisplayField ( $ displayField ) { $ key = array_search ( $ displayField , $ this -> displayFields ) ; if ( $ key ) { unset ( $ this -> displayFields [ $ key ] ) ; $ this -> displayFields = array_values ( $ this -> displayFields ) ; } }
2132	public function add ( $ strKey , $ varValue ) { $ this -> markModified ( ) ; $ this -> arrData [ $ strKey ] = $ this -> escape ( $ varValue ) . ';' ; }
2373	public static function toHtml5 ( $ strString ) { $ arrPregReplace = array ( '/<(br|hr|img)([^>]*) \/>/i' => '<$1$2>' , '/ (cellpadding|cellspacing|border)="[^"]*"/' => '' , '/ rel="lightbox(\[([^\]]+)\])?"/' => ' data-lightbox="$2"' ) ; $ arrStrReplace = array ( '<u>' => '<span style="text-decoration:underline">' , '</u>' => '</span>' , ' target="_self"' => '' , ' onclick="window.open(this.href); return false"' => ' target="_blank"' , ' onclick="window.open(this.href);return false"' => ' target="_blank"' , ' onclick="window.open(this.href); return false;"' => ' target="_blank"' ) ; $ strString = preg_replace ( array_keys ( $ arrPregReplace ) , $ arrPregReplace , $ strString ) ; $ strString = str_ireplace ( array_keys ( $ arrStrReplace ) , $ arrStrReplace , $ strString ) ; return $ strString ; }
9495	public function createService ( ) { $ host = $ this -> getParameters ( ) -> get ( 'host' ) ; $ port = $ this -> getParameters ( ) -> get ( 'port' ) ; $ timeout = $ this -> getParameters ( ) -> get ( 'timeout' ) ; if ( is_null ( $ host ) || is_null ( $ port ) ) { throw new \ Exception ( 'No sphinx server information found within the configuration!' ) ; } $ sphinxClient = new SphinxClient ( ) ; $ sphinxClient -> SetServer ( $ host , $ port ) ; $ sphinxClient -> SetConnectTimeout ( $ timeout ) ; $ sphinxClient -> SetArrayResult ( true ) ; $ sphinxClient -> setMatchModeByModeName ( 'any' ) ; $ sphinxClient -> SetSortMode ( SPH_SORT_RELEVANCE ) ; $ sphinxClient -> SetRankingMode ( SPH_RANK_PROXIMITY ) ; return $ sphinxClient ; }
1160	protected function fakeValidationData ( $ attribute , $ rule , $ parameters ) { $ data = $ this -> validator -> getData ( ) ; $ this -> fakeFileData ( $ data , $ attribute ) ; $ this -> fakeRequiredIfData ( $ data , $ rule , $ parameters ) ; return $ data ; }
4199	public function addConstants ( Event $ abs ) { if ( ! $ this -> abstracter -> getCfg ( 'collectConstants' ) ) { return ; } $ reflector = $ abs [ 'reflector' ] ; $ constants = $ reflector -> getConstants ( ) ; while ( $ reflector = $ reflector -> getParentClass ( ) ) { $ constants = \ array_merge ( $ reflector -> getConstants ( ) , $ constants ) ; } if ( $ this -> abstracter -> getCfg ( 'objectSort' ) == 'name' ) { \ ksort ( $ constants ) ; } $ abs [ 'constants' ] = $ constants ; }
11305	public static function email ( $ email = null , $ errorMsg = null ) { if ( ! $ email ) return null ; $ email = trim ( mb_strtolower ( trim ( $ email ) , "UTF-8" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { return null ; } return $ email ; }
10242	public static function getMatrixDimensions ( array & $ matrix ) { $ matrixRows = count ( $ matrix ) ; $ matrixColumns = 0 ; foreach ( $ matrix as $ rowKey => $ rowValue ) { if ( ! is_array ( $ rowValue ) ) { $ matrix [ $ rowKey ] = [ $ rowValue ] ; $ matrixColumns = max ( 1 , $ matrixColumns ) ; } else { $ matrix [ $ rowKey ] = array_values ( $ rowValue ) ; $ matrixColumns = max ( count ( $ rowValue ) , $ matrixColumns ) ; } } $ matrix = array_values ( $ matrix ) ; return [ $ matrixRows , $ matrixColumns ] ; }
1207	public function moveToPosition ( ItemInterface $ item , $ position ) { $ this -> moveChildToPosition ( $ item -> getParent ( ) , $ item , $ position ) ; }
5424	public function expectException ( $ expected = false , $ message = '%s' ) { $ this -> expected = $ this -> forceToExpectation ( $ expected ) ; $ this -> message = $ message ; }
6646	public function authenticate ( ) { $ request_token = $ this -> oauth -> getRequestToken ( $ this -> settings , $ this -> consumer , $ this -> token ) ; $ auth_url = $ this -> settings ( 'auth_api_url' ) . $ this -> settings ( 'authentication_uri' ) ; $ auth_url .= '?' . http_build_query ( [ 'oauth_token' => $ request_token -> key ] ) ; return $ this -> redirect -> to ( $ auth_url ) ; }
11132	public function exec ( ) { if ( $ this -> customQuery ) { return $ this -> execCustom ( ) ; } $ this -> last_wheres = $ this -> wheres ; $ this -> last_distinct = $ this -> distinct ; $ this -> last_ins = $ this -> ins ; $ this -> last_groupBys = $ this -> groupBys ; $ this -> last_havings = $ this -> havings ; $ this -> last_joins = $ this -> joins ; $ this -> calculate ( ) ; try { $ result = $ this -> db -> query ( $ this -> query ) ; } catch ( \ PDOException $ e ) { if ( $ this -> config [ 'mode' ] == 'development' ) { echo $ this -> getQuery ( ) ; } $ this -> reset ( ) ; throw $ e ; } $ this -> reset ( ) ; $ dbResult = new Db_MySQLResult ( $ result , $ this -> db ) ; return $ dbResult ; }
4719	public function processBlockTags ( Tag $ tag ) { if ( $ tag -> isInline ( ) ) { return ; } $ text = null ; $ tag -> getText ( ) -> replace ( '/(^{([^:\(\)]+)}[ \t]*\n?|(?:[ \t]*|\n?){([^:\(\)]+)}\n*$)/' , function ( Text $ w ) use ( & $ text ) { $ text = $ w -> trim ( ) -> trim ( '{}' ) ; return '' ; } ) ; if ( $ text ) { $ tag -> setAttributes ( $ this -> parseAttributes ( $ text ) ) ; } }
6199	protected function transformParam ( $ param , $ k ) { if ( isset ( $ this -> routeMapParse [ $ k ] [ $ param ] ) and ! is_array ( $ this -> routeMapParse [ $ k ] [ $ param ] ) ) { return $ this -> routeMapParse [ $ k ] [ $ param ] ; } else { return '(.+?)' ; } }
872	private static function wordwrap ( $ string , $ width ) { $ result = [ ] ; $ currentLine = 0 ; $ lineLength = 0 ; foreach ( explode ( ' ' , $ string ) as $ word ) { $ wordLength = \ strlen ( Preg :: replace ( '~</?(\w+)>~' , '' , $ word ) ) ; if ( 0 !== $ lineLength ) { ++ $ wordLength ; } if ( $ lineLength + $ wordLength > $ width ) { ++ $ currentLine ; $ lineLength = 0 ; } $ result [ $ currentLine ] [ ] = $ word ; $ lineLength += $ wordLength ; } return array_map ( static function ( $ line ) { return implode ( ' ' , $ line ) ; } , $ result ) ; }
8806	protected function ensureFacadeExists ( $ alias ) { if ( file_exists ( $ path = storage_path ( 'cache/facade-' . sha1 ( $ alias ) . '.php' ) ) ) { return $ path ; } file_put_contents ( $ path , $ this -> formatFacadeStub ( $ alias , file_get_contents ( __DIR__ . '/stubs/facade.stub' ) ) ) ; return $ path ; }
3640	public function all ( bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> all ( ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
7912	protected function renderToggleButton ( ) { if ( $ this -> toggleButton !== false ) { $ tag = ArrayHelper :: remove ( $ this -> toggleButton , 'tag' , 'div' ) ; $ label = ArrayHelper :: remove ( $ this -> toggleButton , 'label' , 'Show' ) ; if ( $ tag === 'button' && ! isset ( $ this -> toggleButton [ 'type' ] ) ) { $ this -> toggleButton [ 'type' ] = 'button' ; } if ( $ tag === 'div' ) { Html :: addCssClass ( $ this -> toggleButton , 'ui' ) ; Html :: addCssClass ( $ this -> toggleButton , 'button' ) ; } $ view = $ this -> getView ( ) ; DosAmigosAsset :: register ( $ view ) ; $ view -> registerJs ( 'dosamigos.semantic.init();' ) ; return Html :: tag ( $ tag , $ label , $ this -> toggleButton ) ; } else { return null ; } }
6619	public function hasChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; return $ this -> reflection -> hasMethod ( $ methodName ) ; }
8413	public function getLink ( ) { if ( $ this -> isConnected ( ) === false ) { $ this -> connect ( ) ; } if ( isset ( $ this -> servers [ 'all' ] ) === true ) { return $ this -> servers [ 'all' ] [ 'link' ] ; } if ( $ this -> transactionLevel >= 1 ) { return $ this -> servers [ 'write' ] [ 'link' ] ; } return $ this -> servers [ 'read' ] [ 'link' ] ; }
3780	protected function getFilteredAttribute ( ) { if ( ! ( $ attributeId = $ this -> get ( 'attr_id' ) ) ) { return null ; } if ( $ attribute = $ this -> getMetaModel ( ) -> getAttributeById ( $ attributeId ) ) { return $ attribute ; } return null ; }
9817	public function setView ( $ pValue ) { if ( $ pValue === null ) { $ pValue = self :: SHEETVIEW_NORMAL ; } if ( in_array ( $ pValue , self :: $ sheetViewTypes ) ) { $ this -> sheetviewType = $ pValue ; } else { throw new PhpSpreadsheetException ( 'Invalid sheetview layout type.' ) ; } return $ this ; }
7686	function Misc_ColNum ( $ ColRef , $ IsODF ) { if ( $ IsODF ) { $ p = strpos ( $ ColRef , '.' ) ; if ( $ p !== false ) $ ColRef = substr ( $ ColRef , $ p ) ; $ ColRef = str_replace ( array ( '.' , '$' ) , '' , $ ColRef ) ; $ ColRef = explode ( ':' , $ ColRef ) ; $ ColRef = $ ColRef [ 0 ] ; } $ num = 0 ; $ rank = 0 ; for ( $ i = strlen ( $ ColRef ) - 1 ; $ i >= 0 ; $ i -- ) { $ l = $ ColRef [ $ i ] ; if ( ! is_numeric ( $ l ) ) { $ l = ord ( strtoupper ( $ l ) ) - 64 ; if ( $ l > 0 && $ l < 27 ) { $ num = $ num + $ l * pow ( 26 , $ rank ) ; } else { return $ this -> RaiseError ( '(Sheet) Reference of cell \'' . $ ColRef . '\' cannot be recognized.' ) ; } $ rank ++ ; } } return $ num ; }
2349	public function renameTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> rename ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { $ this -> objModel = Dbafs :: moveResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncSource ) { $ this -> objModel = Dbafs :: deleteResource ( $ this -> strFile ) ; } elseif ( $ syncTarget ) { $ this -> objModel = Dbafs :: addResource ( $ strNewName ) ; } if ( $ return != false ) { $ this -> strFile = $ strNewName ; $ this -> arrImageSize = array ( ) ; $ this -> arrPathinfo = array ( ) ; } return $ return ; }
9622	public function getPdo ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } if ( isset ( $ this -> instances [ $ connection ] ) ) { return $ this -> instances [ $ connection ] ; } $ config = $ this -> getConnectionConfig ( $ connection ) ; return $ this -> instances [ $ connection ] = $ this -> factory -> makePdo ( $ config , $ connection ) ; }
8670	public static function fromRecursive ( $ collection ) { $ arr = Arr :: from ( $ collection ) ; foreach ( $ arr as $ key => $ value ) { if ( $ value instanceof stdClass || \ is_iterable ( $ value ) ) { $ value = static :: fromRecursive ( $ value ) ; } $ arr [ $ key ] = $ value ; } return new static ( $ arr ) ; }
9378	protected function files ( $ path ) { $ directory = new \ RecursiveDirectoryIterator ( $ path ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directory ) ; $ regex = new \ RegexIterator ( $ iterator , '/^.+\.php$/i' , 1 ) ; return ( array ) array_keys ( iterator_to_array ( $ regex ) ) ; }
9872	private function writeSheetData ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet , array $ pStringTable ) { $ aFlippedStringTable = $ this -> getParentWriter ( ) -> getWriterPart ( 'stringtable' ) -> flipStringTable ( $ pStringTable ) ; $ objWriter -> startElement ( 'sheetData' ) ; $ colCount = Coordinate :: columnIndexFromString ( $ pSheet -> getHighestColumn ( ) ) ; $ highestRow = $ pSheet -> getHighestRow ( ) ; $ cellsByRow = [ ] ; foreach ( $ pSheet -> getCoordinates ( ) as $ coordinate ) { $ cellAddress = Coordinate :: coordinateFromString ( $ coordinate ) ; $ cellsByRow [ $ cellAddress [ 1 ] ] [ ] = $ coordinate ; } $ currentRow = 0 ; while ( $ currentRow ++ < $ highestRow ) { $ rowDimension = $ pSheet -> getRowDimension ( $ currentRow ) ; $ writeCurrentRow = isset ( $ cellsByRow [ $ currentRow ] ) || $ rowDimension -> getRowHeight ( ) >= 0 || $ rowDimension -> getVisible ( ) == false || $ rowDimension -> getCollapsed ( ) == true || $ rowDimension -> getOutlineLevel ( ) > 0 || $ rowDimension -> getXfIndex ( ) !== null ; if ( $ writeCurrentRow ) { $ objWriter -> startElement ( 'row' ) ; $ objWriter -> writeAttribute ( 'r' , $ currentRow ) ; $ objWriter -> writeAttribute ( 'spans' , '1:' . $ colCount ) ; if ( $ rowDimension -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , '1' ) ; $ objWriter -> writeAttribute ( 'ht' , StringHelper :: formatNumber ( $ rowDimension -> getRowHeight ( ) ) ) ; } if ( $ rowDimension -> getVisible ( ) == false ) { $ objWriter -> writeAttribute ( 'hidden' , 'true' ) ; } if ( $ rowDimension -> getCollapsed ( ) == true ) { $ objWriter -> writeAttribute ( 'collapsed' , 'true' ) ; } if ( $ rowDimension -> getOutlineLevel ( ) > 0 ) { $ objWriter -> writeAttribute ( 'outlineLevel' , $ rowDimension -> getOutlineLevel ( ) ) ; } if ( $ rowDimension -> getXfIndex ( ) !== null ) { $ objWriter -> writeAttribute ( 's' , $ rowDimension -> getXfIndex ( ) ) ; $ objWriter -> writeAttribute ( 'customFormat' , '1' ) ; } if ( isset ( $ cellsByRow [ $ currentRow ] ) ) { foreach ( $ cellsByRow [ $ currentRow ] as $ cellAddress ) { $ this -> writeCell ( $ objWriter , $ pSheet , $ cellAddress , $ aFlippedStringTable ) ; } } $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; }
5536	public function addFrame ( $ page , $ name = false ) { $ this -> frames [ ] = $ page ; if ( $ name ) { $ this -> names [ $ name ] = count ( $ this -> frames ) - 1 ; } }
10589	public function buildPayoutFromId ( $ sPayoutId ) { $ oPayout = new Freeagent \ DataWrapper \ PayoutVO ( ) ; $ oPayout -> setId ( $ sPayoutId ) ; try { $ oDets = $ this -> getTxnChargeDetails ( $ sPayoutId ) ; $ oPayout -> setDateArrival ( strtotime ( $ oDets -> PaymentDate ) ) -> setCurrency ( $ oDets -> GrossAmount -> currencyID ) ; $ oPayout -> addCharge ( $ this -> buildChargeFromTransaction ( $ sPayoutId ) ) ; } catch ( \ Exception $ oE ) { } return $ oPayout ; }
3269	public function readFromFile ( ) : \ Generator { $ file = $ this -> openFile ( static :: FILE_READ ) ; try { foreach ( $ file as $ line ) { yield new Line ( $ line ) ; } } finally { $ this -> closeFile ( $ file ) ; } }
11216	public static function setSingletonName ( $ method ) { if ( ! is_string ( $ method ) || empty ( $ method ) ) { return false ; } self :: $ singleton = $ method ; return true ; }
3760	private function createConditionsForPalette ( PaletteInterface $ palette , array $ typeLegends ) { $ conditions = [ ] ; foreach ( $ typeLegends as $ value => $ legends ) { $ valueCondition = new FilterSettingTypeSubPaletteCondition ( $ this -> filterFactory , $ value ) ; foreach ( $ legends as $ legendName => $ legendProperties ) { $ legend = $ this -> getLegend ( $ palette , $ legendName ) ; foreach ( $ legendProperties as $ propertyName ) { $ this -> getConditionChain ( $ legend , $ propertyName , $ conditions ) -> addCondition ( $ valueCondition ) ; } } } }
8872	private function buildAttachmentPart ( ) { if ( count ( $ this -> attachments ) > 0 ) { $ attachment_part = '' ; foreach ( $ this -> attachments as $ attachment ) { $ file_str = chunk_split ( base64_encode ( file_get_contents ( $ attachment ) ) ) ; $ attachment_part .= "--MIME_BOUNDRY\nContent-Type: " . $ this -> getMimeType ( $ attachment ) . "; name=" . basename ( $ attachment ) . "\nContent-disposition: attachment\nContent-Transfer-Encoding: base64\n\n{$file_str}\n\n" ; } return $ attachment_part ; } }
12410	public function delete ( $ groupId ) { $ params = [ 'group_id' => intval ( $ groupId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DELETE , $ params ] ) ; }
5317	public function run ( ) { $ signalHandler = $ this -> getSignalHandler ( ) ; $ signalHandler -> registerHandler ( SIGTERM , function ( ) { $ this -> shouldShutdown = true ; } ) ; $ this -> sharedMemory [ self :: STARTED_MARKER ] = true ; $ callable = $ this -> callable ; $ callable ( $ this ) ; }
6843	public function call ( Closure $ c , $ params = array ( ) ) { $ ref = new ReflectionFunction ( $ c ) ; $ params_need = $ ref -> getParameters ( ) ; $ args = $ this -> apply ( $ params_need , $ params ) ; return call_user_func_array ( $ c , $ args ) ; }
171	public static function createDirectory ( $ path , $ mode = 0775 , $ recursive = true ) { if ( is_dir ( $ path ) ) { return true ; } $ parentDir = dirname ( $ path ) ; if ( $ recursive && ! is_dir ( $ parentDir ) && $ parentDir !== $ path ) { static :: createDirectory ( $ parentDir , $ mode , true ) ; } try { if ( ! mkdir ( $ path , $ mode ) ) { return false ; } } catch ( \ Exception $ e ) { if ( ! is_dir ( $ path ) ) { throw new \ yii \ base \ Exception ( "Failed to create directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } } try { return chmod ( $ path , $ mode ) ; } catch ( \ Exception $ e ) { throw new \ yii \ base \ Exception ( "Failed to change permissions for directory \"$path\": " . $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
557	protected function buildConjunctionCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } $ result = [ $ operator ] ; foreach ( $ condition as $ part ) { $ result [ ] = $ this -> buildCondition ( $ part ) ; } return $ result ; }
3648	protected function registerBinput ( ) { $ this -> app -> singleton ( 'binput' , function ( Container $ app ) { $ request = $ app [ 'request' ] ; $ security = $ app [ 'security' ] ; $ binput = new Binput ( $ request , $ security ) ; $ app -> refresh ( 'request' , $ binput , 'setRequest' ) ; return $ binput ; } ) ; $ this -> app -> alias ( 'binput' , Binput :: class ) ; }
4235	private static function trimDesc ( $ desc ) { $ lines = \ explode ( "\n" , $ desc ) ; $ leadingSpaces = array ( ) ; foreach ( $ lines as $ line ) { if ( \ strlen ( $ line ) ) { $ leadingSpaces [ ] = \ strspn ( $ line , ' ' ) ; } } \ array_shift ( $ leadingSpaces ) ; $ trimLen = $ leadingSpaces ? \ min ( $ leadingSpaces ) : 0 ; if ( ! $ trimLen ) { return $ desc ; } foreach ( $ lines as $ i => $ line ) { $ lines [ $ i ] = $ i > 0 && \ strlen ( $ line ) ? \ substr ( $ line , $ trimLen ) : $ line ; } $ desc = \ implode ( "\n" , $ lines ) ; return $ desc ; }
10571	protected function validateCache ( $ lastModified , $ etag ) { if ( isset ( $ _SERVER [ 'HTTP_IF_NONE_MATCH' ] ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getEtags ( ) , true ) ; } elseif ( isset ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) ) { return $ lastModified !== null && @ strtotime ( $ _SERVER [ 'HTTP_IF_MODIFIED_SINCE' ] ) >= $ lastModified ; } else { return $ etag === null && $ lastModified === null ; } }
5221	public function sourcePathes ( ) { $ vendorPathes = [ ] ; foreach ( array_merge ( $ this -> loadPsr0Pathes ( ) , $ this -> loadPsr4Pathes ( ) ) as $ pathes ) { if ( is_array ( $ pathes ) ) { $ vendorPathes = array_merge ( $ vendorPathes , $ pathes ) ; } else { $ vendorPathes [ ] = $ pathes ; } } return $ vendorPathes ; }
11224	private static function getRegexRoutes ( ) { foreach ( self :: $ routes as $ key => $ value ) { unset ( self :: $ routes [ $ key ] ) ; if ( strpos ( $ key , ':' ) !== false ) { self :: any ( $ key , $ value ) ; } } }
1790	private function prepareAlias ( string $ alias , array & $ parameters ) : void { if ( 'index' === $ alias ) { return ; } $ hasAutoItem = false ; $ autoItems = $ this -> getAutoItems ( $ parameters ) ; $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ parameters [ 'alias' ] = preg_replace_callback ( '/\{([^\}]+)\}/' , static function ( array $ matches ) use ( $ alias , & $ parameters , $ autoItems , & $ hasAutoItem , $ config ) : string { $ param = $ matches [ 1 ] ; if ( ! isset ( $ parameters [ $ param ] ) ) { throw new MissingMandatoryParametersException ( sprintf ( 'Parameters "%s" is missing to generate a URL for "%s"' , $ param , $ alias ) ) ; } $ value = $ parameters [ $ param ] ; unset ( $ parameters [ $ param ] ) ; if ( $ hasAutoItem || ! $ config -> get ( 'useAutoItem' ) || ! \ in_array ( $ param , $ autoItems , true ) ) { return $ param . '/' . $ value ; } $ hasAutoItem = true ; return $ value ; } , $ alias ) ; }
880	private function resolveSubset ( $ setName , $ setValue ) { $ rules = $ this -> getSetDefinition ( $ setName ) ; foreach ( $ rules as $ name => $ value ) { if ( '@' === $ name [ 0 ] ) { $ set = $ this -> resolveSubset ( $ name , $ setValue ) ; unset ( $ rules [ $ name ] ) ; $ rules = array_merge ( $ rules , $ set ) ; } elseif ( ! $ setValue ) { $ rules [ $ name ] = false ; } else { $ rules [ $ name ] = $ value ; } } return $ rules ; }
434	private function isIncorrectClassNameOrPrefix ( $ className , $ prefix ) { if ( ! preg_match ( '%^[a-z][a-z0-9\\-_]*$%' , $ className ) ) { return true ; } if ( $ prefix !== '' && ! preg_match ( '%^[a-z0-9_/]+$%i' , $ prefix ) ) { return true ; } return false ; }
460	private function quoteTableNames ( $ tables , & $ params ) { foreach ( $ tables as $ i => $ table ) { if ( $ table instanceof Query ) { list ( $ sql , $ params ) = $ this -> build ( $ table , $ params ) ; $ tables [ $ i ] = "($sql) " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( is_string ( $ i ) ) { if ( strpos ( $ table , '(' ) === false ) { $ table = $ this -> db -> quoteTableName ( $ table ) ; } $ tables [ $ i ] = "$table " . $ this -> db -> quoteTableName ( $ i ) ; } elseif ( strpos ( $ table , '(' ) === false ) { if ( preg_match ( '/^(.*?)(?i:\s+as|)\s+([^ ]+)$/' , $ table , $ matches ) ) { $ tables [ $ i ] = $ this -> db -> quoteTableName ( $ matches [ 1 ] ) . ' ' . $ this -> db -> quoteTableName ( $ matches [ 2 ] ) ; } else { $ tables [ $ i ] = $ this -> db -> quoteTableName ( $ table ) ; } } } return $ tables ; }
11055	public function getBundle ( $ name , $ publish = true ) { if ( $ this -> bundles === false ) { return $ this -> loadDummyBundle ( $ name ) ; } elseif ( ! isset ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , [ ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] instanceof AssetBundle ) { return $ this -> bundles [ $ name ] ; } elseif ( is_array ( $ this -> bundles [ $ name ] ) ) { return $ this -> bundles [ $ name ] = $ this -> loadBundle ( $ name , $ this -> bundles [ $ name ] , $ publish ) ; } elseif ( $ this -> bundles [ $ name ] === false ) { return $ this -> loadDummyBundle ( $ name ) ; } else { throw new InvalidConfigException ( "Invalid asset bundle configuration: $name" ) ; } }
1249	public function createService ( $ namespace , array $ config = [ ] ) { $ configuration = $ this -> config ; if ( isset ( $ this -> config [ $ namespace ] ) ) { $ configuration = arrayMergeDeep ( $ configuration , $ this -> config [ $ namespace ] ) ; } $ configuration = arrayMergeDeep ( $ configuration , $ config ) ; $ service = "DTS\\eBaySDK\\{$namespace}\\Services\\{$namespace}Service" ; return new $ service ( $ configuration ) ; }
8039	public function buildEventData ( array $ data ) { $ start = strtotime ( $ data [ 'start' ] [ 'date' ] . ' ' . $ data [ 'start' ] [ 'time' ] ) ; $ start = date ( 'Y-m-d H:i:s' , $ start ) ; $ end = null ; if ( array_key_exists ( 'end' , $ data ) ) { $ end = strtotime ( $ data [ 'end' ] [ 'date' ] . ' ' . $ data [ 'end' ] [ 'time' ] ) ; $ end = date ( 'Y-m-d H:i:s' , $ end ) ; if ( strtotime ( $ end ) < strtotime ( $ start ) ) { throw new DateDifferenceException ( 'Start date bigger then end date!' ) ; } } $ event = [ 'title' => $ data [ 'title' ] , 'description' => $ data [ 'description' ] , 'start' => $ start , 'end' => $ end , 'all_day' => array_key_exists ( 'all_day' , $ data ) , 'border_color' => $ data [ 'border_color' ] , 'background_color' => $ data [ 'background_color' ] , 'text_color' => $ data [ 'text_color' ] , ] ; return $ event ; }
8436	public static function fetchArray ( array $ conditions , array $ orderBy = null , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( $ entity -> getAllFieldsRealNames ( ) ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( is_array ( $ orderBy ) && count ( $ orderBy ) > 0 ) { $ orders = array ( ) ; foreach ( $ orderBy as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ orders [ $ realName ] = strtoupper ( ucfirst ( $ value ) ) ; } $ selectQuery -> orderBy ( $ orders ) ; } $ selectQuery -> limit ( 1 ) ; if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( is_array ( $ data ) === false ) { return false ; } return $ data ; }
4507	public function created ( JWTCreatedEvent $ event ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; $ data = $ event -> getData ( ) ; $ this -> accessor -> setValue ( $ data , $ this -> property , $ request -> getClientIp ( ) ) ; $ event -> setData ( $ data ) ; }
11862	public function setPairedDataItem ( DataItem $ value ) { $ this -> _pairedDataItem = $ value ; if ( ! isset ( $ this -> _localObject ) && isset ( $ value -> localObject ) ) { $ this -> localObject = $ value -> localObject ; } if ( ! isset ( $ this -> _foreignObject ) && isset ( $ value -> foreignObject ) ) { $ this -> foreignObject = $ value -> foreignObject ; } if ( $ value -> handledDataItem ) { $ this -> handledDataItem = $ value -> handledDataItem ; } }
6576	public function stop ( ) : void { if ( $ this -> isStarted ( ) ) { $ this -> getHandler ( ) -> destroy ( $ this -> getDataHolder ( ) -> getId ( ) ) ; $ this -> dataHolder = null ; } }
8995	protected function addActions ( SymfonyController $ controller , Resource $ resource , $ chainName = '' ) { $ actions = array ( ) ; $ chainName = $ chainName . '_' . strtolower ( str_replace ( array ( '{' , '}' ) , '' , $ resource -> getDisplayName ( ) ) ) ; foreach ( $ resource -> getMethods ( ) as $ method ) { $ actionName = strtolower ( $ method -> getType ( ) ) . str_replace ( ' ' , '' , ucwords ( str_replace ( '_' , ' ' , $ chainName ) ) ) . 'Action' ; $ route = new SymfonyRoute ( $ resource -> getUri ( ) , strtolower ( $ method -> getType ( ) . $ chainName ) ) ; $ action = new SymfonyAction ( $ actionName , $ route , $ method -> getType ( ) , $ method -> getDescription ( ) ) ; preg_match_all ( '/\{[a-zA-Z]+\}/' , $ resource -> getUri ( ) , $ parameters ) ; foreach ( $ parameters [ 0 ] as $ parameter ) { $ action -> addParameter ( substr ( $ parameter , 1 , strlen ( $ parameter ) - 2 ) ) ; } if ( $ method -> getResponses ( ) ) { foreach ( $ method -> getResponses ( ) as $ code => $ response ) { $ headers = array ( ) ; foreach ( $ response -> getHeaders ( ) as $ key => $ value ) { if ( isset ( $ value [ 'required' ] ) && $ value [ 'required' ] ) { $ headers [ $ key ] = isset ( $ value [ 'example' ] ) ? $ value [ 'example' ] : '' ; } } $ _response = new SymfonyResponse ( $ code , $ headers ) ; foreach ( $ this -> config [ 'allowed_response_types' ] as $ allowedResponsetype ) { if ( null !== $ example = $ response -> getExampleByType ( $ allowedResponsetype ) ) { $ _response -> addContent ( new SymfonyResponseContent ( $ allowedResponsetype , str_replace ( array ( "\r\n" , "\n" , "\r" , "\t" , " " ) , '' , $ example ) ) ) ; } } $ action -> addResponse ( $ _response ) ; } } $ controller -> addAction ( $ action ) ; } foreach ( $ resource -> getResources ( ) as $ subresource ) { $ this -> addActions ( $ controller , $ subresource , $ chainName ) ; } }
12530	public function apply ( $ quantity , $ reason , $ comment = '' , $ poiId = null ) { $ params = [ 'quantity' => intval ( $ quantity ) , 'apply_reason' => $ reason , ] ; if ( ! empty ( $ comment ) ) { $ params [ 'comment' ] = $ comment ; } if ( ! is_null ( $ poiId ) ) { $ params [ 'poi_id' ] = intval ( $ poiId ) ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYID , $ params ] ) ; }
10575	public static function apply ( $ text , $ foreground = '' , $ background = '' ) { try { $ style = new OutputFormatterStyle ( ) ; if ( $ foreground != '' ) { $ style -> setForeground ( $ foreground ) ; } if ( $ background != '' ) { $ style -> setBackground ( $ background ) ; } return $ style -> apply ( $ text ) ; } catch ( \ Exception $ e ) { return $ text ; } }
5879	protected static function createIndex ( $ fileName , $ width , $ height ) { $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ targetFilename = PathUtility :: basename ( $ fileName ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( ! isset ( $ storageConfiguration [ 'basePath' ] ) ) { return ; } $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ driver = static :: accessProtectedProperty ( $ targetFolder -> getStorage ( ) , 'driver' ) ; $ fileInfo = $ driver -> getFileInfoByIdentifier ( $ identifier ) ; $ file = $ resourceFactory -> createFileObject ( $ fileInfo ) ; $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ fileRepository -> addToIndex ( $ file ) ; }
2420	public static function moveResource ( $ strSource , $ strDestination ) { $ objFile = FilesModel :: findByPath ( $ strSource ) ; if ( $ objFile === null ) { $ objFile = static :: addResource ( $ strDestination ) ; } $ strFolder = \ dirname ( $ strDestination ) ; if ( $ strFolder == Config :: get ( 'uploadPath' ) ) { $ objFile -> pid = null ; } else { $ objFolder = FilesModel :: findByPath ( $ strFolder ) ; if ( $ objFolder === null ) { $ objFolder = static :: addResource ( $ strFolder ) ; } $ objFile -> pid = $ objFolder -> uuid ; } $ objFile -> path = $ strDestination ; $ objFile -> name = basename ( $ strDestination ) ; $ objFile -> save ( ) ; if ( $ objFile -> type == 'folder' ) { $ objFiles = FilesModel :: findMultipleByBasepath ( $ strSource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> path = preg_replace ( '@^' . preg_quote ( $ strSource , '@' ) . '/@' , $ strDestination . '/' , $ objFiles -> path ) ; $ objFiles -> save ( ) ; } } } if ( ( $ strPath = \ dirname ( $ strSource ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } if ( ( $ strPath = \ dirname ( $ strDestination ) ) != Config :: get ( 'uploadPath' ) ) { static :: updateFolderHashes ( $ strPath ) ; } return $ objFile ; }
12352	public function allow ( array $ level_select = [ "min" => 4 , "max" => 4 ] ) : bool { if ( $ this -> details !== false ) { if ( is_array ( $ level_select ) === true && isset ( $ level_select [ "min" ] ) === true && isset ( $ level_select [ "max" ] ) === true ) { $ level_select [ "min" ] = Model \ Role :: find ( $ level_select [ "min" ] ) -> priority ; $ level_select [ "max" ] = Model \ Role :: find ( $ level_select [ "max" ] ) -> priority ; $ level_select = [ "min" => $ level_select [ "min" ] , "max" => $ level_select [ "max" ] ] ; } else { return false ; } $ current_priority = $ this -> details -> role -> priority ; if ( is_numeric ( $ level_select [ "min" ] ) === true && is_numeric ( $ level_select [ "max" ] ) === true ) { if ( $ level_select [ "min" ] >= $ current_priority && $ level_select [ "max" ] <= $ current_priority ) { return true ; } else { return false ; } } else { return false ; } } else { return false ; } }
1976	public static function findMultipleFoldersByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='folder' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
1562	protected function deserializeAttribute ( $ value , $ field , $ record ) { if ( $ this -> isDateAttribute ( $ field , $ record ) ) { return $ this -> deserializeDate ( $ value , $ field , $ record ) ; } $ method = 'deserialize' . Str :: classify ( $ field ) . 'Field' ; if ( method_exists ( $ this , $ method ) ) { return $ this -> { $ method } ( $ value , $ record ) ; } return $ value ; }
2496	private function getIndexFieldName ( int $ depth ) : string { if ( $ depth === 0 ) { return self :: $ fieldName ; } return sprintf ( self :: $ relatedContentFieldName , $ depth ) ; }
11070	public function setBoolean ( string $ key , $ value , bool $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( bool ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
11401	public function startAt ( $ startAt = 0 ) { if ( ! is_numeric ( $ startAt ) || $ startAt < 0 ) { throw new Exception ( "startAt: bad value" , 10 ) ; } $ this -> startAt = $ startAt ; return $ this ; }
4778	public function addWidget ( ItemInterface $ item ) { if ( $ this -> checkRole ) { if ( $ item -> getRole ( ) && ! $ this -> security -> isGranted ( $ item -> getRole ( ) ) ) { return $ this ; } } $ this -> widgets [ $ item -> getId ( ) ] = $ item ; return $ this ; }
11796	public function setSubject ( $ subject = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'subject' ) ; } $ this -> subject = $ subject ; return $ this ; }
1540	public function withQualifiedColumn ( $ column ) { $ parts = explode ( '.' , $ column ) ; if ( ! isset ( $ parts [ 1 ] ) ) { throw new \ InvalidArgumentException ( 'Expecting a valid qualified column name.' ) ; } $ this -> withColumn ( $ parts [ 1 ] ) ; return $ this ; }
1902	public function prepare ( $ strQuery ) { if ( $ strQuery == '' ) { throw new \ Exception ( 'Empty query string' ) ; } $ this -> strQuery = trim ( $ strQuery ) ; if ( strncasecmp ( $ this -> strQuery , 'INSERT' , 6 ) === 0 || strncasecmp ( $ this -> strQuery , 'UPDATE' , 6 ) === 0 ) { $ this -> strQuery = str_replace ( '%s' , '%p' , $ this -> strQuery ) ; } $ arrChunks = preg_split ( "/('[^']*')/" , $ this -> strQuery , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; foreach ( $ arrChunks as $ k => $ v ) { if ( substr ( $ v , 0 , 1 ) == "'" ) { continue ; } $ arrChunks [ $ k ] = str_replace ( '?' , '%s' , $ v ) ; } $ this -> strQuery = implode ( '' , $ arrChunks ) ; return $ this ; }
4924	public function type ( $ className ) { if ( ! class_exists ( $ className ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Class %s is non-existent or could not be loaded' , $ className ) ) ; } $ this -> matrix [ $ this -> currentRegion ] [ ] = $ className ; return $ this ; }
6065	public function listSocialMediaFiles ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/socialmedia/files' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentFile ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12762	public function set ( $ name , $ value , $ expire = 0 , $ path = null , $ domain = null , $ secure = false , $ httpOnly = false ) { if ( $ expire === - 1 ) { $ expire = time ( ) + 3600 * 24 * 365 ; } else { $ expire *= 60 ; } $ value = base64_encode ( $ value ) ; if ( $ path != null ) { if ( $ domain != null ) { if ( $ secure ) { if ( $ httpOnly ) { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure , $ httpOnly ) ; } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain , $ secure ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path , $ domain ) ; } } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } } else { setcookie ( $ name , $ value , $ expire ) ; } }
8378	public function setAction ( AbstractAction $ action ) { $ this -> action = $ action ; $ this -> action -> setArrayContainer ( $ this ) ; return $ this ; }
6612	public static function getDropdownMap ( $ keyAttribute , $ valueAttribute , array $ default = [ ] ) { $ map = ArrayHelper :: map ( self :: getActive ( ) , $ keyAttribute , $ valueAttribute ) ; if ( $ default ) { $ map = array_merge ( $ default , $ map ) ; } return $ map ; }
10665	public function enableBlockMode ( ) : void { if ( ! $ this -> enableProtection ) { throw new MiddlewareException ( $ this , "You can't enable the block mode because the XSS protection is disabled" ) ; } if ( $ this -> reportUri ) { throw new MiddlewareException ( $ this , sprintf ( "You can't enable the block mode because the report mode is already enabled (see %s)" , 'https://developer.mozilla.org/docs/Web/HTTP/Headers/X-XSS-Protection' ) ) ; } $ this -> blockMode = true ; }
1324	public static function decode ( $ string , $ asArray ) { if ( version_compare ( PHP_VERSION , '5.4.0' , '>=' ) && ! ( defined ( 'JSON_C_VERSION' ) && PHP_INT_SIZE > 4 ) ) { return json_decode ( $ string , $ asArray , 512 , JSON_BIGINT_AS_STRING ) ; } return json_decode ( $ string , $ asArray ) ; }
3308	protected function signature ( ) { $ signatureKey = $ this -> buildSignatureKey ( ) ; $ sing = hash_hmac ( 'SHA1' , $ signatureKey , $ this -> secretKey , true ) ; return base64_encode ( $ sing . $ signatureKey ) ; }
8517	public function setInventoryRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'InventoryRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11490	public function destroyWithCookie ( ) : ? bool { if ( $ this -> isStarted ( ) ) { $ this -> destroy ( ) ; return setcookie ( $ this -> getName ( ) , '' , time ( ) - 1 , '/' ) ; } return null ; }
3746	public function setBaseConfig ( array $ arrConfig ) { if ( ! $ arrConfig [ 'source' ] ) { throw new \ RuntimeException ( 'Missing table name.' ) ; } $ this -> strTable = $ arrConfig [ 'source' ] ; $ this -> metaModel = $ arrConfig [ 'metaModel' ] ; }
1757	public static function getReadableSize ( $ intSize , $ intDecimals = 1 ) { for ( $ i = 0 ; $ intSize >= 1024 ; $ i ++ ) { $ intSize /= 1024 ; } return static :: getFormattedNumber ( $ intSize , $ intDecimals ) . ' ' . $ GLOBALS [ 'TL_LANG' ] [ 'UNITS' ] [ $ i ] ; }
3535	public static function createOrRefreshUser ( $ username , $ individualGroupAssignmentOptions = null ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'createOrRefreshUser' , static :: YII2_PROFILE_NAME . 'createOrRefreshUser' ) ; } $ userObjectDb = static :: findOne ( [ 'username' => $ username ] ) ; if ( $ userObjectDb == null ) { $ userObjectDb = static :: createNewUser ( $ username , $ individualGroupAssignmentOptions ) ; } else { $ userObjectDb -> setIndividualGroupAssignmentOptions ( $ individualGroupAssignmentOptions ) ; $ userObjectDb -> updateAccountStatus ( ) ; $ userObjectDb -> updateGroupAssignment ( ) ; } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'createOrRefreshUser' , static :: YII2_PROFILE_NAME . 'createOrRefreshUser' ) ; } return $ userObjectDb ; }
10435	public function post ( $ request ) { if ( $ request instanceof Request ) { $ request = $ request -> xml ( ) ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ this -> url ) ; if ( $ this -> user_agent != null ) { curl_setopt ( $ ch , CURLOPT_USERAGENT , $ this -> user_agent ) ; } curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ request ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-type: application/xml; charset=utf-8' , ) ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( empty ( $ response ) ) { return null ; } return $ response ; }
6757	public function supportsDenormalization ( $ data , $ type , $ format = null ) { if ( ! \ class_exists ( $ type ) ) { return false ; } $ classAnnotation = $ this -> annotationReader -> getClassAnnotation ( new \ ReflectionClass ( $ type ) , NestedPropertyDenormalizerAnnotation :: class ) ; return $ classAnnotation instanceof NestedPropertyDenormalizerAnnotation ; }
9442	public function getManyWithoutReplacement ( $ n ) { if ( ! is_integer ( $ n ) || $ n < 2 ) { throw new \ InvalidArgumentException ( 'You must take 2 or more items in this case.' ) ; } if ( $ this -> range -> as_integer ) { $ arr_range = range ( $ this -> range -> min , $ this -> range -> max ) ; $ max_takable = count ( $ arr_range ) ; shuffle ( $ arr_range ) ; if ( $ n > $ max_takable ) { throw new \ OutOfRangeException ( sprintf ( 'Cannot take without replacement more than available items into range [%d;%d]' , $ this -> range -> min , $ this -> range -> max ) ) ; } elseif ( $ n == $ max_takable ) { return array_values ( $ arr_range ) ; } else { return array_slice ( $ arr_range , 0 , $ n ) ; } } else { $ arr_out = array ( ) ; while ( count ( $ arr_out ) < $ n ) { $ r = $ this -> get ( ) ; if ( ! in_array ( $ r , $ arr_out ) ) { $ arr_out [ ] = $ r ; } } return $ arr_out ; } }
9051	protected function getMessage ( $ level , $ message , array $ context = array ( ) ) : MemoryStream { self :: checkLevel ( $ level ) ; $ ms = new MemoryStream ( ) ; $ ms -> write ( strftime ( "%Y-%m-%d %H:%M:%S" , time ( ) ) ) ; $ ms -> interpolate ( "\t[{level}]: " , array ( 'level' => sprintf ( "%6.6s" , $ level ) ) ) ; $ ms -> interpolate ( $ message , $ context ) ; $ ms -> write ( "\n" ) ; return $ ms ; }
7943	public function deleteSecondaryDnsDomains ( $ domain , $ domain2delete ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; $ domain2delete = ( string ) $ domain2delete ; if ( ! $ domain2delete ) throw new BadMethodCallException ( 'Parameter $domain2getInfo is missing.' ) ; try { $ r = $ this -> delete ( 'dedicated/server/' . $ domain . '/secondaryDnsDomains/' . $ domain2delete ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } }
4040	protected function generateOption ( $ val , $ index ) { $ checked = '' ; if ( is_array ( $ this -> varValue ) && in_array ( $ val [ 'value' ] , $ this -> varValue ) ) { $ checked = ' checked="checked"' ; } return sprintf ( '<span class="%1$s opt_%2$s">' . '<input type="checkbox" name="%8$s[]" id="opt_%3$s" class="checkbox" value="%4$s"%5$s%6$s ' . '<label id="lbl_%3$s" for="opt_%3$s">%7$s</label></span>' , $ this -> getClassForOption ( $ index ) , $ index , $ this -> strName . '_' . $ index , $ val [ 'value' ] , $ checked , $ this -> getAttributes ( ) . $ this -> strTagEnding , $ val [ 'label' ] , $ this -> strName ) ; }
6987	protected function fillFromCustomer ( ContextInterface $ context , CustomerInterface $ customer ) : void { if ( null === $ context -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ customer -> getCustomerGroup ( ) ) ; } if ( null === $ context -> getInvoiceCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultInvoiceAddress ( true ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } } if ( null === $ context -> getDeliveryCountry ( ) ) { if ( null !== $ address = $ customer -> getDefaultDeliveryAddress ( true ) ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } } }
6186	public function renderInclude ( $ name , $ path = null ) { $ twigConfig = Config :: load ( 'twig' ) ; $ pathFile = pathFile ( $ name ) ; $ folder = $ pathFile [ 0 ] ; $ name = $ pathFile [ 1 ] ; $ path = $ twigConfig -> get ( 'setTemplateDir' ) . DIRECTORY_SEPARATOR . $ folder . $ name . $ twigConfig -> get ( 'fileExtension' , '.twig' ) ; try { if ( ! is_file ( $ path ) ) { throw new ViewException ( 'Can not open template ' . $ name . ' in: ' . $ path ) ; } $ renderInclude = $ this -> twig -> render ( $ name , $ this -> assign ) ; } catch ( ViewException $ e ) { echo $ e -> getMessage ( ) . '<br /> File: ' . $ e -> getFile ( ) . '<br /> Code line: ' . $ e -> getLine ( ) . '<br /> Trace: ' . $ e -> getTraceAsString ( ) ; exit ( ) ; } return $ renderInclude ; }
871	public static function getDisplayableAllowedValues ( FixerOptionInterface $ option ) { $ allowed = $ option -> getAllowedValues ( ) ; if ( null !== $ allowed ) { $ allowed = array_filter ( $ allowed , static function ( $ value ) { return ! ( $ value instanceof \ Closure ) ; } ) ; usort ( $ allowed , static function ( $ valueA , $ valueB ) { if ( $ valueA instanceof AllowedValueSubset ) { return - 1 ; } if ( $ valueB instanceof AllowedValueSubset ) { return 1 ; } return strcasecmp ( self :: toString ( $ valueA ) , self :: toString ( $ valueB ) ) ; } ) ; if ( 0 === \ count ( $ allowed ) ) { $ allowed = null ; } } return $ allowed ; }
12573	public function previewVideo ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , $ by ) ; }
783	public function actionReport ( $ sourcePath , $ translationPath , $ title = 'Translation report' ) { $ sourcePath = trim ( $ sourcePath , '/\\' ) ; $ translationPath = trim ( $ translationPath , '/\\' ) ; $ results = [ ] ; $ dir = new DirectoryIterator ( $ sourcePath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ sourceFilePath = $ sourcePath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( $ translatedFilePath ) ; $ diff = empty ( $ errors ) ? $ this -> getDiff ( $ translatedFilePath , $ sourceFilePath ) : '' ; if ( ! empty ( $ diff ) ) { $ errors [ ] = 'Translation outdated.' ; } $ result = [ 'errors' => $ errors , 'diff' => $ diff , ] ; $ results [ $ fileinfo -> getFilename ( ) ] = $ result ; } } $ dir = new DirectoryIterator ( $ translationPath ) ; foreach ( $ dir as $ fileinfo ) { if ( ! $ fileinfo -> isDot ( ) && ! $ fileinfo -> isDir ( ) ) { $ translatedFilePath = $ translationPath . '/' . $ fileinfo -> getFilename ( ) ; $ errors = $ this -> checkFiles ( null , $ translatedFilePath ) ; if ( ! empty ( $ errors ) ) { $ results [ $ fileinfo -> getFilename ( ) ] [ 'errors' ] = $ errors ; } } } echo $ this -> renderFile ( __DIR__ . '/views/translation/report_html.php' , [ 'results' => $ results , 'sourcePath' => $ sourcePath , 'translationPath' => $ translationPath , 'title' => $ title , ] ) ; }
2041	public static function symlink ( string $ target , string $ link , string $ rootDir ) : void { static :: validateSymlink ( $ target , $ link , $ rootDir ) ; $ fs = new Filesystem ( ) ; if ( ! $ fs -> isAbsolutePath ( $ target ) ) { $ target = $ rootDir . '/' . $ target ; } if ( ! $ fs -> isAbsolutePath ( $ link ) ) { $ link = $ rootDir . '/' . $ link ; } if ( '\\' === \ DIRECTORY_SEPARATOR ) { $ fs -> symlink ( $ target , $ link ) ; } else { $ fs -> symlink ( rtrim ( $ fs -> makePathRelative ( $ target , \ dirname ( $ link ) ) , '/' ) , $ link ) ; } }
5091	private function asScalarSubQuery ( $ callback , $ default = false ) { $ sql = $ this -> sql ; $ this -> sql = $ callback ( $ sql ) ; $ result = $ this -> queryScalar ( null ) ; $ this -> sql = $ sql ; return ( is_null ( $ result ) ? $ default : $ result ) ; }
1768	public function listNewsArticles ( $ arrRow ) { return '<div class="tl_content_left">' . $ arrRow [ 'headline' ] . ' <span style="color:#999;padding-left:3px">[' . Contao \ Date :: parse ( Contao \ Config :: get ( 'datimFormat' ) , $ arrRow [ 'date' ] ) . ']</span></div>' ; }
7156	private function setSubjectData ( StockSubjectInterface $ subject , $ inStock = .0 , $ availableStock = .0 , $ virtualStock = .0 , \ DateTime $ eda = null ) { $ changed = false ; if ( $ inStock != $ subject -> getInStock ( ) ) { $ subject -> setInStock ( $ inStock ) ; $ changed = true ; } if ( $ availableStock != $ subject -> getAvailableStock ( ) ) { $ subject -> setAvailableStock ( $ availableStock ) ; $ changed = true ; } if ( $ virtualStock != $ subject -> getVirtualStock ( ) ) { $ subject -> setVirtualStock ( $ virtualStock ) ; $ changed = true ; } if ( $ eda !== $ subject -> getEstimatedDateOfArrival ( ) ) { $ subject -> setEstimatedDateOfArrival ( $ eda ) ; $ changed = true ; } return $ changed ; }
9690	public function render ( $ file , $ env = array ( ) ) { $ file = $ this -> views_path . '/' . $ file ; if ( ! file_exists ( $ file ) ) { throw new \ Exception ( "Could not compile $file, file not found" ) ; } $ cacheHash = md5 ( $ file . serialize ( $ env ) ) ; $ cache_file = $ this -> views_cache . "/$cacheHash.cache" ; if ( ! $ this -> debug && ( file_exists ( $ cache_file ) && filemtime ( $ cache_file ) > filemtime ( $ file ) ) ) { return file_get_contents ( $ cache_file ) ; } $ this -> currFile = $ file ; $ hash = md5 ( $ file ) ; $ this -> compile ( $ file ) ; $ compiled_file = $ this -> views_cache . '/' . $ hash ; set_error_handler ( array ( $ this , 'onTemplateError' ) ) ; require_once ( $ compiled_file ) ; $ output = call_user_func ( 'katar_' . $ hash , $ env ) ; restore_error_handler ( ) ; file_put_contents ( $ cache_file , $ output ) ; return $ output ; }
12598	public function isCacheable ( $ namespace ) { if ( ! $ this -> cacheOptions -> isEnabled ( ) ) { return false ; } $ namespaces = $ this -> cacheOptions -> getNamespaces ( ) ; if ( empty ( $ namespaces ) ) { return true ; } return in_array ( $ namespace , $ namespaces ) ; }
3814	private function injectServiceContainerIntoDataDrivers ( $ providerDefinitions , $ environment ) { foreach ( $ providerDefinitions as $ provider ) { $ providerInstance = $ environment -> getDataProvider ( $ provider -> getName ( ) ) ; if ( $ providerInstance instanceof Driver ) { $ initialization = $ provider -> getInitializationData ( ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ initialization [ 'source' ] ) ; $ providerInstance -> setBaseConfig ( array_merge ( $ initialization , [ 'metaModel' => $ metaModel ] ) ) ; $ providerInstance -> setDispatcher ( $ this -> dispatcher ) ; $ providerInstance -> setConnection ( $ this -> connection ) ; } } }
8383	public function fetchAll ( ) { if ( $ this -> statement == null || $ this -> getErrorState ( ) != '00000' ) { return false ; } return $ this -> statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; }
175	public static function remove ( & $ array , $ key , $ default = null ) { if ( is_array ( $ array ) && ( isset ( $ array [ $ key ] ) || array_key_exists ( $ key , $ array ) ) ) { $ value = $ array [ $ key ] ; unset ( $ array [ $ key ] ) ; return $ value ; } return $ default ; }
10272	function addCustomProperties ( $ mailingId , $ properties ) { $ xml = new SimpleXMLElement ( "<?xml version=\"1.0\"?><properties></properties>" ) ; if ( is_array ( $ properties ) ) { foreach ( $ properties as $ property ) { $ this -> sxml_append ( $ xml , $ property -> toXML ( ) ) ; } } else { $ this -> sxml_append ( $ xml , $ properties -> toXML ( ) ) ; } return $ this -> post ( "mailings/${mailingId}/settings/properties" , $ xml -> asXML ( ) ) ; }
12628	public function register ( Application $ app ) { if ( is_null ( $ this -> filename ) ) { throw new \ RuntimeException ( 'You must provide a valid config filename' ) ; } if ( ! file_exists ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not valid' , $ this -> filename ) ) ; } if ( ! is_readable ( $ this -> filename ) ) { throw new \ RuntimeException ( sprintf ( 'Config path \'%s\' is not readable' , $ this -> filename ) ) ; } $ parser = new YamlParser ( ) ; $ config = $ parser -> parse ( file_get_contents ( $ this -> filename ) ) ; if ( is_array ( $ config ) && ! empty ( $ config ) ) { if ( isset ( $ app [ 'config' ] ) && is_array ( $ app [ 'config' ] ) ) { $ config = array_replace_recursive ( $ app [ 'config' ] , $ config ) ; } $ app [ 'config' ] = $ config ; } }
7822	protected function refreshPipelines ( ) { $ yaml = $ this -> parser -> dump ( $ this -> pipelines ) ; $ this -> files -> put ( $ this -> getSource ( ) , $ yaml ) ; }
1265	public function recoverLabel ( $ trackingData , $ labelSpecification = null , $ labelDelivery = null , $ translate = null ) { if ( is_array ( $ trackingData ) ) { if ( ! isset ( $ trackingData [ 'value' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `value`.' ) ; } if ( ! isset ( $ trackingData [ 'shipperNumber' ] ) ) { throw new InvalidArgumentException ( '$trackingData parameter is required to contain `shipperNumber`.' ) ; } } if ( ! empty ( $ translate ) ) { if ( ! isset ( $ translateOpts [ 'language' ] ) ) { $ translateOpts [ 'language' ] = 'eng' ; } if ( ! isset ( $ translateOpts [ 'dialect' ] ) ) { $ translateOpts [ 'dialect' ] = 'US' ; } } $ request = $ this -> createRecoverLabelRequest ( $ trackingData , $ labelSpecification , $ labelDelivery , $ translate ) ; $ response = $ this -> request ( $ this -> createAccess ( ) , $ request , $ this -> compileEndpointUrl ( $ this -> recoverLabelEndpoint ) ) ; if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { unset ( $ response -> Response ) ; return $ this -> formatResponse ( $ response ) ; } }
11356	public function getInputFilter ( ) { if ( $ this -> filter ) { return $ this -> filter ; } $ specifications = [ ] ; if ( $ this -> object && $ this -> object instanceof InputFilterProviderInterface ) { $ specifications = $ this -> object -> getInputFilterSpecification ( ) ; } if ( $ this instanceof InputFilterProviderInterface ) { $ specifications = ArrayUtils :: merge ( $ specifications , $ this -> getInputFilterSpecification ( ) ) ; } $ this -> addRequiredAttributeToFields ( $ specifications ) ; if ( ! empty ( $ specifications ) && null === $ this -> baseFieldset ) { $ formFactory = $ this -> getFormFactory ( ) ; $ inputFactory = $ formFactory -> getInputFilterFactory ( ) ; if ( ! ( $ this -> filter instanceof InputFilterInterface ) ) { $ this -> filter = new InputFilter ( ) ; $ this -> filter -> setFactory ( $ inputFactory ) ; } foreach ( $ specifications as $ name => $ specification ) { $ input = $ inputFactory -> createInput ( $ specification ) ; $ this -> filter -> add ( $ input , $ name ) ; } } return parent :: getInputFilter ( ) ; }
7225	public function content ( $ decodeJson = false ) { return $ decodeJson && preg_match ( "~^application/json.*~" , $ this -> lastResultType ) && $ this -> lastResult ? from_json ( $ this -> lastResult ) : $ this -> lastResult ; }
6719	private function handleAuthorizeResponse ( $ response ) { $ status = ArrayHelper :: getValue ( $ response , 'status' ) ; if ( ! is_null ( $ status ) && $ status == 'success' ) { $ code = ArrayHelper :: getValue ( $ response , 'data.code' ) ; if ( is_null ( $ code ) ) { throw new Oauth2ClientException ( self :: CODE_NOT_SET ) ; } return $ code ; } else { $ message = ArrayHelper :: getValue ( $ response , 'message' , self :: DEFAULT_ERROR ) ; throw new Oauth2ClientException ( $ message ) ; } }
99	public function addPsr4 ( $ prefix , $ paths , $ prepend = false ) { if ( ! $ prefix ) { if ( $ prepend ) { $ this -> fallbackDirsPsr4 = array_merge ( ( array ) $ paths , $ this -> fallbackDirsPsr4 ) ; } else { $ this -> fallbackDirsPsr4 = array_merge ( $ this -> fallbackDirsPsr4 , ( array ) $ paths ) ; } } elseif ( ! isset ( $ this -> prefixDirsPsr4 [ $ prefix ] ) ) { $ length = strlen ( $ prefix ) ; if ( '\\' !== $ prefix [ $ length - 1 ] ) { throw new \ InvalidArgumentException ( "A non-empty PSR-4 prefix must end with a namespace separator." ) ; } $ this -> prefixLengthsPsr4 [ $ prefix [ 0 ] ] [ $ prefix ] = $ length ; $ this -> prefixDirsPsr4 [ $ prefix ] = ( array ) $ paths ; } elseif ( $ prepend ) { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( ( array ) $ paths , $ this -> prefixDirsPsr4 [ $ prefix ] ) ; } else { $ this -> prefixDirsPsr4 [ $ prefix ] = array_merge ( $ this -> prefixDirsPsr4 [ $ prefix ] , ( array ) $ paths ) ; } }
3030	public function pauseSession ( AssessmentTestSession $ session ) { $ session -> updateDuration ( ) ; return $ this -> getDeliveryExecution ( $ session ) -> setState ( DeliveryExecution :: STATE_PAUSED ) ; }
8901	public function update_batch ( $ data , $ where_key ) { $ _data = array ( ) ; foreach ( $ data as $ key => $ row ) { if ( false !== $ row = $ this -> _do_pre_update ( $ row ) ) { $ _data [ $ key ] = $ row ; } } return $ this -> _database -> update_batch ( $ this -> _table , $ _data , $ where_key ) ; }
5177	public function map ( \ Closure $ callback , $ context = [ ] ) : self { $ collection = new static ( ) ; foreach ( $ this -> props as $ key => $ value ) { $ collection -> add ( $ key , $ callback ( $ value , $ key , $ context ) ) ; } return $ collection ; }
11687	public function getAccompanyingPeriodsOrdered ( ) { $ periods = $ this -> getAccompanyingPeriods ( ) -> toArray ( ) ; usort ( $ periods , function ( $ a , $ b ) { $ dateA = $ a -> getOpeningDate ( ) ; $ dateB = $ b -> getOpeningDate ( ) ; if ( $ dateA == $ dateB ) { $ dateEA = $ a -> getClosingDate ( ) ; $ dateEB = $ b -> getClosingDate ( ) ; if ( $ dateEA == $ dateEB ) { return 0 ; } if ( $ dateEA < $ dateEB ) { return - 1 ; } else { return + 1 ; } } if ( $ dateA < $ dateB ) { return - 1 ; } else { return 1 ; } } ) ; return $ periods ; }
12674	public function getForeignModelConfig ( $ sourceFile , $ modelName ) { $ config = [ 'class' => Model :: className ( ) ] ; if ( isset ( $ this -> foreignModelsConfig [ $ modelName ] ) ) { $ config = array_merge ( $ config , $ this -> foreignModelsConfig [ $ modelName ] ) ; } $ config [ 'modelName' ] = $ modelName ; $ config [ 'sourceFile' ] = $ sourceFile ; $ config [ 'interface' ] = $ this ; return $ config ; }
4309	public function getChannel ( $ channelName , $ config = array ( ) ) { if ( \ strpos ( $ channelName , '.' ) !== false ) { $ this -> error ( 'getChannel(): channelName should not contain period (.)' ) ; return $ this ; } if ( ! isset ( $ this -> channels [ $ channelName ] ) ) { $ cfg = $ this -> getCfg ( ) ; $ cfg = \ array_diff_key ( $ cfg , \ array_flip ( array ( 'errorEmailer' , 'errorHandler' , 'output' , ) ) ) ; unset ( $ cfg [ 'debug' ] [ 'onBootstrap' ] ) ; $ cfg [ 'debug' ] [ 'channel' ] = $ this -> parentInstance ? $ this -> cfg [ 'channel' ] . '.' . $ channelName : $ channelName ; $ cfg [ 'debug' ] [ 'parent' ] = $ this ; $ this -> channels [ $ channelName ] = new static ( $ cfg ) ; if ( $ config ) { $ this -> channels [ $ channelName ] -> setCfg ( $ config ) ; } } return $ this -> channels [ $ channelName ] ; }
44	public function dispatchScript ( $ eventName , $ devMode = false , $ additionalArgs = array ( ) , $ flags = array ( ) ) { return $ this -> doDispatch ( new Script \ Event ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ additionalArgs , $ flags ) ) ; }
9082	private static function parseRemoteHost ( Request & $ request , $ serverVars = array ( ) ) { if ( isset ( $ serverVars [ 'REMOTE_ADDR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'REMOTE_ADDR' ] ; } if ( isset ( $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ) ) { $ request -> remoteHost = $ serverVars [ 'HTTP_X_FORWARDED_FOR' ] ; } }
7588	public function setFileName ( $ fileName ) { $ fileName = preg_replace ( "([^\w\s\d\-_~,;\[\]\(\).])" , '' , $ fileName ) ; $ fileName = preg_replace ( "([\.]{2,})" , '' , $ fileName ) ; $ this -> fileName = $ fileName ; return $ this ; }
4512	public function kernelView ( GetResponseForControllerResultEvent $ event ) { $ request = $ event -> getRequest ( ) ; if ( ! $ request -> query -> has ( 'locale' ) ) { return ; } $ controllerResult = $ event -> getControllerResult ( ) ; $ locale = $ request -> query -> get ( 'locale' ) ; if ( $ controllerResult instanceof Paginator || is_array ( $ controllerResult ) ) { foreach ( $ controllerResult as $ model ) { if ( $ model instanceof Localizable ) { $ this -> localeService -> localize ( $ model , $ locale ) ; } } } elseif ( $ controllerResult instanceof Localizable ) { $ this -> localeService -> localize ( $ controllerResult , $ locale ) ; } $ event -> setControllerResult ( $ controllerResult ) ; }
5103	public static function appendSet ( $ values , $ forceExist = false ) { if ( $ forceExist && ! $ values ) throw new SquidException ( 'SET clause must be present for this type of command!' ) ; return Assembly :: append ( 'SET' , $ values , ', ' ) ; }
1950	public function resendToken ( Contao \ DataContainer $ dc ) { $ model = Contao \ OptInModel :: findByPk ( $ dc -> id ) ; Contao \ System :: getContainer ( ) -> get ( 'contao.opt-in' ) -> find ( $ model -> token ) -> send ( ) ; Contao \ Message :: addConfirmation ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'resendToken' ] , $ model -> email ) ) ; Contao \ Controller :: redirect ( $ this -> getReferer ( ) ) ; }
3442	public function fetchUsing ( $ methodAndParams ) { if ( is_string ( $ methodAndParams ) || empty ( $ methodAndParams [ 'method' ] ) ) { $ this -> fetchUsing = in_array ( $ methodAndParams , [ 'GetNext' , 'getNext' ] ) ? [ 'method' => 'GetNext' , 'params' => [ true , true ] ] : [ 'method' => 'Fetch' ] ; return $ this ; } if ( in_array ( $ methodAndParams [ 'method' ] , [ 'GetNext' , 'getNext' ] ) ) { $ bTextHtmlAuto = isset ( $ methodAndParams [ 'params' ] [ 0 ] ) ? $ methodAndParams [ 'params' ] [ 0 ] : true ; $ useTilda = isset ( $ methodAndParams [ 'params' ] [ 1 ] ) ? $ methodAndParams [ 'params' ] [ 1 ] : true ; $ this -> fetchUsing = [ 'method' => 'GetNext' , 'params' => [ $ bTextHtmlAuto , $ useTilda ] ] ; } else { $ this -> fetchUsing = [ 'method' => 'Fetch' ] ; } return $ this ; }
1313	public function setRetries ( $ maxRetries , $ retriesDelay ) { $ this -> maxRetries = ( int ) $ maxRetries ; $ this -> retriesDelay = ( int ) $ retriesDelay ; }
8473	public function warning ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'warning' , $ scope , $ message , $ context , $ config ) ; }
1533	protected function isFillableRelation ( $ field , $ record ) { return $ this -> isRelation ( $ field ) && $ this -> isFillable ( $ field , $ record ) ; }
1885	public function getItemsAsString ( $ strSeparator = ' ' ) { $ arrLinks = array ( ) ; foreach ( $ this -> getItemsAsArray ( ) as $ arrItem ) { if ( $ arrItem [ 'href' ] === null ) { $ arrLinks [ ] = sprintf ( '<li><strong class="active">%s</strong></li>' , $ arrItem [ 'page' ] ) ; } else { $ arrLinks [ ] = sprintf ( '<li><a href="%s" class="link" title="%s">%s</a></li>' , $ arrItem [ 'href' ] , $ arrItem [ 'title' ] , $ arrItem [ 'page' ] ) ; } } return implode ( $ strSeparator , $ arrLinks ) ; }
10046	function isEmpty ( ) { $ result = ! isset ( $ this -> id ) && ! isset ( $ this -> external_id ) && ! isset ( $ this -> email ) ; return $ result ; }
310	protected function composeMessage ( $ body ) { $ message = $ this -> mailer -> compose ( ) ; Yii :: configure ( $ message , $ this -> message ) ; $ message -> setTextBody ( $ body ) ; return $ message ; }
1350	public function none ( string ... $ resourceTypes ) : self { foreach ( $ resourceTypes as $ resourceType ) { $ this -> allow ( $ resourceType , [ ] ) ; } return $ this ; }
4524	protected function createZoneFromDefinition ( array $ definition ) { $ zone = new Zone ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; if ( isset ( $ definition [ 'scope' ] ) ) { $ this -> scope = $ definition [ 'scope' ] ; } if ( isset ( $ definition [ 'priority' ] ) ) { $ this -> priority = $ definition [ 'priority' ] ; } } , $ zone , '\CommerceGuys\Zone\Model\Zone' ) ; $ setValues ( $ definition ) ; foreach ( $ definition [ 'members' ] as $ memberDefinition ) { if ( $ memberDefinition [ 'type' ] == 'country' ) { $ zoneMember = $ this -> createZoneMemberCountryFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } elseif ( $ memberDefinition [ 'type' ] == 'zone' ) { $ zoneMember = $ this -> createZoneMemberZoneFromDefinition ( $ memberDefinition ) ; $ zone -> addMember ( $ zoneMember ) ; } } return $ zone ; }
7290	static public function isValidMode ( $ mode , $ throw = true ) { if ( in_array ( $ mode , static :: getModes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid adjustment mode.' ) ; } return false ; }
8296	public function write ( $ data ) { if ( ! is_string ( $ data ) ) { throw new \ InvalidArgumentException ( "The data is not a string." ) ; } $ this -> open ( ) ; if ( ! ftruncate ( $ this -> handle , 0 ) ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not truncate file " . $ this -> filePath ) ; } fseek ( $ this -> handle , 0 ) ; $ res = fwrite ( $ this -> handle , $ data ) ; if ( strlen ( $ data ) !== $ res ) { $ this -> writeErrors = true ; throw new \ RuntimeException ( "Could not write to file " . $ this -> filePath ) ; } }
8469	public function emergency ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'emergency' , $ scope , $ message , $ context , $ config ) ; }
8796	public function helper ( $ name , $ directory = 'Helpers' ) { $ file = app_path ( $ directory . DIRECTORY_SEPARATOR . $ name . '.php' ) ; if ( file_exists ( $ file ) ) { return require $ file ; } throw new ExceptionHandler ( 'Oppss! File not found.' , 'Helper::' . $ name . ' not found.' ) ; }
6878	private function getRevenueQuery ( ) { if ( null !== $ this -> revenueQuery ) { return $ this -> revenueQuery ; } $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ expr = $ qb -> expr ( ) ; return $ this -> revenueQuery = $ qb -> select ( [ 'o.date' , 'o.revenue' , 'o.details' ] ) -> andWhere ( $ expr -> eq ( 'o.type' , ':type' ) ) -> andWhere ( $ expr -> gte ( 'o.date' , ':from' ) ) -> andWhere ( $ expr -> lte ( 'o.date' , ':to' ) ) -> addOrderBy ( 'o.date' ) -> getQuery ( ) ; }
20	protected function propagate ( $ level ) { while ( $ this -> decisions -> validOffset ( $ this -> propagateIndex ) ) { $ decision = $ this -> decisions -> atOffset ( $ this -> propagateIndex ) ; $ conflict = $ this -> watchGraph -> propagateLiteral ( $ decision [ Decisions :: DECISION_LITERAL ] , $ level , $ this -> decisions ) ; $ this -> propagateIndex ++ ; if ( $ conflict ) { return $ conflict ; } } return null ; }
3715	public function addKnownAttributeType ( $ typeName ) { if ( ! is_array ( $ this -> attributeTypes ) ) { throw new \ LogicException ( 'Filter setting ' . $ this -> typeClass . ' can not handle attributes.' ) ; } $ this -> attributeTypes [ $ typeName ] = $ typeName ; return $ this ; }
308	protected function createRule ( $ pattern , $ prefix , $ action ) { $ verbs = 'GET|HEAD|POST|PUT|PATCH|DELETE|OPTIONS' ; if ( preg_match ( "/^((?:($verbs),)*($verbs))(?:\\s+(.*))?$/" , $ pattern , $ matches ) ) { $ verbs = explode ( ',' , $ matches [ 1 ] ) ; $ pattern = isset ( $ matches [ 4 ] ) ? $ matches [ 4 ] : '' ; } else { $ verbs = [ ] ; } $ config = $ this -> ruleConfig ; $ config [ 'verb' ] = $ verbs ; $ config [ 'pattern' ] = rtrim ( $ prefix . '/' . strtr ( $ pattern , $ this -> tokens ) , '/' ) ; $ config [ 'route' ] = $ action ; if ( ! empty ( $ verbs ) && ! in_array ( 'GET' , $ verbs ) ) { $ config [ 'mode' ] = WebUrlRule :: PARSING_ONLY ; } $ config [ 'suffix' ] = $ this -> suffix ; return Yii :: createObject ( $ config ) ; }
6472	public function getBestEncodingMatch ( IMediaTypeFormatter $ formatter , array $ acceptCharsetHeaders , ? MediaTypeHeaderValue $ mediaTypeHeader ) : ? string { $ rankedAcceptCharsetHeaders = $ this -> rankAcceptCharsetHeaders ( $ acceptCharsetHeaders ) ; foreach ( $ rankedAcceptCharsetHeaders as $ acceptCharsetHeader ) { foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ acceptCharsetHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } } if ( $ mediaTypeHeader === null || $ mediaTypeHeader -> getCharset ( ) === null ) { return null ; } foreach ( $ formatter -> getSupportedEncodings ( ) as $ supportedEncoding ) { $ charset = $ mediaTypeHeader -> getCharset ( ) ; if ( $ charset === '*' || strcasecmp ( $ charset , $ supportedEncoding ) === 0 ) { return $ supportedEncoding ; } } return null ; }
633	public function delete ( $ table , $ condition = '' , $ params = [ ] ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> delete ( $ table , $ condition , $ params ) ; return $ this -> setSql ( $ sql ) -> bindValues ( $ params ) ; }
649	public function dropCommentFromColumn ( $ table , $ column ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> dropCommentFromColumn ( $ table , $ column ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7054	public function message_id_header ( $ headers , $ iac_options , $ item_ID ) { $ type = ( 'iac_comment_headers' == current_filter ( ) ) ? 'comment' : 'post' ; $ item = ( 'post' == $ type ) ? get_post ( $ item_ID ) : get_comment ( $ item_ID ) ; $ headers [ 'Message-ID' ] = '<' . Iac_Mail_ID :: generate_ID ( $ type , $ item ) . '>' ; return $ headers ; }
10087	private function createZip ( $ pFilename ) { $ zip = new ZipArchive ( ) ; if ( file_exists ( $ pFilename ) ) { unlink ( $ pFilename ) ; } if ( $ zip -> open ( $ pFilename , ZipArchive :: OVERWRITE ) !== true ) { if ( $ zip -> open ( $ pFilename , ZipArchive :: CREATE ) !== true ) { throw new WriterException ( "Could not open $pFilename for writing." ) ; } } return $ zip ; }
4071	public function getJavascripts ( GetOptionsEvent $ event ) { if ( ( $ event -> getEnvironment ( ) -> getDataDefinition ( ) -> getName ( ) !== 'tl_metamodel_rendersettings' ) || ( $ event -> getPropertyName ( ) !== 'additionalJs' ) || ( $ event -> getSubPropertyName ( ) !== 'file' ) ) { return ; } $ event -> setOptions ( $ this -> scanFiles ( 'js' ) ) ; }
5728	public function Field ( $ properties = array ( ) ) { Requirements :: css ( BETTER_BUTTONS_DIR . '/css/dropdown_form_action.css' ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/dropdown_form_action.js' ) ; $ this -> setAttribute ( 'data-form-action-dropdown' , '#' . $ this -> DropdownID ( ) ) ; return parent :: Field ( ) ; }
4938	protected function getOptionsConfig ( $ fullName ) { if ( array_key_exists ( $ fullName , $ this -> optionsConfig ) ) { return $ this -> optionsConfig [ $ fullName ] ; } return false ; }
9919	private function findColumns ( Model $ model ) { $ tableName = $ this -> getTableName ( $ model ) ; if ( ! $ this -> databaseRepository -> hasTable ( $ tableName ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Table %s for %s does not exist!' , $ tableName , $ model -> getName ( ) ) ) ; } $ columns = $ this -> databaseRepository -> getColumnListing ( $ tableName ) ; foreach ( $ columns as $ columnName ) { $ columnType = $ this -> databaseRepository -> getColumnType ( $ tableName , $ columnName ) ; $ model -> addColumn ( new Column ( $ columnName , $ columnType ) ) ; } }
7096	public function get ( string $ name ) : Block { if ( isset ( $ this -> _blocks [ $ name ] ) ) return $ this -> _blocks [ $ name ] ; $ this -> _blocks [ $ name ] = new $ this -> block_class ( $ name ) ; return $ this -> _blocks [ $ name ] ; }
9909	public function setPositionXL ( $ positionXL ) { if ( ! isset ( self :: $ positionXLref [ $ positionXL ] ) ) { return false ; } $ this -> position = self :: $ positionXLref [ $ positionXL ] ; return true ; }
12149	public function getReservedCodes ( ) { $ reserved = [ ] ; foreach ( $ this -> factories as $ factoryClass => $ factory ) { $ reserved [ $ factoryClass ] = $ factory -> getReservedDiapason ( ) ; } return $ reserved ; }
12533	public function bindLocation ( array $ deviceIdentifier , $ poiId , $ type = 1 , $ poiAppid = null ) { $ params = [ 'device_identifier' => $ deviceIdentifier , 'poi_id' => intval ( $ poiId ) , ] ; if ( $ type === 2 ) { if ( is_null ( $ poiAppid ) ) { throw new InvalidArgumentException ( 'If value of argument #3 is 2, argument #4 is required.' ) ; } $ params [ 'type' ] = 2 ; $ params [ 'poi_appid' ] = $ poiAppid ; } return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_BINDLOCATION , $ params ] ) ; }
11256	private function resolve ( string $ class ) : AbstractSeed { $ instance = $ this -> autowire ( $ class ) ; $ instance -> setDatabase ( $ this -> database ) ; $ instance -> setSeeder ( $ this ) ; if ( ! is_null ( $ this -> container ) ) { $ instance -> setContainer ( $ this -> container ) ; } return $ instance ; }
297	public function getDirtyAttributes ( $ names = null ) { if ( $ names === null ) { $ names = $ this -> attributes ( ) ; } $ names = array_flip ( $ names ) ; $ attributes = [ ] ; if ( $ this -> _oldAttributes === null ) { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } else { foreach ( $ this -> _attributes as $ name => $ value ) { if ( isset ( $ names [ $ name ] ) && ( ! array_key_exists ( $ name , $ this -> _oldAttributes ) || $ value !== $ this -> _oldAttributes [ $ name ] ) ) { $ attributes [ $ name ] = $ value ; } } } return $ attributes ; }
191	public function setStatusCodeByException ( $ e ) { if ( $ e instanceof HttpException ) { $ this -> setStatusCode ( $ e -> statusCode ) ; } else { $ this -> setStatusCode ( 500 ) ; } return $ this ; }
4313	protected function autoloader ( $ className ) { $ className = \ ltrim ( $ className , '\\' ) ; if ( ! \ strpos ( $ className , '\\' ) ) { return ; } $ psr4Map = array ( 'bdk\\Debug\\' => __DIR__ , 'bdk\\PubSub\\' => __DIR__ . '/../PubSub' , 'bdk\\ErrorHandler\\' => __DIR__ . '/../ErrorHandler' , ) ; foreach ( $ psr4Map as $ namespace => $ dir ) { if ( \ strpos ( $ className , $ namespace ) === 0 ) { $ rel = \ substr ( $ className , \ strlen ( $ namespace ) ) ; $ rel = \ str_replace ( '\\' , '/' , $ rel ) ; require $ dir . '/' . $ rel . '.php' ; return ; } } $ classMap = array ( 'bdk\\ErrorHandler' => __DIR__ . '/../ErrorHandler/ErrorHandler.php' , ) ; if ( isset ( $ classMap [ $ className ] ) ) { require $ classMap [ $ className ] ; } }
1992	public static function getMetaData ( $ strData , $ strLanguage ) { if ( empty ( $ strLanguage ) ) { return array ( ) ; } $ arrData = StringUtil :: deserialize ( $ strData ) ; $ strLanguage = str_replace ( '-' , '_' , $ strLanguage ) ; if ( ! \ is_array ( $ arrData ) || ! isset ( $ arrData [ $ strLanguage ] ) ) { return array ( ) ; } return $ arrData [ $ strLanguage ] ; }
884	private function getBestDelimiter ( $ pattern ) { $ delimiters = [ ] ; foreach ( self :: $ delimiters as $ k => $ d ) { if ( false === strpos ( $ pattern , $ d ) ) { return $ d ; } $ delimiters [ $ d ] = [ substr_count ( $ pattern , $ d ) , $ k ] ; } uasort ( $ delimiters , static function ( $ a , $ b ) { if ( $ a [ 0 ] === $ b [ 0 ] ) { return Utils :: cmpInt ( $ a , $ b ) ; } return $ a [ 0 ] < $ b [ 0 ] ? - 1 : 1 ; } ) ; return key ( $ delimiters ) ; }
10802	public function savePageHistoricAction ( ) { $ responseData = $ this -> params ( ) -> fromRoute ( 'datas' , $ this -> params ( ) -> fromQuery ( 'datas' , '' ) ) ; $ idPage = isset ( $ responseData [ 'idPage' ] ) ? $ responseData [ 'idPage' ] : ( ! empty ( $ responseData [ 0 ] [ 'idPage' ] ) ? ( $ responseData [ 0 ] [ 'idPage' ] ) : 0 ) ; $ isNew = isset ( $ responseData [ 'isNew' ] ) ? $ responseData [ 'isNew' ] : ( ! empty ( $ responseData [ 0 ] [ 'isNew' ] ) ? ( $ responseData [ 0 ] [ 'isNew' ] ) : 0 ) ; $ response = array ( 'idPage' => $ idPage , 'isNew' => $ isNew ) ; $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_start' , $ this , $ response ) ; $ melisCoreAuth = $ this -> getServiceLocator ( ) -> get ( 'MelisCoreAuth' ) ; $ melisPageHistoricTable = $ this -> getServiceLocator ( ) -> get ( 'MelisPageHistoricTable' ) ; $ pageAction = $ this -> params ( ) -> fromRoute ( 'pageActionUsed' , $ this -> params ( ) -> fromQuery ( 'pageActionUsed' , '' ) ) ; $ histDatas = array ( ) ; $ container = new Container ( 'meliscms' ) ; $ datas = array ( ) ; if ( isset ( $ container [ 'action-page-tmp' ] [ 'success' ] ) && $ container [ 'action-page-tmp' ] [ 'success' ] == 0 ) return ; if ( ! empty ( $ container [ 'action-page-tmp' ] ) ) { if ( ! empty ( $ container [ 'action-page-tmp' ] [ 'datas' ] ) ) $ datas = $ container [ 'action-page-tmp' ] [ 'datas' ] ; } $ description = '' ; switch ( $ pageAction ) { case 'Save' : if ( $ isNew ) { $ description = 'tr_melispagehistoric_description_text_new' ; } else { $ description = 'tr_melispagehistoric_description_text_save' ; } break ; case 'Publish' : $ description = 'tr_melispagehistoric_description_text_publish' ; break ; case 'Unpublish' : $ description = 'tr_melispagehistoric_description_text_unpublished' ; break ; } if ( $ idPage ) { $ userId = ( int ) null ; $ userAuthDatas = $ melisCoreAuth -> getStorage ( ) -> read ( ) ; if ( $ userAuthDatas ) $ userId = $ userAuthDatas -> usr_id ; $ histDatas = array ( 'hist_page_id' => $ idPage , 'hist_action' => $ pageAction , 'hist_date' => date ( 'Y-m-d H:i:s' ) , 'hist_user_id' => $ userId , 'hist_description' => $ description ) ; $ melisPageHistoricTable -> save ( $ histDatas ) ; } $ this -> getEventManager ( ) -> trigger ( 'meliscmspagehistoric_historic_save_end' , $ this , $ histDatas ) ; }
4895	public function render ( $ type = null , $ content = true , array $ options = array ( ) ) { if ( is_array ( $ type ) ) { $ options = $ type ; $ type = self :: TYPE_INFO ; $ content = true ; } elseif ( is_array ( $ content ) ) { $ options = $ content ; $ content = true ; } if ( true === $ content ) { return $ this -> start ( $ type , $ options ) ; } $ id = isset ( $ options [ 'id' ] ) ? ' id="' . $ options [ 'id' ] . '"' : '' ; $ class = isset ( $ options [ 'class' ] ) ? ' ' . $ options [ 'class' ] : '' ; if ( ( isset ( $ options [ 'dismissable' ] ) && $ options [ 'dismissable' ] ) || ! isset ( $ options [ 'dismissable' ] ) ) { $ class .= ' alert-dismissable' ; $ content = '<button type="button" class="close" data-dismiss="alert">&times;</button>' . '<span class="notification-content">' . $ content . '</span>' ; } $ target = array_key_exists ( 'target' , $ options ) ? ' target="' . $ options [ 'target' ] . '"' : '' ; $ markup = '<div ' . $ id . ' class="alert alert-' . $ type . $ class . '" ' . $ target . '>' . $ content . '</div>' . PHP_EOL ; return $ markup ; }
12580	public function previewVideoByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VIDEO , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
3614	public function setTargetTemperatures ( $ temp_low , $ temp_high , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_low = $ this -> temperatureInCelsius ( $ temp_low , $ serial_number ) ; $ temp_high = $ this -> temperatureInCelsius ( $ temp_high , $ serial_number ) ; $ data = json_encode ( array ( 'target_change_pending' => TRUE , 'target_temperature_low' => $ temp_low , 'target_temperature_high' => $ temp_high ) ) ; return $ this -> doPOST ( "/v2/put/shared." . $ serial_number , $ data ) ; }
1007	public static function isValidNameError ( $ name , $ node = null ) { self :: invariant ( is_string ( $ name ) , 'Expected string' ) ; if ( isset ( $ name [ 1 ] ) && $ name [ 0 ] === '_' && $ name [ 1 ] === '_' ) { return new Error ( sprintf ( 'Name "%s" must not begin with "__", which is reserved by ' , $ name ) . 'GraphQL introspection.' , $ node ) ; } if ( ! preg_match ( '/^[_a-zA-Z][_a-zA-Z0-9]*$/' , $ name ) ) { return new Error ( sprintf ( 'Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "%s" does not.' , $ name ) , $ node ) ; } return null ; }
3825	protected function compile ( ) { $ objItemRenderer = new ItemList ( ) ; $ this -> Template -> searchable = ! $ this -> metamodel_donotindex ; $ sorting = $ this -> metamodel_sortby ; $ direction = $ this -> metamodel_sortby_direction ; if ( $ this -> metamodel_sort_override ) { if ( \ Input :: get ( 'orderBy' ) ) { $ sorting = \ Input :: get ( 'orderBy' ) ; } if ( \ Input :: get ( 'orderDir' ) ) { $ direction = \ Input :: get ( 'orderDir' ) ; } } $ objItemRenderer -> setServiceContainerFallback ( function ( ) { return $ this -> getServiceContainer ( ) ; } ) -> setFactory ( System :: getContainer ( ) -> get ( 'metamodels.factory' ) ) -> setFilterFactory ( System :: getContainer ( ) -> get ( 'metamodels.filter_setting_factory' ) ) -> setRenderSettingFactory ( System :: getContainer ( ) -> get ( 'metamodels.render_setting_factory' ) ) -> setEventDispatcher ( System :: getContainer ( ) -> get ( 'event_dispatcher' ) ) -> setMetaModel ( $ this -> metamodel , $ this -> metamodel_rendersettings ) -> setLimit ( $ this -> metamodel_use_limit , $ this -> metamodel_offset , $ this -> metamodel_limit ) -> setPageBreak ( $ this -> perPage ) -> setSorting ( $ sorting , $ direction ) -> setFilterSettings ( $ this -> metamodel_filtering ) -> setFilterParameters ( StringUtil :: deserialize ( $ this -> metamodel_filterparams , true ) , $ this -> getFilterParameters ( $ objItemRenderer ) ) -> setMetaTags ( $ this -> metamodel_meta_title , $ this -> metamodel_meta_description ) ; $ this -> Template -> items = \ StringUtil :: encodeEmail ( $ objItemRenderer -> render ( $ this -> metamodel_noparsing , $ this ) ) ; $ this -> Template -> numberOfItems = $ objItemRenderer -> getItems ( ) -> getCount ( ) ; $ this -> Template -> pagination = $ objItemRenderer -> getPagination ( ) ; }
655	protected function reset ( ) { $ this -> _sql = null ; $ this -> _pendingParams = [ ] ; $ this -> params = [ ] ; $ this -> _refreshTableName = null ; $ this -> _isolationLevel = false ; $ this -> _retryHandler = null ; }
4984	public function setParams ( array $ params ) { $ this -> params = array_merge ( $ this -> params , $ params ) ; foreach ( $ this -> forms as $ form ) { if ( isset ( $ form [ '__instance__' ] ) && is_object ( $ form [ '__instance__' ] ) && method_exists ( $ form [ '__instance__' ] , 'setParams' ) ) { $ form [ '__instance__' ] -> setParams ( $ params ) ; } } return $ this ; }
1605	public function findAllRedirects ( $ currentSiteOnly = false ) { if ( $ currentSiteOnly ) return RedirectRecord :: find ( ) -> where ( '[[siteId]] IS NULL OR [[siteId]] = ' . \ Craft :: $ app -> sites -> currentSite -> id ) -> orderBy ( 'siteId asc' ) -> all ( ) ; return array_reduce ( RedirectRecord :: find ( ) -> all ( ) , function ( $ a , RedirectRecord $ record ) { $ a [ $ record -> siteId ?? 'null' ] [ ] = $ record ; return $ a ; } , array_reduce ( \ Craft :: $ app -> sites -> allSiteIds , function ( $ a , $ id ) { $ a [ $ id ] = [ ] ; return $ a ; } , [ ] ) ) ; }
9995	private function writeComment ( Worksheet $ pSheet , $ coordinate ) { $ result = '' ; if ( ! $ this -> isPdf && isset ( $ pSheet -> getComments ( ) [ $ coordinate ] ) ) { $ result .= '<a class="comment-indicator"></a>' ; $ result .= '<div class="comment">' . nl2br ( $ pSheet -> getComment ( $ coordinate ) -> getText ( ) -> getPlainText ( ) ) . '</div>' ; $ result .= PHP_EOL ; } return $ result ; }
4623	public function execute ( Command $ command ) { $ response = $ this -> getActiveNode ( ) -> execute ( $ command , $ this -> api ) ; if ( empty ( $ response ) && count ( $ this -> nodes ) > 1 && $ this -> attempts < $ this -> getConfigValue ( 'max_connect_attempts' ) ) { $ response = $ this -> pickNewNode ( ) -> execute ( $ command ) ; } elseif ( empty ( $ response ) && $ this -> attempts >= $ this -> getConfigValue ( 'max_connect_attempts' ) ) { throw new Exception ( 'Nodes unreachable. Error Msg: ' . $ this -> api -> getError ( ) ) ; } elseif ( $ response == false ) { throw new Exception ( 'Command failed to execute against Riak. Error Msg: ' . $ this -> api -> getError ( ) ) ; } return $ response ; }
7813	public static function toGregorianStr ( $ j_date , $ sep = '/' ) { $ arr = explode ( $ sep , $ j_date ) ; if ( count ( $ arr ) < 3 || intval ( $ arr [ 0 ] ) == 0 ) return "" ; else $ g_date = jDateTime :: toGregorian ( $ arr [ 2 ] , $ arr [ 1 ] , $ arr [ 0 ] ) ; return implode ( $ sep , $ g_date ) ; }
2270	public function getSizeOf ( $ strTable ) { $ statement = $ this -> resConnection -> executeQuery ( 'SHOW TABLE STATUS LIKE ' . $ this -> resConnection -> quote ( $ strTable ) ) ; $ status = $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ; return $ status [ 'Data_length' ] + $ status [ 'Index_length' ] ; }
12143	public static function user ( ) { if ( ! static :: $ user and static :: $ factory ) { $ id = static :: provider ( ) -> get ( 'id' ) ; static :: $ user = call_user_func ( static :: $ factory , $ id ) ; } return static :: $ user ; }
326	public static function sentence ( array $ words , $ twoWordsConnector = null , $ lastWordConnector = null , $ connector = ', ' ) { if ( $ twoWordsConnector === null ) { $ twoWordsConnector = Yii :: t ( 'yii' , ' and ' ) ; } if ( $ lastWordConnector === null ) { $ lastWordConnector = $ twoWordsConnector ; } switch ( count ( $ words ) ) { case 0 : return '' ; case 1 : return reset ( $ words ) ; case 2 : return implode ( $ twoWordsConnector , $ words ) ; default : return implode ( $ connector , array_slice ( $ words , 0 , - 1 ) ) . $ lastWordConnector . end ( $ words ) ; } }
3849	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'tableName' ) ) { return ; } $ tableName = strtolower ( $ event -> getValue ( ) ) ; if ( ! strlen ( $ tableName ) ) { throw new \ RuntimeException ( 'Table name not given' ) ; } if ( substr ( $ tableName , 0 , 3 ) !== 'mm_' ) { $ tableName = 'mm_' . $ tableName ; } $ dataProvider = $ event -> getEnvironment ( ) -> getDataProvider ( 'tl_metamodel' ) ; try { if ( ! $ event -> getModel ( ) -> getId ( ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } else { $ oldVersion = $ dataProvider -> fetch ( $ dataProvider -> getEmptyConfig ( ) -> setId ( $ event -> getModel ( ) -> getId ( ) ) ) ; if ( $ oldVersion -> getProperty ( 'tableName' ) !== $ event -> getModel ( ) -> getProperty ( 'tableName' ) ) { $ this -> tableManipulator -> checkTableDoesNotExist ( $ tableName ) ; } } } catch ( \ Exception $ exception ) { throw new \ RuntimeException ( $ exception -> getMessage ( ) , $ exception -> getCode ( ) , $ exception ) ; } $ event -> setValue ( $ tableName ) ; }
259	protected function findViewFile ( $ view , $ context = null ) { if ( strncmp ( $ view , '@' , 1 ) === 0 ) { $ file = Yii :: getAlias ( $ view ) ; } elseif ( strncmp ( $ view , '//' , 2 ) === 0 ) { $ file = Yii :: $ app -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } elseif ( strncmp ( $ view , '/' , 1 ) === 0 ) { if ( Yii :: $ app -> controller !== null ) { $ file = Yii :: $ app -> controller -> module -> getViewPath ( ) . DIRECTORY_SEPARATOR . ltrim ( $ view , '/' ) ; } else { throw new InvalidCallException ( "Unable to locate view file for view '$view': no active controller." ) ; } } elseif ( $ context instanceof ViewContextInterface ) { $ file = $ context -> getViewPath ( ) . DIRECTORY_SEPARATOR . $ view ; } elseif ( ( $ currentViewFile = $ this -> getRequestedViewFile ( ) ) !== false ) { $ file = dirname ( $ currentViewFile ) . DIRECTORY_SEPARATOR . $ view ; } else { throw new InvalidCallException ( "Unable to resolve view file for view '$view': no active view context." ) ; } if ( pathinfo ( $ file , PATHINFO_EXTENSION ) !== '' ) { return $ file ; } $ path = $ file . '.' . $ this -> defaultExtension ; if ( $ this -> defaultExtension !== 'php' && ! is_file ( $ path ) ) { $ path = $ file . '.php' ; } return $ path ; }
6103	public function request ( $ cmd , $ throw = true ) { $ query = StringHelper :: factory ( $ cmd ) -> section ( TeamSpeak3 :: SEPARATOR_CELL ) ; if ( strstr ( $ cmd , "\r" ) || strstr ( $ cmd , "\n" ) ) { throw new Ts3Exception ( "illegal characters in command '" . $ query . "'" ) ; } elseif ( in_array ( $ query , $ this -> block ) ) { throw new Ts3Exception ( "command not found" , 0x100 ) ; } Signal :: getInstance ( ) -> emit ( "serverqueryCommandStarted" , $ cmd ) ; $ this -> getProfiler ( ) -> start ( ) ; $ this -> getTransport ( ) -> sendLine ( $ cmd ) ; $ this -> timer = time ( ) ; $ this -> count ++ ; $ rpl = array ( ) ; do { $ str = $ this -> getTransport ( ) -> readLine ( ) ; $ rpl [ ] = $ str ; } while ( $ str instanceof StringHelper && $ str -> section ( TeamSpeak3 :: SEPARATOR_CELL ) != TeamSpeak3 :: ERROR ) ; $ this -> getProfiler ( ) -> stop ( ) ; $ reply = new Reply ( $ rpl , $ cmd , $ this -> getHost ( ) , $ throw ) ; Signal :: getInstance ( ) -> emit ( "serverqueryCommandFinished" , $ cmd , $ reply ) ; return $ reply ; }
132	public function disablePlugins ( ) { foreach ( $ this -> installers as $ i => $ installer ) { if ( ! $ installer instanceof PluginInstaller ) { continue ; } unset ( $ this -> installers [ $ i ] ) ; } }
4229	protected function errorHash ( $ errorValues ) { $ errMsg = $ errorValues [ 'message' ] ; $ errMsg = \ preg_replace ( '/(\(.*?)\d+(.*?\))/' , '\1x\2' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b([a-z]+\d+)+\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\b[\d.-]{4,}\b/' , 'xxx' , $ errMsg ) ; $ errMsg = \ preg_replace ( '/\s*##.+$/' , '' , $ errMsg ) ; $ hash = \ md5 ( $ errorValues [ 'file' ] . $ errorValues [ 'line' ] . $ errorValues [ 'type' ] . $ errMsg ) ; return $ hash ; }
822	private function fixSemicolonAfterCurlyBraceClose ( Tokens $ tokens , $ index , $ curlyCloseIndex ) { static $ beforeCurlyOpeningKinds = null ; if ( null === $ beforeCurlyOpeningKinds ) { $ beforeCurlyOpeningKinds = [ T_ELSE , T_FINALLY , T_NAMESPACE , T_OPEN_TAG ] ; } $ curlyOpeningIndex = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ curlyCloseIndex ) ; $ beforeCurlyOpening = $ tokens -> getPrevMeaningfulToken ( $ curlyOpeningIndex ) ; if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( $ beforeCurlyOpeningKinds ) || $ tokens [ $ beforeCurlyOpening ] -> equalsAny ( [ ';' , '{' , '}' ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeCurlyOpening ] -> isGivenKind ( T_STRING ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ beforeCurlyOpening ) ; while ( $ tokens [ $ classyTest ] -> equals ( ',' ) || $ tokens [ $ classyTest ] -> isGivenKind ( [ T_STRING , T_NS_SEPARATOR , T_EXTENDS , T_IMPLEMENTS ] ) ) { $ classyTest = $ tokens -> getPrevMeaningfulToken ( $ classyTest ) ; } $ tokensAnalyzer = new TokensAnalyzer ( $ tokens ) ; if ( $ tokens [ $ classyTest ] -> isGivenKind ( T_NAMESPACE ) || ( $ tokens [ $ classyTest ] -> isClassy ( ) && ! $ tokensAnalyzer -> isAnonymousClass ( $ classyTest ) ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } return ; } if ( ! $ tokens [ $ beforeCurlyOpening ] -> equals ( ')' ) ) { return ; } $ openingBrace = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ beforeCurlyOpening ) ; $ beforeOpeningBrace = $ tokens -> getPrevMeaningfulToken ( $ openingBrace ) ; if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( [ T_IF , T_ELSEIF , T_FOR , T_FOREACH , T_WHILE , T_SWITCH , T_CATCH , T_DECLARE ] ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; return ; } if ( $ tokens [ $ beforeOpeningBrace ] -> isGivenKind ( T_STRING ) ) { $ beforeString = $ tokens -> getPrevMeaningfulToken ( $ beforeOpeningBrace ) ; if ( $ tokens [ $ beforeString ] -> isGivenKind ( T_FUNCTION ) ) { $ tokens -> clearTokenAndMergeSurroundingWhitespace ( $ index ) ; } } }
9346	public function getCol ( $ int = 0 ) { if ( $ int >= $ this -> size -> cols ) { throw new \ OutOfRangeException ( 'There is not column having this index.' ) ; } $ arr_out = array ( ) ; foreach ( $ this -> arr as $ row ) { $ arr_out [ ] = $ row [ $ int ] ; } return $ arr_out ; }
504	protected function renderHtmlResponse ( ) { return $ this -> controller -> render ( $ this -> view ? : $ this -> id , $ this -> getViewRenderParams ( ) ) ; }
5522	public function generate ( $ methods ) { if ( ! $ this -> reflection -> classOrInterfaceExists ( ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { return false ; } $ code = $ this -> createCodeForClass ( $ methods ? $ methods : array ( ) ) ; return eval ( "$code return \$code;" ) ; }
11071	public function setInteger ( string $ key , $ value , int $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( int ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
1206	protected function renderLink ( ItemInterface $ item , array $ options = array ( ) ) { if ( $ item -> getUri ( ) && ( ! $ item -> isCurrent ( ) || $ options [ 'currentAsLink' ] ) ) { $ text = $ this -> renderLinkElement ( $ item , $ options ) ; } else { $ text = $ this -> renderSpanElement ( $ item , $ options ) ; } return $ this -> format ( $ text , 'link' , $ item -> getLevel ( ) , $ options ) ; }
11131	public static function getRootBackslash ( $ pathname ) { if ( $ pathname [ 0 ] == '\\' ) { $ pathname = substr ( $ pathname , 1 ) ; } $ arr = explode ( '\\' , $ pathname ) ; if ( count ( $ arr ) > 1 ) { return $ arr [ 0 ] ; } return '' ; }
9299	public function postAction ( Request $ request ) { try { $ data = $ this -> get ( 'ongr_api.batch_request_handler' ) -> handleRequest ( $ request , $ repository = $ this -> getRequestRepository ( $ request ) , 'create' ) ; return $ this -> renderRest ( $ request , $ data , Response :: HTTP_OK ) ; } catch ( \ Exception $ e ) { return $ this -> renderError ( $ request , $ e -> getMessage ( ) , Response :: HTTP_BAD_REQUEST ) ; } }
881	private function fixTypes ( Annotation $ annotation ) { $ types = $ annotation -> getTypes ( ) ; $ new = $ this -> normalizeTypes ( $ types ) ; if ( $ types !== $ new ) { $ annotation -> setTypes ( $ new ) ; } }
7018	private function format_h ( & $ str ) { if ( strstr ( $ str , '%h' ) ) { $ h = $ this -> hour > 12 ? $ this -> hour - 12 : $ this -> hour ; $ str = str_replace ( '%h' , sprintf ( '%02d' , $ h ) , $ str ) ; } }
10562	private function _buildControllerName ( $ name ) { $ name = strtoupper ( $ name [ 0 ] ) . substr ( $ name , 1 ) ; $ controller = $ name ; $ namespace = NULL ; foreach ( $ this -> namespaces as $ ns ) { if ( class_exists ( $ ns . $ controller ) ) { $ namespace = $ ns ; $ controller = $ ns . $ controller ; break ; } } if ( NULL === $ namespace ) { return strtoupper ( $ this -> defaultController [ 0 ] ) . substr ( $ this -> defaultController , 1 ) . 'Controller' ; } else { return $ controller ; } }
10831	public static function createFromSplFileInfo ( \ SplFileInfo $ info ) { $ realpath = $ info -> getRealPath ( ) ; if ( $ info -> isFile ( ) ) { return new fs \ entity \ FileEntity ( $ realpath ) ; } return new fs \ entity \ DirEntity ( $ realpath ) ; }
6821	protected function compare ( float $ a , float $ b ) { return Money :: compare ( $ a , $ b , $ this -> currency ) ; }
9003	protected function extra_tablenav ( $ which ) { if ( $ which !== 'top' ) { return ; } $ this -> months_dropdown ( '' ) ; $ selected = isset ( $ _GET [ 'level' ] ) ? $ _GET [ 'level' ] : '' ; ?> <label for="filter-by-level" class="screen-reader-text"> <?php echo $ this -> translations [ 'levelFilterLabel' ] ; ?> </label> <select name="level" id="filter-by-level"> <option value=""> <?php echo $ this -> translations [ 'allLevels' ] ; ?> </option> <?php foreach ( $ this -> get_levels ( ) as $ level => $ label ) : ?> <option value=" <?php echo esc_attr ( $ level ) ; ?> " <?php selected ( $ selected , $ level ) ; ?> > <?php echo $ label ; ?> </option> <?php endforeach ; ?> </select> <?php submit_button ( $ this -> translations [ 'filter' ] , 'button' , 'filter_action' , false ) ; }
11103	public function filter ( ScopeInterface $ scope ) { $ filtered = new self ; foreach ( $ this as $ eachResult ) { if ( $ eachResult -> getScope ( ) -> isEqualTo ( $ scope ) ) { $ filtered -> add ( $ eachResult ) ; } } return $ filtered ; }
9846	public function createSealedRequest ( string $ method , string $ uri , string $ body , SealingPublicKey $ key , array $ headers = [ ] ) : RequestInterface { return new Request ( $ method , Uri :: createFromString ( $ uri ) , new Headers ( $ headers ) , [ ] , [ ] , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) , [ ] ) ; }
9130	public static function create ( $ name , SymfonyRoute $ route , $ method , $ description = '' ) { return new static ( $ name , $ route , $ method , $ description ) ; }
12540	public static function camelize ( $ str , $ ucfirst = false ) { $ replace = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '_' , '-' ] , ' ' , strtolower ( $ str ) ) ) ) ; if ( ! $ ucfirst ) { return lcfirst ( $ replace ) ; } return $ replace ; }
1045	public static function createFromException ( $ e , $ debug = false , $ internalErrorMessage = null ) { Utils :: invariant ( $ e instanceof Exception || $ e instanceof Throwable , 'Expected exception, got %s' , Utils :: getVariableType ( $ e ) ) ; $ internalErrorMessage = $ internalErrorMessage ? : self :: $ internalErrorMessage ; if ( $ e instanceof ClientAware ) { $ formattedError = [ 'message' => $ e -> isClientSafe ( ) ? $ e -> getMessage ( ) : $ internalErrorMessage , 'extensions' => [ 'category' => $ e -> getCategory ( ) , ] , ] ; } else { $ formattedError = [ 'message' => $ internalErrorMessage , 'extensions' => [ 'category' => Error :: CATEGORY_INTERNAL , ] , ] ; } if ( $ e instanceof Error ) { $ locations = Utils :: map ( $ e -> getLocations ( ) , static function ( SourceLocation $ loc ) { return $ loc -> toSerializableArray ( ) ; } ) ; if ( ! empty ( $ locations ) ) { $ formattedError [ 'locations' ] = $ locations ; } if ( ! empty ( $ e -> path ) ) { $ formattedError [ 'path' ] = $ e -> path ; } if ( ! empty ( $ e -> getExtensions ( ) ) ) { $ formattedError [ 'extensions' ] = $ e -> getExtensions ( ) + $ formattedError [ 'extensions' ] ; } } if ( $ debug ) { $ formattedError = self :: addDebugEntries ( $ formattedError , $ e , $ debug ) ; } return $ formattedError ; }
12242	public function asPrettyXML ( $ filepath = null ) { $ xml = dom_import_simplexml ( new SimpleXMLElement ( $ this -> asXML ( ) ) ) ; $ xsl = new DOMDocument ; $ xsl -> loadXML ( '<?xml version="1.0" encoding="utf-8"?><xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"> <xsl:output method="xml" indent="yes" /> <xsl:template match="text()"> <!-- remove everything that contains only whitespace, with at least one LF ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; $ result = trim ( $ xslt -> transformToXML ( $ xml ) ) ; if ( isset ( $ filepath ) ) { return ( bool ) file_put_contents ( $ filepath , $ result ) ; } return $ result ; }
7136	public function merge ( Margin $ margin ) : void { $ this -> purchaseCost += $ margin -> getPurchaseCost ( ) ; $ this -> sellingPrice += $ margin -> getSellingPrice ( ) ; $ this -> average = $ this -> average || $ margin -> isAverage ( ) ; }
9267	public function recipe ( string $ string , string $ method , callable $ callback = null ) : string { return preg_replace_callback ( RegEx :: REGEX_SPACE , [ $ this , $ method ] , $ this -> callback ( $ string , $ callback ) ) ; }
7626	public function containerExists ( $ containerName = '' ) { Assertion :: notEmpty ( $ containerName , 'Container name is not specified' ) ; self :: assertValidContainerName ( $ containerName ) ; $ containers = $ this -> listContainers ( $ containerName , 1 ) ; foreach ( $ containers as $ container ) { if ( $ container -> Name == $ containerName ) { return true ; } } return false ; }
7879	protected function registerLogViewer ( ) { $ this -> app -> singleton ( 'logviewer' , function ( $ app ) { $ factory = $ app [ 'logviewer.factory' ] ; $ filesystem = $ app [ 'logviewer.filesystem' ] ; $ data = $ app [ 'logviewer.data' ] ; return new LogViewer ( $ factory , $ filesystem , $ data ) ; } ) ; $ this -> app -> alias ( 'logviewer' , LogViewer :: class ) ; }
5863	protected function expandConversionMapping ( array $ mapping ) { $ ret = [ ] ; $ matches = [ ] ; foreach ( $ mapping as $ m ) { if ( preg_match ( '/^(.*)\s*=>\s*(.*)/' , $ m , $ matches ) ) { $ ret [ trim ( $ matches [ 1 ] ) ] = trim ( $ matches [ 2 ] ) ; } } return $ ret ; }
5851	protected function addToolbarButtons ( ) { $ buttonBar = $ this -> moduleTemplate -> getDocHeaderComponent ( ) -> getButtonBar ( ) ; $ saveSplitButton = $ buttonBar -> makeSplitButton ( ) ; $ saveButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveDoc' ) ) ) -> setName ( '_savedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveButton , true ) ; $ saveAndCloseButton = $ buttonBar -> makeInputButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.saveCloseDoc' ) ) ) -> setName ( '_saveandclosedok' ) -> setValue ( '1' ) -> setForm ( 'EditDocumentController' ) -> setClasses ( 't3js-editform-submitButton' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-document-save-close' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ saveSplitButton -> addItem ( $ saveAndCloseButton ) ; $ buttonBar -> addButton ( $ saveSplitButton , \ TYPO3 \ CMS \ Backend \ Template \ Components \ ButtonBar :: BUTTON_POSITION_LEFT , 2 ) ; $ closeButton = $ buttonBar -> makeLinkButton ( ) -> setTitle ( htmlspecialchars ( $ this -> languageService -> sL ( 'LLL:EXT:lang/Resources/Private/Language/locallang_core.xlf:rm.closeDoc' ) ) ) -> setHref ( '#' ) -> setClasses ( 't3js-editform-close' ) -> setIcon ( $ this -> moduleTemplate -> getIconFactory ( ) -> getIcon ( 'actions-view-go-back' , \ TYPO3 \ CMS \ Core \ Imaging \ Icon :: SIZE_SMALL ) ) ; $ buttonBar -> addButton ( $ closeButton ) ; }
3398	private function parseStr ( $ string ) { $ params = array ( ) ; $ pairs = explode ( '&' , $ string ) ; foreach ( $ pairs as $ pair ) { if ( ! $ pair ) { continue ; } $ var = explode ( '=' , $ pair , 2 ) ; $ val = ( isset ( $ var [ 1 ] ) ? $ var [ 1 ] : '' ) ; if ( isset ( $ params [ $ var [ 0 ] ] ) ) { if ( is_array ( $ params [ $ var [ 0 ] ] ) ) { $ params [ $ var [ 0 ] ] [ ] = $ val ; } else { $ params [ $ var [ 0 ] ] = array ( $ params [ $ var [ 0 ] ] , $ val ) ; } } else { $ params [ $ var [ 0 ] ] = $ val ; } } return $ params ; }
9116	public function registerView ( $ view , $ order = null , $ applicationName = 'default' ) { if ( ! class_exists ( $ view ) ) { throw new ViewException ( "No such view class {view} found" , array ( 'view' => $ view ) ) ; } $ v = new $ view ( ) ; if ( ! $ v instanceof View ) { throw new ViewException ( "View {view} is not in application scope" , array ( 'view' => $ view ) ) ; } $ viewOrder = $ v -> getOrder ( ) ; if ( null !== $ order ) { $ viewOrder = intval ( $ order ) ; } $ settings = $ v -> getViewSettings ( ) ; $ this -> views [ $ applicationName ] [ $ viewOrder ] [ $ settings -> getViewSimpleName ( ) ] = $ settings ; return $ this ; }
1001	public static function doTypesOverlap ( Schema $ schema , CompositeType $ typeA , CompositeType $ typeB ) { if ( $ typeA === $ typeB ) { return true ; } if ( $ typeA instanceof AbstractType ) { if ( $ typeB instanceof AbstractType ) { foreach ( $ schema -> getPossibleTypes ( $ typeA ) as $ type ) { if ( $ schema -> isPossibleType ( $ typeB , $ type ) ) { return true ; } } return false ; } return $ schema -> isPossibleType ( $ typeA , $ typeB ) ; } if ( $ typeB instanceof AbstractType ) { return $ schema -> isPossibleType ( $ typeB , $ typeA ) ; } return false ; }
3458	public function extend ( $ module ) : void { if ( is_object ( $ module ) || class_exists ( $ module ) ) { $ this -> modules [ ] = $ module ; } else { throw ApplicationException :: forInvalidModule ( $ module ) ; } }
8174	protected function checkLoopUsageCondition ( Twig_TokenStream $ stream , Twig_NodeInterface $ node ) { if ( $ node instanceof Twig_Node_Expression_GetAttr && $ node -> getNode ( 'node' ) instanceof Twig_Node_Expression_Name && 'loop' == $ node -> getNode ( 'node' ) -> getAttribute ( 'name' ) ) { throw new Twig_Error_Syntax ( 'The "loop" variable cannot be used in a looping condition.' , $ node -> getTemplateLine ( ) , $ stream -> getSourceContext ( ) ) ; } foreach ( $ node as $ n ) { if ( ! $ n ) { continue ; } $ this -> checkLoopUsageCondition ( $ stream , $ n ) ; } }
8729	protected function updateFolderName ( HTTPRequest $ request ) { if ( ! $ this -> getCanSelectFolder ( ) ) { return ; } $ folderID = $ request -> requestVar ( "{$this->Name}/folder" ) ; $ path = $ this -> folderPathFromID ( $ folderID ) ; if ( $ path !== false ) { $ this -> setFolderName ( $ path ) ; $ this -> selectField -> setValue ( $ folderID ) ; } }
12881	public function getForeignDataItem ( $ key ) { if ( ! isset ( $ this -> _foreignDataItems [ $ key ] ) ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ key ] ) ; } if ( isset ( $ this -> _foreignDataItems [ $ key ] ) ) { return $ this -> _foreignDataItems [ $ key ] ; } return false ; }
8715	public function getAccessToken ( ) : ApiAccessToken { try { $ accessToken = $ this -> tokenStorage -> getAccessToken ( ) ; } catch ( UnableToAcquireAccessToken $ e ) { $ accessToken = null ; } if ( $ accessToken && $ accessToken -> isExpired ( ) ) { $ this -> tokenStorage -> unsetAccessToken ( ) ; $ accessToken = null ; } return $ accessToken ? : $ this -> refreshToken ( ) ; }
3880	private function getJumpToLabel ( ) { $ tableName = $ this -> metaModel -> getTableName ( ) ; if ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ $ this -> get ( 'id' ) ] [ 'details' ] ; } elseif ( isset ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ) ) { return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ tableName ] [ 'details' ] ; } return $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'details' ] ; }
12307	public function getDatePeriod ( ) { $ intervaloDiario = DateInterval :: createFromDateString ( '1 day' ) ; $ dataFim = clone $ this -> endDate ; $ dataFim -> add ( $ intervaloDiario ) ; return new DatePeriod ( $ this -> startDate , $ intervaloDiario , $ dataFim ) ; }
9663	public static function registerWriter ( $ writerType , $ writerClass ) { if ( ! is_a ( $ writerClass , Writer \ IWriter :: class , true ) ) { throw new Writer \ Exception ( 'Registered writers must implement ' . Writer \ IWriter :: class ) ; } self :: $ writers [ $ writerType ] = $ writerClass ; }
11058	protected function _getDataStore ( ) { return $ this -> dataStore === null ? $ this -> dataStore = $ this -> _createDataStore ( ) : $ this -> dataStore ; }
2715	public function render ( ) { return [ 'id' => $ this -> getId ( ) , 'translate' => 'label comment' , 'showInDefault' => 1 , 'showInWebsite' => 0 , 'showInStore' => 0 , 'sortOrder' => 1 , 'label' => $ this -> label , 'comment' => $ this -> comment , '_elementType' => 'group' , 'path' => self :: BASE_CONFIG_PATH , 'children' => $ this -> children ] ; }
3700	private function handleSorting ( $ information , GroupAndSortingDefinitionInterface $ definition ) { if ( $ information [ 'ismanualsort' ] ) { $ definition -> add ( ) -> setManualSorting ( ) -> setProperty ( 'sorting' ) -> setSortingMode ( GroupAndSortingInformationInterface :: SORT_ASC ) ; return ; } if ( $ information [ 'col_name' ] ) { $ definition -> add ( ) -> setProperty ( $ information [ 'col_name' ] ) -> setSortingMode ( $ information [ 'rendersort' ] ) ; } }
4452	public function stats ( ? int $ date = null ) : array { $ date = $ date ? : time ( ) ; return json_decode ( $ this -> client -> stats ( $ this -> name , $ date ) , true ) ; }
5105	public function limit ( $ from , $ count ) : IWithLimit { return $ this -> setPart ( CmdUpdate :: PART_LIMIT , true , ( $ from ? array ( $ from , $ count ) : $ count ) ) ; }
9328	protected function registerMarkdownPhpEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.php.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownPhpCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.php' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.php.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.php' , 'markdown.php' ) ; }
2690	public function getResizedImageInfo ( ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { return parent :: getResizedImageInfo ( ) ; } if ( $ this -> getBaseFile ( ) !== null ) { return [ 0 => $ this -> getWidth ( ) , 1 => $ this -> getHeight ( ) ] ; } $ asset = $ this -> _assetRepo -> createAsset ( "Magento_Catalog::images/product/placeholder/{$this->getDestinationSubdir()}.jpg" ) ; $ img = $ asset -> getSourceFile ( ) ; $ imageInfo = getimagesize ( $ img ) ; $ this -> setWidth ( $ imageInfo [ 0 ] ) ; $ this -> setHeight ( $ imageInfo [ 1 ] ) ; return $ imageInfo ; }
8037	public static function revert ( $ input , $ inputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { $ number = self :: convertBase ( $ input , $ inputFormat , Code :: FORMAT_NUMBER ) ; if ( is_int ( $ minLength ) ) { $ number -= self :: getMinForlength ( $ inputFormat , $ minLength ) ; } return $ number ; }
6382	public function readQuestions ( $ quizId ) { $ quizSlots = $ this -> readStoreRecords ( 'quiz_slots' , [ 'quizid' => $ quizId ] ) ; $ questions = [ ] ; foreach ( $ quizSlots as $ index => $ quizSlot ) { try { $ question = $ this -> readStoreRecord ( 'question' , [ 'id' => $ quizSlot -> questionid ] ) ; $ question -> answers = $ this -> readStoreRecords ( 'question_answers' , [ 'question' => $ question -> id ] ) ; $ question -> url = $ this -> cfg -> wwwroot . '/mod/question/question.php?id=' . $ question -> id ; if ( $ question -> qtype == 'numerical' ) { $ question -> numerical = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_numerical' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_numerical_options' , [ 'question' => $ question -> id ] ) , 'units' => $ this -> readStoreRecords ( 'question_numerical_units' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'match' ) { $ question -> match = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_match_options' , [ 'questionid' => $ question -> id ] ) , 'subquestions' => $ this -> readStoreRecords ( 'qtype_match_subquestions' , [ 'questionid' => $ question -> id ] ) ] ; } else if ( strpos ( $ question -> qtype , 'calculated' ) === 0 ) { $ question -> calculated = ( object ) [ 'answers' => $ this -> readStoreRecords ( 'question_calculated' , [ 'question' => $ question -> id ] ) , 'options' => $ this -> readStoreRecord ( 'question_calculated_options' , [ 'question' => $ question -> id ] ) ] ; } else if ( $ question -> qtype == 'shortanswer' ) { $ question -> shortanswer = ( object ) [ 'options' => $ this -> readStoreRecord ( 'qtype_shortanswer_options' , [ 'questionid' => $ question -> id ] ) ] ; } $ questions [ $ question -> id ] = $ question ; } catch ( \ Exception $ e ) { } } return $ questions ; }
2663	public function configureBackend ( $ params , $ version , $ old_name ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/backend/' . str_replace ( ' ' , '%20' , $ old_name ) ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT , $ params ) ; return $ result ; }
124	protected function getErrorMessage ( $ retval , $ file ) { switch ( $ retval ) { case ZipArchive :: ER_EXISTS : return sprintf ( "File '%s' already exists." , $ file ) ; case ZipArchive :: ER_INCONS : return sprintf ( "Zip archive '%s' is inconsistent." , $ file ) ; case ZipArchive :: ER_INVAL : return sprintf ( "Invalid argument (%s)" , $ file ) ; case ZipArchive :: ER_MEMORY : return sprintf ( "Malloc failure (%s)" , $ file ) ; case ZipArchive :: ER_NOENT : return sprintf ( "No such zip file: '%s'" , $ file ) ; case ZipArchive :: ER_NOZIP : return sprintf ( "'%s' is not a zip archive." , $ file ) ; case ZipArchive :: ER_OPEN : return sprintf ( "Can't open zip file: %s" , $ file ) ; case ZipArchive :: ER_READ : return sprintf ( "Zip read error (%s)" , $ file ) ; case ZipArchive :: ER_SEEK : return sprintf ( "Zip seek error (%s)" , $ file ) ; default : return sprintf ( "'%s' is not a valid zip archive, got error code: %s" , $ file , $ retval ) ; } }
12174	public function addScalarArgument ( $ name , $ type , $ required = true , $ default = null ) { return $ this -> addArgument ( new ScalarArgument ( $ this -> argumentPosition ++ , $ name , $ type , $ required , $ default ) ) ; }
5394	public function paintError ( $ message ) { parent :: paintError ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'exception>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "exception>\n" ; }
9732	public function writeFont ( ) { $ font_outline = 0 ; $ font_shadow = 0 ; $ icv = $ this -> colorIndex ; if ( $ this -> font -> getSuperscript ( ) ) { $ sss = 1 ; } elseif ( $ this -> font -> getSubscript ( ) ) { $ sss = 2 ; } else { $ sss = 0 ; } $ bFamily = 0 ; $ bCharSet = \ PhpOffice \ PhpSpreadsheet \ Shared \ Font :: getCharsetFromFontName ( $ this -> font -> getName ( ) ) ; $ record = 0x31 ; $ reserved = 0x00 ; $ grbit = 0x00 ; if ( $ this -> font -> getItalic ( ) ) { $ grbit |= 0x02 ; } if ( $ this -> font -> getStrikethrough ( ) ) { $ grbit |= 0x08 ; } if ( $ font_outline ) { $ grbit |= 0x10 ; } if ( $ font_shadow ) { $ grbit |= 0x20 ; } $ data = pack ( 'vvvvvCCCC' , $ this -> font -> getSize ( ) * 20 , $ grbit , $ icv , self :: mapBold ( $ this -> font -> getBold ( ) ) , $ sss , self :: mapUnderline ( $ this -> font -> getUnderline ( ) ) , $ bFamily , $ bCharSet , $ reserved ) ; $ data .= StringHelper :: UTF8toBIFF8UnicodeShort ( $ this -> font -> getName ( ) ) ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
768	protected function regenerateCsrfToken ( ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ request -> enableCsrfCookie || $ this -> enableSession ) { $ request -> getCsrfToken ( true ) ; } }
558	protected function buildBlockCondition ( $ operator , $ condition ) { if ( isset ( $ this -> queryOperatorMap [ $ operator ] ) ) { $ operator = $ this -> queryOperatorMap [ $ operator ] ; } return [ $ operator , $ this -> buildCondition ( $ condition ) , ] ; }
1013	private function readComment ( $ line , $ col , Token $ prev ) { $ start = $ this -> position ; $ value = '' ; $ bytes = 1 ; do { [ $ char , $ code , $ bytes ] = $ this -> moveStringCursor ( 1 , $ bytes ) -> readChar ( ) ; $ value .= $ char ; } while ( $ code && ( $ code > 0x001F || $ code === 0x0009 ) ) ; return new Token ( Token :: COMMENT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
3441	protected function normalizePropertyFormat ( ) { if ( empty ( $ this -> fields [ 'PROPERTIES' ] ) ) { return ; } foreach ( $ this -> fields [ 'PROPERTIES' ] as $ code => $ prop ) { $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE' ] = $ prop [ 'VALUE' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_VALUE' ] = $ prop [ '~VALUE' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ 'DESCRIPTION' ] ; $ this -> fields [ '~PROPERTY_' . $ code . '_DESCRIPTION' ] = $ prop [ '~DESCRIPTION' ] ; $ this -> fields [ 'PROPERTY_' . $ code . '_VALUE_ID' ] = $ prop [ 'PROPERTY_VALUE_ID' ] ; } }
8435	public function delete ( ) : bool { $ status = false ; if ( $ this -> new === false ) { $ deleteQuery = new Delete ( $ this -> getDatabaseName ( ) ) ; $ deleteQuery -> from ( $ this -> getTableName ( ) ) ; $ where = array ( ) ; foreach ( $ this -> getPrimary ( ) as $ primary ) { $ field = $ this -> { 'field' . ucfirst ( $ primary ) } ; $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ primary ) ) ) ; $ where [ $ realName ] = ':primary' . ucfirst ( $ primary ) ; $ deleteQuery -> bind ( 'primary' . ucfirst ( $ primary ) , $ field [ 'value' ] ) ; } $ deleteQuery -> where ( $ where ) ; $ status = $ deleteQuery -> execute ( ) ; } return $ status ; }
10937	protected function getObfuscatedEmail ( CustomerInterface $ user ) { $ email = $ user -> getEmail ( ) ; if ( false !== $ pos = strpos ( $ email , '@' ) ) { $ email = '...' . substr ( $ email , $ pos ) ; } return $ email ; }
4276	public function stream_metadata ( $ path , $ option , $ value ) { self :: restorePrev ( ) ; switch ( $ option ) { case STREAM_META_TOUCH : if ( ! empty ( $ value ) ) { $ success = \ touch ( $ path , $ value [ 0 ] , $ value [ 1 ] ) ; } else { $ success = \ touch ( $ path ) ; } break ; case STREAM_META_OWNER_NAME : case STREAM_META_OWNER : $ success = \ chown ( $ path , $ value ) ; break ; case STREAM_META_GROUP_NAME : case STREAM_META_GROUP : $ success = \ chgrp ( $ path , $ value ) ; break ; case STREAM_META_ACCESS : $ success = \ chmod ( $ path , $ value ) ; break ; default : $ success = false ; } self :: register ( ) ; return $ success ; }
4932	public function renderJSON ( MvcEvent $ event ) { if ( ! $ this -> hasRunned ) { $ valueToPlainStati = array ( 1 => 'error' , 2 => 'error' , 3 => 'error' , 4 => 'error' , 5 => 'success' , 6 => 'info' , 7 => 'info' ) ; $ viewModel = $ event -> getViewModel ( ) ; if ( $ viewModel instanceof JsonModel ) { if ( ! empty ( $ this -> notifications ) ) { $ jsonNotifications = $ viewModel -> getVariable ( 'notifications' , array ( ) ) ; foreach ( $ this -> notifications as $ notification ) { $ status = 'info' ; if ( array_key_exists ( $ notification -> getPriority ( ) , $ valueToPlainStati ) ) { $ status = $ valueToPlainStati [ $ notification -> getPriority ( ) ] ; } $ jsonNotifications [ ] = array ( 'text' => $ notification -> getNotification ( ) , 'status' => $ status ) ; } $ viewModel -> setVariable ( 'notifications' , $ jsonNotifications ) ; } $ this -> hasRunned = true ; } } return ; }
6578	public function parse ( $ url ) { $ parts = $ this -> _parse_url ( $ url ) ; foreach ( array ( 'user' , 'pass' , 'fragment' ) as $ part ) if ( isset ( $ parts [ $ part ] ) ) $ parts [ $ part ] = urldecode ( $ parts [ $ part ] ) ; if ( isset ( $ parts [ 'host' ] ) ) $ parts [ 'host' ] = idn_to_utf8 ( $ parts [ 'host' ] ) ; if ( isset ( $ parts [ 'path' ] ) ) $ parts [ 'path' ] = rawurldecode ( str_ireplace ( '%2F' , '%252F' , $ parts [ 'path' ] ) ) ; return $ this -> setParts ( $ parts ) ; }
12365	public function init ( ) { $ config = new Zend_Config_Ini ( $ this -> config_path == null ? APPLICATION_PATH . DS . "configs" . DS . "secret.ini" : $ config_path , APPLICATION_ENV ) ; $ this -> setConsumer ( new Zend_Oauth_Consumer ( array ( 'callbackUrl' => $ config -> oauth -> callback , 'siteUrl' => $ config -> oauth -> siteurl , 'consumerKey' => $ config -> oauth -> consumerkey , 'consumerSecret' => $ config -> oauth -> consumersecret ) ) ) ; }
11948	public function getSignature ( $ baseString , array $ params ) { unset ( $ params [ 'oauth_signature' ] ) ; if ( $ this -> signature_method === 'HMAC-SHA1' ) { $ result = $ this -> sign_HMAC_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'RSA-SHA1' ) { $ result = $ this -> sign_RSA_SHA1 ( $ baseString ) ; } else if ( $ this -> signature_method == 'PLAINTEXT' ) { $ result = $ this -> sign_PLAINTEXT ( $ baseString ) ; } else { throw new ArtaxServiceException ( 'Unknown signature method: ' . $ this -> signature_method ) ; } return base64_encode ( $ result ) ; }
3238	private function runCalculations ( ) { if ( ! empty ( $ this -> shopCalculations ) ) return $ this -> shopCalculations ; $ cacheKey = $ this -> calculationsCacheKey ; if ( Config :: get ( 'shop.cache_calculations' ) && Cache :: has ( $ cacheKey ) ) { $ this -> shopCalculations = Cache :: get ( $ cacheKey ) ; return $ this -> shopCalculations ; } $ this -> shopCalculations = DB :: table ( $ this -> table ) -> select ( [ DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.quantity) as itemCount' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.price * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalPrice' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.tax * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalTax' ) , DB :: raw ( 'sum(' . Config :: get ( 'shop.item_table' ) . '.shipping * ' . Config :: get ( 'shop.item_table' ) . '.quantity) as totalShipping' ) ] ) -> join ( Config :: get ( 'shop.item_table' ) , Config :: get ( 'shop.item_table' ) . '.' . ( $ this -> table == Config :: get ( 'shop.order_table' ) ? 'order_id' : $ this -> table . '_id' ) , '=' , $ this -> table . '.id' ) -> where ( $ this -> table . '.id' , $ this -> attributes [ 'id' ] ) -> first ( ) ; if ( Config :: get ( 'shop.cache_calculations' ) ) { Cache :: put ( $ cacheKey , $ this -> shopCalculations , Config :: get ( 'shop.cache_calculations_minutes' ) ) ; } return $ this -> shopCalculations ; }
12192	protected function doSave ( $ id , $ data , $ lifeTime = 0 ) { return $ this -> delegate -> doSave ( $ id , $ data , $ lifeTime ) ; }
7732	public function denormalize ( $ data , $ class , $ format = null , array $ context = array ( ) ) { $ value = $ data ; if ( is_array ( $ data ) ) { if ( ! isset ( $ data [ '@value' ] ) || ! isset ( $ data [ '@type' ] ) ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a valid JSON-LD typed value: " . var_export ( $ data , true ) ) ; } if ( self :: XSD_DATETIME_IRI !== $ data [ '@type' ] ) { throw new RuntimeException ( "Cannot denormalize the data as it isn't a XSD dateTime value: " . var_export ( $ data , true ) ) ; } $ value = $ data [ '@value' ] ; } elseif ( ! is_string ( $ data ) ) { throw new RuntimeException ( "Cannot denormalize the data into a DateTime object: " . var_export ( $ data , true ) ) ; } try { $ date = new \ DateTime ( $ value ) ; return $ date ; } catch ( Exception $ e ) { throw new RuntimeException ( "Cannot denormalize the data as the value is invalid: " . var_export ( $ data , true ) , 0 , $ e ) ; } }
11852	protected function setLayout ( string $ layoutName ) : void { if ( is_null ( $ this -> view ) ) { throw new Exception ( "It's unable to set Layout without View." ) ; } $ this -> layout = ViewFactory :: createLayout ( $ layoutName , $ this -> view ) ; }
4825	public function replaceValue ( $ fieldName , $ oldvalue , $ newvalue ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ oldvalue == $ result ) { $ this -> row [ $ fieldName ] = $ newvalue ; $ this -> informChanges ( ) ; } } else { for ( $ i = count ( $ result ) - 1 ; $ i >= 0 ; $ i -- ) { if ( $ result [ $ i ] == $ oldvalue ) { $ this -> row [ $ fieldName ] [ $ i ] = $ newvalue ; $ this -> informChanges ( ) ; } } } }
6011	public function setReplies ( array $ replies ) { $ this -> replies = [ ] ; foreach ( $ replies as $ item ) { $ this -> addCommentResponse ( $ item ) ; } return $ this ; }
6968	protected function calculateGoodLine ( Model \ DocumentLineInterface $ line ) : ? Amount { if ( $ line -> getType ( ) !== Model \ DocumentLineTypes :: TYPE_GOOD ) { throw new LogicException ( sprintf ( "Expected document line with type '%s'." , Model \ DocumentLineTypes :: TYPE_GOOD ) ) ; } if ( null === $ item = $ line -> getSaleItem ( ) ) { throw new LogicException ( "Document can't be recalculated." ) ; } $ result = $ this -> calculator -> calculateSaleItem ( $ item , $ line -> getQuantity ( ) ) ; $ this -> syncLineWithResult ( $ line , $ result ) ; if ( $ item -> isPrivate ( ) ) { return null ; } return $ result ; }
8053	public function deleteCalendarEvent ( $ id ) { $ cache = $ this -> cache ; $ this -> calendarEvent -> destroy ( $ id ) ; $ allEvents = $ this -> getAllEvents ( ) ; unset ( $ allEvents [ $ id ] ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
10476	public function push ( string $ event , $ event_args = null ) : EventChannelInterface { try { $ this -> channel -> push ( $ event , $ event_args ) ; } catch ( EventSourceIsNotPushableException $ e ) { throw new EventStreamException ( 'Event is not pushable.' ) ; } return $ this ; }
8580	public function setPromotionAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PromotionAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
704	public function setDefaultRoles ( $ roles ) { if ( is_array ( $ roles ) ) { $ this -> defaultRoles = $ roles ; } elseif ( $ roles instanceof \ Closure ) { $ roles = call_user_func ( $ roles ) ; if ( ! is_array ( $ roles ) ) { throw new InvalidValueException ( 'Default roles closure must return an array' ) ; } $ this -> defaultRoles = $ roles ; } else { throw new InvalidArgumentException ( 'Default roles must be either an array or a callable' ) ; } }
6875	public static function query ( $ queryString , array $ queryParams = [ ] , $ dbName = "master" , $ fetchResults = true ) { $ query = static :: instance ( $ dbName ) -> prepare ( $ queryString ) ; foreach ( $ queryParams as $ column => $ val ) $ query -> bindValue ( is_int ( $ column ) ? $ column + 1 : ":" . $ column , $ val ) ; if ( $ query -> execute ( ) ) return $ fetchResults ? $ query -> fetchAll ( PDO :: FETCH_ASSOC ) : $ query -> rowCount ( ) ; return false ; }
207	public static function confirm ( $ message , $ default = false ) { while ( true ) { static :: stdout ( $ message . ' (yes|no) [' . ( $ default ? 'yes' : 'no' ) . ']:' ) ; $ input = trim ( static :: stdin ( ) ) ; if ( empty ( $ input ) ) { return $ default ; } if ( ! strcasecmp ( $ input , 'y' ) || ! strcasecmp ( $ input , 'yes' ) ) { return true ; } if ( ! strcasecmp ( $ input , 'n' ) || ! strcasecmp ( $ input , 'no' ) ) { return false ; } } }
270	public function getEnabled ( ) { if ( is_callable ( $ this -> _enabled ) ) { return call_user_func ( $ this -> _enabled , $ this ) ; } return $ this -> _enabled ; }
8071	public function retrieveByCredentials ( array $ credentials ) { $ username = $ credentials [ 'username' ] ; $ result = $ this -> ldap -> find ( $ username ) ; if ( ! is_null ( $ result ) ) { $ user = new $ this -> model ; $ user -> build ( $ result ) ; return $ user ; } return null ; }
7201	public function getUnit ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> unit ) : $ this -> unit ; }
10659	protected function normalizeHeaderName ( $ keyName ) { if ( ! is_string ( $ keyName ) ) { return null ; } return ucwords ( trim ( strtolower ( $ keyName ) ) , '-' ) ? : null ; }
4871	public function setEventPrototype ( EventInterface $ prototype ) { if ( ! $ prototype instanceof DependencyResultEvent ) { throw new \ InvalidArgumentException ( 'This event manager only accepts events of the type ' . DependencyResultEvent :: class ) ; } parent :: setEventPrototype ( $ prototype ) ; }
11462	public static function notice ( $ message ) { $ message = preg_replace ( '/\s+/' , ' ' , $ message ) ; static :: writeLogLine ( 'Notices.log' , $ message ) ; trigger_error ( $ message , E_USER_NOTICE ) ; }
9520	public function getAliasUsage ( $ withEncapsulation = true ) { $ aliases = '' ; foreach ( $ this -> aliases as $ prefix => $ alias ) { if ( $ withEncapsulation ) { $ aliases = ( $ aliases == '' ) ? ' (' : $ aliases ; $ aliases .= ' ' . $ prefix . $ alias ; } else { $ aliases = ( $ aliases == '' ) ? $ prefix . $ alias : $ aliases . ', ' . $ prefix . $ alias ; } } if ( $ withEncapsulation ) { $ aliases .= ( $ aliases == '' ) ? '' : ' )' ; } return $ aliases ; }
10278	public function write ( Spreadsheet $ spreadsheet = null ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-styles' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:style' , 'urn:oasis:names:tc:opendocument:xmlns:style:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:text' , 'urn:oasis:names:tc:opendocument:xmlns:text:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:table' , 'urn:oasis:names:tc:opendocument:xmlns:table:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:draw' , 'urn:oasis:names:tc:opendocument:xmlns:drawing:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:fo' , 'urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:number' , 'urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:presentation' , 'urn:oasis:names:tc:opendocument:xmlns:presentation:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:svg' , 'urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:chart' , 'urn:oasis:names:tc:opendocument:xmlns:chart:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:dr3d' , 'urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:math' , 'http://www.w3.org/1998/Math/MathML' ) ; $ objWriter -> writeAttribute ( 'xmlns:form' , 'urn:oasis:names:tc:opendocument:xmlns:form:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:script' , 'urn:oasis:names:tc:opendocument:xmlns:script:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooow' , 'http://openoffice.org/2004/writer' ) ; $ objWriter -> writeAttribute ( 'xmlns:oooc' , 'http://openoffice.org/2004/calc' ) ; $ objWriter -> writeAttribute ( 'xmlns:dom' , 'http://www.w3.org/2001/xml-events' ) ; $ objWriter -> writeAttribute ( 'xmlns:rpt' , 'http://openoffice.org/2005/report' ) ; $ objWriter -> writeAttribute ( 'xmlns:of' , 'urn:oasis:names:tc:opendocument:xmlns:of:1.2' ) ; $ objWriter -> writeAttribute ( 'xmlns:xhtml' , 'http://www.w3.org/1999/xhtml' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'xmlns:tableooo' , 'http://openoffice.org/2009/table' ) ; $ objWriter -> writeAttribute ( 'xmlns:css3t' , 'http://www.w3.org/TR/css3-text/' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> writeElement ( 'office:font-face-decls' ) ; $ objWriter -> writeElement ( 'office:styles' ) ; $ objWriter -> writeElement ( 'office:automatic-styles' ) ; $ objWriter -> writeElement ( 'office:master-styles' ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
2969	protected function getTableGateway ( $ tableName ) { if ( ! array_key_exists ( $ tableName , $ this -> tableGateways ) ) { $ acl = TableSchema :: getAclInstance ( ) ; $ this -> tableGateways [ $ tableName ] = new RelationalTableGateway ( $ tableName , $ this -> connection , $ acl ) ; } return $ this -> tableGateways [ $ tableName ] ; }
1228	public function parse ( $ expression ) { $ this -> expression = $ expression ; $ this -> tokens = $ this -> lexer -> tokenize ( $ expression ) ; $ this -> tpos = - 1 ; $ this -> next ( ) ; $ result = $ this -> expr ( ) ; if ( $ this -> token [ 'type' ] === T :: T_EOF ) { return $ result ; } throw $ this -> syntax ( 'Did not reach the end of the token stream' ) ; }
5246	public function get ( string $ path ) : string { if ( ! $ this -> isFile ( $ path ) ) { throw new RuntimeException ( 'File does not exist at path ' . $ path ) ; } return file_get_contents ( $ path ) ; }
10021	public function addCellStyleXf ( Style $ pStyle ) { $ this -> cellStyleXfCollection [ ] = $ pStyle ; $ pStyle -> setIndex ( count ( $ this -> cellStyleXfCollection ) - 1 ) ; }
4568	public function getParent ( $ permission ) { $ permission = $ this -> cast ( $ permission ) ; foreach ( $ this -> toArray ( ) as $ element ) { if ( Permission :: ENTITY === $ element -> getType ( ) && 0 === strpos ( $ permission -> getValue ( ) , $ element -> getValue ( ) ) ) { return $ element ; } } }
9086	public function getName ( ) { if ( 0 === count ( $ this -> queue ) ) { return false ; } foreach ( $ this -> queue as $ detector ) { $ name = $ detector -> getName ( ) ; if ( empty ( $ name ) && $ name !== '0' ) { continue ; } $ this -> lastStrategyFound = $ detector ; return $ name ; } return false ; }
5253	public static function findOrFail ( $ id , array $ columns = [ '*' ] , $ parent = null ) { $ model = static :: find ( $ id , $ columns , [ 'parent' => $ parent ] ) ; if ( is_null ( $ model ) ) { throw new ModelNotFoundException ( get_called_class ( ) , $ id ) ; } return $ model ; }
1585	public function withLinks ( $ links ) : self { $ copy = clone $ this ; $ copy -> links = collect ( $ links ) -> all ( ) ; return $ copy ; }
8646	private function getDefaultCurlOptions ( ) { return array ( CURLOPT_POST => true , CURLOPT_USERAGENT => $ this -> config [ 'UserAgent' ] , CURLOPT_VERBOSE => false , CURLOPT_HEADERFUNCTION => array ( $ this , 'headerCallback' ) , CURLOPT_RETURNTRANSFER => true , CURLOPT_SSL_VERIFYPEER => true , CURLOPT_SSL_VERIFYHOST => 2 ) ; }
855	public function insertAt ( $ index , $ items ) { $ items = \ is_array ( $ items ) || $ items instanceof self ? $ items : [ $ items ] ; $ itemsCnt = \ count ( $ items ) ; if ( 0 === $ itemsCnt ) { return ; } $ oldSize = \ count ( $ this ) ; $ this -> changed = true ; $ this -> blockEndCache = [ ] ; $ this -> setSize ( $ oldSize + $ itemsCnt ) ; for ( $ i = $ oldSize + $ itemsCnt - 1 ; $ i >= $ index ; -- $ i ) { $ oldItem = parent :: offsetExists ( $ i - $ itemsCnt ) ? parent :: offsetGet ( $ i - $ itemsCnt ) : new Token ( '' ) ; parent :: offsetSet ( $ i , $ oldItem ) ; } for ( $ i = 0 ; $ i < $ itemsCnt ; ++ $ i ) { if ( '' === $ items [ $ i ] -> getContent ( ) ) { throw new \ InvalidArgumentException ( 'Must not add empty token to collection.' ) ; } $ this -> registerFoundToken ( $ items [ $ i ] ) ; parent :: offsetSet ( $ i + $ index , $ items [ $ i ] ) ; } }
2911	public function xml2array ( $ xml , array & $ arr , $ parentKey = '' ) { if ( ! $ xml ) { return ; } if ( count ( $ xml -> children ( ) ) == 0 ) { $ arr [ $ parentKey ] = ( string ) $ xml ; } else { foreach ( $ xml -> children ( ) as $ key => $ item ) { $ key = $ parentKey ? $ parentKey . DS . $ key : $ key ; $ this -> xml2array ( $ item , $ arr , $ key ) ; } } return $ arr ; }
7483	public function startsWith ( $ string ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; return $ string === $ this -> substring ( 0 , ( mb_strlen ( $ string , $ this -> encoding ) - 1 ) ) -> __toString ( ) ; }
7241	private function getDefaultClasses ( ) { return [ 'address' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAddress :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAddress :: class , ] , 'attachment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAttachment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAttachment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAttachment :: class , ] , 'notification' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartNotification :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderNotification :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteNotification :: class , ] , 'item' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartItem :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderItem :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteItem :: class , ] , 'adjustment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartAdjustment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderAdjustment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuoteAdjustment :: class , ] , 'item_adjustment' => [ Cart \ Model \ CartItemInterface :: class => Cart \ Entity \ CartItemAdjustment :: class , Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemAdjustment :: class , Quote \ Model \ QuoteItemInterface :: class => Quote \ Entity \ QuoteItemAdjustment :: class , ] , 'item_stock_assignment' => [ Order \ Model \ OrderItemInterface :: class => Order \ Entity \ OrderItemStockAssignment :: class , ] , 'payment' => [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ CartPayment :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderPayment :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ QuotePayment :: class , ] , 'shipment' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderShipment :: class , ] , 'shipment_item' => [ Order \ Model \ OrderShipmentInterface :: class => Order \ Entity \ OrderShipmentItem :: class , ] , 'invoice' => [ Order \ Model \ OrderInterface :: class => Order \ Entity \ OrderInvoice :: class , ] , 'invoice_line' => [ Order \ Model \ OrderInvoiceInterface :: class => Order \ Entity \ OrderInvoiceLine :: class , ] , ] ; }
4869	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ helper = new DateFormat ( ) ; $ helper -> setLocale ( Locale :: DEFAULT_LOCALE ) ; return $ helper ; }
1227	private function parseJson ( array $ token ) { $ value = json_decode ( $ token [ 'value' ] , true ) ; if ( $ error = json_last_error ( ) ) { $ value = json_decode ( '"' . $ token [ 'value' ] . '"' , true ) ; if ( $ error = json_last_error ( ) ) { $ token [ 'type' ] = self :: T_UNKNOWN ; return $ token ; } } $ token [ 'value' ] = $ value ; return $ token ; }
6440	public function transform ( $ target = null , $ controller = null , $ action = null , array $ params = [ ] , array $ trailing = [ ] , array $ config = [ ] ) { if ( ! empty ( $ trailing ) ) { $ params [ 'trailing' ] = join ( '_' , $ trailing ) ; } $ params = $ this -> sanitize ( $ params ) ; $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_PATH ; if ( isset ( $ config [ 'absoluteUri' ] ) ) { $ refType = \ Symfony \ Component \ Routing \ Generator \ UrlGeneratorInterface :: ABSOLUTE_URL ; } return $ this -> router -> generate ( $ target , $ params + $ this -> fixed , $ refType ) ; }
11931	protected function generateField ( $ fieldType , $ fieldId , array $ labels ) { $ field = new FieldType ( ) ; $ field -> setType ( $ fieldType ) ; $ field -> setFieldId ( $ fieldId ) ; $ field -> setDefaultValue ( null ) ; $ field -> setSearchable ( true ) ; $ field -> setLabels ( $ labels ) ; return $ field ; }
4165	private function mergeScope ( array $ scope ) { if ( empty ( $ scope ) ) return $ this -> _scope ; $ scope = array_merge ( $ scope , $ this -> _defaulScope ) ; $ scope = array_unique ( $ scope ) ; $ intersectingScope = array_intersect ( $ scope , $ this -> _availableScope ) ; if ( count ( $ intersectingScope ) !== count ( $ scope ) ) { throw new InvalidParameterException ( 'Error: mergeScope() - Invalid permission scope parameter used.' ) ; } return $ intersectingScope ; }
7735	private function documentRouteAndOperations ( $ metadata , Reflector $ element ) { if ( ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Id' ) ) ) || ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Route' ) ) ) ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Operations' ) ; if ( null !== $ annotation ) { $ operations = array_unique ( $ annotation -> operations ) ; $ operationsMetadata = array_map ( array ( $ this , 'getRouteMetadata' ) , $ operations ) ; $ metadata -> setOperations ( $ operationsMetadata ) ; } if ( null !== ( $ route = $ metadata -> getRoute ( ) ) ) { $ metadata -> addOperation ( $ this -> getRouteMetadata ( $ route -> getName ( ) ) ) ; } elseif ( null !== $ annotation ) { $ metadata -> setRoute ( $ this -> getRouteMetadata ( reset ( $ annotation -> operations ) ) ) ; } if ( ( $ metadata instanceof PropertyDefinition ) && ( count ( $ operations = $ metadata -> getOperations ( ) ) > 0 ) ) { foreach ( $ operations as $ operation ) { if ( ( 'GET' === $ operation -> getMethod ( ) ) && ( null !== $ operation -> getReturns ( ) ) ) { $ metadata -> setType ( $ operation -> getReturns ( ) ) ; return ; } } $ metadata -> setType ( 'ML\HydraBundle\Entity\Resource' ) ; } }
6633	public function requestProfile ( AccessTokenInterface $ access_token ) { $ request = [ 'url' => $ this -> settings [ 'api_url' ] . $ this -> settings [ 'profile_uri' ] , 'params' => [ 'access_token' => $ access_token -> token ( ) ] , ] ; return $ this -> parseProfileResponse ( $ this -> http -> get ( $ request ) , $ access_token ) ; }
1321	private function request ( $ url , $ method , $ authorization , array $ postfields , $ json = false ) { $ options = $ this -> curlOptions ( ) ; $ options [ CURLOPT_URL ] = $ url ; $ options [ CURLOPT_HTTPHEADER ] = [ 'Accept: application/json' , $ authorization , 'Expect:' ] ; switch ( $ method ) { case 'GET' : break ; case 'POST' : $ options [ CURLOPT_POST ] = true ; if ( $ json ) { $ options [ CURLOPT_HTTPHEADER ] [ ] = 'Content-type: application/json' ; $ options [ CURLOPT_POSTFIELDS ] = json_encode ( $ postfields ) ; } else { $ options [ CURLOPT_POSTFIELDS ] = Util :: buildHttpQuery ( $ postfields ) ; } break ; case 'DELETE' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'DELETE' ; break ; case 'PUT' : $ options [ CURLOPT_CUSTOMREQUEST ] = 'PUT' ; break ; } if ( in_array ( $ method , [ 'GET' , 'PUT' , 'DELETE' ] ) && ! empty ( $ postfields ) ) { $ options [ CURLOPT_URL ] .= '?' . Util :: buildHttpQuery ( $ postfields ) ; } $ curlHandle = curl_init ( ) ; curl_setopt_array ( $ curlHandle , $ options ) ; $ response = curl_exec ( $ curlHandle ) ; if ( curl_errno ( $ curlHandle ) > 0 ) { throw new TwitterOAuthException ( curl_error ( $ curlHandle ) , curl_errno ( $ curlHandle ) ) ; } $ this -> response -> setHttpCode ( curl_getinfo ( $ curlHandle , CURLINFO_HTTP_CODE ) ) ; $ parts = explode ( "\r\n\r\n" , $ response ) ; $ responseBody = array_pop ( $ parts ) ; $ responseHeader = array_pop ( $ parts ) ; $ this -> response -> setHeaders ( $ this -> parseHeaders ( $ responseHeader ) ) ; curl_close ( $ curlHandle ) ; return $ responseBody ; }
5699	public function findActionByName ( $ action ) { $ actions = $ this -> owner -> getBetterButtonsActions ( ) ; $ formAction = false ; foreach ( $ actions as $ f ) { if ( $ formAction ) { break ; } if ( $ f instanceof CompositeField ) { $ formAction = $ f -> fieldByName ( $ action ) ; } elseif ( $ f -> getName ( ) === $ action ) { $ formAction = $ f ; } } if ( ! $ formAction ) { $ utils = $ this -> owner -> getBetterButtonsUtils ( ) ; $ formAction = $ utils -> fieldByName ( $ action ) ; } return $ formAction ; }
10309	function getOpensCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ formatFilter = null , $ socialNetworkFilter = null , $ deviceTypeFilter = null , $ excludeAnonymousOpens = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousOpens ) ) $ params [ 'exclude_anonymous_opens' ] = ( $ excludeAnonymousOpens == true ) ? "true" : "false" ; if ( isset ( $ formatFilter ) ) $ params [ 'format' ] = $ formatFilter ; $ params = $ this -> appendArrayFields ( $ params , "social_network" , $ socialNetworkFilter ) ; $ params = $ this -> appendArrayFields ( $ params , "device_type" , $ deviceTypeFilter ) ; return $ this -> get ( 'reports/opens/count' , $ params ) ; }
9952	public function setBreak ( $ pCoordinate , $ pBreak ) { $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( $ pCoordinate != '' ) { if ( $ pBreak == self :: BREAK_NONE ) { if ( isset ( $ this -> breaks [ $ pCoordinate ] ) ) { unset ( $ this -> breaks [ $ pCoordinate ] ) ; } } else { $ this -> breaks [ $ pCoordinate ] = $ pBreak ; } } else { throw new Exception ( 'No cell coordinate specified.' ) ; } return $ this ; }
2943	public function hasRoleWithPermission ( $ permission ) { return $ this -> roles -> contains ( function ( $ role ) use ( $ permission ) { return $ role -> getPermissions -> contains ( 'permission_slug' , $ permission ) ; } ) ; }
1948	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> replaceInsertTags ( $ objPage -> url , false ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
897	private function fixTokensCompare ( Tokens $ tokens , $ startLeft , $ endLeft , $ compareOperatorIndex , $ startRight , $ endRight ) { $ type = $ tokens [ $ compareOperatorIndex ] -> getId ( ) ; $ content = $ tokens [ $ compareOperatorIndex ] -> getContent ( ) ; if ( \ array_key_exists ( $ type , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ type ] ; } elseif ( \ array_key_exists ( $ content , $ this -> candidatesMap ) ) { $ tokens [ $ compareOperatorIndex ] = clone $ this -> candidatesMap [ $ content ] ; } $ right = $ this -> fixTokensComparePart ( $ tokens , $ startRight , $ endRight ) ; $ left = $ this -> fixTokensComparePart ( $ tokens , $ startLeft , $ endLeft ) ; for ( $ i = $ startRight ; $ i <= $ endRight ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } for ( $ i = $ startLeft ; $ i <= $ endLeft ; ++ $ i ) { $ tokens -> clearAt ( $ i ) ; } $ tokens -> insertAt ( $ startRight , $ left ) ; $ tokens -> insertAt ( $ startLeft , $ right ) ; return $ startLeft ; }
11203	public function max ( $ key = false ) { $ collection = $ this -> getIterator ( ) ; $ max = 0 ; $ valueToReturn = 0 ; foreach ( $ collection as $ result ) { if ( $ key && isset ( $ result -> $ key ) ) { if ( $ result -> $ key > $ max ) { $ max = $ result -> $ key ; $ valueToReturn = $ result ; } } else if ( $ key && isset ( $ result [ $ key ] ) ) { if ( $ result [ $ key ] > $ max ) { $ max = $ result [ $ key ] ; $ valueToReturn = $ result ; } } else { if ( $ result > $ max ) { $ max = $ result ; $ valueToReturn = $ result ; } } } return $ valueToReturn ; }
5441	public function parse ( $ raw ) { if ( ! isset ( $ this -> parser ) ) { return false ; } $ length = strlen ( $ raw ) ; while ( is_array ( $ parsed = $ this -> reduce ( $ raw ) ) ) { list ( $ raw , $ unmatched , $ matched , $ mode ) = $ parsed ; if ( ! $ this -> dispatchTokens ( $ unmatched , $ matched , $ mode ) ) { return false ; } if ( $ raw === '' ) { return true ; } if ( strlen ( $ raw ) == $ length ) { return false ; } $ length = strlen ( $ raw ) ; } if ( ! $ parsed ) { return false ; } return $ this -> invokeParser ( $ raw , LEXER_UNMATCHED ) ; }
6795	protected function convertValueIds ( $ valueResult , & $ counter = null ) { $ result = [ ] ; $ aliases = [ ] ; $ idColumn = $ this -> getIdColumn ( ) ; $ aliasColumn = $ this -> getAliasColumn ( ) ; while ( $ row = $ valueResult -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ valueId = $ row -> $ idColumn ; $ aliases [ $ valueId ] = $ row -> $ aliasColumn ; $ result [ ] = $ valueId ; } if ( ( $ counter !== null ) && ! empty ( $ result ) ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'value_id' , 'COUNT(value_id) as mm_count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'value_id IN (:values)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'values' , $ result , Connection :: PARAM_STR_ARRAY ) -> execute ( ) -> fetch ( \ PDO :: FETCH_OBJ ) ; $ amount = $ statement -> mm_count ; $ valueId = $ statement -> value_id ; $ alias = $ aliases [ $ valueId ] ; $ counter [ $ valueId ] = $ amount ; $ counter [ $ alias ] = $ amount ; } return $ result ; }
8905	function dropdown ( ) { $ args = func_get_args ( ) ; if ( count ( $ args ) == 2 ) { list ( $ key , $ value ) = $ args ; } else { $ key = $ this -> primary_key ; $ value = $ args [ 0 ] ; } $ this -> trigger ( 'before_dropdown' , array ( $ key , $ value ) ) ; $ this -> apply_soft_delete_filter ( ) ; $ result = $ this -> _database -> select ( array ( $ key , $ value ) ) -> get ( $ this -> _table ) -> result ( ) ; $ options = array ( ) ; foreach ( $ result as $ row ) { $ options [ $ row -> { $ key } ] = $ row -> { $ value } ; } $ options = $ this -> trigger ( 'after_dropdown' , $ options ) ; return $ options ; }
10738	public function search ( $ query ) { $ results = new ResultCollection ( ) ; foreach ( $ this -> engines as $ eachEngine ) { if ( ! $ eachEngine -> supports ( $ query ) ) { continue ; } if ( $ more = $ eachEngine -> search ( $ query ) ) { if ( ! is_array ( $ more ) and ! $ more instanceof \ Traversable ) { throw new DomainException ( 'The returned result set is not traversable.' ) ; } foreach ( $ more as $ eachResult ) { $ results -> add ( $ eachResult ) ; } } } return $ results ; }
9255	public function getRootDir ( ) { if ( ! $ this -> rootDir ) { $ refl = new \ ReflectionObject ( $ this ) ; $ filename = $ refl -> getFileName ( ) ; if ( false !== ( $ pos = strrpos ( $ filename , '/vendor/' ) ) ) { $ filename = substr ( $ filename , 0 , $ pos ) ; } else { $ filename = dirname ( $ filename ) . '/..' ; } $ this -> rootDir = str_replace ( '\\' , '/' , $ filename ) ; } return $ this -> rootDir ; }
5917	public function updateSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/accounts/settings/' . $ key . '' , $ parameters ) ; return $ result ; }
239	private function loadTableMetadataFromCache ( $ cache , $ name ) { if ( $ cache === null ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } $ metadata = $ cache -> get ( $ this -> getCacheKey ( $ name ) ) ; if ( ! is_array ( $ metadata ) || ! isset ( $ metadata [ 'cacheVersion' ] ) || $ metadata [ 'cacheVersion' ] !== static :: SCHEMA_CACHE_VERSION ) { $ this -> _tableMetadata [ $ name ] = [ ] ; return ; } unset ( $ metadata [ 'cacheVersion' ] ) ; $ this -> _tableMetadata [ $ name ] = $ metadata ; }
5500	protected function replaceWildcards ( $ args ) { if ( $ args === false ) { return false ; } for ( $ i = 0 ; $ i < count ( $ args ) ; $ i ++ ) { if ( $ args [ $ i ] === $ this -> wildcard ) { $ args [ $ i ] = new AnythingExpectation ( ) ; } } return $ args ; }
2136	protected static function loadParameters ( ) { $ container = System :: getContainer ( ) ; if ( $ container === null ) { return ; } if ( $ container -> hasParameter ( 'contao.localconfig' ) && \ is_array ( $ params = $ container -> getParameter ( 'contao.localconfig' ) ) ) { foreach ( $ params as $ key => $ value ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ key ] = $ value ; } } $ arrMap = array ( 'dbHost' => 'database_host' , 'dbPort' => 'database_port' , 'dbUser' => 'database_user' , 'dbPass' => 'database_password' , 'dbDatabase' => 'database_name' , 'smtpHost' => 'mailer_host' , 'smtpUser' => 'mailer_user' , 'smtpPass' => 'mailer_password' , 'smtpPort' => 'mailer_port' , 'smtpEnc' => 'mailer_encryption' , 'addLanguageToUrl' => 'contao.prepend_locale' , 'encryptionKey' => 'contao.encryption_key' , 'urlSuffix' => 'contao.url_suffix' , 'uploadPath' => 'contao.upload_path' , 'debugMode' => 'kernel.debug' , ) ; foreach ( $ arrMap as $ strKey => $ strParam ) { if ( $ container -> hasParameter ( $ strParam ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ $ strKey ] = $ container -> getParameter ( $ strParam ) ; } } if ( $ container -> hasParameter ( 'contao.image.valid_extensions' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'validImageTypes' ] = implode ( ',' , $ container -> getParameter ( 'contao.image.valid_extensions' ) ) ; } if ( $ container -> hasParameter ( 'contao.image.imagine_options' ) ) { $ GLOBALS [ 'TL_CONFIG' ] [ 'jpgQuality' ] = $ container -> getParameter ( 'contao.image.imagine_options' ) [ 'jpeg_quality' ] ; } }
6447	public function getUserProfile ( ) { $ linkedin = $ this -> getClient ( ) ; $ response = $ linkedin -> get ( '/people/~:(id,first-name,last-name,picture-url,public-profile-url,email-address)' ) ; if ( isset ( $ response [ 'emailAddress' ] ) ) { return array ( 'userid' => $ response [ 'id' ] , 'name' => $ response [ 'firstName' ] . ' ' . $ response [ 'lastName' ] , 'email' => $ response [ 'emailAddress' ] , 'imageurl' => $ response [ 'pictureUrl' ] ) ; } }
9561	protected function makeResponse ( $ response , Exception $ exception ) { if ( ! $ response instanceof Response ) { $ response = new Response ( $ response ) ; } if ( ! $ response -> isClientError ( ) && ! $ response -> isServerError ( ) && ! $ response -> isRedirect ( ) ) { if ( $ exception instanceof HttpExceptionInterface ) { $ response -> setStatusCode ( $ exception -> getStatusCode ( ) ) ; $ response -> headers -> add ( $ exception -> getHeaders ( ) ) ; } else { $ response -> setStatusCode ( 500 ) ; } } return $ response ; }
2638	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ aclId = $ this -> getRequest ( ) -> getParam ( 'acl_id' ) ; $ aclItems = $ this -> api -> aclItemsList ( $ aclId ) ; if ( is_array ( $ aclItems ) && empty ( $ aclItems ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'aclItems' => [ ] ] ) ; } if ( ! $ aclItems ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to fetch acl items.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'aclItems' => $ aclItems ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
7491	public function setLength ( $ newLength , $ padding = ' ' ) { $ newLength = ( int ) $ newLength ; $ currentLength = $ this -> length ( ) ; if ( $ newLength != $ currentLength ) { while ( $ newLength > $ this -> length ( ) ) { $ this -> string .= $ padding ; } if ( $ newLength < $ this -> length ( ) ) { $ this -> string = mb_substr ( $ this -> string , 0 , $ newLength , $ this -> encoding ) ; } } return $ this ; }
9457	public function addCountableAttribute ( $ attribute ) { if ( empty ( $ attribute ) ) { return false ; } if ( in_array ( $ attribute , $ this -> getCountableAttributes ( ) , true ) ) { return false ; } $ this -> addToArrayValue ( 'countableAttributes' , $ attribute ) ; return $ this ; }
720	public function binary ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_BINARY , $ length ) ; }
8939	public function closeChangeset ( $ id ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id . '/close' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ header [ 'format' ] = 'text/xml' ; $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ header ) ; }
10849	protected function fillDocument ( Document $ document , object $ object ) : bool { if ( $ object instanceof SearchableEntity ) { return $ object -> indexEntity ( $ document ) ; } $ mapping = $ this -> getMapping ( \ get_class ( $ object ) ) ; $ accessor = PropertyAccess :: createPropertyAccessor ( ) ; foreach ( $ mapping as $ fieldName => $ propertyPath ) { $ document -> addField ( $ fieldName , $ accessor -> getValue ( $ object , $ propertyPath ) ) ; } return true ; }
6448	public function getBestLanguageMatch ( array $ supportedLanguages , array $ languageHeaders ) : ? string { usort ( $ languageHeaders , [ $ this , 'compareAcceptLanguageHeaders' ] ) ; $ rankedLanguageHeaders = array_filter ( $ languageHeaders , [ $ this , 'filterZeroScores' ] ) ; $ rankedLanguageHeaderValues = $ this -> getLanguageValuesFromHeaders ( $ rankedLanguageHeaders ) ; foreach ( $ rankedLanguageHeaderValues as $ language ) { $ languageParts = explode ( '-' , $ language ) ; do { foreach ( $ supportedLanguages as $ supportedLanguage ) { if ( $ language === '*' || implode ( '-' , $ languageParts ) === $ supportedLanguage ) { return $ supportedLanguage ; } } array_pop ( $ languageParts ) ; } while ( count ( $ languageParts ) > 0 ) ; } return null ; }
3964	private function getJsonFile ( $ filename ) { if ( ! is_readable ( $ filename ) ) { return [ ] ; } $ contents = json_decode ( file_get_contents ( $ filename ) , true ) ; return $ contents ? : [ ] ; }
10191	public function validate ( ) { foreach ( func_get_args ( ) as $ key ) { $ value = $ this -> parameters -> get ( $ key ) ; if ( ! isset ( $ value ) ) { throw new InvalidRequestException ( "The $key parameter is required" ) ; } } }
12664	public function requirePackage ( string $ package_class ) : ApplicationInterface { if ( ! in_array ( PackageInterface :: class , class_implements ( $ package_class ) ) ) { throw new PackageRequireException ( 'Specified package does not implements PackageInterface: ' . $ package_class , $ package_class ) ; } $ module_list = call_user_func ( [ $ package_class , 'getModuleList' ] ) ; if ( ! is_array ( $ module_list ) ) { throw new PackageRequireException ( 'Failed to call getModuleList: ' . $ package_class , $ package_class ) ; } $ this -> required_modules = array_merge ( $ this -> required_modules , $ module_list ) ; return $ this ; }
6189	public function renderJSONP ( $ data ) { $ callback = null ; if ( isset ( $ _GET [ 'callback' ] ) ) { $ callback = $ _GET [ 'callback' ] ; } exit ( Response :: Create ( $ callback . '(' . json_encode ( $ data ) . ')' ) -> headers ( [ 'Content-Type' => 'application/jsonp' ] ) -> display ( ) ) ; }
11820	public function cell_default ( $ item , $ column ) { $ ret = $ this -> val ( $ item , $ column ) ; return is_null ( $ ret ) ? '' : $ ret ; }
10692	protected function getDialectStatement ( $ method , $ setTable = true ) { $ dialect = $ this -> getDialect ( ) ; if ( ! method_exists ( $ dialect , $ method ) ) { throw new BadMethodCallException ( Message :: get ( Message :: BUILDER_UNKNOWN_METHOD , $ method ) , Message :: BUILDER_UNKNOWN_METHOD ) ; } $ statement = call_user_func ( [ $ dialect , $ method ] , $ this ) ; if ( $ this -> hasPrevious ( ) ) { $ statement -> setPrevious ( $ this -> getPrevious ( ) ) ; $ this -> setPrevious ( null ) ; } elseif ( $ setTable && count ( $ this -> tables ) ) { if ( method_exists ( $ statement , 'from' ) ) { $ statement -> from ( $ this -> tables ) ; } else { $ statement -> into ( $ this -> tables [ array_keys ( $ this -> tables ) [ 0 ] ] ) ; } } return $ statement ; }
7768	public function validate ( array $ data , $ rules = [ ] ) { $ this -> clearErrors ( ) ; $ this -> clearFieldAliases ( ) ; $ data = $ this -> extractFieldAliases ( $ data ) ; if ( empty ( $ rules ) ) { $ rules = $ this -> extractRules ( $ data ) ; $ data = $ this -> extractInput ( $ data ) ; } $ this -> input = $ data ; foreach ( $ this -> before as $ before ) { call_user_func_array ( $ before , [ $ this ] ) ; } foreach ( $ data as $ field => $ value ) { $ fieldRules = explode ( '|' , $ rules [ $ field ] ) ; foreach ( $ fieldRules as $ rule ) { $ continue = $ this -> validateAgainstRule ( $ field , $ value , $ this -> getRuleName ( $ rule ) , $ this -> getRuleArgs ( $ rule ) ) ; if ( ! $ continue ) { break ; } } } return $ this ; }
10118	private function writeMarginLeft ( ) { $ record = 0x0026 ; $ length = 0x0008 ; $ margin = $ this -> phpSheet -> getPageMargins ( ) -> getLeft ( ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'd' , $ margin ) ; if ( self :: getByteOrder ( ) ) { $ data = strrev ( $ data ) ; } $ this -> append ( $ header . $ data ) ; }
5886	public function resolve ( $ tsdns ) { $ this -> getTransport ( ) -> sendLine ( $ tsdns ) ; $ repl = $ this -> getTransport ( ) -> readLine ( ) ; $ this -> getTransport ( ) -> disconnect ( ) ; if ( $ repl -> section ( ":" , 0 ) -> toInt ( ) == 404 ) { throw new Ts3Exception ( "unable to resolve TSDNS hostname (" . $ tsdns . ")" ) ; } Signal :: getInstance ( ) -> emit ( "tsdnsResolved" , $ tsdns , $ repl ) ; return $ repl ; }
11320	function getOne ( $ sql , $ params = array ( ) ) { $ data = $ this -> query ( $ sql , $ params ) ; if ( count ( $ data ) > 0 ) { $ data = array_values ( $ data [ 0 ] ) ; return $ data [ 0 ] ; } return false ; }
12152	public function setup ( ) { $ results = [ true ] ; if ( ! empty ( $ this -> primaryModel ) && ! empty ( $ this -> collectorItem -> parents ) ) { $ groups = [ 'top' ] ; foreach ( $ groups as $ groupName ) { $ group = Group :: getBySystemName ( $ groupName , false ) ; if ( empty ( $ group ) ) { continue ; } if ( $ this -> inheritParentAccess ) { $ results [ ] = $ this -> objectTypeModel -> parentAccess ( null , $ group ) ; } } } return min ( $ results ) ; }
8124	protected function findRecord ( $ data ) { if ( empty ( $ data [ "ID" ] ) ) { throw new HTTPResponse_Exception ( "No record ID" , 404 ) ; } $ page = null ; $ id = $ data [ "ID" ] ; if ( is_numeric ( $ id ) ) { $ page = SiteTree :: get ( ) -> byID ( $ id ) ; } if ( ! $ page || ! $ page -> ID ) { throw new HTTPResponse_Exception ( "Bad record ID #{$id}" , 404 ) ; } return $ page ; }
5423	public function invoke ( $ method ) { $ trap = SimpleTest :: getContext ( ) -> get ( 'SimpleExceptionTrap' ) ; $ trap -> clear ( ) ; try { $ has_thrown = false ; parent :: invoke ( $ method ) ; } catch ( Exception $ exception ) { $ has_thrown = true ; if ( ! $ trap -> isExpected ( $ this -> getTestCase ( ) , $ exception ) ) { $ this -> getTestCase ( ) -> exception ( $ exception ) ; } $ trap -> clear ( ) ; } if ( $ message = $ trap -> getOutstanding ( ) ) { $ this -> getTestCase ( ) -> fail ( $ message ) ; } if ( $ has_thrown ) { try { parent :: getTestCase ( ) -> tearDown ( ) ; } catch ( Exception $ e ) { } } }
7952	public function setReverseProperties ( $ ipblock , $ ip , $ reverse ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Parameter $ip is missing.' ) ; $ payload = array ( 'ipReverse' => $ ip , 'reverse' => $ reverse ) ; try { $ r = $ this -> post ( 'ip/' . urlencode ( $ ipblock ) . '/reverse' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
696	public function afterSend ( $ message , $ isSuccessful ) { $ event = new MailEvent ( [ 'message' => $ message , 'isSuccessful' => $ isSuccessful ] ) ; $ this -> trigger ( self :: EVENT_AFTER_SEND , $ event ) ; }
9922	private function defineManyToManyRelation ( Model $ model1 , Model $ model2 ) { $ this -> relations [ $ model1 -> getName ( ) ] [ ] = new Relation ( $ model1 , $ model2 , Relation :: HAS_AND_BELONGS_TO ) ; $ this -> relations [ $ model2 -> getName ( ) ] [ ] = new Relation ( $ model2 , $ model1 , Relation :: HAS_AND_BELONGS_TO ) ; }
5477	public function addWidget ( $ tag ) { if ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'submit' ) { $ this -> buttons [ ] = $ tag ; } elseif ( strtolower ( $ tag -> getAttribute ( 'type' ) ) === 'image' ) { $ this -> images [ ] = $ tag ; } elseif ( $ tag -> getName ( ) ) { $ this -> setWidget ( $ tag ) ; } }
7968	public function getFaxConsumptions ( $ params = null ) { $ consumptionList = json_decode ( self :: getClient ( ) -> getFaxConsumptions ( $ this -> service , $ this -> billingAccount , $ params ) ) ; $ consumptions = array ( ) ; foreach ( $ consumptionList as $ consumption ) { $ consumptions [ ] = new FaxConsumption ( $ consumption , $ this ) ; } return $ consumptions ; }
12809	private static function isPrimaryKey ( string $ table , string $ column ) : bool { return self :: getPrimaryKey ( $ table ) [ "column_name" ] === $ column ; }
2612	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionary = $ this -> api -> getAuthDictionary ( $ activeVersion ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || ! isset ( $ dictionary -> id ) ) { return $ result -> setData ( [ 'status' => 'empty' , 'msg' => 'Authentication dictionary does not exist.' ] ) ; } $ user = $ this -> getRequest ( ) -> getParam ( 'auth_user' ) ; $ pass = $ this -> getRequest ( ) -> getParam ( 'auth_pass' ) ; $ key = base64_encode ( $ user . ':' . $ pass ) ; $ this -> api -> upsertDictionaryItem ( $ dictionary -> id , $ key , true ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
2995	protected function encodeHeader ( $ str ) { if ( extension_loaded ( 'iconv' ) ) { $ out = iconv_mime_encode ( 'Subject' , $ str , [ 'input-charset' => 'UTF-8' , 'output-charset' => $ this -> charset ] ) ; $ out = substr ( $ out , strlen ( 'Subject: ' ) ) ; } elseif ( extension_loaded ( 'mbstring' ) ) { mb_internal_encoding ( 'UTF-8' ) ; $ out = mb_encode_mimeheader ( $ str , $ this -> charset , 'B' , static :: $ EOL , strlen ( 'Subject: ' ) ) ; } else $ out = wordwrap ( $ str , 65 , static :: $ EOL ) ; return $ out ; }
1052	public static function build ( $ source , ? callable $ typeConfigDecorator = null , array $ options = [ ] ) { $ doc = $ source instanceof DocumentNode ? $ source : Parser :: parse ( $ source ) ; return self :: buildAST ( $ doc , $ typeConfigDecorator , $ options ) ; }
9314	public function storageClearAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ dbAdapter = $ this -> getDbAdapter ( ) ; $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; try { $ table = new JobTable ( $ dbAdapter ) ; $ table -> truncate ( ) ; } catch ( \ Exception $ exception ) { $ console -> writeLine ( 'Truncating database table failed!' , ConsoleColor :: LIGHT_RED ) ; return ; } $ console -> writeLine ( 'Storage was successfully cleared!' , ConsoleColor :: LIGHT_GREEN ) ; }
1981	public static function reset ( ) { $ session = System :: getContainer ( ) -> get ( 'session' ) ; if ( ! $ session -> isStarted ( ) ) { return ; } $ session -> getFlashBag ( ) -> clear ( ) ; }
9066	public function persist ( MessageInterface $ message ) { if ( $ message -> getMessageId ( ) > 0 ) { $ this -> update ( $ message , null , null , new MessageHydrator ) ; } else { $ this -> insert ( $ message , null , new MessageHydrator ) ; } return $ message ; }
10027	function getContactByEmail ( $ email , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/email/' . utf8_encode ( $ email ) , $ queryParameters ) ; }
5147	protected function getOpenedEmail ( $ fetchNextUnread = FALSE ) { if ( $ fetchNextUnread || $ this -> openedEmail == NULL ) { $ this -> openNextUnreadEmail ( ) ; } return $ this -> openedEmail ; }
2064	public function checkFeedAlias ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ varValue == $ dc -> value || $ varValue == '' ) { return $ varValue ; } $ varValue = Contao \ StringUtil :: standardize ( $ varValue ) ; $ this -> import ( 'Contao\Automator' , 'Automator' ) ; $ arrFeeds = $ this -> Automator -> purgeXmlFiles ( true ) ; if ( \ in_array ( $ varValue , $ arrFeeds ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
9838	public function createSymmetricAuthenticatedJsonResponse ( int $ status , array $ arrayToJsonify , SharedAuthenticationKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { if ( empty ( $ headers [ 'Content-Type' ] ) ) { $ headers [ 'Content-Type' ] = 'application/json' ; } $ body = \ json_encode ( $ arrayToJsonify , JSON_PRETTY_PRINT ) ; if ( ! \ is_string ( $ body ) ) { throw new InvalidMessageException ( 'Cannot JSON-encode this message.' ) ; } return $ this -> createSymmetricAuthenticatedResponse ( $ status , $ body , $ key , $ headers , $ version ) ; }
11367	public static function getMimeType ( $ filename = '' ) { $ ext = strtolower ( substr ( $ filename , strrpos ( $ filename , '.' ) ) ) ; switch ( $ ext ) { case '.jpeg' : case '.jpg' : $ mimetype = 'image/jpeg' ; break ; case '.gif' : $ mimetype = 'image/gif' ; break ; case '.png' : $ mimetype = 'image/png' ; break ; case '.txt' : $ mimetype = 'text/plain' ; break ; case '.html' : case '.htm' : $ mimetype = 'text/html' ; break ; case '.zip' : $ mimetype = 'application/x-zip-compressed' ; break ; default : $ mimetype = 'application/octet-stream' ; } return $ mimetype ; }
11743	public function remove ( $ pageName ) { if ( $ pageName == $ this -> configurationHandler -> homepage ( ) ) { throw new RuntimeException ( "exception_homepage_cannot_be_removed" ) ; } $ pageDir = $ this -> pagesDir . '/' . $ pageName ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVING , new PageCollectionRemovingEvent ( $ this -> username , $ pageDir ) ) ; $ filesystem = new Filesystem ( ) ; if ( file_exists ( $ pageDir . '/page.json' ) ) { $ filesystem -> mirror ( $ pageDir , $ this -> pagesRemovedDir . '/' . $ pageName . "-" . date ( "Y-m-d-H.i.s" ) ) ; } $ filesystem -> remove ( $ pageDir ) ; Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_REMOVED , new PageCollectionRemovedEvent ( $ this -> username , $ pageDir ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully removed from website' , $ pageName ) ) ; }
2043	public static function findByEmailAndPids ( $ strEmail , $ arrPids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return null ; } $ t = static :: $ strTable ; return static :: findBy ( array ( "$t.email=? AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) , $ strEmail , $ arrOptions ) ; }
206	public static function stdin ( $ raw = false ) { return $ raw ? fgets ( \ STDIN ) : rtrim ( fgets ( \ STDIN ) , PHP_EOL ) ; }
11057	public function pathFunction ( $ route , array $ params = [ ] ) { return $ this -> container [ 'url_generator' ] -> generate ( $ route , $ params , UrlGeneratorInterface :: ABSOLUTE_PATH ) ; }
8761	public function writeLogLine ( Tick $ tick ) { $ lineSegs = array ( ) ; switch ( $ tick -> getStatus ( ) ) { case Tick :: SUCCESS : $ lineSegs [ ] = sprintf ( "<fg=green>%s</fg=green>" , $ this -> linePrefixMap [ Tick :: SUCCESS ] ) ; break ; case Tick :: FAIL : $ lineSegs [ ] = sprintf ( "<fg=red>%s</fg=red>" , $ this -> linePrefixMap [ Tick :: FAIL ] ) ; break ; case Tick :: SKIP : default : $ lineSegs [ ] = $ this -> linePrefixMap [ Tick :: SKIP ] ; } $ lineSegs [ ] = sprintf ( "[%s%s]" , $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , $ tick -> getReport ( ) -> getTotalItemCount ( ) != Tracker :: UNKNOWN ? "/" . $ tick -> getReport ( ) -> getTotalItemCount ( ) : '' ) ; if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERBOSE ) { $ lineSegs [ ] = $ this -> formatSeconds ( $ tick -> getReport ( ) -> getTimeElapsed ( ) ) ; $ lineSegs [ ] = sprintf ( '(<fg=green>%s</fg=green>/%s/<fg=red>%s</fg=red>)' , $ tick -> getReport ( ) -> getNumItemsSuccess ( ) , $ tick -> getReport ( ) -> getNumItemsSkip ( ) , $ tick -> getReport ( ) -> getNumItemsFail ( ) ) ; } if ( $ this -> output -> getVerbosity ( ) >= OutputInterface :: VERBOSITY_VERY_VERBOSE ) { $ lineSegs [ ] = sprintf ( "{%s/%s}" , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemUsage ( ) ) , $ this -> bytesToHuman ( $ tick -> getReport ( ) -> getMemPeakUsage ( ) ) ) ; } $ lineSegs [ ] = $ tick -> getMessage ( ) ? : sprintf ( "Processing item %s" , number_format ( $ tick -> getReport ( ) -> getNumItemsProcessed ( ) , 0 ) ) ; $ this -> output -> writeln ( implode ( ' ' , $ lineSegs ) ) ; }
11765	public function remove ( ExpressionContract $ e ) { unset ( $ this -> expressions [ $ this -> indexOf ( $ e ) ] ) ; $ this -> expressions = array_values ( $ this -> expressions ) ; return $ this ; }
6383	public function readFeedbackAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'feedback_completed' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/feedback/complete.php?id=' . $ id ; $ model -> name = 'Attempt ' . $ id ; $ model -> responses = $ this -> readStoreRecords ( 'feedback_value' , [ 'completed' => $ id ] ) ; return $ model ; }
4328	public static function parseAttribString ( $ str , $ dataDecode = true ) { $ attribs = array ( ) ; $ regexAttribs = '/\b([\w\-]+)\b(?: \s*=\s*(["\'])(.*?)\\2 | \s*=\s*(\S+) )?/xs' ; \ preg_match_all ( $ regexAttribs , $ str , $ matches ) ; $ keys = \ array_map ( 'strtolower' , $ matches [ 1 ] ) ; $ values = \ array_replace ( $ matches [ 3 ] , \ array_filter ( $ matches [ 4 ] , 'strlen' ) ) ; foreach ( $ keys as $ i => $ k ) { $ attribs [ $ k ] = $ values [ $ i ] ; if ( \ in_array ( $ k , self :: $ htmlBoolAttr ) ) { $ attribs [ $ k ] = true ; } } \ ksort ( $ attribs ) ; foreach ( $ attribs as $ k => $ v ) { if ( \ is_string ( $ v ) ) { $ attribs [ $ k ] = \ htmlspecialchars_decode ( $ v ) ; } $ isDataAttrib = \ strpos ( $ k , 'data-' ) === 0 ; if ( $ isDataAttrib && $ dataDecode ) { $ val = $ attribs [ $ k ] ; $ attribs [ $ k ] = \ json_decode ( $ attribs [ $ k ] , true ) ; if ( $ attribs [ $ k ] === null && $ val !== 'null' ) { $ attribs [ $ k ] = \ json_decode ( '"' . $ val . '"' , true ) ; } } } return $ attribs ; }
11313	public static function buildBasestring ( $ method , Url $ url , array $ data ) { $ base = array ( ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedMethod ( $ method ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedUrl ( $ url ) ) ; $ base [ ] = self :: urlEncode ( self :: getNormalizedParameters ( $ data ) ) ; return implode ( '&' , $ base ) ; }
46	public function dispatchInstallerEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations = array ( ) ) { return $ this -> doDispatch ( new InstallerEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations ) ) ; }
5664	private function collectFrames ( $ node ) { $ frames = array ( ) ; if ( $ node -> name === 'frame' ) { $ frames = array ( $ this -> tags ( ) -> createTag ( $ node -> name , ( array ) $ node -> attribute ) ) ; } elseif ( $ node -> hasChildren ( ) ) { $ frames = array ( ) ; foreach ( $ node -> child as $ child ) { $ frames = array_merge ( $ frames , $ this -> collectFrames ( $ child ) ) ; } } return $ frames ; }
9795	public function setDataValidation ( DataValidation $ pDataValidation = null ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot set data validation for cell that is not bound to a worksheet' ) ; } $ this -> getWorksheet ( ) -> setDataValidation ( $ this -> getCoordinate ( ) , $ pDataValidation ) ; return $ this -> updateInCollection ( ) ; }
9040	public function getMax ( string $ column ) : int { return $ this -> connection -> query ( 'SELECT IFNULL(MAX(%column), 0) position FROM %table' , $ column , $ this -> getTableName ( ) ) -> fetch ( ) -> position ; }
8736	public function insert ( array $ values ) { list ( $ values , $ i18nValues ) = $ this -> filterValues ( $ values ) ; if ( $ this -> query -> insert ( $ values ) ) { return $ this -> insertI18n ( $ i18nValues , $ values [ $ this -> model -> getKeyName ( ) ] ) ; } }
3044	public function encode ( $ data ) { if ( is_array ( $ data ) ) { $ encodedData = [ self :: STORAGE_KEY_FORMAT => $ this -> getFormat ( ) , self :: STORAGE_KEY_VERSION => $ this -> getVersion ( ) , ] ; foreach ( $ data as $ key => & $ value ) { if ( $ value instanceof TimeLine ) { $ encodedData [ $ key ] = $ this -> packTimeLine ( $ value ) ; } else { $ encodedData [ $ key ] = & $ value ; } } return json_encode ( $ encodedData ) ; } return json_encode ( $ data ) ; }
7343	protected function initializeStock ( ) { $ this -> stockMode = StockSubjectModes :: MODE_AUTO ; $ this -> stockState = StockSubjectStates :: STATE_OUT_OF_STOCK ; $ this -> stockFloor = 0 ; $ this -> inStock = 0 ; $ this -> availableStock = 0 ; $ this -> virtualStock = 0 ; $ this -> replenishmentTime = 2 ; $ this -> minimumOrderQuantity = 1 ; $ this -> quoteOnly = false ; $ this -> endOfLife = false ; }
2743	public function execute ( Observer $ observer ) { if ( $ this -> backendAuthSession -> isLoggedIn ( ) == false ) { return ; } if ( $ this -> getFrequency ( ) + $ this -> getLastUpdate ( ) > time ( ) ) { return ; } $ modulePath = $ this -> moduleRegistry -> getPath ( ComponentRegistrar :: MODULE , 'Fastly_Cdn' ) ; $ filePath = str_replace ( [ '\\' , '/' ] , DIRECTORY_SEPARATOR , "$modulePath/composer.json" ) ; $ composerData = json_decode ( file_get_contents ( $ filePath ) ) ; $ currentVersion = ! empty ( $ composerData -> version ) ? $ composerData -> version : false ; if ( $ currentVersion ) { $ this -> feedFactory -> checkUpdate ( $ currentVersion ) ; } $ this -> setLastUpdate ( ) ; }
11485	protected function resolveClassArg ( ReflectionClass $ class , ReflectionParameter $ param , array $ params ) { $ name = '$' . $ param -> getName ( ) ; $ class = $ class -> getName ( ) ; while ( $ name !== null ) { if ( $ params && array_key_exists ( $ name , $ params ) ) { $ class = $ params [ $ name ] ; } if ( $ class instanceof Factory \ FactoryInterface ) { return $ class -> invoke ( $ this ) ; } if ( is_object ( $ class ) ) { return $ class ; } $ name = ( $ name != $ class ) ? $ class : null ; } try { return $ this -> resolve ( $ class ) ; } catch ( ReflectionException $ exception ) { if ( $ param -> isOptional ( ) ) { return null ; } throw $ exception ; } }
2273	public function getModules ( ) { $ groups = array ( ) ; foreach ( $ GLOBALS [ 'FE_MOD' ] as $ k => $ v ) { foreach ( array_keys ( $ v ) as $ kk ) { $ groups [ $ k ] [ ] = $ kk ; } } return $ groups ; }
8626	public function setTermsAndConditionsNotAcceptedCarrierList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'TermsAndConditionsNotAcceptedCarrierList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11263	protected function isUnique ( $ instance ) { foreach ( $ this -> getCollection ( ) as $ entry ) { if ( $ entry -> getAnnotatedName ( ) === $ instance -> getAnnotatedName ( ) ) { return false ; } } return true ; }
8166	public function write ( ) { $ strings = func_get_args ( ) ; foreach ( $ strings as $ string ) { $ this -> source .= str_repeat ( ' ' , $ this -> indentation * 4 ) . $ string ; } return $ this ; }
4233	private static function getHash ( $ what ) { $ str = null ; if ( ! ( $ what instanceof \ Reflector ) ) { $ str = \ get_class ( $ what ) ; } elseif ( $ what instanceof \ ReflectionClass ) { $ str = $ what -> getName ( ) ; } elseif ( $ what instanceof \ ReflectionMethod ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionFunction ) { $ str = $ what -> getName ( ) . '()' ; } elseif ( $ what instanceof \ ReflectionProperty ) { $ str = $ what -> getDeclaringClass ( ) -> getName ( ) . '::' . $ what -> getName ( ) ; } return $ str ? \ md5 ( $ str ) : null ; }
3556	public function setMetaGroup ( $ group = null ) { if ( ! preg_match ( '/^[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*$/' , $ group ) && $ group !== null ) { throw new InvalidArgumentException ( "Provided group [{$group}] is not valid variable name." ) ; } $ this -> attributes [ 'meta_group' ] = $ group ; }
12877	public function generateAndroidManifest ( ) { $ pinicon = $ this -> owner -> AndroidPinicon ( ) ; if ( $ pinicon -> exists ( ) ) { $ manifest = new stdClass ( ) ; $ manifest -> name = $ this -> owner -> PiniconTitle ; $ manifest -> icons = array ( ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 36 , 36 ) -> getAbsoluteURL ( ) , 'sizes' => '36x36' , 'type' => 'image/png' , 'density' => 0.75 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 48 , 48 ) -> getAbsoluteURL ( ) , 'sizes' => '48x48' , 'type' => 'image/png' , 'density' => 1 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 72 , 72 ) -> getAbsoluteURL ( ) , 'sizes' => '72x72' , 'type' => 'image/png' , 'density' => 1.5 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 96 , 96 ) -> getAbsoluteURL ( ) , 'sizes' => '96x96' , 'type' => 'image/png' , 'density' => 2 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 144 , 144 ) -> getAbsoluteURL ( ) , 'sizes' => '144x144' , 'type' => 'image/png' , 'density' => 3 ) ) ; array_push ( $ manifest -> icons , array ( 'src' => $ pinicon -> Fill ( 192 , 192 ) -> getAbsoluteURL ( ) , 'sizes' => '192x192' , 'type' => 'image/png' , 'density' => 4 ) ) ; $ bytes = file_put_contents ( Director :: baseFolder ( ) . '/manifest.json' , json_encode ( $ manifest ) ) ; if ( $ bytes !== false ) { return true ; } } return false ; }
4769	public function run ( ) { if ( ! $ this -> is_debug ( ) || ! $ this -> is_debug_display ( ) ) { return ; } $ run = $ this [ 'run' ] ; $ run -> register ( ) ; ob_start ( ) ; }
11666	public function addFunction ( $ functionName , $ callback ) { if ( is_string ( $ functionName ) && is_callable ( $ callback ) ) { $ functions = [ 'name' => $ functionName , 'callable' => $ callback , ] ; array_push ( $ this -> functionList , $ functions ) ; } }
6823	protected function getShipmentAccountNumber ( TaxRuleInterface $ rule , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_SHIPPING ) { continue ; } if ( $ account -> getTaxRule ( ) !== $ rule ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No shipment account number configured for tax rule '%s' (%s)" , $ rule -> getName ( ) , $ origin ) ) ; }
8154	public function addFunction ( $ name , $ function = null ) { if ( ! $ name instanceof Twig_SimpleFunction && ! ( $ function instanceof Twig_SimpleFunction || $ function instanceof Twig_FunctionInterface ) ) { throw new LogicException ( 'A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction.' ) ; } if ( $ name instanceof Twig_SimpleFunction ) { $ function = $ name ; $ name = $ function -> getName ( ) ; } else { @ trigger_error ( sprintf ( 'Passing a name as a first argument to the %s method is deprecated since version 1.21. Pass an instance of "Twig_SimpleFunction" instead when defining function "%s".' , __METHOD__ , $ name ) , E_USER_DEPRECATED ) ; } if ( $ this -> extensionInitialized ) { throw new LogicException ( sprintf ( 'Unable to add function "%s" as extensions have already been initialized.' , $ name ) ) ; } $ this -> staging -> addFunction ( $ name , $ function ) ; }
12442	public function detach ( $ key ) { if ( isset ( $ this -> instances [ $ key ] ) ) { unset ( $ this -> instances [ $ key ] ) ; } return $ this ; }
8512	public function listInboundShipmentItemsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItemsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
4523	protected function loadDefinition ( $ id ) { $ filename = $ this -> definitionPath . $ id . '.json' ; $ definition = @ file_get_contents ( $ filename ) ; if ( empty ( $ definition ) ) { throw new UnknownZoneException ( $ id ) ; } $ definition = json_decode ( $ definition , true ) ; $ definition [ 'id' ] = $ id ; return $ definition ; }
5524	public function generatePartial ( $ methods ) { if ( ! $ this -> reflection -> classExists ( $ this -> class ) ) { return false ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_class ) ; if ( $ mock_reflection -> classExistsWithoutAutoload ( ) ) { trigger_error ( 'Partial mock class [' . $ this -> mock_class . '] already exists' ) ; return false ; } $ code = $ this -> extendClassCode ( $ methods ) ; return eval ( "$code return \$code;" ) ; }
4987	public function setForm ( $ key , $ spec , $ enabled = true ) { if ( is_object ( $ spec ) ) { if ( $ spec instanceof FormParentInterface ) { $ spec -> setParent ( $ this ) ; } $ spec = [ '__instance__' => $ spec , 'name' => $ key , 'entity' => '*' ] ; } if ( ! is_array ( $ spec ) ) { $ spec = array ( 'type' => $ spec , 'name' => $ key ) ; } if ( ! isset ( $ spec [ 'name' ] ) ) { $ spec [ 'name' ] = $ key ; } if ( ! isset ( $ spec [ 'entity' ] ) ) { $ spec [ 'entity' ] = '*' ; } $ this -> forms [ $ key ] = $ spec ; if ( $ enabled ) { $ this -> enableForm ( $ key ) ; } elseif ( true === $ this -> activeForms ) { $ this -> activeForms = false ; } return $ this ; }
3272	public function setConfig ( Config $ config ) { $ this -> config = $ config ; $ this -> getDatabase ( ) -> setConfig ( $ config ) ; }
8288	protected function loadModules ( ) { foreach ( $ this -> config [ "authModules" ] as $ name ) { try { $ instance = $ this -> container -> get ( $ name ) ; } catch ( \ League \ Container \ Exception \ NotFoundException $ e ) { if ( ! class_exists ( $ name ) ) { throw new \ RuntimeException ( "PicoAuth module not found: " . $ name ) ; } $ instance = new $ name ; } if ( ! is_subclass_of ( $ instance , Module \ AbstractAuthModule :: class , false ) ) { throw new \ RuntimeException ( "PicoAuth module class must inherit from AbstractAuthModule." ) ; } $ name = $ instance -> getName ( ) ; $ this -> modules [ $ name ] = $ instance ; } }
3633	public function pools ( Request $ request ) : array { if ( $ name = $ request -> query ( 'name' ) ) { if ( ! App :: hasPool ( $ name ) ) { return [ ] ; } $ poolConfig = App :: getPool ( $ name ) -> getPoolConfig ( ) ; return $ poolConfig -> toArray ( ) ; } return PoolCollector :: getCollector ( ) ; }
7393	public function unserialize ( $ serialized ) : void { $ this -> _initMetaData ( ) ; $ data = unserialize ( $ serialized ) ; foreach ( $ data as $ k => $ v ) { $ this -> { $ k } = $ v ; } }
7679	function TbsMergeVarFields ( $ PrmVal , $ FldVal ) { $ this -> TBS -> meth_Merge_AutoVar ( $ PrmVal , true ) ; $ PrmVal = str_replace ( $ this -> TBS -> _ChrVal , $ FldVal , $ PrmVal ) ; return $ PrmVal ; }
8128	public static function findByPasswordResetToken ( $ id , $ code ) { if ( ! static :: isPasswordResetTokenValid ( $ code ) ) { return NULL ; } return static :: findOne ( [ 'id' => $ id , 'password_reset_token' => $ code , 'status' => self :: STATUS_ACTIVE , ] ) ; }
3343	public function createLocalCopy ( $ source , $ store = true ) { $ data = $ this -> __preparedRequest ( 'file_copy' , 'POST' , array ( ) , array ( 'source' => $ source , 'store' => $ store ) ) ; if ( array_key_exists ( 'result' , ( array ) $ data ) == true ) { if ( $ data -> type == 'file' ) { return new File ( ( string ) $ data -> result -> uuid , $ this ) ; } else { return ( string ) $ data -> result ; } } else { return ( string ) $ data -> detail ; } }
264	protected function escapeColumnName ( $ columnName , & $ params = [ ] ) { if ( $ columnName instanceof Query ) { list ( $ sql , $ params ) = $ this -> queryBuilder -> build ( $ columnName , $ params ) ; return "($sql)" ; } elseif ( $ columnName instanceof ExpressionInterface ) { return $ this -> queryBuilder -> buildExpression ( $ columnName , $ params ) ; } elseif ( strpos ( $ columnName , '(' ) === false ) { return $ this -> queryBuilder -> db -> quoteColumnName ( $ columnName ) ; } return $ columnName ; }
11074	public function setDateTime ( string $ key , $ value , string $ format , string $ ignoredDefaultValue = null ) { if ( $ value instanceof DateTime ) { $ this -> set ( $ key , $ value -> format ( $ format ) , $ ignoredDefaultValue ) ; } return $ this ; }
5241	private function exceptionFields ( \ Exception $ exception ) { return '|' . get_class ( $ exception ) . '|' . $ exception -> getMessage ( ) . '|' . $ exception -> getFile ( ) . '|' . $ exception -> getLine ( ) ; }
10464	private function deductionForDeletion ( $ connection , $ tableName , $ documentType , $ documentId , $ shopId ) { $ sql = sprintf ( "SELECT `id` FROM {$tableName} WHERE `type` != 'D' AND `document_type` = :documentType AND `document_id` = :documentId AND `status` = :status AND `id` < :id" ) ; $ statement = $ connection -> prepare ( $ sql ) ; $ statement -> execute ( [ 'documentType' => $ documentType , 'documentId' => $ documentId , 'status' => self :: STATUS_NEW , 'id' => $ connection -> lastInsertId ( ) , ] ) ; $ entries = $ statement -> fetchAll ( ) ; foreach ( $ entries as $ entry ) { $ this -> removeRecord ( $ entry [ 'id' ] , [ $ shopId ] ) ; } }
4947	protected function checkPermission ( $ permission ) { $ perms = array ( self :: PERMISSION_ALL , self :: PERMISSION_CHANGE , self :: PERMISSION_NONE , self :: PERMISSION_VIEW , ) ; if ( ! in_array ( $ permission , $ perms ) ) { throw new \ InvalidArgumentException ( 'Invalid permission. Must be one of ' . implode ( ', ' , $ perms ) ) ; } }
9847	public function createSealedResponse ( int $ status , string $ body , SealingPublicKey $ key , array $ headers = [ ] , string $ version = '1.1' ) : ResponseInterface { return new Response ( $ status , new Headers ( $ headers ) , $ this -> stringToStream ( Base64UrlSafe :: encode ( Simple :: seal ( $ body , $ key ) ) ) ) ; }
271	protected function renderSeparator ( $ spanLeft , $ spanMid , $ spanMidMid , $ spanRight ) { $ separator = $ spanLeft ; foreach ( $ this -> _columnWidths as $ index => $ rowSize ) { if ( $ index !== 0 ) { $ separator .= $ spanMid ; } $ separator .= str_repeat ( $ spanMidMid , $ rowSize ) ; } $ separator .= $ spanRight . "\n" ; return $ separator ; }
11709	public function actionUpdate ( $ id ) { $ user = $ this -> findModel ( $ id ) ; $ user -> scenario = 'update' ; $ profile = $ this -> finder -> findProfileById ( $ id ) ; $ r = \ Yii :: $ app -> request ; $ this -> performAjaxValidation ( [ $ user , $ profile ] ) ; if ( $ user -> load ( $ r -> post ( ) ) && $ profile -> load ( $ r -> post ( ) ) && $ user -> save ( ) && $ profile -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'update' , [ 'user' => $ user , 'profile' => $ profile , 'module' => $ this -> module , ] ) ; }
891	public function setTypes ( array $ types ) { $ pattern = '/' . preg_quote ( $ this -> getTypesContent ( ) , '/' ) . '/' ; $ this -> lines [ 0 ] -> setContent ( Preg :: replace ( $ pattern , implode ( '|' , $ types ) , $ this -> lines [ 0 ] -> getContent ( ) , 1 ) ) ; $ this -> clearCache ( ) ; }
12642	public function set ( $ key , $ value ) { if ( ! is_string ( $ key ) ) throw new InvalidArgumentException ( 'First parameter has to be a string' ) ; if ( ! $ this -> isTypeSupported ( gettype ( $ value ) ) ) throw new UnsupportedException ( 'First parameter has to be an int, a double, a bool or a string' ) ; try { $ this -> getRecursive ( $ key , $ this -> data ) ; $ this -> data = $ this -> setRecursive ( $ key , $ value ) ; } catch ( ElementNotFoundException $ e ) { $ this -> data = array_merge_recursive ( $ this -> data , $ this -> setRecursive ( $ key , $ value ) ) ; } }
2665	public function createDictionary ( $ version , $ params ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/dictionary' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ params ) ; return $ result ; }
7824	public function getHalfWidth ( $ up = false ) { $ number = $ this -> getTotalWidth ( ) ; return $ this -> roundHalf ( $ number , $ up ) ; }
7954	public function getSpamStats ( $ ipblock , $ spamstate , $ fromdate , $ todate ) { if ( ! $ ipblock ) throw new BadMethodCallException ( 'Parameter $ipblock is missing.' ) ; if ( ! $ ipv4 ) throw new BadMethodCallException ( 'Parameter $ipv4 is missing.' ) ; if ( ! $ fromdate ) throw new BadMethodCallException ( 'Parameter $fromdate is missing.' ) ; if ( ! $ todate ) throw new BadMethodCallException ( 'Parameter $todate is missing.' ) ; try { $ r = $ this -> get ( 'ip/' . urlencode ( $ ipblock ) . '/spam/' . $ ipv4 . '/stats?from=' . urlencode ( $ fromdate ) . '&to=' . urlencode ( $ todate ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new IpException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7302	static function getAvailableTransitions ( PaymentInterface $ payment , $ admin = false ) { $ transitions = [ ] ; $ method = $ payment -> getMethod ( ) ; $ state = $ payment -> getState ( ) ; if ( $ admin ) { if ( $ method -> isManual ( ) ) { switch ( $ state ) { case PaymentStates :: STATE_PENDING : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CAPTURED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_REFUND ; break ; case PaymentStates :: STATE_REFUNDED : $ transitions [ ] = static :: TRANSITION_CANCEL ; $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; case PaymentStates :: STATE_CANCELED : $ transitions [ ] = static :: TRANSITION_HANG ; $ transitions [ ] = static :: TRANSITION_ACCEPT ; break ; } } elseif ( $ method -> isOutstanding ( ) || $ method -> isManual ( ) ) { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } else { $ transitions [ ] = static :: TRANSITION_ACCEPT ; } } else { if ( $ state === PaymentStates :: STATE_CAPTURED ) { $ transitions [ ] = static :: TRANSITION_REFUND ; } if ( $ state === PaymentStates :: STATE_PENDING ) { $ diff = $ payment -> getUpdatedAt ( ) -> diff ( new \ DateTime ( ) ) ; if ( 0 < $ diff -> days && ! $ diff -> invert ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } } } else { if ( $ method -> isManual ( ) && $ state === PaymentStates :: STATE_PENDING ) { $ transitions [ ] = static :: TRANSITION_CANCEL ; } } return $ transitions ; }
12760	public static function dispatch ( $ eventName , Event $ event ) { if ( null === self :: $ dispatcher ) { return $ event ; } self :: $ dispatcher -> dispatch ( $ eventName , $ event ) ; DataLogger :: log ( sprintf ( 'The "%s" event was dispatched' , $ eventName ) ) ; if ( $ event -> getAbort ( ) ) { DataLogger :: log ( sprintf ( 'The "%s" event was aborted' , $ eventName ) , DataLogger :: ERROR ) ; throw new EventAbortedException ( $ event -> getAbortMessage ( ) ) ; } return $ event ; }
6157	public function redirectSelf ( ) : object { $ url = $ this -> di -> get ( "request" ) -> getCurrentUrl ( ) ; return parent :: redirect ( $ this -> di -> get ( "url" ) -> create ( $ url ) ) ; }
9206	public function importTables ( array $ data ) { $ tableCount = count ( $ data ) ; $ this -> out ( "<info>Starting seed of {$tableCount} table(s).</info>" ) ; foreach ( $ data as $ table => $ records ) { $ this -> out ( "<info>{$table}</info>" ) ; $ defaults = [ ] ; if ( array_key_exists ( '_defaults' , $ records ) ) { $ defaults = $ records [ '_defaults' ] ; unset ( $ records [ '_defaults' ] ) ; $ this -> verbose ( "<success>{$table}: Default values set.</success>" ) ; } $ entityOptions = [ ] ; if ( array_key_exists ( '_options' , $ records ) ) { $ entityOptions = $ records [ '_options' ] ; unset ( $ records [ '_options' ] ) ; $ this -> verbose ( "<success>{$table}: Entity options set, but...</success>" ) ; $ this -> quiet ( "<warning>{$table}: Deprecation notice: Change [_options] to [_entityOptions].</warning>" ) ; } elseif ( array_key_exists ( '_entityOptions' , $ records ) ) { $ entityOptions = $ records [ '_entityOptions' ] ; unset ( $ records [ '_entityOptions' ] ) ; $ this -> verbose ( "<success>{$table}: Entity options set.</success>" ) ; } $ saveOptions = [ ] ; if ( array_key_exists ( '_saveOptions' , $ records ) ) { $ saveOptions = $ records [ '_saveOptions' ] ; unset ( $ records [ '_saveOptions' ] ) ; $ this -> verbose ( "<success>{$table}: Table save() options set.</success>" ) ; } $ Table = $ this -> loadModel ( $ table ) ; if ( array_key_exists ( '_truncate' , $ records ) && $ records [ '_truncate' ] ) { $ this -> truncateTable ( $ Table ) ; } unset ( $ records [ '_truncate' ] ) ; $ this -> importTable ( $ Table , $ this -> entityGenerator ( $ Table , $ records , $ defaults , $ entityOptions ) , $ saveOptions ) ; } $ this -> out ( "<info>Seeding complete.</info>" ) ; }
1182	protected function jsValidator ( Validator $ validator , $ selector = null ) { $ remote = ! $ this -> options [ 'disable_remote_validation' ] ; $ view = $ this -> options [ 'view' ] ; $ selector = is_null ( $ selector ) ? $ this -> options [ 'form_selector' ] : $ selector ; $ delegated = new DelegatedValidator ( $ validator , new ValidationRuleParserProxy ( ) ) ; $ rules = new RuleParser ( $ delegated , $ this -> getSessionToken ( ) ) ; $ messages = new MessageParser ( $ delegated ) ; $ jsValidator = new ValidatorHandler ( $ rules , $ messages ) ; $ manager = new JavascriptValidator ( $ jsValidator , compact ( 'view' , 'selector' , 'remote' ) ) ; return $ manager ; }
3684	protected function buildNativeSqlProcedure ( FilterBuilderSql $ procedure , $ children ) { $ skipped = array ( ) ; $ metaModel = $ this -> getMetaModel ( ) ; $ tableName = $ metaModel -> getTableName ( ) ; foreach ( $ children as $ child ) { if ( isset ( $ child [ 'property' ] ) && $ metaModel -> hasAttribute ( $ child [ 'property' ] ) ) { $ skipped [ ] = $ child ; continue ; } if ( ( 'AND' === $ child [ 'operation' ] ) || ( 'OR' === $ child [ 'operation' ] ) ) { if ( null === $ child [ 'children' ] ) { continue ; } $ subProcedure = new FilterBuilderSql ( $ tableName , $ child [ 'operation' ] , $ this -> connection ) ; $ subSkipped = $ this -> buildNativeSqlProcedure ( $ subProcedure , $ child [ 'children' ] ) ; if ( count ( $ subSkipped ) !== count ( $ child [ 'children' ] ) ) { $ procedure -> addSubProcedure ( $ subProcedure ) ; } if ( ! empty ( $ subSkipped ) ) { $ skipped += $ subSkipped ; } continue ; } $ procedure -> addChild ( $ child ) ; } return $ skipped ; }
4562	public function getProperties ( Translatable $ model ) : array { $ class = get_class ( $ model ) ; if ( substr ( $ class , 0 , 15 ) === 'Proxies\\__CG__\\' ) { $ class = substr ( $ class , 15 ) ; } $ properties = [ ] ; $ reflection = new ReflectionClass ( $ class ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Translate :: class ) ; if ( ! $ annotation ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
5690	public static function normalise ( $ html ) { $ rules = array ( '#<!--.*? , '#<(script|option|textarea)[^>]*>.*?</\1>#si' , '#<img[^>]*alt\s*=\s*("([^"]*)"|\'([^\']*)\'|([a-zA-Z_]+))[^>]*>#' , '#<[^>]*>#' , ) ; $ replace = array ( '' , '' , ' \2\3\4 ' , '' , ) ; $ text = preg_replace ( $ rules , $ replace , $ html ) ; $ text = html_entity_decode ( $ text , ENT_QUOTES ) ; $ text = preg_replace ( '#\s+#' , ' ' , $ text ) ; return trim ( trim ( $ text ) , "\xA0" ) ; }
4956	protected function proxy ( ) { $ args = func_get_args ( ) ; $ method = array_shift ( $ args ) ; $ callback = array ( $ this -> object , $ method ) ; if ( ! is_callable ( $ callback ) ) { throw new \ BadMethodCallException ( sprintf ( 'Cannot proxy "%s" to "%s": Unknown method.' , $ method , get_class ( $ this -> object ) ) ) ; } $ return = call_user_func_array ( $ callback , $ args ) ; if ( $ return === $ this -> object ) { $ return = $ this ; } return $ return ; }
12269	protected function generateEventNames ( $ baseEventName , Page $ page ) { $ pageName = $ page -> getPageName ( ) ; $ language = $ page -> getCurrentLanguage ( ) ; return array ( $ baseEventName , $ baseEventName . '.' . $ language , $ baseEventName . '.' . $ pageName , $ baseEventName . '.' . $ language . '.' . $ pageName , ) ; }
6443	public function httpRequest ( $ url ) { if ( DEBUG ) echo "HTTP request: $url\n" ; $ curl = curl_init ( ) ; curl_setopt ( $ curl , CURLOPT_URL , $ url ) ; curl_setopt ( $ curl , CURLOPT_HEADER , 0 ) ; curl_setopt ( $ curl , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ curl , CURLOPT_TIMEOUT , CURL_TIMEOUT ) ; curl_setopt ( $ curl , CURLOPT_USERAGENT , SPIDER_NAME ) ; curl_setopt ( $ curl , CURLOPT_VERBOSE , false ) ; curl_setopt ( $ curl , CURLOPT_MAXREDIRS , 4 ) ; curl_setopt ( $ curl , CURLOPT_FOLLOWLOCATION , true ) ; $ response [ 'file' ] = curl_exec ( $ curl ) ; $ response [ 'status' ] = curl_getinfo ( $ curl ) ; $ response [ 'error' ] = curl_error ( $ curl ) ; curl_exec ( $ curl ) ; curl_close ( $ curl ) ; if ( DEBUG === 'verbose' ) { echo "Retrieved HTTP:\n" ; var_dump ( $ response [ 'status' ] ) ; var_dump ( $ response [ 'error' ] ) ; } if ( $ response [ 'file' ] == '' ) die ( "Error while making the HTTP request: no HTML retrieved." ) ; return $ response ; }
2425	public static function shouldBeSynchronized ( $ strPath ) { if ( ! isset ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) || ! \ is_bool ( static :: $ arrShouldBeSynchronized [ $ strPath ] ) ) { static :: $ arrShouldBeSynchronized [ $ strPath ] = ! static :: isFileSyncExclude ( $ strPath ) ; } return static :: $ arrShouldBeSynchronized [ $ strPath ] ; }
1385	protected function memberRequired ( string $ path , string $ member ) : void { $ this -> errors -> add ( $ this -> translator -> memberRequired ( $ path , $ member ) ) ; }
4607	public function statuses ( int $ account_id , int $ limit = 40 , int $ since_id = null ) : array { $ url = "/accounts/${account_id}/statuses" ; $ query = [ 'limit' => $ limit , 'since_id' => $ since_id , ] ; return $ this -> get ( $ url , $ query ) ; }
4497	private function getAndroidJsonInner ( ? string $ text ) : array { $ data = [ ] ; if ( null !== $ text ) { $ data [ 'message' ] = $ text ; } if ( null !== $ this -> localizedKey ) { $ data [ 'message-loc-key' ] = $ this -> localizedKey ; if ( $ this -> localizedArguments ) { $ data [ 'message-loc-args' ] = $ this -> localizedArguments ; } } return $ data ; }
2853	public function purgeAllProfiles ( ) { $ table = Mage :: getResourceModel ( 'sheep_debug/requestInfo' ) -> getMainTable ( ) ; $ deleteSql = "DELETE FROM {$table}" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return $ result -> rowCount ( ) ; }
1135	public function moveToNewParent ( ) { $ pid = static :: $ moveToNewParentId ; if ( is_null ( $ pid ) ) $ this -> makeRoot ( ) ; else if ( $ pid !== FALSE ) $ this -> makeChildOf ( $ pid ) ; }
8226	protected function validateRegistration ( array $ reg ) { $ isValid = true ; try { $ this -> storage -> checkValidName ( $ reg [ "username" ] ) ; } catch ( \ RuntimeException $ e ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , $ e -> getMessage ( ) ) ; } $ min = $ this -> config [ "nameLenMin" ] ; $ max = $ this -> config [ "nameLenMax" ] ; if ( strlen ( $ reg [ "username" ] ) < $ min || strlen ( $ reg [ "username" ] ) > $ max ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , sprintf ( "Length of a username must be between %d-%d characters." , $ min , $ max ) ) ; } if ( ! filter_var ( $ reg [ "email" ] , FILTER_VALIDATE_EMAIL ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; } if ( null !== $ this -> storage -> getUserByEmail ( $ reg [ "email" ] ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "This email is already in use." ) ; } if ( $ reg [ "password" ] -> get ( ) !== $ reg [ "passwordRepeat" ] -> get ( ) ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The passwords do not match." ) ; } $ localAuth = $ this -> picoAuth -> getContainer ( ) -> get ( 'LocalAuth' ) ; if ( ! $ localAuth -> checkPasswordPolicy ( $ reg [ "password" ] ) ) { $ isValid = false ; } if ( $ this -> storage -> getUserByName ( $ reg [ "username" ] ) !== null ) { $ isValid = false ; $ this -> session -> addFlash ( "error" , "The username is already taken." ) ; } return $ isValid ; }
9451	protected function logDLStatDetails ( ) { $ pageId = $ GLOBALS [ 'objPage' ] -> id ; $ pageHost = \ Environment :: get ( 'host' ) ; if ( isset ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] ) && ( bool ) $ GLOBALS [ 'TL_CONFIG' ] [ 'dlstatdets' ] === true ) { $ username = '' ; $ strCookie = 'FE_USER_AUTH' ; $ hash = sha1 ( session_id ( ) . ( ! $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] ? $ this -> IP : '' ) . $ strCookie ) ; if ( \ Input :: cookie ( $ strCookie ) == $ hash ) { $ qs = \ Database :: getInstance ( ) -> prepare ( "SELECT pid, tstamp, sessionID, ip FROM `tl_session` WHERE `hash`=? AND `name`=?" ) -> execute ( $ hash , $ strCookie ) ; if ( $ qs -> next ( ) && $ qs -> sessionID == session_id ( ) && ( $ GLOBALS [ 'TL_CONFIG' ] [ 'disableIpCheck' ] || $ qs -> ip == $ this -> IP ) && ( $ qs -> tstamp + $ GLOBALS [ 'TL_CONFIG' ] [ 'sessionTimeout' ] ) > time ( ) ) { $ qm = \ Database :: getInstance ( ) -> prepare ( "SELECT `username` FROM `tl_member` WHERE id=?" ) -> execute ( $ qs -> pid ) ; if ( $ qm -> next ( ) ) { $ username = $ qm -> username ; } } } \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId , 'ip' => $ this -> dlstatsAnonymizeIP ( ) , 'domain' => $ this -> dlstatsAnonymizeDomain ( ) , 'username' => $ username , 'page_host' => $ pageHost , 'page_id' => $ pageId , 'browser_lang' => $ this -> dlstatsGetLang ( ) ) ) -> execute ( ) ; } else { \ Database :: getInstance ( ) -> prepare ( "INSERT INTO `tl_dlstatdets` %s" ) -> set ( array ( 'tstamp' => time ( ) , 'pid' => $ this -> _statId ) ) -> execute ( ) ; } }
10249	public function getDate ( $ params = [ ] , $ format = 'Y-m-d' ) { foreach ( $ params as $ k => $ v ) { $ $ k = $ v ; } if ( ! isset ( $ min_year ) ) { $ min_year = date ( 'Y' ) - 2 ; } if ( ! isset ( $ max_year ) ) { $ max_year = date ( 'Y' ) ; } if ( ! isset ( $ min_month ) ) { $ min_month = 1 ; } if ( ! isset ( $ max_month ) ) { $ max_month = 12 ; } $ rand_year = rand ( $ min_year , $ max_year ) ; $ rand_month = rand ( $ min_month , $ max_month ) ; $ date = DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , '01' ] ) ) ; $ days_in_month = $ date -> format ( 't' ) ; $ rand_day = rand ( 1 , $ days_in_month ) ; return DateTime :: createFromFormat ( 'Y-m-d' , join ( '-' , [ $ rand_year , $ rand_month , $ rand_day ] ) ) -> format ( $ format ) ; }
7605	public function setTranslator ( TranslatorInterface $ oTranslator = null , $ sTextDomain = null ) { $ this -> translator = $ oTranslator ; if ( null !== $ sTextDomain ) { $ this -> setTranslatorTextDomain ( $ sTextDomain ) ; } return $ this ; }
6895	protected function compareStockUnitByEda ( StockUnitInterface $ u1 , StockUnitInterface $ u2 ) { $ u1HasEda = null !== $ u1 -> getEstimatedDateOfArrival ( ) ; $ u2HasEda = null !== $ u2 -> getEstimatedDateOfArrival ( ) ; if ( ! $ u1HasEda && $ u2HasEda ) { return 1 ; } if ( $ u1HasEda && ! $ u2HasEda ) { return - 1 ; } if ( $ u1 -> getEstimatedDateOfArrival ( ) != $ u2 -> getEstimatedDateOfArrival ( ) ) { return $ u1 -> getEstimatedDateOfArrival ( ) > $ u2 -> getEstimatedDateOfArrival ( ) ? 1 : - 1 ; } return 0 ; }
4803	public function renderRichText ( $ richText ) { if ( strlen ( $ richText ) < 1 ) { return '' ; } $ templatePath = $ this -> getTemplatePathAndFilename ( 'RichText' ) ; $ view = $ this -> createView ( $ templatePath ) ; $ view -> assign ( 'richText' , $ richText ) ; return $ view -> render ( $ templatePath ) ; }
4960	public function render ( FormInterface $ form , $ layout = self :: LAYOUT_HORIZONTAL , $ parameter = array ( ) ) { $ formContent = $ this -> renderBare ( $ form , $ layout , $ parameter ) ; $ renderer = $ this -> getView ( ) ; if ( $ form instanceof DescriptionAwareFormInterface && $ form -> isDescriptionsEnabled ( ) ) { $ renderer -> headscript ( ) -> appendFile ( $ renderer -> basepath ( 'modules/Core/js/forms.descriptions.js' ) ) ; if ( $ desc = $ form -> getOption ( 'description' , '' ) ) { $ descriptionParams = $ form -> getOption ( 'description_params' ) ; $ translator = $ this -> getTranslator ( ) ; $ textDomain = $ this -> getTranslatorTextDomain ( ) ; $ desc = $ translator -> translate ( $ desc , $ textDomain ) ; if ( $ descriptionParams ) { array_unshift ( $ descriptionParams , $ desc ) ; $ desc = call_user_func_array ( 'sprintf' , $ descriptionParams ) ; } } $ formContent = sprintf ( '<div class="daf-form-container row"> <div class="daf-form col-md-8"><div class="panel panel-default"><div class="panel-body">%s</div></div></div> <div class="daf-desc col-md-4"> <div class="daf-desc-content alert alert-info">%s</div> </div> </div>' , $ formContent , $ desc ) ; } else { $ formContent = '<div class="form-content">' . $ formContent . '</div>' ; } $ markup = '<div id="form-%s" class="form-container">' . '%s' . '%s' . '</div>' ; if ( $ label = $ form -> getLabel ( ) ) { $ label = '<div class="form-headline"><h3>' . $ renderer -> translate ( $ label ) . '</h3></div>' ; } return sprintf ( $ markup , $ form -> getAttribute ( 'id' ) ? : $ form -> getName ( ) , $ label , $ formContent ) ; }
5671	protected function describeStringDifference ( $ first , $ second , $ identical ) { if ( is_object ( $ second ) || is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } $ position = $ this -> stringDiffersAt ( $ first , $ second ) ; return sprintf ( 'at character %s with [%s] and [%s]' , $ position , $ this -> clipString ( $ first , 200 , $ position ) , $ this -> clipString ( $ second , 200 , $ position ) ) ; }
6030	public function setChildMedias ( array $ childMedias ) { $ this -> childMedias = [ ] ; foreach ( $ childMedias as $ item ) { $ this -> addself ( $ item ) ; } return $ this ; }
2542	protected function analyzeWithErrorCodeMsgQueryLevel ( SendResult $ response , $ qErr , $ qMsg , $ qLvl , $ lvlToText ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ errorCodeNodeList = $ domXpath -> query ( $ qErr ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ lvlNodeList = $ domXpath -> query ( $ qLvl ) ; $ level = null ; if ( $ lvlNodeList -> length > 0 ) { if ( array_key_exists ( $ lvlNodeList -> item ( 0 ) -> nodeValue , $ lvlToText ) ) { $ level = $ lvlToText [ $ lvlNodeList -> item ( 0 ) -> nodeValue ] ; } } $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ errorCodeNodeList -> item ( 0 ) -> nodeValue , $ this -> makeMessageFromMessagesNodeList ( $ domXpath -> query ( $ qMsg ) ) , $ level ) ; } return $ analyzeResponse ; }
4902	private static function getDockerEnv ( $ configuration ) { $ cacheDir = $ configuration [ 'module_listener_options' ] [ 'cache_dir' ] . '/docker' ; $ configDir = static :: getConfigDir ( ) ; $ hydratorDir = $ cacheDir . '/Doctrine/Hydrator' ; $ proxyDir = $ cacheDir . '/Doctrine/Proxy' ; if ( ! is_dir ( $ hydratorDir ) ) { mkdir ( $ hydratorDir , 0777 , true ) ; } if ( ! is_dir ( $ proxyDir ) ) { mkdir ( $ proxyDir , 0777 , true ) ; } return [ 'module_listener_options' => [ 'cache_dir' => $ cacheDir , 'config_glob_paths' => [ $ configDir . '/autoload/*.docker.php' , ] ] , 'doctrine' => [ 'configuration' => [ 'odm_default' => [ 'hydrator_dir' => $ hydratorDir , 'proxy_dir' => $ proxyDir , ] ] ] ] ; }
6916	public function removeAttachment ( AttachmentInterface $ attachment ) { if ( $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> removeElement ( $ attachment ) ; } return $ this ; }
2031	public static function findParentsById ( $ intId ) { $ arrModels = array ( ) ; while ( $ intId > 0 && ( $ objPage = static :: findByPk ( $ intId ) ) !== null ) { $ intId = $ objPage -> pid ; $ arrModels [ ] = $ objPage ; } if ( empty ( $ arrModels ) ) { return null ; } return static :: createCollection ( $ arrModels , 'tl_page' ) ; }
5921	public function getProperty ( $ systemName ) { foreach ( $ this -> propertySets as $ propertySet ) { foreach ( $ propertySet -> getProperties ( ) as $ property ) { if ( $ property -> getPropertyType ( ) -> getSystemName ( ) == $ systemName ) { return $ property ; } } } throw new PropertyNotFoundException ( 'No Property with the system name "' . $ systemName . '" exists.' ) ; }
7841	public function removeNumber ( int $ id , string $ number ) : ? array { $ response = Request :: delete ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
9431	public function routes ( ) { $ routes = array_merge ( $ this -> routes , $ this -> collector -> getData ( ) ) ; return function ( RouteCollector $ collector ) use ( $ routes ) { foreach ( array_filter ( $ routes ) as $ route ) { list ( $ method , $ uri , $ handler ) = ( array ) $ route ; $ collector -> addRoute ( $ method , $ uri , $ handler ) ; } } ; }
5509	public function expect ( $ method , $ args , $ message = '%s' ) { $ this -> dieOnNoMethod ( $ method , 'set expected arguments' ) ; $ this -> checkArgumentsIsArray ( $ args , 'set expected arguments' ) ; $ this -> expectations -> expectArguments ( $ method , $ args , $ message ) ; $ args = $ this -> replaceWildcards ( $ args ) ; $ message .= Mock :: getExpectationLine ( ) ; $ this -> expected_args [ strtolower ( $ method ) ] = new ParametersExpectation ( $ args , $ message ) ; }
9494	private function formatSize ( $ bytes ) { $ kb = 1024 ; $ mb = $ kb * 1024 ; $ gb = $ mb * 1024 ; $ tb = $ gb * 1024 ; if ( ( $ bytes >= 0 ) && ( $ bytes < $ kb ) ) { return $ bytes . ' B' ; } elseif ( ( $ bytes >= $ kb ) && ( $ bytes < $ mb ) ) { return ceil ( $ bytes / $ kb ) . ' KB' ; } elseif ( ( $ bytes >= $ mb ) && ( $ bytes < $ gb ) ) { return ceil ( $ bytes / $ mb ) . ' MB' ; } elseif ( ( $ bytes >= $ gb ) && ( $ bytes < $ tb ) ) { return ceil ( $ bytes / $ gb ) . ' GB' ; } elseif ( $ bytes >= $ tb ) { return ceil ( $ bytes / $ tb ) . ' TB' ; } return $ bytes . ' B' ; }
9285	protected function compileFile ( $ lessPath , $ cssPath ) { $ options = array ( ) ; if ( $ this -> strictImports === true ) $ options [ ] = '--strict-imports' ; if ( $ this -> compression === self :: COMPRESSION_WHITESPACE ) $ options [ ] = '--compress' ; else if ( $ this -> compression === self :: COMPRESSION_YUI ) $ options [ ] = '--yui-compress' ; if ( $ this -> optimizationLevel !== false ) $ options [ ] = '-O' . $ this -> optimizationLevel ; if ( isset ( $ this -> rootPath ) ) $ options [ ] = '--rootpath ' . $ this -> rootPath ; if ( $ this -> relativeUrls === true ) $ options [ ] = '--relative-urls' ; $ nodePath = $ this -> nodePath ? '"' . $ this -> nodePath . '" ' : '' ; $ command = $ nodePath . '"' . $ this -> compilerPath . '" ' . implode ( ' ' , $ options ) . ' "' . $ lessPath . '" "' . $ cssPath . '" 2>&1' ; $ return = 0 ; $ output = array ( ) ; @ exec ( $ command , $ output , $ return ) ; switch ( $ return ) { case 2 : case 1 : $ output = preg_replace ( '/\[[0-9]+m/i' , '' , implode ( "\n" , $ output ) ) ; throw new CException ( 'Failed to compile file "' . $ lessPath . '" using command: ' . $ command . '. The error was: ' . $ output ) ; } }
12659	private function setExtraLanguagesOutdated ( $ name , $ content ) { foreach ( $ this -> extraLangs as $ lang ) { $ this -> getPageTexts ( $ lang ) ; $ this -> contents [ $ lang ] [ $ name ] [ 'outdated' ] = true ; if ( ! isset ( $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] ) ) { $ this -> contents [ $ lang ] [ $ name ] [ 'content' ] = $ content ; } $ this -> writeTextsToFile ( $ lang ) ; } }
3080	public static function isAssessmentSectionAdaptive ( AssessmentSection $ section , $ namespace = '' ) { if ( $ namespace === '' ) { $ namespace = CatService :: QTI_2X_ADAPTIVE_XML_NAMESPACE ; } $ isAdaptive = false ; if ( ( $ selection = $ section -> getSelection ( ) ) !== null && ( ( $ xmlExtension = $ selection -> getXml ( ) ) ) !== null ) { $ xpath = new \ DOMXPath ( $ xmlExtension ) ; $ xpath -> registerNamespace ( 'ais' , $ namespace ) ; if ( $ xpath -> query ( './/ais:adaptiveItemSelection' , $ xmlExtension ) -> length > 0 ) { $ isAdaptive = true ; } } return $ isAdaptive ; }
265	public function setLogger ( $ value ) { if ( is_string ( $ value ) || is_array ( $ value ) ) { $ value = Yii :: createObject ( $ value ) ; } $ this -> _logger = $ value ; $ this -> _logger -> dispatcher = $ this ; }
1325	public static function fromConsumerAndToken ( Consumer $ consumer , Token $ token = null , $ httpMethod , $ httpUrl , array $ parameters = [ ] , $ json = false ) { $ defaults = [ "oauth_version" => Request :: $ version , "oauth_nonce" => Request :: generateNonce ( ) , "oauth_timestamp" => time ( ) , "oauth_consumer_key" => $ consumer -> key ] ; if ( null !== $ token ) { $ defaults [ 'oauth_token' ] = $ token -> key ; } if ( $ json ) { $ parameters = $ defaults ; } else { $ parameters = array_merge ( $ defaults , $ parameters ) ; } return new Request ( $ httpMethod , $ httpUrl , $ parameters ) ; }
3553	protected function set ( $ key , $ value , $ group = 'default' ) { $ this -> setMetaKey ( $ key ) ; $ this -> setValue ( $ value ) ; $ this -> setMetaGroup ( $ group ) ; }
8264	protected function onOAuthError ( $ errorCode ) { $ errorCode = strlen ( $ errorCode > 100 ) ? substr ( $ errorCode , 0 , 100 ) : $ errorCode ; $ this -> logger -> notice ( "OAuth2 error response: code {code}, provider {provider}" , array ( "code" => $ errorCode , "provider" => get_class ( $ this -> provider ) , ) ) ; $ this -> session -> addFlash ( "error" , "The provider returned an error ($errorCode)" ) ; $ this -> picoAuth -> redirectToLogin ( ) ; }
10889	public function parse ( ) { list ( $ opt_str , $ long_opts , $ mapping ) = $ this -> getOptString ( ) ; $ opts = \ getopt ( $ opt_str , $ long_opts ) ; $ options = $ this -> mapOptions ( $ opts , $ mapping ) ; return new Dictionary ( $ options ) ; }
3222	function createShareableLink ( $ path ) { Path :: checkArg ( "path" , $ path ) ; $ response = $ this -> doPost ( $ this -> apiHost , $ this -> appendFilePath ( "1/shares" , $ path ) , array ( "short_url" => "false" , ) ) ; if ( $ response -> statusCode === 404 ) return null ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ j = RequestUtil :: parseResponseJson ( $ response -> body ) ; return self :: getField ( $ j , "url" ) ; }
255	public function beforeRun ( ) { $ event = new WidgetEvent ( ) ; $ this -> trigger ( self :: EVENT_BEFORE_RUN , $ event ) ; return $ event -> isValid ; }
3724	private function buildCacheService ( ContainerBuilder $ container , array $ config ) { if ( ! $ config [ 'enable_cache' ] ) { $ cache = $ container -> getDefinition ( 'metamodels.cache' ) ; $ cache -> setClass ( ArrayCache :: class ) ; $ cache -> setArguments ( [ ] ) ; $ container -> setParameter ( 'metamodels.cache_dir' , null ) ; return ; } $ container -> setParameter ( 'metamodels.cache_dir' , $ config [ 'cache_dir' ] ) ; }
3077	public function processOutput ( QtiRunnerServiceContext $ context ) { $ messages = [ ] ; $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; if ( is_array ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] ) ) { foreach ( $ channels [ self :: CHANNEL_TYPE_OUTPUT ] as $ outputChannelName => $ outputChannelClass ) { $ channel = $ this -> getChannel ( $ outputChannelName , self :: CHANNEL_TYPE_OUTPUT ) ; $ message = $ this -> processChannel ( $ channel , $ context ) ; if ( $ message !== null ) { $ messages [ ] = [ 'channel' => $ channel -> getName ( ) , 'message' => $ message , ] ; } } } return $ messages ; }
11308	public function entityFromBody ( $ body , $ entity ) { $ json = $ this -> decodeJson ( $ body ) ; return $ entity -> populate ( $ json ) ; }
1352	protected function notAllowed ( string $ resourceType , string $ fields ) : Collection { $ fields = collect ( explode ( ',' , $ fields ) ) ; if ( ! $ this -> allowed -> has ( $ resourceType ) ) { return $ fields ; } $ allowed = $ this -> allowed -> get ( $ resourceType ) ; if ( is_null ( $ allowed ) ) { return collect ( ) ; } $ allowed = collect ( ( array ) $ allowed ) ; return $ fields -> reject ( function ( $ value ) use ( $ allowed ) { return $ allowed -> contains ( $ value ) ; } ) ; }
1269	public function getSubscription ( $ name = null , $ beginDateTime = null , $ endDateTime = null , $ fileName = null , $ bookmark = null ) { if ( null !== $ beginDateTime ) { $ beginDateTime = $ this -> formatDateTime ( $ beginDateTime ) ; } if ( null !== $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( $ endDateTime ) ; } if ( null !== $ beginDateTime && null === $ endDateTime ) { $ endDateTime = $ this -> formatDateTime ( time ( ) ) ; } $ this -> name = $ name ; $ this -> beginDateTime = $ beginDateTime ; $ this -> endDateTime = $ endDateTime ; $ this -> fileName = $ fileName ; $ this -> bookmark = $ bookmark ; $ access = $ this -> createAccess ( ) ; $ request = $ this -> createRequest ( ) ; $ this -> response = $ this -> getRequest ( ) -> request ( $ access , $ request , $ this -> compileEndpointUrl ( self :: ENDPOINT ) ) ; $ response = $ this -> response -> getResponse ( ) ; if ( null === $ response ) { throw new Exception ( 'Failure (0): Unknown error' , 0 ) ; } if ( $ response -> Response -> ResponseStatusCode == 0 ) { throw new Exception ( "Failure ({$response->Response->Error->ErrorSeverity}): {$response->Response->Error->ErrorDescription}" , ( int ) $ response -> Response -> Error -> ErrorCode ) ; } else { if ( isset ( $ response -> Bookmark ) ) { $ this -> setBookmark ( ( string ) $ response -> Bookmark ) ; } else { $ this -> setBookmark ( null ) ; } return $ this -> formatResponse ( $ response ) ; } }
10188	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> name ) ) $ this -> name = $ xmlElement -> name ; if ( isset ( $ xmlElement -> active ) ) $ this -> active = $ xmlElement -> active ; if ( isset ( $ xmlElement -> anonymizable ) ) $ this -> anonymizable = $ xmlElement -> anonymizable ; if ( isset ( $ xmlElement -> description ) ) $ this -> description = $ xmlElement -> description ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> attributes ) ) { $ this -> attributes = array ( ) ; foreach ( $ xmlElement -> attributes -> children ( ) as $ xmlAttribute ) { $ attribute = array ( ) ; if ( isset ( $ xmlAttribute -> name ) ) $ attribute [ 'name' ] = trim ( $ xmlAttribute -> name ) ; if ( isset ( $ xmlAttribute -> datatype ) ) $ attribute [ 'datatype' ] = DataType :: getDataType ( $ xmlAttribute -> datatype ) ; if ( isset ( $ xmlAttribute -> description ) ) $ attribute [ 'description' ] = trim ( $ xmlAttribute -> description ) ; if ( isset ( $ xmlAttribute -> required ) ) $ attribute [ 'required' ] = $ xmlAttribute -> required ; array_push ( $ this -> attributes , $ attribute ) ; } } }
10254	public function getStreet ( ) { $ number = rand ( 100 , 9999 ) ; $ street_name = Street :: orderByRaw ( Database :: random ( ) ) -> first ( ) -> name ; return $ number . ' ' . $ street_name ; }
2535	public function getMessagesAndVersions ( ) { if ( empty ( $ this -> messagesAndVersions ) ) { $ this -> messagesAndVersions = WsdlAnalyser :: loadMessagesAndVersions ( $ this -> params -> wsdl ) ; } return $ this -> messagesAndVersions ; }
3191	public function timeout ( $ timeLimit , $ tags , $ target ) { $ duration = $ this -> compute ( $ tags , $ target ) ; return $ duration >= $ timeLimit ; }
2565	public function analyze ( SendResult $ response ) { $ analyzeResponse = new Result ( $ response ) ; $ domXpath = $ this -> makeDomXpath ( $ response -> responseXml ) ; $ queryAllErrorCodes = "//m:generalErrorGroup//m:errorNumber/m:errorDetails/m:errorCode" ; $ queryAllErrorMsg = "//m:generalErrorGroup/m:genrealErrorText/m:freeText" ; $ errorCodeNodeList = $ domXpath -> query ( $ queryAllErrorCodes ) ; if ( $ errorCodeNodeList -> length > 0 ) { $ analyzeResponse -> status = Result :: STATUS_ERROR ; $ code = $ errorCodeNodeList -> item ( 0 ) -> nodeValue ; $ errorTextNodeList = $ domXpath -> query ( $ queryAllErrorMsg ) ; $ message = $ this -> makeMessageFromMessagesNodeList ( $ errorTextNodeList ) ; $ analyzeResponse -> messages [ ] = new Result \ NotOk ( $ code , trim ( $ message ) ) ; } return $ analyzeResponse ; }
3547	public function boot ( ) { $ this -> loadViewsFrom ( realpath ( __DIR__ . '/../views' ) , 'entrust-gui' ) ; $ this -> setupRoutes ( $ this -> app -> router ) ; $ this -> loadTranslationsFrom ( realpath ( __DIR__ . '/../translations' ) , 'entrust-gui' ) ; $ this -> publishes ( [ __DIR__ . '/../config/entrust-gui.php' => config_path ( 'entrust-gui.php' ) ] , 'config' ) ; $ this -> publishes ( [ __DIR__ . '/../views' => base_path ( 'resources/views/vendor/entrust-gui' ) ] , 'views' ) ; $ this -> publishes ( [ __DIR__ . '/../translations' => base_path ( 'resources/lang/vendor/entrust-gui' ) ] , 'translations' ) ; $ this -> commands ( 'command.entrust-gui.models' ) ; }
12734	public function unregister ( Listener $ register ) { $ id = $ register -> id ; $ success = false ; if ( isset ( $ this -> _byId [ $ id ] ) ) { unset ( $ this -> _byId [ $ id ] ) ; $ success = true ; } foreach ( $ this -> _bySignal as $ signal => $ reg ) { if ( isset ( $ reg [ $ id ] ) ) { unset ( $ this -> _bySignal [ $ signal ] [ $ id ] ) ; } } return $ success ; }
11171	public function getFilters ( $ columnDescriptions = [ ] , $ activeFieldName = false ) { $ filters = [ ] ; if ( count ( $ this -> filtersArray ) > 0 ) { foreach ( $ this -> filtersArray as $ key => $ value ) { if ( isset ( $ this -> filters [ $ key ] ) ) { $ activeFieldName = $ activeFieldName ? : $ this -> filtersArray [ 'orderBy' ] ; $ friendlyFieldName = isset ( $ columnDescriptions [ $ activeFieldName ] ) ? $ columnDescriptions [ $ activeFieldName ] : $ activeFieldName ; $ filters [ ] = sprintf ( $ this -> filters [ $ key ] , $ friendlyFieldName , $ value ) ; } } } return $ filters ; }
8741	protected function i18nDeleteQuery ( $ withGlobalScopes = true ) { $ subQuery = $ withGlobalScopes ? $ this -> toBase ( ) : $ this -> getQuery ( ) ; $ subQuery -> select ( $ this -> model -> getQualifiedKeyName ( ) ) ; return $ this -> i18nQuery ( ) -> whereIn ( $ this -> model -> getForeignKey ( ) , $ subQuery -> pluck ( $ this -> model -> getKeyName ( ) ) ) ; }
5973	public function events ( ) { if ( ! $ this -> events instanceof EventsController ) { $ this -> events = new EventsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> events -> setLogger ( $ this -> logger ) ; } return $ this -> events ; }
10145	private function makeKey ( $ block , $ valContext ) { $ pwarray = str_repeat ( "\0" , 64 ) ; for ( $ i = 0 ; $ i < 5 ; ++ $ i ) { $ pwarray [ $ i ] = $ valContext [ $ i ] ; } $ pwarray [ 5 ] = chr ( $ block & 0xff ) ; $ pwarray [ 6 ] = chr ( ( $ block >> 8 ) & 0xff ) ; $ pwarray [ 7 ] = chr ( ( $ block >> 16 ) & 0xff ) ; $ pwarray [ 8 ] = chr ( ( $ block >> 24 ) & 0xff ) ; $ pwarray [ 9 ] = "\x80" ; $ pwarray [ 56 ] = "\x48" ; $ md5 = new Xls \ MD5 ( ) ; $ md5 -> add ( $ pwarray ) ; $ s = $ md5 -> getContext ( ) ; return new Xls \ RC4 ( $ s ) ; }
11924	public function onPermalinkChanged ( PermalinkChangedEvent $ event ) { $ previousPermalink = $ event -> getOriginalText ( ) ; $ newPermalink = $ event -> getChangedText ( ) ; $ this -> updatePermalinkOnBlocks ( $ previousPermalink , $ newPermalink ) ; $ this -> updateHomepagePermalink ( $ previousPermalink , $ newPermalink ) ; }
10037	function createCustomField ( $ name , $ type = 'string' ) { $ queryParameters = array ( 'type' => $ type ) ; $ encodedName = urlencode ( mb_convert_encoding ( $ name , "UTF-8" ) ) ; return $ this -> post ( "contacts/fields/custom/${encodedName}" , "" , $ queryParameters ) ; }
10566	protected function formatJsonp ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/javascript; charset=UTF-8' ) ; if ( is_array ( $ response -> data ) && isset ( $ response -> data [ 'data' ] , $ response -> data [ 'callback' ] ) ) { $ response -> content = sprintf ( '%s(%s);' , $ response -> data [ 'callback' ] , Json :: htmlEncode ( $ response -> data [ 'data' ] ) ) ; } elseif ( $ response -> data !== null ) { $ response -> content = '' ; Yii :: warning ( "The 'jsonp' response requires that the data be an array consisting of both 'data' and 'callback' elements." , __METHOD__ ) ; } }
6031	public function addself ( $ item ) { if ( ! ( $ item instanceof self ) ) { if ( is_array ( $ item ) ) { try { $ item = new self ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate self. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "self"!' , E_USER_WARNING ) ; } } $ this -> childMedias [ ] = $ item ; return $ this ; }
3374	protected function getFilename ( $ filename ) { $ callback = $ this -> fileCallback ; if ( null === $ callback || substr ( $ filename , 0 , 1 ) == '/' ) { return $ filename ; } return $ callback ( $ filename ) ; }
10415	public function updateTable ( $ connection = null ) { $ connection = $ connection ? : $ this -> connection ; $ schemaManager = $ connection -> getSchemaManager ( ) ; if ( ! $ schemaManager -> tablesExist ( [ $ this -> tableName ] ) ) { return false ; } $ table = new Table ( $ this -> tableName ) ; $ this -> buildTable ( $ table ) ; $ oldTable = $ schemaManager -> listTableDetails ( $ this -> tableName ) ; $ comparator = new Comparator ( ) ; $ diff = $ comparator -> diffTable ( $ oldTable , $ table ) ; if ( ! $ diff ) { return null ; } $ schemaManager -> alterTable ( $ diff ) ; return true ; }
4546	public function setIncludeAssignedTasks ( ? bool $ includeAssignedTasks ) { $ this -> includeAssignedTasks = $ includeAssignedTasks ; $ this -> _includeAssignedTasks = null !== $ includeAssignedTasks ; return $ this ; }
371	public function isColorEnabled ( $ stream = \ STDOUT ) { return $ this -> color === null ? Console :: streamSupportsAnsiColors ( $ stream ) : $ this -> color ; }
6212	protected function array2Node ( $ parentNode , $ key , $ params ) { if ( count ( $ params ) == 0 ) { return ; } $ node = $ parentNode -> addChild ( $ key ) ; foreach ( $ params as $ key => $ value ) { if ( is_array ( $ value ) || is_object ( $ value ) ) { $ value = json_encode ( ( array ) $ value ) ; } $ node -> addChild ( 'var' , htmlspecialchars ( $ value ) ) -> addAttribute ( 'key' , $ key ) ; } }
12075	public function childShow ( FilterRequest $ filters , $ id , $ idChild , $ relation ) { $ id = $ this -> getRealId ( $ id ) ; $ idChild = $ this -> getRealId ( $ idChild ) ; $ resource = $ this -> repository -> getChild ( $ id , $ relation , $ idChild , $ filters ) ; if ( ! $ resource ) { } return $ this -> success ( $ resource ) ; }
9124	private function appendPayloadToRequest ( MemoryStream $ ms ) : MemoryStream { $ this -> payload -> reset ( ) ; while ( $ this -> payload -> ready ( ) ) { $ ms -> write ( $ this -> payload -> read ( 1024 ) ) ; } $ ms -> reset ( ) ; return $ ms ; }
5439	public function addPattern ( $ pattern , $ mode = 'accept' ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern ) ; if ( ! isset ( $ this -> mode_handlers [ $ mode ] ) ) { $ this -> mode_handlers [ $ mode ] = $ mode ; } }
353	public static function escapeJsRegularExpression ( $ regexp ) { $ pattern = preg_replace ( '/\\\\x\{?([0-9a-fA-F]+)\}?/' , '\u$1' , $ regexp ) ; $ deliminator = substr ( $ pattern , 0 , 1 ) ; $ pos = strrpos ( $ pattern , $ deliminator , 1 ) ; $ flag = substr ( $ pattern , $ pos + 1 ) ; if ( $ deliminator !== '/' ) { $ pattern = '/' . str_replace ( '/' , '\\/' , substr ( $ pattern , 1 , $ pos - 1 ) ) . '/' ; } else { $ pattern = substr ( $ pattern , 0 , $ pos + 1 ) ; } if ( ! empty ( $ flag ) ) { $ pattern .= preg_replace ( '/[^igmu]/' , '' , $ flag ) ; } return $ pattern ; }
9402	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -t {$options['title']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -m {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ pathInfo = pathinfo ( $ options [ 'image' ] ) ; if ( isset ( $ pathInfo [ 'extension' ] ) ) { $ command .= " --image {$options['image']}" ; } else { $ command .= " -a {$options['image']}" ; } } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " --url {$options['url']}" ; } if ( isset ( $ options [ 'sticky' ] ) && $ options [ 'sticky' ] === true ) { $ command .= ' -s' ; } return $ command ; }
3871	protected function getLanguage ( $ singleLanguage , $ metaModels ) { if ( ! empty ( $ singleLanguage ) ) { return array ( $ singleLanguage ) ; } elseif ( $ metaModels -> isTranslated ( ) && $ metaModels -> getAvailableLanguages ( ) ) { return $ metaModels -> getAvailableLanguages ( ) ; } return array ( $ GLOBALS [ 'TL_LANGUAGE' ] ) ; }
11902	public function cache ( ContentfulAsset $ asset ) { if ( ! isset ( $ asset -> file ) ) { $ this -> log ( 'Asset %s has no file.' , $ asset ) ; return ; } foreach ( $ asset -> file as $ locale => $ file ) { if ( ! $ file ) { $ this -> log ( 'Asset %s contains unpublished file for %s.' , $ asset , $ locale ) ; continue ; } $ localFile = $ this -> getLocalFile ( $ asset , $ locale ) ; if ( $ localFile -> isFile ( ) ) { continue ; } $ this -> log ( 'Caching "%s" file for asset "%s" as "%s" ...' , $ locale , $ asset -> getId ( ) , $ localFile -> getPathname ( ) ) ; $ dir = new \ SplFileInfo ( $ localFile -> getPath ( ) ) ; if ( ! $ dir -> isWritable ( ) ) { throw new RuntimeException ( sprintf ( 'Target directory "%s" is not writeable!' , $ localFile -> getPath ( ) ) ) ; } copy ( str_replace ( '//' , 'https://' , $ file [ 'url' ] ) , $ localFile -> getPathname ( ) ) ; $ size = filesize ( $ localFile -> getPathname ( ) ) ; $ this -> log ( '%d bytes saved.' , $ size ) ; } }
7169	public function resolveSaleTaxRule ( SaleInterface $ sale ) : ? TaxRuleInterface { return $ this -> resolveTaxRule ( $ this -> resolveTargetCountry ( $ sale ) , $ sale -> isBusiness ( ) ) ; }
10285	public static function columnIndexFromString ( $ pString ) { static $ indexCache = [ ] ; if ( isset ( $ indexCache [ $ pString ] ) ) { return $ indexCache [ $ pString ] ; } static $ columnLookup = [ 'A' => 1 , 'B' => 2 , 'C' => 3 , 'D' => 4 , 'E' => 5 , 'F' => 6 , 'G' => 7 , 'H' => 8 , 'I' => 9 , 'J' => 10 , 'K' => 11 , 'L' => 12 , 'M' => 13 , 'N' => 14 , 'O' => 15 , 'P' => 16 , 'Q' => 17 , 'R' => 18 , 'S' => 19 , 'T' => 20 , 'U' => 21 , 'V' => 22 , 'W' => 23 , 'X' => 24 , 'Y' => 25 , 'Z' => 26 , 'a' => 1 , 'b' => 2 , 'c' => 3 , 'd' => 4 , 'e' => 5 , 'f' => 6 , 'g' => 7 , 'h' => 8 , 'i' => 9 , 'j' => 10 , 'k' => 11 , 'l' => 12 , 'm' => 13 , 'n' => 14 , 'o' => 15 , 'p' => 16 , 'q' => 17 , 'r' => 18 , 's' => 19 , 't' => 20 , 'u' => 21 , 'v' => 22 , 'w' => 23 , 'x' => 24 , 'y' => 25 , 'z' => 26 , ] ; if ( isset ( $ pString [ 0 ] ) ) { if ( ! isset ( $ pString [ 1 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 2 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 26 + $ columnLookup [ $ pString [ 1 ] ] ; return $ indexCache [ $ pString ] ; } elseif ( ! isset ( $ pString [ 3 ] ) ) { $ indexCache [ $ pString ] = $ columnLookup [ $ pString [ 0 ] ] * 676 + $ columnLookup [ $ pString [ 1 ] ] * 26 + $ columnLookup [ $ pString [ 2 ] ] ; return $ indexCache [ $ pString ] ; } } throw new Exception ( 'Column string index can not be ' . ( ( isset ( $ pString [ 0 ] ) ) ? 'longer than 3 characters' : 'empty' ) ) ; }
5108	private function appendDesc ( & $ column ) : void { if ( is_array ( $ column ) ) { foreach ( $ column as & $ col ) { $ col = "$col DESC" ; } } else { $ column = [ "$column DESC" ] ; } }
11872	protected function _setDataKey ( $ key ) { if ( ! is_null ( $ key ) && ! is_string ( $ key ) && ! ( $ key instanceof Stringable ) ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Data key must be a string or stringable' ) , 0 , null , $ key ) ; } $ this -> dataKey = $ key ; return $ this ; }
595	private function deletePublishedAssets ( $ bundles ) { $ this -> stdout ( "Deleting source files...\n" ) ; if ( $ this -> getAssetManager ( ) -> linkAssets ) { $ this -> stdout ( "`AssetManager::linkAssets` option is enabled. Deleting of source files canceled.\n" , Console :: FG_YELLOW ) ; return ; } foreach ( $ bundles as $ bundle ) { if ( $ bundle -> sourcePath !== null ) { foreach ( $ bundle -> js as $ jsFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ jsFile ) ; } foreach ( $ bundle -> css as $ cssFile ) { @ unlink ( $ bundle -> basePath . DIRECTORY_SEPARATOR . $ cssFile ) ; } } } $ this -> stdout ( "Source files deleted.\n" , Console :: FG_GREEN ) ; }
8176	public function actionRecoverPassword ( ) { $ model = new AccountRecoverPasswordForm ( ) ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) ) { if ( $ model -> validate ( ) ) { $ model -> recoverPassword ( ) ; } } return $ this -> render ( 'recoverPassword' , [ 'model' => $ model ] ) ; }
2345	public function truncate ( ) { if ( \ is_resource ( $ this -> resFile ) ) { ftruncate ( $ this -> resFile , 0 ) ; rewind ( $ this -> resFile ) ; } return $ this -> write ( '' ) ; }
2410	public function getDbInstallerArray ( ) { $ return = array ( ) ; foreach ( $ this -> arrFields as $ k => $ v ) { if ( \ is_array ( $ v ) ) { if ( ! isset ( $ v [ 'name' ] ) ) { $ v [ 'name' ] = $ k ; } $ return [ 'SCHEMA_FIELDS' ] [ $ k ] = $ v ; } else { $ return [ 'TABLE_FIELDS' ] [ $ k ] = '`' . $ k . '` ' . $ v ; } } $ quote = function ( $ item ) { return '`' . $ item . '`' ; } ; foreach ( $ this -> arrKeys as $ k => $ v ) { if ( strpos ( $ k , ',' ) !== false ) { $ f = array_map ( $ quote , StringUtil :: trimsplit ( ',' , $ k ) ) ; $ k = str_replace ( ',' , '_' , $ k ) ; } else { $ f = array ( $ quote ( $ k ) ) ; } if ( $ v == 'primary' ) { $ k = 'PRIMARY' ; $ v = 'PRIMARY KEY (' . implode ( ', ' , $ f ) . ')' ; } elseif ( $ v == 'index' ) { $ v = 'KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } else { $ v = strtoupper ( $ v ) . ' KEY `' . $ k . '` (' . implode ( ', ' , $ f ) . ')' ; } $ return [ 'TABLE_CREATE_DEFINITIONS' ] [ $ k ] = $ v ; } $ return [ 'TABLE_OPTIONS' ] = '' ; foreach ( $ this -> arrMeta as $ k => $ v ) { if ( $ k == 'engine' ) { $ return [ 'TABLE_OPTIONS' ] .= ' ENGINE=' . $ v ; } elseif ( $ k == 'charset' ) { $ return [ 'TABLE_OPTIONS' ] .= ' DEFAULT CHARSET=' . $ v ; } elseif ( $ k == 'collate' ) { $ return [ 'TABLE_OPTIONS' ] .= ' COLLATE ' . $ v ; } } return $ return ; }
4421	public function generate ( InputInterface $ input , OutputInterface $ output ) { $ fileSystem = $ this -> container -> get ( 'filesystem' ) ; $ legacyRootDir = $ this -> container -> getParameter ( 'ezpublish_legacy.root_dir' ) ; $ siteAccessName = $ input -> getOption ( 'site-access-name' ) ; $ languageCode = $ input -> getOption ( 'language-code' ) ; $ siteAccessLocation = $ legacyRootDir . '/settings/siteaccess/' . $ siteAccessName ; $ skeletonDir = __DIR__ . '/../_templates/legacy_siteaccess' ; if ( $ fileSystem -> exists ( $ siteAccessLocation ) ) { if ( ! $ this -> questionHelper -> ask ( $ input , $ output , new ConfirmationQuestion ( '<info><comment>' . $ siteAccessName . '</comment> legacy siteaccess already exists. Do you want to overwrite it?</info> [<comment>no</comment>] ' , false ) ) ) { return ; } } $ fileSystem -> remove ( $ siteAccessLocation ) ; $ languageService = $ this -> container -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; $ relatedSiteAccessList = $ this -> container -> getParameter ( 'ezpublish.siteaccess.list' ) ; $ relatedSiteAccessList [ ] = $ siteAccessName ; $ availableLocales = array_map ( function ( Language $ language ) { return $ language -> languageCode ; } , $ languageService -> loadLanguages ( ) ) ; $ availableLocales = array_values ( array_diff ( $ availableLocales , array ( $ languageCode ) ) ) ; $ siteLanguageList = array_merge ( array ( $ languageCode ) , $ availableLocales ) ; $ translationList = implode ( ';' , $ availableLocales ) ; $ fileSystem -> mirror ( $ skeletonDir , $ siteAccessLocation ) ; $ this -> setSkeletonDirs ( $ siteAccessLocation ) ; $ this -> renderFile ( 'site.ini.append.php' , $ siteAccessLocation . '/site.ini.append.php' , array ( 'relatedSiteAccessList' => $ relatedSiteAccessList , 'siteAccessLocale' => $ languageCode , 'siteLanguageList' => $ siteLanguageList , 'translationList' => $ translationList , ) ) ; $ output -> writeln ( array ( '' , 'Generated <comment>' . $ siteAccessName . '</comment> legacy siteaccess!' , '' , ) ) ; }
11755	public function markElect ( $ msgId , $ index , $ commentId ) { $ params = [ 'msg_data_id' => $ msgId , 'index' => $ index , 'user_comment_id' => $ commentId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MARK_ELECT , $ params ] ) ; }
893	private function getTypesContent ( ) { if ( null === $ this -> typesContent ) { $ name = $ this -> getTag ( ) -> getName ( ) ; if ( ! $ this -> supportTypes ( ) ) { throw new \ RuntimeException ( 'This tag does not support types.' ) ; } $ matchingResult = Preg :: match ( '{^(?:\s*\*|/\*\*)\s*@' . $ name . '\s+' . self :: REGEX_TYPES . '(?:[ \t].*)?$}sx' , $ this -> lines [ 0 ] -> getContent ( ) , $ matches ) ; $ this -> typesContent = 1 === $ matchingResult ? $ matches [ 'types' ] : '' ; } return $ this -> typesContent ; }
6104	public function wait ( ) { if ( $ this -> getTransport ( ) -> getConfig ( "blocking" ) ) { throw new Ts3Exception ( "only available in non-blocking mode" ) ; } do { $ evt = $ this -> getTransport ( ) -> readLine ( ) ; var_dump ( $ evt ) ; } while ( $ evt instanceof StringHelper && ! $ evt -> section ( TeamSpeak3 :: SEPARATOR_CELL ) -> startsWith ( TeamSpeak3 :: EVENT ) ) ; return new Event ( $ evt , $ this -> getHost ( ) ) ; }
11619	public function site ( ) : \ TheCMSThread \ Core \ Main \ Site { static $ site ; if ( $ site === null ) { $ site = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\Site" ) ; } return $ site ; }
771	public function actionConfig ( $ filePath ) { $ filePath = Yii :: getAlias ( $ filePath ) ; $ dir = dirname ( $ filePath ) ; if ( file_exists ( $ filePath ) ) { if ( ! $ this -> confirm ( "File '{$filePath}' already exists. Do you wish to overwrite it?" ) ) { return ExitCode :: OK ; } } $ array = VarDumper :: export ( $ this -> getOptionValues ( $ this -> action -> id ) ) ; $ content = <<<EOD<?php/** * Configuration file for 'yii {$this->id}/{$this->defaultAction}' command. * * This file is automatically generated by 'yii {$this->id}/{$this->action->id}' command. * It contains parameters for source code messages extraction. * You may modify this file to suit your needs. * * You can use 'yii {$this->id}/{$this->action->id}-template' command to create * template configuration file with detailed description for each parameter. */return $array;EOD ; if ( FileHelper :: createDirectory ( $ dir ) === false || file_put_contents ( $ filePath , $ content , LOCK_EX ) === false ) { $ this -> stdout ( "Configuration file was NOT created: '{$filePath}'.\n\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "Configuration file created: '{$filePath}'.\n\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; }
8965	public function rewriteCountQuery ( $ query ) { if ( \ preg_match ( '/^\s*SELECT\s+\bDISTINCT\b/is' , $ query ) || \ preg_match ( '/\s+GROUP\s+BY\s+/is' , $ query ) ) { return '' ; } $ openParenthesis = '(?:\()' ; $ closeParenthesis = '(?:\))' ; $ subQueryInSelect = $ openParenthesis . '.*\bFROM\b.*' . $ closeParenthesis ; $ pattern = '/(?:.*' . $ subQueryInSelect . '.*)\bFROM\b\s+/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ subQueryWithLimitOrder = $ openParenthesis . '.*\b(LIMIT|ORDER)\b.*' . $ closeParenthesis ; $ pattern = '/.*\bFROM\b.*(?:.*' . $ subQueryWithLimitOrder . '.*).*/Uims' ; if ( \ preg_match ( $ pattern , $ query ) ) { return '' ; } $ queryCount = \ preg_replace ( '/(?:.*)\bFROM\b\s+/Uims' , 'SELECT COUNT(*) FROM ' , $ query , 1 ) ; list ( $ queryCount ) = \ preg_split ( '/\s+ORDER\s+BY\s+/is' , $ queryCount ) ; list ( $ queryCount ) = \ preg_split ( '/\bLIMIT\b/is' , $ queryCount ) ; return \ trim ( $ queryCount ) ; }
10318	function getBlocks ( $ fromDate = null , $ toDate = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ reasons = null , $ oldStatus = null , $ newStatus = null , $ excludeAnonymousBlocks = false , $ standardFields = null , $ customFields = null , $ pageIndex = 1 , $ pageSize = 100 ) { $ params = $ this -> createQueryParameters ( $ pageIndex , $ pageSize , $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , null , null , null ) ; $ params = $ this -> appendArrayFields ( $ params , "standard_field" , $ standardFields ) ; $ params = $ this -> appendArrayFields ( $ params , "custom_field" , $ customFields ) ; if ( isset ( $ embedEmailClientInfos ) ) $ params [ 'embed_email_client_infos' ] = ( $ embedEmailClientInfos == true ) ? "true" : "false" ; if ( isset ( $ excludeAnonymousBlocks ) ) $ params [ 'exclude_anonymous_blocks' ] = ( $ excludeAnonymousBlocks == true ) ? "true" : "false" ; $ params = $ this -> appendArrayFields ( $ params , "reasons" , $ reasons ) ; if ( isset ( $ oldStatus ) ) $ params [ 'old_status' ] = $ oldStatus ; if ( isset ( $ newStatus ) ) $ params [ 'new_status' ] = $ newStatus ; return $ this -> get ( 'reports/blocks' , $ params ) ; }
2572	protected function loadSessionHandler ( $ params ) { if ( isset ( $ params [ 'sessionHandler' ] ) && $ params [ 'sessionHandler' ] instanceof Session \ Handler \ HandlerInterface ) { $ this -> sessionHandler = $ params [ 'sessionHandler' ] ; } }
1023	private function executeOperation ( OperationDefinitionNode $ operation , $ rootValue ) { $ type = $ this -> getOperationRootType ( $ this -> exeContext -> schema , $ operation ) ; $ fields = $ this -> collectFields ( $ type , $ operation -> selectionSet , new ArrayObject ( ) , new ArrayObject ( ) ) ; $ path = [ ] ; try { $ result = $ operation -> operation === 'mutation' ? $ this -> executeFieldsSerially ( $ type , $ rootValue , $ path , $ fields ) : $ this -> executeFields ( $ type , $ rootValue , $ path , $ fields ) ; if ( $ this -> isPromise ( $ result ) ) { return $ result -> then ( null , function ( $ error ) { $ this -> exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ result ; } catch ( Error $ error ) { $ this -> exeContext -> addError ( $ error ) ; return null ; } }
5643	public function makeDry ( $ is_dry = true ) { $ numberOfReporters = count ( $ this -> reporters ) ; for ( $ i = 0 ; $ i < $ numberOfReporters ; $ i ++ ) { $ this -> reporters [ $ i ] -> makeDry ( $ is_dry ) ; } }
8261	protected function saveAfterLogin ( Request $ httpRequest ) { $ referer = $ httpRequest -> headers -> get ( "referer" , null , true ) ; $ afterLogin = Utils :: getRefererQueryParam ( $ referer , "afterLogin" ) ; if ( $ afterLogin && Utils :: isValidPageId ( $ afterLogin ) ) { $ this -> session -> set ( "afterLogin" , $ afterLogin ) ; } }
6520	private function populateDefault ( Field $ field ) { if ( $ this -> has ( $ field -> getName ( ) ) ) { return true ; } $ default = $ field -> getDefault ( $ this ) ; if ( null === $ default ) { return false ; } if ( $ field -> isASingleValue ( ) ) { $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; } if ( empty ( $ default ) ) { return false ; } if ( $ field -> isASet ( ) ) { $ this -> addToSet ( $ field -> getName ( ) , $ default ) ; return true ; } $ this -> data [ $ field -> getName ( ) ] = $ default ; unset ( $ this -> clearedFields [ $ field -> getName ( ) ] ) ; return true ; }
10989	protected function _setData ( $ key , $ value ) { $ store = $ this -> _getDataStore ( ) ; try { $ this -> _containerSet ( $ store , $ key , $ value ) ; } catch ( InvalidArgumentException $ e ) { throw $ this -> _createOutOfRangeException ( $ this -> __ ( 'Invalid store' ) , null , $ e , $ store ) ; } catch ( OutOfRangeException $ e ) { throw $ this -> _createInvalidArgumentException ( $ this -> __ ( 'Invalid key' ) , null , $ e , $ store ) ; } }
10409	protected function getUrlsByDocumentParameter ( ) { if ( count ( $ this -> documentParamCache ) < 1 ) { return [ ] ; } $ urls = [ ] ; $ query = new Query ( ) ; $ queryTerms = [ ] ; foreach ( $ this -> documentParamCache as $ param ) { $ queryTerms [ $ param [ 0 ] ] [ ] = $ param [ 1 ] ; } foreach ( $ queryTerms as $ field => $ values ) { $ termQuery = new TermQuery ( $ field , $ values ) ; $ query -> addQuery ( $ termQuery , 'should' ) ; } $ limitFilter = new LimitFilter ( count ( $ this -> documentParamCache ) ) ; $ repository = $ this -> manager -> getRepository ( 'MultiModel' ) ; $ search = $ repository -> createSearch ( ) -> addQuery ( $ query ) -> addFilter ( $ limitFilter ) ; $ documents = $ repository -> execute ( $ search ) ; foreach ( $ documents as $ document ) { if ( is_array ( $ document -> url ) ) { foreach ( $ document -> url as $ url ) { $ urls [ ] = $ url [ 'url' ] ; } } } array_walk ( $ urls , [ $ this , 'addWildcard' ] ) ; $ this -> addUrls ( $ urls ) ; return $ urls ; }
4539	public function setIndividualUuid ( ? string $ individualUuid ) { $ this -> individualUuid = $ individualUuid ; $ this -> _individualUuid = true ; return $ this ; }
10521	protected function buildTblConst ( ) { $ result = $ this -> buildCol ( ) ; if ( isset ( $ this -> tbl_constraint [ 'primary' ] ) ) { $ p = $ this -> tbl_constraint [ 'primary' ] ; $ result [ ] = 'PRIMARY KEY (' . join ( ', ' , $ this -> quoteIndex ( $ p [ 0 ] ) ) . ')' . ( empty ( $ p [ 1 ] ) ? '' : " $p[1]" ) ; } if ( isset ( $ this -> tbl_constraint [ 'unique' ] ) ) { foreach ( $ this -> tbl_constraint [ 'unique' ] as $ uniq ) { $ result [ ] = 'UNIQUE (' . join ( ', ' , $ this -> quoteIndex ( $ uniq [ 0 ] ) ) . ')' . ( empty ( $ uniq [ 1 ] ) ? '' : " $uniq[1]" ) ; } } if ( isset ( $ this -> tbl_constraint [ 'other' ] ) ) { foreach ( $ this -> tbl_constraint [ 'other' ] as $ const ) { $ result [ ] = $ const ; } } return $ result ; }
1913	protected function generateCaptcha ( ) { if ( $ this -> arrCaptcha ) { return ; } $ int1 = random_int ( 1 , 9 ) ; $ int2 = random_int ( 1 , 9 ) ; $ this -> arrCaptcha = array ( 'int1' => $ int1 , 'int2' => $ int2 , 'sum' => $ int1 + $ int2 , 'key' => $ this -> strCaptchaKey , 'hashes' => $ this -> generateHashes ( $ int1 + $ int2 ) ) ; }
3687	protected function getAttributeFromFilterOperation ( $ operation ) { $ attribute = null ; if ( ! empty ( $ operation [ 'property' ] ) ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ operation [ 'property' ] ) ; } if ( $ attribute === null ) { throw new \ InvalidArgumentException ( 'Attribute ' . $ operation [ 'property' ] . ' not found.' ) ; } return $ attribute ; }
8277	public function onConfigLoaded ( array & $ config ) { $ config [ self :: PLUGIN_NAME ] = $ this -> loadDefaultConfig ( $ config ) ; $ this -> config = $ config [ self :: PLUGIN_NAME ] ; $ this -> createContainer ( ) ; $ this -> initLogger ( ) ; }
12022	function addCheckScopeMethod ( ) { $ scopes = $ this -> operationDefinition -> getScopes ( ) ; if ( count ( $ scopes ) == 0 ) { return ; } $ methodGenerator = new MethodGenerator ( 'checkScopeRequirement' ) ; $ parameterGenerator = new ParameterGenerator ( 'allowedScopes' , 'array' ) ; $ methodGenerator -> setParameter ( $ parameterGenerator ) ; $ body = '//For each of the elements, all of the scopes in that element' . PHP_EOL ; $ body .= '//must be satisfied' . PHP_EOL ; $ body .= '$requiredScopesArray = [' . PHP_EOL ; foreach ( $ scopes as $ scopeList ) { $ body .= ' [' ; $ separator = '' ; foreach ( $ scopeList as $ scope ) { $ body .= sprintf ( "%s'%s'" , $ separator , $ scope ) ; $ separator = ', ' ; } $ body .= ']' . PHP_EOL ; } $ body .= '];' . PHP_EOL . PHP_EOL ; $ body .= <<< 'END'foreach($requiredScopesArray as $requiredScopes) { $requirementMet = true; foreach ($requiredScopes as $requiredScope) { if (in_array($requiredScope, $allowedScopes) == false) { $requirementMet = false; break; } } if ($requirementMet == true) { return true; }}return false;END ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
11740	public function exportAction ( ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ chillSecurityHelper = $ this -> get ( 'chill.main.security.authorization.helper' ) ; $ user = $ this -> get ( 'security.context' ) -> getToken ( ) -> getUser ( ) ; $ reachableCenters = $ chillSecurityHelper -> getReachableCenters ( $ user , new Role ( 'CHILL_PERSON_SEE' ) ) ; $ personRepository = $ em -> getRepository ( 'ChillPersonBundle:Person' ) ; $ qb = $ personRepository -> createQueryBuilder ( 'p' ) ; $ qb -> where ( $ qb -> expr ( ) -> in ( 'p.center' , ':centers' ) ) -> setParameter ( 'centers' , $ reachableCenters ) ; $ persons = $ qb -> getQuery ( ) -> getResult ( ) ; $ response = $ this -> render ( 'ChillPersonBundle:Person:export.csv.twig' , array ( 'persons' => $ persons , 'cf_group' => $ this -> getCFGroup ( ) ) ) ; $ response -> headers -> set ( 'Content-Type' , 'text/csv; charset=utf-8' ) ; $ response -> headers -> set ( 'Content-Disposition' , 'attachment; filename="export_person.csv"' ) ; return $ response ; }
9801	public static function setLibXmlLoaderOptions ( $ options ) { if ( $ options === null && defined ( 'LIBXML_DTDLOAD' ) ) { $ options = LIBXML_DTDLOAD | LIBXML_DTDATTR ; } self :: $ libXmlLoaderOptions = $ options ; }
4201	private function addMethodsMin ( Event $ abs ) { $ obj = $ abs -> getSubject ( ) ; if ( \ method_exists ( $ obj , '__toString' ) ) { $ abs [ 'methods' ] [ '__toString' ] = array ( 'returnValue' => \ call_user_func ( array ( $ obj , '__toString' ) ) , 'visibility' => 'public' , ) ; } if ( \ method_exists ( $ obj , '__get' ) ) { $ abs [ 'methods' ] [ '__get' ] = array ( 'visibility' => 'public' ) ; } if ( \ method_exists ( $ obj , '__set' ) ) { $ abs [ 'methods' ] [ '__set' ] = array ( 'visibility' => 'public' ) ; } return ; }
6979	private function getClient ( ) { if ( null !== $ this -> client ) { return $ this -> client ; } try { return $ this -> client = new \ SoapClient ( static :: ENDPOINT ) ; } catch ( \ SoapFault $ oExcept ) { if ( $ this -> debug ) { @ trigger_error ( 'Failed to connect to the europa web service: ' . $ oExcept -> getMessage ( ) ) ; } } return $ this -> client = null ; }
3531	public static function sendFortniteGetRequest ( $ endpoint , $ access_token , $ extra_headers = array ( ) ) { $ client = new Client ( ) ; $ headers = [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ; $ headers = array_merge ( $ headers , $ extra_headers ) ; try { $ response = $ client -> get ( $ endpoint , [ 'headers' => $ headers ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
7315	public function setDateTime ( $ year , $ month , $ day , $ hour , $ min , $ sec ) { return $ this -> setDate ( $ year , $ month , $ day ) -> setTime ( $ hour , $ min , $ sec ) ; }
4314	private function doGroup ( $ method , $ args ) { $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) ) ; $ this -> rootInstance -> groupStackRef [ ] = array ( 'channel' => $ meta [ 'channel' ] , 'collect' => $ this -> cfg [ 'collect' ] , ) ; if ( ! $ this -> cfg [ 'collect' ] ) { return ; } if ( empty ( $ args ) ) { $ caller = $ this -> utilities -> getCallerInfo ( ) ; if ( isset ( $ caller [ 'class' ] ) ) { $ args [ ] = $ caller [ 'class' ] . $ caller [ 'type' ] . $ caller [ 'function' ] ; $ meta [ 'isMethodName' ] = true ; } elseif ( isset ( $ caller [ 'function' ] ) ) { $ args [ ] = $ caller [ 'function' ] ; } else { $ args [ ] = 'group' ; } } $ this -> appendLog ( $ method , $ args , $ meta ) ; }
9750	public function _savePps ( & $ raList ) { $ iC = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iC ; ++ $ i ) { fwrite ( $ this -> fileHandle , $ raList [ $ i ] -> _getPpsWk ( ) ) ; } $ iCnt = count ( $ raList ) ; $ iBCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; if ( $ iCnt % $ iBCnt ) { fwrite ( $ this -> fileHandle , str_repeat ( "\x00" , ( $ iBCnt - ( $ iCnt % $ iBCnt ) ) * OLE :: OLE_PPS_SIZE ) ) ; } }
5819	private function createAlertsForType ( $ type , array $ messages ) { $ alerts = array ( ) ; foreach ( $ messages as $ msg ) { $ alerts [ ] = new Alert ( $ type , $ msg ) ; } return $ alerts ; }
7690	function OpenXML_ChartGetInfoFromFile ( $ idx , $ Txt = false ) { if ( $ idx === false ) return false ; $ file = $ this -> CdFileLst [ $ idx ] [ 'v_name' ] ; $ relative = ( substr_count ( $ file , '/' ) == 1 ) ? '' : '../' ; $ o = $ this -> OpenXML_Rels_GetObj ( $ file , $ relative . 'charts/' ) ; if ( $ o -> ChartLst === false ) { if ( $ Txt === false ) $ Txt = $ this -> TbsStoreGet ( $ idx , 'OpenXML_ChartGetInfoFromFile' ) ; $ o -> ChartLst = array ( ) ; $ p = 0 ; while ( $ t = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'c:chart' , $ p ) ) { $ rid = $ t -> GetAttLazy ( 'r:id' ) ; $ name = false ; $ title = false ; $ descr = false ; $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'wp:inline' , $ t -> PosBeg , false ) ; if ( $ parent === false ) $ parent = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'p:nvGraphicFramePr' , $ t -> PosBeg , false ) ; if ( $ parent !== false ) { $ parent -> FindEndTag ( ) ; $ src = $ parent -> GetInnerSrc ( ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'title' , 0 ) ; if ( $ el !== false ) $ title = $ el -> GetAttLazy ( 'title' ) ; $ el = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ src , 'descr' , 0 ) ; if ( $ el !== false ) $ descr = $ el -> GetAttLazy ( 'descr' ) ; } if ( isset ( $ o -> TargetLst [ $ rid ] ) ) { $ name = basename ( $ o -> TargetLst [ $ rid ] ) ; if ( substr ( $ name , - 4 ) === '.xml' ) $ name = substr ( $ name , 0 , strlen ( $ name ) - 4 ) ; } $ o -> ChartLst [ ] = array ( 'rid' => $ rid , 'title' => $ title , 'descr' => $ descr , 'name' => $ name ) ; $ p = $ t -> PosEnd ; } } return $ o -> ChartLst ; }
3119	public function fromArray ( $ data ) { $ this -> points = [ ] ; if ( is_array ( $ data ) ) { foreach ( $ data as $ dataPoint ) { $ point = new TimePoint ( ) ; $ point -> fromArray ( $ dataPoint ) ; $ this -> points [ ] = $ point ; } } }
2482	protected function generateQueryString ( array $ parameters ) { $ removedArrayCharacters = preg_replace ( '/%5B[0-9]+%5D=/' , '=' , http_build_query ( $ parameters ) ) ; $ removedDuplicatedEscapingForUrlPath = str_replace ( '%5C%5C%2F' , '%5C%2F' , $ removedArrayCharacters ) ; return $ removedDuplicatedEscapingForUrlPath ; }
417	public function getETags ( ) { if ( $ this -> headers -> has ( 'If-None-Match' ) ) { return preg_split ( '/[\s,]+/' , str_replace ( '-gzip' , '' , $ this -> headers -> get ( 'If-None-Match' ) ) , - 1 , PREG_SPLIT_NO_EMPTY ) ; } return [ ] ; }
1709	public function renderContaoBackendTemplate ( array $ blocks = [ ] ) : string { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( null === $ request || ! $ this -> scopeMatcher -> isBackendRequest ( $ request ) ) { return '' ; } $ controller = $ this -> framework -> createInstance ( BackendCustom :: class ) ; $ template = $ controller -> getTemplateObject ( ) ; foreach ( $ blocks as $ key => $ content ) { $ template -> { $ key } = $ content ; } $ response = $ controller -> run ( ) ; return $ response -> getContent ( ) ; }
9322	protected function registerMarkdownEnvironment ( ) { $ app = $ this -> app ; $ app -> singleton ( 'commonmark.environment' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'markdown' ] ; $ environment = Environment :: createCommonMarkEnvironment ( ) ; if ( $ config [ 'configurations' ] ) { $ environment -> mergeConfig ( $ config [ 'configurations' ] ) ; } foreach ( $ config [ 'extensions' ] as $ extension ) { if ( class_exists ( $ extension ) ) { $ environment -> addExtension ( new $ extension ( ) ) ; } } return $ environment ; } ) ; $ app -> alias ( 'commonmark.environment' , Environment :: class ) ; }
6938	private function find ( array & $ list , $ oid , StockUnitInterface $ unit ) { if ( ! isset ( $ list [ $ oid ] ) ) { return false ; } if ( null === $ unit -> getId ( ) ) { return array_search ( $ unit , $ list [ $ oid ] , true ) ; } foreach ( $ list [ $ oid ] as $ index => $ u ) { if ( $ u -> getId ( ) == $ unit -> getId ( ) ) { return $ index ; } } return false ; }
12245	public function sortChildren ( ) { $ nodes = $ this -> removeNodes ( '*' ) ; $ args = func_get_args ( ) ; array_unshift ( $ args , null ) ; $ args [ 0 ] = & $ nodes ; call_user_func_array ( array ( get_class ( $ this ) , 'sort' ) , $ args ) ; foreach ( $ nodes as $ node ) { $ this -> appendChild ( $ node ) ; } return $ this ; }
4856	public function setParams ( $ namespace , $ params ) { $ session = new Container ( $ namespace ) ; $ session -> params = $ params ; unset ( $ session -> list ) ; return $ this ; }
9578	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; if ( $ this -> materializeAsset ) { MaterializeAsset :: register ( $ view ) ; } if ( $ this -> customAsset ) { MaterializeCustomAsset :: register ( $ view ) ; } $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } $ this -> registerClientEvents ( ) ; }
4245	private function logPhpInfo ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.phpInfo' ) ) { return ; } $ this -> debug -> log ( 'PHP Version' , PHP_VERSION ) ; $ this -> debug -> log ( 'ini location' , \ php_ini_loaded_file ( ) ) ; $ this -> debug -> log ( 'memory_limit' , $ this -> debug -> utilities -> getBytes ( $ this -> debug -> utilities -> memoryLimit ( ) ) ) ; $ this -> debug -> log ( 'session.cache_limiter' , \ ini_get ( 'session.cache_limiter' ) ) ; if ( \ session_module_name ( ) === 'files' ) { $ this -> debug -> log ( 'session_save_path' , \ session_save_path ( ) ? : \ sys_get_temp_dir ( ) ) ; } $ extensionsCheck = array ( 'curl' , 'mbstring' ) ; $ extensionsCheck = \ array_filter ( $ extensionsCheck , function ( $ extension ) { return ! \ extension_loaded ( $ extension ) ; } ) ; if ( $ extensionsCheck ) { $ this -> debug -> warn ( 'These common extensions are not loaded:' , $ extensionsCheck ) ; } $ this -> logPhpInfoEr ( ) ; }
10419	public static function parse ( $ path ) { if ( ! file_exists ( $ path ) ) { throw new Exception ( 'The give file ' . $ path . ' doesn\'t exist.' ) ; } return Yaml :: parse ( file_get_contents ( $ path ) ) ; }
5358	protected function createParameters ( Operation $ operation , $ queryParamDocumentation , Context $ context ) { $ documentationParams = [ ] ; $ methodParameters = [ ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ methodParameters [ ] = $ this -> pathParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> pathParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ key => $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof BodyParameter ) { $ methodParameters [ ] = $ this -> bodyParameterGenerator -> generateMethodParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ; $ documentationParams [ ] = sprintf ( ' * @param %s' , $ this -> bodyParameterGenerator -> generateDocParameter ( $ parameter , $ context , $ operation -> getReference ( ) . '/parameters/' . $ key ) ) ; } } } if ( ! empty ( $ queryParamDocumentation ) ) { $ documentationParams [ ] = " * @param array \$parameters {" ; $ documentationParams = array_merge ( $ documentationParams , array_map ( function ( $ doc ) { return " * " . $ doc ; } , $ queryParamDocumentation ) ) ; $ documentationParams [ ] = " * }" ; } else { $ documentationParams [ ] = " * @param array \$parameters List of parameters" ; } $ documentationParams [ ] = " * @param string \$fetch Fetch mode (object or response)" ; $ methodParameters [ ] = new Param ( 'parameters' , new Expr \ Array_ ( ) ) ; $ methodParameters [ ] = new Param ( 'fetch' , new Expr \ ConstFetch ( new Name ( 'self::FETCH_OBJECT' ) ) ) ; return [ $ documentationParams , $ methodParameters ] ; }
4451	public function recur ( string $ className , array $ data , ? int $ interval = null , ? int $ offset = null , ? string $ jid = null , ? int $ retries = null , ? int $ priority = null , ? int $ backlog = null , ? array $ tags = null ) { try { $ jid = $ jid ? : Uuid :: uuid4 ( ) -> toString ( ) ; } catch ( \ Exception $ e ) { throw new RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } $ data = json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ; if ( empty ( $ data ) ) { throw new RuntimeException ( sprintf ( 'Unable to encode payload to make a recurring job "%s" for the "%s" queue.' , $ jid , $ this -> name ) ) ; } return $ this -> client -> recur ( $ this -> name , $ jid , $ className , $ data , 'interval' , is_null ( $ interval ) ? 60 : $ interval , is_null ( $ offset ) ? 0 : $ offset , 'priority' , is_null ( $ priority ) ? 0 : $ priority , 'tags' , json_encode ( $ tags ? : [ ] , JSON_UNESCAPED_SLASHES ) , 'retries' , is_null ( $ retries ) ? 5 : $ retries , 'backlog' , is_null ( $ backlog ) ? 0 : $ backlog ) ; }
11982	public function acquire ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ this -> isAccessible ( $ acquirer , $ resource ) ) { throw new ResourceLockedException ( sprintf ( 'The resource is not accessible. It is locked by "%s".' , $ resource -> getLock ( ) -> getAcquirer ( ) -> getIdentifier ( ) ) ) ; } return $ this -> repository -> acquire ( $ acquirer , $ resource ) ; }
3969	protected function deleteConditionSettings ( PreDeleteModelEvent $ event ) { $ environment = $ event -> getEnvironment ( ) ; $ model = $ event -> getModel ( ) ; $ dataProvider = $ environment -> getDataProvider ( 'tl_metamodel_dcasetting_condition' ) ; $ conditions = $ dataProvider -> fetchAll ( $ dataProvider -> getEmptyConfig ( ) -> setFilter ( [ [ 'operation' => '=' , 'property' => 'attr_id' , 'value' => $ model -> getId ( ) ] ] ) ) ; if ( $ conditions -> count ( ) < 1 ) { return ; } $ conditionsGeneral = new \ DC_General ( $ dataProvider -> getEmptyModel ( ) -> getProviderName ( ) ) ; $ conditionsEnvironment = $ conditionsGeneral -> getEnvironment ( ) ; $ conditionsDataDefinition = $ conditionsEnvironment -> getDataDefinition ( ) ; $ conditionsPalettesDefinition = $ conditionsDataDefinition -> getPalettesDefinition ( ) ; $ conditionsIterator = $ conditions -> getIterator ( ) ; while ( $ currentCondition = $ conditionsIterator -> current ( ) ) { $ conditionPalette = $ conditionsPalettesDefinition -> getPaletteByName ( $ currentCondition -> getProperty ( 'type' ) ) ; $ conditionProperties = $ conditionPalette -> getVisibleProperties ( $ currentCondition ) ; foreach ( $ conditionProperties as $ conditionProperty ) { if ( $ conditionProperty -> getName ( ) !== 'attr_id' ) { continue ; } $ dataProvider -> delete ( $ currentCondition ) ; } $ conditionsIterator -> next ( ) ; } }
7556	function getChildrenByAttribute ( $ attribute , $ value , $ mode = 'equals' , $ compare = 'total' , $ recursive = true ) { if ( $ this -> childCount ( ) < 1 ) { return array ( ) ; } $ mode = explode ( ' ' , strtolower ( $ mode ) ) ; $ match = ( ( isset ( $ mode [ 1 ] ) && ( $ mode [ 1 ] === 'not' ) ) ? 'false' : 'true' ) ; return $ this -> getChildrenByMatch ( array ( 'attributes' => array ( $ attribute => array ( 'operator_value' => $ mode [ 0 ] , 'value' => $ value , 'match' => $ match , 'compare' => $ compare ) ) ) , $ recursive ) ; }
9310	protected function doPostAction ( $ uri , array $ data = [ ] ) { $ this -> setActionUri ( $ uri ) ; try { $ response = $ this -> client -> post ( $ this -> uri , [ 'json' => $ data ] ) ; } catch ( ClientException $ e ) { $ response = $ e -> getResponse ( ) ; } catch ( ServerException $ e ) { $ response = $ e -> getResponse ( ) ; } return $ this -> responseToJson ( $ response ) ; }
4104	protected static function parseDsn ( $ dsn ) { $ parts = parse_url ( $ dsn ) ; $ protocol = $ parts [ 'scheme' ] ; $ servers = $ parts [ 'host' ] . ':' . $ parts [ 'port' ] ; if ( isset ( $ parts [ 'path' ] ) ) { $ path = explode ( '/' , $ parts [ 'path' ] ) ; list ( $ index , $ type ) = array_values ( array_filter ( $ path ) ) ; } return compact ( 'protocol' , 'servers' , 'index' , 'type' ) ; }
8999	public function fileExists ( $ fileName ) : bool { if ( ! $ this -> exists ( ) ) { return false ; } $ file = sprintf ( "%s/%s" , $ this -> path , $ fileName ) ; return file_exists ( $ file ) ; }
6904	public function runWild ( ) { foreach ( $ this -> handlers as $ handler ) { $ rtn = $ handler instanceof Closure ? $ this -> context -> call ( $ handler , $ this -> req ) : $ this -> context -> callInClass ( $ handler , $ this -> action , $ this -> req ) ; if ( ! is_null ( $ rtn ) ) return $ rtn ; } return null ; }
1083	private function expect ( $ kind ) { $ token = $ this -> lexer -> token ; if ( $ token -> kind === $ kind ) { $ this -> lexer -> advance ( ) ; return $ token ; } throw new SyntaxError ( $ this -> lexer -> source , $ token -> start , sprintf ( 'Expected %s, found %s' , $ kind , $ token -> getDescription ( ) ) ) ; }
6027	public function setUploaded ( $ uploaded ) { if ( $ uploaded instanceof DateTime ) { $ this -> uploaded = $ uploaded ; } else { try { $ this -> uploaded = new DateTime ( $ uploaded ) ; } catch ( \ Exception $ e ) { $ this -> uploaded = null ; } } return $ this ; }
1618	public function scalar ( $ attribute , $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } $ record = $ this -> one ( $ db ) ; if ( $ record !== null ) { return $ record -> hasAttribute ( $ attribute ) ? $ record -> $ attribute : null ; } else { return null ; } }
2974	public function analyze ( \ Closure $ closure ) { $ data = [ 'reflection' => new \ ReflectionFunction ( $ closure ) , 'code' => null , 'hasThis' => false , 'context' => [ ] , 'hasRefs' => false , 'binding' => null , 'scope' => null , 'isStatic' => $ this -> isClosureStatic ( $ closure ) , ] ; $ this -> determineCode ( $ data ) ; $ this -> determineContext ( $ data ) ; $ this -> determineBinding ( $ data ) ; return $ data ; }
9865	private function writeHyperlinks ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ hyperlinkCollection = $ pSheet -> getHyperlinkCollection ( ) ; $ relationId = 1 ; if ( ! empty ( $ hyperlinkCollection ) ) { $ objWriter -> startElement ( 'hyperlinks' ) ; foreach ( $ hyperlinkCollection as $ coordinate => $ hyperlink ) { $ objWriter -> startElement ( 'hyperlink' ) ; $ objWriter -> writeAttribute ( 'ref' , $ coordinate ) ; if ( ! $ hyperlink -> isInternal ( ) ) { $ objWriter -> writeAttribute ( 'r:id' , 'rId_hyperlink_' . $ relationId ) ; ++ $ relationId ; } else { $ objWriter -> writeAttribute ( 'location' , str_replace ( 'sheet://' , '' , $ hyperlink -> getUrl ( ) ) ) ; } if ( $ hyperlink -> getTooltip ( ) != '' ) { $ objWriter -> writeAttribute ( 'tooltip' , $ hyperlink -> getTooltip ( ) ) ; } $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
1294	public static function create ( JsonDecoderClientInterface $ client , ClientOptions $ options ) : ResourcePoolInterface { if ( $ options -> usesLowMemoryResourcePool ( ) ) { return new Standard ( $ client -> getApi ( ) , $ client -> getSpaceId ( ) , $ client -> getEnvironmentId ( ) ) ; } return new Extended ( $ client , $ options -> getCacheItemPool ( ) , $ options -> hasCacheAutoWarmup ( ) , $ options -> hasCacheContent ( ) ) ; }
12301	public function getChilds ( $ id , $ relation , $ filters = null ) { $ parent = $ this -> model -> find ( $ id ) ; if ( ! $ parent ) { return null ; } if ( count ( $ filters -> request -> all ( ) ) > 0 ) { $ child = $ parent -> $ relation ( ) -> getRelated ( ) ; $ search = new Search ( $ child , $ filters , $ parent -> $ relation ( ) ) ; $ this -> builder = $ search -> getBuilder ( ) ; $ this -> builder -> select ( "{$child->getTable()}.*" ) ; return $ this -> builder -> get ( ) ; } $ resource = $ parent -> $ relation ; return $ resource ; }
9182	public function remember ( $ value , $ memoryDuration = null ) { if ( is_null ( $ memoryDuration ) ) { $ memoryDuration = $ this -> memoryDuration ; } $ key = $ this -> getRememberKey ( ) ; if ( Cache :: has ( $ key ) ) { $ value = Cache :: get ( $ key ) ; } else { $ expiresAt = Carbon :: now ( ) -> addMinutes ( $ memoryDuration ) ; if ( is_callable ( $ value ) ) { $ value = $ value ( ) ; } Cache :: put ( $ key , $ value , $ expiresAt ) ; } return $ value ; }
6291	private function loadTheme ( $ theme ) { if ( ! isset ( $ theme ) ) { return ; } $ th = $ this -> findThemeByDirectory ( $ theme ) ; if ( isset ( $ th ) ) { $ viewFinder = $ this -> view -> getFinder ( ) ; $ viewFinder -> prependPath ( $ th -> getPath ( ) ) ; if ( ! is_null ( $ th -> getParent ( ) ) ) { $ this -> loadTheme ( $ th -> getParent ( ) ) ; } $ this -> activeTheme = $ theme ; } }
2857	public function viewHandleAction ( ) { $ area = $ this -> getRequest ( ) -> getParam ( 'area' ) ; $ storeId = ( int ) $ this -> getRequest ( ) -> getParam ( 'store' ) ; $ handle = $ this -> getRequest ( ) -> getParam ( 'handle' ) ; $ updatesByFile = $ this -> getService ( ) -> getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ databaseUpdates = $ this -> getService ( ) -> getDatabaseUpdatesWithHandle ( $ handle , $ storeId , $ area ) ; $ block = $ this -> getLayout ( ) -> createBlock ( 'sheep_debug/view' , '' , array ( 'template' => 'sheep_debug/view/panel/_layout_updates.phtml' , 'file_updates' => $ updatesByFile , 'db_updates' => $ databaseUpdates ) ) ; $ this -> getResponse ( ) -> setBody ( $ block -> toHtml ( ) ) ; }
9531	private function respondDefault ( & $ i , & $ results , $ parameter ) { $ defaultResult = $ this -> parameterCluster -> default -> call ( $ this , $ parameter ) ; if ( $ defaultResult === - 1 ) { $ this -> valid = false ; } $ results [ $ parameter ] = $ defaultResult ; $ i ++ ; }
561	public static function autoload ( $ className ) { if ( isset ( static :: $ classMap [ $ className ] ) ) { $ classFile = static :: $ classMap [ $ className ] ; if ( $ classFile [ 0 ] === '@' ) { $ classFile = static :: getAlias ( $ classFile ) ; } } elseif ( strpos ( $ className , '\\' ) !== false ) { $ classFile = static :: getAlias ( '@' . str_replace ( '\\' , '/' , $ className ) . '.php' , false ) ; if ( $ classFile === false || ! is_file ( $ classFile ) ) { return ; } } else { return ; } include $ classFile ; if ( YII_DEBUG && ! class_exists ( $ className , false ) && ! interface_exists ( $ className , false ) && ! trait_exists ( $ className , false ) ) { throw new UnknownClassException ( "Unable to find '$className' in file: $classFile. Namespace missing?" ) ; } }
1046	public static function toSafeTrace ( $ error ) { $ trace = $ error -> getTrace ( ) ; if ( isset ( $ trace [ 0 ] [ 'function' ] ) && isset ( $ trace [ 0 ] [ 'class' ] ) && ( $ trace [ 0 ] [ 'class' ] . '::' . $ trace [ 0 ] [ 'function' ] === 'GraphQL\Utils\Utils::invariant' ) ) { array_shift ( $ trace ) ; } elseif ( ! isset ( $ trace [ 0 ] [ 'file' ] ) ) { array_shift ( $ trace ) ; } return array_map ( static function ( $ err ) { $ safeErr = array_intersect_key ( $ err , [ 'file' => true , 'line' => true ] ) ; if ( isset ( $ err [ 'function' ] ) ) { $ func = $ err [ 'function' ] ; $ args = ! empty ( $ err [ 'args' ] ) ? array_map ( [ self :: class , 'printVar' ] , $ err [ 'args' ] ) : [ ] ; $ funcStr = $ func . '(' . implode ( ', ' , $ args ) . ')' ; if ( isset ( $ err [ 'class' ] ) ) { $ safeErr [ 'call' ] = $ err [ 'class' ] . '::' . $ funcStr ; } else { $ safeErr [ 'function' ] = $ funcStr ; } } return $ safeErr ; } , $ trace ) ; }
3029	public function setToken ( $ token , $ secret ) { $ this -> token = new \ Eher \ OAuth \ Token ( $ token , $ secret ) ; }
432	public function getModules ( $ loadedOnly = false ) { if ( $ loadedOnly ) { $ modules = [ ] ; foreach ( $ this -> _modules as $ module ) { if ( $ module instanceof self ) { $ modules [ ] = $ module ; } } return $ modules ; } return $ this -> _modules ; }
8823	public function rule ( $ field , $ label , $ rules , array $ text = [ ] ) { $ this -> labels [ $ field ] = $ label ; $ this -> rules [ $ field ] = $ rules ; $ this -> texts [ $ field ] = ( ! empty ( $ text ) ? $ text : null ) ; }
6198	public function parseGets ( ) { $ request = preg_replace ( '!' . $ this -> uri . '(.*)$!i' , '$1' , $ _SERVER [ 'REQUEST_URI' ] ) ; if ( defined ( 'MOD_REWRITE' ) and MOD_REWRITE === true ) { if ( substr ( $ request , - 1 ) != '/' ) { $ request .= '/' ; } $ parseUrl = $ this -> parseUrl ( $ request ) ; $ this -> namespace = $ parseUrl [ 'v' ] [ 'namespace' ] ?? '' ; parse_str ( $ parseUrl [ 'sVars' ] , $ gets ) ; $ this -> controller = ! empty ( $ gets [ 'task' ] ) ? $ gets [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; unset ( $ gets [ 'task' ] ) ; $ this -> action = ! empty ( $ gets [ 'action' ] ) ? $ gets [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; unset ( $ gets [ 'action' ] ) ; $ _GET = array_merge ( $ _GET , $ gets ) ; } else { $ this -> controller = ! empty ( $ _GET [ 'task' ] ) ? $ _GET [ 'task' ] : $ this -> routeMap [ 'NAME_CONTROLLER' ] ; $ this -> action = ! empty ( $ _GET [ 'action' ] ) ? $ _GET [ 'action' ] : $ this -> routeMap [ 'NAME_METHOD' ] ; } $ _GET [ 'task' ] = $ this -> controller ; $ _GET [ 'action' ] = $ this -> action ; }
6805	private function generate ( $ class , array $ names , $ defaultCode ) { $ repository = $ this -> manager -> getRepository ( $ class ) ; foreach ( $ names as $ code => $ name ) { $ result = 'already exists' ; if ( null === $ repository -> findOneBy ( [ 'code' => $ code ] ) ) { $ entity = $ repository -> createNew ( ) ; $ entity -> setName ( $ name ) -> setCode ( $ code ) -> setEnabled ( $ defaultCode === $ code ) ; $ this -> manager -> persist ( $ entity ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
10807	public function select ( ) { $ cols = func_get_args ( ) ; return $ this -> getBuilder ( ) -> setPrevious ( $ this ) -> select ( false ) -> col ( $ cols ) ; }
9599	protected function redirect ( $ name , array $ params = array ( ) , $ statusCode = 302 ) { return new RedirectResponse ( $ this -> url ( $ name , $ params ) , $ statusCode ) ; }
7122	protected function detectAndApplyLanguage ( ) { if ( $ this -> config ( 'autodetect' , true ) ) { $ detector = $ this -> getLanguageDetector ( ) ; $ language = $ detector -> getLanguageFromCookie ( ) ; if ( ! $ language || strlen ( $ language ) > 5 || ! in_array ( $ language , $ this -> getSupportedLanguages ( ) , true ) ) { $ language = $ detector -> getDriver ( ) -> detect ( ) ; if ( ! $ language || strlen ( $ language ) > 5 ) { $ language = $ this -> request -> getDefaultLocale ( ) ; } } $ this -> applyNewLanguage ( $ language , true ) ; } }
12859	public function addRoute ( string $ verb , string $ path , array $ callback ) : Router { $ this -> routeCollector -> addRoute ( $ verb , $ path , $ callback ) ; return $ this ; }
7654	public function dir_readdir ( ) { $ object = current ( $ this -> blobs ) ; if ( $ object !== false ) { next ( $ this -> blobs ) ; return $ object -> Name ; } return false ; }
6624	public function process ( Request $ request ) : Response { $ router = $ request -> attributes -> get ( 'router' ) ; $ next = next ( $ this -> middlewareStack ) ; if ( $ next instanceof Middleware ) { $ router -> log ( "Router: Calling Middleware: %s" , get_class ( $ next ) ) ; $ response = $ next -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , get_class ( $ next ) ) ; return $ response ; } elseif ( is_string ( $ next ) ) { $ router -> log ( "Router: Calling Middleware: %s" , $ next ) ; $ response = $ router -> getMiddleware ( $ next ) -> process ( $ request , $ this ) ; $ router -> log ( "Router: Leaving Middleware: %s" , $ next ) ; return $ response ; } else { $ params = $ request -> attributes -> get ( 'controller' ) ; $ router -> log ( "Router: Calling Controller: %s@%s" , $ params -> className , $ params -> method ) ; $ return = ( new $ params -> className ( $ params -> container ) ) -> { $ params -> method } ( $ request , ... array_values ( $ params -> args ) ) ; $ router -> log ( "Router: Controller Left" ) ; if ( $ return instanceof Response ) { return $ return ; } if ( is_array ( $ return ) or is_object ( $ return ) ) { return new JsonResponse ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'application/json' ) ) ; } return new Response ( $ return , Response :: HTTP_OK , array ( 'content-type' => 'text/html' ) ) ; } }
6279	public function firstkey ( ) { $ this -> keyIterPos = 4 ; if ( ! $ this -> keyIterStop ) { $ pos = INF ; for ( $ i = 0 ; $ i < 2048 ; $ i += 8 ) { $ pos = min ( $ this -> readInt31 ( $ i ) , $ pos ) ; } $ this -> keyIterStop = $ pos ; } $ this -> keyIterPos = 2048 ; return $ this -> nextkey ( ) ; }
8938	public function updateChangeset ( $ id , $ tags = array ( ) ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'changeset/' . $ id ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <changeset>' . $ tagList . '</changeset> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; $ xmlString = simplexml_load_string ( $ response -> body ) ; return $ xmlString -> changeset ; }
1787	public function getActiveLayoutSections ( Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> pid ) { $ arrSections = array ( ) ; $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> activeRecord -> pid ) ; if ( $ objPage -> layout ) { $ objLayout = Contao \ LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( $ objLayout === null ) { return array ( ) ; } $ arrModules = Contao \ StringUtil :: deserialize ( $ objLayout -> modules ) ; if ( empty ( $ arrModules ) || ! \ is_array ( $ arrModules ) ) { return array ( ) ; } foreach ( $ arrModules as $ arrModule ) { if ( $ arrModule [ 'mod' ] == 0 && $ arrModule [ 'enable' ] ) { $ arrSections [ ] = $ arrModule [ 'col' ] ; } } } } else { $ arrSections = array ( 'header' , 'left' , 'right' , 'main' , 'footer' ) ; $ objLayout = $ this -> Database -> query ( "SELECT sections FROM tl_layout WHERE sections!=''" ) ; while ( $ objLayout -> next ( ) ) { $ arrCustom = Contao \ StringUtil :: deserialize ( $ objLayout -> sections ) ; if ( ! empty ( $ arrCustom ) && \ is_array ( $ arrCustom ) ) { foreach ( $ arrCustom as $ v ) { if ( ! empty ( $ v [ 'id' ] ) ) { $ arrSections [ ] = $ v [ 'id' ] ; } } } } } return Contao \ Backend :: convertLayoutSectionIdsToAssociativeArray ( $ arrSections ) ; }
2945	public function removeRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles ( ) -> detach ( Role :: where ( 'slug' , $ role ) -> first ( ) ) ; } return $ this -> roles ( ) -> detach ( $ role ) ; }
7216	protected function getTaxGroupFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof TaxGroupInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . TaxGroupInterface :: class ) ; } return $ resource ; }
9232	public function actionView ( $ id , $ format = false ) { $ model = $ this -> findModel ( $ id ) ; if ( $ format == 'json' ) { return \ yii \ helpers \ Json :: encode ( $ model ) ; } else { return $ this -> render ( 'view' , [ 'model' => $ model , ] ) ; } }
6101	public function listPropertySets ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/propertysets' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new PropertySet ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7669	function ServerVar ( $ varName ) { global $ HTTP_SERVER_VARS ; global $ HTTP_ENV_VARS ; if ( ! isset ( $ _SERVER ) ) { $ _SERVER = $ HTTP_SERVER_VARS ; if ( ! isset ( $ _SERVER [ "REMOTE_ADDR" ] ) ) $ _SERVER = $ HTTP_ENV_VARS ; } if ( isset ( $ _SERVER [ $ varName ] ) ) return $ _SERVER [ $ varName ] ; else return "" ; }
7924	public function extract ( $ zipFile , $ targetPath ) { $ zipArchive = $ this -> openZipFile ( $ zipFile ) ; $ targetPath = $ this -> fixPath ( $ targetPath ) ; $ filenames = $ this -> extractFilenames ( $ zipArchive ) ; if ( $ zipArchive -> extractTo ( $ targetPath , $ filenames ) === false ) { throw new \ Exception ( $ this -> getError ( $ zipArchive -> status ) ) ; } $ zipArchive -> close ( ) ; return $ filenames ; }
10869	public function getByEmail ( string $ email ) { return $ this -> getList ( ) -> where ( [ $ this -> tableName [ 0 ] . '.email' => $ email , $ this -> tableName [ 0 ] . '.active' => true ] ) -> fetch ( ) ; }
11802	public static function import ( $ name ) { $ importPath = FOREVERPHP_ROOT . DS . $ name . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($name) not exists." ) ; } }
11337	public function getMigrationClassName ( ) { $ postfix = '_initial_' . $ this -> tableName ; if ( is_dir ( $ this -> migrationDirectory ) ) { $ searchExisting = FileHelper :: findFiles ( $ this -> migrationDirectory , [ 'only' => [ $ postfix . '.php' ] ] ) ; if ( ! empty ( $ searchExisting ) ) { return strstr ( basename ( $ searchExisting [ 0 ] ) , '.php' , true ) ; } } return 'm' . gmdate ( 'ymd_His' , $ this -> migrationTimestamp ) . $ postfix ; }
12691	protected function outputError ( $ errorNumber , $ test , $ exception ) { $ feature = null ; $ scenario = null ; $ testDescription = null ; $ node = $ test ; while ( $ node !== null ) { $ class = get_class ( $ node ) ; $ description = str_replace ( "\n " , "\n " , $ node -> getDescription ( ) ) ; if ( $ description === '' ) { $ node = $ node -> getParent ( ) ; continue ; } if ( $ class === 'Peridot\Core\Test' ) { $ testDescription = $ description ; } elseif ( $ class === 'Peridot\Core\Suite' ) { if ( strpos ( $ description , 'Feature:' ) === 0 ) { $ feature = $ description ; } else { $ scenario = trim ( $ description ) ; } } $ node = $ node -> getParent ( ) ; } if ( $ this -> lastFeature !== $ feature ) { $ this -> output -> writeln ( " " . $ feature . "\n" ) ; $ this -> lastFeature = $ feature ; $ this -> lastScenario = null ; } if ( $ this -> lastScenario !== $ scenario ) { $ this -> output -> writeln ( " " . $ scenario . "\n" ) ; $ this -> lastScenario = $ scenario ; } $ this -> output -> writeln ( $ this -> color ( 'error' , sprintf ( " %d) %s" , $ errorNumber , $ testDescription ) ) ) ; $ message = sprintf ( " %s" , str_replace ( "\n" , "\n " , $ exception -> getMessage ( ) ) ) ; $ this -> output -> writeln ( $ this -> color ( 'pending' , $ message ) ) ; $ class = method_exists ( $ exception , 'getClass' ) ? $ exception -> getClass ( ) : get_class ( $ exception ) ; $ trace = method_exists ( $ exception , 'getTrueTrace' ) ? $ exception -> getTrueTrace ( ) : $ exception -> getTrace ( ) ; array_unshift ( $ trace , [ 'function' => $ class . ' thrown' , 'file' => $ exception -> getFile ( ) , 'line' => $ exception -> getLine ( ) ] ) ; $ this -> outputTrace ( $ trace ) ; }
2161	public function run33Update ( ) { $ objLayout = $ this -> Database -> query ( "SELECT id, framework FROM tl_layout WHERE framework!=''" ) ; while ( $ objLayout -> next ( ) ) { $ strFramework = '' ; $ tmp = StringUtil :: deserialize ( $ objLayout -> framework ) ; if ( ! empty ( $ tmp ) && \ is_array ( $ tmp ) ) { if ( ( $ key = array_search ( 'layout.css' , $ tmp ) ) !== false ) { array_insert ( $ tmp , $ key + 1 , 'responsive.css' ) ; } $ strFramework = serialize ( array_values ( array_unique ( $ tmp ) ) ) ; } $ this -> Database -> prepare ( "UPDATE tl_layout SET framework=? WHERE id=?" ) -> execute ( $ strFramework , $ objLayout -> id ) ; } $ this -> Database -> query ( "ALTER TABLE `tl_layout` ADD `viewport` varchar(64) NOT NULL default ''" ) ; }
6778	protected function updateVatDisplayMode ( SaleInterface $ sale ) { if ( $ sale -> hasPayments ( ) ) { return false ; } $ mode = null ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ mode = $ group -> getVatDisplayMode ( ) ; } if ( null === $ mode ) { $ mode = $ this -> defaultVatDisplayMode ; } if ( $ mode !== $ sale -> getVatDisplayMode ( ) ) { $ sale -> setVatDisplayMode ( $ mode ) ; return true ; } return false ; }
4718	public function processStandardUrl ( Text $ text ) { $ hashes = array ( ) ; $ text -> replace ( '{<code>.*?</code>}m' , function ( Text $ w ) use ( & $ hashes ) { $ md5 = md5 ( $ w ) ; $ hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '{(?<!]\(|"|<|\[)((?:https?|ftp)://[^\'">\s]+)(?!>|\"|\])}' , '<\1>' ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) use ( & $ hashes ) { return $ hashes [ ( string ) $ md5 ] ; } ) ; }
2714	public function getCheckedValues ( ) { if ( $ this -> values === null ) { $ data = $ this -> config -> getImageOptimizationRatios ( ) ; if ( ! isset ( $ data ) ) { $ data = '' ; } $ this -> values = explode ( ',' , $ data ) ; } return $ this -> values ; }
975	public function shopWebhooks ( ) { if ( ! $ this -> shopWebhooks ) { $ this -> shopWebhooks = $ this -> api -> rest ( 'GET' , '/admin/webhooks.json' , [ 'limit' => 250 , 'fields' => 'id,address' , ] ) -> body -> webhooks ; } return $ this -> shopWebhooks ; }
2746	public function isImageOptimizationPixelRatioEnabled ( ) { if ( $ this -> isImageOptimizationEnabled ( ) !== true ) { return false ; } return $ this -> _scopeConfig -> isSetFlag ( self :: XML_FASTLY_IMAGE_OPTIMIZATIONS_PIXEL_RATIO ) ; }
1481	public function getDefaultCodec ( ) : Codec { return $ this -> factory -> createCodec ( $ this -> getContainer ( ) , $ this -> encodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ? : Encoding :: jsonApi ( ) , $ this -> decodings -> find ( MediaTypeInterface :: JSON_API_MEDIA_TYPE ) ) ; }
10129	private function writeProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } $ record = 0x0012 ; $ length = 0x0002 ; $ fLock = 1 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fLock ) ; $ this -> append ( $ header . $ data ) ; }
9498	public function saveEntity ( BaseEntity $ entity , $ endPoint = '' , $ extraData = null ) { $ end_point = strtolower ( $ endPoint ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; $ method = $ entity -> getId ( ) ? 'put' : 'post' ; if ( $ method == 'post' ) { $ entity -> checkCreatable ( ) ; } $ changes = $ entity -> toArray ( true , $ extraData ) ; if ( empty ( $ changes ) ) { return null ; } $ request = $ this -> api -> $ method ( $ end_point , null , json_encode ( array ( $ baseName => $ changes ) ) ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ changeResult = new ChangeResult ( ) ; $ t = new $ type ( ) ; $ this -> manage ( $ t ) ; $ t -> fromArray ( $ result [ $ baseName ] ) ; $ changeResult -> setItem ( $ t ) ; if ( isset ( $ result [ 'audit' ] ) ) { $ audit = new TicketAudit ( ) ; $ audit -> fromArray ( $ result [ 'audit' ] ) ; $ changeResult -> setAudit ( $ audit ) ; } return $ changeResult ; } return null ; }
1109	protected function groupRootsByScope ( $ roots ) { $ rootsGroupedByScope = array ( ) ; foreach ( $ roots as $ root ) { $ key = $ this -> keyForScope ( $ root ) ; if ( ! isset ( $ rootsGroupedByScope [ $ key ] ) ) $ rootsGroupedByScope [ $ key ] = array ( ) ; $ rootsGroupedByScope [ $ key ] [ ] = $ root ; } return $ rootsGroupedByScope ; }
9692	private function compileString ( $ str ) { $ result = null ; try { $ result = $ this -> parser -> compile ( $ str ) ; } catch ( \ Exception $ e ) { throw new SyntaxErrorException ( "Syntax error in $this->currFile: " . $ e -> getMessage ( ) ) ; } return $ result ; }
8304	public function assertInteger ( $ config , $ key , $ lowest = null , $ highest = null ) { if ( array_key_exists ( $ key , $ config ) ) { if ( ! is_int ( $ config [ $ key ] ) ) { throw new ConfigurationException ( $ key . " must be an integer." ) ; } if ( $ lowest !== null && $ config [ $ key ] < $ lowest ) { throw new ConfigurationException ( $ key . " cannot be lower than " . $ lowest ) ; } if ( $ highest !== null && $ config [ $ key ] > $ highest ) { throw new ConfigurationException ( $ key . " cannot be higher than " . $ highest ) ; } } return $ this ; }
10152	private function readHcenter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ isHorizontalCentered = ( bool ) self :: getUInt2d ( $ recordData , 0 ) ; $ this -> phpSheet -> getPageSetup ( ) -> setHorizontalCentered ( $ isHorizontalCentered ) ; } }
7532	function html ( $ value = null ) { if ( $ value !== null ) { $ this -> setInnerText ( $ value ) ; } return $ this -> getInnerText ( ) ; }
439	public function hasProperty ( $ name , $ checkVars = true , $ checkBehaviors = true ) { return $ this -> canGetProperty ( $ name , $ checkVars , $ checkBehaviors ) || $ this -> canSetProperty ( $ name , false , $ checkBehaviors ) ; }
3841	private function parsePanelFilter ( PanelRowInterface $ row ) { foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'filter' ] ) ) { $ element = new DefaultFilterElementInformation ( ) ; $ element -> setPropertyName ( $ value [ 'col_name' ] ) ; if ( ! $ row -> hasElement ( $ element -> getName ( ) ) ) { $ row -> addElement ( $ element ) ; } } } }
8669	protected function computeFileSystemDifferences ( ) { $ entityPathByFilesystems = [ ] ; foreach ( $ this -> resourceManager -> getResourceConfigurations ( ) as $ resourceConfiguration ) { $ className = $ resourceConfiguration -> getEntity ( ) ; $ entityManager = $ this -> doctrine -> getManagerForClass ( $ className ) ; if ( ! $ entityManager instanceof EntityManagerInterface ) { throw new \ UnexpectedValueException ( "No manager found for class {$className}" ) ; } $ repository = $ entityManager -> getRepository ( $ className ) ; if ( ! $ repository instanceof ResourceRepositoryInterface ) { throw new \ UnexpectedValueException ( "Repository for class {$className} must implement ResourceRepositoryInterface" ) ; } $ paths = $ repository -> getPaths ( ) ; $ adapterReference = $ this -> adaptersByResourceType [ $ resourceConfiguration -> getCode ( ) ] ; if ( array_key_exists ( $ adapterReference , $ entityPathByFilesystems ) ) { $ entityPathByFilesystems [ $ adapterReference ] = array_merge ( $ entityPathByFilesystems [ $ adapterReference ] , $ paths ) ; } else { $ entityPathByFilesystems [ $ adapterReference ] = $ paths ; } } foreach ( $ this -> adapters as $ adapterReference => $ adapter ) { $ existingPaths = [ ] ; foreach ( $ adapter -> listContents ( ) as $ metadata ) { $ entityPath = $ metadata [ 'path' ] ; if ( '.gitkeep' === $ entityPath ) { continue ; } $ existingPaths [ $ entityPath ] = $ entityPath ; } $ entityPaths = $ entityPathByFilesystems [ $ adapterReference ] ; $ this -> extraFiles [ $ adapterReference ] = array_diff_key ( $ existingPaths , $ entityPaths ) ; $ this -> missingFiles [ $ adapterReference ] = array_diff_key ( $ entityPaths , $ existingPaths ) ; } }
7067	protected function getAccountingFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof AccountingInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . AccountingInterface :: class ) ; } return $ resource ; }
5515	public function expectAtLeastOnce ( $ method , $ args = false , $ message = '%s' ) { $ this -> expectMinimumCallCount ( $ method , 1 , $ message ) ; if ( $ args !== false ) { $ this -> expect ( $ method , $ args , $ message ) ; } }
1924	public function setResource ( $ gdResource ) { if ( ! \ is_resource ( $ gdResource ) || get_resource_type ( $ gdResource ) !== 'gd' ) { throw new \ InvalidArgumentException ( '$gdResource is not a valid GD resource' ) ; } $ this -> gdResource = $ gdResource ; return $ this ; }
4881	public function getContent ( ) { if ( $ this -> file instanceof \ Doctrine \ MongoDB \ GridFSFile ) { return $ this -> file -> getMongoGridFSFile ( ) -> getBytes ( ) ; } return null ; }
1734	public function validateCode ( User $ user , string $ code ) : bool { $ totp = TOTP :: create ( $ this -> getUpperUnpaddedSecretForUser ( $ user ) ) ; return $ totp -> verify ( $ code ) ; }
2283	protected static function url ( ) { $ host = static :: get ( 'httpHost' ) ; $ xhost = static :: get ( 'httpXForwardedHost' ) ; if ( $ xhost != '' && $ xhost == Config :: get ( 'sslProxyDomain' ) ) { return 'https://' . $ xhost . '/' . $ host ; } return ( static :: get ( 'ssl' ) ? 'https://' : 'http://' ) . $ host ; }
1591	protected function validateData ( ) : bool { if ( ! property_exists ( $ this -> document , 'data' ) ) { $ this -> memberRequired ( '/' , 'data' ) ; return false ; } $ data = $ this -> document -> data ; if ( ! is_object ( $ data ) ) { $ this -> memberNotObject ( '/' , 'data' ) ; return false ; } return true ; }
4591	public function setOwnerUuid ( ? string $ ownerUuid ) { if ( null !== $ ownerUuid ) { if ( ! preg_match ( '/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i' , $ ownerUuid ) ) { throw new InvalidArgumentException ( 'Owner uuid is not valid.' ) ; } } $ this -> ownerUuid = $ ownerUuid ; return $ this ; }
7334	private function getSubjectIdentityMapper ( EntityManagerInterface $ em ) { if ( null === $ this -> subjectIdentityMapper ) { $ this -> subjectIdentityMapper = new EmbeddableMapper ( $ em , SubjectIdentity :: class ) ; } return $ this -> subjectIdentityMapper ; }
1646	public function getLength ( DistanceInterface $ calculator ) : float { $ distance = 0.0 ; if ( count ( $ this -> points ) <= 1 ) { return $ distance ; } foreach ( $ this -> getSegments ( ) as $ segment ) { $ distance += $ segment -> getLength ( $ calculator ) ; } return $ distance ; }
3862	public function getOutputFormat ( ) { if ( isset ( $ this -> strOutputFormat ) ) { return $ this -> strOutputFormat ; } if ( isset ( $ this -> objView ) && $ this -> objView -> get ( 'format' ) ) { return $ this -> objView -> get ( 'format' ) ; } $ page = $ this -> getPage ( ) ; if ( $ page && $ page -> outputFormat ) { return $ page -> outputFormat ; } return 'text' ; }
4219	private function clearSummary ( $ flags ) { $ return = null ; $ clearErrors = $ flags & Debug :: CLEAR_SUMMARY_ERRORS ; if ( $ flags & Debug :: CLEAR_SUMMARY ) { $ return = 'summary (' . ( $ clearErrors ? 'incl errors' : 'sans errors' ) . ')' ; $ curPriority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; foreach ( \ array_keys ( $ this -> data [ 'logSummary' ] ) as $ priority ) { $ entriesKeep = array ( ) ; if ( $ priority === $ curPriority ) { $ curDepth = 0 ; foreach ( $ this -> data [ 'groupStacks' ] [ $ priority ] as $ group ) { $ curDepth += ( int ) $ group [ 'collect' ] ; } $ entriesKeep = $ this -> debug -> internal -> getCurrentGroups ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ curDepth ) ; } else { $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> clearLogHelper ( $ this -> data [ 'logSummary' ] [ $ priority ] , $ clearErrors , $ entriesKeep ) ; } } elseif ( $ clearErrors ) { $ return = 'summary errors' ; } return $ return ; }
9110	protected function attainPathName ( ) { $ path = false ; $ config = $ this -> getConfig ( ) ; if ( isset ( $ config [ 'theme_locator' ] [ 'themes_default_path' ] ) ) { $ path = $ config [ 'theme_locator' ] [ 'themes_default_path' ] ; } $ themeName = $ this -> attainThemeName ( ) ; if ( isset ( $ config [ 'themes' ] ) && is_array ( $ config [ 'themes' ] ) && isset ( $ config [ 'themes' ] [ $ themeName ] ) ) { if ( array_key_exists ( 'dir_path' , $ config [ 'themes' ] [ $ themeName ] ) ) { $ path = $ config [ 'themes' ] [ $ themeName ] [ 'dir_path' ] ; } } return $ path ; }
7128	public function addRanges ( string $ from , string $ to ) { $ this -> ranges [ ] = [ 'from' => $ from , 'to' => $ to , ] ; return $ this ; }
7055	public function offset ( $ jd ) { if ( $ this -> dst == false ) return $ this -> offset ; IAU :: Jd2cal ( $ jd , 0 , $ y , $ m , $ d , $ fd ) ; $ dayN = static :: dayOfYear ( $ y , $ m , $ d ) + $ fd ; IAU :: Cal2jd ( $ y , 3 , 1 , $ djm0 , $ djm ) ; $ dayB = static :: dayOfYear ( $ y , 2 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; IAU :: Cal2jd ( $ y , 11 , 1 , $ djm0 , $ djm ) ; $ dayE = static :: dayOfYear ( $ y , 11 , 1 ) + 14 - static :: weekDayNum ( $ djm0 + $ djm ) + ( 2 / 24 ) ; if ( $ dayN >= $ dayB && $ dayN < $ dayE ) return $ this -> offset + 1 ; else return $ this -> offset ; }
9882	private function writeSheet ( XMLWriter $ objWriter , $ pSheetname , $ pSheetId = 1 , $ pRelId = 1 , $ sheetState = 'visible' ) { if ( $ pSheetname != '' ) { $ objWriter -> startElement ( 'sheet' ) ; $ objWriter -> writeAttribute ( 'name' , $ pSheetname ) ; $ objWriter -> writeAttribute ( 'sheetId' , $ pSheetId ) ; if ( $ sheetState != 'visible' && $ sheetState != '' ) { $ objWriter -> writeAttribute ( 'state' , $ sheetState ) ; } $ objWriter -> writeAttribute ( 'r:id' , 'rId' . $ pRelId ) ; $ objWriter -> endElement ( ) ; } else { throw new WriterException ( 'Invalid parameters passed.' ) ; } }
5937	public function setFunctionalities ( array $ functionalities ) { $ this -> functionalities = [ ] ; foreach ( $ functionalities as $ item ) { $ this -> addFunctionality ( $ item ) ; } return $ this ; }
6734	protected function handleException ( \ Throwable $ e , Request $ request ) : Response { if ( ! $ e instanceof Exception \ Exception ) { $ e = new Exception \ UncaughtException ( $ e ) ; } $ code = $ e -> getStatusCode ( ) ; if ( $ this -> exceptionHandlers [ $ code ] instanceof ExceptionHandler ) { return $ this -> exceptionHandlers [ $ code ] -> handle ( $ e , $ request ) ; } elseif ( $ this -> defaultExceptionHandler instanceof ExceptionHandler ) { return $ this -> defaultExceptionHandler -> handle ( $ e , $ request ) ; } else { return ( new \ Circuit \ ExceptionHandler \ DefaultHandler ) -> handle ( $ e , $ request ) ; } }
11649	protected function _authenticateCreateSelect ( ) { $ dbSelect = clone $ this -> getDbSelect ( ) ; $ dbSelect -> from ( $ this -> _tableName ) -> where ( "{$this->_identityColumn} = ?" , $ this -> _identity ) -> limit ( 1 ) ; return $ dbSelect ; }
56	public function update ( PackageInterface $ initial , PackageInterface $ target , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ initial ) ; if ( ! $ downloader ) { return ; } $ installationSource = $ initial -> getInstallationSource ( ) ; if ( 'dist' === $ installationSource ) { $ initialType = $ initial -> getDistType ( ) ; $ targetType = $ target -> getDistType ( ) ; } else { $ initialType = $ initial -> getSourceType ( ) ; $ targetType = $ target -> getSourceType ( ) ; } if ( $ target -> isDev ( ) && 'dist' === $ installationSource ) { $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir ) ; return ; } if ( $ initialType === $ targetType ) { $ target -> setInstallationSource ( $ installationSource ) ; try { $ downloader -> update ( $ initial , $ target , $ targetDir ) ; return ; } catch ( \ RuntimeException $ e ) { if ( ! $ this -> io -> isInteractive ( ) ) { throw $ e ; } $ this -> io -> writeError ( '<error> Update failed (' . $ e -> getMessage ( ) . ')</error>' ) ; if ( ! $ this -> io -> askConfirmation ( ' Would you like to try reinstalling the package instead [<comment>yes</comment>]? ' , true ) ) { throw $ e ; } } } $ downloader -> remove ( $ initial , $ targetDir ) ; $ this -> download ( $ target , $ targetDir , 'source' === $ installationSource ) ; }
3638	public function env ( Output $ output ) : void { $ info = [ 'OS' => \ PHP_OS , 'Php version' => \ PHP_VERSION , 'Swoole version' => \ SWOOLE_VERSION , 'Swoft version' => \ Swoft :: VERSION , 'App Name' => \ config ( 'name' , 'unknown' ) , 'Base Path' => \ BASE_PATH , ] ; Show :: aList ( $ info , 'System Environment Info' ) ; }
3632	public function config ( Request $ request ) { if ( $ key = $ request -> query ( 'key' ) ) { return \ config ( $ key ) ; } return \ bean ( 'config' ) -> toArray ( ) ; }
6672	public function restart_all_ratings ( ) { $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customRatingGrifusAdmin' ) ) { die ( 'Busted!' ) ; } $ response [ 'ratings_restarted' ] = 0 ; $ posts = $ this -> model -> get_posts ( ) ; foreach ( $ posts as $ post ) { if ( isset ( $ post -> ID ) && ! $ this -> model -> get_movie_votes ( $ post -> ID ) ) { $ this -> set_rating_and_votes ( $ post -> ID , $ this -> get_default_votes ( $ post -> ID ) ) ; $ response [ 'ratings_restarted' ] ++ ; } } echo json_encode ( $ response ) ; die ( ) ; }
3582	protected function metaSelectListsKey ( Builder $ query , $ key ) { if ( strpos ( $ key , '.' ) !== false ) { return $ query -> addSelect ( $ key ) ; } elseif ( $ this -> hasColumn ( $ key ) ) { return $ query -> addSelect ( $ this -> getTable ( ) . '.' . $ key ) ; } $ alias = $ this -> joinMeta ( $ query , $ key ) ; return $ query -> addSelect ( "{$alias}.meta_value as {$key}" ) ; }
996	public function offsetExists ( $ offset ) { if ( $ offset === false ) { return $ this -> falseValueIsSet ; } if ( $ offset === true ) { return $ this -> trueValueIsSet ; } if ( is_int ( $ offset ) || is_string ( $ offset ) ) { return array_key_exists ( $ offset , $ this -> standardStore ) ; } if ( is_float ( $ offset ) ) { return array_key_exists ( ( string ) $ offset , $ this -> floatStore ) ; } if ( is_object ( $ offset ) ) { return $ this -> objectStore -> offsetExists ( $ offset ) ; } if ( is_array ( $ offset ) ) { foreach ( $ this -> arrayKeys as $ index => $ entry ) { if ( $ entry === $ offset ) { $ this -> lastArrayKey = $ offset ; $ this -> lastArrayValue = $ this -> arrayValues [ $ index ] ; return true ; } } } if ( $ offset === null ) { return $ this -> nullValueIsSet ; } return false ; }
7427	public function renderEmbed ( ) { if ( ! $ this -> isValid ( $ this -> source ) ) { throw new InvalidSourceExtensionException ( ) ; } return sprintf ( $ this -> embedDecorator , $ this -> width , $ this -> height , $ this -> source ) ; }
9613	public function register ( Container $ app ) { $ app [ 'guzzle.handler_stack' ] = function ( ) { $ stack = HandlerStack :: create ( ) ; return $ stack ; } ; $ app [ 'guzzle' ] = function ( ) use ( $ app ) { $ client = new HttpClient ( [ 'handler' => $ app [ 'guzzle.handler_stack' ] ] ) ; return $ client ; } ; }
7620	public function createSignedQueryString ( $ path = '/' , $ queryString = '' , $ resource = 'b' , $ permissions = 'r' , $ start = '' , $ expiry = '' , $ identifier = '' ) { $ parts = array ( ) ; if ( $ start !== '' ) { $ parts [ ] = 'st=' . urlencode ( $ start ) ; } $ parts [ ] = 'se=' . urlencode ( $ expiry ) ; $ parts [ ] = 'sr=' . $ resource ; $ parts [ ] = 'sp=' . $ permissions ; if ( $ identifier !== '' ) { $ parts [ ] = 'si=' . urlencode ( $ identifier ) ; } $ parts [ ] = 'sig=' . urlencode ( $ this -> createSignature ( $ path , $ resource , $ permissions , $ start , $ expiry , $ identifier ) ) ; if ( $ queryString != '' ) { $ queryString .= '&' ; } $ queryString .= implode ( '&' , $ parts ) ; return $ queryString ; }
11703	public function getForm ( ) { $ oForm = $ this -> getFormInObject ( ) ; $ sFormContent = $ oForm -> start ; foreach ( $ oForm -> form as $ sValue ) { $ sFormContent .= $ sValue . $ this -> _sSeparator ; } $ sFormContent .= $ oForm -> end ; $ oContainer = new Container ; $ oContainer -> setView ( $ sFormContent ) -> setForm ( $ this ) ; return $ oContainer ; }
9327	protected function registerMarkdownEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md' , 'markdown' ) ; }
12226	public function insertBeforeSelf ( SimpleXMLElement $ new ) { $ tmp = dom_import_simplexml ( $ this ) ; $ node = $ tmp -> ownerDocument -> importNode ( dom_import_simplexml ( $ new ) , true ) ; return simplexml_import_dom ( $ this -> insertNode ( $ tmp , $ node , 'before' ) , get_class ( $ this ) ) ; }
5818	public function updateTagging ( $ fusionID ) { $ configuration = Config :: inst ( ) ; $ classes = ClassInfo :: subclassesFor ( 'DataObject' ) ; unset ( $ classes [ 'DataObject' ] ) ; foreach ( $ classes as $ class ) { $ extensions = $ configuration -> get ( $ class , 'extensions' , Config :: UNINHERITED ) ; if ( is_array ( $ extensions ) && in_array ( 'TaggingExtension' , $ extensions ) ) { $ mode = Versioned :: get_reading_mode ( ) ; Versioned :: reading_stage ( 'Stage' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; if ( $ class :: has_extension ( $ class , 'Versioned' ) ) { foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } Versioned :: reading_stage ( 'Live' ) ; $ objects = $ class :: get ( ) -> filter ( 'FusionTags.ID' , $ fusionID ) ; foreach ( $ objects as $ object ) { $ object -> writeWithoutVersion ( ) ; } } else { foreach ( $ objects as $ object ) { $ object -> write ( ) ; } } Versioned :: set_reading_mode ( $ mode ) ; } } }
11944	private function validateGetPost ( $ data , ConfigContainer $ config , $ position ) { $ argumentName = $ config -> getValue ( 'name' ) ; $ default = $ config -> getValue ( 'default' ) ; if ( ! isset ( $ data [ $ argumentName ] ) ) { if ( $ default !== false ) { return $ default ; } else { throw new RequiredArgumentException ( $ position , $ argumentName ) ; } } return $ data [ $ argumentName ] ; }
5101	public function valuesExp ( $ expression , $ bind = false ) { return $ this -> appendPart ( CmdInsert :: PART_VALUES , $ expression , $ bind ) ; }
8700	public function append ( $ element ) { if ( true === $ element instanceof \ SVGCreator \ Element ) { $ this -> childElements [ ] = $ element ; return $ element ; } else { $ elementCreated = $ this -> factoryElement ( $ element ) ; $ this -> childElements [ ] = $ elementCreated ; return $ elementCreated ; } }
4306	public function time ( $ label = null ) { $ args = \ func_get_args ( ) ; $ this -> internal -> getMetaVals ( $ args , array ( ) , array ( 'label' => null ) ) ; \ extract ( $ args ) ; if ( isset ( $ label ) ) { $ timers = & $ this -> data [ 'timers' ] [ 'labels' ] ; if ( ! isset ( $ timers [ $ label ] ) ) { $ timers [ $ label ] = array ( 0 , \ microtime ( true ) ) ; } elseif ( ! isset ( $ timers [ $ label ] [ 1 ] ) ) { $ timers [ $ label ] [ 1 ] = \ microtime ( true ) ; } } else { $ this -> data [ 'timers' ] [ 'stack' ] [ ] = \ microtime ( true ) ; } }
1203	private function buildExtras ( ItemInterface $ item , array $ options ) { if ( ! empty ( $ options [ 'extras' ] ) ) { foreach ( $ options [ 'extras' ] as $ key => $ value ) { $ item -> setExtra ( $ key , $ value ) ; } } }
4761	public function flush ( ) { if ( $ this -> doNotTrack ) { return ; } if ( empty ( $ this -> queue ) ) { return ; } if ( $ this -> mergePackets ) { $ this -> send ( implode ( "\n" , $ this -> queue ) ) ; } else { foreach ( $ this -> queue as $ data ) { $ this -> send ( $ data ) ; } } $ this -> queue = array ( ) ; $ this -> queueSize = 0 ; }
1910	protected function createTemplate ( Model $ model , string $ templateName ) : Template { if ( isset ( $ this -> options [ 'template' ] ) ) { $ templateName = $ this -> options [ 'template' ] ; } if ( $ model -> customTpl ) { $ templateName = $ model -> customTpl ; } $ template = $ this -> get ( 'contao.framework' ) -> createInstance ( FrontendTemplate :: class , [ $ templateName ] ) ; $ template -> setData ( $ model -> row ( ) ) ; return $ template ; }
9392	protected function skipRowsClause ( ) { $ skipClause = [ ] ; foreach ( $ this -> skipRows as $ cl => $ val ) { $ skipClause [ ] = [ '<>' , $ cl , $ val ] ; } if ( count ( $ skipClause ) > 1 ) array_unshift ( $ skipClause , 'and' ) ; return $ skipClause ; }
12534	public function pagination ( $ lastSeen , $ count ) { $ params = [ 'type' => 2 , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
11519	protected function GenerateAndroidPinicon ( SiteConfig $ config , SiteTree $ owner , & $ metadata ) { $ metadata .= $ owner -> MarkupComment ( 'Android Pinned Icon' ) ; if ( $ config -> fetchAndroidPiniconThemeColor ( ) ) { $ metadata .= $ owner -> MarkupMeta ( 'theme-color' , $ config -> fetchAndroidPiniconThemeColor ( ) ) ; } $ metadata .= $ owner -> MarkupLink ( 'manifest' , '/manifest.json' ) ; }
8427	public static function get ( string $ class ) { if ( isset ( self :: $ controllers [ $ class ] ) === false ) { self :: $ controllers [ $ class ] = new $ class ( ) ; } return self :: $ controllers [ $ class ] ; }
7725	public function url ( $ text , $ title , $ url ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'title' => $ title , 'url' => $ url ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
7652	public function url_stat ( $ path , $ flags ) { $ stat = array ( ) ; $ stat [ 'dev' ] = 0 ; $ stat [ 'ino' ] = 0 ; $ stat [ 'mode' ] = 0 ; $ stat [ 'nlink' ] = 0 ; $ stat [ 'uid' ] = 0 ; $ stat [ 'gid' ] = 0 ; $ stat [ 'rdev' ] = 0 ; $ stat [ 'size' ] = 0 ; $ stat [ 'atime' ] = 0 ; $ stat [ 'mtime' ] = 0 ; $ stat [ 'ctime' ] = 0 ; $ stat [ 'blksize' ] = 0 ; $ stat [ 'blocks' ] = 0 ; $ info = null ; try { $ info = $ this -> getStorageClient ( $ path ) -> getBlobInstance ( $ this -> getContainerName ( $ path ) , $ this -> getFileName ( $ path ) ) ; $ stat [ 'size' ] = $ info -> Size ; $ lastmodified = strtotime ( $ info -> LastModified ) ; $ stat [ 'mtime' ] = $ lastmodified ; $ stat [ 'ctime' ] = $ lastmodified ; $ stat [ 'mode' ] = 0100000 ; return array_values ( $ stat ) + $ stat ; } catch ( BlobException $ ex ) { return false ; } }
9912	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; if ( isset ( $ xmlElement -> fields ) ) { $ this -> fields = array ( ) ; foreach ( $ xmlElement -> fields -> children ( ) as $ field ) { $ this -> fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
5428	public function getInterfaceMethods ( ) { $ methods = array ( ) ; $ interfaces = $ this -> getInterfaces ( ) ; foreach ( $ interfaces as $ interface ) { $ methods = array_merge ( $ methods , get_class_methods ( $ interface ) ) ; } return array_unique ( $ methods ) ; }
9623	public function getConnectionConfig ( $ connection = null ) { if ( $ connection === null ) { $ connection = $ this -> defaultConnection ; } $ config = $ this -> config -> get ( "database.connections.$connection" ) ; if ( ! $ config ) { if ( ! is_string ( $ connection ) ) { $ connection = gettype ( $ connection ) ; } throw new \ InvalidArgumentException ( "No config found for connection: $connection" ) ; } return $ config ; }
12606	public static function getPath ( string $ file ) { $ parts = explode ( '/' , $ file ) ; array_pop ( $ parts ) ; return implode ( '/' , $ parts ) ; }
9522	public function upsertDoc ( string $ collectionName , string $ docId , array $ docOrSubset ) : void { $ doc = $ this -> getDoc ( $ collectionName , $ docId ) ; if ( $ doc ) { $ this -> updateDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } else { $ this -> addDoc ( $ collectionName , $ docId , $ docOrSubset ) ; } }
12531	public function getStatus ( $ applyId ) { $ params = [ 'apply_id' => intval ( $ applyId ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_DEVICE_APPLYSTATUS , $ params ] ) ; }
7694	function MsExcel_GetDrawingLst ( ) { $ lst = array ( ) ; $ dir = '../drawings/' ; $ dir_len = strlen ( $ dir ) ; $ o = $ this -> OpenXML_Rels_GetObj ( $ this -> TBS -> OtbsCurrFile , $ dir ) ; foreach ( $ o -> TargetLst as $ t ) { if ( ( substr ( $ t , 0 , $ dir_len ) === $ dir ) && ( substr ( $ t , - 4 ) === '.xml' ) ) $ lst [ ] = 'xl/drawings/' . substr ( $ t , $ dir_len ) ; } return $ lst ; }
2759	protected function getStorageKey ( $ key , $ limit , $ milliseconds ) { $ window = $ milliseconds * ( floor ( ( microtime ( 1 ) * 1000 ) / $ milliseconds ) ) ; $ date = date ( 'YmdHis' , $ window / 1000 ) ; return $ date . '::' . $ key . '::' . $ limit . '::' . $ milliseconds . '::COUNT' ; }
161	public function orHaving ( $ condition , $ params = [ ] ) { if ( $ this -> having === null ) { $ this -> having = $ condition ; } else { $ this -> having = [ 'or' , $ this -> having , $ condition ] ; } $ this -> addParams ( $ params ) ; return $ this ; }
2356	public function hasBackendUser ( ) : bool { $ token = $ this -> getToken ( BackendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof BackendUser ; }
5310	protected function getPathFromEllipse ( SimpleXMLElement $ ellipse ) { $ mult = 0.55228475 ; return 'M' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] - $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'C' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] + $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . $ ellipse [ 'cx' ] . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . 'C' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] * $ mult ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . ( $ ellipse [ 'cy' ] + $ ellipse [ 'ry' ] * $ mult ) . ' ' . ( $ ellipse [ 'cx' ] - $ ellipse [ 'rx' ] ) . ' ' . $ ellipse [ 'cy' ] . 'Z' ; }
2569	protected function checkAnyTrue ( ) { $ foundTrue = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( $ arg === true ) { $ foundTrue = true ; break ; } } return $ foundTrue ; }
4327	public static function isList ( $ val ) { if ( ! \ is_array ( $ val ) ) { return false ; } $ keys = \ array_keys ( $ val ) ; foreach ( $ keys as $ i => $ key ) { if ( $ i != $ key ) { return false ; } } return true ; }
9248	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { return $ this -> callback ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof ClassName ) { return lcfirst ( $ string ) ; } return strtolower ( $ string ) ; } ) , $ callback ) ; }
1245	public static function chain ( ) { $ providers = func_get_args ( ) ; if ( empty ( $ providers ) ) { throw new \ InvalidArgumentException ( 'No providers in chain' ) ; } return function ( ) use ( $ providers ) { $ provider = array_shift ( $ providers ) ; $ credentials = $ provider ( ) ; while ( ( $ provider = array_shift ( $ providers ) ) && ! ( $ credentials instanceof Credentials ) ) { $ credentials = $ provider ( ) ; } return $ credentials ; } ; }
5038	public function get ( $ key , $ fallback = true ) { foreach ( $ this -> getImages ( ) as $ image ) { if ( $ key == $ image -> getKey ( ) ) { return $ image ; } } return ! $ fallback || self :: ORIGINAL == $ key ? null : $ this -> get ( self :: ORIGINAL ) ; }
7115	protected function getOneQueryBuilder ( $ alias = null , $ indexBy = null ) { return $ this -> createQueryBuilder ( $ alias , $ indexBy ) -> select ( $ alias , 'customer' , 'customer_group' , 'invoice_address' , 'delivery_address' , 'shipment_method' , 'currency' ) -> leftJoin ( $ alias . '.customer' , 'customer' ) -> leftJoin ( $ alias . '.customerGroup' , 'customer_group' ) -> leftJoin ( $ alias . '.invoiceAddress' , 'invoice_address' ) -> leftJoin ( $ alias . '.deliveryAddress' , 'delivery_address' ) -> leftJoin ( $ alias . '.shipmentMethod' , 'shipment_method' ) -> leftJoin ( $ alias . '.currency' , 'currency' ) -> setMaxResults ( 1 ) ; }
11113	public function runPending ( array $ migrations , array $ options = [ ] ) { if ( count ( $ migrations ) === 0 ) { $ this -> notify -> note ( '<info>Nothing to migrate.</info>' ) ; return ; } $ batch = $ this -> repository -> getNextBatchNumber ( ) ; $ step = $ options [ 'step' ] ?? false ; $ this -> notify -> note ( '' ) ; foreach ( $ migrations as $ file ) { $ this -> runUp ( $ file , $ batch ) ; if ( $ step ) { $ batch ++ ; } } }
3009	public function fetch ( $ template , array $ data = [ ] ) { if ( isset ( $ data [ 'template' ] ) ) { throw new \ InvalidArgumentException ( "Duplicate template key found" ) ; } if ( ! is_file ( $ this -> templatePath . $ template ) ) { throw new \ RuntimeException ( "View cannot render `$template` because the template does not exist" ) ; } $ data = array_merge ( $ this -> attributes , $ data ) ; try { ob_start ( ) ; $ this -> protectedIncludeScope ( $ this -> templatePath . $ template , $ data ) ; $ output = ob_get_clean ( ) ; if ( $ this -> layout !== null ) { ob_start ( ) ; $ data [ 'content' ] = $ output ; $ this -> protectedIncludeScope ( $ this -> layout , $ data ) ; $ output = ob_get_clean ( ) ; } } catch ( \ Throwable $ e ) { ob_end_clean ( ) ; throw $ e ; } catch ( \ Exception $ e ) { ob_end_clean ( ) ; throw $ e ; } return $ output ; }
1326	public function getSignableParameters ( ) { $ params = $ this -> parameters ; if ( isset ( $ params [ 'oauth_signature' ] ) ) { unset ( $ params [ 'oauth_signature' ] ) ; } return Util :: buildHttpQuery ( $ params ) ; }
9833	public function setWorkbookPassword ( $ pValue , $ pAlreadyHashed = false ) { if ( ! $ pAlreadyHashed ) { $ pValue = PasswordHasher :: hashPassword ( $ pValue ) ; } $ this -> workbookPassword = $ pValue ; return $ this ; }
3443	public function offsetExists ( $ offset ) { return $ this -> getAccessor ( $ offset ) || $ this -> getAccessorForLanguageField ( $ offset ) ? true : isset ( $ this -> fields [ $ offset ] ) ; }
5419	protected function parseHeaderLine ( $ header_line ) { if ( preg_match ( '/HTTP\/(\d+\.\d+)\s+(\d+)/i' , $ header_line , $ matches ) ) { $ this -> http_version = $ matches [ 1 ] ; $ this -> response_code = $ matches [ 2 ] ; } if ( preg_match ( '/Content-type:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> mime_type = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Location:\s*(.*)/i' , $ header_line , $ matches ) ) { $ this -> location = trim ( $ matches [ 1 ] ) ; } if ( preg_match ( '/Set-cookie:(.*)/i' , $ header_line , $ matches ) ) { $ this -> cookies [ ] = $ this -> parseCookie ( $ matches [ 1 ] ) ; } if ( preg_match ( '/WWW-Authenticate:\s+(\S+)\s+realm=\"(.*?)\"/i' , $ header_line , $ matches ) ) { $ this -> authentication = $ matches [ 1 ] ; $ this -> realm = trim ( $ matches [ 2 ] ) ; } }
2676	public function upsertAclItem ( $ aclId , $ itemValue , $ negated , $ comment = 'Added by Magento Module' , $ subnet = false ) { $ body = [ 'ip' => $ itemValue , 'negated' => $ negated , 'comment' => $ comment ] ; if ( $ subnet ) { $ body [ 'subnet' ] = $ subnet ; } $ url = $ this -> _getApiServiceUri ( ) . 'acl/' . $ aclId . '/entry' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: POST , $ body ) ; return $ result ; }
12781	private function decrypt ( $ encrypted , $ appId ) { try { $ key = $ this -> getAESKey ( ) ; $ ciphertext = base64_decode ( $ encrypted , true ) ; $ iv = substr ( $ key , 0 , 16 ) ; $ decrypted = openssl_decrypt ( $ ciphertext , 'aes-256-cbc' , $ key , OPENSSL_RAW_DATA | OPENSSL_NO_PADDING , $ iv ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_DECRYPT_AES ) ; } try { $ result = $ this -> decode ( $ decrypted ) ; if ( strlen ( $ result ) < 16 ) { return '' ; } $ content = substr ( $ result , 16 , strlen ( $ result ) ) ; $ listLen = unpack ( 'N' , substr ( $ content , 0 , 4 ) ) ; $ xmlLen = $ listLen [ 1 ] ; $ xml = substr ( $ content , 4 , $ xmlLen ) ; $ fromAppId = trim ( substr ( $ content , $ xmlLen + 4 ) ) ; } catch ( BaseException $ e ) { throw new EncryptionException ( $ e -> getMessage ( ) , EncryptionException :: ERROR_INVALID_XML ) ; } if ( $ fromAppId !== $ appId ) { throw new EncryptionException ( 'Invalid appId.' , EncryptionException :: ERROR_INVALID_APPID ) ; } $ dataSet = json_decode ( $ xml , true ) ; if ( $ dataSet && ( JSON_ERROR_NONE === json_last_error ( ) ) ) { $ xml = XML :: build ( $ dataSet ) ; } return $ xml ; }
9950	public function duplicateStyle ( Style $ pCellStyle , $ pRange ) { $ workbook = $ this -> parent ; if ( $ existingStyle = $ this -> parent -> getCellXfByHashCode ( $ pCellStyle -> getHashCode ( ) ) ) { $ xfIndex = $ existingStyle -> getIndex ( ) ; } else { $ workbook -> addCellXf ( $ pCellStyle ) ; $ xfIndex = $ pCellStyle -> getIndex ( ) ; } list ( $ rangeStart , $ rangeEnd ) = Coordinate :: rangeBoundaries ( $ pRange . ':' . $ pRange ) ; if ( $ rangeStart [ 0 ] > $ rangeEnd [ 0 ] && $ rangeStart [ 1 ] > $ rangeEnd [ 1 ] ) { $ tmp = $ rangeStart ; $ rangeStart = $ rangeEnd ; $ rangeEnd = $ tmp ; } for ( $ col = $ rangeStart [ 0 ] ; $ col <= $ rangeEnd [ 0 ] ; ++ $ col ) { for ( $ row = $ rangeStart [ 1 ] ; $ row <= $ rangeEnd [ 1 ] ; ++ $ row ) { $ this -> getCell ( Coordinate :: stringFromColumnIndex ( $ col ) . $ row ) -> setXfIndex ( $ xfIndex ) ; } } return $ this ; }
11912	public function setIndustry ( $ industryOne , $ industryTwo ) { $ params = [ 'industry_id1' => $ industryOne , 'industry_id2' => $ industryTwo , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_SET_INDUSTRY , $ params ] ) ; }
1639	protected function setupCallbacks ( Client $ client , Container $ app , array $ config ) { if ( ! isset ( $ config [ 'callbacks' ] ) || $ config [ 'callbacks' ] ) { $ client -> registerDefaultCallbacks ( ) ; $ client -> registerCallback ( function ( Report $ report ) use ( $ app ) { $ tracker = $ app -> make ( Tracker :: class ) ; if ( $ context = $ tracker -> context ( ) ) { $ report -> setContext ( $ context ) ; } if ( $ job = $ tracker -> get ( ) ) { $ report -> setMetaData ( [ 'job' => $ job ] ) ; } } ) ; } if ( ! isset ( $ config [ 'user' ] ) || $ config [ 'user' ] ) { $ client -> registerCallback ( new CustomUser ( function ( ) use ( $ app ) { if ( $ user = $ app -> auth -> user ( ) ) { if ( method_exists ( $ user , 'attributesToArray' ) && is_callable ( [ $ user , 'attributesToArray' ] ) ) { return $ user -> attributesToArray ( ) ; } if ( $ user instanceof GenericUser ) { $ reflection = new ReflectionClass ( $ user ) ; $ property = $ reflection -> getProperty ( 'attributes' ) ; $ property -> setAccessible ( true ) ; return $ property -> getValue ( $ user ) ; } } } ) ) ; } }
11635	public function getPageByDeviceId ( array $ deviceIdentifier , $ raw = false ) { $ params = [ 'type' => 1 , 'device_identifier' => $ deviceIdentifier , ] ; $ result = $ this -> parseJSON ( 'json' , [ self :: API_RELATION_SEARCH , $ params ] ) ; if ( $ raw === true ) { return $ result ; } $ page_ids = [ ] ; if ( ! empty ( $ result -> data [ 'relations' ] ) ) { foreach ( $ result -> data [ 'relations' ] as $ item ) { $ page_ids [ ] = $ item [ 'page_id' ] ; } } return $ page_ids ; }
5541	public function setFrameFocus ( $ name ) { if ( is_integer ( $ this -> focus ) ) { if ( $ this -> frames [ $ this -> focus ] -> hasFrames ( ) ) { return $ this -> frames [ $ this -> focus ] -> setFrameFocus ( $ name ) ; } } if ( in_array ( $ name , array_keys ( $ this -> names ) ) ) { $ this -> focus = $ this -> names [ $ name ] ; return true ; } return false ; }
1147	protected function isConditionalRule ( $ attribute , $ rule ) { return isset ( $ this -> conditional [ $ attribute ] ) && in_array ( $ rule , $ this -> conditional [ $ attribute ] ) ; }
1574	public function defaultApi ( $ apiName = null ) { if ( is_null ( $ apiName ) ) { return LaravelJsonApi :: $ defaultApi ; } LaravelJsonApi :: defaultApi ( $ apiName ) ; return $ apiName ; }
7191	private function copyNotification ( Model \ SaleNotificationInterface $ source , Model \ SaleNotificationInterface $ target ) { $ this -> copy ( $ source , $ target , [ 'type' , 'data' , 'sentAt' , 'details' ] ) ; }
6244	protected function getPermissionGroupIndex ( $ groups ) { $ index = [ ] ; foreach ( $ groups as $ key => $ presence ) { $ permissions = $ presence -> permissions ( ) ; if ( ! $ permissions ) { continue ; } if ( ! is_array ( $ permissions ) ) { $ permissions = [ $ permissions ] ; } foreach ( $ permissions as $ permission ) { $ index [ $ permission ] = $ key ; } } return $ index ; }
3	private function buildDependency20Info ( $ depArray ) { $ result = array ( ) ; $ optionals = array ( ) ; $ defaultOptionals = array ( ) ; foreach ( $ depArray as $ depType => $ depTypeGroup ) { if ( ! is_array ( $ depTypeGroup ) ) { continue ; } if ( 'required' == $ depType || 'optional' == $ depType ) { foreach ( $ depTypeGroup as $ depItemType => $ depItem ) { switch ( $ depItemType ) { case 'php' : $ result [ ] = new DependencyConstraint ( $ depType , $ this -> parse20VersionConstraint ( $ depItem ) , 'php' , '' ) ; break ; case 'package' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'extension' : $ deps = $ this -> buildDepExtensionConstraints ( $ depItem , $ depType ) ; $ result = array_merge ( $ result , $ deps ) ; break ; case 'subpackage' : $ deps = $ this -> buildDepPackageConstraints ( $ depItem , 'replaces' ) ; $ defaultOptionals += $ deps ; break ; case 'os' : case 'pearinstaller' : break ; default : break ; } } } elseif ( 'group' == $ depType ) { if ( $ this -> isHash ( $ depTypeGroup ) ) { $ depTypeGroup = array ( $ depTypeGroup ) ; } foreach ( $ depTypeGroup as $ depItem ) { $ groupName = $ depItem [ 'attribs' ] [ 'name' ] ; if ( ! isset ( $ optionals [ $ groupName ] ) ) { $ optionals [ $ groupName ] = array ( ) ; } if ( isset ( $ depItem [ 'subpackage' ] ) ) { $ optionals [ $ groupName ] += $ this -> buildDepPackageConstraints ( $ depItem [ 'subpackage' ] , 'replaces' ) ; } else { $ result += $ this -> buildDepPackageConstraints ( $ depItem [ 'package' ] , 'optional' ) ; } } } } if ( count ( $ defaultOptionals ) > 0 ) { $ optionals [ '*' ] = $ defaultOptionals ; } return new DependencyInfo ( $ result , $ optionals ) ; }
10066	public function actionGenerate ( ) { $ input = $ this -> parseArguments ( func_get_args ( ) ) ; $ container = new Container ( ) ; $ container -> set ( GeneratorInterface :: class , array_merge ( [ 'class' => $ this -> generator_fqn ] , $ input [ 'generator' ] ) ) ; $ container -> set ( DbProviderInterface :: class , array_merge ( [ 'class' => $ this -> dbprovider_fqn ] , $ input [ 'dbprovider' ] ) ) ; $ this -> generator_obj = $ container -> get ( GeneratorInterface :: class ) ; if ( ! $ this -> force && ! $ this -> confirmGeneration ( ) ) { return ; } $ this -> dbprovider_obj = $ container -> get ( DbProviderInterface :: class ) ; Console :: startProgress ( 0 , $ this -> count ) ; foreach ( $ this -> dbprovider_obj -> export ( $ this -> count ) as $ count ) { Console :: updateProgress ( $ this -> count - $ count , $ this -> count ) ; } Console :: endProgress ( true ) ; }
7791	public function setClosingBalanceClass ( $ closingBalanceClass ) { if ( ! is_callable ( $ closingBalanceClass ) && ! class_exists ( $ closingBalanceClass ) ) { throw new \ InvalidArgumentException ( '$closingBalanceClass must be a valid classname or a PHP callable' ) ; } $ this -> closingBalanceClass = $ closingBalanceClass ; return $ this ; }
6815	protected function buildFile ( array $ orders , string $ name ) { if ( false === $ path = tempnam ( sys_get_temp_dir ( ) , $ name ) ) { throw new RuntimeException ( "Failed to create temporary file." ) ; } if ( false === $ handle = fopen ( $ path , "w" ) ) { throw new RuntimeException ( "Failed to open '$path' for writing." ) ; } if ( ! empty ( $ headers = $ this -> buildHeaders ( ) ) ) { fputcsv ( $ handle , $ headers , ';' , '"' ) ; } $ supplierTotal = 0 ; $ forwarderTotal = 0 ; foreach ( $ orders as $ order ) { if ( ! empty ( $ row = $ this -> buildRow ( $ order ) ) ) { fputcsv ( $ handle , $ row , ';' , '"' ) ; $ supplierTotal += $ row [ 'payment_total' ] ; $ forwarderTotal += $ row [ 'forwarder_total' ] ; } } fputcsv ( $ handle , [ 'id' => '' , 'number' => '' , 'state' => '' , 'ordered_at' => '' , 'completed_at' => '' , 'supplier' => '' , 'payment_total' => $ supplierTotal , 'payment_date' => '' , 'payment_due_date' => '' , 'carrier' => '' , 'forwarder_total' => $ forwarderTotal , 'forwarder_date' => '' , 'forwarder_due_date' => '' , ] , ';' , '"' ) ; fclose ( $ handle ) ; return $ path ; }
2615	public function isApiKeyValid ( ) { try { $ apiKey = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_API_KEY ) ; $ serviceId = $ this -> scopeConfig -> getValue ( Config :: XML_FASTLY_SERVICE_ID ) ; $ isApiKeyValid = $ this -> api -> checkServiceDetails ( true , $ serviceId , $ apiKey ) ; } catch ( \ Exception $ e ) { return false ; } return ( bool ) $ isApiKeyValid ; }
902	public function isAnonymousClass ( $ index ) { $ tokens = $ this -> tokens ; $ token = $ tokens [ $ index ] ; if ( ! $ token -> isClassy ( ) ) { throw new \ LogicException ( sprintf ( 'No classy token at given index %d.' , $ index ) ) ; } if ( ! $ token -> isGivenKind ( T_CLASS ) ) { return false ; } return $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] -> isGivenKind ( T_NEW ) ; }
2402	public function previewRoute ( $ strName , $ arrParams = array ( ) ) { $ objRouter = System :: getContainer ( ) -> get ( 'router' ) ; $ objContext = $ objRouter -> getContext ( ) ; $ objPreviewContext = clone $ objContext ; $ objPreviewContext -> setBaseUrl ( '/preview.php' ) ; $ objRouter -> setContext ( $ objPreviewContext ) ; $ strUrl = $ objRouter -> generate ( $ strName , $ arrParams ) ; $ strUrl = substr ( $ strUrl , \ strlen ( Environment :: get ( 'path' ) ) + 1 ) ; $ objRouter -> setContext ( $ objContext ) ; return ampersand ( $ strUrl ) ; }
11161	protected function getReplacements ( $ entry ) { $ link = 'https://youtu.be/' . $ entry -> id ; $ title = $ entry -> snippet -> title ; $ author = $ entry -> snippet -> channelTitle ; $ published = date ( $ this -> publishedFormat , strtotime ( $ entry -> snippet -> publishedAt ) ) ; $ views = number_format ( $ entry -> statistics -> viewCount , 0 ) ; $ likes = number_format ( $ entry -> statistics -> likeCount , 0 ) ; $ dislikes = number_format ( $ entry -> statistics -> dislikeCount , 0 ) ; $ favorites = number_format ( $ entry -> statistics -> favoriteCount , 0 ) ; $ comments = number_format ( $ entry -> statistics -> commentCount , 0 ) ; $ durationInterval = new \ DateInterval ( $ entry -> contentDetails -> duration ) ; $ duration = $ durationInterval -> format ( $ this -> durationFormat ) ; return array ( '%link%' => $ link , '%title%' => $ title , '%author%' => $ author , '%published%' => $ published , '%views%' => $ views , '%likes%' => $ likes , '%dislikes%' => $ dislikes , '%favorites%' => $ favorites , '%comments%' => $ comments , '%duration%' => $ duration , ) ; }
10205	public function setIndent ( $ pValue ) { if ( $ pValue > 0 ) { if ( $ this -> getHorizontal ( ) != self :: HORIZONTAL_GENERAL && $ this -> getHorizontal ( ) != self :: HORIZONTAL_LEFT && $ this -> getHorizontal ( ) != self :: HORIZONTAL_RIGHT ) { $ pValue = 0 ; } } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'indent' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> indent = $ pValue ; } return $ this ; }
7045	private function getColumnNamesFromTable ( $ tableName , $ typeFilter = null ) { if ( ! $ this -> connection -> getSchemaManager ( ) -> tablesExist ( [ $ tableName ] ) ) { return [ ] ; } $ result = [ ] ; foreach ( $ this -> connection -> getSchemaManager ( ) -> listTableColumns ( $ tableName ) as $ column ) { if ( ( $ typeFilter === null ) || \ in_array ( $ column -> getType ( ) -> getName ( ) , $ typeFilter , true ) ) { $ result [ $ column -> getName ( ) ] = $ column -> getName ( ) ; } } if ( ! empty ( $ result ) ) { \ asort ( $ result ) ; return $ result ; } return $ result ; }
10623	public static function synchronizeMigrations ( CommandEvent $ event ) { $ packages = $ event -> getComposer ( ) -> getRepositoryManager ( ) -> getLocalRepository ( ) -> getPackages ( ) ; $ installer = $ event -> getComposer ( ) -> getInstallationManager ( ) ; $ appMigrationDir = self :: getDestinationDir ( $ event -> getComposer ( ) ) ; $ io = $ event -> getIO ( ) ; $ areFileMigrated = array ( ) ; $ areFileMigrated [ ] = self :: handlePackage ( '.' , $ event -> getComposer ( ) -> getPackage ( ) , $ io , $ appMigrationDir ) ; foreach ( $ packages as $ package ) { $ areFileMigrated [ ] = self :: handlePackage ( $ installer -> getInstallPath ( $ package ) , $ package , $ io , $ appMigrationDir ) ; } if ( in_array ( true , $ areFileMigrated ) ) { $ io -> write ( "<warning>Some migration files have been imported. " . "You should run `php app/console doctrine:migrations:status` and/or " . "`php app/console doctrine:migrations:migrate` to apply them to your DB." ) ; } }
5417	protected function createResponse ( $ socket ) { $ response = new SimpleHttpResponse ( $ socket , $ this -> route -> getUrl ( ) , $ this -> encoding ) ; $ socket -> close ( ) ; return $ response ; }
3789	protected function getSetValues ( $ arrValue , $ intId , $ strLangCode ) { if ( ( $ arrValue !== null ) && ! is_array ( $ arrValue ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Invalid value provided: %s' , var_export ( $ arrValue , true ) ) ) ; } return array ( 'tstamp' => time ( ) , 'value' => ( string ) $ arrValue [ 'value' ] , 'att_id' => $ this -> get ( 'id' ) , 'langcode' => $ strLangCode , 'item_id' => $ intId , ) ; }
5600	public static function getSeverityAsString ( $ severity ) { static $ map = array ( E_ERROR => 'E_ERROR' , E_WARNING => 'E_WARNING' , E_PARSE => 'E_PARSE' , E_NOTICE => 'E_NOTICE' , E_CORE_ERROR => 'E_CORE_ERROR' , E_CORE_WARNING => 'E_CORE_WARNING' , E_COMPILE_ERROR => 'E_COMPILE_ERROR' , E_COMPILE_WARNING => 'E_COMPILE_WARNING' , E_USER_ERROR => 'E_USER_ERROR' , E_USER_WARNING => 'E_USER_WARNING' , E_USER_NOTICE => 'E_USER_NOTICE' , E_STRICT => 'E_STRICT' , E_RECOVERABLE_ERROR => 'E_RECOVERABLE_ERROR' , E_DEPRECATED => 'E_DEPRECATED' , E_USER_DEPRECATED => 'E_USER_DEPRECATED' , E_ALL => 'E_ALL' ) ; return $ map [ $ severity ] ; }
8884	private function buildPackages ( $ number , $ weight , $ measurement = 'LBS' ) { $ packages = array ( ) ; if ( $ number > 1 ) { $ individual_weight = $ weight / $ number ; for ( $ i = 0 ; $ i < $ number ; $ i ++ ) { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ individual_weight . '</Weight> </PackageWeight> </Package>' ; } } else { $ packages [ ] = '<Package> <PackagingType> <Code>02</Code> </PackagingType> <PackageWeight> <UnitOfMeasurement> <Code>' . $ measurement . '</Code> </UnitOfMeasurement> <Weight>' . $ weight . '</Weight> </PackageWeight> </Package>' ; } return implode ( '' , $ packages ) ; }
9981	public function writeVMLComments ( \ PhpOffice \ PhpSpreadsheet \ Worksheet \ Worksheet $ pWorksheet ) { $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ comments = $ pWorksheet -> getComments ( ) ; $ objWriter -> startElement ( 'xml' ) ; $ objWriter -> writeAttribute ( 'xmlns:v' , 'urn:schemas-microsoft-com:vml' ) ; $ objWriter -> writeAttribute ( 'xmlns:o' , 'urn:schemas-microsoft-com:office:office' ) ; $ objWriter -> writeAttribute ( 'xmlns:x' , 'urn:schemas-microsoft-com:office:excel' ) ; $ objWriter -> startElement ( 'o:shapelayout' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> startElement ( 'o:idmap' ) ; $ objWriter -> writeAttribute ( 'v:ext' , 'edit' ) ; $ objWriter -> writeAttribute ( 'data' , '1' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shapetype' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'coordsize' , '21600,21600' ) ; $ objWriter -> writeAttribute ( 'o:spt' , '202' ) ; $ objWriter -> writeAttribute ( 'path' , 'm,l,21600r21600,l21600,xe' ) ; $ objWriter -> startElement ( 'v:stroke' ) ; $ objWriter -> writeAttribute ( 'joinstyle' , 'miter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'gradientshapeok' , 't' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'rect' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; foreach ( $ comments as $ key => $ value ) { $ this -> writeVMLComment ( $ objWriter , $ key , $ value ) ; } $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
9946	public function cellExists ( $ pCoordinate ) { if ( strpos ( $ pCoordinate , '!' ) !== false ) { $ worksheetReference = self :: extractSheetTitle ( $ pCoordinate , true ) ; return $ this -> parent -> getSheetByName ( $ worksheetReference [ 0 ] ) -> cellExists ( strtoupper ( $ worksheetReference [ 1 ] ) ) ; } if ( ( ! preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_CELLREF . '$/i' , $ pCoordinate , $ matches ) ) && ( preg_match ( '/^' . Calculation :: CALCULATION_REGEXP_NAMEDRANGE . '$/i' , $ pCoordinate , $ matches ) ) ) { $ namedRange = NamedRange :: resolveRange ( $ pCoordinate , $ this ) ; if ( $ namedRange !== null ) { $ pCoordinate = $ namedRange -> getRange ( ) ; if ( $ this -> getHashCode ( ) != $ namedRange -> getWorksheet ( ) -> getHashCode ( ) ) { if ( ! $ namedRange -> getLocalOnly ( ) ) { return $ namedRange -> getWorksheet ( ) -> cellExists ( $ pCoordinate ) ; } throw new Exception ( 'Named range ' . $ namedRange -> getName ( ) . ' is not accessible from within sheet ' . $ this -> getTitle ( ) ) ; } } else { return false ; } } $ pCoordinate = strtoupper ( $ pCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCoordinate ) ) { throw new Exception ( 'Cell coordinate can not be a range of cells.' ) ; } elseif ( strpos ( $ pCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate must not be absolute.' ) ; } return $ this -> cellCollection -> has ( $ pCoordinate ) ; }
5833	protected function headerToArray ( $ header ) { $ tmp = explode ( "\r\n" , $ header ) ; $ headers = array ( ) ; foreach ( $ tmp as $ singleHeader ) { $ delimiter = strpos ( $ singleHeader , ': ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 2 ) ; $ headers [ $ key ] = $ val ; } else { $ delimiter = strpos ( $ singleHeader , ' ' ) ; if ( $ delimiter !== false ) { $ key = substr ( $ singleHeader , 0 , $ delimiter ) ; $ val = substr ( $ singleHeader , $ delimiter + 1 ) ; $ headers [ $ key ] = $ val ; } } } return $ headers ; }
9964	public function getComment ( $ pCellCoordinate ) { $ pCellCoordinate = strtoupper ( $ pCellCoordinate ) ; if ( Coordinate :: coordinateIsRange ( $ pCellCoordinate ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells.' ) ; } elseif ( strpos ( $ pCellCoordinate , '$' ) !== false ) { throw new Exception ( 'Cell coordinate string must not be absolute.' ) ; } elseif ( $ pCellCoordinate == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string.' ) ; } if ( isset ( $ this -> comments [ $ pCellCoordinate ] ) ) { return $ this -> comments [ $ pCellCoordinate ] ; } $ newComment = new Comment ( ) ; $ this -> comments [ $ pCellCoordinate ] = $ newComment ; return $ newComment ; }
12615	public function addAttribute ( AttributeInterface $ attribute ) { if ( isset ( $ this -> attributes [ $ attribute -> getName ( ) ] ) ) trigger_error ( "Attribute " . $ attribute -> getName ( ) . " already exists" , E_USER_NOTICE ) ; $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; }
11147	public function getFromLocation ( Neuron_GameServer_Map_Location $ location ) { $ area = new Neuron_GameServer_Map_Area ( $ location , 1 ) ; $ objects = $ this -> getDisplayObjects ( $ area ) ; $ out = array ( ) ; foreach ( $ objects as $ v ) { if ( $ v -> getLocation ( ) -> equals ( $ location ) ) { $ out [ ] = $ v ; } } return $ out ; }
10109	private function writeMergedCells ( ) { $ mergeCells = $ this -> phpSheet -> getMergeCells ( ) ; $ countMergeCells = count ( $ mergeCells ) ; if ( $ countMergeCells == 0 ) { return ; } $ maxCountMergeCellsPerRecord = 1027 ; $ record = 0x00E5 ; $ i = 0 ; $ j = 0 ; $ recordData = '' ; foreach ( $ mergeCells as $ mergeCell ) { ++ $ i ; ++ $ j ; $ range = Coordinate :: splitRange ( $ mergeCell ) ; list ( $ first , $ last ) = $ range [ 0 ] ; list ( $ firstColumn , $ firstRow ) = Coordinate :: coordinateFromString ( $ first ) ; list ( $ lastColumn , $ lastRow ) = Coordinate :: coordinateFromString ( $ last ) ; $ recordData .= pack ( 'vvvv' , $ firstRow - 1 , $ lastRow - 1 , Coordinate :: columnIndexFromString ( $ firstColumn ) - 1 , Coordinate :: columnIndexFromString ( $ lastColumn ) - 1 ) ; if ( $ j == $ maxCountMergeCellsPerRecord or $ i == $ countMergeCells ) { $ recordData = pack ( 'v' , $ j ) . $ recordData ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; $ recordData = '' ; $ j = 0 ; } } }
7020	private function format_i ( & $ str ) { if ( strstr ( $ str , '%i' ) ) $ str = str_replace ( '%i' , sprintf ( '%02d' , $ this -> min ) , $ str ) ; }
9876	public function writeWorkbook ( Spreadsheet $ spreadsheet , $ recalcRequired = false ) { if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'workbook' ) ; $ objWriter -> writeAttribute ( 'xml:space' , 'preserve' ) ; $ objWriter -> writeAttribute ( 'xmlns' , 'http://schemas.openxmlformats.org/spreadsheetml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ this -> writeFileVersion ( $ objWriter ) ; $ this -> writeWorkbookPr ( $ objWriter ) ; $ this -> writeWorkbookProtection ( $ objWriter , $ spreadsheet ) ; if ( $ this -> getParentWriter ( ) -> getOffice2003Compatibility ( ) === false ) { $ this -> writeBookViews ( $ objWriter , $ spreadsheet ) ; } $ this -> writeSheets ( $ objWriter , $ spreadsheet ) ; $ this -> writeDefinedNames ( $ objWriter , $ spreadsheet ) ; $ this -> writeCalcPr ( $ objWriter , $ recalcRequired ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
10841	public function sayHello ( ) { $ text = $ this -> getHALLogo ( ) ; if ( $ this -> showText ) { $ text .= $ this -> getHelloDave ( ) ; } $ lines = explode ( "\n" , $ text ) ; $ spaces = '' ; if ( $ this -> center ) { $ max_length = 0 ; foreach ( $ lines as $ line ) { $ max_length = max ( $ max_length , Helper :: strlenWithoutDecoration ( $ this -> output -> getFormatter ( ) , $ line ) ) ; } $ numberOfSpaces = floor ( ( $ this -> screenSize [ 0 ] - $ max_length ) / 2 ) ; if ( $ numberOfSpaces > 0 ) { $ spaces = str_repeat ( ' ' , $ numberOfSpaces ) ; } } foreach ( $ lines as $ line ) { $ this -> output -> writeln ( $ spaces . $ line ) ; } }
2639	public function aroundGetElementByPathParts ( \ Closure $ proceed , array $ pathParts ) { $ result = $ proceed ( $ pathParts ) ; if ( $ this -> isLoaded == true || false ) { return $ result ; } if ( ( $ result instanceof Section ) == false ) { return $ result ; } if ( isset ( $ pathParts [ 0 ] ) == false || $ pathParts [ 0 ] != 'system' ) { return $ result ; } $ this -> isLoaded = true ; $ data = $ result -> getData ( ) ; if ( isset ( $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ) == false ) { return $ result ; } $ original = $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] ; $ data [ 'children' ] [ 'full_page_cache' ] [ 'children' ] [ 'fastly_edge_modules' ] [ 'children' ] = array_merge ( $ original , $ this -> loadModlyData ( ) ) ; $ result -> setData ( $ data , $ this -> scopeDefiner -> getScope ( ) ) ; return $ result ; }
10489	public static function unbufferConnection ( Connection $ connection ) { $ wrappedConnection = $ connection -> getWrappedConnection ( ) ; if ( ! $ wrappedConnection instanceof PDOConnection ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with pdo_mysql Doctrine driver.' ) ; } if ( $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) != 'mysql' ) { throw new InvalidArgumentException ( 'unbufferConection can only be used with PDO mysql driver, got "' . $ wrappedConnection -> getAttribute ( PDO :: ATTR_DRIVER_NAME ) . '" instead.' ) ; } if ( $ connection -> isConnected ( ) ) { $ connection -> close ( ) ; } $ connection -> getWrappedConnection ( ) -> setAttribute ( PDO :: MYSQL_ATTR_USE_BUFFERED_QUERY , false ) ; $ connection -> connect ( ) ; }
2432	public function updateAfterRestore ( $ id , $ table , $ data ) { if ( $ table != 'tl_style' ) { return ; } $ this -> Database -> prepare ( "UPDATE tl_style_sheet SET tstamp=? WHERE id=?" ) -> execute ( time ( ) , $ data [ 'pid' ] ) ; $ this -> import ( 'Contao\StyleSheets' , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheet ( $ data [ 'pid' ] ) ; }
1355	protected function defaultSort ( ) { return collect ( $ this -> defaultSort ) -> map ( function ( $ param ) { $ desc = ( $ param [ 0 ] === '-' ) ; $ field = ltrim ( $ param , '-' ) ; return new SortParameter ( $ field , ! $ desc ) ; } ) -> all ( ) ; }
4913	public function add ( $ name , $ entities = null , array $ options = null ) { if ( $ name instanceof DependencyResult ) { return $ this -> addResult ( $ name ) ; } if ( $ name instanceof \ Traversable ) { return $ this -> addTraversable ( $ name ) ; } if ( is_array ( $ name ) ) { return $ this -> addArray ( $ name ) ; } if ( null === $ entities ) { throw new \ UnexpectedValueException ( '$entities must not be null.' ) ; } return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ entities , 'options' => $ options , ] ) ; }
4957	public function onFlush ( OnFlushEventArgs $ args ) { $ dm = $ args -> getDocumentManager ( ) ; $ uow = $ dm -> getUnitOfWork ( ) ; $ filter = function ( $ element ) { return $ element instanceof $ this -> targetDocument && $ element instanceof PermissionsAwareInterface && $ element -> getPermissions ( ) -> hasChanged ( ) ; } ; $ inserts = array_filter ( $ uow -> getScheduledDocumentInsertions ( ) , $ filter ) ; $ updates = array_filter ( $ uow -> getScheduledDocumentUpdates ( ) , $ filter ) ; $ this -> process ( $ inserts , $ dm , $ uow , true ) ; $ this -> process ( $ updates , $ dm , $ uow ) ; }
6089	public function updateMoodboard ( $ id , Moodboard $ moodboard ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'moodboard' => $ moodboard ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
146	protected function moveWatch ( $ fromLiteral , $ toLiteral , $ node ) { if ( ! isset ( $ this -> watchChains [ $ toLiteral ] ) ) { $ this -> watchChains [ $ toLiteral ] = new RuleWatchChain ; } $ node -> moveWatch ( $ fromLiteral , $ toLiteral ) ; $ this -> watchChains [ $ fromLiteral ] -> remove ( ) ; $ this -> watchChains [ $ toLiteral ] -> unshift ( $ node ) ; }
446	public function detachBehaviors ( ) { $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ name => $ behavior ) { $ this -> detachBehavior ( $ name ) ; } }
2994	protected function encode ( $ str ) { if ( empty ( $ str ) || $ this -> charset == 'UTF-8' ) return $ str ; if ( extension_loaded ( 'iconv' ) ) $ out = @ iconv ( "UTF-8" , $ this -> charset . "//IGNORE" , $ str ) ; if ( ! isset ( $ out ) || ! $ out ) $ out = extension_loaded ( 'mbstring' ) ? mb_convert_encoding ( $ str , $ this -> charset , "UTF-8" ) : utf8_decode ( $ str ) ; return $ out ? : $ str ; }
6547	public function close ( ) { $ writer = \ PHPExcel_IOFactory :: createWriter ( $ this -> container , $ this -> format ) ; $ writer -> save ( $ this -> resourcepath ) ; }
6417	public static function size ( IteratorAggregate $ iterable ) : int { if ( $ iterable instanceof Countable ) { return $ iterable -> count ( ) ; } return Iterators :: size ( Iterators :: from ( $ iterable -> getIterator ( ) ) ) ; }
10284	public static function getRangeBoundaries ( $ pRange ) { if ( empty ( $ pRange ) ) { $ pRange = self :: DEFAULT_RANGE ; } $ pRange = strtoupper ( $ pRange ) ; if ( strpos ( $ pRange , ':' ) === false ) { $ rangeA = $ rangeB = $ pRange ; } else { list ( $ rangeA , $ rangeB ) = explode ( ':' , $ pRange ) ; } return [ self :: coordinateFromString ( $ rangeA ) , self :: coordinateFromString ( $ rangeB ) ] ; }
5703	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; return $ this ; }
7701	function OpenDoc_GetPage ( $ Tag , $ Txt , $ Pos , $ Forward , $ LevelStop ) { $ this -> OpenDoc_StylesInit ( ) ; $ p = $ Pos ; while ( ( $ loc = clsTbsXmlLoc :: FindStartTagHavingAtt ( $ Txt , 'text:style-name' , $ p , $ Forward ) ) !== false ) { $ style = $ loc -> GetAttLazy ( 'text:style-name' ) ; if ( ( $ style !== false ) && isset ( $ this -> OpenDoc_Styles [ $ style ] ) ) { $ pbreak = $ this -> OpenDoc_Styles [ $ style ] -> pbreak ; if ( $ pbreak !== false ) { if ( $ Forward ) { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg - 1 ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd ; } } else { if ( $ pbreak === 'before' ) { return $ loc -> PosBeg ; } else { $ loc -> FindEndTag ( ) ; return $ loc -> PosEnd + 1 ; } } } } $ p = ( $ Forward ) ? $ loc -> PosEnd : $ loc -> PosBeg ; } if ( $ Forward ) { $ p = strpos ( $ Txt , '</office:text' ) ; if ( $ p === false ) return false ; return $ p - 1 ; } else { $ loc = clsTbsXmlLoc :: FindStartTag ( $ Txt , 'office:text' , $ Pos , false ) ; if ( $ loc === false ) return false ; return $ loc -> PosEnd + 1 ; } }
10611	public function confirmAction ( $ token ) { $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByConfirmationToken ( $ token ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with confirmation token "%s" does not exist' , $ token ) ) ; } $ user -> setConfirmationToken ( null ) ; $ user -> setEnabled ( true ) ; $ user -> setLastLogin ( new \ DateTime ( ) ) ; $ this -> get ( 'fos_user.user_manager' ) -> updateUser ( $ user ) ; $ response = $ this -> redirect ( $ this -> generateUrl ( 'miky_app_customer_registration_confirmed' ) ) ; $ this -> authenticateUser ( $ user , $ response ) ; return $ response ; }
4159	function pop ( ) { $ response = $ this -> redis -> blPop ( $ this -> key , 10 ) ; if ( $ response ) { list ( $ list , $ serializedJob ) = $ response ; $ job = unserialize ( $ serializedJob ) ; return $ job ; } }
11706	public function storageValidate ( $ validators , $ storage ) { $ errors = [ ] ; foreach ( $ validators as $ kValidate => $ validate ) { if ( ! isset ( $ storage [ $ kValidate ] ) ) { $ errors [ ] = [ 'field' => $ kValidate , 'message' => 'Value ' . $ kValidate . ' not found.' ] ; continue ; } $ error = $ this -> validate ( $ validate , $ storage [ $ kValidate ] ) ; if ( $ error ) $ errors [ ] = [ 'field' => $ kValidate , 'message' => $ error ] ; } return $ errors ; }
9277	public function renderRest ( $ request , $ data , $ statusCode = Response :: HTTP_OK , $ headers = [ ] ) { $ requestSerializer = $ this -> get ( 'ongr_api.request_serializer' ) ; return new Response ( $ requestSerializer -> serializeRequest ( $ request , $ data ) , $ statusCode , array_merge ( [ 'Content-Type' => 'application/' . $ requestSerializer -> checkAcceptHeader ( $ request ) ] , $ headers ) ) ; }
12646	public function setTrue ( $ obData = null ) { $ this -> bStatus = true ; $ this -> obData = $ obData ; return $ this ; }
4418	protected function createRequest ( Content $ content , Location $ location ) { $ request = Request :: create ( '' ) ; $ request -> attributes -> set ( 'content' , $ content ) ; $ request -> attributes -> set ( 'location' , $ location ) ; if ( interface_exists ( 'eZ\Publish\Core\MVC\Symfony\View\ContentValueView' ) ) { $ contentView = new ContentView ( ) ; $ contentView -> setLocation ( $ location ) ; $ contentView -> setContent ( $ content ) ; $ request -> attributes -> set ( 'view' , $ contentView ) ; } return $ request ; }
2925	public function normaliseValue ( $ value , $ quote = '' ) { if ( strlen ( $ quote ) == 0 ) { return trim ( $ value ) ; } $ value = str_replace ( "\\$quote" , $ quote , $ value ) ; $ value = str_replace ( '\\\\' , '\\' , $ value ) ; return $ value ; }
2810	public function initLogging ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; $ this -> logging = Mage :: getModel ( 'sheep_debug/logging' ) ; $ this -> logging -> addFile ( $ helper -> getLogFilename ( $ this -> getStoreId ( ) ) ) ; $ this -> logging -> addFile ( $ helper -> getExceptionLogFilename ( $ this -> getStoreId ( ) ) ) ; Mage :: dispatchEvent ( 'sheep_debug_init_logging' , array ( 'logging' => $ this -> logging ) ) ; $ this -> logging -> startRequest ( ) ; }
8530	private function _convertListFinancialEvents ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMaxResultsPerPage ( ) ) { $ parameters [ 'MaxResultsPerPage' ] = $ request -> getMaxResultsPerPage ( ) ; } if ( $ request -> isSetAmazonOrderId ( ) ) { $ parameters [ 'AmazonOrderId' ] = $ request -> getAmazonOrderId ( ) ; } if ( $ request -> isSetFinancialEventGroupId ( ) ) { $ parameters [ 'FinancialEventGroupId' ] = $ request -> getFinancialEventGroupId ( ) ; } if ( $ request -> isSetPostedAfter ( ) ) { $ parameters [ 'PostedAfter' ] = $ request -> getPostedAfter ( ) ; } if ( $ request -> isSetPostedBefore ( ) ) { $ parameters [ 'PostedBefore' ] = $ request -> getPostedBefore ( ) ; } return $ parameters ; }
9779	private function expect ( $ target , Constraint $ constraint ) : self { assertThat ( $ target , $ this -> hasFlag ( 'negate' ) ? logicalNot ( $ constraint ) : $ constraint , $ this -> message ) ; return $ this ; }
205	public static function wrapText ( $ text , $ indent = 0 , $ refresh = false ) { $ size = static :: getScreenSize ( $ refresh ) ; if ( $ size === false || $ size [ 0 ] <= $ indent ) { return $ text ; } $ pad = str_repeat ( ' ' , $ indent ) ; $ lines = explode ( "\n" , wordwrap ( $ text , $ size [ 0 ] - $ indent , "\n" , true ) ) ; $ first = true ; foreach ( $ lines as $ i => $ line ) { if ( $ first ) { $ first = false ; continue ; } $ lines [ $ i ] = $ pad . $ line ; } return implode ( "\n" , $ lines ) ; }
1008	public static function suggestionList ( $ input , array $ options ) { $ optionsByDistance = [ ] ; $ inputThreshold = mb_strlen ( $ input ) / 2 ; foreach ( $ options as $ option ) { if ( $ input === $ option ) { $ distance = 0 ; } else { $ distance = ( strtolower ( $ input ) === strtolower ( $ option ) ? 1 : levenshtein ( $ input , $ option ) ) ; } $ threshold = max ( $ inputThreshold , mb_strlen ( $ option ) / 2 , 1 ) ; if ( $ distance > $ threshold ) { continue ; } $ optionsByDistance [ $ option ] = $ distance ; } asort ( $ optionsByDistance ) ; return array_keys ( $ optionsByDistance ) ; }
9785	public function parseFor ( ) { $ for_open_token = $ this -> pop ( 'FOR_OPEN' ) ; $ this -> currLine ++ ; $ output = '$for_index = 0; foreach(' . $ for_open_token [ 1 ] [ 1 ] . ' as ' . $ for_open_token [ 1 ] [ 0 ] . ') {' . "\n" ; while ( true ) { list ( $ type , $ value ) = $ this -> peek ( ) ; if ( $ type == 'FOR_CLOSE' ) { $ this -> pop ( ) ; $ output .= '$for_index++; }' . "\n" ; $ this -> currLine ++ ; break ; } else { $ output .= $ this -> parseExpression ( ) ; } } return $ output ; }
9148	public function markAsRead ( $ uid ) { if ( ! $ object = $ this -> model -> find ( $ uid ) ) { abort ( 404 ) ; } $ this -> authorize ( 'update' , $ object ) ; $ object -> markAsRead ( ) ; \ Cache :: tags ( 'response' ) -> flush ( ) ; return $ this -> successJsonResponse ( ) ; }
1669	public function delete ( ) { $ this -> Files -> rrdir ( $ this -> strFolder ) ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFolder ) ) { Dbafs :: deleteResource ( $ this -> strFolder ) ; } }
8392	public function routes ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Type' , 'Subdomain' , 'Method' , 'Path' , 'Action' ] ) ; $ rows = [ ] ; $ routes = Http :: getRoutes ( ) ; usort ( $ routes , function ( array $ a , array $ b ) { if ( $ a [ 'subdomain' ] != $ b [ 'subdomain' ] ) { return strcmp ( $ a [ 'subdomain' ] , $ b [ 'subdomain' ] ) ; } if ( $ a [ 'path' ] != $ a [ 'path' ] ) { return strcmp ( $ a [ 'path' ] , $ b [ 'path' ] ) ; } return strcmp ( $ a [ 'method' ] , $ b [ 'method' ] ) ; } ) ; foreach ( $ routes as $ route ) { $ rows [ ] = [ $ route [ 'type' ] , $ route [ 'subdomain' ] , $ route [ 'method' ] , empty ( $ route [ 'uri' ] ) === false ? '/' . ltrim ( rtrim ( $ route [ 'uri' ] , '/' ) , '/' ) . $ route [ 'path' ] : $ route [ 'path' ] , $ route [ 'action' ] [ 0 ] == '\\' ? $ route [ 'action' ] : rtrim ( $ route [ 'namespace' ] , '\\' ) . '\\' . $ route [ 'action' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
8441	public function updateAction ( string $ production_slug , int $ id , Request $ request , TokenStorageInterface $ token , AuthorizationCheckerInterface $ auth ) : Response { list ( $ post , $ production ) = $ this -> lookupEntity ( Post :: class , $ id , $ production_slug ) ; if ( ! $ auth -> isGranted ( 'edit' , $ post ) ) { throw new AccessDeniedException ( ) ; } $ user = $ token -> getToken ( ) -> getUser ( ) ; if ( null !== $ post -> getParent ( ) ) { $ form = $ this -> form -> create ( ReplyType :: class , $ post ) ; } else { $ form = $ this -> form -> create ( PostType :: class , $ post ) ; } $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ this -> em -> flush ( ) ; $ this -> session -> getFlashBag ( ) -> add ( 'success' , $ this -> translator -> trans ( 'post.updated' , [ ] , BkstgNoticeBoardBundle :: TRANSLATION_DOMAIN ) ) ; return new RedirectResponse ( $ this -> url_generator -> generate ( 'bkstg_board_show' , [ 'production_slug' => $ production -> getSlug ( ) ] ) ) ; } return new Response ( $ this -> templating -> render ( '@BkstgNoticeBoard/Post/update.html.twig' , [ 'form' => $ form -> createView ( ) , 'post' => $ post , 'production' => $ production , ] ) ) ; }
10832	public function actionIndex ( ) { $ searchModel = new SearchState ( Yii :: $ app -> request -> get ( ) ) ; $ dataProvider = $ searchModel -> search ( Yii :: $ app -> request -> queryParams ) ; return $ this -> render ( 'index' , [ 'searchModel' => $ searchModel , 'dataProvider' => $ dataProvider ] ) ; }
12725	public function format ( $ event ) { $ output = $ this -> format ; if ( array_key_exists ( 'extra' , $ event ) === true ) { $ this -> formatExtra ( $ event , $ event [ 'extra' ] ) ; $ event [ 'message' ] = 'Missing Key:' ; } else { $ event [ 'extra' ] = [ ] ; } foreach ( $ event as $ name => $ value ) { if ( is_array ( $ value ) === true && count ( $ value ) === 0 ) { $ value = '' ; } else { $ value = $ this -> normalize ( $ value ) ; } $ output = str_replace ( '%' . $ name . '%' , $ value , $ output ) ; } return trim ( $ output ) ; }
5635	public function paintException ( $ exception ) { parent :: paintException ( $ exception ) ; print '<span class="fail">Exception</span>: ' ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print implode ( ' -&gt; ' , $ breadcrumb ) ; $ message = 'Unexpected exception of type [' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; print ' -&gt; <strong>' . $ this -> htmlEntities ( $ message ) . "</strong><br />\n" ; }
11457	public function pageSummary ( $ pageId , $ beginDate , $ endDate ) { $ params = [ 'page_id' => $ pageId , 'begin_date' => $ beginDate , 'end_date' => $ endDate , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_PAGE , $ params ] ) ; }
6560	public static function splitPath ( $ path ) { $ fragments = [ ] ; while ( true ) { $ cur = dirname ( $ path ) ; if ( $ cur [ 0 ] === DIRECTORY_SEPARATOR ) { $ cur [ 0 ] = '/' ; } if ( $ cur === $ path || ( $ cur === '.' && basename ( $ path ) === $ path ) ) { break ; } $ fragment = trim ( substr ( $ path , strlen ( $ cur ) ) , '/' ) ; if ( ! $ fragments ) { $ fragments [ ] = $ fragment ; } elseif ( $ fragment === '..' && basename ( $ cur ) !== '..' ) { $ cur = dirname ( $ cur ) ; } elseif ( $ fragment !== '.' ) { $ fragments [ ] = $ fragment ; } $ path = $ cur ; } if ( $ path !== '' ) { $ fragments [ ] = trim ( $ path , '/' ) ; } return array_reverse ( $ fragments ) ; }
8563	private function _convertCreateShipment ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'CreateShipment' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsCreateShipmentRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsCreateShipmentRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } if ( $ request -> isSetShippingServiceId ( ) ) { $ parameters [ 'ShippingServiceId' ] = $ request -> getShippingServiceId ( ) ; } if ( $ request -> isSetShippingServiceOfferId ( ) ) { $ parameters [ 'ShippingServiceOfferId' ] = $ request -> getShippingServiceOfferId ( ) ; } return $ parameters ; }
11064	public function upperFirst ( ) { $ this -> value = mb_strtoupper ( mb_substr ( $ this -> value , 0 , 1 , 'UTF-8' ) , 'UTF-8' ) . mb_substr ( $ this -> value , 1 , null , 'UTF-8' ) ; return $ this ; }
11824	public function detect ( ) { $ str = file_get_contents ( $ this -> uri ) ; foreach ( $ this -> getBom ( 'all' ) as $ encoding => $ bom ) { if ( 0 === strncmp ( $ str , $ bom , strlen ( $ bom ) ) ) { return $ encoding ; } } }
8476	public function info ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'info' , $ scope , $ message , $ context , $ config ) ; }
9537	private function getPrefix ( $ parameter ) { $ prefix = null ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ _prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ _prefix ) ) == $ _prefix ) { $ prefix = $ _prefix ; } } return $ prefix ; }
12316	public function editAction ( Request $ request , Category $ category ) { $ deleteForm = $ this -> createDeleteForm ( $ category ) ; $ editForm = $ this -> createForm ( 'BlogBundle\Form\CategoryType' , $ category ) ; $ editForm -> handleRequest ( $ request ) ; if ( $ editForm -> isSubmitted ( ) && $ editForm -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ category ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'category.edited' ) ; return $ this -> redirectToRoute ( 'blog_category_index' ) ; } return array ( 'entity' => $ category , 'edit_form' => $ editForm -> createView ( ) , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
5686	public function expandUrl ( $ url ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } $ location = $ this -> getBaseUrl ( ) ? $ this -> getBaseUrl ( ) : new SimpleUrl ( ) ; return $ url -> makeAbsolute ( $ location -> makeAbsolute ( $ this -> getUrl ( ) ) ) ; }
11996	static public function doctrine ( $ tableName , $ field , $ length = 16 ) { do { $ generate = self :: generate ( $ length ) ; } while ( self :: doctrineQuery ( $ tableName , $ field , $ generate ) ) ; return $ generate ; }
8011	private static function setParityBit ( $ byte ) { $ parity = 1 ; for ( $ i = 1 ; $ i < 8 ; $ i ++ ) { $ parity = ( $ parity + ( ( $ byte >> $ i ) & 1 ) ) % 2 ; } $ byte = $ byte | ( $ parity & 1 ) ; return $ byte ; }
5452	public function startElement ( $ name , $ attributes ) { $ factory = new SimpleTagBuilder ( ) ; $ tag = $ factory -> createTag ( $ name , $ attributes ) ; if ( ! $ tag ) { return true ; } if ( $ tag -> getTagName ( ) === 'label' ) { $ this -> acceptLabelStart ( $ tag ) ; $ this -> openTag ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'form' ) { $ this -> acceptFormStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frameset' ) { $ this -> acceptFramesetStart ( $ tag ) ; return true ; } if ( $ tag -> getTagName ( ) === 'frame' ) { $ this -> acceptFrame ( $ tag ) ; return true ; } if ( $ tag -> isPrivateContent ( ) && ! isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag = $ tag ; } if ( $ tag -> expectEndTag ( ) ) { $ this -> openTag ( $ tag ) ; return true ; } $ this -> acceptTag ( $ tag ) ; return true ; }
11672	protected function onErrorResponse ( CommandInterface $ command , ErrorResponseInterface $ response ) { if ( $ command instanceof ScriptCommand && $ response -> getErrorType ( ) === 'NOSCRIPT' ) { $ response = $ this -> executeCommand ( $ command -> getEvalCommand ( ) ) ; if ( ! $ response instanceof ResponseInterface ) { $ response = $ command -> parseResponse ( $ response ) ; } return $ response ; } if ( $ this -> options -> exceptions ) { throw new ServerException ( $ response -> getMessage ( ) ) ; } return $ response ; }
11586	public function start ( $ taskName , $ repeat = null ) { $ task = new Task ( ) ; $ task -> name ( $ taskName ) ; if ( $ repeat ) { $ task -> repeat ( $ repeat ) ; } if ( isset ( $ this -> _tasks [ $ taskName ] ) ) { throw new Exception ( "Task {$taskName} is already defined." ) ; } $ this -> _tasks [ $ taskName ] = $ task ; $ task -> start ( ) ; return $ task ; }
11193	protected function setPath ( $ url ) { $ cleanURI = str_replace ( '?' . $ _SERVER [ 'QUERY_STRING' ] , '' , $ url ) ; $ this -> pathString = explode ( $ this -> config [ 'site_url' ] , $ cleanURI , 2 ) [ 1 ] ; if ( $ this -> config [ 'lowercase_url' ] ) { $ this -> pathString = strtolower ( $ this -> pathString ) ; } $ this -> path = explode ( '/' , $ this -> pathString ) ; }
8866	private function runTask ( TaskInterface $ task , PayloadInterface $ payload ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Starting execution.' ) ; try { if ( ! $ task -> unless ( ) ) { $ this -> dispatch ( 'runner.task.unless' , $ task , $ payload ) ; $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping because unless() returned boolean false.' ) ; return ; } $ this -> dispatch ( 'runner.task.start' , $ task , $ payload ) ; $ task -> setUp ( ) ; $ exitCode = ( int ) $ task -> run ( $ payload ) ? : 0 ; $ task -> tearDown ( ) ; if ( $ task -> isFailOnError ( ) && $ exitCode !== 0 ) { throw new FailException ( sprintf ( 'Task: %s failed with exit code %s' , get_class ( $ task ) , $ exitCode ) ) ; } $ message = sprintf ( 'Task exited with status code %s' , $ exitCode ) ; if ( $ exitCode === 0 ) { $ this -> logTask ( $ task , LogLevel :: INFO , $ message ) ; } else { $ this -> logTask ( $ task , LogLevel :: WARNING , $ message ) ; } $ this -> dispatch ( 'runner.task.success' , $ task , $ payload , $ exitCode ) ; $ task -> markAsSuccessfullyExecuted ( ) ; } catch ( SkipException $ e ) { $ this -> logTask ( $ task , LogLevel :: INFO , 'Skipping.' ) ; $ this -> dispatch ( 'runner.task.skip' , $ task , $ payload ) ; } catch ( RetryException $ e ) { $ this -> logTask ( $ task , LogLevel :: NOTICE , 'Retry thrown. Starting again.' ) ; $ this -> dispatch ( 'runner.task.retry' , $ task , $ payload ) ; if ( ! $ task -> getMaxRetries ( ) ) { throw new LogicException ( 'A retry exception was thrown, but no retries instance was set.' ) ; } $ task -> getMaxRetries ( ) -> increase ( ) ; $ this -> runTask ( $ task , $ payload ) ; return ; } catch ( FailException $ e ) { $ this -> logTask ( $ task , LogLevel :: WARNING , sprintf ( 'Failure thrown. Given message: %s' , $ e -> getMessage ( ) ) ) ; $ exitCode = $ e -> getCode ( ) ; if ( is_int ( $ exitCode ) ) { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload , $ exitCode ) ; } else { $ this -> dispatch ( 'runner.task.failure' , $ task , $ payload ) ; } throw $ e ; } $ this -> logTask ( $ task , LogLevel :: INFO , 'Execution successful.' ) ; }
10648	private function normalizeRules ( ) { foreach ( $ this -> rules as $ scope => $ rules ) { foreach ( $ rules as $ field => $ rule ) { if ( is_array ( $ rule ) ) { $ this -> rules [ $ scope ] [ $ field ] = implode ( '|' , $ rule ) ; } } } }
10763	public function setPaymentType ( $ paymentType ) { if ( self :: PAYMENT_PEER_TO_PEER !== $ paymentType ) { throw new RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid payment type.' ) ) ; } return $ this -> add ( 'PT' , $ paymentType ) ; }
12752	public function sendConfirmationMessage ( User $ user , Token $ token ) { return $ this -> sendMessage ( $ user -> email , $ this -> confirmationSubject , 'confirmation' , [ 'user' => $ user , 'token' => $ token ] ) ; }
7367	protected function checkInvoiceIntegrity ( SaleItemInterface $ item , SaleItem $ constraint ) { $ sale = $ item -> getSale ( ) ; if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { return ; } if ( empty ( $ sale -> getInvoices ( ) -> toArray ( ) ) ) { return ; } $ min = $ this -> invoiceCalculator -> calculateInvoicedQuantity ( $ item ) ; $ qty = $ item -> getTotalQuantity ( ) ; if ( 1 === bccomp ( $ min , 0 , 3 ) && 1 === bccomp ( $ min , $ qty , 3 ) ) { $ this -> context -> buildViolation ( $ constraint -> quantity_is_lower_than_invoiced , [ '%min%' => $ min , ] ) -> atPath ( 'quantity' ) -> addViolation ( ) ; throw new ValidationFailedException ( ) ; } }
2668	public function getAuthDictionary ( $ version ) { $ name = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> getSingleDictionary ( $ version , $ name ) ; return $ dictionary ; }
4910	public function renderSummary ( SummaryFormInterface $ form ) { $ form -> prepare ( ) ; $ baseFieldset = $ form -> getBaseFieldset ( ) ; if ( ! isset ( $ baseFieldset ) ) { throw new \ InvalidArgumentException ( 'For the Form ' . get_class ( $ form ) . ' there is no Basefieldset' ) ; } $ dataAttributesMarkup = '' ; foreach ( $ form -> getAttributes ( ) as $ dataKey => $ dataValue ) { if ( preg_match ( '/^data-/' , $ dataKey ) ) { $ dataAttributesMarkup .= sprintf ( ' %s="%s"' , $ dataKey , $ dataValue ) ; } } $ markup = '<div class="panel panel-default" style="min-height: 100px;"' . $ dataAttributesMarkup . '> <div class="panel-body"><div class="sf-controls">%s</div>%s</div></div>' ; $ view = $ this -> getView ( ) ; $ buttonMarkup = false === $ form -> getOption ( 'editable' ) ? '' : '<button type="button" class="btn btn-default btn-xs sf-edit">' . '<span class="yk-icon yk-icon-edit"></span> ' . $ view -> translate ( 'Edit' ) . '</button>' ; if ( ( $ controlButtons = $ form -> getOption ( 'control_buttons' ) ) !== null ) { $ buttonMarkup .= PHP_EOL . implode ( PHP_EOL , array_map ( function ( array $ buttonSpec ) use ( $ view ) { return '<button type="button" class="btn btn-default btn-xs' . ( isset ( $ buttonSpec [ 'class' ] ) ? ' ' . $ buttonSpec [ 'class' ] : '' ) . '">' . ( isset ( $ buttonSpec [ 'icon' ] ) ? '<span class="yk-icon yk-icon-' . $ buttonSpec [ 'icon' ] . '"></span> ' : '' ) . $ view -> translate ( $ buttonSpec [ 'label' ] ) . '</button>' ; } , $ controlButtons ) ) ; } $ elementMarkup = $ this -> renderSummaryElement ( $ baseFieldset ) ; return sprintf ( $ markup , $ buttonMarkup , $ elementMarkup ) ; }
7807	protected function closingBalance ( $ text ) { if ( $ line = $ this -> getLine ( '62M' , $ text ) ) { return $ this -> balance ( $ this -> reader -> createClosingBalance ( ) , $ line ) ; } }
10777	private function total_size ( ) { $ arr = array ( "width" => 0 , "height" => 0 ) ; foreach ( $ this -> images as $ image ) { if ( $ arr [ "width" ] < $ image [ "width" ] ) { $ arr [ "width" ] = $ image [ "width" ] ; } $ arr [ "height" ] += $ image [ "height" ] ; } return $ arr ; }
9420	public function search ( HTTPRequest $ request ) { if ( ! $ request -> isAjax ( ) ) { return ; } $ data = [ ] ; if ( $ term = $ request -> getVar ( 'term' ) ) { $ groups = [ ] ; foreach ( $ this -> backend -> getGroupedIcons ( ) as $ group => $ icons ) { $ children = [ ] ; foreach ( $ icons as $ id => $ icon ) { if ( stripos ( $ id , $ term ) !== false ) { $ children [ ] = $ this -> getResultData ( $ this -> getIconData ( $ id ) ) ; } } if ( ! empty ( $ children ) ) { $ groups [ ] = [ 'text' => $ group , 'children' => $ children ] ; } } $ data [ 'results' ] = $ groups ; } return $ this -> respond ( $ data ) ; }
3772	private function buildLanguageString ( $ name , $ screen , $ locale ) { if ( isset ( $ screen [ 'label' ] [ $ locale ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ $ locale ] ; return ; } $ GLOBALS [ 'TL_LANG' ] [ 'MOD' ] [ $ name ] = $ screen [ 'label' ] [ '' ] ; }
12951	public function afterDelete ( ) { if ( ! empty ( $ this -> _tagsForDelete ) ) { $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ class = $ relation -> modelClass ; $ class :: updateAllCounters ( [ 'count' => - 1 ] , [ 'in' , $ class :: primaryKey ( ) , $ this -> _tagsForDelete ] ) ; $ this -> owner -> getDb ( ) -> createCommand ( ) -> delete ( $ relation -> via -> from [ 0 ] , [ key ( $ relation -> via -> link ) => $ this -> owner -> getPrimaryKey ( ) ] ) -> execute ( ) ; } $ this -> _tagsForDelete = [ ] ; } }
11551	public function saveConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_SAVE , $ event ) ; if ( ! $ consignment -> getStatus ( ) ) { $ consignment -> setStatus ( ConsignmentStatusList :: STATUS_NEW ) ; } try { $ adapter -> saveConsignment ( $ consignment ) ; $ this -> consignmentRepository -> saveConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment saving.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_SAVE , $ event ) ; }
7935	public function send ( $ from , $ to , $ msg ) { $ opt = array ( 'sender' => $ from , 'receivers' => array ( $ to ) , 'message' => $ msg ) ; return $ this -> createJob ( $ opt ) ; }
6374	public function transformAndConcat ( callable $ transformer ) : FluentIterable { return self :: from ( Iterables :: concatIterables ( $ this -> transform ( $ transformer ) ) ) ; }
817	private function fixFunction ( Tokens $ tokens , $ startFunctionIndex ) { $ endFunctionIndex = $ tokens -> findBlockEnd ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ startFunctionIndex ) ; $ isMultiline = false ; $ firstWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ startFunctionIndex , $ endFunctionIndex ) ; $ lastWhitespaceIndex = $ this -> findWhitespaceIndexAfterParenthesis ( $ tokens , $ endFunctionIndex , $ startFunctionIndex ) ; foreach ( [ $ firstWhitespaceIndex , $ lastWhitespaceIndex ] as $ index ) { if ( null === $ index || ! Preg :: match ( '/\R/' , $ tokens [ $ index ] -> getContent ( ) ) ) { continue ; } if ( 'ensure_single_line' !== $ this -> configuration [ 'on_multiline' ] ) { $ isMultiline = true ; continue ; } $ newLinesRemoved = $ this -> ensureSingleLine ( $ tokens , $ index ) ; if ( ! $ newLinesRemoved ) { $ isMultiline = true ; } } for ( $ index = $ endFunctionIndex - 1 ; $ index > $ startFunctionIndex ; -- $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> equals ( ')' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; continue ; } if ( $ token -> isGivenKind ( CT :: T_ARRAY_SQUARE_BRACE_CLOSE ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_ARRAY_SQUARE_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( '}' ) ) { $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_CURLY_BRACE , $ index ) ; continue ; } if ( $ token -> equals ( ',' ) ) { $ this -> fixSpace2 ( $ tokens , $ index ) ; if ( ! $ isMultiline && $ this -> isNewline ( $ tokens [ $ index + 1 ] ) ) { $ isMultiline = true ; break ; } } } return $ isMultiline ; }
11555	private function getBonusTotals ( $ dsBegin , $ dsEnd ) { $ query = $ this -> qbGetBonusTotals -> build ( ) ; $ conn = $ query -> getConnection ( ) ; $ bind = [ QBGetTotals :: BND_PERIOD_BEGIN => $ dsBegin , QBGetTotals :: BND_PERIOD_END => $ dsEnd ] ; $ rs = $ conn -> fetchAll ( $ query , $ bind ) ; $ result = [ ] ; foreach ( $ rs as $ one ) { $ accId = $ one [ QBGetTotals :: A_ACC_ID ] ; $ custId = $ one [ QBGetTotals :: A_CUST_ID ] ; $ total = $ one [ QBGetTotals :: A_TOTAL ] ; if ( $ custId ) { $ item = new DTotal ( ) ; $ item -> accountId = $ accId ; $ item -> customerId = $ custId ; $ item -> total = $ total ; $ result [ $ custId ] = $ item ; } } return $ result ; }
12439	public function render ( $ template , $ data ) { $ tplReady = '' ; $ this -> template = $ template ; $ this -> data = $ data ; if ( $ this -> loadTemplate ( ) ) { $ tplReady = $ this -> dataRender ; } if ( Settings :: getInstance ( ) -> get ( 'minifyTemplate' ) && ! Settings :: getInstance ( ) -> inDebug ( ) ) { $ tplReady = $ this -> minify ( $ tplReady ) ; } $ this -> release ( ) ; return $ tplReady ; }
7517	function parse_text ( ) { $ len = $ this -> pos - 1 - $ this -> status [ 'last_pos' ] ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ this -> status [ 'last_pos' ] + 1 , $ len ) : '' ) ; }
9296	private function update ( $ documents , $ repository , $ commitSize ) { if ( count ( $ documents ) > $ commitSize && $ commitSize > 1 ) { $ esResponse = [ ] ; $ i = 1 ; foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; if ( $ i ++ % ( $ commitSize - 1 ) == 0 ) { $ esResponse [ ] = $ this -> crud -> commit ( $ repository ) ; } } } else { foreach ( $ documents as $ document ) { $ id = $ document [ '_id' ] ; unset ( $ document [ '_id' ] ) ; $ this -> crud -> update ( $ repository , $ id , $ document ) ; } $ esResponse = $ this -> crud -> commit ( $ repository ) ; } return json_encode ( $ esResponse ) ; }
4808	public function unschedule_specific_event ( $ timestamp = '' ) { if ( empty ( $ timestamp ) ) { $ timestamp = wp_next_scheduled ( $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } wp_unschedule_event ( $ timestamp , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; }
8370	public function perform ( array $ args = [ ] ) : int { $ this -> args = $ args ; unset ( $ this -> args [ 'messages' ] ) ; $ transport = new Swift_SmtpTransport ( $ args [ 'smtp' ] [ 'host' ] , $ args [ 'smtp' ] [ 'port' ] ) ; $ transport -> setUsername ( $ args [ 'smtp' ] [ 'username' ] ) ; $ transport -> setPassword ( $ args [ 'smtp' ] [ 'password' ] ) ; $ this -> messages = $ args [ 'messages' ] ; foreach ( $ messages as & $ message ) { if ( $ shutdown ) { break ; } $ mailer = new Swift_Mailer ( $ transport ) ; $ m = ( new Swift_Message ( $ message [ 'subject' ] ) ) -> setFrom ( [ $ message [ 'from' ] [ 'email' ] => $ message [ 'from' ] [ 'email' ] ] ) -> setTo ( [ $ message [ 'to' ] [ 'email' ] => $ message [ 'to' ] [ 'name' ] ] ) -> setBody ( $ message [ 'message' ] ) ; $ message [ 'sent' ] = ( $ mailer -> send ( $ m ) === 1 ) ; } return 0 ; }
9493	private function getFolderSize ( $ path ) { $ size = 0 ; foreach ( new RecursiveIteratorIterator ( new RecursiveDirectoryIterator ( $ path ) ) as $ directory ) { $ size += $ directory -> getSize ( ) ; } return $ size ; }
11828	public function setUri ( $ uri ) { if ( ! empty ( $ uri ) && ! is_file ( $ uri ) ) { throw new \ Exception ( sprintf ( 'File %s not found.' , $ uri ) ) ; } $ this -> uri = $ uri ; return $ this ; }
10786	public function run ( $ query , array $ params = array ( ) ) { $ statement = $ this -> pdo -> prepare ( $ query ) ; $ statement -> execute ( $ params ) ; return $ statement ; }
3353	public function updateInfo ( ) { $ this -> cached_data = ( array ) $ this -> api -> __preparedRequest ( 'file' , 'GET' , array ( 'uuid' => $ this -> uuid ) ) ; return $ this -> cached_data ; }
1522	public function process ( StoreInterface $ store , FetchProcess $ request ) { $ record = $ store -> readRecord ( $ request -> getProcess ( ) , $ request -> getEncodingParameters ( ) ) ; return $ this -> reply ( ) -> process ( $ record ) ; }
4726	private function getCachedPlural ( $ singular ) { $ singular = StringHelper :: strtolower ( $ singular ) ; if ( isset ( $ this -> cache [ $ singular ] ) ) { return $ this -> cache [ $ singular ] ; } return false ; }
10770	protected function resolveViewName ( ) { $ viewName = Yii :: $ app -> request -> get ( $ this -> viewParam , $ this -> defaultView ) ; if ( ! is_string ( $ viewName ) || ! preg_match ( '~^\w(?:(?!\/\.{0,2}\/)[\w\/\-\.])*$~' , $ viewName ) ) { if ( YII_DEBUG ) { throw new NotFoundHttpException ( "The requested view \"$viewName\" must start with a word character, must not contain /../ or /./, can contain only word characters, forward slashes, dots and dashes." ) ; } else { throw new NotFoundHttpException ( Yii :: t ( 'yii' , 'The requested view "{name}" was not found.' , [ 'name' => $ viewName ] ) ) ; } } return empty ( $ this -> viewPrefix ) ? $ viewName : $ this -> viewPrefix . '/' . $ viewName ; }
2315	protected function prepareImportantPart ( ) { $ importantPart = $ this -> getImportantPart ( ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ importantPart = array ( 'x' => 0 , 'y' => 0 , 'width' => $ this -> fileObj -> viewWidth , 'height' => $ this -> fileObj -> viewHeight , ) ; $ mode = explode ( '_' , $ this -> resizeMode ) ; if ( $ mode [ 0 ] === 'left' ) { $ importantPart [ 'width' ] = 1 ; } elseif ( $ mode [ 0 ] === 'right' ) { $ importantPart [ 'x' ] = $ importantPart [ 'width' ] - 1 ; $ importantPart [ 'width' ] = 1 ; } if ( $ mode [ 1 ] === 'top' ) { $ importantPart [ 'height' ] = 1 ; } elseif ( $ mode [ 1 ] === 'bottom' ) { $ importantPart [ 'y' ] = $ importantPart [ 'height' ] - 1 ; $ importantPart [ 'height' ] = 1 ; } } if ( ! $ importantPart [ 'width' ] || ! $ importantPart [ 'height' ] ) { return null ; } return new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ; }
10772	public function getMediaTypeMatch ( $ data ) { foreach ( $ this -> getMediaTypes ( ) as $ mediaTypeClass ) { $ instance = forward_static_call ( array ( $ mediaTypeClass , 'check' ) , $ data ) ; if ( $ instance ) { return $ instance ; } } }
8582	public function setAny ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Any' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2214	public function prev ( ) { if ( $ this -> intIndex < 1 ) { return false ; } $ this -> blnDone = false ; $ this -> arrCache = $ this -> resultSet [ -- $ this -> intIndex ] ; return $ this ; }
11328	public function setFormField ( $ value ) { if ( is_array ( $ value ) ) { if ( is_null ( $ this -> formFieldClass ) ) { throw new Exception ( "DB Field incorrectly set up. What is the form class?" ) ; } if ( is_null ( $ this -> _formField ) ) { $ config = $ value ; $ config [ 'class' ] = $ this -> formFieldClass ; $ config [ 'modelField' ] = $ this ; $ value = Yii :: createObject ( $ config ) ; } else { $ settings = $ value ; $ value = $ this -> _formField ; unset ( $ settings [ 'class' ] ) ; Yii :: configure ( $ value , $ settings ) ; } } $ this -> _formField = $ value ; return true ; }
12799	public function getFilePointer ( ) { if ( ! isset ( $ this -> _filePointer ) ) { ini_set ( 'auto_detect_line_endings' , true ) ; $ this -> _filePointer = false ; $ file = null ; if ( isset ( $ this -> local ) && file_exists ( $ this -> local ) ) { $ file = $ this -> local ; $ pathinfo = pathinfo ( $ this -> local ) ; } elseif ( isset ( $ this -> url ) ) { $ fileCacheKey = md5 ( __CLASS__ . __FUNCTION__ . $ this -> url ) ; $ fileContent = Yii :: $ app -> fileCache -> get ( $ fileCacheKey ) ; $ pathinfo = pathinfo ( $ this -> url ) ; $ file = Yii :: $ app -> fileStorage -> getTempFile ( false , $ pathinfo [ 'extension' ] ) ; if ( $ fileContent ) { file_put_contents ( $ file , $ fileContent ) ; } else { if ( ! $ this -> downloadFile ( $ this -> url , $ file ) ) { $ file = null ; } else { Yii :: $ app -> fileCache -> set ( $ fileCacheKey , file_get_contents ( $ file ) , 86400 ) ; } } } if ( isset ( $ file ) ) { $ file = $ this -> normalizeFile ( $ file ) ; } if ( file_exists ( $ file ) ) { $ this -> _filePointer = fopen ( $ file , 'r' ) ; } } return $ this -> _filePointer ; }
8784	protected function log ( $ level , $ message ) { if ( is_array ( $ message ) || is_object ( $ message ) ) { $ message = print_r ( $ message , true ) ; } $ text = '[' . date ( $ this -> timeFormat , time ( ) ) . '] - [' . strtoupper ( $ level ) . '] - [' . http ( ) -> getClientIP ( ) . '] . $ message ; $ this -> save ( $ text ) ; }
1502	public function acceptable ( AcceptHeaderInterface $ accept ) : ? Encoding { foreach ( $ accept -> getMediaTypes ( ) as $ mediaType ) { if ( $ encoding = $ this -> matchesTo ( $ mediaType ) ) { return $ encoding ; } } return null ; }
2087	public static function getDefaultPath ( $ template , $ format ) { $ file = $ template . '.' . $ format ; $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ files [ $ template ] ) ) { return $ rootDir . '/' . self :: $ files [ $ template ] . '/' . $ file ; } $ strPath = null ; try { foreach ( $ container -> get ( 'contao.resource_finder' ) -> findIn ( 'templates' ) -> name ( $ file ) as $ file ) { $ strPath = $ file -> getPathname ( ) ; } } catch ( \ InvalidArgumentException $ e ) { } if ( $ strPath !== null ) { return $ strPath ; } throw new \ Exception ( 'Could not find template "' . $ template . '"' ) ; }
2393	public function addFile ( $ strFile , $ strName = null ) { if ( ! file_exists ( $ this -> strRootDir . '/' . $ strFile ) ) { throw new \ Exception ( "File $strFile does not exist" ) ; } if ( strncmp ( $ strName , '/' , 1 ) === 0 ) { $ strName = substr ( $ strName , 1 ) ; } $ this -> addString ( file_get_contents ( $ this -> strRootDir . '/' . $ strFile ) , $ strName ? : $ strFile , filemtime ( $ this -> strRootDir . '/' . $ strFile ) ) ; }
5547	public function getMethod ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getMethod ( ) ; } return $ this -> frameset -> getMethod ( ) ; }
3976	public function handle ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) || ( $ event -> getProperty ( ) !== 'colname' ) ) { return ; } $ oldColumnName = $ event -> getModel ( ) -> getProperty ( $ event -> getProperty ( ) ) ; $ columnName = $ event -> getValue ( ) ; $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; if ( ( ! $ columnName ) || $ oldColumnName !== $ columnName ) { $ this -> tableManipulator -> checkColumnDoesNotExist ( $ metaModel -> getTableName ( ) , $ columnName ) ; $ colNames = array_keys ( $ metaModel -> getAttributes ( ) ) ; if ( in_array ( $ columnName , $ colNames ) ) { throw new \ RuntimeException ( sprintf ( $ event -> getEnvironment ( ) -> getTranslator ( ) -> translate ( 'columnExists' , 'ERR' ) , $ columnName , $ metaModel -> getTableName ( ) ) ) ; } } }
12173	protected static function addReflectionArguments ( Definition $ factory , ReflectionFunctionAbstract $ reflectionFunction = null ) { if ( ! $ reflectionFunction ) { $ callable = $ factory -> getCallable ( ) ; if ( is_array ( $ callable ) ) { $ reflectionFunction = new ReflectionMethod ( $ callable [ 0 ] , $ callable [ 1 ] ) ; } else { $ reflectionFunction = new ReflectionFunction ( $ callable ) ; } } foreach ( $ reflectionFunction -> getParameters ( ) as $ arg ) { try { $ name = $ arg -> getName ( ) ; $ required = ! $ arg -> isOptional ( ) ; if ( $ argClass = $ arg -> getClass ( ) ) { $ factory -> addClassArgument ( $ name , $ argClass -> getName ( ) , $ required ) ; } else { $ default = ( $ required ? null : $ arg -> getDefaultValue ( ) ) ; $ factory -> addScalarArgument ( $ name , null , $ required , $ default ) ; } } catch ( ReflectionException $ re ) { throw UnresolvableArgumentException :: fromReflectionParam ( $ arg , $ reflectionFunction , $ re ) ; } } }
5320	public function waitReady ( ) { $ x = 0 ; while ( $ x ++ < 100 ) { usleep ( self :: WAIT_IDLE ) ; if ( $ this [ self :: STARTED_MARKER ] === true ) { return $ this ; } } throw new \ RuntimeException ( 'Wait process running timeout for child pid ' . $ this -> getPid ( ) ) ; }
11387	private function hydrate ( ) { if ( true === $ this -> hydrated ) { return ; } $ this -> filesystem -> get ( $ this -> file ) ; $ this -> hydrated = true ; }
6856	protected static function equinoxMarch ( $ year , $ vsop = true ) { $ month = 3 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
2112	public function generate ( ) { global $ objPage ; $ obj404 = $ this -> prepare ( ) ; $ objPage = $ obj404 -> loadDetails ( ) ; $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'regular' ] ( ) ; header ( 'HTTP/1.1 404 Not Found' ) ; $ objHandler -> generate ( $ objPage ) ; }
9916	public function configure ( array $ modelConfigurations ) { if ( empty ( $ modelConfigurations ) ) { throw new \ LogicException ( 'Supply at least one model or model configuration!' ) ; } foreach ( $ modelConfigurations as $ className ) { $ modelClass = $ className ; if ( is_subclass_of ( $ className , 'Illuminate\Database\Eloquent\Model' ) ) { $ config = new ModelConfig ( ) ; $ config -> setModelClass ( $ modelClass ) ; } else if ( is_subclass_of ( $ className , 'Label305\AujaLaravel\Config\ModelConfig' ) ) { $ config = new $ className ( ) ; $ modelClass = $ config -> getModelClass ( ) ; } else { throw new \ InvalidArgumentException ( "Model configuration should be class name string of either a ModelConfig or Eloquent subclass." ) ; } $ model = new Model ( $ modelClass ) ; $ this -> models [ $ modelClass ] = $ model ; $ this -> relations [ $ modelClass ] = [ ] ; $ configResolver = new ConfigResolver ( $ config , $ model ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; $ this -> findColumns ( $ this -> models [ $ modelClass ] ) ; $ this -> configs [ $ modelClass ] = $ configResolver -> resolve ( ) ; } $ this -> findRelations ( array_values ( $ this -> models ) ) ; }
12497	public static function deleteMany ( array $ ids = array ( ) , $ connection ) { if ( ! is_array ( $ ids ) ) { throw new ClusterpointException ( "\"->deleteMany()\" function: \"_id\" is not in valid format." , 9002 ) ; } $ connection -> method = 'DELETE' ; $ connection -> action = '' ; foreach ( $ ids as & $ id ) { $ id = ( string ) $ id ; } $ connection -> query = json_encode ( $ ids ) ; return self :: sendQuery ( $ connection ) ; }
5775	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ roles = $ this -> mapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) ) ; } catch ( QueryFailureException $ e ) { $ roles = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ roles ) ; }
5312	protected function getHTMLFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<!doctype html> <html> <head> <title>' . htmlspecialchars ( $ fontOptions [ 'id' ] ) . '</title> <style> @font-face { font-family: "' . $ fontOptions [ 'id' ] . '"; src: url("' . $ fontFile . '") format("svg"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.woff") format("woff"), url("' . substr ( $ fontFile , 0 , - 4 ) . '.ttf") format("truetype"); font-weight: normal; font-style: normal; } body { font-family: sans-serif; color: #444; line-height: 1.5; font-size: 16px; padding: 20px; } * { -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box; margin: 0; paddin: 0; } .glyph{ display: inline-block; width: 120px; margin: 10px; text-align: center; vertical-align: top; background: #eee; border-radius: 10px; box-shadow: 1px 1px 5px rgba(0, 0, 0, .2); } .glyph-icon{ padding: 10px; display: block; font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 64px; line-height: 1; } .glyph-icon:before{ content: attr(data-icon); } .class-name{ font-size: 12px; } .glyph > input{ display: block; width: 100px; margin: 5px auto; text-align: center; font-size: 12px; cursor: text; } .glyph > input.icon-input{ font-family: "' . $ fontOptions [ 'id' ] . '"; font-size: 16px; margin-bottom: 10px; } </style> </head> <body> <section id="glyphs">' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= '<div class="glyph"> <div class="glyph-icon" data-icon="&#x' . $ unicode . ';"></div> <div class="class-name">icon-' . $ glyph . '</div> <input type="text" readonly="readonly" value="&amp;#x' . $ unicode . ';" /> <input type="text" readonly="readonly" value="\\' . $ unicode . '" /> <input type="text" readonly="readonly" value="&#x' . $ unicode . ';" class="icon-input" /> </div>' ; } $ html .= '</section> </body> </html>' ; return $ html ; }
10259	public function getPhone ( $ state_code = null , $ zip = null , $ include_toll_free = false ) { if ( ! empty ( $ zip ) ) { $ areacodes = Zipcode :: where ( 'zip' , $ zip ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } else { $ state_code = ! empty ( $ state_code ) ? $ state_code : $ this -> getState ( ) -> code ; $ areacodes = Zipcode :: where ( 'state_code' , $ state_code ) -> orderByRaw ( Database :: random ( ) ) -> first ( ) -> area_codes ; } $ code_list = explode ( ',' , $ areacodes ) ; if ( $ include_toll_free === true ) { $ code_list [ ] = 800 ; $ code_list [ ] = 888 ; $ code_list [ ] = 877 ; $ code_list [ ] = 866 ; $ code_list [ ] = 855 ; } $ areacode = $ this -> fromArray ( $ code_list ) ; $ prefix = rand ( 100 , 999 ) ; $ number = rand ( 1 , 9999 ) ; return $ areacode . '-' . $ prefix . '-' . str_pad ( $ number , 4 , '0' , STR_PAD_LEFT ) ; }
1332	protected function readWithFilters ( $ record , EncodingParametersInterface $ parameters ) { $ query = $ this -> newQuery ( ) -> whereKey ( $ record -> getKey ( ) ) ; $ this -> applyFilters ( $ query , collect ( $ parameters -> getFilteringParameters ( ) ) ) ; return $ query -> exists ( ) ? $ record : null ; }
3775	public function maxChildren ( $ conditionType ) { $ factory = $ this -> factories -> has ( $ conditionType ) ? $ this -> getFactory ( $ conditionType ) : null ; if ( ! $ factory instanceof NestablePropertyConditionFactoryInterface ) { if ( null !== $ value = $ this -> fallbackFactory -> maxChildren ( $ conditionType ) ) { return $ value ; } return 0 ; } return $ factory -> maxChildren ( ) ; }
1131	public function inSameScope ( $ other ) { foreach ( $ this -> getScopedColumns ( ) as $ fld ) { if ( $ this -> $ fld != $ other -> $ fld ) return false ; } return true ; }
10741	protected function buildRecord ( ) { $ res = [ ] ; foreach ( $ this -> clause_records as $ tbl ) { $ res [ ] = $ this -> quote ( $ tbl ) . '.*' ; } if ( ! empty ( $ res ) ) { return [ join ( ', ' , $ res ) ] ; } else { return [ ] ; } }
8310	public function standardizeUrlFormat ( & $ rules , $ pageUrl ) { if ( ! is_string ( $ pageUrl ) || $ pageUrl === "" || ! is_array ( $ rules ) || ! array_key_exists ( $ pageUrl , $ rules ) ) { return ; } $ oldIndex = $ pageUrl ; if ( $ pageUrl [ 0 ] !== '/' ) { $ pageUrl = '/' . $ pageUrl ; } $ len = strlen ( $ pageUrl ) ; if ( $ len > 1 && $ pageUrl [ $ len - 1 ] === '/' ) { $ pageUrl = rtrim ( $ pageUrl , '/' ) ; } if ( $ oldIndex !== $ pageUrl ) { $ rules [ $ pageUrl ] = $ rules [ $ oldIndex ] ; unset ( $ rules [ $ oldIndex ] ) ; } }
12123	public function onEntryUpdate ( ContentfulEntryEvent $ e ) { $ entry = $ e -> getEntry ( ) ; $ key = $ this -> getCacheKeyItem ( $ entry -> getId ( ) , 'uri' ) ; $ urisForItemOption = Option :: fromValue ( $ this -> cache -> fetch ( $ key ) , false ) ; if ( $ urisForItemOption -> isEmpty ( ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Entry "%s" is not used.' , $ entry -> getId ( ) ) ) ; } ) ; return ; } $ urisForItem = $ urisForItemOption -> get ( ) ; foreach ( $ urisForItem as $ uri => $ bool ) { $ key = $ this -> getCacheKeyRequest ( sha1 ( $ uri ) , 'lastmodified' ) ; $ lastModified = $ this -> cache -> fetch ( $ key ) ; if ( $ lastModified >= $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) { Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ lastModified , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] "%s" was last modified at "%s". Entry is older.' , $ uri , $ lastModified ) ) ; } ) ; continue ; } $ this -> cache -> save ( $ key , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ; Option :: fromValue ( $ this -> logger ) -> map ( function ( LoggerInterface $ logger ) use ( $ entry , $ uri ) { $ logger -> debug ( sprintf ( '[ContentfulBundle:RequestLastModifiedCache] Setting last modified time for "%s" to "%s".' , $ uri , $ entry -> getUpdatedAt ( ) -> format ( 'r' ) ) ) ; } ) ; } }
167	protected static function loadMimeTypes ( $ magicFile ) { if ( $ magicFile === null ) { $ magicFile = static :: $ mimeMagicFile ; } $ magicFile = Yii :: getAlias ( $ magicFile ) ; if ( ! isset ( self :: $ _mimeTypes [ $ magicFile ] ) ) { self :: $ _mimeTypes [ $ magicFile ] = require $ magicFile ; } return self :: $ _mimeTypes [ $ magicFile ] ; }
8089	static protected function encode ( $ number ) { $ k = self :: $ encoder ; preg_match_all ( "/[1-9][0-9]|[0-9]/" , $ number , $ a ) ; $ n = '' ; $ o = count ( $ k ) ; foreach ( $ a [ 0 ] as $ i ) { if ( $ i < $ o ) { $ n .= $ k [ $ i ] ; } else { $ n .= '1' . $ k [ $ i - $ o ] ; } } return $ n ; }
9404	protected static function prepare ( Collection & $ collection , $ component ) { $ instance = new $ component ; $ type = $ instance -> type ( ) ; if ( empty ( $ type ) === false ) { $ parameters = array ( $ instance -> get ( ) ) ; $ type === 'http' && $ parameters = $ instance -> get ( ) ; $ class = array ( $ collection , 'set' . ucfirst ( $ type ) ) ; call_user_func_array ( $ class , $ parameters ) ; } return $ instance ; }
11228	protected function getUrl ( $ section , array $ uriParams = [ ] ) { $ endpoint = rtrim ( $ this -> getEndpoint ( ) , '/' ) ; $ section = ltrim ( $ section , '/' ) ; $ params = http_build_query ( $ uriParams ) ; if ( $ params ) { return sprintf ( "%s/%s?%s" , $ endpoint , $ section , $ params ) ; } else { return sprintf ( "%s/%s" , $ endpoint , $ section ) ; } }
10618	public function steptwo ( ) { $ input = Input :: only ( array ( 'name' , 'email' , 'comment' , 'to_email' , 'to_name' ) ) ; $ input [ 'name' ] = $ this -> quickSanitize ( $ input [ 'name' ] ) ; $ input [ 'email' ] = $ this -> quickSanitize ( $ input [ 'email' ] ) ; $ input [ 'comment' ] = $ this -> quickSanitize ( $ input [ 'comment' ] ) ; return view ( 'lasallecmscontact::step_two_form' , [ 'input' => $ input , 'message' => false , ] ) ; }
8921	protected function parseRelationship ( $ node ) { $ rel = array ( ) ; $ x = preg_replace ( '/\(.*?\)/' , '' , $ node -> text ( 'marc:subfield[@code="w"]' ) ) ; if ( ! empty ( $ x ) ) { $ rel [ 'id' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="t"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'title' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="g"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'parts' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="x"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'issn' ] = $ x ; } $ x = $ node -> text ( 'marc:subfield[@code="z"]' ) ; if ( ! empty ( $ x ) ) { $ rel [ 'isbn' ] = $ x ; } return $ rel ; }
6522	public function isCompatibleForMerge ( Field $ other ) { if ( $ this -> name !== $ other -> name ) { return false ; } if ( $ this -> type !== $ other -> type ) { return false ; } if ( $ this -> rule !== $ other -> rule ) { return false ; } if ( $ this -> className !== $ other -> className ) { return false ; } if ( ! array_intersect ( $ this -> anyOfClassNames , $ other -> anyOfClassNames ) ) { return false ; } return true ; }
89	public function write ( array $ hash , $ options = 448 ) { $ dir = dirname ( $ this -> path ) ; if ( ! is_dir ( $ dir ) ) { if ( file_exists ( $ dir ) ) { throw new \ UnexpectedValueException ( $ dir . ' exists and is not a directory.' ) ; } if ( ! @ mkdir ( $ dir , 0777 , true ) ) { throw new \ UnexpectedValueException ( $ dir . ' does not exist and could not be created.' ) ; } } $ retries = 3 ; while ( $ retries -- ) { try { file_put_contents ( $ this -> path , static :: encode ( $ hash , $ options ) . ( $ options & self :: JSON_PRETTY_PRINT ? "\n" : '' ) ) ; break ; } catch ( \ Exception $ e ) { if ( $ retries ) { usleep ( 500000 ) ; continue ; } throw $ e ; } } }
6242	public function reload ( ) : self { if ( $ this -> loaded === false ) { return $ this ; } clearstatcache ( false , $ this -> raw ) ; $ this -> loaded = false ; return $ this ; }
7881	public function read ( $ date ) { try { return $ this -> files -> get ( $ this -> path ( $ date ) ) ; } catch ( FileNotFoundException $ e ) { throw new FilesystemException ( 'There was an reading the log.' ) ; } }
6772	protected function didInvoiceCountryChanged ( SaleInterface $ sale ) { $ saleCs = $ this -> persistenceHelper -> getChangeSet ( $ sale ) ; $ oldCountry = $ newCountry = null ; $ oldAddress = isset ( $ saleCs [ 'invoiceAddress' ] ) ? $ saleCs [ 'invoiceAddress' ] [ 0 ] : $ sale -> getInvoiceAddress ( ) ; if ( null !== $ oldAddress ) { $ oldAddressCs = $ this -> persistenceHelper -> getChangeSet ( $ oldAddress ) ; $ oldCountry = isset ( $ oldAddressCs [ 'country' ] ) ? $ oldAddressCs [ 'country' ] [ 0 ] : $ oldAddress -> getCountry ( ) ; } if ( null !== $ newAddress = $ sale -> getInvoiceAddress ( ) ) { $ newCountry = $ newAddress -> getCountry ( ) ; } if ( $ oldCountry !== $ newCountry ) { return true ; } return false ; }
7580	protected function verifyUrl ( ) { $ UrlArray = explode ( "?" , $ this -> Url ) ; if ( strpos ( $ UrlArray [ 0 ] , "$" ) !== false ) { throw new InvalidURLException ( get_called_class ( ) , "Configured URL is " . $ this -> Url ) ; } return true ; }
12330	public function get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug = null ) { $ source_file = $ filename ; if ( defined ( 'SCRIPT_DEBUG' ) && true === SCRIPT_DEBUG && ! empty ( $ filename_debug ) ) { $ source_file = $ filename_debug ; } $ path = realpath ( trailingslashit ( $ relative_path ) . $ source_file ) ; return WP_Url_Util :: get_instance ( ) -> convert_absolute_path_to_url ( $ path ) ; }
2815	public function addCollection ( Varien_Data_Collection_Db $ collection ) { $ info = Mage :: getModel ( 'sheep_debug/collection' ) ; $ info -> init ( $ collection ) ; $ key = $ info -> getClass ( ) ; if ( ! array_key_exists ( $ key , $ this -> collections ) ) { $ this -> collections [ $ key ] = $ info ; } $ this -> collections [ $ key ] -> incrementCount ( ) ; }
9666	private function writeFill ( XMLWriter $ objWriter , Fill $ pFill ) { if ( $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_LINEAR || $ pFill -> getFillType ( ) === Fill :: FILL_GRADIENT_PATH ) { $ this -> writeGradientFill ( $ objWriter , $ pFill ) ; } elseif ( $ pFill -> getFillType ( ) !== null ) { $ this -> writePatternFill ( $ objWriter , $ pFill ) ; } }
11059	public static function files ( $ path , array $ extensions = array ( ) ) { $ files = array ( ) ; $ it = new \ RecursiveDirectoryIterator ( $ path ) ; $ filter = false ; if ( ! empty ( $ extensions ) && is_array ( $ extensions ) ) { $ filter = true ; } foreach ( new \ RecursiveIteratorIterator ( $ it ) as $ file ) { if ( $ filter ) { $ f = explode ( '.' , $ file ) ; $ ext = strtolower ( array_pop ( $ f ) ) ; if ( in_array ( $ ext , $ extensions ) ) { $ files [ ] = $ file ; } } else { $ files [ ] = $ file ; } } return $ files ; }
8915	public function encode ( $ value , $ b = 62 ) { $ r = ( int ) $ value % $ b ; $ result = $ this -> base [ $ r ] ; $ q = floor ( ( int ) $ value / $ b ) ; while ( $ q ) { $ r = $ q % $ b ; $ q = floor ( $ q / $ b ) ; $ result = $ this -> base [ $ r ] . $ result ; } return $ result ; }
6641	public function init ( ) { $ this -> query = $ this -> controller -> query ; if ( $ this -> query ) { $ modelClass = Yii :: createObject ( $ this -> query -> modelClass ) ; $ this -> modelClass = $ modelClass ; $ this -> tableName = $ modelClass :: tableName ( ) ; } parent :: init ( ) ; }
11374	private function getInjectHint ( \ ReflectionMethod $ method , \ ReflectionParameter $ parameter ) { $ hint = Psi :: it ( $ this -> reader -> getMethodAnnotations ( $ method ) ) -> filter ( new IsInstanceOf ( Di \ DiInjectHintAnnotation :: class ) ) -> filter ( function ( Di \ DiInjectHintAnnotation $ i ) use ( $ parameter ) { return $ i -> getParameter ( ) === $ parameter -> getName ( ) ; } ) -> getFirst ( ) ; if ( $ hint !== null ) { return $ hint ; } try { if ( $ parameter -> getClass ( ) === null ) { throw new \ InvalidArgumentException ( "Cannot inject constructor-param '{$parameter->getName()}' into {$method->getDeclaringClass()->getName()}. " . 'The parameter does not have a an @Inject hint and it has no type-hint.' ) ; } } catch ( \ ReflectionException $ e ) { } return Di \ Inject \ ByType :: create ( $ parameter -> getName ( ) , Util :: normalizeFqcn ( ( string ) $ parameter -> getType ( ) ) ) ; }
10565	protected function formatJson ( $ response ) { $ response -> getHeaders ( ) -> set ( 'Content-Type' , 'application/json; charset=UTF-8' ) ; if ( $ response -> data !== null ) { $ options = $ this -> encodeOptions ; if ( $ this -> prettyPrint ) { $ options |= JSON_PRETTY_PRINT ; } $ response -> content = Json :: encode ( $ response -> data , $ options ) ; } }
1765	public function colorize ( $ row , $ label ) { switch ( $ row [ 'action' ] ) { case 'CONFIGURATION' : case 'REPOSITORY' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_blue">$2</span>' , $ label ) ; break ; case 'CRON' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_green">$2</span>' , $ label ) ; break ; case 'ERROR' : $ label = preg_replace ( '@^(.*</span> )(.*)$@U' , '$1 <span class="tl_red">$2</span>' , $ label ) ; break ; default : if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'colorizeLogEntries' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ label = $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ row , $ label ) ; } } break ; } return '<div class="ellipsis">' . $ label . '</div>' ; }
12150	public function checkReservedCodes ( ) { $ reserved = $ this -> getReservedCodes ( ) ; foreach ( $ reserved as $ factoryClass => $ reservedForFactory ) { foreach ( $ reserved as $ checkInFactory => $ reservedInCheckFactory ) { if ( $ checkInFactory == $ factoryClass ) { continue ; } if ( $ reservedInCheckFactory [ 0 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 0 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } if ( $ reservedInCheckFactory [ 1 ] >= $ reservedForFactory [ 0 ] && $ reservedInCheckFactory [ 1 ] <= $ reservedForFactory [ 1 ] ) { throw new \ RuntimeException ( sprintf ( 'The reserved codes for factory "%s" [%d - %d] superimposed on "%s" factory [%d - %d].' , $ checkInFactory , $ reservedInCheckFactory [ 0 ] , $ reservedInCheckFactory [ 1 ] , $ factoryClass , $ reservedForFactory [ 0 ] , $ reservedForFactory [ 1 ] ) ) ; } } } }
11904	public function getLogModel ( $ refresh = false ) { $ config = $ this -> config ; if ( isset ( $ config [ 'logModel' ] ) ) { if ( ! is_object ( $ config [ 'logModel' ] ) ) { if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] ] ) -> one ( ) ; } else { return DataInterfaceLog :: get ( $ config [ 'logModel' ] ) ; } } if ( $ refresh ) { return DataInterfaceLog :: find ( ) -> where ( [ 'id' => $ config [ 'logModel' ] -> primaryKey ] ) -> one ( ) ; } return $ config [ 'logModel' ] ; } return ; }
11229	public function init ( ) { $ this -> pluginClient = new PluginClient ( $ this -> httpClient ? : HttpClientDiscovery :: find ( ) , $ this -> plugins ) ; $ this -> client = new HttpMethodsClient ( $ this -> pluginClient , $ this -> messageFactory ? : MessageFactoryDiscovery :: find ( ) ) ; }
5293	protected function execute ( InputInterface $ input , OutputInterface $ output ) { $ directory = $ input -> getArgument ( 'directory' ) ; $ outputFile = $ input -> getArgument ( 'output-file' ) ; $ generator = new IconFontGenerator ; $ output -> writeln ( 'reading files from "' . $ directory . '" ...' ) ; $ generator -> generateFromDir ( $ directory , array ( 'id' => $ input -> getOption ( 'name' ) ? : 'SVGFont' , ) , $ input -> getOption ( 'rename-files' ) ) ; $ output -> writeln ( 'writing font to "' . $ outputFile . '" ...' ) ; file_put_contents ( $ outputFile , $ generator -> getFont ( ) -> getXML ( ) ) ; $ output -> getFormatter ( ) -> setStyle ( 'success' , new OutputFormatterStyle ( null , null , array ( 'bold' , 'reverse' ) ) ) ; $ output -> writeln ( '<success>created ' . $ outputFile . ' successfully</success>' ) ; }
11024	protected function buildGroupBy ( ) { $ result = [ ] ; foreach ( $ this -> clause_groupby as $ grp ) { $ result [ ] = $ grp [ 0 ] ? $ grp [ 1 ] : $ this -> quote ( $ grp [ 1 ] ) ; } return $ result ; }
11343	public function addField ( FormField $ field ) { $ this -> fields [ ] = $ field ; if ( $ field -> getName ( ) == null ) { $ field -> setName ( 'name_' . count ( $ this -> fields ) ) ; } if ( $ field -> getId ( ) == null ) { $ field -> setId ( 'id_' . count ( $ this -> fields ) ) ; } if ( $ field instanceof FileField ) { $ this -> formTags [ 'enctype' ] = 'multipart/form-data' ; } }
4638	private function buildBody ( $ body , string $ charset ) : Mime \ Message { if ( $ body instanceof Mime \ Message ) { return $ body ; } if ( is_string ( $ body ) ) { $ mimePart = new Mime \ Part ( $ body ) ; $ mimePart -> type = $ body !== strip_tags ( $ body ) ? Mime \ Mime :: TYPE_HTML : Mime \ Mime :: TYPE_TEXT ; $ body = $ mimePart ; } $ body -> charset = $ charset ; $ message = new Mime \ Message ( ) ; $ message -> setParts ( [ $ body ] ) ; return $ message ; }
10193	public static function getQueryPreview ( QueryBuilder $ query = null ) { if ( empty ( $ query ) ) { return "" ; } $ sql = str_replace ( '?' , "'%s'" , $ query -> toSql ( ) ) ; $ bindings = $ query -> getBindings ( ) ; return vsprintf ( $ sql , $ bindings ) ; }
10995	public function write ( string $ contents , int $ opts = 0 ) : bool { if ( $ this -> prepareWrite ( ) !== true ) { $ this -> error = "failed to write '{$this->path}; {$this->error}" ; return false ; } return $ this -> writeFile ( $ contents , $ opts ) ; }
7758	protected function loadMappingInformation ( array $ config , ContainerBuilder $ container ) { $ this -> drivers = array ( ) ; if ( $ config [ 'auto_mapping' ] ) { foreach ( array_keys ( $ container -> getParameter ( 'kernel.bundles' ) ) as $ bundle ) { if ( ! isset ( $ config [ 'mappings' ] [ $ bundle ] ) ) { $ config [ 'mappings' ] [ $ bundle ] = array ( 'mapping' => true , 'is_bundle' => true , ) ; } } } $ container -> setAlias ( 'hydra.naming_strategy' , new Alias ( $ config [ 'naming_strategy' ] , false ) ) ; foreach ( $ config [ 'mappings' ] as $ mappingName => $ mappingConfig ) { if ( null !== $ mappingConfig && false === $ mappingConfig [ 'mapping' ] ) { continue ; } $ mappingConfig = array_replace ( array ( 'dir' => false , 'type' => false , 'prefix' => false , ) , ( array ) $ mappingConfig ) ; $ mappingConfig [ 'dir' ] = $ container -> getParameterBag ( ) -> resolveValue ( $ mappingConfig [ 'dir' ] ) ; if ( ! isset ( $ mappingConfig [ 'is_bundle' ] ) ) { $ mappingConfig [ 'is_bundle' ] = ! is_dir ( $ mappingConfig [ 'dir' ] ) ; } if ( $ mappingConfig [ 'is_bundle' ] ) { $ bundle = null ; foreach ( $ container -> getParameter ( 'kernel.bundles' ) as $ name => $ class ) { if ( $ mappingName === $ name ) { $ bundle = new \ ReflectionClass ( $ class ) ; break ; } } if ( null === $ bundle ) { throw new \ InvalidArgumentException ( sprintf ( 'Bundle "%s" does not exist or it is not enabled.' , $ mappingName ) ) ; } $ mappingConfig = $ this -> getMappingDriverBundleConfigDefaults ( $ mappingConfig , $ bundle , $ container ) ; if ( ! $ mappingConfig ) { continue ; } } $ this -> validateMappingConfiguration ( $ mappingConfig , $ mappingName ) ; $ this -> setMappingDriverConfig ( $ mappingConfig , $ mappingName ) ; } $ this -> registerMappingDrivers ( $ config , $ container ) ; }
5548	public function getUrl ( ) { if ( is_integer ( $ this -> focus ) ) { $ url = $ this -> frames [ $ this -> focus ] -> getUrl ( ) ; $ url -> setTarget ( $ this -> getPublicNameFromIndex ( $ this -> focus ) ) ; } else { $ url = $ this -> frameset -> getUrl ( ) ; } return $ url ; }
12758	public static function getNew ( ) { $ class = new MediaLink ; $ medialink = get_class_vars ( get_class ( $ class ) ) ; foreach ( $ medialink as $ name => $ default ) : $ class :: set ( $ name , null ) ; $ class :: set ( "objectType" , "medialink" ) ; endforeach ; return $ class ; }
8697	protected function validateMandatoryAttribs ( ) { foreach ( static :: $ mandatoryFields as $ field ) { if ( ! array_key_exists ( $ field , $ this -> attributes ) ) { throw new \ SVGCreator \ SVGException ( "The field " . $ field . " does not exist for " . static :: TYPE . "." , 1 ) ; } } }
11254	public function drop ( ) : array { $ touched = [ ] ; $ this -> pdo -> beginTransaction ( ) ; foreach ( $ this -> getViews ( ) as $ view ) { $ this -> pdo -> exec ( "drop view if exists {$view} cascade" ) ; $ touched [ ] = [ 'view' , $ view ] ; } foreach ( $ this -> getTables ( ) as $ table ) { $ this -> pdo -> exec ( "drop table if exists {$table} cascade" ) ; $ touched [ ] = [ 'table' , $ table ] ; } $ this -> pdo -> commit ( ) ; return $ touched ; }
1121	public function ancestorsAndSelf ( ) { return $ this -> newNestedSetQuery ( ) -> where ( $ this -> getLeftColumnName ( ) , '<=' , $ this -> getLeft ( ) ) -> where ( $ this -> getRightColumnName ( ) , '>=' , $ this -> getRight ( ) ) ; }
1218	public function setConfig ( array $ configuration ) { $ this -> config = Functions \ arrayMergeDeep ( $ this -> config , $ this -> resolver -> resolveOptions ( $ configuration ) ) ; }
5565	public function head ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } if ( $ this -> getUrl ( ) ) { $ url = $ url -> makeAbsolute ( $ this -> getUrl ( ) ) ; } $ response = $ this -> user_agent -> fetchResponse ( $ url , new SimpleHeadEncoding ( $ parameters ) ) ; $ this -> page = new SimplePage ( $ response ) ; return ! $ response -> isError ( ) ; }
9015	function getRoot ( ) { $ sm = $ this -> sl -> getServiceLocator ( ) ; $ event = $ sm -> get ( 'Application' ) -> getMvcEvent ( ) ; return $ event -> getViewModel ( ) ; }
5134	private static function createUri ( string $ scheme , string $ host , ? int $ port , string $ user , string $ password , string $ path , string $ query , string $ fragment ) : \ One \ Uri { return new Uri ( $ scheme , $ host , $ port , $ path , $ query , $ fragment , $ user , $ password ) ; }
10401	private function countSourceItems ( $ sources ) { $ count = 0 ; foreach ( $ sources as $ source ) { $ count += count ( $ source ) ; } return $ count ; }
8531	public function listFinancialEventsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1633	protected function fireLogEvent ( $ level , $ message , array $ context = [ ] ) { if ( ! isset ( $ this -> dispatcher ) ) { return ; } if ( class_exists ( MessageLogged :: class ) ) { $ this -> dispatcher -> dispatch ( new MessageLogged ( $ level , $ message , $ context ) ) ; } else { $ this -> dispatcher -> fire ( 'illuminate.log' , compact ( 'level' , 'message' , 'context' ) ) ; } }
1154	public function makeReplacements ( $ message , $ attribute , $ rule , $ parameters ) { if ( is_object ( $ rule ) ) { $ rule = get_class ( $ rule ) ; } return $ this -> callValidator ( 'makeReplacements' , [ $ message , $ attribute , $ rule , $ parameters ] ) ; }
6135	public function search ( Search $ search , $ returnType = self :: RETURN_OBJECTS , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'returnType' => $ returnType ] , 'body' => json_encode ( [ 'search' => $ search ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> call ( 'v1/search' , $ parameters , self :: METHOD_POST , $ cachePolicy ) ; $ result = new SearchResult ( $ result ) ; return $ result ; }
6020	public function removeMediaFromDeploymentSite ( $ id , $ mediaIds ) { $ parameters = [ 'query' => [ 'mediaIds' => $ mediaIds ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '/media' , $ parameters ) ; return $ result ; }
6177	protected function executeDelete ( ) { foreach ( $ this -> tableData as $ key => $ row ) { if ( $ this -> where && ! $ this -> where -> execute ( $ row ) ) { continue ; } unset ( $ this -> tableData [ $ key ] ) ; } $ this -> tableData = array_values ( $ this -> tableData ) ; }
12880	public function register ( ) { if ( ! $ this -> validate ( ) ) { return false ; } $ this -> user -> setAttributes ( [ 'email' => $ this -> email , 'username' => $ this -> username , 'password' => $ this -> password ] ) ; return $ this -> user -> register ( ) ; }
7161	private function initialize ( Model \ SaleInterface $ sale , array $ options = [ ] ) { $ this -> lineNumber = 1 ; $ this -> view = new SaleView ( ) ; $ this -> types = $ this -> registry -> getTypesForSale ( $ sale ) ; foreach ( $ this -> types as $ type ) { $ type -> configureOptions ( $ sale , $ this -> view , $ options ) ; } $ this -> options = $ this -> getOptionsResolver ( ) -> resolve ( $ options ) ; $ this -> view -> setTemplate ( $ this -> options [ 'template' ] ) ; if ( ! is_null ( $ this -> options [ 'ati' ] ) ) { $ this -> view -> setAti ( $ this -> options [ 'ati' ] ) ; } else { $ this -> view -> setAti ( $ sale -> isAtiDisplayMode ( ) ) ; } $ this -> formatter = $ this -> formatterFactory -> create ( $ this -> options [ 'locale' ] , $ sale -> getCurrency ( ) -> getCode ( ) ) ; foreach ( $ this -> types as $ type ) { $ type -> setFormatter ( $ this -> formatter ) ; } }
3199	protected function getRange ( $ tags ) { $ range = $ this -> timeLine -> find ( $ tags , TimePoint :: TARGET_SERVER ) ; TimePoint :: sort ( $ range ) ; return $ range ; }
1364	public function register ( ) { $ this -> bindNeomerx ( ) ; $ this -> bindService ( ) ; $ this -> bindInboundRequest ( ) ; $ this -> bindRouteRegistrar ( ) ; $ this -> bindApiRepository ( ) ; $ this -> bindExceptionParser ( ) ; $ this -> bindRenderer ( ) ; $ this -> mergePackageConfig ( ) ; }
3786	public function addListener ( $ eventName , $ listener , $ priority = 200 ) { $ dispatcher = $ this -> getServiceContainer ( ) -> getEventDispatcher ( ) ; $ dispatcher -> addListener ( $ eventName , $ listener , $ priority ) ; return $ this ; }
7326	private function configureTaxableMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Pricing \ Model \ TaxableInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> taxableClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'taxGroup' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'taxGroup' , 'targetEntity' => Pricing \ Entity \ TaxGroup :: class , 'joinColumns' => [ [ 'name' => 'tax_group_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> taxableClassCache [ ] = $ class ; }
6799	public function installCountries ( $ code = 'US' ) { $ countryNames = Intl :: getRegionBundle ( ) -> getCountryNames ( ) ; if ( ! isset ( $ countryNames [ $ code ] ) ) { throw new InvalidArgumentException ( "Invalid default country code '$code'." ) ; } asort ( $ countryNames ) ; $ this -> generate ( Country :: class , $ countryNames , $ code ) ; }
9458	private function mapAdminRoutes ( ) { $ this -> adminGroup ( function ( ) { $ this -> name ( 'foundation.' ) -> group ( function ( ) { Routes \ Admin \ DashboardRoute :: register ( ) ; Routes \ Admin \ SettingsRoutes :: register ( ) ; Routes \ Admin \ SystemRoutes :: register ( ) ; } ) ; } ) ; }
12545	public function listen ( $ event , callable $ callback , $ priority = 100 ) { $ this -> event -> on ( $ event , $ callback , $ priority ) ; }
9020	public function getUniqueWords ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ words = $ analysis -> getKeyValuesByFrequency ( ) ; return array_unique ( array_keys ( $ words ) ) ; }
6766	public function onAddressChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } if ( $ this -> handleAddressChange ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; $ this -> scheduleContentChangeEvent ( $ sale ) ; } }
3316	protected function initFromSpecString ( $ specString ) { $ pattern = '/ ( (?:[a-zA-Z0-9-]+) (?: \| (?:[a-zA-Z0-9-]+) )? ) # option attribute operators ([:+?])? # value types (?:=(boolean|string|number|date|file|dir|url|email|ip|ipv6|ipv4))? /x' ; $ ret = preg_match ( $ pattern , $ specString , $ regs ) ; if ( $ ret === false || $ ret === 0 ) { throw new Exception ( 'Incorrect spec string' ) ; } $ orig = $ regs [ 0 ] ; $ name = $ regs [ 1 ] ; $ attributes = isset ( $ regs [ 2 ] ) ? $ regs [ 2 ] : null ; $ type = isset ( $ regs [ 3 ] ) ? $ regs [ 3 ] : null ; $ short = null ; $ long = null ; if ( strpos ( $ name , '|' ) !== false ) { list ( $ short , $ long ) = explode ( '|' , $ name ) ; } else if ( strlen ( $ name ) === 1 ) { $ short = $ name ; } else if ( strlen ( $ name ) > 1 ) { $ long = $ name ; } $ this -> short = $ short ; $ this -> long = $ long ; if ( strpos ( $ attributes , ':' ) !== false ) { $ this -> required ( ) ; } else if ( strpos ( $ attributes , '+' ) !== false ) { $ this -> multiple ( ) ; } else if ( strpos ( $ attributes , '?' ) !== false ) { $ this -> optional ( ) ; } else { $ this -> flag ( ) ; } if ( $ type ) { $ this -> isa ( $ type ) ; } }
11972	protected function validateParams ( Event $ event ) { return ( $ this -> genericParamValidation ( $ event ) && $ this -> firstParamValidation ( $ event ) && $ this -> secondParamValidation ( $ event ) ) ; }
7265	public static function select ( $ queryString = "" , array $ queryParams = [ ] ) { $ tableName = static :: tableName ( ) ; $ rows = Db :: query ( " select $tableName.* from $tableName $queryString " , $ queryParams , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ model = new static ; foreach ( $ row as $ column => $ val ) $ model -> $ column = $ model -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ model ; } return new Collection ( $ collection ) ; }
10255	public function getApartment ( ) { $ types = [ 'Apt.' , 'Apartment' , 'Ste.' , 'Suite' , 'Box' ] ; if ( $ this -> getBool ( true , false ) ) { $ extra = $ this -> getLetter ( ) ; } else { $ extra = $ this -> getInteger ( 1 , 9999 ) ; } $ type = $ this -> fromArray ( $ types ) ; return $ type . ' ' . $ extra ; }
1434	public static function decamelize ( $ value ) { if ( isset ( self :: $ decamelized [ $ value ] ) ) { return self :: $ decamelized [ $ value ] ; } return self :: $ decamelized [ $ value ] = strtolower ( preg_replace ( '/(.)(?=[A-Z])/u' , '$1_' , $ value ) ) ; }
3460	public function find ( string $ method , string $ path ) : Route { $ matcher = new UrlMatcher ( $ this -> routeCollection , new RequestContext ( '/' , $ method ) ) ; try { $ route = $ matcher -> match ( $ path ) ; } catch ( ResourceNotFoundException $ exception ) { throw RouterException :: noRouteMatchesRequestedUri ( $ path , $ method ) ; } catch ( SymfonyMethodNotAllowedException $ exception ) { throw RouterException :: methodNotAllowed ( $ path , $ exception -> getAllowedMethods ( ) ) ; } $ routeName = $ route [ '_route' ] ; unset ( $ route [ '_route' ] ) ; return $ this -> routes [ $ routeName ] -> withAttributes ( $ route ) ; }
12747	public function getInputSpecification ( ) { $ dateValidator = $ this -> getDateValidator ( ) ; $ dateValidatorName = get_class ( $ dateValidator ) ; return [ 'name' => $ this -> getName ( ) , 'required' => true , 'filters' => [ Filter \ StringTrim :: class => [ 'name' => Filter \ StringTrim :: class ] , Filter \ StripNewlines :: class => [ 'name' => Filter \ StripNewlines :: class ] , Filter \ StripTags :: class => [ 'name' => Filter \ StripTags :: class ] , TimeToDateTime :: class => [ 'name' => TimeToDateTime :: class , 'options' => [ 'time_format' => $ this -> getFormat ( ) ] ] ] , 'validators' => [ $ dateValidatorName => $ dateValidator ] ] ; }
8846	public function getBlogPosts ( ) { $ blogPosts = BlogPost :: get ( ) -> filter ( "ParentID" , $ this -> ID ) ; $ this -> extend ( 'updateGetBlogPosts' , $ blogPosts ) ; return $ blogPosts ; }
9050	private static function checkLevel ( $ level ) { if ( $ level != LogLevel :: ALERT && $ level != LogLevel :: CRITICAL && $ level != LogLevel :: DEBUG && $ level != LogLevel :: EMERGENCY && $ level != LogLevel :: ERROR && $ level != LogLevel :: INFO && $ level != LogLevel :: NOTICE && $ level != LogLevel :: WARNING ) { throw new \ Psr \ Log \ InvalidArgumentException ( "Invalid log level provided!" ) ; } }
11940	public function getUrl ( string $ sCode , array $ aParams = array ( ) ) : string { if ( isset ( $ _SERVER ) && isset ( $ _SERVER [ 'HTTP_HOST' ] ) ) { foreach ( Config :: get ( 'route' ) as $ sHost => $ oHost ) { if ( ( ! strstr ( $ sHost , '/' ) && $ sHost == $ _SERVER [ 'HTTP_HOST' ] ) || ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) ) { if ( strstr ( $ sHost , '/' ) && strstr ( $ _SERVER [ 'HTTP_HOST' ] . $ _SERVER [ 'REQUEST_URI' ] , $ sHost ) ) { $ this -> _sBaseUri = preg_replace ( '#^[^/]+#' , '' , $ sHost ) ; } if ( isset ( $ oHost -> routes ) ) { foreach ( $ oHost -> routes as $ sKey => $ oRoute ) { if ( $ sKey === $ sCode ) { $ sRoute = $ this -> _sBaseUri . $ oRoute -> route ; if ( isset ( $ oRoute -> constraints ) ) { foreach ( $ oRoute -> constraints as $ sName => $ sType ) { if ( ! isset ( $ aParams [ $ sName ] ) ) { $ aParams [ $ sName ] = '' ; } if ( preg_match ( '#' . $ sType . '#' , $ aParams [ $ sName ] ) ) { if ( $ aParams [ $ sName ] ) { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '/' . $ aParams [ $ sName ] , $ sRoute ) ; } else { $ sRoute = str_replace ( '[/:' . $ sName . ']' , '' , $ sRoute ) ; } $ sRoute = str_replace ( '[:' . $ sName . ']' , $ aParams [ $ sName ] , $ sRoute ) ; continue ; } else if ( isset ( $ oRoute -> defaults_constraints ) && isset ( $ oRoute -> defaults_constraints -> { $ sName } ) && preg_match ( '#' . $ sType . '#' , $ oRoute -> defaults_constraints -> { $ sName } ) ) { continue ; } throw new \ Exception ( 'For the route ' . $ sCode . ' the parameter ' . $ sName . ' is not good!' ) ; } } return $ sRoute ; } } } } } } }
10592	public function display ( $ level = 0 ) { $ value = $ this -> getContent ( ) ; if ( null === $ value ) { $ value = 'null' ; } elseif ( is_object ( $ value ) ) { $ value = get_class ( $ value ) ; } elseif ( is_array ( $ value ) ) { $ value = 'Array' ; } $ ret = str_repeat ( ' ' , $ level * 4 ) . $ value . "\n" ; $ children = $ this -> getChildren ( ) ; foreach ( $ children as $ child ) { $ ret .= $ child -> display ( $ level + 1 ) ; } return $ ret ; }
12351	public function invalidate ( string $ api_session = null ) { if ( empty ( $ api_session ) === false && is_string ( $ api_session ) === true ) { $ session = Model \ Session :: where ( 'code' , $ api_session ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _SESSION [ 'api_session' ] ) === false && is_string ( $ _SESSION [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _SESSION [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } elseif ( empty ( $ _GET [ 'api_session' ] ) === false && is_string ( $ _GET [ 'api_session' ] ) === true ) { $ session = Model \ Session :: where ( 'code' , $ _GET [ 'api_session' ] ) -> first ( ) ; if ( $ session !== null ) { $ session -> delete ( ) ; } } $ this -> details = false ; $ _SESSION [ 'api_session' ] = null ; $ _GET [ 'api_session' ] = null ; }
12338	public function changeSecurityQuestionAction ( ) { if ( ! $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getLoginRoute ( ) ) ; } $ url = $ this -> url ( ) -> fromRoute ( null , [ 'action' => 'change-security-question' ] ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getChangeSecurityQuestionForm ( ) ; $ form -> setObject ( $ this -> cmsAuthentication ( ) -> getIdentity ( ) ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post ) { $ identity = $ this -> getUserService ( ) -> changeSecurityQuestion ( $ post ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/index/change-security-question-success' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
3052	public function getItemIndexValue ( $ id , $ name ) { return $ this -> itemIndex -> getItemValue ( $ id , \ common_session_SessionManager :: getSession ( ) -> getInterfaceLanguage ( ) , $ name ) ; }
11999	static protected function phalconQuery ( $ modelName , $ field , $ generate ) { $ return = \ Phalcon \ Mvc \ Model :: query ( ) -> setModelName ( $ modelName ) -> where ( "$field = :value:" ) -> bind ( array ( 'value' => $ generate ) ) -> execute ( ) ; return ( boolean ) $ return -> count ( ) ; }
3550	protected function registerParser ( ) { $ this -> app -> singleton ( EmojiParser :: class , function ( Container $ app ) { return new EmojiParser ( $ app -> make ( RepositoryInterface :: class ) ) ; } ) ; }
10180	private function storeCurrentCell ( ) { if ( $ this -> currentCellIsDirty && ! empty ( $ this -> currentCoordinate ) ) { $ this -> currentCell -> detach ( ) ; $ stored = $ this -> cache -> set ( $ this -> cachePrefix . $ this -> currentCoordinate , $ this -> currentCell ) ; if ( ! $ stored ) { $ this -> __destruct ( ) ; throw new PhpSpreadsheetException ( "Failed to store cell {$this->currentCoordinate} in cache" ) ; } $ this -> currentCellIsDirty = false ; } $ this -> currentCoordinate = null ; $ this -> currentCell = null ; }
7068	static function getUnits ( ) { return [ static :: PIECE , static :: METER , static :: CENTIMETER , static :: MILLIMETER , static :: INCH , static :: FOOT , static :: KILOGRAM , static :: GRAM , static :: CUBIC_METER , static :: LITER , static :: MILLILITER , static :: DAY , static :: HOUR , static :: MINUTE , static :: SECOND , ] ; }
4416	public function onKernelResponse ( FilterResponseEvent $ event ) { $ routeName = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; if ( $ routeName !== FallbackRouter :: ROUTE_NAME ) { return ; } $ response = $ event -> getResponse ( ) ; if ( ! $ response instanceof LegacyResponse ) { return ; } if ( ! $ this -> legacyMode && ( int ) $ response -> getStatusCode ( ) === Response :: HTTP_NOT_FOUND ) { $ moduleResult = $ response -> getModuleResult ( ) ; $ exception = new NotFoundHttpException ( isset ( $ moduleResult [ 'errorMessage' ] ) ? $ moduleResult [ 'errorMessage' ] : 'Not Found' ) ; $ exception -> setOriginalResponse ( $ response ) ; throw $ exception ; } }
7425	public function setSource ( $ source = '' ) { if ( ! $ this -> isValid ( $ source ) ) { throw new InvalidSourceExtensionException ( ) ; } $ this -> source = $ source ; return $ this ; }
346	private static function mergeCssClasses ( array $ existingClasses , array $ additionalClasses ) { foreach ( $ additionalClasses as $ key => $ class ) { if ( is_int ( $ key ) && ! in_array ( $ class , $ existingClasses ) ) { $ existingClasses [ ] = $ class ; } elseif ( ! isset ( $ existingClasses [ $ key ] ) ) { $ existingClasses [ $ key ] = $ class ; } } return array_unique ( $ existingClasses ) ; }
1575	public function api ( $ apiName = null ) { $ repo = $ this -> container -> make ( Repository :: class ) ; return $ repo -> createApi ( $ apiName ? : $ this -> defaultApi ( ) ) ; }
149	public function isActive ( $ scenario ) { return ! in_array ( $ scenario , $ this -> except , true ) && ( empty ( $ this -> on ) || in_array ( $ scenario , $ this -> on , true ) ) ; }
11109	public function getExtensions ( Container $ app ) { $ directories = $ this -> findExtensionsDirectories ( $ app ) ; foreach ( $ directories as $ directory ) { $ extensionName = $ directory -> getRelativePathname ( ) ; $ this -> extensions [ $ extensionName ] [ 'name' ] = $ extensionName ; $ this -> extensions [ $ extensionName ] [ 'pathName' ] = $ directory -> getPathName ( ) ; } return $ this -> extensions ; }
7278	public function input ( $ name = null , $ default = null ) { return ! $ name ? $ this -> inputs : ( $ this -> inputs [ $ name ] ?? $ default ) ; }
1193	private function addCustomElements ( array $ elements , HTMLPurifier_HTMLDefinition $ definition ) { foreach ( $ elements as $ element ) { $ name = $ element [ 0 ] ; $ contentSet = $ element [ 1 ] ; $ allowedChildren = $ element [ 2 ] ; $ attributeCollection = $ element [ 3 ] ; $ attributes = isset ( $ element [ 4 ] ) ? $ element [ 4 ] : null ; if ( ! empty ( $ attributes ) ) { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection , $ attributes ) ; } else { $ definition -> addElement ( $ name , $ contentSet , $ allowedChildren , $ attributeCollection ) ; } } }
6459	public function fillInWithValueOfFieldOfCurrentUser ( $ field , $ user_field ) { if ( ! empty ( $ this -> user ) && ! $ this -> user -> uid ) { throw new \ Exception ( 'Anonymous user have no fields' ) ; } $ entity = new EntityDrupalWrapper ( 'user' ) ; $ wrapper = $ entity -> wrapper ( $ this -> user -> uid ) ; $ user_field = $ entity -> getFieldNameByLocator ( $ user_field ) ; if ( empty ( $ wrapper -> { $ user_field } ) ) { throw new \ InvalidArgumentException ( sprintf ( 'User entity has no "%s" field.' , $ user_field ) ) ; } $ value = $ wrapper -> { $ user_field } -> value ( ) ; if ( empty ( $ value ) ) { throw new \ UnexpectedValueException ( 'The value of "%s" field is empty.' , $ user_field ) ; } $ this -> fillField ( $ field , $ value ) ; }
7120	protected function getFindBySubjectAndSupplierQuery ( ) { if ( null !== $ this -> findBySubjectAndSupplierQuery ) { return $ this -> findBySubjectAndSupplierQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectAndSupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ this -> getAlias ( ) . '.supplier' , ':supplier' ) ) -> getQuery ( ) ; }
5563	protected function load ( $ url , $ parameters ) { $ frame = $ url -> getTarget ( ) ; if ( ! $ frame || ! $ this -> page -> hasFrames ( ) || ( strtolower ( $ frame ) == '_top' ) ) { return $ this -> loadPage ( $ url , $ parameters ) ; } return $ this -> loadFrame ( array ( $ frame ) , $ url , $ parameters ) ; }
11614	public function update ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
6900	public function close ( ) : void { if ( $ this -> is_active ( ) ) { $ this -> _data [ 'last_active' ] = time ( ) ; config ( 'debug' ) ? session_write_close ( ) : @ session_write_close ( ) ; } }
11119	protected function runUp ( array $ file , int $ batch ) : void { $ this -> notify -> note ( "<comment>Migrating:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> log ( $ this -> getMigrationName ( $ file ) , $ batch ) ; $ this -> notify -> note ( "<info>Migrated:</info> {$file['basename']}" ) ; }
8237	protected function configGenerationAction ( ParameterBag $ post ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> addOutput ( "installer_step" , 1 ) ; return ; } $ this -> picoAuth -> addOutput ( "installer_step" , 2 ) ; $ this -> outputModulesConfiguration ( $ post ) ; }
2526	protected function prepareForNextMessage ( $ messageName , $ messageOptions ) { if ( $ this -> isAuthenticated === true && is_int ( $ this -> sessionData [ 'sequenceNumber' ] ) ) { $ this -> sessionData [ 'sequenceNumber' ] ++ ; } $ headers = $ this -> createSoapHeaders ( $ this -> sessionData , $ this -> params , $ messageName , $ messageOptions ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( null ) ; $ this -> getSoapClient ( $ messageName ) -> __setSoapHeaders ( $ headers ) ; }
5542	protected function clearNestedFramesFocus ( ) { for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ this -> frames [ $ i ] -> clearFrameFocus ( ) ; } }
11201	public function fetchOffset ( $ num ) { if ( $ this -> contentModified ) { $ this -> generateContent ( ) ; } $ key = $ this -> fetchOffsetKey ( $ num ) ; if ( $ key != null ) { return $ this -> content [ $ key ] ; } return null ; }
148	public static function createValidator ( $ type , $ model , $ attributes , $ params = [ ] ) { $ params [ 'attributes' ] = $ attributes ; if ( $ type instanceof \ Closure || ( $ model -> hasMethod ( $ type ) && ! isset ( static :: $ builtInValidators [ $ type ] ) ) ) { $ params [ 'class' ] = __NAMESPACE__ . '\InlineValidator' ; $ params [ 'method' ] = $ type ; } else { if ( isset ( static :: $ builtInValidators [ $ type ] ) ) { $ type = static :: $ builtInValidators [ $ type ] ; } if ( is_array ( $ type ) ) { $ params = array_merge ( $ type , $ params ) ; } else { $ params [ 'class' ] = $ type ; } } return Yii :: createObject ( $ params ) ; }
5155	public function setConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } unset ( $ this -> configuration ) ; $ this -> configuration = $ configuration ; if ( $ configure ) { $ this -> configure ( ) ; } }
4444	public function failedForGroup ( $ group , int $ start = 0 , int $ limit = 25 ) : array { $ results = json_decode ( $ this -> client -> failed ( $ group , $ start , $ limit ) , true ) ; if ( isset ( $ results [ 'jobs' ] ) && ! empty ( $ results [ 'jobs' ] ) ) { $ results [ 'jobs' ] = $ this -> multiget ( $ results [ 'jobs' ] ) ; } return is_array ( $ results ) ? $ results : [ ] ; }
10248	public function getGuid ( ) { return sprintf ( '%04x%04x-%04x-%03x4-%04x-%04x%04x%04x' , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 4095 ) , bindec ( substr_replace ( sprintf ( '%016b' , mt_rand ( 0 , 65535 ) ) , '01' , 6 , 2 ) ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) , mt_rand ( 0 , 65535 ) ) ; }
1561	protected function deserializeAttributes ( $ attributes , $ record ) { return collect ( $ attributes ) -> reject ( function ( $ v , $ field ) use ( $ record ) { return $ this -> isNotFillable ( $ field , $ record ) ; } ) -> mapWithKeys ( function ( $ value , $ field ) use ( $ record ) { $ key = $ this -> modelKeyForField ( $ field , $ record ) ; return [ $ key => $ this -> deserializeAttribute ( $ value , $ field , $ record ) ] ; } ) -> all ( ) ; }
1366	protected function bootResponseMacro ( ) { Response :: macro ( 'jsonApi' , function ( $ api = null ) { return json_api ( $ api ) -> getResponses ( ) -> withEncodingParameters ( app ( EncodingParametersInterface :: class ) ) ; } ) ; }
903	public function isLambda ( $ index ) { if ( ! $ this -> tokens [ $ index ] -> isGivenKind ( T_FUNCTION ) ) { throw new \ LogicException ( sprintf ( 'No T_FUNCTION at given index %d, got %s.' , $ index , $ this -> tokens [ $ index ] -> getName ( ) ) ) ; } $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ index ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; if ( $ startParenthesisToken -> isGivenKind ( CT :: T_RETURN_REF ) ) { $ startParenthesisIndex = $ this -> tokens -> getNextMeaningfulToken ( $ startParenthesisIndex ) ; $ startParenthesisToken = $ this -> tokens [ $ startParenthesisIndex ] ; } return $ startParenthesisToken -> equals ( '(' ) ; }
11613	public function create ( $ account , $ nickname ) { $ params = [ 'kf_account' => $ account , 'nickname' => $ nickname , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_CREATE , $ params ] ) ; }
6225	public function cd ( array $ path ) : void { array_unshift ( $ path , $ this -> path ) ; $ this -> path = new Path ( $ path ) ; }
3192	public function save ( ) { if ( ! $ this -> storage ) { throw new InvalidStorageException ( 'A storage must be defined in order to store the data!' ) ; } $ this -> storage -> store ( $ this -> toArray ( ) ) ; return $ this ; }
7468	protected function colorize ( $ str , $ attrs ) { $ start = $ this -> start ( $ attrs ) ; return $ start . $ str . $ this -> end ( ) ; }
1681	public function copyUser ( $ row , $ href , $ label , $ title , $ icon , $ attributes , $ table ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'config' ] [ 'closed' ] ) { return '' ; } return ( $ this -> User -> isAdmin || ! $ row [ 'admin' ] ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
5035	public function setFrom ( $ email , $ name = null ) { if ( is_array ( $ email ) ) { $ this -> from = [ $ email [ 'email' ] => $ email [ 'name' ] ] ; } else { $ this -> from = is_object ( $ email ) || null === $ name ? $ email : array ( $ email => $ name ) ; } return $ this ; }
4082	public function getInputScreen ( $ metaModel ) { $ inputScreen = $ this -> getInputScreenDetails ( $ metaModel ) ; return $ inputScreen ? $ inputScreen -> getId ( ) : null ; }
7069	static function isValid ( $ unit , $ throw = false ) { if ( in_array ( $ unit , static :: getUnits ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( "Invalid unit '$unit'." ) ; } return false ; }
11398	public function remove ( $ sourceDir , array $ options , $ username ) { $ dir = $ this -> init ( $ sourceDir , $ options , $ username ) -> getDirInUse ( ) ; $ blockName = $ options [ "blockname" ] ; $ blocksDir = $ dir . '/blocks' ; $ filename = sprintf ( '%s/%s.json' , $ blocksDir , $ blockName ) ; $ options [ "block" ] = JsonTools :: jsonDecode ( FilesystemTools :: readFile ( $ filename ) ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVING , new BlockRemovingEvent ( $ this -> serializer , $ filename ) ) ; $ this -> filesystem -> remove ( $ filename ) ; $ this -> removeBlockFromSlotFile ( $ options , $ dir ) ; Dispatcher :: dispatch ( BlockEvents :: BLOCK_REMOVED , new BlockRemovedEvent ( $ this -> serializer , $ filename ) ) ; DataLogger :: log ( sprintf ( 'Block "%s" has been removed from the "%s" slot on page "%s" for the "%s_%s" language' , $ options [ "blockname" ] , $ options [ "slot" ] , $ options [ "page" ] , $ options [ "language" ] , $ options [ "country" ] ) ) ; }
3283	public function setCache ( $ cache ) { if ( ! is_bool ( $ cache ) && ! $ cache instanceof CacheInterface ) { throw new Exception ( 'Cache must be a boolean or an instance of Flintstone\Cache\CacheInterface' ) ; } if ( $ cache === true ) { $ cache = new ArrayCache ( ) ; } $ this -> config [ 'cache' ] = $ cache ; }
9821	public function shiftColumn ( $ fromColumn , $ toColumn ) { $ fromColumn = strtoupper ( $ fromColumn ) ; $ toColumn = strtoupper ( $ toColumn ) ; if ( ( $ fromColumn !== null ) && ( isset ( $ this -> columns [ $ fromColumn ] ) ) && ( $ toColumn !== null ) ) { $ this -> columns [ $ fromColumn ] -> setParent ( ) ; $ this -> columns [ $ fromColumn ] -> setColumnIndex ( $ toColumn ) ; $ this -> columns [ $ toColumn ] = $ this -> columns [ $ fromColumn ] ; $ this -> columns [ $ toColumn ] -> setParent ( $ this ) ; unset ( $ this -> columns [ $ fromColumn ] ) ; ksort ( $ this -> columns ) ; } return $ this ; }
6951	private function getBaseQueryBuilder ( ) { $ qb = $ this -> getQueryBuilder ( 'r' , 'r.id' ) ; return $ qb -> andWhere ( $ qb -> expr ( ) -> orX ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'r.countries' ) , 'r.countries IS EMPTY' ) ) -> addOrderBy ( 'r.priority' , 'DESC' ) ; }
12298	public function onlyFillablePivot ( $ pivotRelation , $ data ) { $ fillable = $ this -> getPivotFields ( $ pivotRelation , 'pivotColumns' ) ; return array_only ( $ data , $ fillable ) ; }
4965	public function fromFiles ( $ name = null , $ default = null ) { if ( $ name === null ) { return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getFiles ( $ name , $ default ) ; }
5569	public function delete ( $ url , $ parameters = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimpleDeleteEncoding ( $ parameters ) ) ; }
2694	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activate_flag = $ this -> getRequest ( ) -> getParam ( 'activate_flag' ) ; $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ formData = $ this -> getRequest ( ) -> getParams ( ) ; if ( in_array ( "" , $ formData ) ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Please fill in the required fields.' ] ) ; } $ service = $ this -> api -> checkServiceDetails ( ) ; $ this -> vcl -> checkCurrentVersionActive ( $ service -> versions , $ activeVersion ) ; $ currActiveVersion = $ this -> vcl -> getCurrentVersion ( $ service -> versions ) ; $ clone = $ this -> api -> cloneVersion ( $ currActiveVersion ) ; $ id = $ service -> id . '-' . $ clone -> number . '-imageopto' ; $ params = json_encode ( [ 'data' => [ 'id' => $ id , 'type' => 'io_settings' , 'attributes' => [ 'webp' => $ this -> getRequest ( ) -> getParam ( 'webp' ) , 'webp_quality' => $ this -> getRequest ( ) -> getParam ( 'webp_quality' ) , 'jpeg_type' => $ this -> getRequest ( ) -> getParam ( 'jpeg_type' ) , 'jpeg_quality' => $ this -> getRequest ( ) -> getParam ( 'jpeg_quality' ) , 'upscale' => $ this -> getRequest ( ) -> getParam ( 'upscale' ) , 'resize_filter' => $ this -> getRequest ( ) -> getParam ( 'resize_filter' ) ] ] ] ) ; $ configureIo = $ this -> api -> configureImageOptimizationDefaultConfigOptions ( $ params , $ clone -> number ) ; if ( ! $ configureIo ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to update image optimization default config options.' ] ) ; } $ this -> api -> validateServiceVersion ( $ clone -> number ) ; if ( $ activate_flag === 'true' ) { $ this -> api -> activateVersion ( $ clone -> number ) ; } if ( $ this -> config -> areWebHooksEnabled ( ) && $ this -> config -> canPublishConfigChanges ( ) ) { $ this -> api -> sendWebHook ( '*Image optimization default config options have been updated*' ) ; } $ comment = [ 'comment' => 'Magento Module updated the Image Optimization Default Configuration' ] ; $ this -> api -> addComment ( $ clone -> number , $ comment ) ; return $ result -> setData ( [ 'status' => true , 'active_version' => $ clone -> number ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
3822	public function purge ( ) { $ fileSystem = new Filesystem ( ) ; $ fileSystem -> remove ( $ this -> cacheDir ) ; $ this -> logger -> log ( LogLevel :: INFO , 'Purged the MetaModels cache' , [ 'contao' => new ContaoContext ( __METHOD__ , TL_CRON ) ] ) ; }
11644	protected function getConnection ( ) { $ connection = $ this -> getClient ( ) -> getConnection ( ) ; if ( $ connection instanceof ReplicationInterface ) { $ connection -> switchToMaster ( ) ; } return $ connection ; }
5874	public static function isAnimatedGif ( $ fileName ) { if ( ( $ fh = fopen ( $ fileName , 'rb' ) ) === false ) { throw new \ RuntimeException ( 'Can\'t open ' . $ fileName , 1454678600 ) ; } $ count = 0 ; while ( ! feof ( $ fh ) && $ count < 2 ) { $ chunk = fread ( $ fh , 1024 * 100 ) ; $ count += preg_match_all ( '#\x00\x21\xF9\x04.{4}\x00[\x2C\x21]#s' , $ chunk , $ matches ) ; } fclose ( $ fh ) ; return $ count > 1 ; }
4804	private function getTemplatePath ( ) { $ tsfe = $ GLOBALS [ 'TSFE' ] ; if ( isset ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ) { $ templateFile = GeneralUtility :: getFileAbsFileName ( $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ) ; if ( is_file ( $ templateFile ) ) { return $ tsfe -> tmpl -> setup [ 'lib.' ] [ 'plugins.' ] [ 'tx_happyfeet.' ] [ 'view.' ] [ 'template' ] ; } } return $ this -> getTemplatePathAndFilename ( $ this -> defaultTemplate ) ; }
6001	public function addImageTemplate ( $ item ) { if ( ! ( $ item instanceof ImageTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new ImageTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate ImageTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "ImageTemplate"!' , E_USER_WARNING ) ; } } $ this -> imagetemplates [ ] = $ item ; return $ this ; }
4590	public function exists ( $ form , Parameters $ parameters = null ) : bool { $ object = $ this -> execute ( 'GET' , 'http://www.mocky.io/v2/592c6f7311000029066df850' ) ; if ( $ object && property_exists ( $ object , '_id' ) && $ object -> _id ) { return true ; } return false ; }
8528	public function listFinancialEventGroupsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEventGroupsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventGroupsByNextTokenResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventGroupsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
12233	public function moveTo ( SimpleXMLElement $ dst ) { return simplexml_import_dom ( dom_import_simplexml ( $ dst ) , get_class ( $ this ) ) -> appendChild ( $ this -> removeSelf ( ) ) ; }
3856	protected function prepareMetaModel ( ) { $ factory = $ this -> getFactory ( ) ; $ this -> objMetaModel = $ factory -> getMetaModel ( $ factory -> translateIdToMetaModelName ( $ this -> intMetaModel ) ) ; if ( ! $ this -> objMetaModel ) { throw new \ RuntimeException ( 'Could get metamodel id: ' . $ this -> intMetaModel ) ; } }
10137	private function writeMsoDrawing ( ) { if ( isset ( $ this -> escher ) ) { $ writer = new Escher ( $ this -> escher ) ; $ data = $ writer -> close ( ) ; $ spOffsets = $ writer -> getSpOffsets ( ) ; $ spTypes = $ writer -> getSpTypes ( ) ; $ spOffsets [ 0 ] = 0 ; $ nm = count ( $ spOffsets ) - 1 ; for ( $ i = 1 ; $ i <= $ nm ; ++ $ i ) { $ record = 0x00EC ; $ dataChunk = substr ( $ data , $ spOffsets [ $ i - 1 ] , $ spOffsets [ $ i ] - $ spOffsets [ $ i - 1 ] ) ; $ length = strlen ( $ dataChunk ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ dataChunk ) ; $ record = 0x005D ; $ objData = '' ; if ( $ spTypes [ $ i ] == 0x00C9 ) { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0014 , $ i , 0x2101 , 0 , 0 , 0 ) ; $ objData .= pack ( 'vv' , 0x00C , 0x0014 ) ; $ objData .= pack ( 'H*' , '0000000000000000640001000A00000010000100' ) ; $ objData .= pack ( 'vv' , 0x0013 , 0x1FEE ) ; $ objData .= pack ( 'H*' , '00000000010001030000020008005700' ) ; } else { $ objData .= pack ( 'vvvvvVVV' , 0x0015 , 0x0012 , 0x0008 , $ i , 0x6011 , 0 , 0 , 0 ) ; } $ objData .= pack ( 'vv' , 0x0000 , 0x0000 ) ; $ length = strlen ( $ objData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ objData ) ; } } }
12874	public function saveAction ( Request $ request , Application $ app ) { $ options = array ( "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , "theme_deployer" => $ app [ "red_kite_cms.theme_deployer" ] , "page" => clone ( $ app [ "red_kite_cms.page" ] ) , ) ; return parent :: save ( $ options ) ; }
12184	public static function getById ( $ relationshipId ) { $ key = md5 ( $ relationshipId ) ; if ( isset ( self :: $ _relationships [ $ key ] ) ) { return self :: $ _relationships [ $ key ] ; } return false ; }
9252	protected function initializeContainer ( ) { $ this -> registerDefaultExtensions ( ) ; $ initializer = $ this -> getContainerInitializer ( ) ; $ this -> container = $ initializer -> initializeContainer ( $ this , $ this -> extensions , $ this -> compilerPasses ) ; $ this -> container -> set ( 'app' , $ this ) ; return $ this -> container ; }
3812	protected function transformConditions ( $ conditions ) { $ sorted = array ( ) ; $ byPid = array ( ) ; foreach ( $ conditions as $ i => $ condition ) { $ sorted [ $ condition [ 'id' ] ] = $ conditions [ $ i ] ; $ byPid [ $ condition [ 'pid' ] ] [ ] = $ condition [ 'id' ] ; } $ instances = array ( ) ; foreach ( $ sorted as $ id => $ condition ) { $ instances [ $ id ] = $ this -> transformCondition ( $ condition ) ; } foreach ( $ byPid as $ pid => $ ids ) { foreach ( $ ids as $ id ) { $ settingId = $ sorted [ $ id ] [ 'settingId' ] ; if ( ! isset ( $ this -> conditions [ $ settingId ] ) ) { $ this -> conditions [ $ settingId ] = new PropertyConditionChain ( ) ; } $ result = $ this -> conditions [ $ settingId ] ; $ condition = $ instances [ $ id ] ; $ parent = ( $ pid == 0 ) ? $ result : $ instances [ $ pid ] ; if ( $ parent instanceof ConditionChainInterface ) { $ parent -> addCondition ( $ condition ) ; } elseif ( $ parent instanceof NotCondition ) { $ parent -> setCondition ( $ condition ) ; } } } }
9464	private function registerLogViewerPackage ( ) { $ this -> registerProvider ( LogViewerServiceProvider :: class ) ; $ config = $ this -> config ( ) ; $ config -> set ( 'log-viewer.route.enabled' , false ) ; $ config -> set ( 'log-viewer.menu.filter-route' , $ config -> get ( 'arcanesoft.foundation.log-viewer.filter-route' ) ) ; }
2272	public static function quoteIdentifier ( $ strName ) { static $ strQuoteCharacter = null ; if ( $ strQuoteCharacter === null ) { $ strQuoteCharacter = System :: getContainer ( ) -> get ( 'database_connection' ) -> getDatabasePlatform ( ) -> getIdentifierQuoteCharacter ( ) ; } if ( strncmp ( $ strName , $ strQuoteCharacter , 1 ) === 0 ) { return $ strName ; } if ( ! preg_match ( '/^[A-Za-z0-9_$.]+$/' , $ strName ) ) { return $ strName ; } return System :: getContainer ( ) -> get ( 'database_connection' ) -> quoteIdentifier ( $ strName ) ; }
8869	public function attach ( Runner $ runner ) { if ( $ this -> runners -> contains ( $ runner ) ) { throw new LogicException ( 'Can\'t attach already attached runner.' ) ; } $ this -> runners -> attach ( $ runner ) ; return $ this ; }
10568	public function create ( \ Psr \ Http \ Message \ ServerRequestInterface $ request , string $ sortParameter = self :: SORT , array $ defaultSort = [ ] ) : Pagination { $ offset = 0 ; $ max = PHP_INT_MAX ; $ params = $ request -> getQueryParams ( ) ; $ range = $ request -> getHeaderLine ( self :: RANGE ) ; if ( $ range !== null && preg_match ( self :: REGEX_RANGE , $ range , $ rm ) ) { $ offset = ( int ) $ rm [ 1 ] ; $ max = ( int ) $ rm [ 2 ] - $ offset + 1 ; } else { $ max = $ this -> parse ( self :: $ maxAlias , $ params , PHP_INT_MAX ) ; $ offVal = $ this -> parse ( self :: $ offsetAlias , $ params , 0 ) ; if ( $ offVal > 0 ) { $ offset = $ offVal ; } elseif ( isset ( $ params [ self :: START_INDEX ] ) ) { $ startIdx = isset ( $ params [ self :: START_INDEX ] ) ? ( int ) $ params [ self :: START_INDEX ] : 0 ; if ( $ startIdx > 0 ) { $ offset = $ startIdx - 1 ; } } elseif ( isset ( $ params [ self :: START_PAGE ] ) || isset ( $ params [ self :: PAGE ] ) ) { $ startPage = $ this -> parse ( self :: $ pageAlias , $ params , 0 ) ; if ( $ startPage > 0 ) { $ offset = ( $ max * ( $ startPage - 1 ) ) ; } } } return new Pagination ( $ max , $ offset , $ this -> getOrder ( $ request , $ sortParameter , $ defaultSort ) ) ; }
11482	public function saveAllPages ( BlockManagerApprover $ approver , array $ languages , $ saveCommonSlots = true ) { $ this -> contributorDefined ( ) ; $ finder = new Finder ( ) ; $ pages = $ finder -> directories ( ) -> depth ( 0 ) -> in ( $ this -> pagesDir ) ; foreach ( $ pages as $ page ) { $ page = ( string ) $ page ; $ pageName = basename ( $ page ) ; foreach ( $ languages as $ language ) { $ tokens = explode ( "_" , $ language ) ; $ options = array ( 'page' => $ pageName , 'language' => $ tokens [ 0 ] , 'country' => $ tokens [ 1 ] , ) ; $ this -> save ( $ approver , $ options , $ saveCommonSlots ) ; } $ saveCommonSlots = false ; } Dispatcher :: dispatch ( PageCollectionEvents :: SITE_SAVED , new SiteSavedEvent ( ) ) ; DataLogger :: log ( 'The whole website\'s pages were successfully saved in production' ) ; }
3624	public function temperatureInUserScale ( $ temperature_in_celsius , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature_in_celsius * 1.8 ) + 32 ; } return $ temperature_in_celsius ; }
2075	public function purgeVersionTable ( ) { $ objDatabase = Database :: getInstance ( ) ; $ objDatabase -> execute ( "TRUNCATE TABLE tl_version" ) ; $ this -> log ( 'Purged the version table' , __METHOD__ , TL_CRON ) ; }
5464	public function isWithin ( $ url ) { if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) ) ) { return true ; } if ( $ this -> isIn ( $ this -> root , $ url -> getBasePath ( ) . $ url -> getPage ( ) . '/' ) ) { return true ; } return false ; }
8992	public function getAttributeNames ( $ entity ) { if ( ! $ entity instanceof \ ElggEntity ) { return array ( ) ; } $ default = array ( 'guid' , 'type' , 'subtype' , 'owner_guid' , 'container_guid' , 'site_guid' , 'access_id' , 'time_created' , 'time_updated' , 'last_action' , 'enabled' , ) ; switch ( $ entity -> getType ( ) ) { case 'user' ; $ attributes = array ( 'name' , 'username' , 'email' , 'language' , 'banned' , 'admin' , 'password' , 'salt' ) ; break ; case 'group' : $ attributes = array ( 'name' , 'description' , ) ; break ; case 'object' : $ attributes = array ( 'title' , 'description' , ) ; break ; } return array_merge ( $ default , $ attributes ) ; }
8693	public static function createSymlink ( $ symlinkTarget , $ symlinkName ) { if ( false === @ symlink ( $ symlinkTarget , $ symlinkName ) ) { throw new \ UnexpectedValueException ( "An error occurred while creating symlink '{$symlinkName}'" ) ; } if ( false === $ target = readlink ( $ symlinkName ) ) { throw new \ UnexpectedValueException ( "Symlink {$symlinkName} points to target {$target}" ) ; } }
12422	public function getAll ( $ domain ) { $ messages = [ ] ; $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { $ messages = $ messages + ( array ) $ object -> getMessages ( $ domain , $ locale ) ; } return $ messages ; }
109	public function getVersion ( ) { if ( isset ( self :: $ version ) ) { return self :: $ version ; } if ( 0 !== $ this -> process -> execute ( 'git --version' , $ output ) ) { return ; } if ( preg_match ( '/^git version (\d+(?:\.\d+)+)/m' , $ output , $ matches ) ) { return self :: $ version = $ matches [ 1 ] ; } }
4273	public function stream_eof ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ feof ( $ this -> handle ) ; self :: register ( ) ; return $ result ; }
8522	public function setGlobalSellingRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GlobalSellingRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1264	private function createVoidRequest ( $ shipmentData ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'VoidShipmentRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , '1' ) ) ; if ( is_string ( $ shipmentData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData ) ) ) ; } else { $ expanded = $ container -> appendChild ( $ xml -> createElement ( 'ExpandedVoidShipment' ) ) ; $ expanded -> appendChild ( $ xml -> createElement ( 'ShipmentIdentificationNumber' , strtoupper ( $ shipmentData [ 'shipmentId' ] ) ) ) ; if ( array_key_exists ( 'trackingNumbers' , $ shipmentData ) ) { foreach ( $ shipmentData [ 'trackingNumbers' ] as $ tn ) { $ expanded -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , strtoupper ( $ tn ) ) ) ; } } } return $ xml -> saveXML ( ) ; }
754	public function run ( ) { if ( Yii :: $ app -> request -> getQueryParam ( self :: REFRESH_GET_VAR ) !== null ) { $ code = $ this -> getVerifyCode ( true ) ; Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; return [ 'hash1' => $ this -> generateValidationHash ( $ code ) , 'hash2' => $ this -> generateValidationHash ( strtolower ( $ code ) ) , 'url' => Url :: to ( [ $ this -> id , 'v' => uniqid ( '' , true ) ] ) , ] ; } $ this -> setHttpHeaders ( ) ; Yii :: $ app -> response -> format = Response :: FORMAT_RAW ; return $ this -> renderImage ( $ this -> getVerifyCode ( ) ) ; }
8511	public function listInboundShipmentItems ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentItemsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentItems' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentItemsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8327	public function recognizeRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra = [ ] ) { $ captchaId = $ this -> sendRecaptchaV2 ( $ googleKey , $ pageUrl , $ extra ) ; $ startTime = time ( ) ; while ( true ) { $ this -> getLogger ( ) -> info ( "Waiting {$this->rTimeout} sec." ) ; sleep ( $ this -> recaptchaRTimeout ) ; if ( time ( ) - $ startTime >= $ this -> mTimeout ) { throw new RuntimeException ( "Captcha waiting timeout." ) ; } $ result = $ this -> getCaptchaResult ( $ captchaId ) ; if ( $ result === false ) { continue ; } $ this -> getLogger ( ) -> info ( "Elapsed " . ( time ( ) - $ startTime ) . " second(s)." ) ; return $ result ; } throw new RuntimeException ( 'Unknown recognition logic error.' ) ; }
479	public function renameColumn ( $ table , $ name , $ newName ) { $ time = $ this -> beginCommand ( "rename column $name in table $table to $newName" ) ; $ this -> db -> createCommand ( ) -> renameColumn ( $ table , $ name , $ newName ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
10072	function fromXML ( $ xmlElement ) { $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> author = $ xmlElement -> author ; $ this -> state = $ xmlElement -> state ; $ this -> type = $ xmlElement -> type ; $ this -> contactFilterName = $ xmlElement -> contact_filter_name ; $ this -> contactFilterId = $ xmlElement -> contact_filter_id ; $ this -> evaluated = $ xmlElement -> evaluated ; $ this -> created = $ xmlElement -> created ; $ this -> updated = $ xmlElement -> updated ; $ this -> countActiveContacts = $ xmlElement -> count_active_contacts ; $ this -> countContacts = $ xmlElement -> count_contacts ; }
4274	public function stream_flush ( ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ success = \ fflush ( $ this -> handle ) ; self :: register ( ) ; return $ success ; }
9488	public function getPages ( ) { if ( $ this -> getPageRange ( ) > $ this -> getPagesCount ( ) ) { $ this -> setPageRange ( $ this -> getPagesCount ( ) ) ; } $ delta = ceil ( $ this -> getPageRange ( ) / 2 ) ; if ( $ this -> getCurrentPageNumber ( ) - $ delta > $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) ) { $ pages = range ( $ this -> getPagesCount ( ) - $ this -> getPageRange ( ) + 1 , $ this -> getPagesCount ( ) ) ; } else { if ( $ this -> getCurrentPageNumber ( ) - $ delta < 0 ) { $ delta = $ this -> getCurrentPageNumber ( ) ; } $ offset = $ this -> getCurrentPageNumber ( ) - $ delta ; $ pages = range ( $ offset + 1 , $ offset + $ this -> getPageRange ( ) ) ; } return $ pages ; }
11311	protected static function getMessage ( $ code ) { $ mapping = static :: getMappings ( ) ; if ( isset ( $ mapping [ $ code ] ) ) { return $ mapping [ $ code ] ; } return ( string ) $ code ; }
1319	private function cleanUpParameters ( array $ parameters ) { foreach ( $ parameters as $ key => $ value ) { if ( is_bool ( $ value ) ) { $ parameters [ $ key ] = var_export ( $ value , true ) ; } } return $ parameters ; }
3821	private function getReferer ( Request $ request , $ table , $ encodeAmp = false ) { $ uri = $ this -> systemAdapter -> getReferer ( $ encodeAmp , $ table ) ; if ( ! preg_match ( '@^https?://@i' , $ uri ) ) { $ uri = $ request -> getBasePath ( ) . '/' . ltrim ( $ uri , '/' ) ; } return $ uri ; }
12711	public function register ( $ alias , $ abstract ) { if ( ! is_string ( $ alias ) || ! is_string ( $ abstract ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 and 2 of %s must be a string." , __METHOD__ ) ) ; } if ( ! isset ( $ this -> aliases [ $ alias ] ) ) { $ this -> aliases [ $ alias ] = $ this -> make ( $ abstract ) ; } return $ this ; }
12832	private function _processModifiers ( $ expression ) { $ mStart = '' ; $ mEnd = '' ; $ rawEcho = false ; if ( strpos ( $ expression , '|' ) !== false && strpos ( $ expression , '||' ) === false ) { $ modifiers = explode ( '|' , $ expression ) ; $ expression = array_shift ( $ modifiers ) ; foreach ( $ modifiers as $ modifier ) { $ params = array ( ) ; if ( strpos ( $ modifier , ':' ) !== false ) { $ params = explode ( ':' , $ modifier ) ; $ modifier = array_shift ( $ params ) ; } if ( $ modifier == 'raw' ) { $ rawEcho = true ; continue ; } if ( $ this -> isCallable ( $ modifier ) ) { $ mStart = $ modifier . '(' . $ mStart ; if ( $ modifier !== 'raw' ) { foreach ( $ params as $ param ) { $ mEnd .= ', ' . $ this -> compileExpression ( $ param ) ; } } $ mEnd .= ')' ; } else { throw new \ Exception ( 'SLOT compiler error: undefined modifier ' . $ modifier ) ; } } } return array ( $ expression , $ mStart , $ mEnd , $ rawEcho ) ; }
4032	private function preCreateInverseImage ( ModelInterface $ model , string $ image ) : void { if ( false === $ intPos = strrpos ( $ image , '.' ) ) { return ; } if ( $ model -> getProperty ( 'enabled' ) ) { $ this -> iconBuilder -> getBackendIcon ( substr_replace ( $ image , '_1' , $ intPos , 0 ) ) ; return ; } $ this -> iconBuilder -> getBackendIcon ( $ image ) ; }
6217	public static function thumbnailToId ( string $ thumbnailUrl ) : string { if ( 1 !== \ preg_match ( '/\/([\d]+)\/([\d]+)(\-avatar\.jpg)$/' , $ thumbnailUrl , $ match ) ) { throw new \ RuntimeException ( \ vsprintf ( 'Invalid thumbnail URL "%s"' , [ $ thumbnailUrl , ] ) ) ; } return ltrim ( $ match [ 1 ] . $ match [ 2 ] , '0' ) ; }
2391	public function adjustPermissions ( $ insertId ) { if ( \ func_num_args ( ) == 4 ) { $ insertId = func_get_arg ( 1 ) ; } if ( $ this -> User -> isAdmin ) { return ; } if ( empty ( $ this -> User -> calendarfeeds ) || ! \ is_array ( $ this -> User -> calendarfeeds ) ) { $ root = array ( 0 ) ; } else { $ root = $ this -> User -> calendarfeeds ; } if ( \ in_array ( $ insertId , $ root ) ) { return ; } $ objSessionBag = Contao \ System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ arrNew = $ objSessionBag -> get ( 'new_records' ) ; if ( \ is_array ( $ arrNew [ 'tl_calendar_feed' ] ) && \ in_array ( $ insertId , $ arrNew [ 'tl_calendar_feed' ] ) ) { if ( $ this -> User -> inherit != 'custom' ) { $ objGroup = $ this -> Database -> execute ( "SELECT id, calendarfeeds, calendarfeedp FROM tl_user_group WHERE id IN(" . implode ( ',' , array_map ( '\intval' , $ this -> User -> groups ) ) . ")" ) ; while ( $ objGroup -> next ( ) ) { $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objGroup -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user_group SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ objGroup -> id ) ; } } } if ( $ this -> User -> inherit != 'group' ) { $ objUser = $ this -> Database -> prepare ( "SELECT calendarfeeds, calendarfeedp FROM tl_user WHERE id=?" ) -> limit ( 1 ) -> execute ( $ this -> User -> id ) ; $ arrCalendarfeedp = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeedp ) ; if ( \ is_array ( $ arrCalendarfeedp ) && \ in_array ( 'create' , $ arrCalendarfeedp ) ) { $ arrCalendarfeeds = Contao \ StringUtil :: deserialize ( $ objUser -> calendarfeeds , true ) ; $ arrCalendarfeeds [ ] = $ insertId ; $ this -> Database -> prepare ( "UPDATE tl_user SET calendarfeeds=? WHERE id=?" ) -> execute ( serialize ( $ arrCalendarfeeds ) , $ this -> User -> id ) ; } } $ root [ ] = $ insertId ; $ this -> User -> calendarfeeds = $ root ; } }
9605	public function vectorTripleProduct ( self $ b , self $ c ) { return $ this -> crossProduct ( $ b -> crossProduct ( $ c ) ) ; }
7518	function parse_comment ( ) { $ this -> pos += 3 ; if ( $ this -> next_pos ( ' , false ) !== self :: TOK_UNKNOWN ) { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; -- $ this -> pos ; } else { $ this -> status [ 'comment' ] = $ this -> getTokenString ( 1 , - 1 ) ; $ this -> pos += 2 ; } $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; }
5099	public function into ( $ table , array $ fields = null ) { $ this -> setPart ( CmdInsert :: PART_INTO , $ table ) ; if ( ! is_null ( $ fields ) ) { $ this -> placeholder = false ; $ this -> fields = $ fields ; } return $ this ; }
1687	public function loginAction ( ) : Response { $ this -> get ( 'contao.framework' ) -> initialize ( ) ; if ( ! isset ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) || ! class_exists ( $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ) ) { throw new UnauthorizedHttpException ( '' , 'Not authorized' ) ; } $ pageHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_401' ] ( ) ; try { return $ pageHandler -> getResponse ( ) ; } catch ( ResponseException $ e ) { return $ e -> getResponse ( ) ; } catch ( InsufficientAuthenticationException $ e ) { throw new UnauthorizedHttpException ( '' , $ e -> getMessage ( ) ) ; } }
3725	private function buildPickerService ( ContainerBuilder $ container ) { $ pickerService = $ container -> getDefinition ( 'metamodels.controller.picker' ) ; $ configs = $ pickerService -> getArgument ( 2 ) ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'w50x' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clr' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'clx' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'long' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'wizard' ] ; $ configs [ 'PALETTE_STYLE_PICKER' ] [ ] = [ 'cssclass' => 'm12' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'search' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'sort' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'filter' ] ; $ configs [ 'PALETTE_PANEL_PICKER' ] [ ] = [ 'cssclass' => 'limit' ] ; $ pickerService -> setArgument ( 2 , $ configs ) ; }
3297	public function doAutoRunEnhancements ( LeadEvent $ event ) { $ lead = $ event -> getLead ( ) ; if ( $ lead && ( null !== $ lead -> getDateIdentified ( ) || ! $ lead -> isAnonymous ( ) ) ) { $ leadKey = strtolower ( implode ( '|' , [ $ lead -> getFirstname ( ) , ( $ lead -> getLastActive ( ) ? $ lead -> getLastActive ( ) -> format ( 'c' ) : '' ) , $ lead -> getEmail ( ) , $ lead -> getPhone ( ) , $ lead -> getMobile ( ) , ] ) ) ; if ( strlen ( $ leadKey ) > 3 ) { if ( isset ( $ this -> leadsEnhanced [ $ leadKey ] ) ) { return ; } else { $ this -> leadsEnhanced [ $ leadKey ] = true ; } } $ integrations = $ this -> enhancerHelper -> getEnhancerIntegrations ( ) ; foreach ( $ integrations as $ integration ) { $ settings = $ integration -> getIntegrationSettings ( ) ; if ( $ settings -> getIsPublished ( ) ) { $ features = $ settings -> getFeatureSettings ( ) ; if ( isset ( $ features [ 'autorun_enabled' ] ) && $ features [ 'autorun_enabled' ] ) { try { $ integration -> doEnhancement ( $ lead ) ; } catch ( \ Exception $ exception ) { $ e = new ApiErrorException ( 'There was an issue using enhancer: ' . $ integration -> getName ( ) , 0 , $ exception ) ; if ( ! empty ( $ lead ) ) { $ e -> setContact ( $ lead ) ; } throw $ e ; } } } } $ this -> logger -> info ( 'doAutoRunEnhancements complete' ) ; } }
3773	private function buildMetaPaletteConditions ( $ palette , $ metaPalettes ) { foreach ( $ metaPalettes as $ typeName => $ paletteInfo ) { if ( 'default' === $ typeName ) { continue ; } if ( preg_match ( '#^(\w+) extends (\w+)$#' , $ typeName , $ matches ) ) { $ typeName = $ matches [ 1 ] ; } foreach ( $ paletteInfo as $ legendName => $ properties ) { foreach ( $ properties as $ propertyName ) { $ condition = new AttributeByIdIsOfType ( $ typeName , $ this -> connection , 'attr_id' ) ; $ legend = $ this -> getLegend ( $ legendName , $ palette ) ; $ property = $ this -> getProperty ( $ propertyName , $ legend ) ; $ this -> addCondition ( $ property , $ condition ) ; } } } }
8347	public function canEdit ( GroupableInterface $ post , TokenInterface $ token ) : bool { $ user = $ token -> getUser ( ) ; if ( $ post -> getAuthor ( ) == $ user -> getUsername ( ) ) { return true ; } foreach ( $ post -> getGroups ( ) as $ group ) { if ( $ this -> decision_manager -> decide ( $ token , [ 'GROUP_ROLE_ADMIN' ] , $ group ) ) { return true ; } } return false ; }
9313	public function infoAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ mapper = $ this -> getJobMapper ( ) ; try { $ pendingJobs = $ mapper -> getPending ( ) -> count ( ) ; $ runningJobs = $ mapper -> getRunning ( ) -> count ( ) ; $ finishedJobs = $ mapper -> getHistory ( ) -> count ( ) ; $ console -> writeLine ( sprintf ( 'Pending jobs: %s' , $ pendingJobs ) ) ; $ console -> writeLine ( sprintf ( 'Running jobs: %s' , $ runningJobs ) ) ; $ console -> writeLine ( sprintf ( 'Finished jobs: %s' , $ finishedJobs ) ) ; } catch ( \ PDOException $ exception ) { $ console -> writeLine ( 'Something is bad with your database - either database ' . 'adapter is not properly configured or database table is ' . 'not created.' , ConsoleColor :: LIGHT_RED ) ; } }
351	public static function getInputName ( $ model , $ attribute ) { $ formName = $ model -> formName ( ) ; if ( ! preg_match ( static :: $ attributeRegex , $ attribute , $ matches ) ) { throw new InvalidArgumentException ( 'Attribute name must contain word characters only.' ) ; } $ prefix = $ matches [ 1 ] ; $ attribute = $ matches [ 2 ] ; $ suffix = $ matches [ 3 ] ; if ( $ formName === '' && $ prefix === '' ) { return $ attribute . $ suffix ; } elseif ( $ formName !== '' ) { return $ formName . $ prefix . "[$attribute]" . $ suffix ; } throw new InvalidArgumentException ( get_class ( $ model ) . '::formName() cannot be empty for tabular inputs.' ) ; }
1935	public function generate ( $ objPage ) { $ this -> redirect ( $ this -> getForwardUrl ( $ objPage ) , $ this -> getRedirectStatusCode ( $ objPage ) ) ; }
3303	public function getClient ( ) { if ( empty ( $ this -> client ) || ! ( $ this -> client instanceof HttpClient ) ) { $ this -> client = new HttpClient ( ) ; } return $ this -> client ; }
5082	public function deleteRemap ( $ sMethod ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'put' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItem = $ this -> lookUpResource ( ) ; if ( ! $ oItem ) { throw new ApiException ( 'Resource not found' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } $ this -> userCan ( static :: ACTION_DELETE , $ oItem ) ; if ( ! $ this -> oModel -> delete ( $ oItem -> id ) ) { throw new ApiException ( 'Failed to delete resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } return Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; }
11324	public static function convertCase ( $ string , $ toCase ) { $ str = strtolower ( ltrim ( preg_replace ( [ '/[A-Z]/' , '/[_]/' ] , [ ' $0' , ' ' ] , $ string ) ) ) ; switch ( strtoupper ( $ toCase ) ) { case 'PASCAL' : return str_replace ( ' ' , '' , ucwords ( $ str ) ) ; case 'CAMEL' : return lcfirst ( str_replace ( ' ' , '' , ucwords ( $ str ) ) ) ; default : return str_replace ( ' ' , '_' , $ str ) ; } }
10550	public function dispatch ( ) { $ response = null ; try { $ this -> resolveApp ( ) ; $ this -> getTemplate ( ) ; $ this -> request -> startSession ( $ this -> vhost -> getHost ( ) , $ this -> config ) ; FlashMessage :: setStorage ( $ this -> request -> session ) ; $ this -> setupLocale ( ) ; if ( $ this -> route === null ) throw new HTTPError ( 404 , 'Could not resolve ' . $ this -> url ) ; $ app = new AppRunner ( $ this -> app , $ this -> arguments ) ; $ app -> setVariables ( $ this -> variables ) ; $ app -> setVariable ( 'dispatcher' , $ this ) ; $ app -> execute ( ) ; } catch ( Throwable $ e ) { if ( ! ( $ e instanceof Response ) ) $ e = new HTTPError ( 500 , "Exception of type " . get_class ( $ e ) . " thrown: " . $ e -> getMessage ( ) , null , $ e ) ; if ( $ e instanceof HTTPError ) $ this -> prepareErrorResponse ( $ e ) ; $ response = $ e ; } return $ response ; }
9365	public function multiply ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( ( $ this -> float_r * $ z -> re ) - ( $ this -> float_i * $ z -> im ) , ( $ this -> float_r * $ z -> im ) + ( $ z -> re * $ this -> float_i ) ) ; }
762	private function tokensMatch ( SqlToken $ patternToken , SqlToken $ token , $ offset = 0 , & $ firstMatchIndex = null , & $ lastMatchIndex = null ) { if ( $ patternToken -> getIsCollection ( ) !== $ token -> getIsCollection ( ) || ( ! $ patternToken -> getIsCollection ( ) && $ patternToken -> content !== $ token -> content ) ) { return false ; } if ( $ patternToken -> children === $ token -> children ) { $ firstMatchIndex = $ lastMatchIndex = $ offset ; return true ; } $ firstMatchIndex = $ lastMatchIndex = null ; $ wildcard = false ; for ( $ index = 0 , $ count = count ( $ patternToken -> children ) ; $ index < $ count ; $ index ++ ) { if ( $ patternToken [ $ index ] -> content === 'any' ) { $ wildcard = true ; continue ; } for ( $ limit = $ wildcard ? count ( $ token -> children ) : $ offset + 1 ; $ offset < $ limit ; $ offset ++ ) { if ( ! $ wildcard && ! isset ( $ token [ $ offset ] ) ) { break ; } if ( ! $ this -> tokensMatch ( $ patternToken [ $ index ] , $ token [ $ offset ] ) ) { continue ; } if ( $ firstMatchIndex === null ) { $ firstMatchIndex = $ offset ; $ lastMatchIndex = $ offset ; } else { $ lastMatchIndex = $ offset ; } $ wildcard = false ; $ offset ++ ; continue 2 ; } return false ; } return true ; }
9899	private function convertError ( $ errorCode ) { switch ( $ errorCode ) { case '#NULL!' : return pack ( 'C' , 0x00 ) ; case '#DIV/0!' : return pack ( 'C' , 0x07 ) ; case '#VALUE!' : return pack ( 'C' , 0x0F ) ; case '#REF!' : return pack ( 'C' , 0x17 ) ; case '#NAME?' : return pack ( 'C' , 0x1D ) ; case '#NUM!' : return pack ( 'C' , 0x24 ) ; case '#N/A' : return pack ( 'C' , 0x2A ) ; } return pack ( 'C' , 0xFF ) ; }
8735	public function decrement ( $ column , $ amount = 1 , array $ extra = [ ] ) { $ extra = $ this -> addUpdatedAtColumn ( $ extra ) ; return $ this -> noTranslationsQuery ( ) -> decrement ( $ column , $ amount , $ extra ) ; }
6603	public function makeRequestToken ( Response $ response ) { parse_str ( $ response -> content ( ) , $ params ) ; $ this -> validateRequestTokenResponse ( $ params ) ; $ this -> credentials [ 'key' ] = $ params [ 'oauth_token' ] ; $ this -> credentials [ 'secret' ] = $ params [ 'oauth_token_secret' ] ; $ this -> credentials [ 'callback_confirmed' ] = ( isset ( $ params [ 'oauth_callback_confirmed' ] ) ) ? ( boolean ) $ params [ 'oauth_callback_confirmed' ] : null ; return $ this ; }
11215	public static function __callstatic ( $ method , $ params ) { $ uri = $ params [ 0 ] ; $ callback = $ params [ 1 ] ; array_push ( self :: $ routes , $ uri ) ; array_push ( self :: $ methods , strtoupper ( $ method ) ) ; array_push ( self :: $ callbacks , $ callback ) ; }
11920	public function onPageRemoved ( PageCollectionRemovedEvent $ event ) { $ pageName = basename ( $ event -> getFilePath ( ) ) ; $ page = $ this -> pagesParser -> contributor ( $ event -> getUsername ( ) ) -> parse ( ) -> page ( $ pageName ) ; if ( null === $ page ) { return ; } foreach ( $ page [ "seo" ] as $ seo ) { $ permalink = $ seo [ "permalink" ] ; $ this -> permalinkManager -> remove ( $ permalink ) ; } $ this -> permalinkManager -> save ( ) ; }
12555	public function showAction ( Tag $ tag ) { $ deleteForm = $ this -> createDeleteForm ( $ tag ) ; return array ( 'entity' => $ tag , 'delete_form' => $ deleteForm -> createView ( ) , ) ; }
10776	public function fromArray ( array $ array ) { $ root = new Node ( null ) ; $ map = array ( ) ; $ map [ 0 ] = $ root ; foreach ( $ array as $ element ) { if ( 3 !== count ( $ element ) ) { throw new Exception ( 'Each array must have 3 elements.' ) ; } $ map [ $ element [ 0 ] ] = new Node ( $ element [ 2 ] ) ; } foreach ( $ array as $ element ) { if ( empty ( $ element [ 1 ] ) ) { $ element [ 1 ] = 0 ; } $ found = false ; $ i = 0 ; $ keys = array_keys ( $ map ) ; $ cnt = count ( $ keys ) ; while ( ! $ found && $ i < $ cnt ) { if ( $ keys [ $ i ] === $ element [ 1 ] ) { $ map [ $ keys [ $ i ] ] -> addChild ( $ map [ $ element [ 0 ] ] ) ; $ found = true ; } else { $ i ++ ; } } if ( ! $ found ) { throw new Exception ( 'Data structure does not seem to be consistent. ' . 'Key "' . $ element [ 1 ] . '" could not be found.' ) ; } } return $ root ; }
10486	protected function retrieveMapping ( $ table ) { $ result = $ this -> connection -> fetchAll ( 'SELECT COLUMN_NAME, ORDINAL_POSITION FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = ?' , [ $ table ] ) ; if ( empty ( $ result ) ) { return false ; } $ columns = [ ] ; foreach ( $ result as $ column ) { $ columns [ $ column [ 'ORDINAL_POSITION' ] ] = $ column [ 'COLUMN_NAME' ] ; } return $ columns ; }
8480	public function run ( $ eventGroupId = null ) { $ eventGroups = EventGroup :: find ( ) -> asArray ( true ) -> all ( ) ; if ( count ( $ eventGroups ) === 0 ) { throw new Exception ( 'Event groups not found' ) ; } if ( $ eventGroupId === null ) { $ first = reset ( $ eventGroups ) ; $ eventGroupId = $ first [ 'id' ] ; } $ tabs = [ ] ; foreach ( $ eventGroups as $ eventGroup ) { $ tabs [ ] = [ 'label' => $ eventGroup [ 'name' ] , 'url' => [ 'index' , 'eventGroupId' => $ eventGroup [ 'id' ] ] , 'active' => $ eventGroupId == $ eventGroup [ 'id' ] , ] ; } $ model = new EventEventHandler ( [ 'scenario' => 'search' ] ) ; $ eventsList = Event :: find ( ) -> select ( [ 'name' , 'id' ] ) -> where ( [ 'event_group_id' => $ eventGroupId ] ) -> indexBy ( 'id' ) -> column ( ) ; return $ this -> controller -> render ( 'index' , [ 'dataProvider' => $ model -> search ( \ Yii :: $ app -> request -> get ( ) , array_keys ( $ eventsList ) ) , 'eventGroupId' => $ eventGroupId , 'eventsList' => $ eventsList , 'model' => $ model , 'tabs' => $ tabs , ] ) ; }
11841	private function extractInput ( ) { $ params = $ this -> request -> getParams ( ) ; $ period = $ params [ self :: REQ_PERIOD ] ?? '' ; if ( empty ( $ period ) ) { $ period = $ this -> hlpPeriod -> getPeriodCurrent ( null , 0 , HPeriod :: TYPE_MONTH ) ; } else { $ period = $ this -> hlpPeriod -> normalizePeriod ( $ period , HPeriod :: TYPE_MONTH ) ; } $ dsBegin = $ this -> hlpPeriod -> getPeriodFirstDate ( $ period ) ; $ treeType = $ params [ self :: REQ_TREE_TYPE ] ?? '' ; if ( $ treeType != OptionTreeType :: VAL_PLAIN ) { $ treeType = OptionTreeType :: VAL_COMPRESS ; } return [ $ dsBegin , $ treeType ] ; }
9307	public function setJsonApiSecurityHash ( $ jsonApiSecurityHash ) { if ( ! is_string ( $ jsonApiSecurityHash ) ) { throw new \ InvalidArgumentException ( '`jsonApiSecurityHash` expects string value!' ) ; } $ this -> options [ 'jsonApiSecurityHash' ] = ( string ) $ jsonApiSecurityHash ; return $ this ; }
2579	protected function loadCustomerRefs ( $ dkNumber ) { if ( ! is_null ( $ dkNumber ) ) { $ this -> customerRef = new MasterPricer \ CustomerRef ( ) ; $ this -> customerRef -> customerReferences [ ] = new MasterPricer \ CustomerReferences ( $ dkNumber , MasterPricer \ CustomerReferences :: QUAL_AGENCY_GROUPING_ID ) ; } }
8719	public function fresh ( $ with = [ ] ) { if ( ! $ this -> exists ) { return ; } $ query = static :: newQueryWithoutScopes ( ) -> with ( is_string ( $ with ) ? func_get_args ( ) : $ with ) -> where ( $ this -> getKeyName ( ) , $ this -> getKey ( ) ) ; ( new TranslatableScope ( ) ) -> apply ( $ query , $ this ) ; return $ query -> first ( ) ; }
6901	public function destroy ( ) : void { if ( $ this -> is_active ( ) ) { session_unset ( ) ; session_destroy ( ) ; $ this -> _data = [ ] ; Cookie :: delete ( $ this -> name ) ; } }
1498	public function merge ( EncodingList $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings -> stack ) -> all ( ) ; return $ copy ; }
12396	public function where ( $ field , $ operator = null , $ value = null , $ logical = '&&' ) { if ( $ field instanceof Closure ) { $ this -> scope -> where .= $ this -> scope -> where == '' ? ' (' : $ logical . ' (' ; call_user_func ( $ field , $ this ) ; $ this -> scope -> where .= ') ' ; } else { $ logical = ( strlen ( $ this -> scope -> where ) <= 1 || substr ( $ this -> scope -> where , - 1 ) == '(' ) ? '' : $ logical ; $ this -> scope -> where .= Parser :: where ( $ field , $ operator , $ value , $ logical ) ; } return $ this ; }
5037	public function setImages ( array $ images , PermissionsInterface $ permissions = null ) { $ this -> clear ( ) ; foreach ( $ images as $ prop => $ image ) { $ this -> set ( $ prop , $ image , false ) ; } if ( $ permissions ) { $ this -> setPermissions ( $ permissions ) ; } return $ this ; }
8716	public static function createInLocale ( $ locale , array $ attributes = [ ] , $ translations = [ ] ) { $ model = ( new static ( $ attributes ) ) -> setLocale ( $ locale ) ; if ( $ model -> save ( ) && is_array ( $ translations ) ) { $ model -> saveTranslations ( $ translations ) ; } return $ model ; }
9749	public function _calcSize ( & $ raList ) { list ( $ iSBDcnt , $ iBBcnt , $ iPPScnt ) = [ 0 , 0 , 0 ] ; $ iSmallLen = 0 ; $ iSBcnt = 0 ; $ iCount = count ( $ raList ) ; for ( $ i = 0 ; $ i < $ iCount ; ++ $ i ) { if ( $ raList [ $ i ] -> Type == OLE :: OLE_PPS_TYPE_FILE ) { $ raList [ $ i ] -> Size = $ raList [ $ i ] -> getDataLen ( ) ; if ( $ raList [ $ i ] -> Size < OLE :: OLE_DATA_SIZE_SMALL ) { $ iSBcnt += floor ( $ raList [ $ i ] -> Size / $ this -> smallBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> smallBlockSize ) ? 1 : 0 ) ; } else { $ iBBcnt += ( floor ( $ raList [ $ i ] -> Size / $ this -> bigBlockSize ) + ( ( $ raList [ $ i ] -> Size % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; } } } $ iSmallLen = $ iSBcnt * $ this -> smallBlockSize ; $ iSlCnt = floor ( $ this -> bigBlockSize / OLE :: OLE_LONG_INT_SIZE ) ; $ iSBDcnt = floor ( $ iSBcnt / $ iSlCnt ) + ( ( $ iSBcnt % $ iSlCnt ) ? 1 : 0 ) ; $ iBBcnt += ( floor ( $ iSmallLen / $ this -> bigBlockSize ) + ( ( $ iSmallLen % $ this -> bigBlockSize ) ? 1 : 0 ) ) ; $ iCnt = count ( $ raList ) ; $ iBdCnt = $ this -> bigBlockSize / OLE :: OLE_PPS_SIZE ; $ iPPScnt = ( floor ( $ iCnt / $ iBdCnt ) + ( ( $ iCnt % $ iBdCnt ) ? 1 : 0 ) ) ; return [ $ iSBDcnt , $ iBBcnt , $ iPPScnt ] ; }
5210	public static function getInstance ( OutputInterface $ output ) { $ questionHelper = new QuestionHelper ( ) ; $ application = new Application ( 'PHP to Zephir Command Line Interface' , 'Beta 0.2.1' ) ; $ application -> getHelperSet ( ) -> set ( new FormatterHelper ( ) , 'formatter' ) ; $ application -> getHelperSet ( ) -> set ( $ questionHelper , 'question' ) ; $ application -> add ( ConvertFactory :: getInstance ( $ output ) ) ; return $ application ; }
2422	public static function deleteResource ( $ strResource ) { $ objModel = FilesModel :: findByPath ( $ strResource ) ; if ( $ objModel !== null ) { $ objModel -> delete ( ) ; } $ objFiles = FilesModel :: findMultipleByBasepath ( $ strResource . '/' ) ; if ( $ objFiles !== null ) { while ( $ objFiles -> next ( ) ) { $ objFiles -> delete ( ) ; } } static :: updateFolderHashes ( \ dirname ( $ strResource ) ) ; return null ; }
7237	protected function fixInvoiceDefault ( CustomerAddressInterface $ address ) { if ( ! $ this -> persistenceHelper -> isChanged ( $ address , [ 'invoiceDefault' ] ) ) { return ; } $ customer = $ address -> getCustomer ( ) ; if ( $ address -> isInvoiceDefault ( ) ) { foreach ( $ customer -> getAddresses ( ) as $ a ) { if ( $ a === $ address ) { continue ; } if ( $ a -> isInvoiceDefault ( ) ) { $ a -> setInvoiceDefault ( false ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ a , false ) ; } } } elseif ( null === $ customer -> getDefaultInvoiceAddress ( true ) ) { $ address -> setInvoiceDefault ( true ) ; $ this -> persistenceHelper -> persistAndRecompute ( $ address , false ) ; } }
6111	public function fileDelete ( $ cpw = "" , $ name = "/" ) { return $ this -> getParent ( ) -> channelFileDelete ( $ this -> getId ( ) , $ cpw , $ name ) ; }
2116	public function addTemplateWarning ( ) { if ( Contao \ Input :: get ( 'act' ) && Contao \ Input :: get ( 'act' ) != 'select' ) { return ; } $ objResult = $ this -> Database -> query ( "SELECT COUNT(*) AS cnt FROM tl_user_group WHERE modules LIKE '%\"tpl_editor\"%'" ) ; if ( $ objResult -> cnt > 0 ) { Contao \ Message :: addInfo ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'groupTemplateEditor' ] ) ; } }
6974	private function buildAssociationValue ( ClassMetadata $ metadata , $ propertyPath , $ value ) { $ childMetadata = $ this -> manager -> getClassMetadata ( $ metadata -> getAssociationTargetClass ( $ propertyPath ) ) ; if ( $ metadata -> isSingleValuedAssociation ( $ propertyPath ) ) { if ( is_string ( $ value ) && '#' === substr ( $ value , 0 , 1 ) ) { return $ this -> getReference ( substr ( $ value , 1 ) ) ; } elseif ( is_array ( $ value ) ) { return $ this -> buildEntity ( $ childMetadata , $ value ) ; } throw new \ Exception ( "Unexpected value for single association '$propertyPath'." ) ; } elseif ( $ metadata -> isCollectionValuedAssociation ( $ propertyPath ) ) { if ( ! is_array ( $ value ) ) { throw new \ Exception ( 'Expected array.' ) ; } $ builtValue = [ ] ; foreach ( $ value as $ childData ) { if ( is_string ( $ childData ) && '#' === substr ( $ childData , 0 , 1 ) ) { array_push ( $ builtValue , $ this -> getReference ( substr ( $ childData , 1 ) ) ) ; } elseif ( is_array ( $ value ) ) { array_push ( $ builtValue , $ this -> buildEntity ( $ childMetadata , $ childData ) ) ; } else { throw new \ Exception ( "Unexpected value for association '$propertyPath'." ) ; } } return $ builtValue ; } throw new \ Exception ( "Unexpected association path '$propertyPath'." ) ; }
3076	public function processInput ( QtiRunnerServiceContext $ context , array $ input ) { $ responses = [ ] ; foreach ( $ input as $ data ) { if ( ! is_array ( $ data ) || ! isset ( $ data [ 'channel' ] ) || ! isset ( $ data [ 'message' ] ) ) { throw new \ common_exception_InconsistentData ( 'Wrong message chunk received by the bidirectional communication service: either channel or message content is missing!' ) ; } if ( $ this -> hasChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ) { $ channel = $ this -> getChannel ( $ data [ 'channel' ] , self :: CHANNEL_TYPE_INPUT ) ; $ responses [ ] = $ this -> processChannel ( $ channel , $ context , $ data [ 'message' ] ) ; } else { $ responses [ ] = $ this -> fallback ( $ data [ 'channel' ] , $ context , $ data [ 'message' ] ) ; } } return $ responses ; }
3468	public function delete ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: delete ( $ route ) ) ; }
8664	private function convertManageReportSchedule ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'ManageReportSchedule' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportType ( ) ) { $ parameters [ 'ReportType' ] = $ request -> getReportType ( ) ; } if ( $ request -> isSetSchedule ( ) ) { $ parameters [ 'Schedule' ] = $ request -> getSchedule ( ) ; } if ( $ request -> isSetScheduleDate ( ) ) { $ parameters [ 'ScheduleDate' ] = $ this -> getFormattedTimestamp ( $ request -> getScheduleDate ( ) ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
9590	public function radioWithGap ( $ options = [ ] , $ enclosedByLabel = true ) { Html :: addCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radio ( $ options , $ enclosedByLabel ) ; }
11495	public function showAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "page_collection_manager" => $ app [ "red_kite_cms.page_collection_manager" ] , 'form_factory' => $ app [ "form.factory" ] , "pages_collection_parser" => $ app [ "red_kite_cms.pages_collection_parser" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , 'theme' => $ app [ "red_kite_cms.theme" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , 'twig' => $ app [ "twig" ] , ) ; return parent :: show ( $ options ) ; }
86	public function archive ( PackageInterface $ package , $ format , $ targetDir , $ fileName = null , $ ignoreFilters = false ) { if ( empty ( $ format ) ) { throw new \ InvalidArgumentException ( 'Format must be specified' ) ; } $ usableArchiver = null ; foreach ( $ this -> archivers as $ archiver ) { if ( $ archiver -> supports ( $ format , $ package -> getSourceType ( ) ) ) { $ usableArchiver = $ archiver ; break ; } } if ( null === $ usableArchiver ) { throw new \ RuntimeException ( sprintf ( 'No archiver found to support %s format' , $ format ) ) ; } $ filesystem = new Filesystem ( ) ; if ( null === $ fileName ) { $ packageName = $ this -> getPackageFilename ( $ package ) ; } else { $ packageName = $ fileName ; } $ filesystem -> ensureDirectoryExists ( $ targetDir ) ; $ target = realpath ( $ targetDir ) . '/' . $ packageName . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ target ) ) ; if ( ! $ this -> overwriteFiles && file_exists ( $ target ) ) { return $ target ; } if ( $ package instanceof RootPackageInterface ) { $ sourcePath = realpath ( '.' ) ; } else { $ sourcePath = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) ; $ filesystem -> ensureDirectoryExists ( $ sourcePath ) ; try { $ this -> downloadManager -> download ( $ package , $ sourcePath ) ; } catch ( \ Exception $ e ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; throw $ e ; } if ( file_exists ( $ composerJsonPath = $ sourcePath . '/composer.json' ) ) { $ jsonFile = new JsonFile ( $ composerJsonPath ) ; $ jsonData = $ jsonFile -> read ( ) ; if ( ! empty ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ) { $ package -> setArchiveExcludes ( $ jsonData [ 'archive' ] [ 'exclude' ] ) ; } } } $ tempTarget = sys_get_temp_dir ( ) . '/composer_archive' . uniqid ( ) . '.' . $ format ; $ filesystem -> ensureDirectoryExists ( dirname ( $ tempTarget ) ) ; $ archivePath = $ usableArchiver -> archive ( $ sourcePath , $ tempTarget , $ format , $ package -> getArchiveExcludes ( ) , $ ignoreFilters ) ; $ filesystem -> rename ( $ archivePath , $ target ) ; if ( ! $ package instanceof RootPackageInterface ) { $ filesystem -> removeDirectory ( $ sourcePath ) ; } $ filesystem -> remove ( $ tempTarget ) ; return $ target ; }
2452	private function getLocale ( Request $ request ) : string { if ( null !== $ request -> attributes -> get ( '_locale' ) ) { return $ this -> formatLocaleId ( $ request -> attributes -> get ( '_locale' ) ) ; } return $ request -> getPreferredLanguage ( $ this -> availableLocales ) ; }
9363	public function add ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return new self ( $ this -> float_r + $ z -> re , $ this -> float_i + $ z -> im ) ; }
6877	private function buildRevenueData ( array $ result , $ detailed = false ) { $ data = [ ] ; foreach ( $ result as $ r ) { $ data [ $ r [ 'date' ] ] = $ detailed ? json_decode ( $ r [ 'details' ] , true ) : $ r [ 'revenue' ] ; } return $ data ; }
7270	public function save ( $ create = false ) { $ tableName = static :: tableName ( ) ; $ columns = static :: tableColumns ( ) ; $ idColumn = static :: $ idColumn ; $ isModel = false ; $ into = "" ; $ values = "" ; $ updates = "" ; $ condition = "" ; $ params = [ ] ; $ primaries = [ ] ; $ updateCondition = "" ; foreach ( $ columns as $ i => $ column ) { $ name = $ column [ "column_name" ] ; $ key = $ column [ "column_key" ] ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) { $ into .= "$name, " ; $ values .= ":$name, " ; $ updates .= "$name = :$name, " ; $ condition .= "$name = :$name and " ; $ params [ $ name ] = $ this -> encodeValue ( $ name ) ; } if ( strcasecmp ( $ key , "PRI" ) === 0 ) { $ updateCondition .= "$name = :$name and " ; if ( property_exists ( $ this , $ name ) && ! in_array ( $ name , static :: $ autos ) ) $ primaries [ $ name ] = $ this -> encodeValue ( $ name ) ; if ( $ name === $ idColumn ) $ isModel = true ; } } $ into = substr ( $ into , 0 , - 2 ) ; $ values = substr ( $ values , 0 , - 2 ) ; $ updates = substr ( $ updates , 0 , - 2 ) ; $ condition = substr ( $ condition , 0 , - 5 ) ; $ updateCondition = substr ( $ updateCondition , 0 , - 5 ) ; try { $ status = Db :: query ( " insert into $tableName ($into) values ($values) " , $ params , static :: getDbName ( ) , false ) !== false ; } catch ( PDOException $ e ) { if ( $ create ) throw $ e ; if ( $ e -> getCode ( ) === "23000" && preg_match ( "/.*'PRIMARY'$/" , $ e -> getMessage ( ) ) ) { $ status = Db :: query ( " update $tableName set $updates where $updateCondition " , $ params , static :: getDbName ( ) , false ) !== false ; } else throw $ e ; } if ( $ status ) { $ lastInsertId = Db :: instance ( static :: getDbName ( ) ) -> lastInsertId ( ) ; if ( $ lastInsertId > 0 ) return static :: find ( $ lastInsertId ) ; else return static :: select ( "where $updateCondition" , $ primaries , static :: getDbName ( ) ) -> first ( ) ; } else return false ; }
527	public function registerAssetFiles ( $ view ) { $ manager = $ view -> getAssetManager ( ) ; foreach ( $ this -> js as $ js ) { if ( is_array ( $ js ) ) { $ file = array_shift ( $ js ) ; $ options = ArrayHelper :: merge ( $ this -> jsOptions , $ js ) ; $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ js !== null ) { $ view -> registerJsFile ( $ manager -> getAssetUrl ( $ this , $ js ) , $ this -> jsOptions ) ; } } } foreach ( $ this -> css as $ css ) { if ( is_array ( $ css ) ) { $ file = array_shift ( $ css ) ; $ options = ArrayHelper :: merge ( $ this -> cssOptions , $ css ) ; $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ file ) , $ options ) ; } else { if ( $ css !== null ) { $ view -> registerCssFile ( $ manager -> getAssetUrl ( $ this , $ css ) , $ this -> cssOptions ) ; } } } }
2749	public function getVclFile ( $ vclTemplatePath ) { $ moduleEtcPath = $ this -> reader -> getModuleDir ( Dir :: MODULE_ETC_DIR , 'Fastly_Cdn' ) ; $ configFilePath = $ moduleEtcPath . '/' . $ this -> _scopeConfig -> getValue ( self :: FASTLY_CONFIGURATION_PATH ) ; $ directoryRead = $ this -> readFactory -> create ( $ moduleEtcPath ) ; $ configFilePath = $ directoryRead -> getRelativePath ( $ configFilePath ) ; $ data = $ directoryRead -> readFile ( $ configFilePath ) ; return strtr ( $ data , $ this -> getReplacements ( ) ) ; }
5910	public function createSetting ( $ key , $ value ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'key' => $ key , 'value' => $ value ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/settings' , $ parameters ) ; return $ result ; }
12822	protected function resolveOptions ( array $ options ) { if ( $ this -> optionsResolved ) { return ; } $ this -> optionsResolver -> clear ( ) ; $ this -> optionsResolver -> setRequired ( array ( 'blockname' , ) ) ; parent :: resolveOptions ( $ options ) ; $ this -> optionsResolved = true ; }
12104	public function handleRequest ( ) : void { global $ argv ; if ( ! is_array ( $ argv ) || empty ( $ argv ) ) { throw new Exception ( 'Invalid value of the cli args array was given.' ) ; } ( new CliCtrlResolver ( $ argv ) ) -> run ( ) ; }
1717	public function canEditFieldsOf ( $ table ) { if ( $ this -> isAdmin ) { return true ; } return \ count ( preg_grep ( '/^' . preg_quote ( $ table , '/' ) . '::/' , $ this -> alexf ) ) > 0 ; }
2246	public static function isVisibleElement ( Model $ objElement ) { $ blnReturn = true ; if ( TL_MODE == 'FE' ) { if ( $ objElement -> protected ) { if ( ! FE_USER_LOGGED_IN ) { $ blnReturn = false ; } else { $ objUser = FrontendUser :: getInstance ( ) ; if ( ! \ is_array ( $ objUser -> groups ) ) { $ blnReturn = false ; } else { $ groups = StringUtil :: deserialize ( $ objElement -> groups ) ; if ( empty ( $ groups ) || ! \ is_array ( $ groups ) || ! \ count ( array_intersect ( $ groups , $ objUser -> groups ) ) ) { $ blnReturn = false ; } } } } elseif ( $ objElement -> guests && FE_USER_LOGGED_IN ) { $ blnReturn = false ; } } if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'isVisibleElement' ] as $ callback ) { $ blnReturn = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objElement , $ blnReturn ) ; } } return $ blnReturn ; }
6132	protected function getSuffixFlag ( ) { if ( ! $ this -> currObj instanceof Client ) { return "" ; } if ( $ this -> flagpath && $ this -> currObj [ "client_country" ] ) { return $ this -> getImage ( $ this -> currObj [ "client_country" ] -> toLower ( ) . ".png" , $ this -> currObj [ "client_country" ] , null , false , true ) ; } return "" ; }
6956	private function calculatePaymentBase ( SupplierOrderInterface $ order ) { $ base = $ this -> calculateItemsTotal ( $ order ) + $ order -> getShippingCost ( ) - $ order -> getDiscountTotal ( ) ; $ currency = $ order -> getCurrency ( ) -> getCode ( ) ; return Money :: round ( $ base , $ currency ) ; }
12347	public function add ( array $ assets ) { foreach ( $ assets as $ type => $ asset ) { if ( $ asset instanceof Plugin ) { $ this -> parse ( $ asset ) ; continue ; } $ this -> assets [ $ type ] = array_merge ( $ this -> assets [ $ type ] , $ asset ) ; } }
11271	public function render ( $ template , array $ vars = array ( ) ) { ob_start ( ) ; try { $ this -> display ( $ template , $ vars ) ; } catch ( Exception $ exception ) { ob_end_clean ( ) ; throw $ exception ; } return ob_get_clean ( ) ; }
11737	public function getDomain ( $ scheme = false ) { if ( $ scheme ) { return sprintf ( '%s.%s' , $ this -> get ( self :: PARSE_SCHEME ) , $ this -> get ( self :: PARSE_HOST ) ) ; } return $ this -> get ( self :: PARSE_HOST ) ; }
8862	public function getYearlyArchiveLink ( ) { $ date = $ this -> dbObject ( "PublishDate" ) ; return Controller :: join_links ( $ this -> Parent ( ) -> Link ( "archive" ) , $ date -> format ( "Y" ) ) ; }
9703	private function addColor ( $ rgb ) { if ( ! isset ( $ this -> colors [ $ rgb ] ) ) { $ color = [ hexdec ( substr ( $ rgb , 0 , 2 ) ) , hexdec ( substr ( $ rgb , 2 , 2 ) ) , hexdec ( substr ( $ rgb , 4 ) ) , 0 , ] ; $ colorIndex = array_search ( $ color , $ this -> palette ) ; if ( $ colorIndex ) { $ this -> colors [ $ rgb ] = $ colorIndex ; } else { if ( count ( $ this -> colors ) == 0 ) { $ lastColor = 7 ; } else { $ lastColor = end ( $ this -> colors ) ; } if ( $ lastColor < 57 ) { $ colorIndex = $ lastColor + 1 ; $ this -> palette [ $ colorIndex ] = $ color ; $ this -> colors [ $ rgb ] = $ colorIndex ; } else { $ colorIndex = 0 ; } } } else { $ colorIndex = $ this -> colors [ $ rgb ] ; } return $ colorIndex ; }
8478	public function log ( $ level , $ message , array $ context = [ ] ) { if ( $ this -> config ( 'requiredScope' ) && ( empty ( $ context [ 'scope' ] ) ) ) return false ; $ scopes = ( empty ( $ context [ 'scope' ] ) ) ? [ null ] : $ context [ 'scope' ] ; unset ( $ context [ 'scope' ] ) ; $ this -> _context = $ context ; $ Table = TableRegistry :: get ( $ this -> config ( 'model' ) , [ 'table' => $ this -> config ( 'table' ) ] ) ; foreach ( $ scopes as $ scope ) { $ entity = $ Table -> newEntity ( ) ; $ data = [ 'level' => $ level , 'user_id' => $ this -> _userId ( ) , 'scope' => $ scope , 'message' => $ message , 'context' => $ this -> _context , ] ; $ entity = $ Table -> patchEntity ( $ entity , $ data ) ; $ Table -> save ( $ entity ) ; } return true ; }
9463	public function compose ( View $ view ) { $ this -> sidebar -> loadItemsFromConfig ( 'arcanesoft.foundation.sidebar.items' ) ; $ this -> sidebar -> setCurrent ( Arr :: get ( $ view -> getData ( ) , 'current_page' , '' ) ) ; }
444	public function trigger ( $ name , Event $ event = null ) { $ this -> ensureBehaviors ( ) ; $ eventHandlers = [ ] ; foreach ( $ this -> _eventWildcards as $ wildcard => $ handlers ) { if ( StringHelper :: matchWildcard ( $ wildcard , $ name ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ handlers ) ; } } if ( ! empty ( $ this -> _events [ $ name ] ) ) { $ eventHandlers = array_merge ( $ eventHandlers , $ this -> _events [ $ name ] ) ; } if ( ! empty ( $ eventHandlers ) ) { if ( $ event === null ) { $ event = new Event ( ) ; } if ( $ event -> sender === null ) { $ event -> sender = $ this ; } $ event -> handled = false ; $ event -> name = $ name ; foreach ( $ eventHandlers as $ handler ) { $ event -> data = $ handler [ 1 ] ; call_user_func ( $ handler [ 0 ] , $ event ) ; if ( $ event -> handled ) { return ; } } } Event :: trigger ( $ this , $ name , $ event ) ; }
7888	public function logs ( ) { $ logs = array_reverse ( $ this -> filesystem -> files ( ) ) ; foreach ( $ logs as $ index => $ file ) { $ logs [ $ index ] = preg_replace ( '/.*(\d{4}-\d{2}-\d{2}).*/' , '$1' , basename ( $ file ) ) ; } return $ logs ; }
6082	public function removeComment ( $ mediaId , $ commentId ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/media/' . $ mediaId . '/comments/' . $ commentId . '' , $ parameters ) ; $ result = new Comment ( $ result ) ; return $ result ; }
4111	public function findFileAndLine ( $ className ) { $ result = false ; $ fullPath = $ this -> searchFullPath ( $ this -> getFileFromClassName ( $ className ) ) ; if ( $ fullPath ) { $ result = array ( 'file' => $ fullPath , 'line' => 0 ) ; $ lineNumber = $ this -> getLineNumber ( $ fullPath , '/class\s+' . $ className . '/' ) ; if ( $ lineNumber ) { $ result [ 'line' ] = $ lineNumber ; } } return $ result ; }
9356	public function withUri ( UriInterface $ uri , $ preserve = false ) { $ static = clone $ this ; $ static -> uri = $ uri ; if ( ! $ preserve && $ host = $ uri -> getHost ( ) ) { $ port = $ host . ':' . $ uri -> getPort ( ) ; $ host = $ uri -> getPort ( ) ? $ port : $ host ; $ static -> headers [ 'Host' ] = ( array ) $ host ; } return $ static ; }
2030	public static function findPublishedRootPages ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.type=?" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findBy ( $ arrColumns , 'root' , $ arrOptions ) ; }
2274	public function getEditableMemberProperties ( ) { $ return = array ( ) ; Contao \ System :: loadLanguageFile ( 'tl_member' ) ; $ this -> loadDataContainer ( 'tl_member' ) ; foreach ( $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] as $ k => $ v ) { if ( $ v [ 'eval' ] [ 'feEditable' ] ) { $ return [ $ k ] = $ GLOBALS [ 'TL_DCA' ] [ 'tl_member' ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ; } } return $ return ; }
11157	public function handleUrl ( $ url , Event $ event , Queue $ queue ) { $ logger = $ this -> getLogger ( ) ; $ logger -> info ( 'handleUrl' , array ( 'url' => $ url ) ) ; $ v = $ this -> getVideoId ( $ url ) ; $ logger -> info ( 'getVideoId' , array ( 'url' => $ url , 'v' => $ v ) ) ; if ( ! $ v ) { return ; } $ apiUrl = $ this -> getApiUrl ( $ v ) ; $ request = $ this -> getApiRequest ( $ apiUrl , $ event , $ queue ) ; $ this -> getEventEmitter ( ) -> emit ( 'http.request' , array ( $ request ) ) ; }
1782	public static function isValidFileName ( $ strName ) { if ( $ strName == '' ) { return false ; } if ( preg_match ( '@[\\\\/:*?"<>|]@' , $ strName ) ) { return false ; } if ( preg_match ( '/[\pC]/u' , $ strName ) !== 0 ) { return false ; } if ( Utf8 :: strlen ( $ strName ) > 255 ) { return false ; } return true ; }
731	protected function getUniqueIndexInformation ( $ table ) { $ sql = <<<'SQL'SELECT i.relname as indexname, pg_get_indexdef(idx.indexrelid, k + 1, TRUE) AS columnnameFROM ( SELECT *, generate_subscripts(indkey, 1) AS k FROM pg_index) idxINNER JOIN pg_class i ON i.oid = idx.indexrelidINNER JOIN pg_class c ON c.oid = idx.indrelidINNER JOIN pg_namespace ns ON c.relnamespace = ns.oidWHERE idx.indisprimary = FALSE AND idx.indisunique = TRUEAND c.relname = :tableName AND ns.nspname = :schemaNameORDER BY i.relname, kSQL ; return $ this -> db -> createCommand ( $ sql , [ ':schemaName' => $ table -> schemaName , ':tableName' => $ table -> name , ] ) -> queryAll ( ) ; }
3261	public static function placeOrder ( $ cart = null ) { try { if ( empty ( static :: $ gatewayKey ) ) throw new ShopException ( 'Payment gateway not selected.' ) ; if ( empty ( $ cart ) ) $ cart = Auth :: user ( ) -> cart ; $ order = $ cart -> placeOrder ( ) ; $ statusCode = $ order -> statusCode ; \ event ( new OrderPlaced ( $ order -> id ) ) ; static :: $ gateway -> setCallbacks ( $ order ) ; if ( static :: $ gateway -> onCharge ( $ order ) ) { $ order -> statusCode = static :: $ gateway -> getTransactionStatusCode ( ) ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , static :: $ gateway -> getTransactionId ( ) , static :: $ gateway -> getTransactionDetail ( ) , static :: $ gateway -> getTransactionToken ( ) ) ; if ( $ order -> isCompleted ) \ event ( new OrderCompleted ( $ order -> id ) ) ; } else { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; } } catch ( ShopException $ e ) { static :: setException ( $ e ) ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } catch ( GatewayException $ e ) { static :: $ exception = $ e ; if ( isset ( $ order ) ) { $ order -> statusCode = 'failed' ; $ order -> save ( ) ; $ order -> placeTransaction ( static :: $ gatewayKey , uniqid ( ) , static :: $ exception -> getMessage ( ) , $ order -> statusCode ) ; } } if ( $ order ) { static :: checkStatusChange ( $ order , $ statusCode ) ; return $ order ; } else { return ; } }
9326	protected function registerEngines ( ) { $ app = $ this -> app ; $ config = $ app [ 'config' ] ; $ resolver = $ app [ 'view.engine.resolver' ] ; if ( $ config [ 'markdown.tags' ] ) { $ this -> registerBladeEngine ( $ resolver ) ; } if ( $ config [ 'markdown.views' ] ) { $ this -> registerMarkdownEngine ( $ resolver ) ; $ this -> registerMarkdownPhpEngine ( $ resolver ) ; $ this -> registerMarkdownBladeEngine ( $ resolver ) ; } }
2602	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ dictionaryName = Config :: AUTH_DICTIONARY_NAME ; $ dictionary = $ this -> api -> getSingleDictionary ( $ activeVersion , $ dictionaryName ) ; if ( ( is_array ( $ dictionary ) && empty ( $ dictionary ) ) || $ dictionary == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } else { return $ result -> setData ( [ 'status' => true ] ) ; } } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
10466	public function onModify ( ItemPipelineEvent $ event ) { $ item = $ event -> getItem ( ) ; if ( $ item instanceof ImportItem ) { $ this -> modify ( $ item , $ event ) ; } elseif ( $ item instanceof SyncExecuteItem ) { $ syncStorageData = $ item -> getSyncStorageData ( ) ; if ( $ syncStorageData [ 'type' ] !== ActionTypes :: DELETE ) { $ this -> modify ( $ item , $ event ) ; } else { ItemSkipper :: skip ( $ event , 'Delete item with id = ' . $ syncStorageData [ 'id' ] ) ; } } else { $ this -> log ( 'The type of provided item is not ImportItem or SyncExecuteItem.' , LogLevel :: ERROR ) ; } }
81	public static function call ( $ callable ) { try { self :: suppress ( ) ; $ result = call_user_func_array ( $ callable , array_slice ( func_get_args ( ) , 1 ) ) ; self :: restore ( ) ; return $ result ; } catch ( \ Exception $ e ) { self :: restore ( ) ; throw $ e ; } }
2878	public function enableFPCDebugAction ( ) { try { $ this -> getService ( ) -> setFPCDebug ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; $ message = $ this -> __ ( 'FPC debug was enabled' ) ; $ this -> getSession ( ) -> addSuccess ( $ message ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'FPC debug cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
11582	private function getPublicRequireDefinition ( ContainerBuilder $ container , $ id , $ type ) { $ serviceDefinition = $ container -> getDefinition ( $ id ) ; if ( ! $ serviceDefinition -> isPublic ( ) ) { throw new InvalidArgumentException ( sprintf ( 'The service "%s" must be public as block %s are lazy-loaded.' , $ id , $ type ) ) ; } return $ serviceDefinition ; }
8486	public static function getCpuVendor ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT Manufacturer FROM Win32_Processor" ) ; foreach ( $ object as $ cpu ) { return $ cpu -> Manufacturer ; } return 'Unknown' ; }
12259	public function compile ( callable $ validator = NULL ) { if ( ! ( $ project = $ this -> getProject ( ) ) ) { $ project = CC :: get ( $ this -> getConfiguration ( ) , CC :: COMPILER_PROJECT ) ; if ( ! $ project ) throw new CompilerException ( "Compilation without project settings is not possible" ) ; } $ this -> project = $ project ; try { set_error_handler ( function ( $ code , $ msg , $ file , $ line ) { switch ( AbstractErrorHandlerService :: detectErrorLevel ( $ code ) ) { case AbstractErrorHandlerService :: NOTICE_ERROR_LEVEL : return $ this -> getLogger ( ) -> logNotice ( $ msg , [ $ file , $ line ] ) ; case AbstractErrorHandlerService :: DEPRECATED_ERROR_LEVEL : case AbstractErrorHandlerService :: WARNING_ERROR_LEVEL : return $ this -> getLogger ( ) -> logWarning ( $ msg , [ $ file , $ line ] ) ; default : return $ this -> getLogger ( ) -> logError ( $ msg , [ $ file , $ line ] ) ; } } ) ; foreach ( $ this -> getOrganizedCompilers ( ) as $ compiler ) { if ( ! $ validator || $ validator ( $ compiler ) ) $ compiler -> compile ( $ this ) ; } } catch ( Throwable $ throwable ) { $ this -> getLogger ( ) -> logException ( $ throwable ) ; } finally { restore_error_handler ( ) ; } }
10729	public function getDay ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'day' ] ; } }
2350	public function copyTo ( $ strNewName ) { $ strParent = \ dirname ( $ strNewName ) ; if ( ! is_dir ( $ this -> strRootDir . '/' . $ strParent ) ) { new Folder ( $ strParent ) ; } $ return = $ this -> Files -> copy ( $ this -> strFile , $ strNewName ) ; $ syncSource = Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ; $ syncTarget = Dbafs :: shouldBeSynchronized ( $ strNewName ) ; if ( $ syncSource && $ syncTarget ) { Dbafs :: copyResource ( $ this -> strFile , $ strNewName ) ; } elseif ( $ syncTarget ) { Dbafs :: addResource ( $ strNewName ) ; } return $ return ; }
6324	public function start ( ) { if ( ! isset ( $ this -> _dir ) ) { return false ; } $ this -> _page = $ this -> url ; $ this -> _file = $ this -> _dir . md5 ( $ this -> _page ) . '.' . $ this -> _ext ; $ ignore_page = false ; for ( $ i = 0 ; $ i < count ( $ this -> _ignoreList ) ; $ i ++ ) { $ ignore_page = ( strpos ( $ this -> _page , $ this -> _ignoreList [ $ i ] ) !== false ) ? true : $ ignore_page ; } $ cachefile_created = ( file_exists ( $ this -> _file ) && ( $ ignore_page === false ) ) ? filemtime ( $ this -> _file ) : 0 ; clearstatcache ( ) ; if ( time ( ) - $ this -> _time < $ cachefile_created ) { ob_start ( 'ob_gzhandler' ) ; readfile ( $ this -> _file ) ; ob_end_flush ( ) ; exit ( ) ; } ob_start ( 'ob_gzhandler' ) ; }
10543	public function setConfig ( Dictionary $ config ) { $ this -> config = $ config ; $ this -> configureSites ( ) ; $ this -> setVariable ( 'config' , $ config ) ; return $ this ; }
1783	protected function countItems ( $ newsArchives , $ blnFeatured ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'newsListCountItems' ] as $ callback ) { if ( ( $ intResult = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ newsArchives , $ blnFeatured , $ this ) ) === false ) { continue ; } if ( \ is_int ( $ intResult ) ) { return $ intResult ; } } } return NewsModel :: countPublishedByPids ( $ newsArchives , $ blnFeatured ) ; }
10184	function createContactFilter ( $ newFilterObject , $ createTargetGroup , $ version = 1.0 ) { if ( $ version == 1.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> put ( "contactfilters/contactfilter" , $ newFilterObject -> toXMLString ( ) , $ queryParameters ) ; } else if ( $ version == 2.0 ) { $ queryParameters = array ( 'createTargetGroup' => ( $ createTargetGroup ) ? "true" : "false" ) ; return $ this -> post ( "contactfilters/v2" , $ newFilterObject , $ queryParameters , "application/json" ) ; } }
7211	public function validateLoginToken ( string $ token ) : ? array { $ token = base64_decode ( $ token ) ; $ serializedData = Security :: decrypt ( $ token , $ this -> getKey ( ) , $ this -> getSalt ( ) ) ; if ( $ serializedData === false ) { return null ; } $ data = unserialize ( $ serializedData ) ; if ( ! empty ( $ data [ 'expireInterval' ] ) && ! empty ( $ data [ 'timestamp' ] ) ) { $ tokenCreated = new Time ( $ data [ 'timestamp' ] ) ; if ( ! $ tokenCreated -> wasWithinLast ( $ data [ 'expireInterval' ] ) ) { return null ; } } return $ data ; }
4018	protected function initializeWidget ( & $ arrField , $ strRow , $ strKey , $ varValue ) { $ xlabel = $ this -> getHelpWizard ( $ strKey , $ arrField ) ; if ( isset ( $ arrField [ 'input_field_callback' ] ) && is_array ( $ arrField [ 'input_field_callback' ] ) ) { if ( ! is_object ( $ this -> $ arrField [ 'input_field_callback' ] [ 0 ] ) ) { $ this -> import ( $ arrField [ 'input_field_callback' ] [ 0 ] ) ; } return $ this -> { $ arrField [ 'input_field_callback' ] [ 0 ] } -> $ arrField [ 'input_field_callback' ] [ 1 ] ( $ this , $ xlabel ) ; } $ strClass = $ this -> getWidgetClass ( $ arrField ) ; if ( empty ( $ strClass ) ) { return null ; } $ varValue = $ this -> handleLoadCallback ( $ arrField , $ varValue ) ; $ arrField = $ this -> makeMandatory ( $ arrField , $ strRow , $ strKey ) ; $ arrField [ 'name' ] = $ this -> strName . '[' . $ strRow . '][' . $ strKey . ']' ; $ arrField [ 'id' ] = $ this -> strId . '_' . $ strRow . '_' . $ strKey ; $ arrField [ 'value' ] = ( $ varValue !== '' ) ? $ varValue : $ arrField [ 'default' ] ; $ arrField [ 'eval' ] [ 'tableless' ] = true ; $ event = new GetAttributesFromDcaEvent ( $ arrField , $ arrField [ 'name' ] , $ arrField [ 'value' ] , null , $ this -> strTable , $ this -> objDca ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ objWidget -> strId = $ arrField [ 'id' ] ; $ objWidget -> storeValues = true ; $ objWidget -> xlabel = $ xlabel ; return $ objWidget ; }
1748	protected function listSingleRecord ( $ id ) { if ( ! \ strlen ( $ this -> list_info_layout ) ) { $ this -> list_info_layout = 'info_default' ; } $ this -> Template = new FrontendTemplate ( $ this -> list_info_layout ) ; $ this -> Template -> record = array ( ) ; $ this -> Template -> referer = 'javascript:history.go(-1)' ; $ this -> Template -> back = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'goBack' ] ; $ this -> list_info = StringUtil :: deserialize ( $ this -> list_info ) ; $ this -> list_info_where = $ this -> replaceInsertTags ( $ this -> list_info_where , false ) ; $ objRecord = $ this -> Database -> prepare ( "SELECT " . implode ( ', ' , array_map ( 'Database::quoteIdentifier' , trimsplit ( ',' , $ this -> list_info ) ) ) . " FROM " . $ this -> list_table . " WHERE " . ( ( $ this -> list_info_where != '' ) ? "(" . $ this -> list_info_where . ") AND " : "" ) . Database :: quoteIdentifier ( $ this -> strPk ) . "=?" ) -> limit ( 1 ) -> execute ( $ id ) ; if ( $ objRecord -> numRows < 1 ) { return ; } $ arrFields = array ( ) ; $ arrRow = $ objRecord -> row ( ) ; $ limit = \ count ( $ arrRow ) ; $ count = - 1 ; foreach ( $ arrRow as $ k => $ v ) { if ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'password' ) { -- $ limit ; continue ; } $ class = 'row_' . ++ $ count . ( ( $ count == 0 ) ? ' row_first' : '' ) . ( ( $ count >= ( $ limit - 1 ) ) ? ' row_last' : '' ) . ( ( ( $ count % 2 ) == 0 ) ? ' even' : ' odd' ) ; $ arrFields [ $ k ] = array ( 'raw' => $ v , 'label' => ( \ strlen ( $ label = $ GLOBALS [ 'TL_DCA' ] [ $ this -> list_table ] [ 'fields' ] [ $ k ] [ 'label' ] [ 0 ] ) ? $ label : $ k ) , 'content' => $ this -> formatValue ( $ k , $ v , true ) , 'class' => $ class ) ; } $ this -> Template -> record = $ arrFields ; }
3731	protected function fetchRows ( $ arrIds , $ arrAttrOnly = array ( ) ) { $ builder = $ this -> getConnection ( ) -> createQueryBuilder ( ) ; $ query = $ builder -> select ( '*' ) -> from ( $ this -> getTableName ( ) ) -> where ( $ builder -> expr ( ) -> in ( 'id' , ':values' ) ) -> setParameter ( 'values' , $ arrIds , Connection :: PARAM_STR_ARRAY ) -> orderBy ( 'FIELD(id, :values)' ) -> execute ( ) ; if ( $ arrAttrOnly ) { $ arrAttrOnly = array_merge ( $ this -> systemColumns , $ arrAttrOnly ) ; } $ result = [ ] ; while ( $ row = $ query -> fetch ( \ PDO :: FETCH_ASSOC ) ) { $ data = [ ] ; foreach ( $ row as $ attribute => $ value ) { if ( ( ! $ arrAttrOnly ) || ( in_array ( $ attribute , $ arrAttrOnly , true ) ) ) { $ data [ $ attribute ] = $ value ; } } $ result [ $ row [ 'id' ] ] = $ data ; } return $ result ; }
8101	public function getRow ( $ arguments ) { $ sql = 'SELECT * FROM _table_ WHERE _arguments_ LIMIT 1' ; if ( ! $ stmt = $ this -> getStatement ( $ sql , $ arguments ) ) { return false ; } else { return $ stmt -> fetch ( ) ; } }
2917	protected function ensureFileIsWritable ( $ filePath ) { if ( ( is_file ( $ filePath ) && ! is_writable ( $ filePath ) ) || ( ! is_file ( $ filePath ) && ! is_writable ( dirname ( $ filePath ) ) ) ) { throw new UnableWriteToFileException ( sprintf ( 'Unable to write to the file at %s.' , $ filePath ) ) ; } }
9308	public function register ( ) { $ app = $ this -> app ; $ app -> bind ( 'Germanazo\CkanApi\CkanApiClient' , function ( ) { $ config = [ 'base_uri' => config ( 'ckan_api.url' ) , 'headers' => [ 'Authorization' => config ( 'ckan_api.api_key' ) ] , ] ; return new CkanApiClient ( new Client ( $ config ) ) ; } ) ; $ app -> alias ( 'Germanazo\CkanApi\CkanApiClient' , 'CkanApi' ) ; }
12065	public function destroy ( ) { session_start ( ) ; $ _SESSION = array ( ) ; if ( ini_get ( "session.use_cookies" ) ) { $ aParams = session_get_cookie_params ( ) ; setcookie ( session_name ( ) , '' , time ( ) - 42000 , $ aParams [ "path" ] , $ aParams [ "domain" ] , $ aParams [ "secure" ] , $ aParams [ "httponly" ] ) ; } session_destroy ( ) ; }
2519	public function queueList ( RequestOptions \ QueueListOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_List' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
9576	protected function resolveKernel ( ) { if ( $ this -> kernel !== null ) { return $ this -> kernel ; } $ class = 'Symfony\Component\EventDispatcher\EventDispatcherInterface' ; $ eventDispatcher = $ this -> container -> isBound ( $ class ) ? $ this -> container -> resolve ( $ class ) : null ; $ kernel = new Kernel ( $ this -> getRouter ( ) , $ this -> requests , $ this -> errorHandler , $ eventDispatcher ) ; return $ this -> kernel = $ this -> resolveStack ( ) -> resolve ( $ kernel ) ; }
8628	public static function fromXML ( $ xml ) { $ dom = new DOMDocument ( ) ; $ dom -> loadXML ( $ xml ) ; $ xpath = new DOMXPath ( $ dom ) ; $ response = $ xpath -> query ( "//*[local-name()='GetCompetitivePricingForSKUResponse']" ) ; if ( $ response -> length == 1 ) { return new MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse ( ( $ response -> item ( 0 ) ) ) ; } else { throw new Exception ( "Unable to construct MarketplaceWebServiceProducts_Model_GetCompetitivePricingForSKUResponse from provided XML. Make sure that GetCompetitivePricingForSKUResponse is a root element" ) ; } }
1999	private function getAcceptedLocales ( ) : array { $ accepted = [ ] ; $ locales = [ ] ; preg_match_all ( '/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.\d+))?/i' , $ this -> requestStack -> getCurrentRequest ( ) -> headers -> get ( 'accept-language' ) , $ accepted ) ; foreach ( $ accepted [ 1 ] as $ v ) { $ chunks = explode ( '-' , $ v ) ; if ( isset ( $ chunks [ 1 ] ) ) { $ locale = $ chunks [ 0 ] . '-' . strtoupper ( $ chunks [ 1 ] ) ; if ( preg_match ( '/^[a-z]{2}(\-[A-Z]{2})?$/' , $ locale ) ) { $ locales [ ] = $ locale ; } } if ( preg_match ( '/^[a-z]{2}$/' , $ chunks [ 0 ] ) ) { $ locales [ ] = $ chunks [ 0 ] ; } } return \ array_slice ( array_unique ( $ locales ) , 0 , 8 ) ; }
10458	public function validate ( string $ answer ) : string { if ( trim ( ( string ) $ answer ) === '' ) { throw new \ RuntimeException ( sprintf ( '%s Given value: "%s"' , $ this -> getErrorMessage ( ) , $ answer ) ) ; } return $ answer ; }
8789	public function image ( $ url , $ alt = null , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'alt' ] = $ alt ; return $ this -> toHtmlString ( '<img src="' . $ this -> uri -> assets ( $ url , $ secure ) . '"' . $ this -> attributes ( $ attributes ) . '>' ) ; }
7591	public function render ( $ sBadgeMessage , array $ aBadgeAttributes = null ) { if ( ! is_scalar ( $ sBadgeMessage ) ) { throw new InvalidArgumentException ( sprintf ( 'Badge message expects a scalar value, "%s" given' , is_object ( $ sBadgeMessage ) ? get_class ( $ sBadgeMessage ) : gettype ( $ sBadgeMessage ) ) ) ; } if ( empty ( $ aBadgeAttributes ) ) { $ aBadgeAttributes = array ( 'class' => 'badge' ) ; } else { if ( empty ( $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] = 'badge' ; } elseif ( ! preg_match ( '/(\s|^)badge(\s|$)/' , $ aBadgeAttributes [ 'class' ] ) ) { $ aBadgeAttributes [ 'class' ] .= ' badge' ; } } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sBadgeMessage = $ oTranslator -> translate ( $ sBadgeMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ badgeFormat , $ this -> createAttributesString ( $ aBadgeAttributes ) , $ sBadgeMessage ) ; }
3560	protected function getValueType ( $ value ) { $ type = is_object ( $ value ) ? get_class ( $ value ) : gettype ( $ value ) ; return ( $ type == 'double' ) ? 'float' : $ type ; }
7030	public function toArray ( ) { return [ 'o_msg' => $ this -> overflowMessage , 'min_qty' => $ this -> minimumQuantity , 'min_msg' => $ this -> minimumMessage , 'max_qty' => INF === $ this -> maximumQuantity ? 'INF' : $ this -> maximumQuantity , 'max_msg' => $ this -> maximumMessage , 'a_qty' => INF === $ this -> availableQuantity ? 'INF' : $ this -> availableQuantity , 'a_msg' => $ this -> availableMessage , 'r_qty' => $ this -> resupplyQuantity , 'r_msg' => $ this -> resupplyMessage , ] ; }
9098	public function initThemeManager ( ModuleEvent $ e ) { $ moduleManager = $ e -> getTarget ( ) ; $ sm = $ moduleManager -> getEvent ( ) -> getParam ( 'ServiceManager' ) ; $ themManager = $ sm -> get ( 'yimaTheme.Manager' ) ; if ( ! $ themManager instanceof ManagerInterface ) { throw new \ Exception ( sprintf ( 'yimaTheme theme manager most instance of "ManagerInterface" but "%s" given.' , get_class ( $ themManager ) ) ) ; } $ themManager -> init ( ) ; }
11533	public static function readFile ( $ file ) { if ( ! file_exists ( $ file ) ) { return null ; } $ handle = fopen ( $ file , 'r' ) ; if ( ! self :: lockFile ( $ handle , LOCK_SH | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_reading' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } $ contents = file_get_contents ( $ file ) ; self :: unlockFile ( $ handle ) ; return $ contents ; }
6109	public function permAssign ( $ permid , $ permvalue ) { return $ this -> getParent ( ) -> channelPermAssign ( $ this -> getId ( ) , $ permid , $ permvalue ) ; }
9112	public function setVisitTime ( $ visitTime ) { if ( $ visitTime instanceof \ DateTime ) { $ this -> visitTime = $ visitTime ; } else { $ this -> visitTime = new \ DateTime ( $ visitTime ) ; } return $ this ; }
2926	public function load ( $ filePath = null , $ restoreIfNotFound = false , $ restorePath = null ) { $ this -> resetContent ( ) ; if ( ! is_null ( $ filePath ) ) { $ this -> filePath = $ filePath ; } else { if ( method_exists ( $ this -> app , 'environmentPath' ) && method_exists ( $ this -> app , 'environmentFile' ) ) { $ this -> filePath = $ this -> app -> environmentPath ( ) . '/' . $ this -> app -> environmentFile ( ) ; } else { $ this -> filePath = __DIR__ . '/../../../../../../.env' ; } } $ this -> reader -> load ( $ this -> filePath ) ; if ( file_exists ( $ this -> filePath ) ) { $ this -> writer -> setBuffer ( $ this -> getContent ( ) ) ; return $ this ; } elseif ( $ restoreIfNotFound ) { return $ this -> restore ( $ restorePath ) ; } else { return $ this ; } }
2816	public function getCollectionsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getCollections ( ) as $ collection ) { $ data [ ] = array ( 'type' => $ collection -> getType ( ) , 'class' => $ collection -> getClass ( ) , 'sql' => $ collection -> getQuery ( ) , 'count' => $ collection -> getCount ( ) ) ; } return $ data ; }
10691	public function shutdown ( ) { if ( ! $ this -> is_shutdown ) { $ this -> is_shutdown = true ; if ( ! empty ( $ this -> autoloader ) ) spl_autoload_unregister ( array ( $ this -> autoloader , 'autoload' ) ) ; ErrorInterceptor :: unregisterErrorHandler ( ) ; restore_exception_handler ( ) ; } }
3487	private static function tryResolveByWebTokenJwtSystem ( ) : ? WebTokenJwtSignatureGenerator { $ requiredClasses = [ WebTokenComponentJws :: class , WebTokenComponentJwk :: class , WebTokenComponentJWKFactory :: class , ] ; foreach ( $ requiredClasses as $ requiredClass ) { if ( ! class_exists ( $ requiredClass ) ) { return null ; } } return new WebTokenJwtSignatureGenerator ( ) ; }
5816	public function onAfterWrite ( ) { parent :: onAfterWrite ( ) ; $ types = unserialize ( $ this -> TagTypes ) ; $ changed = $ this -> getChangedFields ( ) ; foreach ( $ this -> service -> getFusionTagTypes ( ) as $ type => $ field ) { if ( isset ( $ types [ $ type ] ) ) { $ newTypes = array ( ) ; if ( isset ( $ changed [ 'TagTypes' ] ) ) { $ before = unserialize ( $ changed [ 'TagTypes' ] [ 'before' ] ) ; $ after = unserialize ( $ changed [ 'TagTypes' ] [ 'after' ] ) ; $ newTypes = is_array ( $ before ) ? array_diff ( $ after , $ before ) : $ after ; } if ( ( isset ( $ changed [ 'ID' ] ) || isset ( $ newTypes [ $ type ] ) ) && ! ( $ type :: get ( ) -> filter ( $ field , $ this -> Title ) -> first ( ) ) ) { $ tag = $ type :: create ( ) ; $ tag -> $ field = $ this -> Title ; $ tag -> FusionTagID = $ this -> ID ; $ tag -> write ( ) ; } else if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) && ( $ existing = $ type :: get ( ) -> filter ( $ field , $ changed [ 'Title' ] [ 'before' ] ) ) ) { foreach ( $ existing as $ tag ) { $ tag -> $ field = $ changed [ 'Title' ] [ 'after' ] ; $ tag -> write ( ) ; } } } } if ( ! isset ( $ changed [ 'ID' ] ) && isset ( $ changed [ 'Title' ] ) ) { $ this -> service -> updateTagging ( $ this -> ID ) ; } }
6222	public function getElevation ( $ latitude , $ longitude ) { if ( $ latitude === 0.0 && $ longitude === 0.0 ) { return false ; } if ( ! $ this -> locationIsInBounds ( $ latitude , $ longitude ) ) { throw new InvalidArgumentException ( sprintf ( 'Location (%f, %f) is out of bounds ([-%f, %f], [-%f, %f]).' , $ latitude , $ longitude , static :: MAX_LATITUDE , static :: MAX_LATITUDE , static :: MAX_LONGITUDE , static :: MAX_LONGITUDE ) ) ; } $ filename = $ this -> getFilenameFor ( $ latitude , $ longitude ) ; if ( $ this -> CurrentFilename !== $ filename ) { $ this -> openResource ( $ filename ) ; } return $ this -> getElevationFromResource ( $ latitude , $ longitude ) ; }
10390	public static function loadString ( $ xmlString ) { $ xmlFile = tempnam ( self :: getSysTempDir ( ) , 'xml_' ) ; file_put_contents ( $ xmlFile , $ xmlString ) ; $ xml = self :: parseXml ( $ xmlFile ) ; unlink ( $ xmlFile ) ; return $ xml ; }
1183	protected function getSessionToken ( ) { $ token = null ; if ( $ session = $ this -> app -> __get ( 'session' ) ) { $ token = $ session -> token ( ) ; } if ( $ encrypter = $ this -> app -> __get ( 'encrypter' ) ) { $ token = $ encrypter -> encrypt ( $ token ) ; } return $ token ; }
61	public function isDirEmpty ( $ dir ) { $ finder = Finder :: create ( ) -> ignoreVCS ( false ) -> ignoreDotFiles ( false ) -> depth ( 0 ) -> in ( $ dir ) ; return count ( $ finder ) === 0 ; }
9800	public static function setChartRenderer ( $ rendererClass ) { if ( ! is_a ( $ rendererClass , IRenderer :: class , true ) ) { throw new Exception ( 'Chart renderer must implement ' . IRenderer :: class ) ; } self :: $ chartRenderer = $ rendererClass ; }
10941	public function getModifiedResponse ( Request $ request , $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { $ response = $ this -> getResponse ( $ params , $ lifetime , $ response ) ; if ( $ response -> isNotModified ( $ request ) ) { throw new NotModifiedException ( $ response ) ; } return $ response ; }
9361	public function norm ( ) { if ( $ this -> original ) { return $ this -> original -> rho ; } return sqrt ( pow ( $ this -> float_r , 2 ) + pow ( $ this -> float_i , 2 ) ) ; }
10608	public function passwordRecoveredAction ( ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_201 ) ; $ userService = $ this -> getServiceLocator ( ) -> get ( 'user.service.user' ) ; $ id = $ this -> params ( ) -> fromRoute ( 'id' ) ; try { $ userService -> passwordRecovered ( $ id ) ; $ returnData = array ( 'status' => 'success' , 'message' => 'Ti abbiamo inviato un\'email con la nuova password per il tuo account. Se vorrai potrai modificarla una volta connesso.' ) ; } catch ( \ Exception $ e ) { $ this -> getResponse ( ) -> setStatusCode ( Response :: STATUS_CODE_500 ) ; $ returnData = @ unserialize ( $ e -> getMessage ( ) ) ; if ( ! is_array ( $ returnData ) ) { $ returnData = array ( 'status' => 'danger' , 'message' => $ e -> getMessage ( ) ) ; } } return new JsonModel ( $ returnData ) ; }
150	public function addError ( $ model , $ attribute , $ message , $ params = [ ] ) { $ params [ 'attribute' ] = $ model -> getAttributeLabel ( $ attribute ) ; if ( ! isset ( $ params [ 'value' ] ) ) { $ value = $ model -> $ attribute ; if ( is_array ( $ value ) ) { $ params [ 'value' ] = 'array()' ; } elseif ( is_object ( $ value ) && ! method_exists ( $ value , '__toString' ) ) { $ params [ 'value' ] = '(object)' ; } else { $ params [ 'value' ] = $ value ; } } $ model -> addError ( $ attribute , $ this -> formatMessage ( $ message , $ params ) ) ; }
28	public static function register ( IOInterface $ io = null ) { set_error_handler ( array ( __CLASS__ , 'handle' ) ) ; error_reporting ( E_ALL | E_STRICT ) ; self :: $ io = $ io ; }
5204	public function isActiveURL ( $ url , $ output = "active" ) { if ( $ this -> url -> current ( ) == $ this -> url -> to ( $ url ) ) { return $ output ; } return null ; }
6884	static public function isValidType ( $ type , $ throw = true ) { if ( in_array ( $ type , static :: getTypes ( ) , true ) ) { return true ; } if ( $ throw ) { throw new InvalidArgumentException ( 'Invalid notification type.' ) ; } return false ; }
1198	protected function escape ( $ value ) { return $ this -> fixDoubleEscape ( htmlspecialchars ( ( string ) $ value , ENT_QUOTES | ENT_SUBSTITUTE , $ this -> charset ) ) ; }
7132	protected function updateExchangeRate ( SupplierOrderInterface $ order ) { if ( null !== $ order -> getExchangeRate ( ) ) { return false ; } if ( ! SupplierOrderStates :: isStockableState ( $ order -> getState ( ) ) ) { return false ; } $ date = new \ DateTime ( ) ; $ rate = $ this -> currencyConverter -> getRate ( $ this -> currencyConverter -> getDefaultCurrency ( ) , $ order -> getCurrency ( ) -> getCode ( ) , $ date ) ; $ order -> setExchangeRate ( $ rate ) -> setExchangeDate ( $ date ) ; return true ; }
6095	public function permAssign ( $ permid , $ permvalue , $ permskip = false ) { return $ this -> getParent ( ) -> clientPermAssign ( $ this [ "client_database_id" ] , $ permid , $ permvalue , $ permskip ) ; }
634	public function createTable ( $ table , $ columns , $ options = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> createTable ( $ table , $ columns , $ options ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
7299	public static function sender_to_message ( $ message , $ options , $ id ) { $ author = NULL ; $ commenter = NULL ; $ parts = array ( ) ; if ( 'iac_post_message' == current_filter ( ) ) { $ post = get_post ( $ id ) ; $ author = get_userdata ( $ post -> post_author ) ; if ( ! is_a ( $ author , 'WP_User' ) ) { return $ message ; } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ author -> data -> display_name ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } elseif ( 'iac_comment_message' == current_filter ( ) ) { $ comment = get_comment ( $ id ) ; $ post = get_post ( $ comment -> comment_post_ID ) ; $ commenter = array ( 'name' => 'Annonymous' ) ; if ( 0 != $ comment -> user_id ) { $ author = get_userdata ( $ comment -> user_id ) ; $ commenter [ 'name' ] = $ author -> data -> display_name ; } else { if ( ! empty ( $ comment -> comment_author ) ) { $ commenter [ 'name' ] = $ comment -> comment_author ; } } $ parts = array ( '' , implode ( ' ' , array ( $ options [ 'static_options' ] [ 'mail_string_by' ] , $ commenter [ 'name' ] , $ options [ 'static_options' ] [ 'mail_string_to' ] , get_the_title ( $ post -> ID ) , ) ) , implode ( ': ' , array ( $ options [ 'static_options' ] [ 'mail_string_url' ] , get_permalink ( $ post ) ) ) ) ; } if ( ! empty ( $ parts ) ) { $ message .= implode ( PHP_EOL , $ parts ) ; } return $ message ; }
2666	public function dictionaryItemsList ( $ dictionaryId ) { $ url = $ this -> _getApiServiceUri ( ) . 'dictionary/' . $ dictionaryId . '/items' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: GET ) ; return $ result ; }
7675	function TbsStoreGet ( $ idx , $ caller ) { $ this -> LastReadNotStored = false ; if ( $ idx === $ this -> TbsCurrIdx ) { return $ this -> TBS -> Source ; } elseif ( isset ( $ this -> TbsStoreLst [ $ idx ] ) ) { $ txt = $ this -> TbsStoreLst [ $ idx ] [ 'src' ] ; if ( $ caller === false ) $ this -> TbsStoreLst [ $ idx ] [ 'src' ] = '' ; return $ txt ; } else { $ this -> LastReadNotStored = true ; $ txt = $ this -> FileRead ( $ idx , true ) ; if ( $ this -> LastReadComp > 0 ) { if ( $ caller === false ) { return $ txt ; } else { return $ this -> RaiseError ( "(" . $ caller . ") unable to uncompress '" . $ this -> TbsGetFileName ( $ idx ) . "'." ) ; } } else { return $ txt ; } } }
6320	public function getColumn ( $ name ) { foreach ( $ this -> columns as $ column ) { if ( $ column -> getName ( ) == $ name ) { return $ column ; } } return null ; }
4342	public function start ( ) { if ( $ this -> isProfiling ) { return false ; } $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS ) ; $ backtrace = $ this -> backtraceRemoveInternal ( $ backtrace ) ; foreach ( $ backtrace as $ frame ) { $ class = isset ( $ frame [ 'class' ] ) ? $ frame [ 'class' ] . '::' : '' ; $ this -> rootStack [ ] = $ class . $ frame [ 'function' ] ; } \ register_tick_function ( array ( $ this , 'tickFunction' ) ) ; $ this -> isProfiling = true ; $ this -> timeLastTick = \ microtime ( true ) ; return true ; }
9927	private function cleanUnwanted ( Parameters $ params , $ permitted ) { foreach ( $ params -> toArray ( ) as $ key => $ value ) { if ( is_array ( $ value ) && ! is_int ( $ key ) ) { if ( ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } elseif ( ! is_int ( $ key ) && ! in_array ( $ key , $ permitted ) && ! array_key_exists ( $ key , $ permitted ) ) { $ this -> handleUnpermittedParam ( $ key , $ params ) ; } } }
7711	function Delete ( $ Contents = true ) { $ this -> FindEndTag ( ) ; if ( $ Contents || $ this -> SelfClosing ) { $ this -> ReplaceSrc ( '' ) ; } else { $ inner = $ this -> GetInnerSrc ( ) ; $ this -> ReplaceSrc ( $ inner ) ; } }
569	protected function encrypt ( $ data , $ passwordBased , $ secret , $ info ) { if ( ! extension_loaded ( 'openssl' ) ) { throw new InvalidConfigException ( 'Encryption requires the OpenSSL PHP extension' ) ; } if ( ! isset ( $ this -> allowedCiphers [ $ this -> cipher ] [ 0 ] , $ this -> allowedCiphers [ $ this -> cipher ] [ 1 ] ) ) { throw new InvalidConfigException ( $ this -> cipher . ' is not an allowed cipher' ) ; } list ( $ blockSize , $ keySize ) = $ this -> allowedCiphers [ $ this -> cipher ] ; $ keySalt = $ this -> generateRandomKey ( $ keySize ) ; if ( $ passwordBased ) { $ key = $ this -> pbkdf2 ( $ this -> kdfHash , $ secret , $ keySalt , $ this -> derivationIterations , $ keySize ) ; } else { $ key = $ this -> hkdf ( $ this -> kdfHash , $ secret , $ keySalt , $ info , $ keySize ) ; } $ iv = $ this -> generateRandomKey ( $ blockSize ) ; $ encrypted = openssl_encrypt ( $ data , $ this -> cipher , $ key , OPENSSL_RAW_DATA , $ iv ) ; if ( $ encrypted === false ) { throw new \ yii \ base \ Exception ( 'OpenSSL failure on encryption: ' . openssl_error_string ( ) ) ; } $ authKey = $ this -> hkdf ( $ this -> kdfHash , $ key , null , $ this -> authKeyInfo , $ keySize ) ; $ hashed = $ this -> hashData ( $ iv . $ encrypted , $ authKey ) ; return $ keySalt . $ hashed ; }
6158	protected function renderItem ( $ link , $ template ) { if ( isset ( $ link [ 'label' ] ) ) { $ label = $ this -> encodeLabels ? Html :: encode ( $ link [ 'label' ] ) : $ link [ 'label' ] ; } else { throw new InvalidConfigException ( 'The "label" element is required for each link.' ) ; } if ( $ link [ 'options' ] [ 'class' ] ) { $ label = Html :: tag ( 'i' , '' , $ link [ 'options' ] ) . $ label ; } if ( isset ( $ link [ 'url' ] ) ) { return strtr ( $ template , [ '{link}' => Html :: a ( $ label , $ link [ 'url' ] ) ] ) ; } else { return strtr ( $ template , [ '{link}' => $ label ] ) ; } }
7659	function AddrAppend ( $ type , $ addr ) { $ addr_str = $ type . ": " ; $ addr_str .= $ this -> AddrFormat ( $ addr [ 0 ] ) ; if ( count ( $ addr ) > 1 ) { for ( $ i = 1 ; $ i < count ( $ addr ) ; $ i ++ ) $ addr_str .= ", " . $ this -> AddrFormat ( $ addr [ $ i ] ) ; } $ addr_str .= $ this -> LE ; return $ addr_str ; }
8805	protected function driver ( ) { if ( $ this -> getDefaultDriver ( ) === 'argon' ) { return $ this -> createArgonDriver ( ) ; } elseif ( $ this -> getDefaultDriver ( ) === 'argon2id' ) { return $ this -> createArgon2IdDriver ( ) ; } return $ this -> createBcryptDriver ( ) ; }
8595	public function getServiceStatus ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_GetServiceStatusRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetServiceStatus' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_GetServiceStatusResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8305	public function assertGreaterThan ( $ config , $ keyGreater , $ keyLower ) { if ( ! isset ( $ config [ $ keyLower ] ) || ! isset ( $ config [ $ keyGreater ] ) || $ config [ $ keyLower ] >= $ config [ $ keyGreater ] ) { throw new ConfigurationException ( $ keyGreater . " must be greater than " . $ keyLower ) ; } return $ this ; }
5982	protected function getClient ( ) { if ( ! ( $ this -> client instanceof Client ) ) { $ handlerStack = HandlerStack :: create ( ) ; $ handlerStack = $ this -> withOAuth2MiddleWare ( $ handlerStack ) ; $ this -> client = new Client ( [ 'handler' => $ handlerStack , 'auth' => 'oauth2' , 'base_uri' => $ this -> basepath , 'headers' => [ 'Accept' => 'application/json' , 'Content-type' => 'application/json' , 'User-Agent' => 'qbank3api-phpwrapper/2 (qbankapi: 1; swagger: 1.1)' , ] , 'verify' => $ this -> verifyCertificates , ] ) ; $ this -> logger -> debug ( 'Guzzle client instantiated.' , [ 'basepath' => $ this -> basepath ] ) ; } return $ this -> client ; }
7514	function next_search ( $ characters , $ callback = true ) { $ this -> token_start = $ this -> pos ; if ( ! is_array ( $ characters ) ) { $ characters = array_fill_keys ( str_split ( $ characters ) , true ) ; } while ( ++ $ this -> pos < $ this -> size ) { if ( isset ( $ characters [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( $ callback && isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
11847	final public function save ( ) { $ this -> checkReadOnly ( ) ; $ this -> _save ( ) ; if ( count ( $ this -> _errors ) ) { throw new Zend_Db_Table_Row_Exception ( 'This row contain errors.' ) ; } foreach ( $ this -> _data as $ column => & $ value ) { if ( $ value instanceof DateTime ) { if ( ! ( $ value instanceof Benri_Util_DateTime ) ) { $ value = new Benri_Util_DateTime ( $ value -> format ( 'U' ) ) ; } $ value -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> isNewRecord ( ) ) { if ( $ this -> offsetExists ( 'created_at' ) ) { $ this -> created_at = new Benri_Util_DateTime ( ) ; $ this -> created_at -> setFormat ( 'Y-m-d H:i:s' ) ; } } if ( $ this -> offsetExists ( 'updated_at' ) ) { $ this -> updated_at = new Benri_Util_DateTime ( ) ; $ this -> updated_at -> setFormat ( 'Y-m-d H:i:s' ) ; } parent :: save ( ) ; $ this -> _postSave ( ) ; return $ this ; }
10291	protected function aquireLock ( ) { $ lockfile = $ this -> lockDir . '/lock' ; $ fp = @ fopen ( $ lockfile , 'x' ) ; if ( $ fp === false ) { $ this -> logger -> log ( sprintf ( 'The lockfile %s does already exist.' , $ lockfile ) , Logger :: WARNING ) ; return false ; } fwrite ( $ fp , time ( ) ) ; fclose ( $ fp ) ; $ this -> logger -> log ( 'Aquired lock.' , Logger :: INFO ) ; return true ; }
5579	public function clickImageById ( $ id , $ x = 1 , $ y = 1 , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormByImage ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitImage ( new SelectById ( $ id ) , $ x , $ y , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
3006	static public function jump ( \ Base $ f3 , $ params ) { $ target = $ f3 -> get ( 'GET.target' ) ; if ( $ f3 -> exists ( 'mailer.on.jump' , $ jump_handler ) ) $ f3 -> call ( $ jump_handler , array ( $ target , $ params ) ) ; $ f3 -> reroute ( urldecode ( $ target ) ) ; }
134	public function isPackageInstalled ( InstalledRepositoryInterface $ repo , PackageInterface $ package ) { if ( $ package instanceof AliasPackage ) { return $ repo -> hasPackage ( $ package ) && $ this -> isPackageInstalled ( $ repo , $ package -> getAliasOf ( ) ) ; } return $ this -> getInstaller ( $ package -> getType ( ) ) -> isInstalled ( $ repo , $ package ) ; }
11116	public function drop ( ) : void { $ dropped = $ this -> repository -> drop ( ) ; if ( count ( $ dropped ) === 0 ) { return ; } $ this -> notify -> note ( '' ) ; foreach ( $ dropped as [ $ type , $ value ] ) { $ type = ucfirst ( $ type ) ; $ this -> notify -> note ( "<comment>{$type}</comment> \"{$value}\" <comment>dropped</comment>" ) ; } }
10517	private function getMediaIdentifiers ( $ values ) { $ identifiers = [ ] ; foreach ( $ values as $ key => $ id ) { if ( is_int ( $ key ) ) { $ identifiers [ ] = $ id ; } } return $ identifiers ; }
9169	public function setTimestampCreated ( $ postTime ) { if ( $ postTime instanceof DateTime ) { $ this -> timestampCreated = $ postTime ; } else { $ this -> timestampCreated = new DateTime ( $ postTime ) ; } return $ this ; }
10099	private function writeString ( $ row , $ col , $ str , $ xfIndex ) { $ this -> writeLabelSst ( $ row , $ col , $ str , $ xfIndex ) ; }
8589	public function setReportScheduleList ( $ reportSchedule ) { if ( ! $ this -> _isNumericArray ( $ reportSchedule ) ) { $ reportSchedule = array ( $ reportSchedule ) ; } $ this -> fields [ 'ReportSchedule' ] [ 'FieldValue' ] = $ reportSchedule ; return $ this ; }
1272	public function isValid ( ) { if ( AddressValidation :: REQUEST_OPTION_ADDRESS_CLASSIFICATION == $ this -> requestAction ) { return $ this -> response -> AddressClassification -> Code > 0 ; } return isset ( $ this -> response -> ValidAddressIndicator ) ; }
3101	private function getSubIdentifiersRecursively ( $ array , $ identifiers ) { $ identifier = array_shift ( $ identifiers ) ; if ( count ( $ identifiers ) > 0 ) { $ result = [ ] ; foreach ( $ array [ $ identifier ] as $ key => $ value ) { $ result [ ] = $ this -> getSubIdentifiersRecursively ( $ array [ $ identifier ] [ $ key ] , $ identifiers ) ; } return array_merge ( ... $ result ) ; } return array_keys ( $ array [ $ identifier ] ) ; }
5064	public function exec ( ) : string { ob_start ( ) ; $ response = curl_exec ( $ this -> ch ) ; $ this -> buffer = ob_get_contents ( ) ; ob_end_clean ( ) ; if ( false === $ response ) { throw new CurlException ( $ this -> error ( ) ) ; } if ( true === $ response ) { $ response = $ this -> buffer ; } return $ response ; }
11393	public static function activateError ( $ iLevel ) { if ( self :: $ _bFirstActivation === true ) { self :: _setFileNameInErrorFile ( ) ; self :: $ _bFirstActivation = false ; } self :: _initLogFile ( ) ; self :: $ _bActivateError = true ; error_reporting ( $ iLevel ) ; set_error_handler ( function ( $ iErrNo , $ sErrStr , $ sErrFile , $ iErrLine ) { $ aContext = array ( 'file' => $ sErrFile , 'line' => $ iErrLine ) ; $ sType = self :: getTranslateErrorCode ( $ iErrNo ) ; self :: getInstance ( ) -> $ sType ( $ sErrStr , $ aContext ) ; return true ; } , $ iLevel ) ; register_shutdown_function ( function ( ) { if ( null !== ( $ aLastError = error_get_last ( ) ) ) { $ aContext = array ( 'file' => $ aLastError [ 'file' ] , 'line' => $ aLastError [ 'line' ] ) ; $ sType = self :: getTranslateErrorCode ( $ aLastError [ 'type' ] ) ; self :: getInstance ( ) -> $ sType ( $ aLastError [ 'message' ] , $ aContext ) ; } } ) ; }
2102	protected static function resolveCustomModifiers ( $ strDate ) { if ( strpos ( $ strDate , '::' ) === false ) { return $ strDate ; } System :: loadLanguageFile ( 'default' ) ; if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'dayShortLength' ] = 3 ; } if ( ! $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] ) { $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'monthShortLength' ] = 3 ; } $ strReturn = '' ; $ chunks = preg_split ( "/([0-9]{1,2}::[1-4])/" , $ strDate , - 1 , PREG_SPLIT_DELIM_CAPTURE ) ; foreach ( $ chunks as $ chunk ) { list ( $ index , $ flag ) = explode ( '::' , $ chunk ) ; switch ( $ flag ) { case 1 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS' ] [ $ index ] ; break ; case 2 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'DAYS_SHORT' ] [ $ index ] ; break ; case 3 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS' ] [ ( $ index - 1 ) ] ; break ; case 4 : $ strReturn .= $ GLOBALS [ 'TL_LANG' ] [ 'MONTHS_SHORT' ] [ ( $ index - 1 ) ] ; break ; default : $ strReturn .= $ chunk ; break ; } } return $ strReturn ; }
10939	public function get ( $ key ) { if ( ! ( $ time = $ this -> driver -> get ( $ key ) ) ) { if ( $ key == self :: LAST_UPDATE_KEY ) { $ time = $ this -> reset ( ) ; } else { $ time = $ this -> get ( self :: LAST_UPDATE_KEY ) ; } } return $ time ; }
1490	public function equalsTo ( MediaTypeInterface $ mediaType ) : ? Decoding { return collect ( $ this -> stack ) -> first ( function ( Decoding $ decoding ) use ( $ mediaType ) { return $ decoding -> equalsTo ( $ mediaType ) ; } ) ; }
3345	public function __batchProcessFilesChunk ( $ filesUuidArr , $ request_type ) { if ( count ( $ filesUuidArr ) > $ this -> batchFilesChunkSize ) { throw new \ Exception ( 'Files number should not exceed ' . $ this -> batchFilesChunkSize . ' items per request.' ) ; } $ data = $ this -> __preparedRequest ( 'files_storage' , $ request_type , array ( ) , $ filesUuidArr ) ; $ files_raw = ( array ) $ data -> result ; $ result = array ( ) ; foreach ( $ files_raw as $ file_raw ) { $ result [ ] = new File ( $ file_raw -> uuid , $ this , $ file_raw ) ; } return array ( 'status' => ( string ) $ data -> status , 'files' => $ result , 'problems' => $ data -> problems , ) ; }
4930	public function detach ( EventManagerInterface $ events ) { foreach ( $ this -> listeners as $ i => $ listener ) { if ( $ events -> detach ( $ listener ) ) { unset ( $ this -> listeners [ $ i ] ) ; } } return empty ( $ this -> listeners ) ; }
12239	public function innerXML ( ) { $ xml = $ this -> outerXML ( ) ; $ pos = 1 + strpos ( $ xml , '>' ) ; $ len = strrpos ( $ xml , '<' ) - $ pos ; return substr ( $ xml , $ pos , $ len ) ; }
2199	public static function findPublishedByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
12714	protected function resolveMethodParameters ( $ params = [ ] ) { if ( ! is_array ( $ params ) ) { throw new \ InvalidArgumentException ( sprintf ( "Parameter 1 of %s must be an array." , __METHOD__ ) ) ; } foreach ( $ params as $ key => $ value ) { if ( $ value instanceof \ ReflectionParameter ) { $ class = $ value -> getClass ( ) ; if ( $ class instanceof \ ReflectionClass ) { if ( $ class -> isInterface ( ) ) { $ params [ $ key ] = $ this -> getConcreteFromInterface ( $ class -> getName ( ) ) ; } else { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ class -> getName ( ) ) ; } } else { $ params [ $ key ] = ( $ value -> isDefaultValueAvailable ( ) ? $ value -> getDefaultValue ( ) : null ) ; } } else { if ( is_string ( $ value ) && class_exists ( $ value ) ) { $ params [ $ key ] = $ this -> circularDependencyResolver ( $ value ) ; } elseif ( $ value instanceof \ Closure ) { $ params [ $ key ] = $ value ( $ this ) ; } else { $ params [ $ key ] = $ value ; } } } return $ params ; }
10262	public function getInternet ( $ person_name = null , $ company = null ) { if ( empty ( $ person_name ) ) { $ person_name = $ this -> getFullName ( ) ; } $ internet = new Entities \ Internet ( ) ; $ internet -> domain = $ this -> getDomain ( $ company ) ; $ internet -> username = $ this -> getUserName ( $ person_name ) ; $ internet -> email = $ this -> getEmail ( $ person_name , $ internet -> domain ) ; $ internet -> url = $ this -> getUrl ( $ internet -> domain ) ; $ internet -> ip = $ this -> getIp ( ) ; return $ internet ; }
7207	public function finalize ( ) : void { $ this -> round ( ) ; $ old = $ this -> taxes ; usort ( $ old , function ( Adjustment $ a , Adjustment $ b ) : int { if ( $ a -> getAmount ( ) == $ b -> getAmount ( ) ) { return 0 ; } return $ a -> getAmount ( ) > $ b -> getAmount ( ) ? 1 : - 1 ; } ) ; $ new = [ ] ; $ total = 0 ; foreach ( $ old as $ tax ) { $ amount = Money :: round ( $ tax -> getAmount ( ) , $ this -> currency ) ; if ( $ total + $ amount > $ this -> tax ) { $ amount = $ this -> tax - $ total ; } $ total += $ amount ; $ new [ ] = new Adjustment ( $ tax -> getName ( ) , $ amount , $ tax -> getRate ( ) ) ; } usort ( $ new , function ( Adjustment $ a , Adjustment $ b ) : int { return $ a -> getRate ( ) > $ b -> getRate ( ) ? 1 : - 1 ; } ) ; $ this -> taxes = $ new ; }
8138	public function getTemplateClass ( $ name , $ index = null ) { $ key = $ this -> getLoader ( ) -> getCacheKey ( $ name ) . $ this -> optionsHash ; return $ this -> templateClassPrefix . hash ( 'sha256' , $ key ) . ( null === $ index ? '' : '_' . $ index ) ; }
3073	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = ( $ this -> getRequestParameter ( 'start' ) !== false ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( ! $ this -> getRunnerService ( ) -> isTerminated ( $ serviceContext ) ) { $ this -> endItemTimer ( $ this -> getTime ( ) ) ; $ this -> saveItemState ( ) ; } $ this -> initServiceContext ( ) ; $ this -> saveItemResponses ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> timeout ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
12583	static function run_tool_version ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { pake_echo ( "eZ Extension Builder ver." . self :: VERSION . "\nRunning on pake " . pakeApp :: VERSION ) ; }
5033	public function extract ( $ value ) { if ( ! $ value instanceof FileInterface ) { return null ; } $ tmp = tempnam ( sys_get_temp_dir ( ) , 'yk-copy.' ) ; $ out = fopen ( $ tmp , 'w' ) ; $ in = $ value -> getResource ( ) ; register_shutdown_function ( function ( $ filename ) { @ unlink ( $ filename ) ; } , $ tmp ) ; while ( ! feof ( $ in ) ) { fputs ( $ out , fgets ( $ in , 1024 ) ) ; } fclose ( $ in ) ; fclose ( $ out ) ; $ return = [ "file" => $ tmp ] ; foreach ( [ 'user' , 'name' , 'type' ] as $ key ) { $ v = $ value -> { "get$key" } ( ) ; if ( $ v ) { $ return [ $ key ] = $ v ; } } return $ return ; }
3137	public function parsesItemResponse ( RunnerServiceContext $ context , $ itemRef , $ response ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ currentItem = $ context -> getCurrentAssessmentItemRef ( ) ; $ responses = new State ( ) ; if ( $ currentItem === false ) { $ msg = "Trying to store item variables but the state of the test session is INITIAL or CLOSED.\n" ; $ msg .= "Session state value: " . $ session -> getState ( ) . "\n" ; $ msg .= "Session ID: " . $ session -> getSessionId ( ) . "\n" ; $ msg .= "JSON Payload: " . mb_substr ( json_encode ( $ response ) , 0 , 1000 ) ; \ common_Logger :: e ( $ msg ) ; } $ filler = new \ taoQtiCommon_helpers_PciVariableFiller ( $ currentItem , $ this -> getServiceManager ( ) -> get ( QtiFlysystemFileManager :: SERVICE_ID ) ) ; if ( is_array ( $ response ) ) { foreach ( $ response as $ id => $ responseData ) { try { $ var = $ filler -> fill ( $ id , $ responseData ) ; if ( \ taoQtiCommon_helpers_Utils :: isQtiFilePlaceHolder ( $ var ) === false ) { $ responses -> setVariable ( $ var ) ; } } catch ( \ OutOfRangeException $ e ) { \ common_Logger :: d ( "Could not convert client-side value for variable '${id}'." ) ; } catch ( \ OutOfBoundsException $ e ) { \ common_Logger :: d ( "Could not find variable with identifier '${id}' in current item." ) ; } } } else { \ common_Logger :: e ( 'Invalid json payload' ) ; } return $ responses ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'storeItemResponse' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
1243	private static function actualValue ( array $ info , $ value ) { if ( is_object ( $ value ) ) { return $ value ; } $ types = explode ( '|' , $ info [ 'type' ] ) ; foreach ( $ types as $ type ) { switch ( $ type ) { case 'integer' : case 'string' : case 'double' : case 'boolean' : case 'any' : return $ value ; case 'DateTime' : return new \ DateTime ( $ value , new \ DateTimeZone ( 'UTC' ) ) ; } } return new $ info [ 'type' ] ( $ value ) ; }
5277	public function where ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( ! in_array ( $ type , array ( 'and' , 'or' , 'where' ) ) ) { throw new \ Exception ( 'Invalid where type "' . $ type . '"' ) ; } $ sub_type = is_null ( $ param1 ) ? $ type : $ param1 ; if ( empty ( $ this -> statements [ 'wheres' ] ) ) { $ type = 'where' ; } if ( is_array ( $ column ) ) { $ subquery = array ( ) ; foreach ( $ column as $ value ) { if ( ! isset ( $ value [ 2 ] ) ) { $ value [ 2 ] = $ value [ 1 ] ; $ value [ 1 ] = '=' ; } $ subquery [ ] = $ this -> generateWhere ( $ value [ 0 ] , $ value [ 1 ] , $ value [ 2 ] , empty ( $ subquery ) ? '' : $ sub_type ) ; } $ this -> statements [ 'wheres' ] [ ] = $ type . ' ( ' . trim ( join ( ' ' , $ subquery ) ) . ' )' ; return $ this ; } $ this -> statements [ 'wheres' ] [ ] = $ this -> generateWhere ( $ column , $ param1 , $ param2 , $ type ) ; return $ this ; }
3185	public function process ( ) { $ this -> validate ( ) ; $ ref = $ this -> getRequestParameter ( 'ref' ) ? : null ; $ itemDuration = null ; $ scope = $ this -> getRequestParameter ( 'scope' ) ; $ start = $ this -> getRequestParameter ( 'start' ) !== false ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; $ this -> getRunnerService ( ) -> endTimer ( $ serviceContext , $ itemDuration , $ this -> getTime ( ) ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> skip ( $ serviceContext , $ scope , $ ref ) ; $ response = [ 'success' => $ result , ] ; if ( $ result ) { $ response [ 'testContext' ] = $ this -> getRunnerService ( ) -> getTestContext ( $ serviceContext ) ; if ( $ serviceContext -> containsAdaptive ( ) ) { $ response [ 'testMap' ] = $ this -> getRunnerService ( ) -> getTestMap ( $ serviceContext , true ) ; } } if ( $ start == true ) { $ this -> getRunnerService ( ) -> startTimer ( $ serviceContext , $ this -> getTime ( ) ) ; } } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
2015	public static function load ( $ class ) { if ( class_exists ( $ class , false ) || interface_exists ( $ class , false ) || trait_exists ( $ class , false ) ) { return ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; if ( isset ( self :: $ classes [ $ class ] ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_set' ] [ $ class ] = $ class ; } include $ rootDir . '/' . self :: $ classes [ $ class ] ; } elseif ( ( $ namespaced = self :: findClass ( $ class ) ) !== null ) { if ( ! class_exists ( $ namespaced , false ) && ! interface_exists ( $ namespaced , false ) && ! trait_exists ( $ namespaced , false ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_aliased' ] [ $ class ] = $ namespaced ; } include $ rootDir . '/' . self :: $ classes [ $ namespaced ] ; } class_alias ( $ namespaced , $ class ) ; } elseif ( strncmp ( $ class , 'Contao\\' , 7 ) !== 0 ) { $ namespaced = 'Contao\\' . $ class ; if ( class_exists ( $ namespaced ) || interface_exists ( $ namespaced ) || trait_exists ( $ namespaced ) ) { if ( Config :: get ( 'debugMode' ) ) { $ GLOBALS [ 'TL_DEBUG' ] [ 'classes_composerized' ] [ $ class ] = $ namespaced ; } if ( ! class_exists ( $ class , false ) && ! interface_exists ( $ class , false ) && ! trait_exists ( $ class , false ) ) { class_alias ( $ namespaced , $ class ) ; } } } }
11329	public function getHuman ( ) { if ( is_null ( $ this -> _human ) ) { $ this -> _human = HumanFieldDetector :: test ( $ this -> fieldSchema ) ; } return $ this -> _human ; }
4069	public function handle ( GetOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ event -> setOptions ( array_flip ( array_filter ( array_flip ( System :: getLanguages ( ) ) , function ( $ langCode ) { return ( strlen ( $ langCode ) == 2 ) ; } ) ) ) ; }
12148	public function getExceptionCode ( \ Exception $ exception ) { $ class = get_class ( $ exception ) ; $ exceptions = $ this -> getExceptions ( ) ; if ( ! isset ( $ exceptions [ $ class ] ) ) { throw new \ RuntimeException ( sprintf ( 'Not exist exception "%s" in storage.' , $ class ) ) ; } return $ exceptions [ $ class ] ; }
7819	public function settle ( ) { $ this -> files -> makeDirectory ( $ this -> path , 0755 , true , true ) ; $ this -> files -> put ( $ this -> getSource ( ) , '' ) ; }
3771	public function fixupModules ( DataContainer $ dataContainer ) { if ( ! class_exists ( 'tl_user_group' , false ) ) { throw new \ RuntimeException ( 'data container is not loaded!' ) ; } $ original = new \ tl_user_group ( ) ; $ modules = $ original -> getModules ( ) ; foreach ( array_keys ( $ modules ) as $ group ) { foreach ( $ modules [ $ group ] as $ key => $ module ) { if ( strpos ( $ module , 'metamodel_' ) === 0 ) { unset ( $ modules [ $ group ] [ $ key ] ) ; } } $ modules [ $ group ] = array_values ( $ modules [ $ group ] ) ; } $ modules [ 'metamodels' ] [ ] = 'support_metamodels' ; if ( false !== $ index = array_search ( 'metamodels' , $ modules [ 'metamodels' ] , true ) ) { unset ( $ modules [ 'metamodels' ] [ $ index ] ) ; $ modules [ 'metamodels' ] = array_values ( $ modules [ 'metamodels' ] ) ; } $ combinations = $ this -> combinationBuilder -> getCombinationsForUser ( [ $ dataContainer -> activeRecord -> id ] , 'be' ) ; $ screenIds = array_map ( function ( $ combination ) { return $ combination [ 'dca_id' ] ; } , $ combinations [ 'byName' ] ) ; $ screens = $ this -> inputScreens -> fetchInputScreens ( $ screenIds ) ; $ locale = $ this -> requestStack -> getCurrentRequest ( ) -> getLocale ( ) ; foreach ( $ screens as $ metaModel => $ screen ) { if ( 'standalone' === $ screen [ 'meta' ] [ 'rendertype' ] ) { $ modules [ $ screen [ 'meta' ] [ 'backendsection' ] ] [ ] = 'metamodel_' . $ metaModel ; $ this -> buildLanguageString ( 'metamodel_' . $ metaModel , $ screen , $ locale ) ; } } return $ modules ; }
2219	public static function countPublishedByPids ( $ arrPids , $ blnFeatured = null , array $ arrOptions = array ( ) ) { if ( empty ( $ arrPids ) || ! \ is_array ( $ arrPids ) ) { return 0 ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrPids ) ) . ")" ) ; if ( $ blnFeatured === true ) { $ arrColumns [ ] = "$t.featured='1'" ; } elseif ( $ blnFeatured === false ) { $ arrColumns [ ] = "$t.featured=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } return static :: countBy ( $ arrColumns , null , $ arrOptions ) ; }
6080	public function updateProperties ( $ id , array $ properties ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'properties' => $ properties ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> put ( 'v1/media/' . $ id . '/properties' , $ parameters ) ; $ result = new MediaResponse ( $ result ) ; return $ result ; }
2784	private function indent ( $ output , $ asArray = false ) { $ lines = explode ( "\n" , $ output ) ; $ out = [ ] ; foreach ( $ lines as $ line ) { $ out [ ] = ' > ' . $ line ; } if ( $ asArray ) { return $ out ; } $ return = implode ( "\n" , $ out ) ; return $ return ; }
8728	public function changeFolder ( HTTPRequest $ request ) { $ token = $ this -> getForm ( ) -> getSecurityToken ( ) ; if ( ! $ token -> checkRequest ( $ request ) ) { return $ this -> httpError ( 400 ) ; } $ folderID = $ request -> postVar ( 'FolderID' ) ; if ( $ folderID ) { $ this -> FolderSelector ( ) -> setLastFolderID ( $ folderID ) ; } }
954	protected function returnTo ( ) { $ return_to = Session :: get ( 'return_to' ) ; if ( $ return_to ) { Session :: forget ( 'return_to' ) ; return Redirect :: to ( $ return_to ) ; } return Redirect :: route ( 'home' ) ; }
7303	public function onParentChange ( ResourceEventInterface $ event ) { $ customer = $ this -> getCustomerFromEvent ( $ event ) ; if ( $ this -> updateFromParent ( $ customer ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ customer , true ) ; } }
4435	public static function fromErrorMessage ( string $ error ) : QlessException { $ area = null ; $ message = $ error ; if ( preg_match ( self :: ERROR_MESSAGE_RE , $ error , $ matches ) > 0 ) { $ area = $ matches [ 'area' ] ; $ message = $ matches [ 'message' ] ; } switch ( true ) { case ( $ area === 'Requeue' && stripos ( $ message , 'does not exist' ) !== false ) : case ( stripos ( $ message , 'Job does not exist' ) !== false ) : return new InvalidJobException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job given out to another worker' ) !== false ) : return new JobLostException ( $ message , $ area ) ; case ( stripos ( $ message , 'Job not currently running' ) !== false ) : default : return new QlessException ( $ message , $ area ) ; } }
11104	protected function registerClientScript ( ) { $ view = $ this -> getView ( ) ; DateTimePickerAssets :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; $ options = Json :: encode ( $ this -> clientOptions ) ; $ view -> registerJs ( "jQuery('#$id').datetimepicker($options);" ) ; }
9118	private function getViewBestMatch ( Request $ request , $ applicationName ) { $ best = null ; if ( count ( $ this -> views [ $ applicationName ] ) > 0 ) { foreach ( $ this -> views [ $ applicationName ] as $ orderLevel => $ views ) { foreach ( $ views as $ view ) { assert ( $ view instanceof View ) ; if ( $ view -> matchBoth ( $ request -> getController ( ) , $ request -> getAction ( ) ) ) { $ best [ $ orderLevel ] = $ view ; continue 2 ; } } } } if ( null == $ best ) { throw new ViewException ( "No view found for request" ) ; } if ( count ( $ best ) > 1 ) { krsort ( $ best ) ; } return reset ( $ best ) ; }
9406	protected function approach ( $ middleware ) { if ( $ middleware instanceof \ Closure ) { $ object = new \ ReflectionFunction ( $ middleware ) ; return count ( $ object -> getParameters ( ) ) === 2 ; } $ class = ( string ) get_class ( $ middleware ) ; $ object = new \ ReflectionMethod ( $ class , '__invoke' ) ; return count ( $ object -> getParameters ( ) ) === 2 ; }
7490	public function reverse ( ) { $ length = $ this -> length ( ) ; $ reversed = '' ; while ( $ length -- > 0 ) { $ reversed .= mb_substr ( $ this -> string , $ length , 1 , $ this -> encoding ) ; } $ this -> string = $ reversed ; return $ this ; }
10926	private function renderCell ( $ columnNumber , $ value , $ filler , $ style = '' ) { $ output = [ ] ; $ width = $ this -> getWidth ( $ columnNumber ) ; $ output [ ] = $ filler ; while ( $ this -> length ( $ value ) < $ width ) { $ value .= $ filler ; } $ output [ ] = Style :: applyStyle ( $ value , $ style ) ; $ output [ ] = $ filler ; return implode ( '' , $ output ) ; }
12359	public static function decodeHashId ( $ idHashed ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ idHashed ; } $ hashids = App :: make ( 'Hashids' ) ; $ hashId = $ hashids -> decode ( $ idHashed ) ; return ( count ( $ hashId ) > 0 ) ? $ hashId [ 0 ] : '' ; }
4635	private function attachMailListeners ( EventsCapableInterface $ service , ContainerInterface $ container , array $ mailOptions ) : void { $ listeners = ( array ) ( $ mailOptions [ 'mail_listeners' ] ?? [ ] ) ; if ( empty ( $ listeners ) ) { return ; } $ definitions = [ ] ; $ eventManager = $ service -> getEventManager ( ) ; foreach ( $ listeners as $ listener ) { $ this -> addDefinitions ( $ definitions , $ listener , $ eventManager ) ; } if ( ! empty ( $ definitions ) ) { ( new LazyListenerAggregate ( $ definitions , $ container ) ) -> attach ( $ eventManager ) ; } }
10296	public function writeChart ( \ PhpOffice \ PhpSpreadsheet \ Chart \ Chart $ pChart , $ calculateCellValues = true ) { $ this -> calculateCellValues = $ calculateCellValues ; $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } if ( $ this -> calculateCellValues ) { $ pChart -> refresh ( ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' , 'yes' ) ; $ objWriter -> startElement ( 'c:chartSpace' ) ; $ objWriter -> writeAttribute ( 'xmlns:c' , 'http://schemas.openxmlformats.org/drawingml/2006/chart' ) ; $ objWriter -> writeAttribute ( 'xmlns:a' , 'http://schemas.openxmlformats.org/drawingml/2006/main' ) ; $ objWriter -> writeAttribute ( 'xmlns:r' , 'http://schemas.openxmlformats.org/officeDocument/2006/relationships' ) ; $ objWriter -> startElement ( 'c:date1904' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:lang' ) ; $ objWriter -> writeAttribute ( 'val' , 'en-GB' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:roundedCorners' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writeAlternateContent ( $ objWriter ) ; $ objWriter -> startElement ( 'c:chart' ) ; $ this -> writeTitle ( $ objWriter , $ pChart -> getTitle ( ) ) ; $ objWriter -> startElement ( 'c:autoTitleDeleted' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ this -> writePlotArea ( $ objWriter , $ pChart -> getWorksheet ( ) , $ pChart -> getPlotArea ( ) , $ pChart -> getXAxisLabel ( ) , $ pChart -> getYAxisLabel ( ) , $ pChart -> getChartAxisX ( ) , $ pChart -> getChartAxisY ( ) , $ pChart -> getMajorGridlines ( ) , $ pChart -> getMinorGridlines ( ) ) ; $ this -> writeLegend ( $ objWriter , $ pChart -> getLegend ( ) ) ; $ objWriter -> startElement ( 'c:plotVisOnly' ) ; $ objWriter -> writeAttribute ( 'val' , 1 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:dispBlanksAs' ) ; $ objWriter -> writeAttribute ( 'val' , 'gap' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:showDLblsOverMax' ) ; $ objWriter -> writeAttribute ( 'val' , 0 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ this -> writePrintSettings ( $ objWriter ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
3666	public function convertParameter ( $ arrMatch ) { list ( $ strSource , $ strQuery ) = explode ( '?' , $ arrMatch [ 1 ] , 2 ) ; parse_str ( $ strQuery , $ arrArgs ) ; $ arrName = ( array ) $ arrArgs [ 'name' ] ; $ var = $ this -> getValueFromSource ( $ strSource , array_shift ( $ arrName ) , $ arrArgs ) ; $ index = 0 ; $ count = count ( $ arrName ) ; while ( $ index < $ count && is_array ( $ var ) ) { $ var = $ var [ $ arrName [ $ index ++ ] ] ; } if ( $ index != $ count || $ var === null ) { if ( array_key_exists ( 'default' , $ arrArgs ) && ( null !== $ arrArgs [ 'default' ] ) ) { $ this -> addParameter ( $ arrArgs [ 'default' ] ) ; return '?' ; } else { return 'NULL' ; } } if ( ! isset ( $ arrArgs [ 'aggregate' ] ) ) { $ this -> addParameter ( $ var ) ; return '?' ; } return $ this -> convertParameterAggregate ( $ var , $ arrArgs ) ; }
3276	public function flush ( ) { $ this -> getDatabase ( ) -> flushFile ( ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> flush ( ) ; } }
10341	protected function validateColumns ( $ columns ) { $ patterns = array ( '((?P<minute>(?:\*|(?:(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)(?:,(?:[0-9]|[1-5][0-9])(?:-(?:[0-9]|[1-5][0-9]))?)*)(?:/(?:[1-9]|[1-5][0-9]))?)$)AD' , '((?P<hour>(?:\*|(?:(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)(?:,(?:[0-9]|1[0-9]|2[0-3])(?:-(?:[0-9]|1[0-9]|2[0-3]))?)*)(?:/(?:[1-9]|1[0-9]|2[0-3]))?)$)AD' , '((?P<dayOfMonth>(?:\*|(?:(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)(?:,(?:[1-9]|[1-2][0-9]|3[0-1])(?:-(?:[1-9]|[1-2][0-9]|3[0-1]))?)*)(?:/(?:[1-9]|[1-2][0-9]|3[0-1]))?)$)AD' , '((?P<month>(?:\*|(?:(?:[1-9]|1[0-2])(?:-(?:[1-9]|1[1-2]))?)(?:,(?:[1-9]|1[1-2])(?:-(?:[1-9]|1[1-2]))?)*)(?:/(?:[1-9]|1[1-2]))?)$)AD' , '((?P<dayOfWeek>(?:\*|(?:(?:[0-7])(?:-(?:[0-7]))?)(?:,(?:[0-7])(?:-(?:[0-7]))?)*)(?:/(?:[1-7]))?)$)AD' , ) ; if ( count ( $ columns ) !== 5 ) { return false ; } foreach ( $ columns as $ key => $ column ) { if ( preg_match ( $ patterns [ $ key ] , $ column ) !== 1 ) { return ( int ) $ key ; } } return true ; }
12607	public static function makeSafe ( $ file ) { $ regex = [ '#(\.){2,}#' , '#[^A-Za-z0-9\.\_\- ]#' , '#^\.#' , ] ; $ file = rtrim ( $ file , '.' ) ; $ clean = preg_replace ( $ regex , ' ' , $ file ) ; $ clean = preg_replace ( "/[ \_]/" , '-' , $ clean ) ; $ clean = preg_replace ( "/[\-]+/" , '-' , $ clean ) ; return $ clean ; }
7061	private function setClasses ( array $ classes ) { if ( ! empty ( $ classes ) ) { $ this -> vars [ 'attr' ] [ 'class' ] = ' ' . trim ( implode ( ' ' , $ classes ) ) ; } else { unset ( $ this -> vars [ 'attr' ] [ 'class' ] ) ; } }
1098	public function updateStructure ( ) { list ( $ a , $ b , $ c , $ d ) = $ this -> boundaries ( ) ; $ this -> applyLockBetween ( $ a , $ d ) ; $ connection = $ this -> node -> getConnection ( ) ; $ grammar = $ connection -> getQueryGrammar ( ) ; $ currentId = $ this -> quoteIdentifier ( $ this -> node -> getKey ( ) ) ; $ parentId = $ this -> quoteIdentifier ( $ this -> parentId ( ) ) ; $ leftColumn = $ this -> node -> getLeftColumnName ( ) ; $ rightColumn = $ this -> node -> getRightColumnName ( ) ; $ parentColumn = $ this -> node -> getParentColumnName ( ) ; $ wrappedLeft = $ grammar -> wrap ( $ leftColumn ) ; $ wrappedRight = $ grammar -> wrap ( $ rightColumn ) ; $ wrappedParent = $ grammar -> wrap ( $ parentColumn ) ; $ wrappedId = $ grammar -> wrap ( $ this -> node -> getKeyName ( ) ) ; $ lftSql = "CASE WHEN $wrappedLeft BETWEEN $a AND $b THEN $wrappedLeft + $d - $b WHEN $wrappedLeft BETWEEN $c AND $d THEN $wrappedLeft + $a - $c ELSE $wrappedLeft END" ; $ rgtSql = "CASE WHEN $wrappedRight BETWEEN $a AND $b THEN $wrappedRight + $d - $b WHEN $wrappedRight BETWEEN $c AND $d THEN $wrappedRight + $a - $c ELSE $wrappedRight END" ; $ parentSql = "CASE WHEN $wrappedId = $currentId THEN $parentId ELSE $wrappedParent END" ; $ updateConditions = array ( $ leftColumn => $ connection -> raw ( $ lftSql ) , $ rightColumn => $ connection -> raw ( $ rgtSql ) , $ parentColumn => $ connection -> raw ( $ parentSql ) ) ; if ( $ this -> node -> timestamps ) $ updateConditions [ $ this -> node -> getUpdatedAtColumn ( ) ] = $ this -> node -> freshTimestamp ( ) ; return $ this -> node -> newNestedSetQuery ( ) -> where ( function ( $ query ) use ( $ leftColumn , $ rightColumn , $ a , $ d ) { $ query -> whereBetween ( $ leftColumn , array ( $ a , $ d ) ) -> orWhereBetween ( $ rightColumn , array ( $ a , $ d ) ) ; } ) -> update ( $ updateConditions ) ; }
8758	public function tick ( $ status = Tick :: SUCCESS , $ msg = null , array $ extraInfo = [ ] , $ incrementBy = 1 ) { if ( ! $ this -> isRunning ( ) ) { $ this -> start ( ) ; } $ tick = new Tick ( $ this , $ status , $ msg , $ extraInfo , $ incrementBy ) ; if ( array_key_exists ( $ tick -> getStatus ( ) , $ this -> numProcessedItems ) ) { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] += $ tick -> getIncrementBy ( ) ; } else { $ this -> numProcessedItems [ $ tick -> getStatus ( ) ] = $ tick -> getIncrementBy ( ) ; } $ this -> dispatcher -> dispatch ( Events :: TRACKER_TICK , $ tick ) ; $ this -> lastTick = $ tick ; return $ tick -> getReport ( ) ; }
5015	public function logFinish ( FinishEvent $ event ) : void { $ this -> getLogger ( ) -> info ( sprintf ( $ this -> tmpl [ 'queue' ] , 'Stop' , $ event -> getQueue ( ) -> getName ( ) ) ) ; $ this -> injectLoggerInEvent ( $ event ) ; }
4148	protected function findExceptions ( $ response ) { $ response = $ response [ 'body' ] ; $ data = json_decode ( $ response , true ) ; if ( isset ( $ response [ 0 ] ) && $ response [ 0 ] !== '{' && $ response [ 0 ] !== '[' && ! $ data ) { if ( strpos ( $ response , 'oauth_token=' ) !== false ) { parse_str ( $ response , $ data ) ; } if ( empty ( $ data ) || ! is_array ( $ data ) ) { throw new TwitterException ( $ response , 0 ) ; } return json_encode ( $ data ) ; } if ( ! empty ( $ data [ 'errors' ] ) || ! empty ( $ data [ 'error' ] ) ) { if ( ! empty ( $ data [ 'errors' ] ) ) { $ data = current ( $ data [ 'errors' ] ) ; } if ( empty ( $ data [ 'message' ] ) && ! empty ( $ data [ 'error' ] ) ) { $ data [ 'message' ] = $ data [ 'error' ] ; } if ( ! isset ( $ data [ 'code' ] ) || empty ( $ data [ 'code' ] ) ) { $ data [ 'code' ] = 0 ; } throw new TwitterException ( $ data [ 'message' ] , $ data [ 'code' ] ) ; } unset ( $ data ) ; return $ response ; }
1117	public static function roots ( ) { $ instance = new static ; return $ instance -> newQuery ( ) -> whereNull ( $ instance -> getParentColumnName ( ) ) -> orderBy ( $ instance -> getQualifiedOrderColumnName ( ) ) ; }
7297	private function modulate_next_group ( $ object_id , $ object_type , $ mail_to_chunks ) { if ( ! empty ( $ mail_to_chunks ) ) { $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] = $ mail_to_chunks ; if ( $ object_type == 'post' ) { $ this -> transit_posts [ $ object_id ] = array ( 'new_status' => 'publish' , 'old_status' => 'draft' ) ; $ this -> inform_about_posts ( $ object_id ) ; } elseif ( $ object_type == 'comment' ) { $ this -> inform_about_comment ( $ object_id ) ; } } else { } }
12945	public function getTagValues ( $ asString = false ) { if ( $ this -> _tagsList === null && ! $ this -> owner -> getIsNewRecord ( ) ) { $ this -> _tagsList = [ ] ; $ relation = $ this -> owner -> getRelation ( 'tagsList' , false ) ; if ( $ relation instanceof ActiveQuery ) { $ this -> _tagsList = array_unique ( $ relation -> select ( 'text' ) -> column ( ) ) ; } } return $ asString === true ? implode ( ',' , $ this -> _tagsList ) : $ this -> _tagsList ; }
6936	private function findBySubjectAndStates ( StockSubjectInterface $ subject , array $ states = [ ] ) { $ units = [ ] ; $ oid = spl_object_hash ( $ subject ) ; if ( isset ( $ this -> addedUnits [ $ oid ] ) ) { $ units = $ this -> addedUnits [ $ oid ] ; } if ( ! empty ( $ units ) && ! empty ( $ states ) ) { $ units = array_filter ( $ units , function ( StockUnitInterface $ unit ) use ( $ states ) { return in_array ( $ unit -> getState ( ) , $ states ) ; } ) ; } return $ units ; }
1773	public function validate ( ) { $ varValue = $ this -> validator ( $ this -> getPost ( $ this -> strName ) ) ; if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } $ this -> varValue = $ varValue ; }
9087	public function attach ( ResolverInterface $ detector , $ priority = 1 ) { $ this -> queue -> insert ( $ detector , $ priority ) ; return $ this ; }
2823	public function deleteExpiredRequests ( ) { $ helper = Mage :: helper ( 'sheep_debug' ) ; if ( ! $ helper -> isEnabled ( ) ) { return 'skipped: module is disabled.' ; } if ( $ helper -> getPersistLifetime ( ) == 0 ) { return 'skipped: lifetime is set to 0' ; } $ expirationDate = $ this -> getExpirationDate ( date ( self :: DATE_FORMAT ) ) ; $ table = $ this -> getRequestsTable ( ) ; $ deleteSql = "DELETE FROM {$table} WHERE date <= '{$expirationDate}'" ; $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ result = $ connection -> query ( $ deleteSql ) ; return "{$result->rowCount()} requests deleted" ; }
4255	protected function buildFatal ( ) { $ haveFatal = isset ( $ this -> stats [ 'counts' ] [ 'fatal' ] ) ; if ( ! $ haveFatal ) { return '' ; } $ lastError = $ this -> errorHandler -> get ( 'lastError' ) ; $ isHtml = $ lastError [ 'isHtml' ] ; $ backtrace = $ lastError [ 'backtrace' ] ; $ html = '<h3>Fatal Error</h3>' ; $ html .= '<ul class="list-unstyled indent">' ; if ( \ count ( $ backtrace ) > 1 ) { $ table = $ this -> outputHtml -> buildTable ( $ backtrace , array ( 'attribs' => 'trace table-bordered' , 'caption' => 'trace' , 'columns' => array ( 'file' , 'line' , 'function' ) , ) ) ; $ html .= '<li>' . $ lastError [ 'message' ] . '</li>' ; $ html .= '<li>' . $ table . '</li>' ; if ( ! $ isHtml ) { $ html = \ str_replace ( $ lastError [ 'message' ] , \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ html ) ; } } else { $ keysKeep = array ( 'typeStr' , 'message' , 'file' , 'line' ) ; $ lastError = \ array_intersect_key ( $ lastError , \ array_flip ( $ keysKeep ) ) ; $ html .= '<li>' . $ this -> outputHtml -> dump ( $ lastError ) . '</li>' ; if ( $ isHtml ) { $ html = \ str_replace ( \ htmlspecialchars ( $ lastError [ 'message' ] ) , $ lastError [ 'message' ] , $ html ) ; } } if ( ! \ extension_loaded ( 'xdebug' ) ) { $ html .= '<li>Want to see a backtrace here? Install <a target="_blank" href="https://xdebug.org/docs/install">xdebug</a> PHP extension.</li>' ; } $ html .= '</ul>' ; return $ html ; }
4776	public function render ( $ widgets , bool $ base = true ) { if ( ! $ widgets ) { return false ; } $ output = '' ; $ userId = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) -> getId ( ) ; foreach ( $ widgets as $ widget ) { if ( $ widget -> isActive ( ) ) { $ output .= $ this -> getOutput ( $ widget , $ userId ) ; } } if ( $ base ) { $ output = $ this -> engine -> render ( $ this -> baseTemplate , [ 'widgets' => $ output ] ) ; } return $ output ; }
8694	public static function parse ( $ size , $ fallbackUnits = null ) { preg_match ( '/^(\d+)[.,]?(\d*)\s*(\w*)$/' , $ size , $ matches ) ; if ( empty ( $ matches [ 1 ] ) || ( empty ( $ matches [ 3 ] ) && null === $ fallbackUnits ) ) { throw new \ UnexpectedValueException ( "Unable to parse : '{$size}'" ) ; } $ oSize = $ matches [ 1 ] ; if ( ! empty ( $ matches [ 2 ] ) ) { $ oSize .= '.' . $ matches [ 2 ] ; } $ oSize = ( float ) $ oSize ; $ unit = strtolower ( empty ( $ matches [ 3 ] ) ? $ fallbackUnits : $ matches [ 3 ] ) ; $ byteMultiplier = 1 ; if ( 'b' === substr ( $ unit , - 1 ) ) { $ byteMultiplier = 8 ; $ unit = substr ( $ unit , 0 , - 1 ) . 'o' ; } if ( ! array_key_exists ( $ unit , self :: getBinarySizes ( ) ) ) { throw new \ UnexpectedValueException ( "Unexpected unit {$unit}" ) ; } return ( int ) ( $ oSize * self :: getBinarySizes ( ) [ $ unit ] * $ byteMultiplier ) ; }
8544	public function setRefundEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RefundEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
105	public function watch2OnHighest ( Decisions $ decisions ) { $ literals = $ this -> rule -> getLiterals ( ) ; if ( count ( $ literals ) < 3 ) { return ; } $ watchLevel = 0 ; foreach ( $ literals as $ literal ) { $ level = $ decisions -> decisionLevel ( $ literal ) ; if ( $ level > $ watchLevel ) { $ this -> watch2 = $ literal ; $ watchLevel = $ level ; } } }
5520	protected function checkExpectations ( $ method , $ args , $ timing ) { $ test = $ this -> getCurrentTestCase ( ) ; if ( isset ( $ this -> max_counts [ $ method ] ) ) { if ( ! $ this -> max_counts [ $ method ] -> test ( $ timing + 1 ) ) { $ test -> assert ( $ this -> max_counts [ $ method ] , $ timing + 1 ) ; } } if ( isset ( $ this -> expected_args_at [ $ timing ] [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args_at [ $ timing ] [ $ method ] , $ args , "Mock method [$method] at [$timing] -> %s" ) ; } elseif ( isset ( $ this -> expected_args [ $ method ] ) ) { $ test -> assert ( $ this -> expected_args [ $ method ] , $ args , "Mock method [$method] -> %s" ) ; } }
4390	protected function getXmlProvider ( ) { $ provider = OPay :: create ( 'Datatrans\Xml' ) ; $ provider -> initialize ( $ this -> getServiceItem ( ) -> getConfig ( ) ) ; return $ provider ; }
10955	protected function redirect ( Response $ response , int $ code , string $ url ) : Response { return $ response -> withStatus ( $ code ) -> withHeader ( 'Location' , $ url ) ; }
4976	public static function factory ( ContainerInterface $ container ) { $ manager = $ container -> get ( 'ModuleManager' ) ; $ modules = $ manager -> getLoadedModules ( ) ; return new static ( $ modules ) ; }
4162	public function searchMedia ( $ lat , $ lng , $ distance = 1000 , $ minTimestamp = NULL , $ maxTimestamp = NULL ) { return $ this -> _makeCall ( 'media/search' , array ( 'lat' => $ lat , 'lng' => $ lng , 'distance' => $ distance , 'min_timestamp' => $ minTimestamp , 'max_timestamp' => $ maxTimestamp ) ) ; }
1735	public function getProvisionUri ( User $ user , Request $ request ) : string { $ issuer = rawurlencode ( $ request -> getSchemeAndHttpHost ( ) ) ; return sprintf ( 'otpauth://totp/%s:%s?secret=%s&issuer=%s' , $ issuer , rawurlencode ( $ user -> getUsername ( ) ) . '@' . $ issuer , $ this -> getUpperUnpaddedSecretForUser ( $ user ) , $ issuer ) ; }
6311	public function getTable ( Table $ table ) { return $ this -> container -> get ( 'rentgen.get_table' ) -> setTableName ( $ table -> getName ( ) ) -> execute ( ) ; }
959	public function cancel ( ) { if ( ! $ this -> isType ( self :: CHARGE_ONETIME ) && ! $ this -> isType ( self :: CHARGE_RECURRING ) ) { throw new Exception ( 'Cancel may only be called for single and recurring charges.' ) ; } $ this -> status = self :: STATUS_CANCELLED ; $ this -> cancelled_on = Carbon :: today ( ) -> format ( 'Y-m-d' ) ; return $ this -> save ( ) ; }
2573	protected function loadAuthParams ( $ params ) { if ( isset ( $ params [ 'authParams' ] ) ) { if ( $ params [ 'authParams' ] instanceof AuthParams ) { $ this -> authParams = $ params [ 'authParams' ] ; } elseif ( is_array ( $ params [ 'authParams' ] ) ) { $ this -> authParams = new AuthParams ( $ params [ 'authParams' ] ) ; } } }
93	public function filter ( $ relativePath , $ exclude ) { foreach ( $ this -> excludePatterns as $ patternData ) { list ( $ pattern , $ negate , $ stripLeadingSlash ) = $ patternData ; if ( $ stripLeadingSlash ) { $ path = substr ( $ relativePath , 1 ) ; } else { $ path = $ relativePath ; } if ( preg_match ( $ pattern , $ path ) ) { $ exclude = ! $ negate ; } } return $ exclude ; }
7171	protected function resolveTaxRule ( CountryInterface $ country , $ business = false ) : ? TaxRuleInterface { if ( $ business ) { return $ this -> taxRuleRepository -> findOneByCountryForBusiness ( $ country ) ; } return $ this -> taxRuleRepository -> findOneByCountryForCustomer ( $ country ) ; }
8818	public function files ( $ key = null , $ name = null ) { if ( is_null ( $ key ) ) { return $ _FILES ; } if ( isset ( $ _FILES [ $ key ] ) ) { if ( ! is_null ( $ name ) ) { return $ _FILES [ $ key ] [ $ name ] ; } return $ _FILES [ $ key ] ; } return false ; }
4485	public function watchdog ( string $ jid , string $ worker , ? int $ pid = null ) { if ( empty ( $ this -> channels ) || $ pid === null ) { return ; } ini_set ( 'default_socket_timeout' , self :: UNLIMITED ) ; $ pubsub = $ this -> redis -> pubSubLoop ( ) ; $ callable = [ $ pubsub , 'subscribe' ] ; if ( ! is_callable ( $ callable ) ) { return ; } call_user_func_array ( $ callable , $ this -> channels ) ; foreach ( $ pubsub as $ message ) { if ( $ message -> kind !== 'message' || empty ( $ message -> payload ) ) { continue ; } $ payload = json_decode ( $ message -> payload , true ) ; if ( empty ( $ payload ) ) { continue ; } if ( empty ( $ payload [ 'event' ] ) || ! is_array ( $ payload ) ) { continue ; } if ( ! in_array ( $ payload [ 'event' ] , self :: WATCHDOG_EVENTS , true ) || empty ( $ payload [ 'jid' ] ) ) { continue ; } if ( $ payload [ 'jid' ] !== $ jid ) { continue ; } $ who = 'watchdog:' . $ worker ; switch ( $ payload [ 'event' ] ) { case self :: LOCK_LOST : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} handed out to another worker" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: CANCELED : if ( ! empty ( $ payload [ 'worker' ] ) && $ payload [ 'worker' ] === $ worker ) { $ this -> logger -> info ( "{type}: sending SIGKILL to child {$pid}; job {jid} canceled" , [ 'type' => $ who , 'jid' => $ jid ] ) ; $ this -> system -> posixKill ( $ pid , SIGKILL ) ; $ pubsub -> stop ( ) ; } break ; case self :: COMPLETED : case self :: FAILED : $ pubsub -> stop ( ) ; break ; } } unset ( $ pubsub ) ; ini_set ( 'default_socket_timeout' , $ this -> defaultSocketTimeout ) ; }
4786	function offsetGet ( $ key ) { $ this -> access ( $ key ) ; if ( ! array_key_exists ( $ key , $ this -> row ) ) { $ this -> access ( $ key , true ) ; } return $ this -> row [ $ key ] ; }
12415	public static function init ( $ options = array ( ) ) { Flight :: map ( "render" , function ( $ template , $ data , $ toVar = false ) { Flight :: view ( ) -> render ( $ template , $ data , $ toVar ) ; } ) ; Flight :: register ( 'view' , get_called_class ( ) , $ options ) ; }
9393	public function withStatus ( $ code , $ reason = '' ) { $ static = clone $ this ; $ static -> code = $ code ; $ static -> reason = $ reason ? : $ static -> codes [ $ code ] ; return $ static ; }
2400	public function output ( ) { @ trigger_error ( 'Using Template::output() has been deprecated and will no longer work in Contao 5.0. Use Template::getResponse() instead.' , E_USER_DEPRECATED ) ; $ this -> compile ( ) ; header ( 'Content-Type: ' . $ this -> strContentType . '; charset=' . Config :: get ( 'characterSet' ) ) ; echo $ this -> strBuffer ; $ this -> flushAllData ( ) ; }
12	public function setOptimizeAutoloader ( $ optimizeAutoloader = false ) { $ this -> optimizeAutoloader = ( bool ) $ optimizeAutoloader ; if ( ! $ this -> optimizeAutoloader ) { $ this -> setClassMapAuthoritative ( false ) ; } return $ this ; }
4016	protected function getWidgetClass ( $ field ) { $ className = $ GLOBALS [ ( TL_MODE == 'BE' ? 'BE_FFL' : 'TL_FFL' ) ] [ $ field [ 'inputType' ] ] ; if ( ( $ className !== '' ) && class_exists ( $ className ) ) { return $ className ; } return null ; }
4573	public function getProperties ( Auditable $ entity ) { $ reflection = new ReflectionObject ( $ entity ) ; $ properties = [ ] ; foreach ( $ reflection -> getProperties ( ) as $ key => $ property ) { if ( ! $ this -> annotationReader -> getPropertyAnnotation ( $ property , AuditAnnotation :: class ) ) { continue ; } $ properties [ ] = $ property -> name ; } return $ properties ; }
12693	public function generate ( ) { $ templates = array_merge ( array_keys ( $ this -> templates [ "base" ] ) , array_keys ( $ this -> templates [ "template" ] ) ) ; foreach ( $ templates as $ template ) { $ templateDir = $ this -> themeDir . '/' . $ template ; if ( ! is_dir ( $ templateDir ) ) { continue ; } $ finder = new Finder ( ) ; $ files = $ finder -> files ( ) -> depth ( 0 ) -> in ( $ templateDir ) ; foreach ( $ files as $ file ) { $ file = ( string ) $ file ; $ slotName = basename ( $ file , '.json' ) ; $ json = FilesystemTools :: readFile ( $ file ) ; $ slot = json_decode ( $ json , true ) ; $ blocks = array ( ) ; if ( array_key_exists ( "blocks" , $ slot ) ) { $ blocks = $ slot [ "blocks" ] ; } $ slotManager = $ this -> slotsManagerFactory -> createSlotManager ( $ slot [ "repeat" ] ) ; $ slotManager -> addSlot ( $ slotName , $ blocks ) ; } } }
12136	public function edit ( QuestionRequest $ request , Question $ question ) { return $ this -> response -> title ( trans ( 'forum::question.name' ) ) -> view ( 'forum::public.question.newdiscussion' ) -> data ( compact ( 'question' ) ) -> output ( ) ; }
5718	public function doPublishAndClose ( $ data , $ form ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return $ this -> publish ( $ data , $ form , $ this -> owner , $ this -> getBackLink ( ) ) ; }
7921	private function extractFilenames ( \ ZipArchive $ zipArchive ) { $ filenames = array ( ) ; $ fileCount = $ zipArchive -> numFiles ; for ( $ i = 0 ; $ i < $ fileCount ; $ i ++ ) { if ( ( $ filename = $ this -> extractFilename ( $ zipArchive , $ i ) ) !== false ) { $ filenames [ ] = $ filename ; } } return $ filenames ; }
535	protected function fixDocBlockIndentation ( & $ lines ) { $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; $ indent = '' ; foreach ( $ lines as $ i => $ line ) { if ( preg_match ( '~^(\s*)/\*\*$~' , $ line , $ matches ) ) { $ docBlock = true ; $ indent = $ matches [ 1 ] ; } elseif ( preg_match ( '~^(\s*)\*+/~' , $ line ) ) { if ( $ docBlock ) { $ lines [ $ i ] = $ indent . ' */' ; } $ docBlock = false ; $ codeBlock = false ; $ listIndent = '' ; $ tag = false ; } elseif ( $ docBlock ) { $ line = ltrim ( $ line ) ; if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === '*' ) { $ line = substr ( $ line , 1 ) ; } if ( isset ( $ line [ 0 ] ) && $ line [ 0 ] === ' ' ) { $ line = substr ( $ line , 1 ) ; } $ docLine = str_replace ( "\t" , ' ' , rtrim ( $ line ) ) ; if ( empty ( $ docLine ) ) { $ listIndent = '' ; } elseif ( $ docLine [ 0 ] === '@' ) { $ listIndent = '' ; $ codeBlock = false ; $ tag = true ; $ docLine = preg_replace ( '/\s+/' , ' ' , $ docLine ) ; $ docLine = $ this -> fixParamTypes ( $ docLine ) ; } elseif ( preg_match ( '/^(~~~|```)/' , $ docLine ) ) { $ codeBlock = ! $ codeBlock ; $ listIndent = '' ; } elseif ( preg_match ( '/^(\s*)([0-9]+\.|-|\*|\+) /' , $ docLine , $ matches ) ) { $ listIndent = str_repeat ( ' ' , \ strlen ( $ matches [ 0 ] ) ) ; $ tag = false ; $ lines [ $ i ] = $ indent . ' * ' . $ docLine ; continue ; } if ( $ codeBlock ) { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . $ docLine ) ; } else { $ lines [ $ i ] = rtrim ( $ indent . ' * ' . ( empty ( $ listIndent ) && ! $ tag ? $ docLine : ( $ listIndent . ltrim ( $ docLine ) ) ) ) ; } } } }
10875	public function getDecodeHash ( string $ hash ) : array { $ decode = base64_decode ( $ hash ) ; list ( $ part1 , $ part2 ) = explode ( self :: PART_SEPARATOR , $ decode ) ; $ p1 = explode ( self :: TIME_SEPARATOR , $ part1 ) ; list ( $ linkValidate , ) = $ p1 ; $ id = null ; $ verifyHash = null ; $ dateNow = new DateTime ( ) ; $ dateValidate = $ dateNow ; if ( $ linkValidate == self :: NO_TIME ) { $ linkValidate = $ dateNow -> getTimestamp ( ) ; } $ dateValidate -> setTimestamp ( ( int ) $ linkValidate ) ; if ( $ dateValidate >= $ dateNow ) { $ p2 = explode ( self :: ID_SEPARATOR , $ part2 ) ; $ verifyHash = implode ( '.' , array_slice ( $ p2 , 0 , - 1 ) ) ; $ id = $ p2 [ count ( $ p2 ) - 1 ] ; } else { throw new IdentityException ( 'Activate link is expired!' ) ; } return [ 'id' => $ id , 'verifyHash' => $ verifyHash , 'expired' => ( int ) $ linkValidate ] ; }
5118	public function deleteAttachment ( string $ idArticle , string $ field , string $ order ) : string { return $ this -> delete ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) . "/${order}" ) ; }
11092	public static function poorManTranslate ( $ category , $ text , array $ params = [ ] ) { if ( class_exists ( 'Yii' ) ) { return \ Yii :: t ( $ category , $ text , $ params ) ; } $ pos = strrpos ( $ category , '/' ) ; $ category = $ pos === false ? $ category : substr ( $ category , $ pos + 1 ) ; $ translation = @ include 'messages/cs/' . $ category . '.php' ; if ( $ translation !== null && \ is_array ( $ translation ) && array_key_exists ( $ text , $ translation ) ) { $ keys = array_keys ( $ params ) ; array_walk ( $ keys , function ( & $ v ) { $ v = '{' . $ v . '}' ; } ) ; return str_replace ( array_values ( $ params ) , $ keys , $ translation [ $ text ] ) ; } return $ text ; }
11710	public function actionConfirm ( $ id , $ back = 'index' ) { $ this -> findModel ( $ id ) -> confirm ( ) ; \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'User has been confirmed' ) ) ; $ url = $ back == 'index' ? [ 'index' ] : [ 'update' , 'id' => $ id ] ; return $ this -> redirect ( $ url ) ; }
4472	public function retry ( $ group , $ message , $ delay = 0 ) { return $ this -> client -> retry ( $ this -> jid , $ this -> queue , $ this -> worker , $ delay , $ group , $ message ) ; }
4625	public function prepare ( Command $ command , Node $ node ) { if ( $ this -> connection ) { $ this -> resetConnection ( ) ; } parent :: prepare ( $ command , $ node ) ; $ this -> buildPath ( ) ; $ this -> prepareConnection ( ) ; $ this -> prepareRequest ( ) ; return $ this ; }
11609	public function actionDisconnect ( $ id ) { $ account = $ this -> finder -> findAccountById ( $ id ) ; if ( $ account === null ) { throw new NotFoundHttpException ; } if ( $ account -> user_id != \ Yii :: $ app -> user -> id ) { throw new ForbiddenHttpException ; } $ account -> delete ( ) ; return $ this -> redirect ( [ 'networks' ] ) ; }
6899	public function regenerate ( $ delete_old = false ) { if ( $ this -> is_active ( ) ) { @ session_regenerate_id ( $ delete_old ) ; } else { $ this -> open ( ) ; } return session_id ( ) ; }
1883	public static function find ( array $ arrOptions ) { $ objBase = DcaExtractor :: getInstance ( $ arrOptions [ 'table' ] ) ; if ( ! $ objBase -> hasRelations ( ) ) { $ strQuery = "SELECT * FROM " . $ arrOptions [ 'table' ] ; } else { $ arrJoins = array ( ) ; $ arrFields = array ( $ arrOptions [ 'table' ] . ".*" ) ; $ intCount = 0 ; foreach ( $ objBase -> getRelations ( ) as $ strKey => $ arrConfig ) { if ( $ arrConfig [ 'load' ] == 'eager' || $ arrOptions [ 'eager' ] ) { if ( $ arrConfig [ 'type' ] == 'hasOne' || $ arrConfig [ 'type' ] == 'belongsTo' ) { ++ $ intCount ; $ objRelated = DcaExtractor :: getInstance ( $ arrConfig [ 'table' ] ) ; foreach ( array_keys ( $ objRelated -> getFields ( ) ) as $ strField ) { $ arrFields [ ] = 'j' . $ intCount . '.' . Database :: quoteIdentifier ( $ strField ) . ' AS ' . $ strKey . '__' . $ strField ; } $ arrJoins [ ] = " LEFT JOIN " . $ arrConfig [ 'table' ] . " j$intCount ON " . $ arrOptions [ 'table' ] . "." . Database :: quoteIdentifier ( $ strKey ) . "=j$intCount." . $ arrConfig [ 'field' ] ; } } } $ strQuery = "SELECT " . implode ( ', ' , $ arrFields ) . " FROM " . $ arrOptions [ 'table' ] . implode ( "" , $ arrJoins ) ; } if ( isset ( $ arrOptions [ 'column' ] ) ) { $ strQuery .= " WHERE " . ( \ is_array ( $ arrOptions [ 'column' ] ) ? implode ( " AND " , $ arrOptions [ 'column' ] ) : $ arrOptions [ 'table' ] . '.' . Database :: quoteIdentifier ( $ arrOptions [ 'column' ] ) . "=?" ) ; } if ( isset ( $ arrOptions [ 'group' ] ) ) { $ strQuery .= " GROUP BY " . $ arrOptions [ 'group' ] ; } if ( isset ( $ arrOptions [ 'having' ] ) ) { $ strQuery .= " HAVING " . $ arrOptions [ 'having' ] ; } if ( isset ( $ arrOptions [ 'order' ] ) ) { $ strQuery .= " ORDER BY " . $ arrOptions [ 'order' ] ; } return $ strQuery ; }
1292	private function buildResult ( array $ data ) : Result { $ token = $ this -> getTokenFromResponse ( $ data ) ; $ done = isset ( $ data [ 'nextSyncUrl' ] ) ; $ items = \ array_map ( function ( array $ item ) : ResourceInterface { return $ this -> builder -> build ( $ item ) ; } , $ data [ 'items' ] ) ; return new Result ( $ items , $ token , $ done ) ; }
804	private function hasReturnTypeHint ( Tokens $ tokens , $ index ) { $ endFuncIndex = $ tokens -> getPrevTokenOfKind ( $ index , [ ')' ] ) ; $ nextIndex = $ tokens -> getNextMeaningfulToken ( $ endFuncIndex ) ; return $ tokens [ $ nextIndex ] -> isGivenKind ( CT :: T_TYPE_COLON ) ; }
8842	private function stringToArray ( string $ string ) : array { $ lines = preg_split ( '/\R/' , $ string ) ; if ( 1 === count ( $ lines ) && '' === $ lines [ 0 ] ) { $ lines = [ ] ; } return $ lines ; }
10029	function getContactsByFilterId ( $ filterId , $ page_index = 1 , $ page_size = 100 , $ standard_fields = array ( ) , $ custom_fields = array ( ) ) { $ queryParameters = array ( 'page_index' => $ page_index , 'page_size' => $ page_size , 'standard_field' => $ standard_fields ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ custom_fields ) ; return $ this -> get ( 'contacts/filter/' . utf8_encode ( $ filterId ) , $ queryParameters ) ; }
2564	public static function generateSomewhatRandomString ( $ length = 22 ) { $ chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz" ; srand ( ( double ) microtime ( ) * 1000000 ) ; $ i = 0 ; $ somewhatRandom = '' ; while ( $ i < $ length ) { $ num = rand ( ) % 60 ; $ tmp = substr ( $ chars , $ num , 1 ) ; $ somewhatRandom = $ somewhatRandom . $ tmp ; $ i ++ ; } return $ somewhatRandom ; }
3702	protected function getLegend ( $ name , $ palette , $ prevLegend = null ) { if ( strpos ( $ name , '+' ) === 0 ) { $ name = substr ( $ name , 1 ) ; } if ( ! $ palette -> hasLegend ( $ name ) ) { $ palette -> addLegend ( new Legend ( $ name ) , $ prevLegend ) ; } return $ palette -> getLegend ( $ name ) ; }
1078	public static function executeQuery ( SchemaType $ schema , $ source , $ rootValue = null , $ context = null , $ variableValues = null , ? string $ operationName = null , ? callable $ fieldResolver = null , ? array $ validationRules = null ) : ExecutionResult { $ promiseAdapter = new SyncPromiseAdapter ( ) ; $ promise = self :: promiseToExecute ( $ promiseAdapter , $ schema , $ source , $ rootValue , $ context , $ variableValues , $ operationName , $ fieldResolver , $ validationRules ) ; return $ promiseAdapter -> wait ( $ promise ) ; }
7646	protected function getFileName ( $ path ) { $ url = parse_url ( $ path ) ; if ( $ url [ 'host' ] ) { $ fileName = isset ( $ url [ 'path' ] ) ? $ url [ 'path' ] : $ url [ 'host' ] ; if ( strpos ( $ fileName , '/' ) === 0 ) { $ fileName = substr ( $ fileName , 1 ) ; } return $ fileName ; } return '' ; }
4457	public function detach ( string $ eventName , $ handler ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } if ( isset ( $ this -> events [ $ eventName ] ) == false ) { return ; } $ priorityQueue = $ this -> events [ $ eventName ] ; $ priorityQueue -> setExtractFlags ( SplPriorityQueue :: EXTR_BOTH ) ; $ priorityQueue -> top ( ) ; $ newPriorityQueue = $ this -> createQueue ( ) ; while ( $ priorityQueue -> valid ( ) ) { $ data = $ priorityQueue -> current ( ) ; $ priorityQueue -> next ( ) ; if ( $ data [ 'data' ] !== $ handler ) { $ newPriorityQueue -> insert ( $ data [ 'data' ] , $ data [ 'priority' ] ) ; } } $ this -> events [ $ eventName ] = $ newPriorityQueue ; }
1104	protected function quoteIdentifier ( $ value ) { if ( is_null ( $ value ) ) return 'NULL' ; $ connection = $ this -> node -> getConnection ( ) ; $ pdo = $ connection -> getPdo ( ) ; return $ pdo -> quote ( $ value ) ; }
8908	public function created_at ( $ row ) { if ( is_object ( $ row ) ) { $ row -> { $ this -> created_at_key } = date ( 'Y-m-d H:i:s' ) ; } else { $ row [ $ this -> created_at_key ] = date ( 'Y-m-d H:i:s' ) ; } return $ row ; }
8431	public function start ( ) { Loop :: run ( function ( ) { $ this -> logger -> info ( sprintf ( "RPQ is now started, and is listening for new jobs every %d ms" , $ this -> config [ 'poll_interval' ] ) , [ 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> setIsRunning ( false ) ; Loop :: repeat ( $ this -> config [ 'poll_interval' ] , function ( $ watcherId , $ callback ) { if ( ! $ this -> isRunning ) { return ; } $ this -> queue -> rescheduleJobs ( ) ; if ( count ( $ this -> processes ) === $ this -> config [ 'max_jobs' ] ) { return ; } $ job = $ this -> queue -> pop ( ) ; if ( $ job !== null ) { $ command = sprintf ( 'exec %s %s --jobId=%s --name=%s' , ( $ this -> config [ 'process' ] [ 'script' ] ?? $ _SERVER [ "SCRIPT_FILENAME" ] ) , $ this -> config [ 'process' ] [ 'command' ] , $ job -> getId ( ) , $ this -> queue -> getName ( ) ) ; if ( $ this -> config [ 'process' ] [ 'config' ] === true ) { $ command .= " --config={$this->args['configFile']}" ; } $ process = new Process ( $ command ) ; $ process -> start ( ) ; $ pid = yield $ process -> getPid ( ) ; $ this -> logger -> info ( 'Started worker' , [ 'pid' => $ pid , 'command' => $ command , 'id' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ this -> processes [ $ pid ] = [ 'process' => $ process , 'id' => $ job -> getId ( ) ] ; $ stream = $ process -> getStdout ( ) ; while ( $ chunk = yield $ stream -> read ( ) ) { $ this -> logger -> info ( $ chunk , [ 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; } $ code = yield $ process -> join ( ) ; $ this -> jobHandler -> exit ( $ job -> getId ( ) , $ pid , $ code , false , $ this -> config [ 'failed_job_backoff_time' ] ) ; unset ( $ this -> processes [ $ pid ] ) ; } } ) ; $ this -> registerSignals ( ) ; } ) ; }
5116	public function submitAttachment ( string $ idArticle , Model $ attachment , string $ field ) : array { return json_decode ( $ this -> post ( $ this -> getAttachmentEndPoint ( $ idArticle , $ field ) , $ this -> normalizePayload ( $ attachment -> getCollection ( ) ) ) , true ) ; }
4055	private function convertLegends ( array $ properties , IMetaModel $ metaModel , array $ conditions ) : array { $ result = [ ] ; $ label = [ ] ; if ( $ trans = $ metaModel -> isTranslated ( ) ) { foreach ( $ metaModel -> getAvailableLanguages ( ) as $ availableLanguage ) { $ label [ $ availableLanguage ] = $ metaModel -> getName ( ) ; } } else { $ label [ $ metaModel -> getActiveLanguage ( ) ] = $ metaModel -> getName ( ) ; } $ legend = [ 'label' => $ label , 'hide' => false , 'properties' => [ ] ] ; $ condition = function ( $ property ) use ( $ conditions ) { if ( ! isset ( $ conditions [ $ property [ 'id' ] ] ) ) { return null ; } return [ 'type' => 'conditionand' , 'children' => $ conditions [ $ property [ 'id' ] ] ] ; } ; foreach ( $ properties as $ property ) { switch ( $ property [ 'dcatype' ] ) { case 'legend' : $ this -> convertLegend ( $ property , $ trans , $ condition , $ legend , $ result ) ; break ; case 'attribute' : $ this -> convertAttribute ( $ property , $ condition , $ legend ) ; break ; default : break ; } } if ( ! empty ( $ legend [ 'properties' ] ) ) { $ result [ 'legend' . ( \ count ( $ result ) + 1 ) ] = $ legend ; } return $ result ; }
7986	public function getModels ( $ domain ) { $ domain = ( string ) $ domain ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/models' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
11864	public function save ( string $ sessionIdentifier , string $ sessionData ) : void { self :: $ files [ $ sessionIdentifier ] = [ 'data' => $ sessionData , 'time' => microtime ( true ) ] ; }
10339	public static function checkString ( $ pValue ) { if ( $ pValue instanceof RichText ) { return $ pValue ; } $ pValue = StringHelper :: substring ( $ pValue , 0 , 32767 ) ; $ pValue = str_replace ( [ "\r\n" , "\r" ] , "\n" , $ pValue ) ; return $ pValue ; }
9668	private function writePatternFill ( XMLWriter $ objWriter , Fill $ pFill ) { $ objWriter -> startElement ( 'fill' ) ; $ objWriter -> startElement ( 'patternFill' ) ; $ objWriter -> writeAttribute ( 'patternType' , $ pFill -> getFillType ( ) ) ; if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getStartColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'fgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getStartColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } if ( $ pFill -> getFillType ( ) !== Fill :: FILL_NONE ) { if ( $ pFill -> getEndColor ( ) -> getARGB ( ) ) { $ objWriter -> startElement ( 'bgColor' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFill -> getEndColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } } $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
10973	public static function getAuthPassword ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_PW' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_PW' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
4996	public function getColumnMap ( ) { $ map = $ this -> getOption ( 'column_map' ) ; if ( null === $ map ) { $ map = [ ] ; foreach ( $ this as $ element ) { $ col = $ element -> getOption ( 'span' ) ; if ( null !== $ col ) { $ map [ $ element -> getName ( ) ] = $ col ; } } $ this -> setOption ( 'column_map' , $ map ) ; } return $ map ; }
6201	public function addRoute ( $ newRoute ) { $ this -> routeMap [ 'routes' ] = array_merge ( $ this -> routeMap [ 'routes' ] , $ newRoute ) ; $ this -> routeMapParse = array_merge ( $ this -> routeMapParse , $ newRoute ) ; }
3402	protected function applyResultCallbackChain ( Crawler $ node , ApistMethod $ method ) { if ( empty ( $ this -> resultMethodChain ) ) { $ this -> addCallback ( 'text' ) ; } $ traceStack = [ ] ; foreach ( $ this -> resultMethodChain as $ resultCallback ) { try { $ traceStack [ ] = $ resultCallback ; $ node = $ resultCallback -> apply ( $ node , $ method ) ; } catch ( InvalidArgumentException $ e ) { if ( $ method -> getResource ( ) -> isSuppressExceptions ( ) ) { return null ; } $ message = $ this -> createExceptionMessage ( $ e , $ traceStack ) ; throw new InvalidArgumentException ( $ message , 0 , $ e ) ; } } return $ node ; }
4092	public function term ( $ term , $ field = false ) { $ this -> term = ( $ field ) ? array ( $ field => $ term ) : $ term ; return $ this ; }
2448	public function sendNotifications ( $ varValue ) { if ( $ varValue ) { Contao \ Comments :: notifyCommentsSubscribers ( Contao \ CommentsModel :: findByPk ( Contao \ Input :: get ( 'id' ) ) ) ; } return $ varValue ; }
12653	public function getTextsWithBaseTexts ( $ language ) { $ texts = $ this -> getPageTexts ( $ language ) ; if ( $ language !== $ this -> baseLang ) { $ baseTexts = $ this -> getPageTexts ( $ this -> baseLang ) ; $ texts = array_map ( function ( $ text , $ baseText ) { return $ text + array ( "basecontent" => $ baseText [ 'content' ] ) ; } , $ texts , $ baseTexts ) ; } return $ texts ; }
914	public static function calculateBitmask ( array $ options ) { $ bitmask = 0 ; foreach ( $ options as $ optionName ) { if ( \ defined ( $ optionName ) ) { $ bitmask |= \ constant ( $ optionName ) ; } } return $ bitmask ; }
8824	protected function errorMessage ( $ filter , $ field , $ params = null ) { $ text = ( isset ( $ this -> texts [ $ field ] [ $ filter ] ) && ! is_null ( $ this -> texts [ $ field ] [ $ filter ] ) ? $ this -> texts [ $ field ] [ $ filter ] : $ this -> msg ) ; $ text = str_replace ( [ ':label:' , ':value:' ] , '%s' , $ text ) ; if ( ! isset ( $ this -> data [ $ field ] ) ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } elseif ( ! is_null ( $ params ) ) { if ( $ filter == 'matches' ) { if ( $ this -> matches ( $ this -> data [ $ field ] , $ this -> data [ $ params ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] , $ params ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } } else { if ( $ this -> $ filter ( $ this -> data [ $ field ] ) === false ) { $ this -> errors [ ] = sprintf ( $ text , $ this -> labels [ $ field ] , $ params ) ; } } }
7678	function TbsSheetCheck ( ) { if ( count ( $ this -> OtbsSheetSlidesDelete ) > 0 ) $ this -> RaiseError ( "Unable to delete the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , $ this -> OtbsSheetSlidesDelete ) ) ) . '.' ) ; if ( count ( $ this -> OtbsSheetSlidesVisible ) > 0 ) $ this -> RaiseError ( "Unable to change visibility of the following sheets because they are not found in the workbook: " . ( str_replace ( array ( 'i:' , 'n:' ) , '' , implode ( ', ' , array_keys ( $ this -> OtbsSheetSlidesVisible ) ) ) ) . '.' ) ; }
1627	public function useFiles ( $ path , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useFiles ( $ path , $ level ) ; } } }
2277	public function getPasswordDefault ( $ varValue ) { if ( ! trim ( $ varValue ) ) { $ varValue = ( \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] [ 1 ] : $ GLOBALS [ 'TL_LANG' ] [ 'tl_module' ] [ 'passwordText' ] ) ; } return $ varValue ; }
12585	static function run_convert_configuration ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { self :: setConfigDir ( $ cliopts ) ; $ extname = @ $ args [ 0 ] ; if ( $ extname == '' ) { $ extname = dirname ( __FILE__ ) ; } while ( ! is_file ( "ant/$extname.properties" ) ) { $ extname = pake_input ( 'What is the name of the current extension?' ) ; if ( ! is_file ( "ant/$extname.properties" ) ) { pake_echo ( "File ant/$extname.properties not found" ) ; } } self :: convertPropertyFileToYamlFile ( "ant/$extname.properties" , self :: getConfigDir ( ) . "/options-$extname.yaml" , array ( $ extname => '' , 'external' => 'dependencies' , 'dependency' => 'extensions' , 'repository' => array ( 'svn' , 'url' ) ) , "extension:\n name: $extname\n\n" ) ; foreach ( array ( 'files.to.parse.txt' => 'to_parse' , 'files.to.exclude.txt' => 'to_exclude' ) as $ file => $ option ) { $ src = "ant/$file" ; if ( file_exists ( $ src ) ) { if ( count ( $ in = file ( $ src , FILE_SKIP_EMPTY_LINES | FILE_IGNORE_NEW_LINES ) ) ) { $ in = "\n\nfiles:\n $option: [" . implode ( ', ' , $ in ) . "]\n" ; file_put_contents ( self :: getConfigDir ( ) . "options-$extname.yaml" , $ in , FILE_APPEND ) ; } } } }
7642	public function getBaseUrl ( ) { if ( $ this -> credentials -> usePathStyleUri ( ) ) { return $ this -> host . '/' . $ this -> accountName ; } return $ this -> host ; }
10374	public static function remove ( $ type , $ name ) { if ( isset ( self :: $ data [ $ type ] [ $ name ] ) ) { unset ( self :: $ data [ $ type ] [ $ name ] ) ; } return true ; }
776	private function supportsFractionalSeconds ( ) { $ version = $ this -> db -> getSlavePdo ( ) -> getAttribute ( \ PDO :: ATTR_SERVER_VERSION ) ; return version_compare ( $ version , '5.6.4' , '>=' ) ; }
5673	protected function describeArrayDifference ( $ first , $ second , $ identical ) { if ( ! is_array ( $ second ) ) { return $ this -> describeGenericDifference ( $ first , $ second ) ; } if ( ! $ this -> isMatchingKeys ( $ first , $ second , $ identical ) ) { return sprintf ( 'as key list [%s] does not match key list [%s]' , implode ( ', ' , array_keys ( $ first ) ) , implode ( ', ' , array_keys ( $ second ) ) ) ; } foreach ( array_keys ( $ first ) as $ key ) { if ( $ identical && ( $ first [ $ key ] === $ second [ $ key ] ) ) { continue ; } if ( ! $ identical && ( $ first [ $ key ] == $ second [ $ key ] ) ) { continue ; } return sprintf ( 'with member [%s] %s' , $ key , $ this -> describeDifference ( $ first [ $ key ] , $ second [ $ key ] , $ identical ) ) ; } return '' ; }
2691	public function getForceLossyUrl ( ) { $ baseFile = $ this -> getBaseFile ( ) ; $ extension = pathinfo ( $ baseFile , PATHINFO_EXTENSION ) ; $ url = $ this -> getBaseFileUrl ( $ baseFile ) ; if ( $ extension == 'png' || $ extension == 'bmp' ) { if ( $ this -> isFastlyImageOptimizationEnabled ( ) == false ) { $ this -> lossyUrl = $ url . '?format=jpeg' ; } else { $ this -> lossyParam = '&format=jpeg' ; } } }
8986	public function get_columns ( ) { return array ( 'id' => new IntegerBased ( 'BIGINT' , 'id' , array ( 'NOT NULL' , 'auto_increment' ) , array ( 20 ) ) , 'message' => new StringBased ( 'VARCHAR' , 'message' , array ( ) , array ( 255 ) ) , 'level' => new StringBased ( 'VARCHAR' , 'level' , array ( ) , array ( 20 ) ) , 'lgroup' => new StringBased ( 'VARCHAR' , 'lgroup' , array ( ) , array ( 20 ) ) , 'time' => new DateTime ( 'time' ) , 'user' => new ForeignUser ( 'user' ) , 'ip' => new StringBased ( 'VARCHAR' , 'ip' , array ( ) , array ( 45 ) ) , 'exception' => new StringBased ( 'VARCHAR' , 'exception' , array ( ) , array ( 255 ) ) , 'trace' => new StringBased ( 'LONGTEXT' , 'trace' ) , 'context' => new StringBased ( 'LONGTEXT' , 'context' ) , ) ; }
9137	public function call ( callable $ callable , array $ args = [ ] ) { $ args = $ this -> resolveArguments ( $ args ) ; $ reflection = $ this -> reflectCallable ( $ callable ) ; return call_user_func_array ( $ callable , $ this -> getParameters ( $ reflection , $ args ) ) ; }
8451	public function setProfilePhoto ( $ mediaUri ) { $ processedMedia = $ this -> processMediaUri ( $ mediaUri ) ; if ( ! $ processedMedia ) { return false ; } $ result = $ this -> exec ( 'set_profile_photo ' . $ processedMedia [ 'filepath' ] ) ; $ this -> cleanUpMedia ( $ processedMedia ) ; return $ result ; }
8131	protected function removeNodeFilter ( Twig_Node $ node ) { if ( $ node instanceof Twig_Node_Expression_Filter ) { return $ this -> removeNodeFilter ( $ node -> getNode ( 'node' ) ) ; } return $ node ; }
2880	public function disableTranslateAction ( ) { try { $ this -> getService ( ) -> setTranslateInline ( 0 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Translate inline cannot be disabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
4007	public function createMetaModel ( CreateMetaModelEvent $ event ) { if ( $ event -> getMetaModel ( ) !== null ) { return ; } if ( isset ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ) { $ event -> setMetaModel ( $ this -> instancesByTable [ $ event -> getMetaModelName ( ) ] ) ; return ; } $ table = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel' ) -> where ( 'tableName=:tableName' ) -> setParameter ( 'tableName' , $ event -> getMetaModelName ( ) ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( $ table ) { $ table [ 'system_columns' ] = $ this -> systemColumns ; $ this -> createInstance ( $ event , $ table ) ; } }
10972	public static function getAuthUsername ( ) { $ result = null ; if ( isset ( $ _SERVER [ 'PHP_AUTH_USER' ] ) ) { $ result = $ _SERVER [ 'PHP_AUTH_USER' ] ; } if ( trim ( $ result ) == '' ) { $ result = null ; } return $ result ; }
5112	protected function setPart ( $ part , $ sql , $ bind = false ) { $ this -> parts [ $ part ] = $ sql ; if ( is_array ( $ bind ) ) $ this -> bind [ $ part ] = $ bind ; else if ( $ bind === false ) $ this -> bind [ $ part ] = false ; else $ this -> bind [ $ part ] = [ $ bind ] ; return $ this ; }
7691	function OpenMXL_GarbageCollector ( ) { if ( ( count ( $ this -> IdxToCheck ) == 0 ) && ( count ( $ this -> OtbsSheetSlidesDelete ) == 0 ) ) return ; $ pic_path = $ this -> ExtInfo [ 'pic_path' ] ; $ pic_path_len = strlen ( $ pic_path ) ; $ rels_ext = '.rels' ; $ rels_ext_len = strlen ( $ rels_ext ) ; $ pictures = array ( ) ; $ rels = array ( ) ; foreach ( $ this -> CdFileLst as $ idx => $ f ) { $ n = $ f [ 'v_name' ] ; if ( substr ( $ n , 0 , $ pic_path_len ) == $ pic_path ) { $ short = basename ( $ pic_path ) . '/' . basename ( $ n ) ; $ pictures [ ] = array ( 'name' => $ n , 'idx' => $ idx , 'nbr' => 0 , 'short' => $ short ) ; } elseif ( substr ( $ n , - $ rels_ext_len ) == $ rels_ext ) { if ( $ this -> FileGetState ( $ idx ) != 'd' ) $ rels [ $ n ] = $ idx ; } } foreach ( $ rels as $ n => $ idx ) { $ txt = $ this -> TbsStoreGet ( $ idx , 'GarbageCollector' ) ; foreach ( $ pictures as $ i => $ info ) { if ( strpos ( $ txt , $ info [ 'short' ] . '"' ) !== false ) $ pictures [ $ i ] [ 'nbr' ] ++ ; } } foreach ( $ pictures as $ info ) { if ( $ info [ 'nbr' ] == 0 ) $ this -> FileReplace ( $ info [ 'idx' ] , false ) ; } }
10798	public function dateToSqlFormat ( $ dateString ) { $ dateFormatter = new \ IntlDateFormatter ( \ Locale :: getDefault ( ) , \ IntlDateFormatter :: NONE , \ IntlDateFormatter :: NONE , \ date_default_timezone_get ( ) , \ IntlDateFormatter :: GREGORIAN , "dd MMM yyyy" ) ; $ time = $ dateFormatter -> parse ( $ dateString ) ; $ date = new \ DateTime ( ) ; $ date -> setTimestamp ( $ time ) ; return $ date -> format ( 'Y-m-d' ) ; }
7867	protected function drawBorder ( $ left , $ middle , $ right ) { $ width = $ this -> geometry -> getWidthButBorders ( ) ; $ border = str_repeat ( static :: BORDER_Y , $ width ) ; $ this -> replaceUtf8 ( $ border , $ left , 0 ) ; $ this -> replaceUtf8 ( $ border , $ middle , floor ( $ width / 2 ) ) ; $ this -> replaceUtf8 ( $ border , $ right , $ width - 1 ) ; $ this -> drawBordered ( $ border ) ; }
11750	public function relation ( ) { if ( is_null ( $ this -> relation ) ) { $ this -> relation = new Relation ( $ this -> accessToken ) ; } return $ this -> relation ; }
8564	public function getEligibleShippingServices ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetEligibleShippingServicesResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetEligibleShippingServicesResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2367	public static function encodeEmail ( $ strString ) { if ( strpos ( $ strString , '@' ) === false ) { return $ strString ; } $ arrEmails = static :: extractEmail ( $ strString , Config :: get ( 'allowedTags' ) ) ; foreach ( $ arrEmails as $ strEmail ) { $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ strEmail ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( ( random_int ( 0 , 1 ) ? '&#x%X;' : '&#%s;' ) , Utf8 :: ord ( $ strCharacter ) ) ; } $ strString = str_replace ( $ strEmail , $ strEncoded , $ strString ) ; } return str_replace ( 'mailto:' , '&#109;&#97;&#105;&#108;&#116;&#111;&#58;' , $ strString ) ; }
8955	public function createRelation ( $ changeset , $ tags , $ members ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'relation/create' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ tagList = '' ; if ( ! empty ( $ tags ) ) { foreach ( $ tags as $ key => $ value ) { $ tagList .= '<tag k="' . $ key . '" v="' . $ value . '"/>' ; } } $ memberList = '' ; if ( ! empty ( $ members ) ) { foreach ( $ members as $ member ) { if ( $ member [ 'type' ] == 'node' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" role="' . $ member [ 'role' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } elseif ( $ member [ 'type' ] == 'way' ) { $ memberList .= '<member type="' . $ member [ 'type' ] . '" ref="' . $ member [ 'ref' ] . '"/>' ; } } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <relation relation="' . $ changeset . '" >' . $ tagList . $ memberList . '</relation> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
2230	protected function getTargetFolders ( $ strFolder , $ intLevel = 1 ) { $ strFolders = '' ; $ strPath = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) . '/' . $ strFolder ; foreach ( scan ( $ strPath ) as $ strFile ) { if ( ! is_dir ( $ strPath . '/' . $ strFile ) || strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } $ strRelPath = $ strFolder . '/' . $ strFile ; $ strFolders .= sprintf ( '<option value="%s"%s>%s%s</option>' , $ strRelPath , ( ( Contao \ Input :: post ( 'target' ) == $ strRelPath ) ? ' selected="selected"' : '' ) , str_repeat ( ' &nbsp; ' , $ intLevel ) , basename ( $ strRelPath ) ) ; $ strFolders .= $ this -> getTargetFolders ( $ strRelPath , ( $ intLevel + 1 ) ) ; } return $ strFolders ; }
5349	public function installOperatingSystemUnattended ( $ vpsName , $ operatingSystemName , $ base64InstallText ) { return $ this -> call ( self :: SERVICE , 'installOperatingSystemUnattended' , [ $ vpsName , $ operatingSystemName , $ base64InstallText ] ) ; }
3681	public function getJumpTo ( ) { if ( ! isset ( $ this -> arrJumpTo ) ) { $ page = $ GLOBALS [ 'objPage' ] ; $ this -> setJumpTo ( $ page -> row ( ) ) ; if ( $ this -> metamodel_jumpTo ) { $ statement = $ this -> getConnection ( ) -> prepare ( 'SELECT id, alias FROM tl_page WHERE id=? LIMIT 0,1' ) ; $ statement -> bindValue ( 1 , $ this -> metamodel_jumpTo ) ; $ statement -> execute ( ) ; if ( $ statement -> rowCount ( ) ) { $ this -> setJumpTo ( $ statement -> fetch ( \ PDO :: FETCH_ASSOC ) ) ; } } } return $ this -> arrJumpTo ; }
4580	public function encrypt ( Encryptable $ model ) : EncryptionService { if ( $ model -> getEncrypted ( ) ) { return $ this ; } $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ property -> setAccessible ( true ) ; $ property -> setValue ( $ model , $ this -> cipherService -> encrypt ( $ property -> getValue ( $ model ) ) ) ; } $ model -> setEncrypted ( true ) ; return $ this ; }
2977	public function unserialize ( $ serialized ) { $ this -> data = unserialize ( $ serialized ) ; $ this -> closure = __reconstruct_closure ( $ this -> data ) ; if ( ! $ this -> closure instanceof Closure ) { throw new ClosureUnserializationException ( 'The closure is corrupted and cannot be unserialized.' ) ; } if ( $ this -> data [ 'binding' ] || $ this -> data [ 'isStatic' ] ) { $ this -> closure = $ this -> closure -> bindTo ( $ this -> data [ 'binding' ] , $ this -> data [ 'scope' ] ) ; } }
11552	public function removeConsignment ( ConsignmentInterface $ consignment ) { $ adapter = $ this -> getAdapter ( $ consignment ) ; $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: PRE_CONSIGNMENT_REMOVE , $ event ) ; if ( $ consignment -> getStatus ( ) != ConsignmentStatusList :: STATUS_NEW ) { throw new OperationNotPermittedException ( sprintf ( 'Can not remove Consignment "%s" with status "%s"' , $ consignment -> getId ( ) , $ consignment -> getStatus ( ) ) ) ; } try { $ adapter -> removeConsignment ( $ consignment ) ; $ this -> consignmentRepository -> removeConsignment ( $ consignment ) ; } catch ( \ Exception $ e ) { throw new VendorAdapterException ( 'Error during consignment removing.' , null , $ e ) ; } $ event = new EventConsignment ( $ consignment ) ; $ this -> eventDispatcher -> dispatch ( Events :: POST_CONSIGNMENT_REMOVE , $ event ) ; }
3302	public function json ( $ url , $ options = [ ] , $ encodeOption = JSON_UNESCAPED_UNICODE , $ queries = [ ] ) { is_array ( $ options ) && $ options = json_encode ( $ options , $ encodeOption ) ; return $ this -> setHeaders ( [ 'content-type' => 'application/json' ] ) -> request ( 'POST' , $ url , [ 'query' => $ queries , 'body' => $ options ] ) ; }
1158	protected function ruleAfter ( $ attribute , array $ parameters ) { if ( ! ( $ date = strtotime ( $ parameters [ 0 ] ) ) ) { $ date = $ this -> getAttributeName ( $ parameters [ 0 ] ) ; } return [ $ attribute , [ $ date ] ] ; }
4126	public function getDocumentNamespace ( $ documentNamespaceAlias ) { if ( ! isset ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] ) ) { throw CouchDBException :: unknownDocumentNamespace ( $ documentNamespaceAlias ) ; } return trim ( $ this -> attributes [ 'documentNamespaces' ] [ $ documentNamespaceAlias ] , '\\' ) ; }
5271	private function translateDelete ( ) { $ build = array ( "delete from {$this->table}" ) ; if ( ! empty ( $ this -> statements [ 'wheres' ] ) ) { $ build [ ] = join ( ' ' , $ this -> statements [ 'wheres' ] ) ; } if ( ! empty ( $ this -> limit ) ) { $ build [ ] = $ this -> limit ; } return join ( ' ' , $ build ) ; }
6551	static function send ( $ channel_code = null ) { try { if ( is_numeric ( $ channel_code ) ) { $ channel_id = $ channel_code ; } else { $ channel_id = env ( 'telegram.' . $ channel_code ) ; $ channel_id = $ channel_id ? : env ( 'telegram' ) ; } if ( ! $ channel_id ) { echo 'No channel' ; return ; } if ( is_array ( $ channel_code ) ) { foreach ( $ channel_code as $ _code ) { self :: send ( $ _code ) ; } return ; } $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 3 ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 0 ) ; $ partials = [ ] ; $ current = '' ; foreach ( static :: $ messages as $ message ) { if ( mb_strlen ( $ current ) + mb_strlen ( $ message ) < self :: MAX ) { $ current .= PHP_EOL . $ message ; } else { $ partials [ ] = $ current ; $ current = '' ; if ( mb_strlen ( $ message ) > self :: MAX ) { $ strlen = mb_strlen ( $ message ) ; while ( $ strlen ) { $ partials [ ] = mb_substr ( $ message , 0 , self :: MAX , "UTF-8" ) ; $ message = mb_substr ( $ message , self :: MAX , mb_strlen ( $ message ) , "UTF-8" ) ; $ strlen = mb_strlen ( $ message ) ; } } else { $ current = $ message ; } } } $ partials [ ] = $ current ; foreach ( $ partials as $ partial ) { $ params = http_build_query ( [ 'disable_web_page_preview' => 'true' , 'parse_mode' => 'HTML' , 'chat_id' => $ channel_id , 'text' => $ partial , ] ) ; $ url = 'https://api.telegram.org/bot' . env ( 'telegram.key' ) . '/sendMessage?' ; curl_setopt ( $ ch , CURLOPT_URL , $ url . $ params ) ; curl_exec ( $ ch ) ; } curl_close ( $ ch ) ; } catch ( \ Exception $ e ) { echo $ e -> getMessage ( ) ; } }
9940	public function calculateColumnWidths ( ) { $ autoSizes = [ ] ; foreach ( $ this -> getColumnDimensions ( ) as $ colDimension ) { if ( $ colDimension -> getAutoSize ( ) ) { $ autoSizes [ $ colDimension -> getColumnIndex ( ) ] = - 1 ; } } if ( ! empty ( $ autoSizes ) ) { $ isMergeCell = [ ] ; foreach ( $ this -> getMergeCells ( ) as $ cells ) { foreach ( Coordinate :: extractAllCellReferencesInRange ( $ cells ) as $ cellReference ) { $ isMergeCell [ $ cellReference ] = true ; } } foreach ( $ this -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ this -> getCell ( $ coordinate , false ) ; if ( $ cell !== null && isset ( $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] ) ) { $ isMerged = isset ( $ isMergeCell [ $ this -> cellCollection -> getCurrentCoordinate ( ) ] ) ; $ isMergedButProceed = false ; if ( $ isMerged && $ cell -> isMergeRangeValueCell ( ) ) { $ range = $ cell -> getMergeRange ( ) ; $ rangeBoundaries = Coordinate :: rangeDimension ( $ range ) ; if ( $ rangeBoundaries [ 0 ] == 1 ) { $ isMergedButProceed = true ; } } if ( ! $ isMerged || $ isMergedButProceed ) { $ cellValue = NumberFormat :: toFormattedString ( $ cell -> getCalculatedValue ( ) , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getNumberFormat ( ) -> getFormatCode ( ) ) ; $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] = max ( ( float ) $ autoSizes [ $ this -> cellCollection -> getCurrentColumn ( ) ] , ( float ) Shared \ Font :: calculateColumnWidth ( $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getFont ( ) , $ cellValue , $ this -> getParent ( ) -> getCellXfByIndex ( $ cell -> getXfIndex ( ) ) -> getAlignment ( ) -> getTextRotation ( ) , $ this -> getParent ( ) -> getDefaultStyle ( ) -> getFont ( ) ) ) ; } } } foreach ( $ autoSizes as $ columnIndex => $ width ) { if ( $ width == - 1 ) { $ width = $ this -> getDefaultColumnDimension ( ) -> getWidth ( ) ; } $ this -> getColumnDimension ( $ columnIndex ) -> setWidth ( $ width ) ; } } return $ this ; }
2461	private function canonicalize ( string $ value ) : string { $ resolved = [ ] ; $ chunks = preg_split ( '#([\\\\/]+)#' , $ value , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) ; for ( $ i = 0 , $ c = \ count ( $ chunks ) ; $ i < $ c ; ++ $ i ) { if ( '.' === $ chunks [ $ i ] ) { ++ $ i ; continue ; } if ( '/' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '/' ; continue ; } if ( '\\' === $ chunks [ $ i ] [ 0 ] ) { $ resolved [ ] = '\\' ; continue ; } if ( '..' === $ chunks [ $ i ] ) { ++ $ i ; array_pop ( $ resolved ) ; array_pop ( $ resolved ) ; continue ; } $ resolved [ ] = $ chunks [ $ i ] ; } return rtrim ( implode ( '' , $ resolved ) , '\/' ) ; }
10330	public function replace_when_add ( ) { $ state = isset ( $ _POST [ 'state' ] ) ? $ _POST [ 'state' ] : null ; $ nonce = isset ( $ _POST [ 'nonce' ] ) ? $ _POST [ 'nonce' ] : '' ; if ( ! wp_verify_nonce ( $ nonce , 'eliasis' ) && ! wp_verify_nonce ( $ nonce , 'customImagesGrifusAdmin' ) ) { die ( 'Busted!' ) ; } App :: setCurrentID ( 'EFG' ) ; $ slug = Module :: CustomImagesGrifus ( ) -> getOption ( 'slug' ) ; $ this -> model -> set_replace_when_add ( $ slug , $ state ) ; $ response = [ 'replace-when-add' => $ state ] ; echo json_encode ( $ response ) ; die ( ) ; }
608	private function addTokenFromBuffer ( ) { if ( $ this -> _buffer === '' ) { return ; } $ isKeyword = $ this -> isKeyword ( $ this -> _buffer , $ content ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => $ isKeyword ? SqlToken :: TYPE_KEYWORD : SqlToken :: TYPE_TOKEN , 'content' => is_string ( $ content ) ? $ content : $ this -> _buffer , 'startOffset' => $ this -> offset - mb_strlen ( $ this -> _buffer , 'UTF-8' ) , 'endOffset' => $ this -> offset , ] ) ; $ this -> _buffer = '' ; }
10365	public function login ( LoginRequest $ request ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'login' ) ) -> dispatchFrom ( LoginJob :: class , $ request ) ; return redirect ( ) -> route ( config ( '_auth.login.redirect' ) ) ; }
11489	public function start ( ? string $ name = null , ? string $ sessionId = null ) : string { if ( ! $ this -> isStarted ( ) ) { if ( ! is_null ( $ name ) ) { $ this -> setName ( $ name ) ; } @ session_start ( $ sessionId ) ; } ; return $ this -> getId ( ) ; }
5352	public function getSupportedNamespaces ( ) { if ( empty ( $ this -> data -> namespaces ) || ! is_array ( $ this -> data -> namespaces ) ) { return array ( ) ; } return $ this -> data -> namespaces ; }
6525	public function createMessage ( array $ data = [ ] ) { $ className = $ this -> className ; if ( empty ( $ data ) ) { return $ className :: create ( ) ; } return $ className :: fromArray ( $ data ) ; }
5770	public function getLoggedInAdministrator ( ) : Administrator { if ( ! isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { throw new \ Exception ( "No one is logged in" ) ; } if ( null === $ administrator = ( AdministratorsEntityMapper :: getInstance ( ) ) -> getObjectById ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ) { unset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] ) ; throw new \ Exception ( "Invalid administrator id " . $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMINISTRATOR_ID ] . " in session" ) ; } return $ administrator ; }
7081	public function onPostCopy ( SaleTransformEvent $ event ) { $ source = $ event -> getSource ( ) ; $ target = $ event -> getTarget ( ) ; $ target -> setOriginNumber ( $ source -> getNumber ( ) ) ; if ( $ source instanceof OrderInterface && $ target instanceof OrderInterface ) { $ target -> setSample ( $ source -> isSample ( ) ) ; } if ( null === $ customer = $ source -> getCustomer ( ) ) { return ; } if ( $ target instanceof OrderInterface && $ customer -> hasParent ( ) ) { $ target -> setCustomer ( $ customer -> getParent ( ) ) ; if ( null === $ target -> getOriginCustomer ( ) ) { $ target -> setOriginCustomer ( $ customer ) ; } } }
7114	static public function isBetterMode ( $ modeA , $ modeB ) { if ( $ modeA === static :: MODE_DISABLED ) { return $ modeB !== static :: MODE_DISABLED ; } elseif ( $ modeA === static :: MODE_JUST_IN_TIME ) { return in_array ( $ modeB , [ static :: MODE_MANUAL , static :: MODE_AUTO ] , true ) ; } return false ; }
9702	public function addFont ( \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font ) { $ fontHashCode = $ font -> getHashCode ( ) ; if ( isset ( $ this -> addedFonts [ $ fontHashCode ] ) ) { $ fontIndex = $ this -> addedFonts [ $ fontHashCode ] ; } else { $ countFonts = count ( $ this -> fontWriters ) ; $ fontIndex = ( $ countFonts < 4 ) ? $ countFonts : $ countFonts + 1 ; $ fontWriter = new Font ( $ font ) ; $ fontWriter -> setColorIndex ( $ this -> addColor ( $ font -> getColor ( ) -> getRGB ( ) ) ) ; $ this -> fontWriters [ ] = $ fontWriter ; $ this -> addedFonts [ $ fontHashCode ] = $ fontIndex ; } return $ fontIndex ; }
4675	public function addString ( $ content , $ region = "main" , $ sort = 0 ) { $ view = new View ( ) ; $ view -> set ( $ content , [ ] , $ sort , "string" ) ; $ this -> views [ $ region ] [ ] = $ view ; return $ this ; }
8470	public function alert ( $ scope , $ message , $ context = [ ] , $ config = [ ] ) { return $ this -> write ( 'alert' , $ scope , $ message , $ context , $ config ) ; }
2507	protected static function loopOperationsWithQuery ( $ operations , $ query , $ wsdlIdentifier , $ domXpath ) { $ msgAndVer = [ ] ; foreach ( $ operations as $ operation ) { if ( ! empty ( $ operation -> value ) ) { $ fullVersion = $ domXpath -> evaluate ( sprintf ( $ query , $ operation -> value ) ) ; if ( ! empty ( $ fullVersion ) ) { $ extractedVersion = self :: extractMessageVersion ( $ fullVersion ) ; $ msgAndVer [ $ operation -> value ] = [ 'version' => $ extractedVersion , 'wsdl' => $ wsdlIdentifier ] ; } } } return $ msgAndVer ; }
258	public function render ( $ view , $ params = [ ] , $ context = null ) { $ viewFile = $ this -> findViewFile ( $ view , $ context ) ; return $ this -> renderFile ( $ viewFile , $ params , $ context ) ; }
6957	private function _getRenderedToc ( $ list , $ depth = 1 ) { if ( ! isset ( $ list ) || empty ( $ list ) ) return ( '' ) ; $ html = "<ul class=\"toc-list\">\n" ; foreach ( $ list as $ entry ) { $ html .= "<li class=\"toc-entry\">\n" ; $ html .= '<a href="#' . $ this -> getParam ( 'anchorsPrefix' ) . $ this -> titleToIdentifier ( $ depth , $ entry [ 'value' ] ) . '">' . $ entry [ 'value' ] . "</a>\n" ; if ( isset ( $ entry [ 'sub' ] ) ) $ html .= $ this -> _getRenderedToc ( $ entry [ 'sub' ] , ( $ depth + 1 ) ) ; $ html .= "</li>\n" ; } $ html .= "</ul>\n" ; return ( $ html ) ; }
4971	public static function convert ( ContentItemInterface $ from , ContentItemInterface $ to ) { $ reflectionFrom = new \ ReflectionClass ( $ from ) ; $ reflectionTo = new \ ReflectionClass ( $ to ) ; foreach ( $ reflectionFrom -> getProperties ( ) as $ property ) { $ property -> setAccessible ( true ) ; $ method = 'set' . ucfirst ( $ property -> getName ( ) ) ; if ( $ reflectionTo -> hasMethod ( $ method ) ) { $ to -> $ method ( $ property -> getValue ( $ from ) ) ; } } return $ to ; }
9966	public function fromArray ( array $ source , $ nullValue = null , $ startCell = 'A1' , $ strictNullComparison = false ) { if ( ! is_array ( end ( $ source ) ) ) { $ source = [ $ source ] ; } list ( $ startColumn , $ startRow ) = Coordinate :: coordinateFromString ( $ startCell ) ; foreach ( $ source as $ rowData ) { $ currentColumn = $ startColumn ; foreach ( $ rowData as $ cellValue ) { if ( $ strictNullComparison ) { if ( $ cellValue !== $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } else { if ( $ cellValue != $ nullValue ) { $ this -> getCell ( $ currentColumn . $ startRow ) -> setValue ( $ cellValue ) ; } } ++ $ currentColumn ; } ++ $ startRow ; } return $ this ; }
759	public function setChildren ( $ children ) { $ this -> _children = [ ] ; foreach ( $ children as $ child ) { $ child -> parent = $ this ; $ this -> _children [ ] = $ child ; } $ this -> updateCollectionOffsets ( ) ; }
2397	public function parseBbCode ( $ strComment ) { $ arrSearch = array ( '@\[b\](.*)\[/b\]@Uis' , '@\[i\](.*)\[/i\]@Uis' , '@\[u\](.*)\[/u\]@Uis' , '@\s*\[code\](.*)\[/code\]\s*@Uis' , '@\[color=([^\]" ]+)\](.*)\[/color\]@Uis' , '@\s*\[quote\](.*)\[/quote\]\s*@Uis' , '@\s*\[quote=([^\]]+)\](.*)\[/quote\]\s*@Uis' , '@\[img\]\s*([^\[" ]+\.(jpe?g|png|gif|bmp|tiff?|ico))\s*\[/img\]@i' , '@\[url\]\s*([^\[" ]+)\s*\[/url\]@i' , '@\[url=([^\]" ]+)\](.*)\[/url\]@Uis' , '@\[email\]\s*([^\[" ]+)\s*\[/email\]@i' , '@\[email=([^\]" ]+)\](.*)\[/email\]@Uis' , '@href="(([a-z0-9]+\.)*[a-z0-9]+\.([a-z]{2}|asia|biz|com|info|name|net|org|tel)(/|"))@i' ) ; $ arrReplace = array ( '<strong>$1</strong>' , '<em>$1</em>' , '<span style="text-decoration:underline">$1</span>' , "\n\n" . '<div class="code"><p>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_code' ] . '</p><pre>$1</pre></div>' . "\n\n" , '<span style="color:$1">$2</span>' , "\n\n" . '<blockquote>$1</blockquote>' . "\n\n" , "\n\n" . '<blockquote><p>' . sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_quote' ] , '$1' ) . '</p>$2</blockquote>' . "\n\n" , '<img src="$1" alt="" />' , '<a href="$1">$1</a>' , '<a href="$1">$2</a>' , '<a href="mailto:$1">$1</a>' , '<a href="mailto:$1">$2</a>' , 'href="http://$1' ) ; $ strComment = preg_replace ( $ arrSearch , $ arrReplace , $ strComment ) ; if ( strpos ( $ strComment , 'mailto:' ) !== false ) { $ strComment = StringUtil :: encodeEmail ( $ strComment ) ; } return $ strComment ; }
7708	function ReplaceSrc ( $ new ) { $ len = $ this -> GetLen ( ) ; $ this -> Txt = substr_replace ( $ this -> Txt , $ new , $ this -> PosBeg , $ len ) ; $ diff = strlen ( $ new ) - $ len ; $ this -> PosEnd += $ diff ; $ this -> pST_Src = false ; if ( $ new === '' ) { $ this -> pST_PosBeg = false ; $ this -> pST_PosEnd = false ; $ this -> pET_PosBeg = false ; } else { $ this -> pST_PosEnd += $ diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ diff ; } }
8767	protected function registerBaseBindings ( ) { static :: setInstance ( $ this ) ; $ this -> instance ( 'app' , $ this ) ; $ this -> instance ( Container :: class , $ this ) ; $ this -> singleton ( 'config' , function ( ) { return new \ Nur \ Config \ Config ( $ this -> config ) ; } ) ; $ this -> singleton ( 'files' , function ( ) { return new Filesystem ; } ) ; $ this -> instance ( PackageManifest :: class , new PackageManifest ( new Filesystem , $ this -> basePath ( ) , $ this -> getCachedPackagesPath ( ) ) ) ; }
4224	public function handleException ( $ exception ) { $ this -> uncaughtException = $ exception ; \ http_response_code ( 500 ) ; $ this -> handleError ( E_ERROR , 'Uncaught exception \'' . \ get_class ( $ exception ) . '\' with message ' . $ exception -> getMessage ( ) , $ exception -> getFile ( ) , $ exception -> getLine ( ) ) ; $ this -> uncaughtException = null ; if ( $ this -> cfg [ 'continueToPrevHandler' ] && $ this -> prevExceptionHandler ) { \ call_user_func ( $ this -> prevErrorHandler , $ exception ) ; } }
11970	public function extendExpiration ( ) { if ( null === $ this -> ttl ) { throw new DomainException ( 'There is no TTL set for this Lock.' ) ; } if ( ! $ this -> expiresAt ) { $ this -> expiresAt = new \ DateTime ( ) ; $ this -> expiresAt -> setTimestamp ( time ( ) ) ; } $ this -> expiresAt -> add ( $ this -> ttl ) ; }
10175	public function getHighestColumn ( $ row = null ) { if ( $ row == null ) { $ colRow = $ this -> getHighestRowAndColumn ( ) ; return $ colRow [ 'column' ] ; } $ columnList = [ 1 ] ; foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ r != $ row ) { continue ; } $ columnList [ ] = Coordinate :: columnIndexFromString ( $ c ) ; } return Coordinate :: stringFromColumnIndex ( max ( $ columnList ) + 1 ) ; }
11360	public function setSortBy ( $ sortKeys ) { if ( $ sortKeys == null ) { $ sortKeys = [ ] ; } if ( ! is_array ( $ sortKeys ) ) { $ sortKeys = [ $ sortKeys ] ; } $ this -> sortKeys = $ sortKeys ; }
12547	public function getBlockPlugin ( $ name ) { if ( ! array_key_exists ( $ name , $ this -> blocks ) ) { return null ; } return $ this -> blocks [ $ name ] ; }
5783	private function enterEventAndNotice ( string $ action , $ primaryKeyValue = null ) { if ( $ action != 'insert' && $ action != 'update' ) { throw new \ InvalidArgumentException ( "Action must be either insert or update" ) ; } $ actionPastTense = ( $ action == 'insert' ) ? 'inserted' : 'updated' ; $ tableNameSingular = $ this -> tableMapper -> getFormalTableName ( false ) ; $ noteStart = "$actionPastTense $tableNameSingular" ; $ eventTitle = @ constant ( "EVENT_" . strtoupper ( $ tableNameSingular ) . "_" . strtoupper ( $ action ) ) ?? $ noteStart ; $ adminNotification = $ noteStart ; $ eventPayload = [ ] ; if ( null !== $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ) { $ adminNotification .= " $primaryKeyValue" ; $ eventPayload = [ $ primaryKeyColumnName => $ primaryKeyValue ] ; } $ eventPayload = array_merge ( $ eventPayload , $ this -> requestInput ) ; $ this -> events -> insertInfo ( $ eventTitle , $ eventPayload ) ; SlimPostgres :: setAdminNotice ( $ adminNotification ) ; }
6485	private function isUsingStandardPort ( ) : bool { return $ this -> port === null || ( ( $ this -> scheme === 'http' && $ this -> port === 80 ) || ( $ this -> scheme === 'https' && $ this -> port === 443 ) ) ; }
57	public function remove ( PackageInterface $ package , $ targetDir ) { $ downloader = $ this -> getDownloaderForInstalledPackage ( $ package ) ; if ( $ downloader ) { $ downloader -> remove ( $ package , $ targetDir ) ; } }
401	public static function processParagraph ( $ markdown , $ flavor = null ) { $ parser = static :: getParser ( $ flavor ) ; return $ parser -> parseParagraph ( $ markdown ) ; }
2212	public function fetchField ( $ intOffset = 0 ) { $ arrFields = array_values ( $ this -> resultSet [ $ this -> intIndex ] ) ; return $ arrFields [ $ intOffset ] ; }
3855	public function setMetaTags ( $ strTitleAttribute , $ strDescriptionAttribute ) { $ this -> strDescriptionAttribute = $ strDescriptionAttribute ; $ this -> strTitleAttribute = $ strTitleAttribute ; return $ this ; }
3865	public function render ( $ blnNoNativeParsing , $ objCaller ) { $ event = new RenderItemListEvent ( $ this , $ this -> objTemplate , $ objCaller ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: RENDER_ITEM_LIST , $ event ) ; $ this -> objTemplate -> noItemsMsg = $ this -> getNoItemsCaption ( ) ; $ this -> objTemplate -> details = $ this -> getCaptionText ( 'details' ) ; $ this -> prepare ( ) ; $ strOutputFormat = $ this -> getOutputFormat ( ) ; if ( $ this -> objItems -> getCount ( ) && ! $ blnNoNativeParsing ) { $ this -> objTemplate -> data = $ this -> objItems -> parseAll ( $ strOutputFormat , $ this -> objView ) ; } else { $ this -> objTemplate -> data = array ( ) ; } $ this -> setTitleAndDescription ( ) ; $ this -> objTemplate -> caller = $ objCaller ; $ this -> objTemplate -> items = $ this -> objItems ; $ this -> objTemplate -> filterParams = $ this -> arrParam ; return $ this -> objTemplate -> parse ( $ strOutputFormat ) ; }
12051	protected function _createRendererException ( $ message = null , $ code = null , RootException $ previous = null , RendererInterface $ renderer = null ) { return new RendererException ( $ message , $ code , $ previous , $ renderer ) ; }
10094	protected function srvGet ( $ domain , $ https = false ) { if ( isset ( $ https ) && $ https === true ) { $ subdomain = '_avatars-sec._tcp.' ; $ fallback = 'seccdn.' ; $ port = 443 ; } else { $ subdomain = '_avatars._tcp.' ; $ fallback = 'cdn.' ; $ port = 80 ; } if ( $ domain === null ) { return $ fallback . 'libravatar.org' ; } $ srv = dns_get_record ( $ subdomain . $ domain , DNS_SRV ) ; if ( count ( $ srv ) == 0 ) { return $ fallback . 'libravatar.org' ; } usort ( $ srv , array ( $ this , 'comparePriority' ) ) ; $ top = $ srv [ 0 ] ; $ sum = 0 ; shuffle ( $ srv ) ; $ srvs = array ( ) ; foreach ( $ srv as $ s ) { if ( $ s [ 'weight' ] == 0 ) { array_unshift ( $ srvs , $ s ) ; } else { array_push ( $ srvs , $ s ) ; } } foreach ( $ srvs as $ s ) { if ( $ s [ 'pri' ] == $ top [ 'pri' ] ) { $ sum += ( int ) $ s [ 'weight' ] ; $ pri [ $ sum ] = $ s ; } } $ random = rand ( 0 , $ sum ) ; foreach ( $ pri as $ k => $ v ) { if ( $ k >= $ random ) { $ target = $ v [ 'target' ] ; if ( $ v [ 'port' ] !== $ port ) { $ target .= ':' . $ v [ 'port' ] ; } return $ target ; } } }
9770	function matchFormat ( string $ format ) : self { return $ this -> expect ( $ this -> target , matches ( $ format ) ) ; }
72	public function authorizeOAuth ( $ originUrl ) { if ( $ originUrl !== 'bitbucket.org' ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config bitbucket.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , 'x-token-auth' , trim ( $ output ) ) ; return true ; } return false ; }
9329	protected function registerMarkdownBladeEngine ( $ resolver ) { $ app = $ this -> app ; $ app -> singleton ( 'markdown.blade.compiler' , function ( $ app ) { $ cache = $ app [ 'config' ] [ 'view.compiled' ] ; return new MarkdownBladeCompiler ( $ app [ 'files' ] , $ cache ) ; } ) ; $ resolver -> register ( 'markdown.blade' , function ( ) use ( $ app ) { return new MarkdownEngine ( $ app [ 'markdown.blade.compiler' ] , $ app [ 'files' ] ) ; } ) ; $ app [ 'view' ] -> addExtension ( 'md.blade.php' , 'markdown.blade' ) ; }
1179	protected function getValidationData ( array $ rules , array $ customAttributes = [ ] ) { $ attributes = array_filter ( array_keys ( $ rules ) , function ( $ attribute ) { return $ attribute !== '' && mb_strpos ( $ attribute , '*' ) !== false ; } ) ; $ attributes = array_merge ( array_keys ( $ customAttributes ) , $ attributes ) ; $ data = array_reduce ( $ attributes , function ( $ data , $ attribute ) { Arr :: set ( $ data , $ attribute , true ) ; return $ data ; } , [ ] ) ; return $ data ; }
4412	public function getLegacyPreference ( $ name ) { $ legacyKernel = $ this -> legacyKernel ; return $ legacyKernel ( ) -> runCallback ( function ( ) use ( $ name ) { return eZPreferences :: value ( $ name ) ; } ) ; }
5323	public function registerHandler ( $ signal , $ handler ) { if ( ! is_callable ( $ handler ) ) { throw new \ InvalidArgumentException ( 'The handler is not callable' ) ; } if ( ! isset ( $ this -> handlers [ $ signal ] ) ) { $ this -> handlers [ $ signal ] = [ ] ; if ( ! pcntl_signal ( $ signal , [ $ this , 'handleSignal' ] ) ) { throw new \ RuntimeException ( sprintf ( 'Could not register signal %d with pcntl_signal' , $ signal ) ) ; } ; } ; $ this -> handlers [ $ signal ] [ ] = $ handler ; return $ this ; }
9125	private function handleHeader ( & $ delimiterFound , & $ numBytes , & $ tmp ) { if ( $ tmp == "\r\n" ) { $ numBytes = $ this -> adjustNumbytes ( $ numBytes ) ; $ delimiterFound = true ; $ tmp = "" ; return ; } if ( substr ( $ tmp , - 2 , 2 ) == "\r\n" ) { $ this -> addParsedHeader ( $ tmp ) ; $ tmp = "" ; } }
8851	public function PaginatedList ( ) { $ posts = new PaginatedList ( $ this -> blogPosts ) ; if ( $ this -> PostsPerPage > 0 ) $ posts -> setPageLength ( $ this -> PostsPerPage ) ; else $ posts -> setPageLength ( $ this -> getBlogPosts ( ) -> count ( ) ) ; $ start = $ this -> request -> getVar ( $ posts -> getPaginationGetVar ( ) ) ; $ posts -> setPageStart ( $ start ) ; return $ posts ; }
2483	protected function getSearchTargets ( $ languageSettings ) { if ( $ this -> endpointResolver instanceof SingleEndpointResolver && ! $ this -> endpointResolver -> hasMultipleEndpoints ( ) ) { return '' ; } $ shards = array ( ) ; $ endpoints = $ this -> endpointResolver -> getSearchTargets ( $ languageSettings ) ; if ( ! empty ( $ endpoints ) ) { foreach ( $ endpoints as $ endpoint ) { $ shards [ ] = $ this -> endpointRegistry -> getEndpoint ( $ endpoint ) -> getIdentifier ( ) ; } } return implode ( ',' , $ shards ) ; }
7719	function meth_Conv_Str ( & $ Txt , $ ConvBr = true ) { if ( $ this -> Charset === '' ) { $ Txt = htmlspecialchars ( $ Txt ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } elseif ( $ this -> _CharsetFct ) { $ Txt = call_user_func ( $ this -> Charset , $ Txt , $ ConvBr ) ; } else { $ Txt = htmlspecialchars ( $ Txt , ENT_COMPAT , $ this -> Charset ) ; if ( $ ConvBr ) $ Txt = nl2br ( $ Txt ) ; } }
3061	public function getCurrentPosition ( ) { $ route = $ this -> getTestSession ( ) -> getRoute ( ) ; $ routeCount = $ route -> count ( ) ; $ routeItemPosition = $ route -> getPosition ( ) ; $ currentRouteItem = $ route -> getRouteItemAt ( $ routeItemPosition ) ; $ finalPosition = 0 ; for ( $ i = 0 ; $ i < $ routeCount ; $ i ++ ) { $ routeItem = $ route -> getRouteItemAt ( $ i ) ; if ( $ routeItem !== $ currentRouteItem ) { if ( ! $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition ++ ; } else { $ finalPosition += count ( $ this -> getShadowTest ( $ routeItem ) ) ; } } else { if ( $ this -> isAdaptive ( $ routeItem -> getAssessmentItemRef ( ) ) ) { $ finalPosition += array_search ( $ this -> getCurrentCatItemId ( $ routeItem ) , $ this -> getShadowTest ( $ routeItem ) ) ; } break ; } } return $ finalPosition ; }
11150	protected function setCacheState ( $ useCache ) { if ( is_bool ( $ useCache ) ) { $ this -> useCache = $ useCache ; } else { $ this -> useCache = true ; } }
2627	public function renderCellTemplate ( $ columnName ) { if ( $ columnName == 'store_id' && isset ( $ this -> _columns [ $ columnName ] ) ) { $ options = $ this -> getOptions ( __ ( '-- Select Store --' ) ) ; $ element = $ this -> elementFactory -> create ( 'select' ) ; $ element -> setForm ( $ this -> getForm ( ) ) -> setName ( $ this -> _getCellInputElementName ( $ columnName ) ) -> setHtmlId ( $ this -> _getCellInputElementId ( '<%- _id %>' , $ columnName ) ) -> setValues ( $ options ) ; return str_replace ( "\n" , '' , $ element -> getElementHtml ( ) ) ; } return parent :: renderCellTemplate ( $ columnName ) ; }
8868	public function notify ( PayloadInterface $ payload ) { foreach ( $ this -> runners as $ runner ) { $ runner -> run ( $ payload ) ; } return $ this ; }
9052	public function getMenuItemsJson ( Collection $ menuItems , $ currentOwner ) { $ this -> alreadySetIds = [ ] ; $ this -> position = 0 ; $ this -> currentOwner = $ currentOwner ; return json_encode ( $ this -> recursiveMenuItemHandling ( $ menuItems ) ) ; }
12953	public function getForeignChildren ( ) { $ children = [ ] ; foreach ( $ this -> dataSource -> foreignChildKeys as $ keySet ) { $ model = $ keySet [ 'foreignModel' ] ; unset ( $ keySet [ 'foreignModel' ] ) ; if ( ! empty ( $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ) ) { $ keySet [ 'foreignId' ] = $ this -> foreignObject -> { $ keySet [ 'foreignId' ] } ; if ( ! isset ( $ children [ $ model ] ) ) { $ children [ $ model ] = [ ] ; } $ children [ $ model ] [ ] = $ keySet ; } } return $ children ; }
652	public function execute ( ) { $ sql = $ this -> getSql ( ) ; list ( $ profile , $ rawSql ) = $ this -> logQuery ( __METHOD__ ) ; if ( $ sql == '' ) { return 0 ; } $ this -> prepare ( false ) ; try { $ profile and Yii :: beginProfile ( $ rawSql , __METHOD__ ) ; $ this -> internalExecute ( $ rawSql ) ; $ n = $ this -> pdoStatement -> rowCount ( ) ; $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; $ this -> refreshTableSchema ( ) ; return $ n ; } catch ( Exception $ e ) { $ profile and Yii :: endProfile ( $ rawSql , __METHOD__ ) ; throw $ e ; } }
4189	protected function dumpConstants ( $ constants ) { $ str = '' ; if ( $ constants && $ this -> debug -> output -> getCfg ( 'outputConstants' ) ) { $ str = '<dt class="constants">constants</dt>' . "\n" ; foreach ( $ constants as $ k => $ value ) { $ str .= '<dd class="constant">' . '<span class="constant-name">' . $ k . '</span>' . ' <span class="t_operator">=</span> ' . $ this -> debug -> output -> html -> dump ( $ value ) . '</dd>' . "\n" ; } } return $ str ; }
11780	public function fromDbToEntity ( array $ data ) { $ hydratorFactory = $ this -> documentManager -> getHydratorFactory ( ) ; $ documentClass = $ this -> documentClass ; $ document = new $ documentClass ( ) ; $ hydratorFactory -> hydrate ( $ document , $ data ) ; return $ document ; }
11218	public static function dispatch ( ) { self :: routeValidator ( ) ; self :: $ routes = str_replace ( '//' , '/' , self :: $ routes ) ; if ( in_array ( self :: $ uri , self :: $ routes , true ) ) { return self :: checkRoutes ( ) ; } if ( self :: checkRegexRoutes ( ) !== false ) { return self :: checkRegexRoutes ( ) ; } return self :: getErrorCallback ( ) ; }
2404	public function asset ( $ path , $ packageName = null ) { $ url = System :: getContainer ( ) -> get ( 'assets.packages' ) -> getUrl ( $ path , $ packageName ) ; return ltrim ( $ url , '/' ) ; }
12072	private function getForcedCustomersIds ( ) { $ mlmIds = array_keys ( $ this -> QUALIFIED_CUSTOMERS ) ; $ where = '' ; foreach ( $ mlmIds as $ one ) { if ( strlen ( $ where ) > 0 ) { $ where .= ' OR ' ; } $ quoted = $ this -> conn -> quote ( $ one ) ; $ where .= Customer :: A_MLM_ID . "=\"$quoted\"" ; } $ cols = [ Customer :: A_CUSTOMER_REF , Customer :: A_MLM_ID ] ; $ result = $ this -> daoGeneric -> getEntities ( Customer :: ENTITY_NAME , $ cols , $ where ) ; return $ result ; }
5977	public function moodboards ( ) { if ( ! $ this -> moodboards instanceof MoodboardsController ) { $ this -> moodboards = new MoodboardsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> moodboards -> setLogger ( $ this -> logger ) ; } return $ this -> moodboards ; }
4640	private function createHelperPluginManager ( ContainerInterface $ container ) : HelperPluginManager { $ factory = new ViewHelperManagerFactory ( ) ; $ helperManager = $ factory ( $ container , ViewHelperManagerFactory :: PLUGIN_MANAGER_CLASS ) ; $ config = new Config ( $ this -> getSpecificConfig ( $ container , 'view_helpers' ) ) ; $ config -> configureServiceManager ( $ helperManager ) ; return $ helperManager ; }
213	public function registerClientScript ( ) { $ js = '' ; $ view = $ this -> getView ( ) ; $ this -> initClientOptions ( ) ; if ( ! empty ( $ this -> mask ) ) { $ this -> clientOptions [ 'mask' ] = $ this -> mask ; } $ this -> hashPluginOptions ( $ view ) ; if ( is_array ( $ this -> definitions ) && ! empty ( $ this -> definitions ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendDefinitions(' . Json :: htmlEncode ( $ this -> definitions ) . ');' ; } if ( is_array ( $ this -> aliases ) && ! empty ( $ this -> aliases ) ) { $ js .= ucfirst ( self :: PLUGIN_NAME ) . '.extendAliases(' . Json :: htmlEncode ( $ this -> aliases ) . ');' ; } $ id = $ this -> options [ 'id' ] ; $ js .= 'jQuery("#' . $ id . '").' . self :: PLUGIN_NAME . '(' . $ this -> _hashVar . ');' ; MaskedInputAsset :: register ( $ view ) ; $ view -> registerJs ( $ js ) ; }
4764	protected function validateDeliveryAddressOptIn ( ) { $ return = true ; $ optin = ( int ) $ this -> getRequestParameter ( 'oegdproptin_deliveryaddress' ) ; $ changeExistigAddress = ( int ) $ this -> getRequestParameter ( 'oegdproptin_changeDelAddress' ) ; $ addressId = $ this -> getRequestParameter ( 'oxaddressid' ) ; $ deliveryAddressData = $ this -> _getDelAddressData ( ) ; if ( \ OxidEsales \ Eshop \ Core \ Registry :: getConfig ( ) -> getConfigParam ( 'blOeGdprOptinDeliveryAddress' ) && ( ( null == $ addressId ) || ( '-1' == $ addressId ) || ( 1 == $ changeExistigAddress ) ) && ! empty ( $ deliveryAddressData ) && ( 1 !== $ optin ) ) { $ return = false ; } return $ return ; }
7972	public function deleteIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; try { $ this -> delete ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return true ; }
5	private function buildDepPackageConstraints ( $ depItem , $ depType ) { if ( $ this -> isHash ( $ depItem ) ) { $ depItem = array ( $ depItem ) ; } $ result = array ( ) ; foreach ( $ depItem as $ subDepItem ) { if ( ! array_key_exists ( 'channel' , $ subDepItem ) ) { $ subDepItem [ 'channel' ] = $ subDepItem [ 'uri' ] ; } $ depChannelName = $ subDepItem [ 'channel' ] ; $ depPackageName = $ subDepItem [ 'name' ] ; $ depVersionConstraint = $ this -> parse20VersionConstraint ( $ subDepItem ) ; if ( isset ( $ subDepItem [ 'conflicts' ] ) ) { $ depType = 'conflicts' ; } $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } return $ result ; }
7746	private function findSetter ( ) { $ reflClass = new \ ReflectionClass ( $ this -> class ) ; $ setter = 'set' . $ this -> camelize ( $ this -> name ) ; $ classHasProperty = $ reflClass -> hasProperty ( $ this -> name ) ; if ( $ reflClass -> hasMethod ( $ setter ) && $ reflClass -> getMethod ( $ setter ) -> isPublic ( ) ) { $ this -> setter = $ setter ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( 0 === strpos ( $ this -> name , 'set' ) ) && $ reflClass -> hasMethod ( $ this -> name ) && $ reflClass -> getMethod ( $ this -> name ) -> isPublic ( ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_METHOD ; } elseif ( ( $ reflClass -> hasMethod ( '__set' ) && $ reflClass -> getMethod ( '__set' ) -> isPublic ( ) ) || ( $ classHasProperty && $ reflClass -> getProperty ( $ this -> name ) -> isPublic ( ) ) ) { $ this -> setter = $ this -> name ; $ this -> setterType = self :: GETTER_SETTER_PROPERTY ; } }
9658	public static function createWriter ( Spreadsheet $ spreadsheet , $ writerType ) { if ( ! isset ( self :: $ writers [ $ writerType ] ) ) { throw new Writer \ Exception ( "No writer found for type $writerType" ) ; } $ className = self :: $ writers [ $ writerType ] ; $ writer = new $ className ( $ spreadsheet ) ; return $ writer ; }
6014	public function retrieveProtocol ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/protocols/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new Protocol ( $ result ) ; return $ result ; }
8371	protected function shutdown ( ) { $ this -> shutdown = true ; $ this -> args [ 'messages' ] = array_filter ( $ this -> messages , function ( $ message ) { if ( ! isset ( $ message [ 'sent' ] ) || $ message [ 'sent' ] === false ) { return $ message ; } } ) ; $ redis = new Redis ; $ client = new Client ( $ redis ) ; $ client -> push ( static :: class , $ this -> args , 1 , 100 ) ; return true ; }
7963	public function ipSetMonitoringNotifications ( $ ip , $ frequency = 'once' , $ email = '' , $ sms = array ( ) ) { return json_decode ( self :: getClient ( ) -> ipSetMonitoringNotifications ( $ this -> id , $ ip , $ frequency , $ email , $ sms ) ) ; }
3916	protected function sortByIdList ( $ sortIds ) { $ fileMap = $ this -> foundFiles ; if ( ! $ fileMap ) { return array ( 'files' => array ( ) , 'source' => array ( ) ) ; } $ fileKeys = array_flip ( array_keys ( $ this -> uuidMap ) ) ; $ sorted = array ( ) ; foreach ( $ sortIds as $ sortStringId ) { $ key = $ fileKeys [ $ sortStringId ] ; $ sorted [ $ key ] = $ fileMap [ $ key ] ; unset ( $ fileMap [ $ key ] ) ; } $ sorted += $ fileMap ; return $ this -> remapSorting ( $ sorted , $ this -> outputBuffer ) ; }
5237	private function injectionValuesForMethod ( \ ReflectionMethod $ method ) { $ paramValues = [ ] ; $ defaultName = $ this -> methodBindingName ( $ method ) ; foreach ( $ method -> getParameters ( ) as $ param ) { $ type = $ this -> paramType ( $ method , $ param ) ; $ name = $ this -> detectBindingName ( $ param , $ defaultName ) ; $ hasExplicitBinding = $ this -> injector -> hasExplicitBinding ( $ type , $ name ) ; if ( ! $ hasExplicitBinding && $ param -> isDefaultValueAvailable ( ) ) { $ paramValues [ ] = $ param -> getDefaultValue ( ) ; continue ; } if ( ! $ this -> injector -> hasBinding ( $ type , $ name ) ) { $ typeMsg = $ this -> createTypeMessage ( $ type , $ name ) ; throw new BindingException ( 'Can not inject into ' . $ this -> class -> getName ( ) . '::' . $ method -> getName ( ) . '(' . $ this -> createParamString ( $ param , $ type ) . '). No binding for type ' . $ typeMsg . ' specified. Injection stack: ' . "\n" . join ( "\n" , $ this -> injector -> stack ( ) ) ) ; } $ paramValues [ ] = $ this -> injector -> getInstance ( $ type , $ name ) ; } return $ paramValues ; }
11445	public function getTransporter ( ) { if ( empty ( $ this -> transporter ) ) { $ transport_class = $ this -> getDefault ( 'transporter' ) ; if ( class_exists ( $ transport_class ) ) { $ this -> setTransporter ( new $ transport_class ) ; } else { throw new \ Exception ( sprintf ( 'Default transport class "%s" not found!' , $ transport_class ) ) ; } } return $ this -> transporter ; }
9744	public function setState ( $ state ) { if ( ! $ state ) { return $ this ; } if ( ! ( $ state instanceof State ) ) { $ state = new State ( $ state ) ; } if ( $ state -> isEmpty ( ) ) { $ this -> invalidArguments ( '10002' ) ; } return $ this -> setParameter ( 'state' , $ state ) ; }
12435	public function add ( $ id , IFormField $ field ) { $ field -> setId ( $ id ) ; return $ this -> addFormField ( $ field ) ; }
3502	private function initializeCurlResource ( ) : void { if ( ! $ this -> resource ) { $ this -> resource = curl_init ( ) ; curl_setopt ( $ this -> resource , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_POST , 1 ) ; curl_setopt ( $ this -> resource , CURLOPT_HTTP_VERSION , 3 ) ; } }
994	private function getDescription ( $ node ) { if ( $ node -> description ) { return $ node -> description -> value ; } if ( isset ( $ this -> options [ 'commentDescriptions' ] ) ) { $ rawValue = $ this -> getLeadingCommentBlock ( $ node ) ; if ( $ rawValue !== null ) { return BlockString :: value ( "\n" . $ rawValue ) ; } } return null ; }
809	private function sortByLength ( array $ first , array $ second ) { $ firstNamespace = ( self :: IMPORT_TYPE_CLASS === $ first [ 'importType' ] ? '' : $ first [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ first [ 'namespace' ] ) ; $ secondNamespace = ( self :: IMPORT_TYPE_CLASS === $ second [ 'importType' ] ? '' : $ second [ 'importType' ] . ' ' ) . $ this -> prepareNamespace ( $ second [ 'namespace' ] ) ; $ firstNamespaceLength = \ strlen ( $ firstNamespace ) ; $ secondNamespaceLength = \ strlen ( $ secondNamespace ) ; if ( $ firstNamespaceLength === $ secondNamespaceLength ) { $ sortResult = strcasecmp ( $ firstNamespace , $ secondNamespace ) ; } else { $ sortResult = $ firstNamespaceLength > $ secondNamespaceLength ? 1 : - 1 ; } return $ sortResult ; }
5636	public function paintFail ( $ message ) { parent :: paintFail ( $ message ) ; print $ this -> getFailCount ( ) . ") $message\n" ; $ breadcrumb = $ this -> getTestList ( ) ; array_shift ( $ breadcrumb ) ; print "\tin " . implode ( "\n\tin " , array_reverse ( $ breadcrumb ) ) ; print "\n" ; }
190	private function loadTableColumnsInfo ( $ tableName ) { $ tableColumns = $ this -> db -> createCommand ( 'PRAGMA TABLE_INFO (' . $ this -> quoteValue ( $ tableName ) . ')' ) -> queryAll ( ) ; $ tableColumns = $ this -> normalizePdoRowKeyCase ( $ tableColumns , true ) ; return ArrayHelper :: index ( $ tableColumns , 'cid' ) ; }
9160	private function adjustHeaders ( $ requestType ) { if ( ! array_key_exists ( 'Accept' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept' , 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8' ) ; } if ( ! array_key_exists ( 'Accept-Language' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'Accept-Language' , 'en-US;q=0.7,en;q=0.3' ) ; } if ( ! array_key_exists ( 'User-Agent' , $ this -> headers ) && $ requestType != 'HEAD' ) { $ this -> setHeader ( 'User-Agent' , 'phpGenerics 1.0' ) ; } if ( ! array_key_exists ( 'Connection' , $ this -> headers ) || strlen ( $ this -> headers [ 'Connection' ] ) == 0 ) { $ this -> adjustConnectionHeader ( $ requestType ) ; } if ( ! array_key_exists ( 'Accept-Encoding' , $ this -> headers ) ) { if ( function_exists ( 'gzinflate' ) ) { $ encoding = 'gzip, deflate' ; } else { $ encoding = 'identity' ; } $ this -> setHeader ( 'Accept-Encoding' , $ encoding ) ; } }
9720	public function setEscher ( \ PhpOffice \ PhpSpreadsheet \ Shared \ Escher $ pValue = null ) { $ this -> escher = $ pValue ; }
4553	public function created ( JWTCreatedEvent $ event ) { $ data = $ event -> getData ( ) ; foreach ( $ this -> removed as $ property ) { if ( ! array_key_exists ( $ property , $ data ) ) { throw new OutOfRangeException ( 'Property does not exist.' ) ; } unset ( $ data [ $ property ] ) ; } $ event -> setData ( $ data ) ; }
11146	public function move ( Neuron_GameServer_Map_MapObject $ object , Neuron_GameServer_Map_Location $ location , Neuron_GameServer_Map_Date $ start , Neuron_GameServer_Map_Date $ end ) { throw new Neuron_Exceptions_NotImplemented ( "The move method is not implemented in this map." ) ; }
3589	protected function saveMeta ( ) { foreach ( $ this -> getMetaAttributes ( ) as $ attribute ) { if ( is_null ( $ attribute -> getValue ( ) ) ) { $ attribute -> delete ( ) ; } else { $ this -> metaAttributes ( ) -> save ( $ attribute ) ; } } }
11825	public function add ( $ encoding = 'UTF-8' ) { $ str = file_get_contents ( $ this -> uri ) ; return file_put_contents ( $ this -> uri , $ this -> getBom ( $ encoding ) . $ str ) ; }
4513	public function toObject ( ) : stdClass { $ object = new stdClass ; $ object -> timestamp = $ this -> timestamp ; $ object -> collection = $ this -> collection -> toArray ( ) ; foreach ( $ object -> collection as $ alias => $ status ) { $ object -> collection [ $ alias ] = $ status -> toObject ( ) ; } return $ object ; }
4980	public function convertToDatabaseValue ( $ value ) { if ( ! $ value instanceof \ DateTime ) { return null ; } $ timezone = $ value -> getTimezone ( ) -> getName ( ) ; $ timestamp = $ value -> getTimestamp ( ) ; $ date = new \ MongoDate ( $ timestamp ) ; return array ( 'date' => $ date , 'tz' => $ timezone , ) ; }
5532	protected function createCodeForOverridenMethods ( $ methods ) { $ code = '' ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) . " {\n" ; $ code .= " return \$this->mock->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } return $ code ; }
3583	protected function joinMeta ( Builder $ query , $ column ) { $ query -> prefixColumnsForJoin ( ) ; $ alias = $ this -> generateMetaAlias ( ) ; $ table = ( new Attribute ) -> getTable ( ) ; $ query -> leftJoin ( "{$table} as {$alias}" , function ( $ join ) use ( $ alias , $ column ) { $ join -> on ( "{$alias}.metable_id" , '=' , $ this -> getQualifiedKeyName ( ) ) -> where ( "{$alias}.metable_type" , '=' , $ this -> getMorphClass ( ) ) -> where ( "{$alias}.meta_key" , '=' , $ column ) ; } ) ; return $ alias ; }
12131	public function handle ( ) { $ view = $ this -> application -> createInstance ( "view" , [ $ this -> application -> response , $ this -> application -> createInstance ( "viewengine" , [ $ this -> application -> response ] ) , $ this -> application ] ) ; $ view -> setData ( "title" , "An Error Occured" ) ; $ this -> application -> response -> send ( $ view -> render ( "errors/error" ) ) ; return Handler :: LAST_HANDLER ; }
6703	public function get ( OAuthConsumerInterface $ consumer , OAuthTokenInterface $ token , $ httpverb , $ url , $ params = [ ] ) { uksort ( $ params , 'strcmp' ) ; $ base_url = $ this -> baseURL ( $ httpverb , $ url , $ params ) ; $ key = $ consumer -> secret . '&' . $ token -> secret ; return base64_encode ( hash_hmac ( 'sha1' , $ base_url , $ key , true ) ) ; }
3207	private static function chunk ( $ binaryString , $ bits ) { $ binaryString = chunk_split ( $ binaryString , $ bits , ' ' ) ; if ( substr ( $ binaryString , ( strlen ( $ binaryString ) ) - 1 ) == ' ' ) { $ binaryString = substr ( $ binaryString , 0 , strlen ( $ binaryString ) - 1 ) ; } return explode ( ' ' , $ binaryString ) ; }
2891	public function onControllerFrontSendResponseAfter ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ front = $ observer -> getData ( 'front' ) ; $ this -> updateProfiling ( ) ; $ this -> getRequestInfo ( ) -> getController ( ) -> addResponseInfo ( $ front -> getResponse ( ) ) ; }
10398	protected function doReplacement ( $ inputString ) { if ( is_string ( $ inputString ) ) { $ inputString = str_replace ( array_keys ( $ this -> replacements ) , array_values ( $ this -> replacements ) , $ inputString ) ; } return $ inputString ; }
7948	public function getPppLoginByMail ( $ id ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; try { $ this -> post ( 'xdsl/' . $ id . '/requestPPPLoginMail' ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
2036	public function getAbsoluteUrl ( $ strParams = null ) { $ this -> loadDetails ( ) ; $ objUrlGenerator = System :: getContainer ( ) -> get ( 'contao.routing.url_generator' ) ; $ strUrl = $ objUrlGenerator -> generate ( ( $ this -> alias ? : $ this -> id ) . $ strParams , array ( '_locale' => $ this -> rootLanguage , '_domain' => $ this -> domain , '_ssl' => ( bool ) $ this -> rootUseSSL , ) , UrlGeneratorInterface :: ABSOLUTE_URL ) ; $ strUrl = $ this -> applyLegacyLogic ( $ strUrl , $ strParams ) ; return $ strUrl ; }
5883	public function beforeFind ( Event $ event , Query $ query , ArrayObject $ options , $ primary ) { $ orders = $ this -> _config [ 'orders' ] ; $ args = [ $ query , $ options , $ primary ] ; foreach ( $ orders as $ config ) { if ( ( ! empty ( $ config [ 'callback' ] ) && call_user_func_array ( $ config [ 'callback' ] , $ args ) ) || ! $ query -> clause ( 'order' ) ) { $ query -> order ( $ config [ 'order' ] ) ; break ; } } }
2198	public static function findByIdOrAliasAndPid ( $ varId , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) ; $ arrValues = array ( $ varId ) ; if ( $ intPid ) { $ arrColumns [ ] = "$t.pid=?" ; $ arrValues [ ] = $ intPid ; } return static :: findOneBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
12647	public function setFalse ( $ obData = null ) { $ this -> bStatus = false ; $ this -> obData = $ obData ; return $ this ; }
9068	protected function convert_value_to_string ( $ value ) { if ( $ this -> is_resource ( $ value ) ) { $ type = get_resource_type ( $ value ) ; return "(Resource:$type)" ; } if ( is_object ( $ value ) ) { if ( $ value instanceof \ Exception || $ value instanceof \ Throwable ) { return '(' . get_class ( $ value ) . "#{$value->getCode()}:{$value->getMessage()})" ; } elseif ( $ value instanceof \ DateTime || ( interface_exists ( '\DateTimeInterface' ) && $ value instanceof \ DateTimeInterface ) ) { return $ value -> format ( \ DateTime :: ATOM ) ; } elseif ( method_exists ( $ value , '__toString' ) ) { return ( string ) $ value ; } else { $ class = get_class ( $ value ) ; return "($class)" ; } } if ( is_array ( $ value ) ) { return '(Array)' ; } if ( is_scalar ( $ value ) ) { return $ value ; } if ( $ value === null ) { return '(Null)' ; } return '(Invalid)' ; }
12784	protected function isNoResultMask ( $ mask ) { foreach ( $ this -> noResultMasks as $ noresultMask ) { if ( $ mask === $ noresultMask ) { return TRUE ; } if ( ( $ mask & $ noresultMask ) === $ noresultMask ) { $ this -> noResultMasks [ ] = $ mask ; return TRUE ; } } return FALSE ; }
5918	protected function setSecretKey ( $ passphrase ) { $ length = strlen ( $ passphrase ) ; if ( strlen ( $ passphrase ) < 1 || strlen ( $ passphrase ) > 56 ) { throw new Ts3Exception ( "secret passphrase must contain at least one but less than 56 characters" ) ; } $ k = 0 ; $ data = 0 ; $ datal = 0 ; $ datar = 0 ; for ( $ i = 0 ; $ i < 18 ; $ i ++ ) { $ data = 0 ; for ( $ j = 4 ; $ j > 0 ; $ j -- ) { $ data = $ data << 8 | ord ( $ passphrase { $ k } ) ; $ k = ( $ k + 1 ) % $ length ; } $ this -> p [ $ i ] ^= $ data ; } for ( $ i = 0 ; $ i <= 16 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> p [ $ i ] = $ datal ; $ this -> p [ $ i + 1 ] = $ datar ; } foreach ( $ this -> s as $ key => $ val ) { for ( $ i = 0 ; $ i < 256 ; $ i += 2 ) { $ this -> encipher ( $ datal , $ datar ) ; $ this -> s [ $ key ] [ $ i ] = $ datal ; $ this -> s [ $ key ] [ $ i + 1 ] = $ datar ; } } }
4231	public static function findInheritedDoc ( \ Reflector $ reflector ) { $ name = $ reflector -> getName ( ) ; $ reflectionClass = $ reflector -> getDeclaringClass ( ) ; $ interfaces = $ reflectionClass -> getInterfaceNames ( ) ; foreach ( $ interfaces as $ className ) { $ reflectionClass2 = new \ ReflectionClass ( $ className ) ; if ( $ reflectionClass2 -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass2 -> getMethod ( $ name ) ) ; } } $ reflectionClass = $ reflectionClass -> getParentClass ( ) ; if ( $ reflectionClass && $ reflectionClass -> hasMethod ( $ name ) ) { return self :: getParsed ( $ reflectionClass -> getMethod ( $ name ) ) ; } }
5774	public function isDeletable ( ) : bool { if ( is_null ( $ this -> authorization ) ) { throw new \ Exception ( "Authorization must be set" ) ; } $ id = $ this -> getId ( ) ; if ( $ this -> isLoggedIn ( ) ) { $ this -> notDeletableReason = "Administrator cannot delete own account: id $id" ; return false ; } if ( ! $ this -> getAuthorization ( ) -> hasTopRole ( ) && $ this -> hasTopRole ( ) ) { $ this -> notDeletableReason = "Not authorized to delete administrator: id $id" ; return false ; } if ( ( EventsTableMapper :: getInstance ( ) ) -> existForAdministrator ( $ id ) ) { $ this -> notDeletableReason = "Events exist for administrator: id $id" ; return false ; } return true ; }
5607	public function paintGroupEnd ( $ group ) { $ this -> group = '' ; $ cc = '' ; if ( $ this -> cc ) { if ( extension_loaded ( 'xdebug' ) ) { $ arrfiles = xdebug_get_code_coverage ( ) ; xdebug_stop_code_coverage ( ) ; $ thisdir = dirname ( __FILE__ ) ; $ thisdirlen = strlen ( $ thisdir ) ; foreach ( $ arrfiles as $ index => $ file ) { if ( substr ( $ index , 0 , $ thisdirlen ) === $ thisdir ) { continue ; } $ lcnt = 0 ; $ ccnt = 0 ; foreach ( $ file as $ line ) { if ( $ line == - 2 ) { continue ; } $ lcnt ++ ; if ( $ line == 1 ) { $ ccnt ++ ; } } if ( $ lcnt > 0 ) { $ cc .= round ( ( $ ccnt / $ lcnt ) * 100 , 2 ) . '%' ; } else { $ cc .= '0.00%' ; } $ cc .= "\t" . $ index . "\n" ; } } } $ this -> listener -> write ( '{status:"coverage",message:"' . self :: escapeVal ( $ cc ) . '"}' ) ; }
12395	abstract public function __construct ( ConnectionInterface $ connection ) ;
10624	private static function checkAndMoveFile ( $ sourceMigrationFile , $ appMigrationDir , IOInterface $ io ) { $ explodedPath = explode ( '/' , $ sourceMigrationFile ) ; $ filename = array_pop ( $ explodedPath ) ; if ( file_exists ( $ appMigrationDir . '/' . $ filename ) ) { if ( md5_file ( $ appMigrationDir . '/' . $ filename ) === md5_file ( $ sourceMigrationFile ) ) { if ( $ io -> isVeryVerbose ( ) ) { $ io -> write ( "<info>found that $sourceMigrationFile is equal" . " to $appMigrationDir/$filename</info>" ) ; } $ doTheMove = false ; } else { $ doTheMove = $ io -> askConfirmation ( "<question>The file \n" . " \t$sourceMigrationFile\n has the same name than the previous " . "migrated file located at \n\t$appMigrationDir/$filename\n " . "but the content is not equal.\n Overwrite the file ?[y,N]" , false ) ; } } else { $ doTheMove = true ; } if ( $ doTheMove ) { $ fs = new Filesystem ( ) ; $ fs -> copy ( $ sourceMigrationFile , $ appMigrationDir . '/' . $ filename ) ; $ io -> write ( "<info>Importing '$filename' migration file</info>" ) ; return true ; } return false ; }
5198	public function save ( ) { try { $ connection = new Connection ( $ this -> buildConnectionOptions ( ) ) ; $ connection -> open ( ) ; $ msg = new AMQPMessage ( $ this -> message , array ( 'content_type' => $ this -> content_type , 'delivery_mode' => 2 ) ) ; $ connection -> channel -> basic_publish ( $ msg , $ this -> exchange , $ this -> queue_name ) ; $ connection -> close ( ) ; } catch ( Exception $ e ) { $ connection -> close ( ) ; throw new Exception ( $ e ) ; } }
3234	static function stringEquals ( $ a , $ b ) { if ( func_num_args ( ) !== 2 ) { throw new \ InvalidArgumentException ( "Expecting 2 args, got " . func_num_args ( ) . "." ) ; } Checker :: argString ( "a" , $ a ) ; Checker :: argString ( "b" , $ b ) ; $ len = strlen ( $ a ) ; if ( strlen ( $ b ) !== $ len ) return false ; $ result = 0 ; for ( $ i = 0 ; $ i < $ len ; $ i ++ ) { $ result |= ord ( $ a [ $ i ] ) ^ ord ( $ b [ $ i ] ) ; } return $ result === 0 ; }
5501	protected function checkArgumentsIsArray ( $ args , $ task ) { if ( ! is_array ( $ args ) ) { $ errormsg = sprintf ( 'Cannot %s. Parameter %s is not an array.' , $ task , $ args ) ; trigger_error ( $ errormsg , E_USER_ERROR ) ; } }
3255	public function scopeWhereUser ( $ query , $ userId ) { return $ query -> join ( Config :: get ( 'shop.order_table' ) , Config :: get ( 'shop.order_table' ) . '.id' , '=' , Config :: get ( 'shop.transaction_table' ) . '.order_id' ) -> where ( Config :: get ( 'shop.order_table' ) . '.user_id' , $ userId ) ; }
11027	protected function city ( ) { $ pluginOptions = [ 'url' => Url :: to ( [ "/{$this->module->id}/city/list" ] ) , 'depends' => [ $ this -> fieldIds [ 'country' ] ] ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'state' ] ; $ pluginOptions [ 'initDepends' ] = [ $ this -> fieldIds [ 'country' ] ] ; } else { $ pluginOptions [ 'depends' ] [ ] = null ; } if ( isset ( $ this -> fieldIds [ 'region' ] ) ) { $ pluginOptions [ 'depends' ] [ ] = $ this -> fieldIds [ 'region' ] ; if ( isset ( $ this -> fieldIds [ 'state' ] ) ) { $ pluginOptions [ 'initDepends' ] [ ] = $ this -> fieldIds [ 'state' ] ; } } else { $ pluginOptions [ 'depends' ] [ ] = null ; } $ this -> parts [ '{city}' ] = $ this -> form -> field ( $ this -> model , $ this -> model -> getCityPropertyName ( ) ) -> widget ( DepDrop :: className ( ) , [ 'options' => [ 'id' => $ this -> fieldIds [ 'city' ] , 'cityholder' => Yii :: t ( 'jlorente/location' , 'Select city' ) , 'name' => $ this -> getSubmitModelName ( $ this -> model -> getCityPropertyName ( ) ) ] , 'data' => ArrayHelper :: map ( City :: find ( ) -> where ( [ 'region_id' => $ this -> model -> region_id ] ) -> orderBy ( [ 'name' => SORT_ASC ] ) -> all ( ) , 'id' , 'name' ) , 'pluginOptions' => $ pluginOptions ] ) ; }
8720	protected function initTranslatableAttributes ( ) { if ( property_exists ( $ this , 'translatable' ) ) { $ attributes = $ this -> translatable ; } else { $ attributes = $ this -> getTranslatableAttributesFromSchema ( ) ; } static :: $ i18nAttributes [ $ this -> getTable ( ) ] = $ attributes ; }
3136	public function setItemState ( RunnerServiceContext $ context , $ itemRef , $ state ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ serviceService = $ this -> getServiceManager ( ) -> get ( StorageManager :: SERVICE_ID ) ; $ userUri = \ common_session_SessionManager :: getSession ( ) -> getUserUri ( ) ; $ stateId = $ this -> getStateId ( $ context , $ itemRef ) ; if ( ! isset ( $ state ) ) { $ state = '' ; } return is_null ( $ userUri ) ? false : $ serviceService -> set ( $ userUri , $ stateId , json_encode ( $ state ) ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'setItemState' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
8217	public static function getRefererQueryParam ( $ url , $ key ) { if ( ! $ url ) { return null ; } $ query = [ ] ; parse_str ( parse_url ( $ url , PHP_URL_QUERY ) , $ query ) ; if ( isset ( $ query [ $ key ] ) ) { return $ query [ $ key ] ; } return null ; }
10151	private function readFooter ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { if ( $ recordData ) { if ( $ this -> version == self :: XLS_BIFF8 ) { $ string = self :: readUnicodeStringLong ( $ recordData ) ; } else { $ string = $ this -> readByteStringShort ( $ recordData ) ; } $ this -> phpSheet -> getHeaderFooter ( ) -> setOddFooter ( $ string [ 'value' ] ) ; $ this -> phpSheet -> getHeaderFooter ( ) -> setEvenFooter ( $ string [ 'value' ] ) ; } } }
3811	protected function transformCondition ( $ condition ) { $ dispatcher = $ GLOBALS [ 'container' ] [ 'event-dispatcher' ] ; $ event = new CreatePropertyConditionEvent ( $ condition , $ this -> getMetaModel ( ) ) ; $ dispatcher -> dispatch ( CreatePropertyConditionEvent :: NAME , $ event ) ; if ( $ event -> getInstance ( ) === null ) { throw new \ RuntimeException ( sprintf ( 'Condition of type %s could not be transformed to an instance.' , $ condition [ 'type' ] ) ) ; } return $ event -> getInstance ( ) ; }
7231	public function loadResult ( array $ result ) { $ changed = false ; foreach ( [ 'revenue' , 'shipping' , 'margin' , 'orders' , 'items' , 'average' , 'details' ] as $ property ) { if ( $ this -> { $ property } != $ result [ $ property ] ) { $ this -> { $ property } = $ result [ $ property ] ; $ changed = true ; } } return $ changed ; }
712	public function integer ( $ length = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_INTEGER , $ length ) ; }
11798	public function setHtml ( $ html = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } $ this -> html .= Helper :: formatText ( $ html , 'ascii' ) ; return $ this ; }
9890	public static function xml ( $ response ) { $ body = self :: toString ( $ response ) ; $ errorMessage = null ; $ internalErrors = libxml_use_internal_errors ( true ) ; $ disableEntities = libxml_disable_entity_loader ( true ) ; libxml_clear_errors ( ) ; $ xml = null ; try { $ xml = new \ SimpleXMLElement ( ( string ) $ body ? : '<root />' , LIBXML_NONET ) ; } catch ( \ Exception $ e ) { $ errorMessage = $ e -> getMessage ( ) ; } libxml_clear_errors ( ) ; libxml_use_internal_errors ( $ internalErrors ) ; libxml_disable_entity_loader ( $ disableEntities ) ; if ( $ errorMessage !== null ) { throw new RuntimeException ( 'Unable to parse response body into XML: ' . $ errorMessage ) ; } return $ xml ; }
10597	protected function getRouteLocalizedRecord ( \ MvcCore \ IRoute & $ route , $ getter ) { $ result = $ route -> $ getter ( $ this -> requestLang ) ; if ( $ result === NULL && $ this -> defaultLang !== NULL ) $ result = $ route -> $ getter ( $ this -> defaultLang ) ; return $ result ; }
7275	protected function encodeValue ( $ column ) { $ val = in_array ( $ column , static :: $ jsons ) ? to_json ( $ this -> $ column ) : $ this -> $ column ; if ( isset ( static :: $ casts [ $ column ] ) && ( static :: $ casts [ $ column ] === "object" || static :: $ casts [ $ column ] === "array" ) ) $ val = to_json ( $ this -> $ column ) ; if ( is_bool ( $ val ) ) $ val = ( int ) $ val ; return $ val ; }
10133	public function insertBitmap ( $ row , $ col , $ bitmap , $ x = 0 , $ y = 0 , $ scale_x = 1 , $ scale_y = 1 ) { $ bitmap_array = ( is_resource ( $ bitmap ) ? $ this -> processBitmapGd ( $ bitmap ) : $ this -> processBitmap ( $ bitmap ) ) ; list ( $ width , $ height , $ size , $ data ) = $ bitmap_array ; $ width *= $ scale_x ; $ height *= $ scale_y ; $ this -> positionImage ( $ col , $ row , $ x , $ y , $ width , $ height ) ; $ record = 0x007f ; $ length = 8 + $ size ; $ cf = 0x09 ; $ env = 0x01 ; $ lcb = $ size ; $ header = pack ( 'vvvvV' , $ record , $ length , $ cf , $ env , $ lcb ) ; $ this -> append ( $ header . $ data ) ; }
12451	static function run_check_php_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ files = pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) ; if ( count ( $ files ) ) { $ php = self :: getTool ( 'php' , $ opts ) ; if ( strpos ( pake_sh ( $ php . " -v" ) , 'PHP' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$php does not seem to be a valid php executable" ) ; } foreach ( pakeFinder :: type ( 'file' ) -> name ( array ( '*.php' ) ) -> in ( $ destdir ) as $ file ) { if ( strpos ( pake_sh ( $ php . " -l " . escapeshellarg ( $ file ) ) , 'No syntax errors detected' ) === false ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "$file does not seem to be a valid php file" ) ; } } } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
6935	protected function formatMessage ( $ message , $ format = [ Console :: FG_RED , Console :: BOLD ] ) { $ stream = ( PHP_SAPI === 'cli' ) ? \ STDERR : \ STDOUT ; if ( Console :: stream_supports_ansi_colors ( $ stream ) ) { $ message = Console :: ansi_format ( $ message , $ format ) ; } return $ message ; }
5979	public function propertysets ( ) { if ( ! $ this -> propertysets instanceof PropertysetsController ) { $ this -> propertysets = new PropertysetsController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> propertysets -> setLogger ( $ this -> logger ) ; } return $ this -> propertysets ; }
3722	public function handleUpdate ( PostPersistModelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ old = $ event -> getOriginalModel ( ) ; $ new = $ event -> getModel ( ) ; $ oldTable = $ old ? $ old -> getProperty ( 'tableName' ) : null ; $ newTable = $ new -> getProperty ( 'tableName' ) ; if ( $ oldTable !== $ newTable ) { if ( ! empty ( $ oldTable ) ) { $ this -> tableManipulator -> renameTable ( $ oldTable , $ newTable ) ; } else { $ this -> tableManipulator -> createTable ( $ newTable ) ; } } $ this -> tableManipulator -> setVariantSupport ( $ newTable , $ new -> getProperty ( 'varsupport' ) ) ; }
11538	public function setItems ( $ items ) { $ this -> _items = $ items ; if ( isset ( $ this -> _items [ 0 ] ) && is_array ( $ this -> _items [ 0 ] ) ) { $ this -> _items = $ this -> _items [ 0 ] ; } foreach ( $ this -> _items as $ item ) { $ item -> owner = $ this ; if ( ! $ item -> isValid ) { $ this -> isValid = false ; } } }
3966	public function getInputScreen ( ) { return new InputScreen ( \ System :: getContainer ( ) -> get ( 'cca.legacy_dic' ) -> getService ( 'metamodels-service-container' ) , $ this -> inputScreen [ 'meta' ] , $ this -> inputScreen [ 'properties' ] , $ this -> inputScreen [ 'conditions' ] , $ this -> inputScreen [ 'groupSort' ] ) ; }
1933	protected function getLocaleString ( ) { $ container = System :: getContainer ( ) ; return 'var Contao={' . 'theme:"' . Backend :: getTheme ( ) . '",' . 'lang:{' . 'close:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'close' ] . '",' . 'collapse:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'collapseNode' ] . '",' . 'expand:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'expandNode' ] . '",' . 'loading:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'loadingData' ] . '",' . 'apply:"' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'apply' ] . '"' . '},' . 'script_url:"' . $ container -> get ( 'contao.assets.assets_context' ) -> getStaticUrl ( ) . '",' . 'path:"' . Environment :: get ( 'path' ) . '",' . 'request_token:"' . REQUEST_TOKEN . '",' . 'referer_id:"' . $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) -> attributes -> get ( '_contao_referer_id' ) . '"' . '};' ; }
10996	public function prepend ( string $ contents , int $ maxMemory = 8096 ) : bool { $ test = \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ; if ( $ this -> test ( $ test ) === false ) { $ this -> error = "failed to prepend file; {$this->error}" ; return false ; } $ len = strlen ( $ contents ) ; $ size = filesize ( $ this -> path ) ; $ endsize = $ len + $ size ; if ( $ endsize > $ maxMemory ) { return $ this -> prependFileInPlace ( $ contents , $ len , $ endsize ) ; } if ( ( $ tmp = $ this -> readFile ( 0 ) ) === false ) { return false ; } if ( $ this -> writeFile ( $ contents . $ tmp , 0 ) === false ) { return false ; } return true ; }
5516	public function errorOn ( $ method , $ error = 'A mock error' , $ args = false , $ severity = E_USER_ERROR ) { $ this -> dieOnNoMethod ( $ method , 'error on' ) ; $ this -> actions -> register ( $ method , $ args , new SimpleErrorThrower ( $ error , $ severity ) ) ; }
10961	protected function restoreResponse ( $ response , $ data ) { if ( isset ( $ data [ 'format' ] ) ) { $ response -> format = $ data [ 'format' ] ; } if ( isset ( $ data [ 'version' ] ) ) { $ response -> version = $ data [ 'version' ] ; } if ( isset ( $ data [ 'statusCode' ] ) ) { $ response -> statusCode = $ data [ 'statusCode' ] ; } if ( isset ( $ data [ 'statusText' ] ) ) { $ response -> statusText = $ data [ 'statusText' ] ; } if ( isset ( $ data [ 'headers' ] ) && is_array ( $ data [ 'headers' ] ) ) { $ headers = $ response -> getHeaders ( ) -> toArray ( ) ; $ response -> getHeaders ( ) -> fromArray ( array_merge ( $ data [ 'headers' ] , $ headers ) ) ; } if ( isset ( $ data [ 'cookies' ] ) && is_array ( $ data [ 'cookies' ] ) ) { $ cookies = $ response -> getCookies ( ) -> toArray ( ) ; $ response -> getCookies ( ) -> fromArray ( array_merge ( $ data [ 'cookies' ] , $ cookies ) ) ; } }
7310	public static function solsticeSummer ( $ year ) { $ jd = static :: solsticeJune ( ( int ) $ year , false ) ; return AstroDate :: jd ( $ jd , TimeScale :: TT ( ) ) ; }
4874	public function setFormId ( $ formId ) { $ this -> formId = $ formId . '-' ; foreach ( $ this as $ button ) { $ button -> setAttribute ( 'id' , $ this -> formId . $ button -> getAttribute ( 'id' ) ) ; } return $ this ; }
12785	protected function generateIntersection ( $ combinationMask ) { $ combination = [ ] ; foreach ( str_split ( $ combinationMask ) as $ key => $ indicator ) { if ( $ indicator ) { $ combination [ ] = $ this -> arrays [ $ this -> arrayKeys [ $ key ] ] ; } } $ intersection = call_user_func_array ( 'array_intersect_assoc' , $ combination ) ; if ( count ( $ intersection ) >= $ this -> threshold ) { $ this -> intersections [ ] = $ intersection ; return ; } $ this -> noResultMasks [ ] = $ combinationMask ; }
11221	private static function routeValidator ( ) { self :: $ uri = Url :: getUriMethods ( ) ; self :: $ uri = Url :: setUrlParams ( self :: $ uri ) ; self :: $ uri = Url :: addBackSlash ( self :: $ uri ) ; self :: cleanResources ( ) ; if ( self :: getMethod ( self :: $ uri ) ) { self :: any ( self :: $ uri , self :: $ routes [ self :: $ uri ] ) ; } }
5235	public function withEntryFromProvider ( $ key , $ provider ) { $ this -> bindings [ $ key ] = $ this -> getProviderCreator ( $ provider ) ; return $ this ; }
9873	private function writeDrawings ( XMLWriter $ objWriter = null , PhpspreadsheetWorksheet $ pSheet = null , $ includeCharts = false ) { $ chartCount = ( $ includeCharts ) ? $ pSheet -> getChartCollection ( ) -> count ( ) : 0 ; if ( ( $ pSheet -> getDrawingCollection ( ) -> count ( ) > 0 ) || ( $ chartCount > 0 ) ) { $ objWriter -> startElement ( 'drawing' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId1' ) ; $ objWriter -> endElement ( ) ; } }
5207	public function areActiveURLs ( array $ urls , $ output = "active" ) { foreach ( $ urls as $ url ) { if ( $ this -> isActiveURL ( $ url , true ) ) { return $ output ; } } return null ; }
743	private function initializeEventHandlers ( ) { $ this -> owner -> on ( Widget :: EVENT_BEFORE_RUN , [ $ this , 'beforeRun' ] ) ; $ this -> owner -> on ( Widget :: EVENT_AFTER_RUN , [ $ this , 'afterRun' ] ) ; }
11355	public function getValue ( $ name = null ) { if ( $ this -> has ( $ name ) ) { return $ this -> get ( $ name ) -> getValue ( ) ; } return parent :: getValue ( ) ; }
6125	public function setRoles ( array $ roles ) { $ this -> roles = [ ] ; foreach ( $ roles as $ item ) { $ this -> addRole ( $ item ) ; } return $ this ; }
9367	public function equal ( $ z ) { if ( is_numeric ( $ z ) ) { $ z = new self ( $ z , 0 ) ; } return ( $ z -> real == $ this -> float_r ) && ( $ z -> imaginary == $ this -> float_i ) ; }
11817	protected function step4 ( ) { $ this -> view -> addToBlock ( "form" , "import://admin/setup/user" ) ; $ this -> view -> setData ( "step" , "4" ) ; $ this -> view -> setData ( "title" , t ( "Installation | Install SuperUser" ) ) ; if ( $ this -> application -> input -> methodIs ( "post" ) ) { $ install = new Helpers \ Install ( $ this -> application -> config , $ this -> application -> encrypt ) ; if ( ! $ install -> database ( $ this -> application ) ) { $ this -> application -> dispatcher -> redirect ( "/admin/setup/install/3" ) ; } $ this -> response -> addAlert ( "Wohooo! The database was successfully configure. Now please create a super user." , "info" ) ; } return ; }
853	public function getNonEmptySibling ( $ index , $ direction ) { while ( true ) { $ index += $ direction ; if ( ! $ this -> offsetExists ( $ index ) ) { return null ; } if ( ! $ this -> isEmptyAt ( $ index ) ) { return $ index ; } } }
10492	public function sub ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value - $ value ) ; }
8283	protected function resolveRealUrl ( $ fileName ) { $ fileNameClean = str_replace ( "\0" , '' , $ fileName ) ; $ realPath = realpath ( $ fileNameClean ) ; if ( $ realPath === false ) { return $ this -> requestUrl ; } $ contentPath = realpath ( $ this -> pico -> getConfig ( 'content_dir' ) ) ; $ contentExt = $ this -> pico -> getConfig ( 'content_ext' ) ; if ( strpos ( $ realPath , $ contentPath ) !== 0 ) { throw new \ RuntimeException ( "The plugin cannot be used with " . "symbolic links inside the content directory." ) ; } $ name = substr ( $ realPath , strlen ( $ contentPath ) + 1 , - strlen ( $ contentExt ) ) ; if ( DIRECTORY_SEPARATOR !== '/' ) { $ name = str_replace ( DIRECTORY_SEPARATOR , '/' , $ name ) ; } if ( strlen ( $ name ) >= 5 && 0 === substr_compare ( $ name , "index" , - 5 ) ) { $ name = rtrim ( substr ( $ name , 0 , - 5 ) , '/' ) ; } return $ name ; }
6227	public function removeOnFree ( bool $ activate = true ) : self { $ this -> storage -> removeOnFree ( $ activate ) ; return $ this ; }
2061	public function generateAlias ( $ varValue , Contao \ DataContainer $ dc ) { $ objPage = Contao \ PageModel :: findWithDetails ( $ dc -> id ) ; $ aliasExists = function ( string $ alias ) use ( $ dc , $ objPage ) : bool { $ objAliasIds = $ this -> Database -> prepare ( "SELECT id FROM tl_page WHERE alias=? AND id!=?" ) -> execute ( $ alias , $ dc -> id ) ; if ( ! $ objAliasIds -> numRows ) { return false ; } $ strCurrentDomain = $ objPage -> domain ; $ strCurrentLanguage = $ objPage -> rootLanguage ; if ( $ objPage -> type == 'root' ) { $ strCurrentDomain = Contao \ Input :: post ( 'dns' ) ; $ strCurrentLanguage = Contao \ Input :: post ( 'language' ) ; } while ( $ objAliasIds -> next ( ) ) { $ objAliasPage = Contao \ PageModel :: findWithDetails ( $ objAliasIds -> id ) ; if ( $ objAliasPage -> domain != $ strCurrentDomain ) { continue ; } if ( Contao \ Config :: get ( 'addLanguageToUrl' ) && $ objAliasPage -> rootLanguage != $ strCurrentLanguage ) { continue ; } return true ; } return false ; } ; if ( $ varValue == '' ) { $ varValue = Contao \ System :: getContainer ( ) -> get ( 'contao.slug' ) -> generate ( $ dc -> activeRecord -> title , $ dc -> activeRecord -> id , function ( $ alias ) use ( $ objPage , $ aliasExists ) { return $ aliasExists ( ( Contao \ Config :: get ( 'folderUrl' ) ? $ objPage -> folderUrl : '' ) . $ alias ) ; } ) ; if ( Contao \ Config :: get ( 'folderUrl' ) && $ objPage -> folderUrl != '' ) { $ varValue = $ objPage -> folderUrl . $ varValue ; } } elseif ( $ aliasExists ( $ varValue ) ) { throw new Exception ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'aliasExists' ] , $ varValue ) ) ; } return $ varValue ; }
760	public function getIsCollection ( ) { return in_array ( $ this -> type , [ self :: TYPE_CODE , self :: TYPE_STATEMENT , self :: TYPE_PARENTHESIS , ] , true ) ; }
7689	function OpenXML_CTypesPrepareExt ( $ FileOrExt , $ ct = '' ) { $ ext = $ this -> Misc_FileExt ( $ FileOrExt ) ; $ this -> OpenXML_CTypesInit ( ) ; $ lst = & $ this -> OpenXmlCTypes [ 'Extension' ] ; if ( isset ( $ lst [ $ ext ] ) && ( $ lst [ $ ext ] !== '' ) ) return ; if ( ( $ ct === '' ) && isset ( $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ) ) $ ct = 'image/' . $ this -> ExtInfo [ 'pic_ext' ] [ $ ext ] ; $ lst [ $ ext ] = $ ct ; }
2965	public function buildRequest ( $ method , $ path , array $ params = [ ] ) { $ body = ArrayUtils :: get ( $ params , 'body' , null ) ; $ query = ArrayUtils :: get ( $ params , 'query' , null ) ; $ options = [ ] ; if ( in_array ( $ method , [ 'POST' , 'PUT' , 'PATCH' ] ) && $ body ) { $ options [ 'body' ] = $ body ; } if ( $ query ) { $ options [ 'query' ] = $ query ; } return $ this -> createRequest ( $ method , $ path , $ options ) ; }
317	public function registerAssetBundle ( $ name , $ position = null ) { if ( ! isset ( $ this -> assetBundles [ $ name ] ) ) { $ am = $ this -> getAssetManager ( ) ; $ bundle = $ am -> getBundle ( $ name ) ; $ this -> assetBundles [ $ name ] = false ; $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } $ this -> assetBundles [ $ name ] = $ bundle ; } elseif ( $ this -> assetBundles [ $ name ] === false ) { throw new InvalidConfigException ( "A circular dependency is detected for bundle '$name'." ) ; } else { $ bundle = $ this -> assetBundles [ $ name ] ; } if ( $ position !== null ) { $ pos = isset ( $ bundle -> jsOptions [ 'position' ] ) ? $ bundle -> jsOptions [ 'position' ] : null ; if ( $ pos === null ) { $ bundle -> jsOptions [ 'position' ] = $ pos = $ position ; } elseif ( $ pos > $ position ) { throw new InvalidConfigException ( "An asset bundle that depends on '$name' has a higher javascript file position configured than '$name'." ) ; } foreach ( $ bundle -> depends as $ dep ) { $ this -> registerAssetBundle ( $ dep , $ pos ) ; } } return $ bundle ; }
1493	public function index ( $ resourceType , $ meta = null , array $ queryParams = [ ] ) { return $ this -> factory -> createLink ( $ this -> urls -> index ( $ resourceType , $ queryParams ) , $ meta , true ) ; }
3623	public function temperatureInCelsius ( $ temperature , $ serial_number = NULL ) { $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ temp_scale = $ this -> getDeviceTemperatureScale ( $ serial_number ) ; if ( $ temp_scale == 'F' ) { return ( $ temperature - 32 ) / 1.8 ; } return $ temperature ; }
430	public function getBasePath ( ) { if ( $ this -> _basePath === null ) { $ class = new \ ReflectionClass ( $ this ) ; $ this -> _basePath = dirname ( $ class -> getFileName ( ) ) ; } return $ this -> _basePath ; }
4180	protected function notifyUser ( ) { $ this -> console -> line ( '' ) ; $ this -> console -> line ( "{$this->isDone($this->getProviders()->isRegistered())} " . "{$this->getProviders()->count()} service provider registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getFacades()->isRegistered())} " . "{$this->getFacades()->count()} facade registered." ) ; $ this -> console -> line ( "{$this->isDone($this->getMigration()->isRegistered())} " . "{$this->getMigration()->count()} migration file ran." ) ; $ this -> console -> line ( "{$this->isDone($this->getResources()->isRegistered())} " . '- ' . $ this -> console -> tokenizePackageInfo ( ) [ 'name' ] . ' file publish.' ) ; return true ; }
7539	function isParent ( $ tag , $ recursive = false ) { return ( $ this -> hasParent ( $ tag , $ recursive ) === ( $ tag !== null ) ) ; }
5228	public static function createInjector ( callable ... $ applyBindings ) { $ self = new self ( ) ; foreach ( $ applyBindings as $ applyBinding ) { $ applyBinding ( $ self ) ; } return $ self -> getInjector ( ) ; }
2845	public function getRequestPath ( ) { $ requestPath = '' ; $ server = $ this -> getGlobalServer ( ) ; if ( array_key_exists ( 'REQUEST_URI' , $ server ) ) { $ requestPath = parse_url ( $ server [ 'REQUEST_URI' ] , PHP_URL_PATH ) ; } return $ requestPath ; }
5141	public function run ( ) : void { $ request = $ request = ServerRequestFactory :: fromGlobals ( ) ; $ response = $ this -> process ( $ request ) ; $ emitter = $ this -> getContainer ( ) -> has ( EmitterInterface :: class ) ? $ this -> getContainer ( ) -> get ( EmitterInterface :: class ) : new SapiEmitter ( ) ; $ emitter -> emit ( $ response ) ; }
3106	public function getEvents ( ) { if ( isset ( $ this -> state [ self :: VAR_EVENTS_QUEUE ] ) ) { $ events = $ this -> state [ self :: VAR_EVENTS_QUEUE ] ; } else { $ events = [ ] ; } return $ events ; }
624	public function findWith ( $ with , & $ models ) { $ primaryModel = reset ( $ models ) ; if ( ! $ primaryModel instanceof ActiveRecordInterface ) { $ modelClass = $ this -> modelClass ; $ primaryModel = $ modelClass :: instance ( ) ; } $ relations = $ this -> normalizeRelations ( $ primaryModel , $ with ) ; foreach ( $ relations as $ name => $ relation ) { if ( $ relation -> asArray === null ) { $ relation -> asArray ( $ this -> asArray ) ; } $ relation -> populateRelation ( $ name , $ models ) ; } }
6864	protected function updateTotals ( InvoiceInterface $ invoice ) { $ changed = $ this -> invoiceCalculator -> calculate ( $ invoice ) ; if ( $ changed ) { foreach ( $ invoice -> getLines ( ) as $ line ) { $ this -> persistenceHelper -> persistAndRecompute ( $ line , false ) ; } } return $ changed ; }
7274	protected function decodeValue ( $ val , $ column = "" ) { if ( $ column === static :: $ idColumn ) $ val = ( int ) $ val ; else if ( isset ( static :: $ casts [ $ column ] ) ) { switch ( static :: $ casts [ $ column ] ) { case "object" : $ val = from_json ( $ val , false ) ; break ; case "array" : $ val = from_json ( $ val , true ) ; break ; default : settype ( $ val , static :: $ casts [ $ column ] ) ; } } else if ( in_array ( $ column , static :: $ jsons ) && is_string ( $ val ) ) $ val = from_json ( $ val ) ; return $ val ; }
8150	public function initRuntime ( ) { $ this -> runtimeInitialized = true ; foreach ( $ this -> getExtensions ( ) as $ name => $ extension ) { if ( ! $ extension instanceof Twig_Extension_InitRuntimeInterface ) { $ m = new ReflectionMethod ( $ extension , 'initRuntime' ) ; if ( 'Twig_Extension' !== $ m -> getDeclaringClass ( ) -> getName ( ) ) { @ trigger_error ( sprintf ( 'Defining the initRuntime() method in the "%s" extension is deprecated since version 1.23. Use the `needs_environment` option to get the Twig_Environment instance in filters, functions, or tests; or explicitly implement Twig_Extension_InitRuntimeInterface if needed (not recommended).' , $ name ) , E_USER_DEPRECATED ) ; } } $ extension -> initRuntime ( $ this ) ; } }
5815	public function onBeforeWrite ( ) { parent :: onBeforeWrite ( ) ; $ types = $ this -> Types ? explode ( ',' , $ this -> Types ) : array ( ) ; if ( is_string ( $ this -> TagTypes ) ) { $ types = array_merge ( $ types , array_keys ( unserialize ( $ this -> TagTypes ) ) ) ; } if ( ! empty ( $ types ) ) { sort ( $ types ) ; $ formatted = array ( ) ; $ existing = $ this -> service -> getFusionTagTypes ( ) ; foreach ( $ types as $ type ) { if ( isset ( $ existing [ $ type ] ) ) { $ formatted [ $ type ] = $ type ; } } $ this -> TagTypes = ! empty ( $ formatted ) ? serialize ( $ formatted ) : null ; $ this -> Types = implode ( ',' , $ formatted ) ; } }
12264	public function addSource ( $ sourcePath , $ useStrict = true ) { if ( is_link ( $ sourcePath ) ) { return $ this -> addSource ( realpath ( $ sourcePath ) , $ useStrict ) ; } if ( is_dir ( $ sourcePath ) ) { $ this -> sourceDirs [ ] = $ sourcePath ; } elseif ( true === $ useStrict ) { throw new \ Exception ( sprintf ( 'Path {%s} is not a readable directory' , $ sourcePath ) ) ; } return $ this ; }
10491	public function add ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value + $ value ) ; }
9861	private function writeDimension ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'dimension' ) ; $ objWriter -> writeAttribute ( 'ref' , $ pSheet -> calculateWorksheetDimension ( ) ) ; $ objWriter -> endElement ( ) ; }
10984	public static function getHostId ( ) { if ( self :: isWindows ( ) ) { $ uuid = explode ( "\r\n" , trim ( shell_exec ( 'wmic csproduct get UUID' ) ) ) ; return ( \ count ( $ uuid ) === 2 ? $ uuid [ 1 ] : false ) ; } $ uuid = trim ( shell_exec ( 'hostid' ) ) ; return $ uuid === null ? false : $ uuid ; }
8787	public function script ( $ url , $ attributes = [ ] , $ secure = null ) { $ attributes [ 'src' ] = $ this -> uri -> assets ( $ url , $ secure ) ; return $ this -> toHtmlString ( '<script' . $ this -> attributes ( $ attributes ) . '></script>' . PHP_EOL ) ; }
7645	protected function getStorageClient ( $ path = '' ) { if ( is_null ( $ this -> storageClient ) ) { $ url = explode ( ':' , $ path ) ; if ( ! $ url ) { throw new BlobException ( 'Could not parse path "' . $ path . '".' ) ; } $ this -> storageClient = BlobClient :: getWrapperClient ( $ url [ 0 ] ) ; if ( ! $ this -> storageClient ) { throw new BlobException ( 'No storage client registered for stream type "' . $ url [ 0 ] . '://".' ) ; } } return $ this -> storageClient ; }
9059	public function addUnique ( string ... $ name ) : self { $ key = new Index ( ... $ name ) ; $ key -> setUnique ( ) ; $ this -> keys [ $ key -> name ] = $ key ; return $ this ; }
7028	static function getDefaultImplementations ( ) { return [ Cart \ Model \ CartInterface :: class => Cart \ Entity \ Cart :: class , Cart \ Model \ CartAddressInterface :: class => Cart \ Entity \ CartAddress :: class , Customer \ Model \ CustomerInterface :: class => Customer \ Entity \ Customer :: class , Customer \ Model \ CustomerGroupInterface :: class => Customer \ Entity \ CustomerGroup :: class , Customer \ Model \ CustomerAddressInterface :: class => Customer \ Entity \ CustomerAddress :: class , Order \ Model \ OrderInterface :: class => Order \ Entity \ Order :: class , Order \ Model \ OrderAddressInterface :: class => Order \ Entity \ OrderAddress :: class , Payment \ Model \ PaymentMethodInterface :: class => Payment \ Entity \ PaymentMethod :: class , Payment \ Model \ PaymentTermInterface :: class => Payment \ Entity \ PaymentTerm :: class , Quote \ Model \ QuoteInterface :: class => Quote \ Entity \ Quote :: class , Quote \ Model \ QuoteAddressInterface :: class => Quote \ Entity \ QuoteAddress :: class , Shipment \ Model \ ShipmentMethodInterface :: class => Shipment \ Entity \ ShipmentMethod :: class , Supplier \ Model \ SupplierInterface :: class => Supplier \ Entity \ Supplier :: class , Supplier \ Model \ SupplierAddressInterface :: class => Supplier \ Entity \ SupplierAddress :: class , Supplier \ Model \ SupplierDeliveryInterface :: class => Supplier \ Entity \ SupplierDelivery :: class , Supplier \ Model \ SupplierOrderInterface :: class => Supplier \ Entity \ SupplierOrder :: class , Supplier \ Model \ SupplierProductInterface :: class => Supplier \ Entity \ SupplierProduct :: class , Support \ Model \ TicketInterface :: class => Support \ Entity \ Ticket :: class , Support \ Model \ TicketMessageInterface :: class => Support \ Entity \ TicketMessage :: class , ] ; }
9093	public function getPagePartial ( $ page ) { if ( isset ( $ this -> pagePartials [ $ page ] ) ) { return $ this -> pagePartials [ $ page ] ; } return null ; }
9775	function startWith ( string $ value ) : self { return $ this -> expect ( $ this -> target , stringStartsWith ( $ value ) ) ; }
10418	public static function extract ( $ yamlArray , $ key , $ needed = false ) { if ( ! empty ( $ yamlArray ) && array_key_exists ( $ key , $ yamlArray ) ) return $ yamlArray [ $ key ] ; if ( $ needed ) { throw new \ Deployer \ Exception \ Exception ( 'Cannot find the setting: ' . $ key . '. This key needs to be given!' ) ; } return null ; }
9670	private function writeBorder ( XMLWriter $ objWriter , Borders $ pBorders ) { $ objWriter -> startElement ( 'border' ) ; switch ( $ pBorders -> getDiagonalDirection ( ) ) { case Borders :: DIAGONAL_UP : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'false' ) ; break ; case Borders :: DIAGONAL_DOWN : $ objWriter -> writeAttribute ( 'diagonalUp' , 'false' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; case Borders :: DIAGONAL_BOTH : $ objWriter -> writeAttribute ( 'diagonalUp' , 'true' ) ; $ objWriter -> writeAttribute ( 'diagonalDown' , 'true' ) ; break ; } $ this -> writeBorderPr ( $ objWriter , 'left' , $ pBorders -> getLeft ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'right' , $ pBorders -> getRight ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'top' , $ pBorders -> getTop ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'bottom' , $ pBorders -> getBottom ( ) ) ; $ this -> writeBorderPr ( $ objWriter , 'diagonal' , $ pBorders -> getDiagonal ( ) ) ; $ objWriter -> endElement ( ) ; }
4150	protected function getBinaryFile ( $ filename ) { if ( ! file_exists ( $ filename ) ) { throw new FileNotFoundException ; } if ( ! is_readable ( $ filename ) ) { throw new FileNotReadableException ; } ob_start ( ) ; readfile ( $ filename ) ; $ binary = ob_get_contents ( ) ; ob_end_clean ( ) ; unset ( $ filename ) ; return $ binary ; }
4095	protected function call ( $ url , $ method = "GET" , $ payload = null ) { $ conn = $ this -> ch ; $ protocol = "http" ; $ requestURL = $ protocol . "://" . $ this -> host . $ url ; curl_setopt ( $ conn , CURLOPT_URL , $ requestURL ) ; curl_setopt ( $ conn , CURLOPT_TIMEOUT , $ this -> timeout ) ; curl_setopt ( $ conn , CURLOPT_PORT , $ this -> port ) ; curl_setopt ( $ conn , CURLOPT_CUSTOMREQUEST , strtoupper ( $ method ) ) ; curl_setopt ( $ conn , CURLOPT_FORBID_REUSE , 0 ) ; $ headers = array ( ) ; $ headers [ ] = 'Accept: application/json' ; $ headers [ ] = 'Content-Type: application/json' ; curl_setopt ( $ conn , CURLOPT_HTTPHEADER , $ headers ) ; if ( is_array ( $ payload ) && count ( $ payload ) > 0 ) curl_setopt ( $ conn , CURLOPT_POSTFIELDS , json_encode ( $ payload ) ) ; else curl_setopt ( $ conn , CURLOPT_POSTFIELDS , $ payload ) ; ob_start ( ) ; curl_exec ( $ conn ) ; $ response = ob_get_clean ( ) ; if ( $ response !== false ) { $ data = json_decode ( $ response , true ) ; if ( ! $ data ) { $ data = array ( 'error' => $ response , "code" => curl_getinfo ( $ conn , CURLINFO_HTTP_CODE ) ) ; } } else { $ errno = curl_errno ( $ conn ) ; switch ( $ errno ) { case CURLE_UNSUPPORTED_PROTOCOL : $ error = "Unsupported protocol [$protocol]" ; break ; case CURLE_FAILED_INIT : $ error = "Internal cUrl error?" ; break ; case CURLE_URL_MALFORMAT : $ error = "Malformed URL [$requestURL] -d " . json_encode ( $ payload ) ; break ; case CURLE_COULDNT_RESOLVE_PROXY : $ error = "Couldnt resolve proxy" ; break ; case CURLE_COULDNT_RESOLVE_HOST : $ error = "Couldnt resolve host" ; break ; case CURLE_COULDNT_CONNECT : $ error = "Couldnt connect to host [{$this->host}], ElasticSearch down?" ; break ; case CURLE_OPERATION_TIMEDOUT : $ error = "Operation timed out on [$requestURL]" ; break ; default : $ error = "Unknown error" ; if ( $ errno == 0 ) { $ error .= ". Non-cUrl error" ; } else { $ errstr = curl_error ( $ conn ) ; $ error .= " ($errstr)" ; } break ; } $ exception = new HTTPException ( $ error ) ; $ exception -> payload = $ payload ; $ exception -> port = $ this -> port ; $ exception -> protocol = $ protocol ; $ exception -> host = $ this -> host ; $ exception -> method = $ method ; throw $ exception ; } return $ data ; }
3147	public function check ( RunnerServiceContext $ context ) { $ state = $ context -> getTestSession ( ) -> getState ( ) ; if ( $ state == AssessmentTestSessionState :: CLOSED ) { throw new QtiRunnerClosedException ( ) ; } return true ; }
7956	public function getBillingAccountServices ( ) { $ serviceList = json_decode ( self :: getClient ( ) -> getBillingAccountServices ( $ this -> billingAccount ) ) ; $ services = array ( ) ; foreach ( $ serviceList as $ service ) { $ services [ ] = new TelephonyAccountService ( $ service , $ this ) ; } return $ services ; }
3274	public function set ( string $ key , $ data ) { Validation :: validateKey ( $ key ) ; if ( $ this -> get ( $ key ) !== false ) { $ this -> replace ( $ key , $ data ) ; return ; } $ this -> getDatabase ( ) -> appendToFile ( $ this -> getLineString ( $ key , $ data ) ) ; if ( $ cache = $ this -> getConfig ( ) -> getCache ( ) ) { $ cache -> delete ( $ key ) ; } }
10111	private function writeSheetProtection ( ) { $ record = 0x0867 ; $ options = ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getScenarios ( ) << 1 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatCells ( ) << 2 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatColumns ( ) << 3 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getFormatRows ( ) << 4 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertColumns ( ) << 5 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertRows ( ) << 6 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getInsertHyperlinks ( ) << 7 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteColumns ( ) << 8 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getDeleteRows ( ) << 9 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectLockedCells ( ) << 10 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSort ( ) << 11 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getAutoFilter ( ) << 12 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getPivotTables ( ) << 13 | ( int ) ! $ this -> phpSheet -> getProtection ( ) -> getSelectUnlockedCells ( ) << 14 ; $ recordData = pack ( 'vVVCVVvv' , 0x0867 , 0x0000 , 0x0000 , 0x00 , 0x01000200 , 0xFFFFFFFF , $ options , 0x0000 ) ; $ length = strlen ( $ recordData ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; }
12761	protected function checkBrowsers ( ) { return ( $ this -> checkBrowserWebTv ( ) || $ this -> checkBrowserInternetExplorer ( ) || $ this -> checkBrowserOpera ( ) || $ this -> checkBrowserGaleon ( ) || $ this -> checkBrowserNetscapeNavigator9Plus ( ) || $ this -> checkBrowserFirefox ( ) || $ this -> checkBrowserChrome ( ) || $ this -> checkBrowserOmniWeb ( ) || $ this -> checkBrowserAndroid ( ) || $ this -> checkBrowseriPad ( ) || $ this -> checkBrowseriPod ( ) || $ this -> checkBrowseriPhone ( ) || $ this -> checkBrowserBlackBerry ( ) || $ this -> checkBrowserNokia ( ) || $ this -> checkBrowserGoogleBot ( ) || $ this -> checkBrowserMSNBot ( ) || $ this -> checkBrowserBingBot ( ) || $ this -> checkBrowserSlurp ( ) || $ this -> checkFacebookExternalHit ( ) || $ this -> checkBrowserSafari ( ) || $ this -> checkBrowserNetPositive ( ) || $ this -> checkBrowserFirebird ( ) || $ this -> checkBrowserKonqueror ( ) || $ this -> checkBrowserIcab ( ) || $ this -> checkBrowserPhoenix ( ) || $ this -> checkBrowserAmaya ( ) || $ this -> checkBrowserLynx ( ) || $ this -> checkBrowserShiretoko ( ) || $ this -> checkBrowserIceCat ( ) || $ this -> checkBrowserIceweasel ( ) || $ this -> checkBrowserW3CValidator ( ) || $ this -> checkBrowserMozilla ( ) ) ; }
10654	public function __isset ( $ propertyName ) { $ methodName = 'get' . $ propertyName ; if ( method_exists ( $ this , $ methodName ) ) { return ( $ this -> $ methodName ( ) !== null ) ; } else { return false ; } }
5966	public function permReset ( ) { $ token = $ this -> request ( "permreset" ) -> toList ( ) ; Signal :: getInstance ( ) -> emit ( "notifyTokencreated" , $ this , $ token [ "token" ] ) ; return $ token [ "token" ] ; }
11838	public function set ( $ key , $ value ) { if ( $ this -> cacheEnabled ) { $ this -> cacheEngine -> set ( $ key , $ value ) ; } }
2580	protected function loadWsdl ( $ params ) { if ( isset ( $ params [ 'wsdl' ] ) ) { if ( is_string ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = [ $ params [ 'wsdl' ] ] ; } elseif ( is_array ( $ params [ 'wsdl' ] ) ) { $ this -> wsdl = $ params [ 'wsdl' ] ; } } }
12331	public function get ( $ key ) { if ( ! $ this -> repository -> containsKey ( $ key ) ) throw new ReferenceDoesNotExistException ( ) ; return $ this -> repository -> get ( $ key ) ; }
2264	public function tableExists ( $ strTable , $ strDatabase = null , $ blnNoCache = false ) { if ( $ strTable == '' ) { return false ; } return \ in_array ( $ strTable , $ this -> listTables ( $ strDatabase , $ blnNoCache ) ) ; }
2365	public static function prepareSlug ( $ strSlug ) { $ strSlug = static :: stripInsertTags ( $ strSlug ) ; $ strSlug = static :: restoreBasicEntities ( $ strSlug ) ; $ strSlug = static :: decodeEntities ( $ strSlug ) ; return $ strSlug ; }
6609	public static function getIdByField ( $ field , $ value ) { $ result = self :: find ( ) -> where ( [ $ field => $ value ] ) -> limit ( 1 ) -> one ( ) ; return ( $ result ) ? $ result -> id : null ; }
1242	private static function determineActualValueToAssign ( $ class , $ property , $ value ) { if ( ! array_key_exists ( $ property , self :: $ properties [ $ class ] ) ) { return $ value ; } $ info = self :: propertyInfo ( $ class , $ property ) ; if ( $ info [ 'repeatable' ] && is_array ( $ value ) ) { $ values = [ ] ; foreach ( $ value as $ val ) { $ values [ ] = self :: actualValue ( $ info , $ val ) ; } return $ values ; } return self :: actualValue ( $ info , $ value ) ; }
1789	public function pasteArticle ( Contao \ DataContainer $ dc , $ row , $ table , $ cr , $ arrClipboard = null ) { $ imagePasteAfter = Contao \ Image :: getHtml ( 'pasteafter.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) ; $ imagePasteInto = Contao \ Image :: getHtml ( 'pasteinto.svg' , sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) ; if ( $ table == $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'config' ] [ 'ptable' ] ) { return ( $ row [ 'type' ] == 'root' || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ row ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteinto_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=2&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteinto' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteInto . '</a> ' ; } $ objPage = Contao \ PageModel :: findById ( $ row [ 'pid' ] ) ; return ( ( $ arrClipboard [ 'mode' ] == 'cut' && $ arrClipboard [ 'id' ] == $ row [ 'id' ] ) || ( $ arrClipboard [ 'mode' ] == 'cutAll' && \ in_array ( $ row [ 'id' ] , $ arrClipboard [ 'id' ] ) ) || ! $ this -> User -> isAllowed ( Contao \ BackendUser :: CAN_EDIT_ARTICLE_HIERARCHY , $ objPage -> row ( ) ) || $ cr ) ? Contao \ Image :: getHtml ( 'pasteafter_.svg' ) . ' ' : '<a href="' . $ this -> addToUrl ( 'act=' . $ arrClipboard [ 'mode' ] . '&amp;mode=1&amp;pid=' . $ row [ 'id' ] . ( ! \ is_array ( $ arrClipboard [ 'id' ] ) ? '&amp;id=' . $ arrClipboard [ 'id' ] : '' ) ) . '" title="' . Contao \ StringUtil :: specialchars ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ $ dc -> table ] [ 'pasteafter' ] [ 1 ] , $ row [ 'id' ] ) ) . '" onclick="Backend.getScrollOffset()">' . $ imagePasteAfter . '</a> ' ; }
9502	public function runPeridot ( InputInterface $ input , OutputInterface $ output ) { global $ argv ; $ command = $ this -> joinCommand ( $ argv ) ; $ process = new Process ( $ command ) ; $ process -> run ( function ( $ type , $ buffer ) use ( $ output ) { $ buffer = preg_replace ( '/\[([\d]{1,2})m/' , "\033[$1m" , $ buffer ) ; $ output -> write ( $ buffer ) ; } ) ; }
4080	protected function isInputScreenStandalone ( $ metaModel ) { $ information = $ this -> information [ $ metaModel ] ; $ inputScreen = isset ( $ information [ self :: INPUTSCREEN ] ) ? $ information [ self :: INPUTSCREEN ] : null ; if ( ! is_object ( $ inputScreen ) ) { return ( $ inputScreen [ 'row' ] [ 'rendertype' ] == 'standalone' ) ; } return $ inputScreen -> isStandalone ( ) ; }
5055	protected function getEntityClassName ( $ name ) { $ repositoryName = str_replace ( 'Repository/' , '' , $ name ) ; $ nameParts = explode ( '/' , $ repositoryName ) ; $ namespace = $ nameParts [ 0 ] ; $ entity = isset ( $ nameParts [ 1 ] ) ? $ nameParts [ 1 ] : substr ( $ namespace , 0 , - 1 ) ; $ class = "\\$namespace\\Entity\\$entity" ; return $ class ; }
9588	protected function isAttributeSet ( SimpleXmlElement $ node , $ name ) { $ attributes = $ node -> attributes ( ) ; return isset ( $ attributes [ $ name ] ) ; }
4749	public function getAddonsForPlan ( array $ plans , string $ addonType = null ) : array { $ addonApi = new Addon ( $ this -> token , $ this -> organizationId , $ this -> cache , $ this -> ttl ) ; foreach ( $ plans as & $ plan ) { $ addons = [ ] ; foreach ( $ plan [ 'addons' ] as $ planAddon ) { $ addon = $ addonApi -> getAddon ( $ planAddon [ 'addon_code' ] ) ; if ( null !== $ addonType ) { if ( ( $ addon [ 'type' ] == $ addonType ) && ( in_array ( $ addonType , self :: $ addonTypes ) ) ) { $ addons [ ] = $ addon ; } } else { $ addons [ ] = $ addon ; } } $ plan [ 'addons' ] = $ addons ; } return $ plans ; }
11938	public function findAll ( $ params = [ ] ) { $ return = $ this -> populateRecords ( $ this -> find ( $ params ) -> all ( $ this -> interface -> db ) ) ; return $ return ; }
6254	public function fetchShippingLabels ( $ trackingCodes ) { $ id = str_replace ( '.' , '' , microtime ( true ) ) ; $ xml = new \ SimpleXMLElement ( '<eChannel/>' ) ; $ routing = $ xml -> addChild ( 'ROUTING' ) ; $ routing -> addChild ( 'Routing.Account' , $ this -> api_key ) ; $ routing -> addChild ( 'Routing.Id' , $ id ) ; $ routing -> addChild ( 'Routing.Key' , md5 ( "{$this->api_key}{$id}{$this->secret}" ) ) ; $ label = $ xml -> addChild ( 'PrintLabel' ) ; $ label [ 'responseFormat' ] = 'File' ; foreach ( $ trackingCodes as $ trackingCode ) { $ label -> addChild ( 'TrackingCode' , $ trackingCode ) ; } $ response = $ this -> doPost ( '/prinetti/get-shipping-label' , null , $ xml -> asXML ( ) ) ; $ response_xml = @ simplexml_load_string ( $ response ) ; if ( ! $ response_xml ) { throw new \ Exception ( "Failed to load response xml" ) ; } $ this -> response = $ response_xml ; if ( $ response_xml -> { 'response.status' } != 0 ) { throw new \ Exception ( "Error: {$response_xml->{'response.status'}}, {$response_xml->{'response.message'}}" ) ; } return $ response_xml ; }
1241	private static function encodeValueXml ( $ value ) { if ( $ value instanceof \ DateTime ) { return $ value -> format ( 'Y-m-d\TH:i:s.000\Z' ) ; } elseif ( is_bool ( $ value ) ) { return $ value ? 'true' : 'false' ; } else { return htmlspecialchars ( $ value , ENT_QUOTES , 'UTF-8' , true ) ; } }
6519	private function unFreeze ( ) { $ this -> isFrozen = false ; $ this -> isReplay = null ; foreach ( static :: schema ( ) -> getFields ( ) as $ field ) { if ( $ field -> getType ( ) -> isMessage ( ) ) { $ value = $ this -> get ( $ field -> getName ( ) ) ; if ( empty ( $ value ) ) { continue ; } if ( $ value instanceof Message ) { $ value -> unFreeze ( ) ; continue ; } foreach ( $ value as $ v ) { $ v -> unFreeze ( ) ; } } } }
741	public function beforeRun ( $ event ) { $ cacheKey = $ this -> getCacheKey ( ) ; $ fragmentCacheConfiguration = $ this -> getFragmentCacheConfiguration ( ) ; if ( ! $ this -> owner -> view -> beginCache ( $ cacheKey , $ fragmentCacheConfiguration ) ) { $ event -> isValid = false ; } }
12418	static function run_php_loc_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phploc = self :: getTool ( 'phploc' , $ opts , true ) ; $ out = pake_sh ( "$phploc -n " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phploc.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
9085	public function getAlias ( string $ abstract ) : string { if ( ! isset ( $ this -> aliases [ $ abstract ] ) ) { return $ abstract ; } if ( $ this -> aliases [ $ abstract ] === $ abstract ) { throw new ContainerException ( "[{$abstract}] is aliased to itself." ) ; } return $ this -> getAlias ( $ this -> aliases [ $ abstract ] ) ; }
116	public function executeLocal ( $ command , $ path , $ cwd = null , $ verbose = false ) { return $ this -> executeWithAuthRetry ( $ command , $ cwd , '' , $ path , $ verbose ) ; }
8395	public static function get ( ) : Logger { if ( self :: $ log == null ) { self :: $ log = new Logger ( ) ; } return self :: $ log ; }
6400	public static function init ( ) : void { self :: $ classMap = new CallbackLazyMap ( function ( $ className ) { $ trimmedClassName = trim ( $ className , '\\' ) ; return $ trimmedClassName === $ className ? new ObjectClass ( $ className ) : ObjectClass :: $ classMap -> $ trimmedClassName ; } ) ; }
5202	public function open ( ) { try { $ additionalConnectionOptions = array ( ) ; foreach ( array ( 'connection_timeout' , 'read_write_timeout' , 'keepalive' , 'heartbeat' ) as $ option ) { if ( isset ( $ this -> $ option ) ) { $ additionalConnectionOptions [ $ option ] = $ this -> $ option ; } } $ this -> AMQPConnection = new AMQPSSLConnection ( $ this -> host , $ this -> port , $ this -> username , $ this -> password , $ this -> vhost , $ this -> ssl_context_options , $ additionalConnectionOptions ) ; $ this -> channel = $ this -> AMQPConnection -> channel ( ) ; $ this -> channel -> queue_declare ( $ this -> queue_name , false , false , false , false ) ; $ this -> channel -> exchange_declare ( $ this -> exchange , $ this -> exchange_type , false , true , false ) ; $ this -> channel -> queue_bind ( $ this -> queue_name , $ this -> exchange ) ; } catch ( Exception $ e ) { throw new Exception ( $ e ) ; } }
5232	public function equals ( $ compare ) { if ( $ compare instanceof self ) { return ( get_class ( $ compare ) === get_class ( $ this ) && $ compare -> name ( ) === $ this -> name ) ; } return false ; }
9408	protected function resolve ( $ index ) { $ callback = null ; $ stack = $ this -> stack ; if ( isset ( $ this -> stack [ $ index ] ) ) { $ item = $ stack [ $ index ] ; $ next = $ this -> resolve ( $ index + 1 ) ; $ callback = function ( $ request ) use ( $ item , $ next ) { return $ item -> process ( $ request , $ next ) ; } ; } return new Delegate ( $ callback ) ; }
4408	public function onKernelController ( FilterControllerEvent $ event ) { if ( $ event -> getRequestType ( ) !== HttpKernelInterface :: MASTER_REQUEST ) { return ; } if ( ! $ this -> isAdminSiteAccess ) { return ; } $ currentRoute = $ event -> getRequest ( ) -> attributes -> get ( '_route' ) ; foreach ( $ this -> legacyRoutes as $ legacyRoute ) { if ( stripos ( $ currentRoute , $ legacyRoute ) === 0 ) { $ event -> getRequest ( ) -> attributes -> set ( '_controller' , 'ezpublish_legacy.controller:indexAction' ) ; $ event -> setController ( $ this -> controllerResolver -> getController ( $ event -> getRequest ( ) ) ) ; return ; } } }
2014	public static function addClasses ( $ classes ) { @ trigger_error ( 'Using ClassLoader::addClasses() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; foreach ( $ classes as $ class => $ file ) { self :: addClass ( $ class , $ file ) ; } }
4841	public function fetch_sub_resource ( $ type , $ params = array ( ) ) { $ endpoint = preg_replace ( '/api\/v[0-9]+\//' , '' , parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_PATH ) ) ; $ sub_resource_params = array ( ) ; if ( $ param_string = parse_url ( $ this -> sub_resource_uris [ $ type ] , PHP_URL_QUERY ) ) { $ split_params = explode ( '&' , $ param_string ) ; foreach ( $ split_params as $ split_param ) { $ parts = explode ( '=' , $ split_param ) ; $ sub_resource_params [ $ parts [ 0 ] ] = $ parts [ 1 ] ; } } $ params = array_merge ( $ params , $ sub_resource_params ) ; $ class = 'GoCardless_' . GoCardless_Utils :: camelize ( GoCardless_Utils :: singularize ( $ type ) ) ; $ objects = array ( ) ; foreach ( $ this -> client -> request ( 'get' , $ endpoint , $ params ) as $ value ) { $ objects [ ] = new $ class ( $ this -> client , $ value ) ; } return $ objects ; }
2225	public function onKernelException ( GetResponseForExceptionEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( 'html' !== $ request -> getRequestFormat ( ) ) { return ; } if ( ! AcceptHeader :: fromString ( $ request -> headers -> get ( 'Accept' ) ) -> has ( 'text/html' ) ) { return ; } $ this -> handleException ( $ event ) ; }
9106	public function getPreparedThemeObject ( ) { $ name = $ this -> attainThemeName ( ) ; $ path = $ this -> attainPathName ( ) ; $ return = false ; if ( $ name && $ path ) { $ return = $ this -> getThemeObject ( ) ; $ return -> setName ( $ name ) ; $ return -> setThemesPath ( $ path ) ; } return $ return ; }
1728	public function save ( ) { $ arrFields = $ this -> Database -> getFieldNames ( $ this -> strTable ) ; $ arrSet = array_intersect_key ( $ this -> arrData , array_flip ( $ arrFields ) ) ; $ this -> Database -> prepare ( "UPDATE " . $ this -> strTable . " %s WHERE id=?" ) -> set ( $ arrSet ) -> execute ( $ this -> id ) ; }
5089	public function queryMapRow ( $ key = 0 , $ removeColumnFromRow = false ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) ) throw new MySqlException ( "Key '$key' column not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; if ( $ removeColumnFromRow ) { $ map [ $ row [ $ key ] ] = $ row ; unset ( $ map [ $ row [ $ key ] ] [ $ key ] ) ; } else { $ map [ $ row [ $ key ] ] = $ row ; } } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
8593	public function listOrders ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceOrders_Model_ListOrdersRequest ) ) { $ request = new MarketplaceWebServiceOrders_Model_ListOrdersRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListOrders' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceOrders_Model_ListOrdersResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10483	public static function createSoftBounce ( $ recipientEmailAddress , $ listExternalId , $ recipientExternalId = null , $ ipAddress = '127.0.0.1' ) { if ( $ recipientExternalId == null ) { $ recipientExternalId = rand ( 1 , 99999 ) ; } return ( new Payload ( ) ) -> setIpAddress ( $ ipAddress ) -> setAction ( Type :: SOFT_BOUNCE ) -> setCampaignId ( rand ( 1 , 99999 ) ) -> setListExternalId ( $ listExternalId ) -> setReason ( Type :: REASON_SYSTEM_AUTOMATIC ) -> setRecipientEmailAddress ( $ recipientEmailAddress ) -> setHash ( md5 ( $ recipientEmailAddress ) ) -> setRecipientExternalId ( $ recipientExternalId ) -> setTriggerDate ( new \ DateTime ( ) ) -> setType ( Type :: SOFT_BOUNCE ) ; }
7749	public function getAllMetadata ( ) { $ metadata = array ( ) ; foreach ( $ this -> driver -> getAllClassNames ( ) as $ className ) { $ metadata [ ] = $ this -> getMetadataFor ( $ className ) ; } $ this -> validate ( $ metadata ) ; return $ metadata ; }
7117	protected function getFindBySubjectQuery ( ) { if ( null !== $ this -> findBySubjectQuery ) { return $ this -> findBySubjectQuery ; } $ qb = $ this -> createFindBySubjectQueryBuilder ( ) ; return $ this -> findBySubjectQuery = $ qb -> getQuery ( ) ; }
6067	public function listUsages ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/usages' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MediaUsageResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4725	private function addRule ( $ data , $ ruleType ) { if ( \ is_string ( $ data ) ) { $ data = array ( $ data ) ; } elseif ( ! \ is_array ( $ data ) ) { throw new InvalidArgumentException ( 'Invalid inflector rule data.' ) ; } foreach ( $ data as $ rule ) { array_push ( $ this -> rules [ $ ruleType ] , ( string ) $ rule ) ; } }
9033	protected function mapField ( $ field ) { if ( ! $ this -> classMetadata -> hasField ( $ field ) ) { $ this -> classMetadata -> mapField ( [ 'fieldName' => $ field , 'type' => 'datetime' , 'nullable' => true , ] ) ; } }
7522	function parse_style ( ) { if ( $ this -> parse_attributes ( ) && ( $ this -> token === self :: TOK_TAG_CLOSE ) && ( $ start = $ this -> pos ) && ( $ this -> next_pos ( '</style>' , false ) === self :: TOK_UNKNOWN ) ) { $ len = $ this -> pos - 1 - $ start ; $ this -> status [ 'text' ] = ( ( $ len > 0 ) ? substr ( $ this -> doc , $ start + 1 , $ len ) : '' ) ; $ this -> pos += 7 ; $ this -> status [ 'last_pos' ] = $ this -> pos ; return true ; } else { $ this -> addError ( 'No end for style tag found' ) ; return false ; } }
12474	public function getTheme ( $ identifier ) { $ themes = $ this -> getAvailableThemes ( ) ; if ( ! isset ( $ themes [ $ identifier ] ) ) { $ themeIds = array ( ) ; foreach ( $ themes as $ key => $ value ) { $ themeIds [ ] = $ key ; } throw new \ Exception ( sprintf ( 'Theme "%s" does not exist. Possible values are [%s]' , $ identifier , implode ( ', ' , $ themeIds ) ) , 1 ) ; } return $ themes [ $ identifier ] ; }
10053	public function setDataType ( $ dataType ) { if ( ! in_array ( $ dataType , self :: $ dataTypeValues ) ) { throw new Exception ( 'Invalid datatype for chart data series values' ) ; } $ this -> dataType = $ dataType ; return $ this ; }
10892	public function isPrime ( ) { if ( $ this -> value < 2 ) { return false ; } if ( $ this -> value === 2 ) { return true ; } if ( $ this -> isEven ( ) ) { return false ; } for ( $ i = 3 ; $ i <= ceil ( sqrt ( $ this -> value ) ) ; $ i = $ i + 2 ) { if ( $ this -> value % $ i == 0 ) { return false ; } } return true ; }
8573	public function listRecommendationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenRequest.php' ) ; $ request = new MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListRecommendationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListRecommendationsByNextTokenResponse.php' ) ; $ response = MWSRecommendationsSectionService_Model_ListRecommendationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
10933	protected function resolveParams ( UriInfo $ info , array $ params ) { $ uri = $ info -> getUri ( ) ; if ( false === strpos ( $ uri , '{' ) ) { return $ info ; } $ ctx = NULL ; $ result = '' ; foreach ( preg_split ( "'(\\{[^\\}]+\\})'" , $ uri , - 1 , PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY ) as $ part ) { if ( '{' != substr ( $ part , 0 , 1 ) ) { $ result .= $ part ; continue ; } $ placeholder = substr ( $ part , 1 , - 1 ) ; if ( '*' == substr ( $ placeholder , - 1 ) ) { $ placeholder = substr ( $ placeholder , 0 , - 1 ) ; $ multi = true ; } else { $ multi = false ; } switch ( substr ( $ placeholder , 0 , 1 ) ) { case '.' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '.' ; $ join = $ multi ? '.' : ',' ; break ; case '/' : $ placeholder = substr ( $ placeholder , 1 ) ; $ prefix = '/' ; $ join = $ multi ? '/' : ',' ; break ; default : $ prefix = '' ; $ join = ',' ; } if ( false === strpos ( $ placeholder , '.' ) ) { $ value = array_key_exists ( $ placeholder , $ params ) ? $ params [ $ placeholder ] : $ this ; } else { if ( $ ctx === NULL ) { $ ctx = $ this -> factory -> createContext ( $ params ) ; } $ value = $ ctx -> resolveValue ( explode ( '.' , $ placeholder ) , $ this ) ; } if ( $ value === $ this ) { $ result .= $ part ; } elseif ( is_array ( $ value ) || $ value instanceof \ Traversable ) { $ i = 0 ; foreach ( $ value as $ val ) { $ result .= ( ( $ i ++ == 0 ) ? $ prefix : $ join ) . Uri :: encode ( $ val , true ) ; } } else { $ result .= $ prefix . Uri :: encode ( $ value , true ) ; } } return new UriInfo ( $ result , $ info -> getRouteName ( ) , $ info -> getMethods ( ) , $ info -> getHandler ( ) ) ; }
2468	public function getOptions ( ) : array { $ options = [ ] ; foreach ( self :: DEFAULT_OPTIONS as $ option => $ label ) { $ options [ $ option ] = $ this -> translator -> trans ( 'MSC.validCharacters.' . $ label , [ ] , 'contao_default' ) ; } $ event = new SlugValidCharactersEvent ( $ options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: SLUG_VALID_CHARACTERS , $ event ) ; return $ event -> getOptions ( ) ; }
4782	public function removeWidgetConfig ( string $ widgetId , array $ config = [ ] ) { foreach ( $ config as $ id => $ content ) { if ( isset ( $ this -> config [ $ widgetId ] [ $ id ] ) ) { unset ( $ this -> config [ $ widgetId ] [ $ id ] ) ; } } return $ this ; }
7856	private function publishConfig ( ) { $ config = __DIR__ . '/config/workflow.php' ; $ this -> publishes ( [ $ config => config_path ( 'workflow.php' ) ] ) ; $ this -> mergeConfigFrom ( $ config , 'workflow' ) ; }
9478	protected function getCalendarDayDownloads ( $ limit = 30 ) { $ arrCalendarDayDownloads = array ( ) ; $ CalendarDays = date ( 'Y-m-d' , mktime ( 0 , 0 , 0 , date ( "m" ) , date ( "d" ) - $ limit , date ( "Y" ) ) ) ; $ objCalendarDayDownloads = \ Database :: getInstance ( ) -> prepare ( "SELECT dl.`id` , FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) as datum , count(dl.`filename`) as downloads , dl.`filename` FROM `tl_dlstats` dl INNER JOIN `tl_dlstatdets` det on dl.id = det.pid WHERE FROM_UNIXTIME(det.`tstamp`,GET_FORMAT(DATE,'ISO')) >=? GROUP BY dl.`id`, datum ORDER BY datum DESC, `filename`" ) -> execute ( $ CalendarDays ) ; while ( $ objCalendarDayDownloads -> next ( ) ) { $ viewDate = $ this -> parseDate ( $ GLOBALS [ 'TL_CONFIG' ] [ 'dateFormat' ] , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; $ c4d = $ this -> check4details ( $ objCalendarDayDownloads -> id ) ; $ arrCalendarDayDownloads [ ] = array ( $ viewDate , $ objCalendarDayDownloads -> filename , $ this -> getFormattedNumber ( $ objCalendarDayDownloads -> downloads , 0 ) , $ objCalendarDayDownloads -> id , $ c4d , $ objCalendarDayDownloads -> downloads , strtotime ( $ objCalendarDayDownloads -> datum ) ) ; } return $ arrCalendarDayDownloads ; }
2646	public function cloneVersion ( $ curVersion ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ curVersion . '/clone' ; $ result = $ this -> _fetch ( $ url , \ Zend_Http_Client :: PUT ) ; if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to clone active version.' ) ) ; } return $ result ; }
7911	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; SemanticUiPluginAsset :: register ( $ view ) ; $ selector = $ this -> selector ? : '#' . $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('$selector').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ handler = $ handler instanceof JsExpression ? $ handler : new JsExpression ( $ handler ) ; $ js [ ] = "jQuery('$selector').$name('setting', '$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
10542	public static function createFromApplication ( Application $ app ) { $ dispatch = new static ( $ app -> request , $ app -> resolver , $ app -> config ) ; $ dispatch -> setApplication ( $ app ) ; return $ dispatch ; }
12921	public function getRemaining ( ) { if ( is_null ( $ this -> _countRemaining ) ) { $ this -> _countRemaining = $ this -> total ; } return $ this -> _countRemaining ; }
10696	public function toArray ( ) : array { if ( empty ( $ this -> output ) ) { $ problem = [ 'type' => $ this -> type ? ( string ) $ this -> type : 'about:blank' ] ; if ( $ this -> title ) { $ problem [ 'title' ] = $ this -> title ; } if ( $ this -> status ) { $ problem [ 'status' ] = $ this -> status ; } if ( $ this -> detail ) { $ problem [ 'detail' ] = $ this -> detail ; } if ( $ this -> instance ) { $ problem [ 'instance' ] = ( string ) $ this -> instance ; } $ this -> output = array_merge ( $ problem , $ this -> extensions ) ; } return $ this -> output ; }
7673	function TbsStorePark ( ) { if ( $ this -> TbsCurrIdx !== false ) { $ this -> TbsStoreLst [ $ this -> TbsCurrIdx ] = array ( 'src' => $ this -> TBS -> Source , 'onshow' => true ) ; $ this -> TBS -> Source = '' ; $ this -> TbsCurrIdx = false ; } }
2886	public function onActionPreDispatch ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ action = $ observer -> getData ( 'controller_action' ) ; $ this -> getRequestInfo ( ) -> initController ( $ action ) ; }
11534	public static function writeFile ( $ file , $ content ) { $ handle = fopen ( $ file , 'w' ) ; if ( ! self :: lockFile ( $ handle , LOCK_EX | LOCK_NB ) ) { $ exception = array ( "message" => 'exception_file_cannot_be_locked_for_writing' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } if ( fwrite ( $ handle , $ content ) === false ) { $ exception = array ( "message" => 'exception_file_cannot_be_written' , "parameters" => array ( "%file%" => basename ( $ file ) , ) ) ; throw new RuntimeException ( json_encode ( $ exception ) ) ; } self :: unlockFile ( $ handle ) ; }
5629	protected function extractAbsolutePath ( $ base ) { if ( $ this -> getHost ( ) ) { return $ this -> path ; } if ( ! $ this -> isRelativePath ( $ this -> path ) ) { return $ this -> path ; } if ( $ this -> path ) { return $ base -> getBasePath ( ) . $ this -> path ; } return $ base -> getPath ( ) ; }
11504	public function setSlots ( $ first , $ last , $ connection ) { if ( ! static :: isValidRange ( $ first , $ last ) ) { throw new \ OutOfBoundsException ( "Invalid slot range $first-$last for `$connection`" ) ; } $ this -> slots += array_fill ( $ first , $ last - $ first + 1 , ( string ) $ connection ) ; }
12617	public function removeAttribute ( string $ attributeName ) { if ( isset ( $ this -> attributes [ $ attributeName ] ) ) unset ( $ this -> attributes [ $ attributeName ] ) ; }
5001	public function removeTab ( $ tabName , FormMapper $ formMapper ) { $ tabs = $ this -> getFormTabs ( ) ; if ( array_key_exists ( $ tabName , $ tabs ) ) { $ groups = $ this -> getFormGroups ( ) ; if ( ! is_array ( $ groups ) ) { return ; } foreach ( $ tabs [ $ tabName ] [ 'groups' ] as $ group ) { if ( isset ( $ groups [ $ group ] ) ) { foreach ( $ groups [ $ group ] [ 'fields' ] as $ field ) { $ formMapper -> remove ( $ field ) ; } } unset ( $ groups [ $ group ] ) ; } $ this -> setFormGroups ( $ groups ) ; $ this -> removeEmptyGroups ( ) ; } }
7549	function deleteChild ( $ child , $ soft_delete = false ) { if ( is_object ( $ child ) ) { $ child = $ this -> findChild ( $ child ) ; } elseif ( $ child < 0 ) { $ child += count ( $ this -> children ) ; } if ( ! $ soft_delete ) { $ this -> children [ $ child ] -> delete ( ) ; } unset ( $ this -> children [ $ child ] ) ; $ tmp = array ( ) ; foreach ( array_keys ( $ this -> children ) as $ k ) { $ tmp [ ] = & $ this -> children [ $ k ] ; } $ this -> children = $ tmp ; }
10451	public function getTtl ( $ key ) { $ getResult = $ this -> getValue ( $ key ) ; $ unserialized = @ unserialize ( $ getResult ) ; if ( ! Util :: hasInternalExpireTime ( $ unserialized ) ) { throw new \ Exception ( 'Cannot retrieve ttl' ) ; } return $ this -> handleTtl ( $ key , $ unserialized [ 'ts' ] , $ unserialized [ 's' ] ) ; }
9108	protected function attainThemeName ( ) { $ themeName = $ this -> getResolverObject ( 'resolver_adapter_service' ) -> getName ( ) ; return ( empty ( $ themeName ) && ! ( $ themeName === '0' ) ) ? false : $ themeName ; }
7082	public function uri ( $ uri = NULL ) : string { if ( $ uri === NULL ) { return empty ( $ this -> _uri ) ? '/' : $ this -> _uri ; } return $ this -> _uri = $ uri ; }
4520	public function set ( string $ key , $ value ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ parameter -> setKey ( $ key ) -> setValue ( $ value ) ; $ this -> manager -> persist ( $ parameter ) ; $ this -> manager -> flush ( ) ; $ this -> manager -> detach ( $ parameter ) ; }
3938	private function setExplanation ( PropertyInterface $ property , $ propInfo ) { if ( $ property -> getExplanation ( ) || ! isset ( $ propInfo [ 'explanation' ] ) ) { return ; } $ property -> setExplanation ( $ propInfo [ 'explanation' ] ) ; }
11592	public function getFullPath ( $ file = '' ) { $ this -> name = ( $ file ) ? $ file : $ this -> name ; return config ( 'odin.assetsUrl' ) . $ this -> getPath ( ) . $ this -> name ; }
3816	protected function render ( $ table , $ metaModel , Request $ request ) { $ fields = $ this -> generateForm ( $ table , $ metaModel , $ request ) ; return [ 'action' => '' , 'requestToken' => REQUEST_TOKEN , 'href' => $ this -> getReferer ( $ request , $ table , true ) , 'backBt' => $ this -> translator -> trans ( 'MSC.backBT' , [ ] , 'contao_default' ) , 'add' => $ this -> translator -> trans ( 'MSC.continue' , [ ] , 'contao_default' ) , 'saveNclose' => $ this -> translator -> trans ( 'MSC.saveNclose' , [ ] , 'contao_default' ) , 'activate' => $ this -> translator -> trans ( $ table . '.addAll_activate' , [ ] , 'contao_' . $ table ) , 'headline' => $ this -> translator -> trans ( $ table . '.addall.1' , [ ] , 'contao_' . $ table ) , 'selectAll' => $ this -> translator -> trans ( 'MSC.selectAll' , [ ] , 'contao_default' ) , 'cacheMessage' => '' , 'updateMessage' => '' , 'hasCheckbox' => count ( $ fields ) > 0 , 'fields' => $ fields , ] ; }
12146	public function get ( $ name ) { if ( $ this -> exists ( $ name ) ) { $ value = $ this -> settings [ $ name ] ; return $ value ; } return false ; }
9389	protected function parse ( $ route ) { $ route [ 0 ] = strtoupper ( $ route [ 0 ] ) ; $ route [ 1 ] = str_replace ( '//' , '/' , $ this -> prefix . $ route [ 1 ] ) ; is_string ( $ route [ 2 ] ) && $ route [ 2 ] = explode ( '@' , $ route [ 2 ] ) ; is_array ( $ route [ 2 ] ) && $ route [ 2 ] [ 0 ] = $ this -> namespace . $ route [ 2 ] [ 0 ] ; is_array ( $ route [ 3 ] ) || $ route [ 3 ] = array ( $ route [ 3 ] ) ; return $ route ; }
3146	public function resume ( RunnerServiceContext $ context ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ context -> getTestSession ( ) -> resume ( ) ; $ this -> persist ( $ context ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'resume' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
12485	public function adapterHasBehavior ( Adapter $ adapter , $ behavior ) { if ( $ adapter instanceof KnowsItsBehaviors ) { return in_array ( $ behavior , $ adapter -> getBehaviors ( ) ) ; } return true === is_a ( $ adapter , $ behavior ) ; }
1386	protected function memberFieldsNotAllowed ( string $ path , string $ member , iterable $ fields ) : void { foreach ( $ fields as $ field ) { $ this -> errors -> add ( $ this -> translator -> memberFieldNotAllowed ( $ path , $ member , $ field ) ) ; } }
9639	public function setValue ( $ url ) { if ( $ url ) { $ url = $ this -> rebuildURL ( $ url ) ; } parent :: setValue ( $ url ) ; }
9579	public function setChannel ( $ channel , LoggerInterface $ logger ) { if ( isset ( $ this -> channels [ $ channel ] ) ) { throw new InvalidArgumentException ( "Channel $channel is already defined" ) ; } $ this -> channels [ $ channel ] = $ logger ; }
12151	public function getRelatedType ( $ name ) { list ( $ relationship , $ role ) = $ this -> getRelationship ( $ name ) ; if ( $ relationship ) { return $ relationship -> roleType ( $ role ) ; } return false ; }
12578	public function previewVoiceByName ( $ message , $ to ) { return $ this -> preview ( self :: MSG_TYPE_VOICE , $ message , $ to , self :: PREVIEW_BY_NAME ) ; }
8159	public function getIsStatus ( ) { switch ( $ this -> status ) { case User :: STATUS_PENDING : return '<div class="text-center"><span class="text-primary">Pending</span></div>' ; case User :: STATUS_ACTIVE : return '<div class="text-center"><span class="text-success">Active</span></div>' ; case User :: STATUS_BLOCKED : return '<div class="text-center"><span class="text-danger">Blocked</span></div>' ; } return NULL ; }
486	public function addCommentOnTable ( $ table , $ comment ) { $ time = $ this -> beginCommand ( "add comment on table $table" ) ; $ this -> db -> createCommand ( ) -> addCommentOnTable ( $ table , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
908	private function isShortArray ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> equals ( '[' ) ) { return false ; } static $ disallowedPrevTokens = [ ')' , ']' , '}' , '"' , [ T_CONSTANT_ENCAPSED_STRING ] , [ T_STRING ] , [ T_STRING_VARNAME ] , [ T_VARIABLE ] , [ CT :: T_ARRAY_SQUARE_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_PROP_BRACE_CLOSE ] , [ CT :: T_DYNAMIC_VAR_BRACE_CLOSE ] , [ CT :: T_ARRAY_INDEX_CURLY_BRACE_CLOSE ] , ] ; $ prevToken = $ tokens [ $ tokens -> getPrevMeaningfulToken ( $ index ) ] ; if ( $ prevToken -> equalsAny ( $ disallowedPrevTokens ) ) { return false ; } $ nextToken = $ tokens [ $ tokens -> getNextMeaningfulToken ( $ index ) ] ; if ( $ nextToken -> equals ( ']' ) ) { return true ; } return ! $ this -> isArrayDestructing ( $ tokens , $ index ) ; }
7945	public function ipDeleteMonitoringNotification ( $ id , $ ip , $ notificationId ) { if ( ! $ id ) throw new BadMethodCallException ( 'Missing parameter $id.' ) ; if ( ! $ ip ) throw new BadMethodCallException ( 'Missing parameter $ip.' ) ; if ( ! $ notificationId ) throw new BadMethodCallException ( 'Missing parameter $notificationId.' ) ; try { $ r = $ this -> delete ( 'xdsl/' . $ id . '/ips/' . $ ip . '/monitoringNotifications/' . $ notificationId ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new XdslException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return ; }
9274	public function getServiceConfig ( ) { return array ( 'factories' => array ( 'CronHelper\Service\CronService' => function ( $ serviceManager ) { $ mainConfig = $ serviceManager -> get ( 'config' ) ; $ serviceConfig = array ( ) ; if ( is_array ( $ mainConfig ) ) { if ( array_key_exists ( 'cron_helper' , $ mainConfig ) ) { $ serviceConfig = $ mainConfig [ 'cron_helper' ] ; } } $ cronService = new CronService ( $ serviceConfig ) ; return $ cronService ; } , ) , ) ; }
10739	public function supports ( $ query ) { foreach ( $ this -> engines as $ eachEngine ) { if ( $ eachEngine -> supports ( $ query ) ) { return true ; } } return false ; }
2782	public function renderShadowMark ( $ count , $ current , $ eolInterval = 60 ) { $ this -> progressCount ++ ; $ this -> write ( '<fg=blue;options=bold>S</fg=blue;options=bold>' , false ) ; if ( ( $ this -> progressCount % $ eolInterval ) == 0 ) { $ counter = str_pad ( $ this -> progressCount , 5 , ' ' , STR_PAD_LEFT ) ; $ this -> write ( ' |' . $ counter . ' (' . str_pad ( $ current , strlen ( $ count ) , ' ' , STR_PAD_LEFT ) . '/' . $ count . ')' . PHP_EOL , false ) ; } }
6326	public static function getClassNameWithoutNamespace ( $ object ) { $ className = get_class ( $ object ) ; if ( preg_match ( '@\\\\([\w]+)$@' , $ className , $ matches ) ) { $ className = $ matches [ 1 ] ; } return $ className ; }
2453	public static function findByHashAndPid ( $ strHash , $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; return static :: findOneBy ( array ( "($t.hash=? AND $t.pid=?)" ) , array ( $ strHash , $ intPid ) , $ arrOptions ) ; }
728	public static function off ( $ class , $ name , $ handler = null ) { $ class = ltrim ( $ class , '\\' ) ; if ( empty ( self :: $ _events [ $ name ] [ $ class ] ) && empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { return false ; } if ( $ handler === null ) { unset ( self :: $ _events [ $ name ] [ $ class ] ) ; unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; return true ; } if ( isset ( self :: $ _events [ $ name ] [ $ class ] ) ) { $ removed = false ; foreach ( self :: $ _events [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _events [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _events [ $ name ] [ $ class ] = array_values ( self :: $ _events [ $ name ] [ $ class ] ) ; return $ removed ; } } $ removed = false ; if ( isset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { foreach ( self :: $ _eventWildcards [ $ name ] [ $ class ] as $ i => $ event ) { if ( $ event [ 0 ] === $ handler ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] [ $ i ] ) ; $ removed = true ; } } if ( $ removed ) { self :: $ _eventWildcards [ $ name ] [ $ class ] = array_values ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] [ $ class ] ) ; if ( empty ( self :: $ _eventWildcards [ $ name ] ) ) { unset ( self :: $ _eventWildcards [ $ name ] ) ; } } } } return $ removed ; }
5008	public function trigger ( $ event , $ target = null ) { if ( empty ( $ this -> _template ) || ! is_string ( $ this -> _template ) ) { throw new \ InvalidArgumentException ( 'ContentCollector must have a template-name' ) ; } $ responseCollection = $ this -> getController ( ) -> getEventManager ( ) -> trigger ( $ event , $ target ) ; $ viewModel = new ViewModel ( ) ; $ viewModel -> setTemplate ( $ this -> _template ) ; foreach ( $ responseCollection as $ i => $ response ) { if ( is_string ( $ response ) ) { $ template = $ response ; $ response = new ViewModel ( array ( 'target' => $ target ) ) ; $ response -> setTemplate ( $ template ) ; } $ viewModel -> addChild ( $ response , $ this -> _captureTo . $ i ) ; } return $ viewModel ; }
11184	protected function generateActions ( ) { $ parser = new Parser ( ) ; $ parser -> setPath ( $ this -> getApplicationPath ( ) ) ; $ parser -> setNameSpace ( $ this -> getApplicationNameSpace ( ) ) ; $ list = $ parser -> run ( ) ; return $ list ; }
10765	public function generateImage ( $ filename = false , $ level = Constants :: QR_ECLEVEL_L , $ size = 3 , $ margin = 4 ) { $ result = 'SPD' . self :: DELIMITER . $ this -> version . self :: DELIMITER . $ this -> implodeContent ( ) ; if ( $ this -> appendCRC32 ) { $ result .= self :: DELIMITER . 'CRC32:' . sprintf ( '%x' , crc32 ( $ result ) ) ; } QRcode :: png ( $ result , $ filename , $ level , $ size , $ margin ) ; die ( ) ; }
5993	public function addSearchSort ( $ item ) { if ( ! ( $ item instanceof SearchSort ) ) { if ( is_array ( $ item ) ) { try { $ item = new SearchSort ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate SearchSort. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "SearchSort"!' , E_USER_WARNING ) ; } } $ this -> sortFields [ ] = $ item ; return $ this ; }
10199	private function writeCellSpan ( XMLWriter $ objWriter , $ curColumn , $ prevColumn ) { $ diff = $ curColumn - $ prevColumn - 1 ; if ( 1 === $ diff ) { $ objWriter -> writeElement ( 'table:table-cell' ) ; } elseif ( $ diff > 1 ) { $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , $ diff ) ; $ objWriter -> endElement ( ) ; } }
6130	protected function getCorpusName ( ) { if ( $ this -> currObj instanceof Channel && $ this -> currObj -> isSpacer ( ) ) { if ( $ this -> currObj -> spacerGetType ( ) != TeamSpeak3 :: SPACER_CUSTOM ) { return "" ; } $ string = $ this -> currObj [ "channel_name" ] -> section ( "]" , 1 , 99 ) ; if ( $ this -> currObj -> spacerGetAlign ( ) == TeamSpeak3 :: SPACER_ALIGN_REPEAT ) { $ string -> resize ( 30 , $ string ) ; } return htmlspecialchars ( $ string ) ; } if ( $ this -> currObj instanceof Client ) { $ before = array ( ) ; $ behind = array ( ) ; foreach ( $ this -> currObj -> memberOf ( ) as $ group ) { if ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEFORE ) { $ before [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } elseif ( $ group -> getProperty ( "namemode" ) == TeamSpeak3 :: GROUP_NAMEMODE_BEHIND ) { $ behind [ ] = "[" . htmlspecialchars ( $ group [ "name" ] ) . "]" ; } } return implode ( "" , $ before ) . " " . htmlspecialchars ( $ this -> currObj ) . " " . implode ( "" , $ behind ) ; } return htmlspecialchars ( $ this -> currObj ) ; }
9397	protected function escape ( array $ options ) { $ results = [ ] ; foreach ( $ options as $ key => $ value ) { if ( ! in_array ( $ key , $ this -> safe ) ) { $ results [ $ key ] = escapeshellarg ( $ value ) ; } else { $ results [ $ key ] = $ value ; } } return $ results ; }
9120	public function registerRouter ( AbstractRouter $ router ) { $ this -> router = $ router ; $ this -> router -> setApplication ( $ this ) ; return $ this ; }
7093	private function checkHierarchyIntegrity ( InvoiceInterface $ invoice ) { if ( null !== $ shipment = $ invoice -> getShipment ( ) ) { if ( $ invoice -> getSale ( ) !== $ shipment -> getSale ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isCredit ( $ invoice ) && ! $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } if ( InvoiceTypes :: isInvoice ( $ invoice ) && $ shipment -> isReturn ( ) ) { throw new ValidationFailedException ( ) ; } } }
7062	protected function updateCustomerBalance ( PaymentInterface $ payment , $ amount = null ) { if ( null === $ customer = $ payment -> getSale ( ) -> getCustomer ( ) ) { return false ; } $ amount = $ amount ? : $ payment -> getAmount ( ) ; if ( $ this -> isAcceptedPayment ( $ payment ) ) { $ amount = - $ amount ; } if ( $ payment -> getMethod ( ) -> isCredit ( ) ) { return $ this -> updateCreditBalance ( $ customer , $ amount , true ) ; } elseif ( $ payment -> getMethod ( ) -> isOutstanding ( ) ) { return $ this -> updateOutstandingBalance ( $ customer , $ amount , true ) ; } return false ; }
6960	public static function dt ( AstroDate $ dt ) { $ epoch = new static ( $ dt -> toTT ( ) -> toJD ( ) ) ; $ epoch -> dt = $ dt -> copy ( ) ; return $ epoch ; }
9	public function authorizeOAuth ( $ originUrl ) { if ( ! in_array ( $ originUrl , $ this -> config -> get ( 'gitlab-domains' ) , true ) ) { return false ; } if ( 0 === $ this -> process -> execute ( 'git config gitlab.accesstoken' , $ output ) ) { $ this -> io -> setAuthentication ( $ originUrl , trim ( $ output ) , 'oauth2' ) ; return true ; } $ authTokens = $ this -> config -> get ( 'gitlab-token' ) ; if ( isset ( $ authTokens [ $ originUrl ] ) ) { $ this -> io -> setAuthentication ( $ originUrl , $ authTokens [ $ originUrl ] , 'private-token' ) ; return true ; } return false ; }
389	public function link ( $ attribute , $ options = [ ] ) { if ( ( $ direction = $ this -> getAttributeOrder ( $ attribute ) ) !== null ) { $ class = $ direction === SORT_DESC ? 'desc' : 'asc' ; if ( isset ( $ options [ 'class' ] ) ) { $ options [ 'class' ] .= ' ' . $ class ; } else { $ options [ 'class' ] = $ class ; } } $ url = $ this -> createUrl ( $ attribute ) ; $ options [ 'data-sort' ] = $ this -> createSortParam ( $ attribute ) ; if ( isset ( $ options [ 'label' ] ) ) { $ label = $ options [ 'label' ] ; unset ( $ options [ 'label' ] ) ; } else { if ( isset ( $ this -> attributes [ $ attribute ] [ 'label' ] ) ) { $ label = $ this -> attributes [ $ attribute ] [ 'label' ] ; } else { $ label = Inflector :: camel2words ( $ attribute ) ; } } return Html :: a ( $ label , $ url , $ options ) ; }
11180	protected function set ( $ key , $ value ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; $ cache [ $ key ] = $ value ; apc_store ( $ this -> getKey ( ) , $ cache ) ; }
12703	public function publishAction ( Request $ request , Application $ app ) { $ options = array ( "request" => $ request , "page_manager" => $ app [ "red_kite_cms.page_manager" ] , "username" => $ this -> fetchUsername ( $ app [ "security" ] , $ app [ "red_kite_cms.configuration_handler" ] ) , ) ; return parent :: publish ( $ options ) ; }
12695	static function getVendorDir ( $ vendorPrefix = 'vendor' ) { if ( is_dir ( __DIR__ . '/../../../composer' ) && is_file ( __DIR__ . '/../../../autoload.php' ) ) { return realpath ( __DIR__ . '/../../..' ) ; } if ( is_dir ( __DIR__ . "/../$vendorPrefix/composer" ) && is_file ( __DIR__ . "/../$vendorPrefix/autoload.php" ) ) { return realpath ( __DIR__ . "/../$vendorPrefix" ) ; } return false ; }
322	public static function pluralize ( $ word ) { if ( isset ( static :: $ specials [ $ word ] ) ) { return static :: $ specials [ $ word ] ; } foreach ( static :: $ plurals as $ rule => $ replacement ) { if ( preg_match ( $ rule , $ word ) ) { return preg_replace ( $ rule , $ replacement , $ word ) ; } } return $ word ; }
318	public function registerCssFile ( $ url , $ options = [ ] , $ key = null ) { $ url = Yii :: getAlias ( $ url ) ; $ key = $ key ? : $ url ; $ depends = ArrayHelper :: remove ( $ options , 'depends' , [ ] ) ; if ( empty ( $ depends ) ) { $ this -> cssFiles [ $ key ] = Html :: cssFile ( $ url , $ options ) ; } else { $ this -> getAssetManager ( ) -> bundles [ $ key ] = Yii :: createObject ( [ 'class' => AssetBundle :: className ( ) , 'baseUrl' => '' , 'css' => [ strncmp ( $ url , '//' , 2 ) === 0 ? $ url : ltrim ( $ url , '/' ) ] , 'cssOptions' => $ options , 'depends' => ( array ) $ depends , ] ) ; $ this -> registerAssetBundle ( $ key ) ; } }
9516	public function settings ( $ name = null , $ value = null ) { switch ( func_num_args ( ) ) { case 0 : return $ this -> info ( 'settings' ) ; break ; case 1 : return $ this -> info ( 'settings' , func_get_arg ( 0 ) ) ; break ; case 2 : $ update = false ; list ( $ name , $ value ) = func_get_args ( ) ; $ current = $ this -> info ( 'settings' , $ name ) ; if ( is_null ( $ value ) ) { if ( ! is_null ( $ current ) ) { unset ( $ this -> info [ 'settings' ] [ $ name ] ) ; $ update = true ; } } elseif ( $ current !== $ value ) { $ this -> info [ 'settings' ] [ $ name ] = $ value ; $ update = true ; } if ( $ update ) { $ this -> exec ( 'UPDATE config SET settings = ?' , serialize ( $ this -> info [ 'settings' ] ) ) ; } break ; } }
12293	public function update ( array $ data , $ id ) { $ resource = $ this -> model -> find ( $ id ) ; if ( ! $ resource ) { return '' ; } $ resource -> update ( $ data ) ; return $ resource ; }
12484	protected function getDefaultOptionIds ( ) { $ optionIds = [ ] ; $ defaultDefinition = $ this -> getDefaultInputDefinition ( ) ; foreach ( $ defaultDefinition -> getOptions ( ) as $ option ) { $ optionIds [ ] = $ option -> getName ( ) ; } ; return $ optionIds ; }
8778	public function redirect ( $ data = null , int $ statusCode = 301 , $ secure = false ) { if ( substr ( $ data , 0 , 4 ) === 'http' || substr ( $ data , 0 , 5 ) === 'https' ) { header ( 'Location: ' . $ data , true , $ statusCode ) ; } else { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . $ data : $ this -> url ; header ( 'Location: ' . $ this -> getUrl ( $ data , $ secure ) , true , $ statusCode ) ; } die ( ) ; }
4252	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ errorStats = $ this -> debug -> internal -> errorStats ( ) ; $ errorStr = '' ; if ( $ errorStats [ 'inConsole' ] ) { $ errorStr = 'Errors: ' ; foreach ( $ errorStats [ 'counts' ] as $ category => $ vals ) { $ errorStr .= $ vals [ 'inConsole' ] . ' ' . $ category . ', ' ; } $ errorStr = \ substr ( $ errorStr , 0 , - 2 ) ; } $ str = '' ; $ str .= '<script type="text/javascript">' . "\n" ; $ str .= $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP' , ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '' ) , $ errorStr , ) ) ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ str .= $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ str .= '</script>' . "\n" ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
1048	public static function value ( $ rawString ) { $ lines = preg_split ( "/\\r\\n|[\\n\\r]/" , $ rawString ) ; $ commonIndent = null ; $ linesLength = count ( $ lines ) ; for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ indent = self :: leadingWhitespace ( $ line ) ; if ( $ indent >= mb_strlen ( $ line ) || ( $ commonIndent !== null && $ indent >= $ commonIndent ) ) { continue ; } $ commonIndent = $ indent ; if ( $ commonIndent === 0 ) { break ; } } if ( $ commonIndent ) { for ( $ i = 1 ; $ i < $ linesLength ; $ i ++ ) { $ line = $ lines [ $ i ] ; $ lines [ $ i ] = mb_substr ( $ line , $ commonIndent ) ; } } while ( count ( $ lines ) > 0 && trim ( $ lines [ 0 ] , " \t" ) === '' ) { array_shift ( $ lines ) ; } while ( count ( $ lines ) > 0 && trim ( $ lines [ count ( $ lines ) - 1 ] , " \t" ) === '' ) { array_pop ( $ lines ) ; } return implode ( "\n" , $ lines ) ; }
3769	public function collectAttributeSettings ( IMetaModel $ metaModel , $ renderSetting ) { $ attributeRows = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' ) -> setParameter ( 'pid' , $ renderSetting -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ attributeRows -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ attributeRow ) { $ attribute = $ metaModel -> getAttributeById ( $ attributeRow [ 'attr_id' ] ) ; if ( ! $ attribute ) { continue ; } $ attributeSetting = $ renderSetting -> getSetting ( $ attribute -> getColName ( ) ) ; if ( ! $ attributeSetting ) { $ attributeSetting = $ attribute -> getDefaultRenderSettings ( ) ; } foreach ( $ attributeRow as $ strKey => $ varValue ) { if ( $ varValue ) { $ attributeSetting -> set ( $ strKey , StringUtil :: deserialize ( $ varValue ) ) ; } } $ renderSetting -> setSetting ( $ attribute -> getColName ( ) , $ attributeSetting ) ; } }
12855	function goWait ( $ maxExecution = null ) { $ jobExecution = 0 ; $ sleep = 0 ; while ( 1 ) { if ( 0 == $ executed = $ this -> goUntilEmpty ( ) ) { $ sleep += 100000 ; usleep ( $ sleep ) ; if ( $ sleep > 2 * 1000000 ) $ sleep = 100000 ; continue ; } $ jobExecution += $ executed ; if ( $ jobExecution >= $ maxExecution ) break ; if ( $ sleep = $ this -> getSleep ( ) ) usleep ( $ sleep ) ; $ sleep = 0 ; } }
12707	public static function parseSignature ( string $ signature ) : array { $ signature = explode ( ' ' , trim ( $ signature ) ) ; $ command = trim ( $ signature [ 0 ] ) ; $ arguments = [ ] ; $ options = [ ] ; foreach ( $ signature as $ word ) { $ type = self :: determineTypeOfWord ( $ word ) ; if ( $ type == self :: OPTION_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ options [ $ key ] = $ defaultValue ; } elseif ( $ type == self :: ARGUMENT_TYPE ) { list ( $ key , $ defaultValue ) = self :: parse ( $ word ) ; $ arguments [ $ key ] = $ defaultValue ; } } return [ $ command , $ arguments , $ options ] ; }
82	public function extractTo ( $ target , array $ roles = array ( 'php' => '/' , 'script' => '/bin' ) , $ vars = array ( ) ) { $ extractionPath = $ target . '/tarball' ; try { $ archive = new \ PharData ( $ this -> file ) ; $ archive -> extractTo ( $ extractionPath , null , true ) ; if ( ! is_file ( $ this -> combine ( $ extractionPath , '/package.xml' ) ) ) { throw new \ RuntimeException ( 'Invalid PEAR package. It must contain package.xml file.' ) ; } $ fileCopyActions = $ this -> buildCopyActions ( $ extractionPath , $ roles , $ vars ) ; $ this -> copyFiles ( $ fileCopyActions , $ extractionPath , $ target , $ roles , $ vars ) ; $ this -> filesystem -> removeDirectory ( $ extractionPath ) ; } catch ( \ Exception $ exception ) { throw new \ UnexpectedValueException ( sprintf ( 'Failed to extract PEAR package %s to %s. Reason: %s' , $ this -> file , $ target , $ exception -> getMessage ( ) ) , 0 , $ exception ) ; } }
10469	public function post ( Request $ request ) { $ this -> emit ( 'message.send' , array ( $ request -> xml ( ) ) ) ; $ response = $ this -> connector -> post ( $ request ) ; $ this -> emit ( 'message.recv' , array ( $ response ) ) ; try { return $ this -> parseXml ( $ response ) ; } catch ( InvalidXMLException $ e ) { throw new InvalidNcipResponseException ( 'Invalid response received from the NCIP service "' . $ this -> connector -> url . '": ' . $ response ) ; } }
7253	private function getShipmentMethodFromEvent ( ResourceEventInterface $ event ) { $ resource = $ event -> getResource ( ) ; if ( ! $ resource instanceof ShipmentMethodInterface ) { throw new InvalidArgumentException ( 'Expected instance of ' . ShipmentMethodInterface :: class ) ; } return $ resource ; }
3057	public function isAdaptive ( AssessmentItemRef $ currentAssessmentItemRef = null ) { return $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> isAdaptive ( $ this -> getTestSession ( ) , $ currentAssessmentItemRef ) ; }
5308	protected function getPathFromRect ( SimpleXMLElement $ rect ) { if ( empty ( $ rect [ 'width' ] ) || $ rect [ 'width' ] < 0 || empty ( $ rect [ 'height' ] ) || $ rect [ 'height' ] < 0 ) { return '' ; } if ( empty ( $ rect [ 'x' ] ) ) { $ rect [ 'x' ] = 0 ; } if ( empty ( $ rect [ 'y' ] ) ) { $ rect [ 'y' ] = 0 ; } return 'M' . $ rect [ 'x' ] . ' ' . $ rect [ 'y' ] . 'l' . $ rect [ 'width' ] . ' 0l0 ' . $ rect [ 'height' ] . 'l' . ( - $ rect [ 'width' ] ) . ' 0Z' ; }
5076	public function getIndex ( $ aData = [ ] , $ iPage = null , $ iPerPage = null ) { $ oInput = Factory :: service ( 'Input' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; if ( is_null ( $ iPage ) ) { $ iPage = ( int ) $ oInput -> get ( 'page' ) ? : 1 ; } if ( is_null ( $ iPerPage ) ) { $ iPerPage = static :: CONFIG_MAX_ITEMS_PER_PAGE ; } $ aResults = $ oItemModel -> getAll ( $ iPage , $ iPerPage , $ aData ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( array_map ( [ $ this , 'formatObject' ] , $ aResults ) ) ; return $ oResponse ; }
11198	public function delete ( $ name ) { $ name = $ this -> getName ( $ name ) ; $ resourceKey = $ name ; if ( is_numeric ( $ name ) ) { $ resourceKey = $ this -> fetchOffsetKey ( $ name ) ; } if ( $ this -> processDelete ( $ resourceKey ) ) { $ this -> contentModified = true ; $ this -> size -= 1 ; } }
8372	public function help ( Request $ request ) { $ routes = Console :: getRoutes ( ) ; echo 'strayFw console help screen' . PHP_EOL . 'Available actions :' . PHP_EOL . PHP_EOL ; $ namespace = null ; foreach ( $ routes as $ route ) { if ( $ namespace != $ route [ 'namespace' ] ) { $ namespace = $ route [ 'namespace' ] ; echo $ namespace . PHP_EOL . PHP_EOL ; } echo ' ' . $ route [ 'usage' ] . PHP_EOL ; if ( isset ( $ route [ 'help' ] ) != null ) { echo ' ' . $ route [ 'help' ] ; } echo PHP_EOL . PHP_EOL ; } }
2355	public function hasFrontendUser ( ) : bool { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; return null !== $ token && $ token -> getUser ( ) instanceof FrontendUser ; }
2241	public static function getArticle ( $ varId , $ blnMultiMode = false , $ blnIsInsertTag = false , $ strColumn = 'main' ) { global $ objPage ; if ( \ is_object ( $ varId ) ) { $ objRow = $ varId ; } else { if ( ! $ varId ) { return '' ; } $ objRow = ArticleModel :: findByIdOrAliasAndPid ( $ varId , ( ! $ blnIsInsertTag ? $ objPage -> id : null ) ) ; if ( $ objRow === null ) { return false ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } if ( isset ( $ _GET [ 'pdf' ] ) && Input :: get ( 'pdf' ) == $ objRow -> id ) { if ( $ objRow -> printable == 1 ) { @ trigger_error ( 'Setting tl_article.printable to "1" has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } elseif ( $ objRow -> printable != '' ) { $ options = StringUtil :: deserialize ( $ objRow -> printable ) ; if ( \ is_array ( $ options ) && \ in_array ( 'pdf' , $ options ) ) { $ objArticle = new ModuleArticle ( $ objRow ) ; $ objArticle -> generatePdf ( ) ; } } } $ objRow -> headline = $ objRow -> title ; $ objRow -> multiMode = $ blnMultiMode ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getArticle' ] as $ callback ) { static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow ) ; } } $ objArticle = new ModuleArticle ( $ objRow , $ strColumn ) ; $ strBuffer = $ objArticle -> generate ( $ blnIsInsertTag ) ; if ( $ objArticle -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
8597	public function listMarketplaceParticipationsByNextToken ( $ request ) { if ( ! ( $ request instanceof MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ) ) { $ request = new MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListMarketplaceParticipationsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = MarketplaceWebServiceSellers_Model_ListMarketplaceParticipationsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
2629	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; if ( $ key == '' ) { return $ result -> setData ( [ 'status' => true ] ) ; } $ deleteItem = $ this -> api -> deleteDictionaryItem ( $ dictionaryId , $ key ) ; if ( ! $ deleteItem ) { return $ result -> setData ( [ 'status' => false ] ) ; } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
9319	public function markdown ( $ contents ) { $ contents = app ( 'markdown' ) -> convertToHtml ( $ contents ) ; if ( ! is_null ( $ this -> cachePath ) ) { $ this -> files -> put ( $ this -> getCompiledPath ( $ this -> getPath ( ) ) , $ contents ) ; } return $ contents ; }
6553	public function unlock ( ) { try { if ( $ this -> pid === $ this -> getSerial ( ) && is_resource ( $ this -> fh ) ) { $ this -> removeLineFromFile ( $ this -> pid , $ this -> fh ) ; flock ( $ this -> fh , LOCK_UN ) ; fclose ( $ this -> fh ) ; if ( filesize ( $ filename = $ this -> getPidFilename ( ) ) === 0 ) { unlink ( $ filename ) ; } } } catch ( FileNotFoundException $ fnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID file %s doesn\'t exist' , $ this -> getPidFilename ( ) ) ) ; } catch ( LineNotFoundException $ lnfe ) { $ this -> getSystemLogger ( ) -> notice ( sprintf ( 'PID %s is can not be found in PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) ) ; } catch ( \ Exception $ e ) { throw new \ Exception ( sprintf ( 'Can\'t remove PID %s from PID file %s' , $ this -> pid , $ this -> getPidFilename ( ) ) , null , $ e ) ; } }
7405	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; $ this -> _container = [ ] ; foreach ( $ in as $ k => $ v ) { $ this -> offsetSet ( $ k , $ v ) ; } }
6019	public function removeSite ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/deployment/' . $ id . '' , $ parameters ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
8461	public static function getCurrentPage ( ) { $ protocol = self :: getProtocol ( ) ; $ host = self :: getDomain ( ) ; $ port = ':' . self :: getPort ( ) ; $ port = ( ( $ port == ':80' ) || ( $ port == ':443' ) ) ? '' : $ port ; $ uri = self :: getUri ( ) ; return $ protocol . '://' . $ host . $ port . $ uri ; }
12905	public function index ( FilterRequest $ request ) { $ limit = $ request -> request -> get ( 'limit' , 15 ) ; $ limit = ( $ limit > 49 ) ? 50 : $ limit ; $ filter = $ this -> repository -> filter ( $ request ) ; if ( $ this -> list || $ request -> request -> get ( 'search_type' ) == 'list' ) { $ resources = $ filter -> get ( 1000 ) ; } else { $ resources = $ filter -> paginate ( $ limit ) ; } if ( $ resources -> count ( ) < 1 ) { } return $ this -> success ( $ resources ) ; }
1642	public static function fromString ( string $ string , Ellipsoid $ ellipsoid = null ) : Coordinate { $ string = self :: mergeSecondsToMinutes ( $ string ) ; $ result = self :: parseDecimalMinutesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalMinutesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithoutCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } $ result = self :: parseDecimalDegreesWithCardinalLetters ( $ string , $ ellipsoid ) ; if ( $ result instanceof Coordinate ) { return $ result ; } throw new InvalidArgumentException ( 'Format of coordinates was not recognized' ) ; }
10520	public function constraint ( $ string ) { if ( ! isset ( $ this -> tbl_constraint [ 'other' ] ) ) { $ this -> tbl_constraint [ 'other' ] = [ ] ; } $ this -> tbl_constraint [ 'other' ] [ ] = $ string ; return $ this ; }
11121	protected function pendingMigrations ( array $ files , array $ ran ) : array { $ array = [ ] ; foreach ( $ files as $ file ) { if ( ! in_array ( $ this -> getMigrationName ( $ file ) , $ ran , true ) ) { $ array [ ] = $ file ; } } return $ array ; }
4101	public function map ( $ mapping , array $ config = array ( ) ) { if ( is_array ( $ mapping ) ) $ mapping = new Mapping ( $ mapping ) ; $ mapping -> config ( $ config ) ; try { $ type = $ mapping -> config ( 'type' ) ; } catch ( \ Exception $ e ) { } if ( isset ( $ type ) && ! $ this -> passesTypeConstraint ( $ type ) ) { throw new Exception ( "Cant create mapping due to type constraint mismatch" ) ; } return $ this -> request ( '_mapping' , 'PUT' , $ mapping -> export ( ) , true ) ; }
6816	public function isSameAs ( Adjustment $ adjustment ) : bool { return $ this -> name === $ adjustment -> getName ( ) && $ this -> rate === $ adjustment -> getRate ( ) ; }
2520	public function queuePlacePnr ( RequestOptions \ QueuePlacePnrOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'Queue_PlacePNR' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
2785	private function extractFail ( $ output ) { if ( preg_match ( '%##teamcity\[testFailed.*\]%' , $ output , $ matches ) ) { preg_match ( "/##teamcity\\[testFailed.*name='(.*)' message='(.*)' details='\\s*(.*)' flowId=.*/" , $ output , $ matches ) ; $ matches = $ this -> replaceEscapedChars ( $ matches ) ; $ fail = sprintf ( 'Test Name: %s' . PHP_EOL . 'Failure Message: %s' . PHP_EOL . 'Trace:' . PHP_EOL . '%s' , $ matches [ 1 ] , $ matches [ 2 ] , $ matches [ 3 ] ) ; return $ fail ; } return 'No failure output was detected by Humbug, but a failure was reported by PHPUnit.' ; }
5528	protected function createCodeForMethods ( $ methods ) { $ code = '' ; $ methods = array_merge ( $ methods , $ this -> reflection -> getMethods ( ) ) ; foreach ( $ methods as $ method ) { if ( $ this -> isConstructorOrDeconstructor ( $ method ) ) { continue ; } $ mock_reflection = new SimpleReflection ( $ this -> mock_base ) ; if ( in_array ( $ method , $ mock_reflection -> getMethods ( ) ) ) { continue ; } $ code .= ' ' . $ this -> reflection -> getSignature ( $ method ) ; if ( $ mock_reflection -> isAbstract ( ) ) { $ code .= ";\n" ; } else { $ code .= " {\n" ; $ code .= " return \$this->invoke(\"$method\", func_get_args());\n" ; $ code .= " }\n" ; } } return $ code ; }
3190	public function getLastRegisteredTimestamp ( ) { $ points = $ this -> timeLine -> getPoints ( ) ; $ length = count ( $ points ) ; $ last = false ; if ( $ length ) { $ last = end ( $ points ) -> getTimestamp ( ) ; } return $ last ; }
1152	public function selector ( $ selector ) { $ this -> selector = is_null ( $ selector ) ? $ this -> selector : $ selector ; return $ this ; }
5090	public function execute ( $ path ) { if ( ! file_exists ( $ path ) || ! is_readable ( $ path ) ) throw new SquidException ( "The file at [$path] is unreadable or doesn't exists" ) ; $ data = file_get_contents ( $ path ) ; $ result = $ this -> connector -> bulk ( ) -> add ( $ data ) -> executeAll ( ) ; return ( bool ) $ result ; }
12158	public function getObjectLevel ( ) { if ( $ this -> isPrimaryType ) { return 1 ; } $ parents = $ this -> collectorItem -> parents ; if ( ! empty ( $ parents ) ) { $ maxLevel = 1 ; foreach ( $ parents as $ rel ) { if ( get_class ( $ rel -> parent ) === get_class ( $ this ) ) { continue ; } $ newLevel = $ rel -> parent -> objectLevel + 1 ; if ( $ newLevel > $ maxLevel ) { $ maxLevel = $ newLevel ; } } return $ maxLevel ; } return 1 ; }
10775	public function loginRequired ( $ checkAjax = true ) { $ request = Yii :: $ app -> getRequest ( ) ; if ( $ this -> enableSession && ( ! $ checkAjax || ! $ request -> getIsAjax ( ) ) ) { $ this -> setReturnUrl ( $ request -> getUrl ( ) ) ; } if ( $ this -> loginUrl !== null ) { $ loginUrl = ( array ) $ this -> loginUrl ; if ( $ loginUrl [ 0 ] !== Yii :: $ app -> requestedRoute ) { return Yii :: $ app -> getResponse ( ) -> redirect ( $ this -> loginUrl ) ; } } throw new ForbiddenHttpException ( Yii :: t ( 'yii' , 'Login Required' ) ) ; }
7859	private function registerWorkflowRunnersHook ( ) { $ this -> app -> afterResolving ( function ( WorkflowRunner $ runner , $ app ) { $ runner -> setWorkflow ( $ app [ 'cerbero.workflow' ] ) ; } ) ; }
4982	public function setOptions ( $ options ) { foreach ( $ options as $ key => $ val ) { $ this -> setOption ( $ key , $ val ) ; } }
8832	public function tokenise ( $ pattern , $ expand = false ) { preg_match_all ( ' / (?<class_U_explicit>\\\U) \{ (?<class_U_repetition>[0-9]+) \} | (?<class_U_implicit>\\\U) | \[ (?<range_token_explicit>[^]]+) \] \{ (?<range_repetition>[0-9]+) \} | \[ (?<range_token_implicit>[^]]+) \] | (?<literal_string>[^\\\[]+) /x ' , $ pattern , $ matches , \ PREG_SET_ORDER ) ; $ tokens = [ ] ; foreach ( $ matches as $ match ) { if ( ! empty ( $ match [ 'class_U_explicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => ( int ) $ match [ 'class_U_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'class_U_implicit' ] ) ) { $ token = [ 'type' => 'class' , 'class' => static :: CLASS_UPPERCASE_UNAMBIGUOUS , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = 'ABCDEFGHKMNOPRSTUVWXYZ23456789' ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_explicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_explicit' ] , 'repetition' => ( int ) $ match [ 'range_repetition' ] ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_explicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'range_token_implicit' ] ) ) { $ token = [ 'type' => 'range' , 'token' => $ match [ 'range_token_implicit' ] , 'repetition' => 1 ] ; if ( $ expand ) { $ token [ 'haystack' ] = static :: expandRange ( $ match [ 'range_token_implicit' ] ) ; } $ tokens [ ] = $ token ; } else if ( ! empty ( $ match [ 'literal_string' ] ) ) { $ tokens [ ] = [ 'type' => 'literal' , 'string' => $ match [ 'literal_string' ] ] ; } } return $ tokens ; }
2962	public function serialflush ( ) { if ( ! $ this -> _ckOpened ( ) ) { return false ; } if ( fwrite ( $ this -> _dHandle , $ this -> _buffer ) !== false ) { $ this -> _buffer = "" ; return true ; } else { $ this -> _buffer = "" ; trigger_error ( "Error while sending message" , E_USER_WARNING ) ; return false ; } }
7144	public static function remove_author_meta_values ( ) { global $ blog_id ; if ( isset ( $ blog_id ) && ! empty ( $ blog_id ) ) { $ blogusers = get_users ( array ( 'blog_id' => $ blog_id ) ) ; foreach ( $ blogusers as $ user_object ) { delete_user_meta ( $ user_object -> ID , 'post_subscription' ) ; delete_user_meta ( $ user_object -> ID , 'comment_subscription' ) ; } } }
6635	public function bootstrap ( $ app ) { Yii :: setAlias ( '@wavecms' , '@vendor/mrstroz/yii2-wavecms' ) ; if ( $ app -> id === 'app-backend' || $ app -> id === 'app-frontend' ) { Yii :: setAlias ( '@frontWeb' , str_replace ( '/admin' , '' , Yii :: getAlias ( '@web' ) ) ) ; Yii :: setAlias ( '@frontWebroot' , str_replace ( '/public/admin' , '/public' , Yii :: getAlias ( '@webroot' ) ) ) ; } if ( $ app -> id === 'app-backend' ) { if ( ! Yii :: $ app -> user -> isGuest ) { Yii :: $ app -> language = Yii :: $ app -> user -> identity -> lang ; } } $ this -> initTranslations ( ) ; if ( $ app -> hasModule ( 'wavecms' ) && ( $ module = $ app -> getModule ( 'wavecms' ) ) instanceof Module ) { if ( $ app instanceof ConsoleApplication ) { $ module -> controllerNamespace = 'mrstroz\wavecms\commands' ; } else { $ module -> controllerNamespace = 'mrstroz\wavecms\controllers' ; if ( $ app -> id === 'app-backend' ) { Yii :: $ app -> errorHandler -> errorAction = $ module -> errorAction ; $ app -> set ( 'wavecms' , [ 'class' => 'mrstroz\wavecms\WavecmsComponent' , 'languages' => $ module -> languages ] ) ; $ app -> set ( 'cacheFrontend' , [ 'class' => 'yii\caching\FileCache' , 'cachePath' => Yii :: getAlias ( '@frontend' ) . '/runtime/cache' ] ) ; $ app -> set ( 'settings' , [ 'class' => 'yii2mod\settings\components\Settings' , ] ) ; Yii :: $ app -> assetManager -> appendTimestamp = true ; Yii :: $ app -> i18n -> translations [ 'yii2mod.settings' ] = [ 'class' => 'yii\i18n\PhpMessageSource' , 'basePath' => '@yii2mod/settings/messages' ] ; $ this -> initContainer ( $ module ) ; $ this -> initLanguages ( ) ; $ this -> initParams ( ) ; $ this -> initRoutes ( $ app , $ module ) ; $ this -> initNavigation ( ) ; } } } }
1413	public function resourceDoesNotExist ( string $ path ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_NOT_FOUND , $ this -> trans ( 'resource_not_found' , 'code' ) , $ this -> trans ( 'resource_not_found' , 'title' ) , $ this -> trans ( 'resource_not_found' , 'detail' ) , $ this -> pointer ( $ path ) ) ; }
8652	private function convertGetReportScheduleCount ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetReportScheduleCount' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetReportTypeList ( ) ) { $ reportTypeList = $ request -> getReportTypeList ( ) ; foreach ( $ reportTypeList -> getType ( ) as $ typeIndex => $ type ) { $ parameters [ 'ReportTypeList' . '.' . 'Type' . '.' . ( $ typeIndex + 1 ) ] = $ type ; } } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
10105	private function writeDefaultRowHeight ( ) { $ defaultRowHeight = $ this -> phpSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ; if ( $ defaultRowHeight < 0 ) { return ; } $ defaultRowHeight = ( int ) 20 * $ defaultRowHeight ; $ record = 0x0225 ; $ length = 0x0004 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , 1 , $ defaultRowHeight ) ; $ this -> append ( $ header . $ data ) ; }
194	public function sendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( ! isset ( $ options [ 'mimeType' ] ) ) { $ options [ 'mimeType' ] = FileHelper :: getMimeTypeByExtension ( $ filePath ) ; } if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } $ handle = fopen ( $ filePath , 'rb' ) ; $ this -> sendStreamAsFile ( $ handle , $ attachmentName , $ options ) ; return $ this ; }
3151	protected function continueInteraction ( RunnerServiceContext $ context ) { $ continue = false ; $ session = $ context -> getTestSession ( ) ; if ( $ session -> isRunning ( ) === true && $ session -> isTimeout ( ) === false ) { $ event = new QtiContinueInteractionEvent ( $ context , $ this ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; TestRunnerUtils :: beginCandidateInteraction ( $ session ) ; $ continue = true ; } else { $ this -> finish ( $ context ) ; } return $ continue ; }
3919	public static function convertUuidsOrPathsToMetaModels ( $ values ) { $ values = array_filter ( ( array ) $ values ) ; if ( empty ( $ values ) ) { return array ( 'bin' => array ( ) , 'value' => array ( ) , 'path' => array ( ) , 'meta' => array ( ) ) ; } foreach ( $ values as $ key => $ value ) { if ( ! ( Validator :: isUuid ( $ value ) ) ) { $ file = FilesModel :: findByPath ( $ value ) ? : Dbafs :: addResource ( $ value ) ; if ( ! $ file ) { throw new InvalidArgumentException ( 'Invalid value.' ) ; } $ values [ $ key ] = $ file -> uuid ; } } return self :: convertValuesToMetaModels ( $ values ) ; }
5791	public function isDeletable ( ) : bool { if ( in_array ( $ this -> title , self :: UNDELETABLE ) ) { return false ; } return ( PermissionsTableMapper :: getInstance ( ) ) -> isDeletable ( ) ; }
981	public function planCharge ( ) { return $ this -> charges ( ) -> whereIn ( 'type' , [ Charge :: CHARGE_RECURRING , Charge :: CHARGE_ONETIME ] ) -> where ( 'plan_id' , $ this -> plan_id ) -> orderBy ( 'created_at' , 'desc' ) -> first ( ) ; }
2705	public function execute ( ) { $ result = $ this -> resultJsonFactory -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ snippets = $ this -> config -> getVclSnippets ( Config :: VCL_AUTH_SNIPPET_PATH ) ; foreach ( $ snippets as $ key => $ value ) { $ name = Config :: FASTLY_MAGENTO_MODULE . '_basic_auth_' . $ key ; $ status = $ this -> api -> hasSnippet ( $ activeVersion , $ name ) ; if ( $ status == false ) { return $ result -> setData ( [ 'status' => false ] ) ; } } return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
920	private function fixDescription ( DocBlock $ doc ) { foreach ( $ doc -> getLines ( ) as $ index => $ line ) { if ( $ line -> containsATag ( ) ) { break ; } if ( $ line -> containsUsefulContent ( ) ) { $ next = $ doc -> getLine ( $ index + 1 ) ; if ( $ next -> containsATag ( ) ) { $ line -> addBlank ( ) ; break ; } } } }
7200	protected function detachSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> detachSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> detachSaleItemRecursively ( $ child ) ; } }
11072	public function setFloat ( string $ key , $ value , float $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( float ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
6917	public function isEmpty ( ) { return empty ( $ this -> subject ) || ( empty ( $ this -> customMessage ) && empty ( $ this -> paymentMessage ) && empty ( $ this -> shipmentMessage ) ) ; }
3164	public function endTimer ( RunnerServiceContext $ context , $ duration = null , $ timestamp = null ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ session -> endItemTimer ( $ duration , $ timestamp ) ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'endTimer' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } return true ; }
12917	public function sumValor ( ) { $ tableGateway = new TableGateway ( $ this -> tableName , $ this -> dbAdapter ) ; $ sql = $ tableGateway -> getSql ( ) ; $ select = $ sql -> select ( ) -> columns ( array ( 'sum' => new Expression ( 'SUM(valor)' ) ) ) ; return $ tableGateway -> selectWith ( $ select ) -> current ( ) ; }
9689	static function getDataType ( $ value ) { switch ( $ value ) { case "string" : return self :: $ STRING ; case "double" : return self :: $ DOUBLE ; case "float" : return self :: $ FLOAT ; case "integer" : return self :: $ INTEGER ; case "boolean" : return self :: $ BOOLEAN ; case "timestamp" : return self :: $ TIMESTAMP ; case "json" : return self :: $ JSON ; default : return null ; } }
2390	private function findLegendForField ( array & $ config , string $ field ) { foreach ( $ config as $ legend => $ group ) { if ( \ in_array ( $ field , $ group [ 'fields' ] , true ) ) { return $ legend ; } } return false ; }
9987	private function mapBorderStyle ( $ borderStyle ) { switch ( $ borderStyle ) { case Border :: BORDER_NONE : return 'none' ; case Border :: BORDER_DASHDOT : return '1px dashed' ; case Border :: BORDER_DASHDOTDOT : return '1px dotted' ; case Border :: BORDER_DASHED : return '1px dashed' ; case Border :: BORDER_DOTTED : return '1px dotted' ; case Border :: BORDER_DOUBLE : return '3px double' ; case Border :: BORDER_HAIR : return '1px solid' ; case Border :: BORDER_MEDIUM : return '2px solid' ; case Border :: BORDER_MEDIUMDASHDOT : return '2px dashed' ; case Border :: BORDER_MEDIUMDASHDOTDOT : return '2px dotted' ; case Border :: BORDER_MEDIUMDASHED : return '2px dashed' ; case Border :: BORDER_SLANTDASHDOT : return '2px dashed' ; case Border :: BORDER_THICK : return '3px solid' ; case Border :: BORDER_THIN : return '1px solid' ; default : return '1px solid' ; } }
10264	public function getBank ( ) { $ bank_account = new Entities \ BankAccount ; $ bank_account -> type = $ this -> fromArray ( [ 'Checking' , 'Savings' ] ) ; $ bank_account -> name = $ this -> fromArray ( [ 'First National' , 'Arvest' , 'Regions' , 'Metropolitan' , 'Wells Fargo' ] ) ; $ bank_account -> account = $ this -> getInteger ( '1000' , '999999999' ) ; $ bank_account -> routing = $ this -> getBankNumber ( 'Routing' ) ; return $ bank_account ; }
816	private function getMeaningfulSequence ( Tokens $ tokens , $ start , $ end ) { $ sequence = [ ] ; $ index = $ start ; while ( $ index < $ end ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; if ( $ index >= $ end || null === $ index ) { break ; } $ sequence [ ] = $ tokens [ $ index ] ; } return Tokens :: fromArray ( $ sequence ) ; }
10493	public function mul ( $ value ) { $ value = Cast :: Float ( $ value ) ; if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * $ value ) ; }
8236	protected function checkServerConfiguration ( ) { $ pico = $ this -> picoAuth -> getPico ( ) ; $ configDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfigDir ( ) ) ; $ configFile = $ configDir . "/config.yml" ; $ contentDir = $ pico -> getBaseUrl ( ) . basename ( $ pico -> getConfig ( 'content_dir' ) ) ; $ indexFile = $ contentDir . "/index" . $ pico -> getConfig ( 'content_ext' ) ; $ urls = array ( 'dir_listing' => $ configDir , 'config_file' => $ configFile , 'content_file' => $ indexFile ) ; $ this -> httpsTest ( ) ; $ this -> webRootDirsTest ( ) ; $ this -> picoAuth -> addOutput ( "installer_urltest" , $ urls ) ; }
8764	private function createUniqueFilename ( $ filename ) { $ full_size_dir = config ( 'dropzoner.upload-path' ) ; $ full_image_path = $ full_size_dir . $ filename . '.jpg' ; if ( \ File :: exists ( $ full_image_path ) ) { $ image_token = substr ( sha1 ( mt_rand ( ) ) , 0 , 5 ) ; return $ filename . '-' . $ image_token ; } return $ filename ; }
770	public function getIterator ( ) { $ value = $ this -> getValue ( ) ; if ( $ value instanceof QueryInterface ) { throw new InvalidConfigException ( 'The ArrayExpression class can not be iterated when the value is a QueryInterface object' ) ; } if ( $ value === null ) { $ value = [ ] ; } return new \ ArrayIterator ( $ value ) ; }
2802	public static function parseBooleanValue ( $ value ) : bool { if ( \ is_bool ( $ value ) ) { return $ value ; } if ( \ is_string ( $ value ) ) { $ value = \ strtolower ( $ value ) ; return 'true' === $ value ; } if ( \ is_object ( $ value ) || \ is_array ( $ value ) || \ is_callable ( $ value ) ) { return false ; } return ( bool ) $ value ; }
4022	protected function getHelpForWidget ( $ widget ) { if ( $ GLOBALS [ 'TL_CONFIG' ] [ 'showHelp' ] && $ widget -> description ) { return sprintf ( '<p class="tl_help tl_tip%s">%s</p>' , $ widget -> tl_class , $ widget -> description ) ; } return '' ; }
6872	private function initializeRelayPoint ( ShipmentInterface $ shipment ) { if ( null === $ method = $ shipment -> getMethod ( ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } $ gateway = $ this -> registry -> getGateway ( $ method -> getGatewayName ( ) ) ; if ( ! $ gateway -> supports ( GatewayInterface :: CAPABILITY_RELAY ) ) { if ( null !== $ shipment -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( null ) ; } return ; } if ( null !== $ relayPoint = $ shipment -> getSale ( ) -> getRelayPoint ( ) ) { $ shipment -> setRelayPoint ( $ relayPoint ) ; } }
12819	public static function setPermission ( array $ paths ) { foreach ( $ paths as $ path => $ permission ) { echo "chmod('$path', $permission)..." ; if ( is_dir ( $ path ) || is_file ( $ path ) ) { chmod ( $ path , octdec ( $ permission ) ) ; echo "done.\n" ; } else { echo "file not found.\n" ; } } }
1959	public static function encode ( $ strDomain ) { if ( $ strDomain == '' ) { return '' ; } $ objPunycode = new Punycode ( ) ; try { return $ objPunycode -> encode ( $ strDomain ) ; } catch ( LabelOutOfBoundsException $ e ) { return '' ; } }
1277	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trackRequest = $ xml -> appendChild ( $ xml -> createElement ( 'TrackRequest' ) ) ; $ trackRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ trackRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'Track' ) ) ; if ( null !== $ this -> requestOption ) { $ request -> appendChild ( $ xml -> createElement ( 'RequestOption' , $ this -> requestOption ) ) ; } if ( null !== $ this -> trackingNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ this -> trackingNumber ) ) ; } if ( $ this -> isMailInnovations ( ) ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'IncludeMailInnovationIndicator' ) ) ; } if ( null !== $ this -> referenceNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) -> appendChild ( $ xml -> createElement ( 'Value' , $ this -> referenceNumber ) ) ; } if ( null !== $ this -> shipperNumber ) { $ trackRequest -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ this -> shipperNumber ) ) ; } if ( null !== $ this -> beginDate || null !== $ this -> endDate ) { $ DateRange = $ xml -> createElement ( 'PickupDateRange' ) ; if ( null !== $ this -> beginDate ) { $ beginDate = $ this -> beginDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'BeginDate' , $ beginDate ) ) ; } if ( null !== $ this -> endDate ) { $ endDate = $ this -> endDate -> format ( 'Ymd' ) ; $ DateRange -> appendChild ( $ xml -> createElement ( 'EndDate' , $ endDate ) ) ; } $ trackRequest -> appendChild ( $ DateRange ) ; } return $ xml -> saveXML ( ) ; }
1647	public function calculateBearing ( Coordinate $ point1 , Coordinate $ point2 ) : float { $ lat1 = deg2rad ( $ point1 -> getLat ( ) ) ; $ lat2 = deg2rad ( $ point2 -> getLat ( ) ) ; $ lng1 = deg2rad ( $ point1 -> getLng ( ) ) ; $ lng2 = deg2rad ( $ point2 -> getLng ( ) ) ; $ y = sin ( $ lng2 - $ lng1 ) * cos ( $ lat2 ) ; $ x = cos ( $ lat1 ) * sin ( $ lat2 ) - sin ( $ lat1 ) * cos ( $ lat2 ) * cos ( $ lng2 - $ lng1 ) ; $ bearing = rad2deg ( atan2 ( $ y , $ x ) ) ; if ( $ bearing < 0 ) { $ bearing = fmod ( $ bearing + 360 , 360 ) ; } return $ bearing ; }
1664	protected function getCountries ( ) { if ( sizeof ( $ this -> countries ) == 0 ) { $ this -> countries = json_decode ( file_get_contents ( __DIR__ . '/Models/countries.json' ) , true ) ; } return $ this -> countries ; }
2072	public function getAllowedArchives ( ) { if ( $ this -> User -> isAdmin ) { $ objArchive = Contao \ NewsArchiveModel :: findAll ( ) ; } else { $ objArchive = Contao \ NewsArchiveModel :: findMultipleByIds ( $ this -> User -> news ) ; } $ return = array ( ) ; if ( $ objArchive !== null ) { while ( $ objArchive -> next ( ) ) { $ return [ $ objArchive -> id ] = $ objArchive -> title ; } } return $ return ; }
10336	public static function getDistanceY ( Worksheet $ sheet , $ startRow = 1 , $ startOffsetY = 0 , $ endRow = 1 , $ endOffsetY = 0 ) { $ distanceY = 0 ; for ( $ row = $ startRow ; $ row <= $ endRow ; ++ $ row ) { $ distanceY += self :: sizeRow ( $ sheet , $ row ) ; } $ distanceY -= ( int ) floor ( self :: sizeRow ( $ sheet , $ startRow ) * $ startOffsetY / 256 ) ; $ distanceY -= ( int ) floor ( self :: sizeRow ( $ sheet , $ endRow ) * ( 1 - $ endOffsetY / 256 ) ) ; return $ distanceY ; }
4977	public function send ( \ Zend \ Mail \ Message $ message ) { $ options = $ this -> options ; $ filename = call_user_func ( $ options -> getCallback ( ) , $ this ) ; $ file = $ options -> getPath ( ) . DIRECTORY_SEPARATOR . $ filename ; $ contents = $ message -> toString ( ) ; $ umask = umask ( ) ; umask ( 022 ) ; if ( false === file_put_contents ( $ file , $ contents , LOCK_EX ) ) { throw new RuntimeException ( sprintf ( 'Unable to write mail to file (directory "%s")' , $ options -> getPath ( ) ) ) ; } umask ( $ umask ) ; $ this -> lastFile = $ file ; }
9556	public function add ( ParameterClosure $ closure ) { $ this -> prefixes [ $ closure -> prefix ] [ $ closure -> parameterName ] = $ closure ; return $ this ; }
5347	public function revertSnapshotToOtherVps ( $ sourceVpsName , $ snapshotName , $ destinationVpsName ) { return $ this -> call ( self :: SERVICE , 'revertSnapshotToOtherVps' , [ $ sourceVpsName , $ snapshotName , $ destinationVpsName ] ) ; }
1091	public function aggregate ( $ function , $ columns = array ( '*' ) ) { if ( ! isset ( $ this -> groups ) ) $ this -> reOrderBy ( null ) ; return parent :: aggregate ( $ function , $ columns ) ; }
3444	public function offsetGet ( $ offset ) { $ fieldValue = isset ( $ this -> fields [ $ offset ] ) ? $ this -> fields [ $ offset ] : null ; $ accessor = $ this -> getAccessor ( $ offset ) ; if ( $ accessor ) { return $ this -> $ accessor ( $ fieldValue ) ; } $ accessorForLanguageField = $ this -> getAccessorForLanguageField ( $ offset ) ; if ( $ accessorForLanguageField ) { return $ this -> $ accessorForLanguageField ( $ offset ) ; } return $ fieldValue ; }
6091	public function removeMoodboard ( $ id ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> delete ( 'v1/moodboards/' . $ id . '' , $ parameters ) ; $ result = new MoodboardResponse ( $ result ) ; return $ result ; }
4644	public function stop ( Job $ job , $ timeout = 10 ) { foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { try { $ this -> docker -> getContainerManager ( ) -> stop ( $ service -> getContainer ( ) , [ 't' => $ timeout ] ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) != 304 ) { throw $ e ; } } $ this -> docker -> getContainerManager ( ) -> remove ( $ service -> getContainer ( ) , [ 'v' => true , 'force' => true ] ) ; $ service -> setContainer ( null ) ; } } }
11349	public function setData ( $ data ) { $ data = $ this -> transformer -> encode ( $ data ) ; foreach ( $ this -> fields as $ field ) { if ( isset ( $ data [ $ field -> getName ( ) ] ) ) { $ field -> setData ( $ data [ $ field -> getName ( ) ] ) ; } } }
6478	protected function encodingIsSupported ( string $ encoding ) : bool { $ lowercaseSupportedEncodings = array_map ( 'strtolower' , $ this -> getSupportedEncodings ( ) ) ; $ lowercaseEncoding = strtolower ( $ encoding ) ; return in_array ( $ lowercaseEncoding , $ lowercaseSupportedEncodings , true ) ; }
12358	private function registerCalc ( $ period ) { $ ctx = new \ Praxigento \ Core \ Data ( ) ; $ ctx -> set ( PCalcReg :: IN_CALC_TYPE_CODE , Cfg :: CODE_TYPE_CALC_FORECAST_PHASE1 ) ; $ ctx -> set ( PCalcReg :: IN_PERIOD , $ period ) ; $ res = $ this -> zCalcReg -> exec ( $ ctx ) ; $ result = $ res -> get ( PCalcReg :: OUT_CALC_ID ) ; return $ result ; }
6166	protected function writeProgress ( $ progress ) { $ this -> progress = ! $ this -> flawless && $ progress === '.' ? $ this -> formatWithColor ( 'fg-red' , '!' ) : $ progress ; ++ $ this -> numTestsRun ; }
6740	public function front ( ) { add_action ( 'wp' , function ( ) { App :: setCurrentID ( 'EFG' ) ; if ( App :: main ( ) -> is_single ( ) && ! is_preview ( ) ) { $ this -> add_scripts ( 'customRatingGrifus' ) ; $ this -> add_styles ( ) ; } elseif ( is_home ( ) || is_category ( ) || is_archive ( ) || is_search ( ) ) { $ this -> add_scripts ( 'customRatingGrifusHome' ) ; } } ) ; }
10210	public function createAction ( ) { $ request = $ this -> getRequest ( ) ; $ prg = $ this -> prg ( $ request -> getRequestUri ( ) , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } elseif ( $ prg === false ) { return $ this -> viewModel ; } if ( $ this -> contactForm -> setData ( $ prg ) -> isValid ( ) ) { $ contact = $ this -> contactForm -> getData ( ) ; $ this -> commandService -> persist ( $ contact ) ; $ this -> viewModel -> setVariable ( 'contact' , $ contact ) ; } return $ this -> viewModel ; }
508	protected function composeFields ( $ id = null , $ data = null ) { $ fields = $ this -> writeCallback ? call_user_func ( $ this -> writeCallback , $ this ) : [ ] ; if ( $ id !== null ) { $ fields [ 'id' ] = $ id ; } if ( $ data !== null ) { $ fields [ 'data' ] = $ data ; } return $ fields ; }
5878	protected static function updateIndex ( \ TYPO3 \ CMS \ Core \ Resource \ File $ file = null , $ width , $ height , array $ metadata = [ ] ) { if ( count ( $ metadata ) > 0 ) { $ metadataRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ Index \ MetaDataRepository :: class ) ; $ currentMetadata = $ metadataRepository -> findByFile ( $ file ) ; $ newMetadata = [ ] ; foreach ( $ currentMetadata as $ key => $ value ) { if ( ! empty ( $ metadata [ $ key ] ) ) { if ( $ key === 'creator_tool' && MathUtility :: canBeInterpretedAsFloat ( $ metadata [ $ key ] ) ) { continue ; } $ newMetadata [ $ key ] = $ metadata [ $ key ] ; } } unset ( $ newMetadata [ 'width' ] ) ; unset ( $ newMetadata [ 'height' ] ) ; $ newMetadata [ 'unit' ] = 'px' ; $ mapping = [ 'color_space' => 'ColorSpace' , 'content_creation_date' => 'DateTimeOriginal' , 'creator' => 'IPTCCreator|Company' , 'creator_tool' => 'Model|Make|Software' , 'description' => 'ImageDescription' , 'keywords' => 'IPTCKeywords' , 'latitude' => 'GPSLatitudeDecimal' , 'longitude' => 'GPSLongitudeDecimal' , 'location_city' => 'IPTCCity' , 'location_country' => 'IPTCCountry' , 'location_region' => 'IPTCRegion' , 'note' => 'IPTCLocation' , 'publisher' => 'IPTCCredit' , 'source' => 'IPTCSource' , 'title' => 'IPTCTitle' , ] ; foreach ( $ mapping as $ falKey => $ metadataKeyMapping ) { if ( ! empty ( $ newMetadata [ $ falKey ] ) ) { continue ; } $ metatadaKeys = explode ( '|' , $ metadataKeyMapping ) ; foreach ( $ metatadaKeys as $ metadataKey ) { $ value = null ; if ( isset ( $ metadata [ $ metadataKey ] ) ) { $ value = trim ( $ metadata [ $ metadataKey ] ) ; if ( ord ( $ value ) === 1 ) $ value = null ; switch ( $ metadataKey ) { case 'ColorSpace' : if ( $ value == 1 ) { $ value = 'RGB' ; } else { $ value = null ; } break ; case 'DateTimeOriginal' : $ value = strtotime ( $ value ) ; break ; } } if ( ! empty ( $ value ) ) { $ newMetadata [ $ falKey ] = $ value ; break ; } } } $ metadataRepository -> update ( $ file -> getUid ( ) , $ newMetadata ) ; } }
2852	public function deleteTemplateHintsDbConfigs ( ) { $ configTable = Mage :: getResourceModel ( 'core/config' ) -> getMainTable ( ) ; $ db = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ db -> delete ( $ configTable , "path like 'dev/debug/template_hints%'" ) ; }
12393	public function onSiteSaved ( SiteSavedEvent $ event ) { $ fs = new Filesystem ( ) ; $ fs -> mirror ( $ this -> configurationHandler -> uploadAssetsDir ( ) , $ this -> configurationHandler -> uploadAssetsDirProduction ( ) ) ; }
3047	protected function getToolStates ( ) { $ toolStates = $ this -> getRunnerService ( ) -> getToolsStates ( $ this -> getServiceContext ( ) ) ; array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_decode ( $ toolState ) ; } ) ; return $ toolStates ; }
10508	private function registerChecker ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogChecker :: class , Utilities \ LogChecker :: class ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.checker' , Contracts \ Utilities \ LogChecker :: class ) ; }
7346	static public function calculateReceivedQuantity ( SupplierOrderItemInterface $ item ) { $ quantity = 0 ; foreach ( $ item -> getOrder ( ) -> getDeliveries ( ) as $ delivery ) { foreach ( $ delivery -> getItems ( ) as $ deliveryItem ) { if ( $ item === $ deliveryItem -> getOrderItem ( ) ) { $ quantity += $ deliveryItem -> getQuantity ( ) ; continue 2 ; } } } return $ quantity ; }
4357	protected function processLog ( ) { $ str = '' ; foreach ( $ this -> data [ 'log' ] as $ entry ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; if ( $ this -> channelTest ( $ channel ) ) { $ str .= $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } } return $ str ; }
2559	protected function loadPaymentSupplementaryData ( MopInfo $ options ) { foreach ( $ options -> paySupData as $ paySupData ) { $ this -> paymentModule -> paymentSupplementaryData [ ] = new PaymentSupplementaryData ( $ paySupData -> function , $ paySupData -> data ) ; } }
10223	public function menuFor ( $ model , $ modelId = 0 , ModelConfig $ config = null ) { if ( is_null ( $ this -> aujaConfigurator ) ) { throw new \ LogicException ( 'Auja not initialized. Call Auja::init first.' ) ; } $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ modelId == 0 ) { $ menu = $ this -> noAssociationsMenuFor ( $ modelName , $ config ) ; } else { $ menu = $ this -> buildComplexIndexMenu ( $ modelName , $ modelId , $ config ) ; } return $ menu ; }
165	public static function serialize ( array $ links ) { foreach ( $ links as $ rel => $ link ) { if ( is_array ( $ link ) ) { foreach ( $ link as $ i => $ l ) { $ link [ $ i ] = $ l instanceof self ? array_filter ( ( array ) $ l ) : [ 'href' => $ l ] ; } $ links [ $ rel ] = $ link ; } elseif ( ! $ link instanceof self ) { $ links [ $ rel ] = [ 'href' => $ link ] ; } } return $ links ; }
2085	public static function addFiles ( $ files ) { foreach ( $ files as $ name => $ file ) { self :: addFile ( $ name , $ file ) ; } }
102	public function findFile ( $ class ) { if ( isset ( $ this -> classMap [ $ class ] ) ) { return $ this -> classMap [ $ class ] ; } if ( $ this -> classMapAuthoritative || isset ( $ this -> missingClasses [ $ class ] ) ) { return false ; } if ( null !== $ this -> apcuPrefix ) { $ file = apcu_fetch ( $ this -> apcuPrefix . $ class , $ hit ) ; if ( $ hit ) { return $ file ; } } $ file = $ this -> findFileWithExtension ( $ class , '.php' ) ; if ( false === $ file && defined ( 'HHVM_VERSION' ) ) { $ file = $ this -> findFileWithExtension ( $ class , '.hh' ) ; } if ( null !== $ this -> apcuPrefix ) { apcu_add ( $ this -> apcuPrefix . $ class , $ file ) ; } if ( false === $ file ) { $ this -> missingClasses [ $ class ] = true ; } return $ file ; }
12253	public function dump ( ) { $ dom = new DOMDocument ( '1.0' ) ; $ dom -> preserveWhiteSpace = false ; $ dom -> formatOutput = true ; $ dom -> loadXML ( $ this -> asXML ( ) ) ; return $ dom -> saveXML ( ) ; }
6971	protected function syncLineWithResult ( Model \ DocumentLineInterface $ line , Amount $ result ) { if ( $ line -> getUnit ( ) !== $ result -> getUnit ( ) ) { $ line -> setUnit ( $ result -> getUnit ( ) ) ; $ this -> changed = true ; } if ( $ line -> getGross ( ) !== $ result -> getGross ( ) ) { $ line -> setGross ( $ result -> getGross ( ) ) ; $ this -> changed = true ; } if ( $ line -> getDiscount ( ) !== $ result -> getDiscount ( ) ) { $ line -> setDiscount ( $ result -> getDiscount ( ) ) ; $ this -> changed = true ; } $ discountRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getDiscountAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ discountRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ discountRates !== $ line -> getDiscountRates ( ) ) { $ line -> setDiscountRates ( $ discountRates ) ; $ this -> changed = true ; } if ( $ line -> getBase ( ) !== $ result -> getBase ( ) ) { $ line -> setBase ( $ result -> getBase ( ) ) ; $ this -> changed = true ; } if ( $ line -> getTax ( ) !== $ result -> getTax ( ) ) { $ line -> setTax ( $ result -> getTax ( ) ) ; $ this -> changed = true ; } $ taxRates = [ ] ; if ( ! empty ( $ adjustments = $ result -> getTaxAdjustments ( ) ) ) { foreach ( $ adjustments as $ adjustment ) { $ taxRates [ ] = $ adjustment -> getRate ( ) ; } } if ( $ taxRates !== $ line -> getTaxRates ( ) ) { $ line -> setTaxRates ( $ taxRates ) ; $ this -> changed = true ; } if ( $ line -> getTotal ( ) !== $ result -> getTotal ( ) ) { $ line -> setTotal ( $ result -> getTotal ( ) ) ; $ this -> changed = true ; } }
5650	private function parseArgument ( & $ arguments ) { $ argument = array_shift ( $ arguments ) ; if ( preg_match ( '/^-(\w)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^-(\w)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } elseif ( preg_match ( '/^--(\w+)=(.+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ matches [ 2 ] ) ; } elseif ( preg_match ( '/^--(\w+)$/' , $ argument , $ matches ) ) { return array ( $ matches [ 1 ] , $ this -> nextNonFlagElseTrue ( $ arguments ) ) ; } }
6319	public function execute ( ) { $ this -> preExecute ( ) ; $ result = $ this -> connection -> execute ( $ this -> getSql ( ) ) ; $ this -> postExecute ( ) ; return $ result ; }
9343	public function addRow ( array $ arr_row ) { if ( count ( $ this -> arr ) == $ this -> size -> rows ) { throw new \ OutOfRangeException ( sprintf ( 'You cannot add another row! Max number of rows is %d' , $ this -> size -> rows ) ) ; } if ( count ( $ arr_row ) != $ this -> size -> cols ) { throw new \ InvalidArgumentException ( 'New row must have same amout of columns than defined into the size matrix' ) ; } $ this -> arr [ ] = $ arr_row ; return $ this ; }
11795	public function setAttachment ( $ file = '' , $ clear = false ) { if ( true === $ clear ) { $ this -> clear ( 'text' ) ; } if ( is_array ( $ file ) ) { foreach ( $ file as $ _f ) { if ( file_exists ( $ _f ) ) { $ this -> attachment [ ] = $ _f ; } } } else { if ( file_exists ( $ file ) ) { $ this -> attachment [ ] = $ file ; } } return $ this ; }
1701	protected function decToUnix ( $ intTime , $ intDate ) { return mktime ( ( $ intTime & 0xf800 ) >> 11 , ( $ intTime & 0x07e0 ) >> 5 , ( $ intTime & 0x001f ) << 1 , ( $ intDate & 0x01e0 ) >> 5 , ( $ intDate & 0x001f ) , ( ( $ intDate & 0xfe00 ) >> 9 ) + 1980 ) ; }
8615	public function setSalesRank ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'SalesRank' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10195	public static function getPrettyQueryLog ( $ connection = "" ) { $ return_queries = [ ] ; $ queries = Capsule :: connection ( $ connection ) -> getQueryLog ( ) ; foreach ( $ queries as $ query ) { $ query_pattern = str_replace ( '?' , "'%s'" , $ query [ 'query' ] ) ; $ return_queries [ ] = vsprintf ( $ query_pattern , $ query [ 'bindings' ] ) ; } return $ return_queries ; }
410	public function setHostInfo ( $ value ) { $ this -> _hostName = null ; $ this -> _hostInfo = $ value === null ? null : rtrim ( $ value , '/' ) ; }
8783	protected function publishes ( array $ paths , $ group = null ) { $ this -> ensurePublishArrayInitialized ( $ class = static :: class ) ; static :: $ publishes [ $ class ] = array_merge ( static :: $ publishes [ $ class ] , $ paths ) ; if ( $ group ) { $ this -> addPublishGroup ( $ group , $ paths ) ; } }
12334	private function _checkPasswordIsGood ( ) : bool { $ sLogin = self :: $ _sLogin ; $ sPassword = Config :: get ( 'security' ) -> users -> $ sLogin -> password ; if ( $ sPassword == self :: $ _sPassword ) { return true ; } else if ( $ sPassword == md5 ( self :: $ _sPassword ) ) { return true ; } else { return false ; } }
5533	public function paintRectangleStart ( $ node , $ horiz , $ vert ) { $ name = $ node -> getName ( ) ; $ description = $ node -> getDescription ( ) ; $ status = $ node -> getStatus ( ) ; echo "<div title=\"$name: $description\" class=\"$status\" style=\"width:{$horiz}%;height:{$vert}%\">" ; }
2890	public function onModelLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ model = $ observer -> getData ( 'object' ) ; $ this -> getRequestInfo ( ) -> addModel ( $ model ) ; }
7971	public function getIncoming ( $ domain , $ id ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( $ id !== 0 && ! $ id ) throw new BadMethodCallException ( 'Parameter $id is missing.' ) ; $ id = intval ( $ id ) ; try { $ r = $ this -> get ( 'sms/' . $ domain . '/incoming/' . $ id ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new SmsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
2286	protected static function agent ( ) { $ ua = static :: get ( 'httpUserAgent' ) ; $ return = new \ stdClass ( ) ; $ return -> string = $ ua ; $ os = 'unknown' ; $ mobile = false ; $ browser = 'other' ; $ shorty = '' ; $ version = '' ; $ engine = '' ; foreach ( Config :: get ( 'os' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ os = $ v [ 'os' ] ; $ mobile = $ v [ 'mobile' ] ; break ; } } $ return -> os = $ os ; foreach ( Config :: get ( 'browser' ) as $ k => $ v ) { if ( stripos ( $ ua , $ k ) !== false ) { $ browser = $ v [ 'browser' ] ; $ shorty = $ v [ 'shorty' ] ; $ version = preg_replace ( $ v [ 'version' ] , '$1' , $ ua ) ; $ engine = $ v [ 'engine' ] ; break ; } } $ versions = explode ( '.' , $ version ) ; $ version = $ versions [ 0 ] ; $ return -> class = $ os . ' ' . $ browser . ' ' . $ engine ; if ( $ version != '' ) { $ return -> class .= ' ' . $ shorty . $ version ; } if ( $ os == 'android' && $ engine != 'presto' && stripos ( $ ua , 'mobile' ) === false ) { $ mobile = false ; } if ( $ mobile ) { $ return -> class .= ' mobile' ; } $ return -> browser = $ browser ; $ return -> shorty = $ shorty ; $ return -> version = $ version ; $ return -> engine = $ engine ; $ return -> versions = $ versions ; $ return -> mobile = $ mobile ; return $ return ; }
9383	public function getClassName ( $ identifier , $ args = [ ] ) { if ( isset ( $ this -> classes [ $ identifier ] ) ) { return $ args ? vsprintf ( $ this -> classes [ $ identifier ] , $ args ) : $ this -> classes [ $ identifier ] ; } }
12797	public function mb_str_pad ( $ input , $ length , $ string = ' ' , $ type = STR_PAD_LEFT ) { return str_pad ( $ input , $ length + strlen ( $ input ) - mb_strlen ( $ input ) , $ string , $ type ) ; }
2208	public function __isset ( $ strKey ) { if ( empty ( $ this -> arrCache ) ) { $ this -> next ( ) ; } return isset ( $ this -> arrCache [ $ strKey ] ) ; }
2159	public function run210Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_style` ADD `positioning` char(1) NOT NULL default ''" ) ; $ this -> Database -> query ( "UPDATE `tl_style` SET `positioning`=`size`" ) ; $ this -> Database -> query ( "UPDATE `tl_module` SET `guests`=1 WHERE `type`='lostPassword' OR `type`='registration'" ) ; $ this -> Database -> query ( "UPDATE `tl_news` SET `teaser`=CONCAT('<p>', teaser, '</p>') WHERE `teaser`!='' AND `teaser` NOT LIKE '<p>%'" ) ; }
12225	protected function retryMiddleware ( ) { return Middleware :: retry ( function ( $ retries , RequestInterface $ request , ResponseInterface $ response = null ) { if ( $ retries <= self :: $ maxRetries && $ response && $ body = $ response -> getBody ( ) ) { if ( stripos ( $ body , 'errcode' ) && ( stripos ( $ body , '40001' ) || stripos ( $ body , '42001' ) ) ) { $ field = $ this -> accessToken -> getQueryName ( ) ; $ token = $ this -> accessToken -> getToken ( true ) ; $ request = $ request -> withUri ( $ newUri = Uri :: withQueryValue ( $ request -> getUri ( ) , $ field , $ token ) ) ; Log :: debug ( "Retry with Request Token: {$token}" ) ; Log :: debug ( "Retry with Request Uri: {$newUri}" ) ; return true ; } } return false ; } ) ; }
3380	public function getModel ( $ entity ) { if ( \ Links :: isMain ( $ entity ) ) { $ modelClass = 'Serverfireteam\\Panel\\' . $ entity ; } else { if ( ! empty ( \ Config :: get ( 'panel.modelPath' ) ) ) { $ modelClass = $ this -> getNameSpace ( ) . \ Config :: get ( 'panel.modelPath' ) . '\\' . $ entity ; } else { $ modelClass = $ this -> getNameSpace ( ) . $ entity ; } } return $ modelClass ; }
6846	public static function hours ( $ step = 1 , $ long = false , $ start = null ) { if ( ! $ start ) { $ start = $ long ? 0 : 1 ; } $ size = $ long ? 23 : 12 ; $ step = ( int ) $ step ; $ hours = array ( ) ; for ( $ i = $ start ; $ i <= $ size ; $ i += $ step ) { $ hours [ $ i ] = ( string ) $ i ; } return $ hours ; }
9794	public function getDataValidation ( ) { if ( ! isset ( $ this -> parent ) ) { throw new Exception ( 'Cannot get data validation for cell that is not bound to a worksheet' ) ; } return $ this -> getWorksheet ( ) -> getDataValidation ( $ this -> getCoordinate ( ) ) ; }
3744	protected function getMetaModel ( ) { if ( ! $ this -> metaModel ) { if ( $ this -> metaModel === null ) { throw new \ RuntimeException ( 'No MetaModel instance set for ' . $ this -> strTable ) ; } } return $ this -> metaModel ; }
8682	public function setPath ( $ path , $ value ) { Deprecated :: method ( 1.1 , MutableBag :: class ) ; Arr :: set ( $ this -> items , $ path , $ value ) ; }
8380	protected function applyFilters ( $ value , $ key ) { foreach ( $ this -> filters as $ filter ) { $ value = $ filter ( $ value , $ key ) ; } return $ value ; }
11087	public static function getUserPlatform ( ) { $ user_agent = $ _SERVER [ 'HTTP_USER_AGENT' ] ; $ user_platform = 'unknown' ; if ( false !== stripos ( $ user_agent , 'linux' ) ) { $ user_platform = 'Linux' ; } elseif ( preg_match ( '/macintosh|mac os x/i' , $ user_agent ) ) { $ user_platform = 'Mac' ; } elseif ( preg_match ( '/windows|win32/i' , $ user_agent ) ) { $ user_platform = 'Windows' ; } return $ user_platform ; }
2285	protected static function server ( ) { $ strServer = ! empty ( $ _SERVER [ 'SERVER_ADDR' ] ) ? $ _SERVER [ 'SERVER_ADDR' ] : $ _SERVER [ 'LOCAL_ADDR' ] ; if ( empty ( $ strServer ) ) { $ strServer = @ gethostbyname ( $ _SERVER [ 'SERVER_NAME' ] ) ; } return $ strServer ; }
4242	public function onOutput ( ) { if ( $ this -> debug -> parentInstance ) { return ; } $ vals = $ this -> runtimeVals ( ) ; $ this -> debug -> groupSummary ( 1 ) ; $ this -> debug -> info ( 'Built In ' . $ vals [ 'runtime' ] . ' sec' ) ; $ this -> debug -> info ( 'Peak Memory Usage' . ( $ this -> debug -> getCfg ( 'output/outputAs' ) == 'html' ? ' <span title="Includes debug overhead">?&#x20dd;</span>' : '' ) . ': ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryPeakUsage' ] ) . ' / ' . $ this -> debug -> utilities -> getBytes ( $ vals [ 'memoryLimit' ] ) ) ; $ this -> debug -> groupEnd ( ) ; }
1017	public static function getAllBuiltInTypes ( ) { if ( self :: $ builtInTypes === null ) { self :: $ builtInTypes = array_merge ( Introspection :: getTypes ( ) , self :: getStandardTypes ( ) ) ; } return self :: $ builtInTypes ; }
11151	public function getApi ( ) { if ( $ this -> api === null ) { $ this -> api = new ExtDirectApi ( $ this -> useCache ( ) , $ this -> getApplicationPath ( ) , $ this -> getApplicationNameSpace ( ) ) ; } return $ this -> api ; }
5292	public function buildGravatarURL ( $ email , $ hash_email = true ) { if ( $ this -> usingSecureImages ( ) ) { $ url = static :: HTTPS_URL ; } else { $ url = static :: HTTP_URL ; } if ( $ hash_email == true && ! empty ( $ email ) ) { $ url .= $ this -> getEmailHash ( $ email ) ; } elseif ( ! empty ( $ email ) ) { $ url .= $ email ; } else { $ url .= str_repeat ( '0' , 32 ) ; } if ( $ this -> param_cache === NULL ) { $ params = array ( ) ; $ params [ ] = 's=' . $ this -> getAvatarSize ( ) ; $ params [ ] = 'r=' . $ this -> getMaxRating ( ) ; if ( $ this -> getDefaultImage ( ) ) { $ params [ ] = 'd=' . $ this -> getDefaultImage ( ) ; } $ this -> params_cache = ( ! empty ( $ params ) ) ? '?' . implode ( '&' , $ params ) : '' ; } $ tail = '' ; if ( empty ( $ email ) ) { $ tail = ! empty ( $ this -> params_cache ) ? '&f=y' : '?f=y' ; } return $ url . $ this -> params_cache . $ tail ; }
7889	public function make ( $ date , $ level = 'all' ) { $ raw = $ this -> filesystem -> read ( $ date ) ; $ levels = $ this -> levels ; return new Log ( $ raw , $ levels , $ level ) ; }
50	protected function pushEvent ( Event $ event ) { $ eventName = $ event -> getName ( ) ; if ( in_array ( $ eventName , $ this -> eventStack ) ) { throw new \ RuntimeException ( sprintf ( "Circular call to script handler '%s' detected" , $ eventName ) ) ; } return array_push ( $ this -> eventStack , $ eventName ) ; }
3774	public function getTypeNames ( ) { $ names = $ this -> factories -> ids ( ) ; if ( [ ] !== $ fallback = $ this -> fallbackFactory -> getIds ( ) ) { $ names = array_unique ( array_merge ( $ fallback , $ names ) ) ; } return $ names ; }
12804	private static function buildColumnPropertiesCache ( ) { $ class = self :: getStaticChildClass ( ) ; $ annotations = new AnnotationReader ( $ class ) ; $ properties = $ annotations -> getPropertyAnnotations ( ) ; self :: $ columnPropertiesCache [ $ class ] = [ ] ; foreach ( $ properties as $ property ) { if ( $ property === [ ] ) continue ; if ( array_key_exists ( "ColumnName" , $ property ) ) self :: $ columnPropertiesCache [ $ class ] [ $ property [ "ColumnName" ] ] [ ] = $ property [ "var" ] [ "name" ] ; else self :: $ columnPropertiesCache [ $ class ] [ $ property [ "var" ] [ "name" ] ] [ ] = $ property [ "var" ] [ "name" ] ; } }
3148	public function isItemCompleted ( RunnerServiceContext $ context , $ routeItem , $ itemSession , $ partially = true ) { if ( $ context instanceof QtiRunnerServiceContext && $ context -> isAdaptive ( ) ) { $ itemIdentifier = $ context -> getCurrentAssessmentItemRef ( ) -> getIdentifier ( ) ; $ itemState = $ this -> getItemState ( $ context , $ itemIdentifier ) ; if ( $ itemState !== null ) { $ itemResponse = [ ] ; foreach ( $ itemState as $ key => $ value ) { if ( isset ( $ value [ 'response' ] ) ) { $ itemResponse [ $ key ] = $ value [ 'response' ] ; } } $ responses = $ this -> parsesItemResponse ( $ context , $ itemIdentifier , $ itemResponse ) ; $ excludedResponseVariables = array ( 'numAttempts' , 'duration' ) ; foreach ( $ responses as $ var ) { if ( $ var instanceof ResponseVariable && in_array ( $ var -> getIdentifier ( ) , $ excludedResponseVariables ) === false ) { $ value = $ var -> getValue ( ) ; $ defaultValue = $ var -> getDefaultValue ( ) ; if ( Utils :: isNull ( $ value ) === true ) { if ( Utils :: isNull ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } else { if ( $ value -> equals ( $ defaultValue ) === ( ( $ partially ) ? false : true ) ) { return ( ( $ partially ) ? true : false ) ; } } } } } return ( ( $ partially ) ? false : true ) ; } else { return TestRunnerUtils :: isItemCompleted ( $ routeItem , $ itemSession , $ partially ) ; } }
8708	public function select ( $ columns = [ '*' ] ) { parent :: select ( $ columns ) ; $ this -> columns = $ this -> qualifyColumns ( $ this -> columns ) ; return $ this ; }
8269	public function read ( ) { $ this -> open ( ) ; $ data = file_get_contents ( $ this -> filePath ) ; if ( $ data === false ) { throw new \ RuntimeException ( "Could not read from file " . $ this -> filePath ) ; } return $ data ; }
6287	private function buildReactRequest ( RequestInterface $ request ) { $ headers = [ ] ; foreach ( $ request -> getHeaders ( ) as $ name => $ value ) { $ headers [ $ name ] = ( is_array ( $ value ) ? $ value [ 0 ] : $ value ) ; } $ reactRequest = $ this -> client -> request ( $ request -> getMethod ( ) , ( string ) $ request -> getUri ( ) , $ headers , $ request -> getProtocolVersion ( ) ) ; return $ reactRequest ; }
47	public function addSubscriber ( EventSubscriberInterface $ subscriber ) { foreach ( $ subscriber -> getSubscribedEvents ( ) as $ eventName => $ params ) { if ( is_string ( $ params ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params ) ) ; } elseif ( is_string ( $ params [ 0 ] ) ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ params [ 0 ] ) , isset ( $ params [ 1 ] ) ? $ params [ 1 ] : 0 ) ; } else { foreach ( $ params as $ listener ) { $ this -> addListener ( $ eventName , array ( $ subscriber , $ listener [ 0 ] ) , isset ( $ listener [ 1 ] ) ? $ listener [ 1 ] : 0 ) ; } } } }
11427	public function toObject ( ) { $ groups = $ this -> groups ; foreach ( $ groups as & $ group ) { $ group = $ group -> toObject ( ) ; } $ items = $ this -> items ; foreach ( $ items as & $ item ) { $ item = $ item -> toObject ( ) ; } return ( object ) [ 'type' => $ this -> type , 'value' => $ this -> value , 'text' => $ this -> text , 'groups' => $ groups , 'items' => $ items , ] ; }
2605	public function aroundSetHeader ( Http $ subject , callable $ proceed , ... $ args ) { if ( $ this -> config -> getType ( ) !== Config :: FASTLY ) { return $ proceed ( ... $ args ) ; } if ( isset ( $ args [ 0 ] ) == true && $ args [ 0 ] !== 'X-Magento-Tags' ) { return $ proceed ( ... $ args ) ; } $ args [ 1 ] = $ this -> cacheTags -> convertCacheTags ( str_replace ( ',' , ' ' , $ args [ 1 ] ) ) ; $ tagsSize = $ this -> config -> getXMagentoTagsSize ( ) ; if ( strlen ( $ args [ 1 ] ) > $ tagsSize ) { $ trimmedArgs = substr ( $ args [ 1 ] , 0 , $ tagsSize ) ; $ args [ 1 ] = substr ( $ trimmedArgs , 0 , strrpos ( $ trimmedArgs , ' ' , - 1 ) ) ; } return $ proceed ( ... $ args ) ; }
2477	public function request ( $ method , Endpoint $ endpoint , $ path , Message $ message = null ) { $ message = $ message ? : new Message ( ) ; $ i = 0 ; do { ++ $ i ; if ( $ responseMessage = $ this -> requestStream ( $ method , $ endpoint , $ path , $ message ) ) { return $ responseMessage ; } usleep ( $ this -> retryWaitMs * 1000 ) ; } while ( $ i < $ this -> connectionRetry ) ; if ( $ this -> logger instanceof LoggerInterface ) { $ this -> logger -> error ( sprintf ( 'Connection to %s failed, attempted %d times' , $ endpoint -> getURL ( ) , $ this -> connectionRetry ) ) ; } throw new ConnectionException ( $ endpoint -> getURL ( ) , $ path , $ method ) ; }
3918	private function checkDownloads ( ) { if ( $ this -> getShowImages ( ) ) { return ; } if ( ( $ file = Input :: get ( 'file' ) ) && ( $ key = Input :: get ( 'fileKey' ) ) ) { if ( ! ( array_key_exists ( $ file , $ _SESSION [ 'metaModels_downloads' ] ) && $ _SESSION [ 'metaModels_downloads' ] [ $ file ] === $ key ) ) { $ objHandler = new $ GLOBALS [ 'TL_PTY' ] [ 'error_403' ] ( ) ; $ objHandler -> generate ( $ file ) ; } Controller :: sendFileToBrowser ( $ file ) ; } }
12931	public function createRouter ( $ debug = false ) { if ( null === $ this -> routesFile ) { throw new LogicException ( 'The derived class must define the string variable "routesFile"' ) ; } if ( ! is_string ( $ this -> routesFile ) ) { throw new LogicException ( '"routesFile" variable must be a string value' ) ; } $ isProduction = $ this -> configurationHandler -> isProduction ( ) ; $ cacheDir = null ; if ( ! $ debug && $ isProduction ) { $ cacheDir = $ this -> configurationHandler -> siteCacheDir ( ) . '/routes' ; } $ this -> router = new Router ( new YamlFileLoader ( $ this -> fileLocator ) , $ this -> routesFile , array ( 'cache_dir' => $ cacheDir ) ) ; return $ this -> router ; }
11967	public function getPidByProgramName ( $ name ) { $ process = new Process ( sprintf ( 'supervisorctl pid %s' , $ name ) ) ; $ process -> run ( ) ; return $ process -> getOutput ( ) ; }
643	public function addUnique ( $ name , $ table , $ columns ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addUnique ( $ name , $ table , $ columns ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
2909	public function getModuleVersion ( ) { $ moduleConfig = $ this -> getConfig ( ) -> getModuleConfig ( $ this -> getModuleName ( ) ) ; return ( string ) $ moduleConfig -> version ; }
10279	public static function coordinateFromString ( $ pCoordinateString ) { if ( preg_match ( '/^([$]?[A-Z]{1,3})([$]?\\d{1,7})$/' , $ pCoordinateString , $ matches ) ) { return [ $ matches [ 1 ] , $ matches [ 2 ] ] ; } elseif ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } elseif ( $ pCoordinateString == '' ) { throw new Exception ( 'Cell coordinate can not be zero-length string' ) ; } throw new Exception ( 'Invalid cell coordinate ' . $ pCoordinateString ) ; }
3378	private function showLink ( $ link ) { if ( ! $ link [ 'show_menu' ] ) return false ; $ user = \ Auth :: guard ( 'panel' ) -> user ( ) ; return $ user -> hasRole ( 'super' ) || $ user -> hasPermission ( '/' . $ link [ 'url' ] . '/all' ) ; }
8348	public function setValue ( string $ v ) : string { if ( static :: isValid ( $ v ) === false ) { throw new BadUse ( '"' . $ v . '" is not recognized as a possible value' ) ; } $ this -> value = $ v ; }
7264	private function validateItem ( SaleItemInterface $ item ) { foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> validateItem ( $ child ) ; } if ( $ item -> isCompound ( ) ) { return ; } if ( null === $ subject = $ this -> subjectHelper -> resolve ( $ item , false ) ) { return ; } if ( ! $ subject instanceof StockSubjectInterface ) { return ; } $ quantity = $ item -> getTotalQuantity ( ) ; $ availability = $ this -> availabilityHelper -> getAvailability ( $ subject , is_null ( $ item -> getParent ( ) ) ) ; if ( $ quantity < $ availability -> getMinimumQuantity ( ) ) { $ message = $ availability -> getMinimumMessage ( ) ; } elseif ( $ quantity > $ availability -> getMaximumQuantity ( ) ) { $ message = $ availability -> getMaximumMessage ( ) ; } else { return ; } if ( null !== $ item -> getParent ( ) ) { $ message = $ item -> getDesignation ( ) . ' : ' . $ message ; } throw new ValidationFailedException ( $ message ) ; }
4318	private function setLogDest ( $ where = 'auto' ) { if ( $ where == 'auto' ) { $ where = $ this -> data [ 'groupPriorityStack' ] ? 'summary' : 'log' ; } if ( $ where == 'log' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'log' ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ 'main' ] ; } elseif ( $ where == 'alerts' ) { $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'alerts' ] ; } else { $ priority = \ end ( $ this -> data [ 'groupPriorityStack' ] ) ; if ( ! isset ( $ this -> data [ 'logSummary' ] [ $ priority ] ) ) { $ this -> data [ 'logSummary' ] [ $ priority ] = array ( ) ; $ this -> data [ 'groupStacks' ] [ $ priority ] = array ( ) ; } $ this -> rootInstance -> logRef = & $ this -> rootInstance -> data [ 'logSummary' ] [ $ priority ] ; $ this -> rootInstance -> groupStackRef = & $ this -> rootInstance -> data [ 'groupStacks' ] [ $ priority ] ; } }
6249	protected function prepareForPresentation ( ) { if ( $ this -> prepared ) { return ; } $ this -> permissionGroups = new Collection ; $ this -> ungroupedPermissions = [ ] ; $ this -> groupedPermissionIndex = [ ] ; $ this -> loadPermissionsFromModules ( ) -> loadCustomPermissions ( ) -> loadCustomPermissionGroups ( ) -> addUngroupedPermissionGroup ( ) -> filterEmptyGroups ( ) ; }
5875	public function containerAdd ( ServerRequestInterface $ request , ResponseInterface $ response ) : ResponseInterface { $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] = include ( ExtensionManagementUtility :: extPath ( 'image_autoresize' ) . 'Configuration/TCA/Module/Options.php' ) ; $ GLOBALS [ 'TCA' ] [ 'tx_imageautoresize' ] [ 'ajax' ] = true ; $ dataProviders = & $ GLOBALS [ 'TYPO3_CONF_VARS' ] [ 'SYS' ] [ 'formEngine' ] [ 'formDataGroup' ] [ 'tcaDatabaseRecord' ] ; $ dataProviders [ \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: class ] = [ 'before' => [ \ TYPO3 \ CMS \ Backend \ Form \ FormDataProvider \ DatabaseEditRow :: class , ] ] ; $ record = [ 'uid' => \ Causal \ ImageAutoresize \ Controller \ ConfigurationController :: virtualRecordId , 'pid' => 0 , ] ; \ Causal \ ImageAutoresize \ Backend \ Form \ FormDataProvider \ VirtualDatabaseEditRow :: initialize ( $ record ) ; $ response = parent :: containerAdd ( $ request , $ response ) ; return $ response -> withHeader ( 'Content-Type' , 'application/json; charset=utf-8' ) ; }
827	public function getCommentBlockIndices ( Tokens $ tokens , $ index ) { if ( ! $ tokens [ $ index ] -> isGivenKind ( T_COMMENT ) ) { throw new \ InvalidArgumentException ( 'Given index must point to a comment.' ) ; } $ commentType = $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ; $ indices = [ $ index ] ; if ( self :: TYPE_SLASH_ASTERISK === $ commentType ) { return $ indices ; } $ count = \ count ( $ tokens ) ; ++ $ index ; for ( ; $ index < $ count ; ++ $ index ) { if ( $ tokens [ $ index ] -> isComment ( ) ) { if ( $ commentType === $ this -> getCommentType ( $ tokens [ $ index ] -> getContent ( ) ) ) { $ indices [ ] = $ index ; continue ; } break ; } if ( ! $ tokens [ $ index ] -> isWhitespace ( ) || $ this -> getLineBreakCount ( $ tokens , $ index , $ index + 1 ) > 1 ) { break ; } } return $ indices ; }
8423	public function mappings ( Request $ request ) { $ table = new \ cli \ Table ( ) ; $ table -> setHeaders ( [ 'Mapping' , 'Database' , 'Models path' ] ) ; $ rows = [ ] ; $ mappings = Mapping :: getMappings ( ) ; usort ( $ mappings , function ( array $ a , array $ b ) { return strcmp ( $ a [ 'config' ] [ 'name' ] , $ b [ 'config' ] [ 'name' ] ) ; } ) ; foreach ( $ mappings as $ mapping ) { $ rows [ ] = [ $ mapping [ 'config' ] [ 'name' ] , $ mapping [ 'config' ] [ 'database' ] , $ mapping [ 'config' ] [ 'models' ] [ 'path' ] , ] ; } $ table -> setRows ( $ rows ) ; $ table -> display ( ) ; }
3260	protected function process ( Request $ request ) { $ validator = Validator :: make ( [ 'order_id' => $ request -> get ( 'order_id' ) , 'status' => $ request -> get ( 'status' ) , 'shoptoken' => $ request -> get ( 'shoptoken' ) , ] , [ 'order_id' => 'required|exists:' . config ( 'shop.order_table' ) . ',id' , 'status' => 'required|in:success,fail' , 'shoptoken' => 'required|exists:' . config ( 'shop.transaction_table' ) . ',token,order_id,' . $ request -> get ( 'order_id' ) , ] ) ; if ( $ validator -> fails ( ) ) { abort ( 404 ) ; } $ order = call_user_func ( config ( 'shop.order' ) . '::find' , $ request -> get ( 'order_id' ) ) ; $ transaction = $ order -> transactions ( ) -> where ( 'token' , $ request -> get ( 'shoptoken' ) ) -> first ( ) ; Shop :: callback ( $ order , $ transaction , $ request -> get ( 'status' ) , $ request -> all ( ) ) ; $ transaction -> token = null ; $ transaction -> save ( ) ; return redirect ( ) -> route ( config ( 'shop.callback_redirect_route' ) , [ 'orderId' => $ order -> id ] ) ; }
11371	public function destroy ( $ menuId = null ) { if ( $ menuId !== null ) { return $ this -> parseJSON ( 'json' , [ self :: API_CONDITIONAL_DELETE , [ 'menuid' => $ menuId ] ] ) ; } return $ this -> parseJSON ( 'get' , [ self :: API_DELETE ] ) ; }
7777	protected function extractFieldAliases ( array $ data ) { foreach ( $ data as $ field => $ fieldRules ) { $ extraction = explode ( '|' , $ field ) ; if ( isset ( $ extraction [ 1 ] ) ) { $ updatedField = $ extraction [ 0 ] ; $ alias = $ extraction [ 1 ] ; $ this -> fieldAliases [ $ updatedField ] = $ alias ; $ data [ $ updatedField ] = $ data [ $ field ] ; unset ( $ data [ $ field ] ) ; } } return $ data ; }
8322	public function getLoad ( $ paramsList = [ 'waiting' , 'load' , 'minbid' , 'averageRecognitionTime' ] ) { $ parser = $ this -> getLoadXml ( ) ; if ( is_string ( $ paramsList ) ) { return $ parser -> $ paramsList -> __toString ( ) ; } $ statusData = [ ] ; foreach ( $ paramsList as $ item ) { $ statusData [ $ item ] = $ parser -> $ item -> __toString ( ) ; } return $ statusData ; }
2637	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ dictionaryId = $ this -> getRequest ( ) -> getParam ( 'dictionary_id' ) ; $ value = $ this -> getRequest ( ) -> getParam ( 'item_value' ) ; $ key = $ this -> getRequest ( ) -> getParam ( 'item_key' ) ; $ this -> api -> upsertDictionaryItem ( $ dictionaryId , $ key , $ value ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
1397	public function deleted ( $ resource = null , array $ links = [ ] , $ meta = null , array $ headers = [ ] ) { return $ this -> getResourceResponse ( $ resource , $ links , $ meta , $ headers ) ; }
11281	public function getFloat ( $ min , $ max ) { if ( $ min > $ max ) { throw new InvalidArgumentException ( 'Min cannot be greater than max' ) ; } $ random01 = \ mt_rand ( ) / \ mt_getrandmax ( ) ; return ( $ max - $ min ) * $ random01 + $ min ; }
10936	protected function authenticateUser ( CustomerInterface $ user , Response $ response ) { try { $ this -> get ( 'fos_user.security.login_manager' ) -> loginUser ( $ this -> getParameter ( 'fos_user.firewall_name' ) , $ user , $ response ) ; } catch ( AccountStatusException $ ex ) { } }
10882	protected function aggregateTernaryValues ( array $ values ) { if ( in_array ( false , $ values , true ) ) { return false ; } elseif ( in_array ( true , $ values , true ) ) { return true ; } else { return null ; } }
3381	public function hasRole ( $ role ) { if ( is_string ( $ role ) ) { return $ this -> roles -> contains ( 'name' , $ role ) ; } return ! ! $ role -> intersect ( $ this -> roles ) -> count ( ) ; }
4875	public function getMetaData ( $ key = null , $ default = null ) { if ( null === $ key ) { return $ this -> metaData ; } return $ this -> hasMetaData ( $ key ) ? $ this -> metaData [ $ key ] : $ default ; }
8536	public function setRentalChargeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalChargeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3177	public static function checkTimedSectionExit ( RunnerServiceContext $ context , $ nextPosition ) { $ timerConfig = $ context -> getTestConfig ( ) -> getConfigValue ( 'timer' ) ; if ( empty ( $ timerConfig [ 'keepUpToTimeout' ] ) ) { $ session = $ context -> getTestSession ( ) ; $ route = $ session -> getRoute ( ) ; $ section = $ session -> getCurrentAssessmentSection ( ) ; $ limits = $ section -> getTimeLimits ( ) ; if ( ! ( $ context instanceof QtiRunnerServiceContext ) || ! $ context -> isAdaptive ( ) ) { $ isJumpOutOfSection = false ; if ( ( $ nextPosition >= 0 ) && ( $ nextPosition < $ route -> count ( ) ) ) { $ nextSection = $ route -> getRouteItemAt ( $ nextPosition ) ; $ isJumpOutOfSection = ( $ section -> getIdentifier ( ) !== $ nextSection -> getAssessmentSection ( ) -> getIdentifier ( ) ) ; } if ( $ isJumpOutOfSection && $ limits != null && $ limits -> hasMaxTime ( ) ) { $ assessmentItemRefs = $ section -> getComponentsByClassName ( 'assessmentItemRef' ) ; foreach ( $ assessmentItemRefs as $ assessmentItemRef ) { $ itemSessions = $ session -> getAssessmentItemSessions ( $ assessmentItemRef -> getIdentifier ( ) ) ; if ( $ itemSessions !== false ) { foreach ( $ itemSessions as $ itemSession ) { $ itemSession -> endItemSession ( ) ; } } } } } } }
3634	public function events ( Request $ request ) : array { $ em = \ bean ( 'eventManager' ) ; if ( $ event = \ trim ( $ request -> query ( 'name' ) ) ) { if ( ! $ queue = $ em -> getListenerQueue ( $ event ) ) { return [ 'msg' => 'event name is invalid: ' . $ event ] ; } $ classes = [ ] ; foreach ( $ queue -> getIterator ( ) as $ listener ) { $ classes [ ] = \ get_class ( $ listener ) ; } return $ classes ; } return $ em -> getListenedEvents ( ) ; }
1190	protected function isRemoteRule ( $ rule ) { return in_array ( $ rule , $ this -> serverRules ) || ! in_array ( $ rule , $ this -> clientRules ) ; }
4184	public function getFile ( $ class ) { if ( is_null ( $ this -> count ) ) { return $ this -> fileHas ( $ class ) -> getFile ( $ class ) ; } if ( isset ( $ this -> files [ $ class ] ) ) { return $ this -> files [ $ class ] ; } throw new FileException ( "File does not exists with given `{$class}` class." ) ; }
8443	public function exit ( $ id , $ pid , $ code , $ forceRetry = false , $ queueBackoffTime = null ) { $ this -> logger -> info ( 'Job ended' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ id , 'queue' => $ this -> queue -> getName ( ) ] ) ; $ hash = explode ( ':' , $ id ) ; $ jobId = $ hash [ count ( $ hash ) - 1 ] ; try { $ job = $ this -> queue -> getJob ( $ jobId ) ; } catch ( JobNotFoundException $ e ) { $ this -> logger -> info ( 'Unable to process job exit code or retry status. Job data unavailable' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return true ; } if ( $ code === 0 ) { $ this -> logger -> info ( 'Job succeeded and is now complete' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> end ( ) ; } else { $ retry = $ job -> getRetry ( ) ; if ( $ forceRetry === true ) { $ retry = true ; } if ( $ retry === true || $ retry > 0 ) { $ this -> logger -> info ( 'Rescheduling job' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) , 'time' => \ time ( ) + $ queueBackoffTime ?? 0 ] ) ; return $ job -> retry ( $ queueBackoffTime ) ; } else { $ this -> logger -> info ( 'Job failed' , [ 'exitCode' => $ code , 'pid' => $ pid , 'jobId' => $ job -> getId ( ) , 'queue' => $ this -> queue -> getName ( ) ] ) ; return $ job -> fail ( ) ; } } return ; }
11227	final public function setProperties ( array $ properties = [ ] ) { foreach ( $ properties as $ name => $ value ) { if ( property_exists ( $ this , $ name ) ) { $ this -> $ name = $ value ; } else { trigger_error ( Message :: get ( Message :: MSG_PROPERTY_UNKNOWN , $ name , get_class ( $ this ) ) , E_USER_WARNING ) ; } } }
1634	public function boot ( ) { $ this -> app [ 'auth' ] -> viaRequest ( 'api' , function ( $ request ) { if ( $ request -> input ( 'api_token' ) ) { return User :: where ( 'api_token' , $ request -> input ( 'api_token' ) ) -> first ( ) ; } } ) ; }
4237	public static function getMetaVals ( & $ args , $ defaultMeta = array ( ) , $ defaultArgs = array ( ) , $ argsToMeta = array ( ) ) { $ meta = array ( ) ; foreach ( $ args as $ i => $ v ) { if ( \ is_array ( $ v ) && isset ( $ v [ 'debug' ] ) && $ v [ 'debug' ] === Debug :: META ) { unset ( $ v [ 'debug' ] ) ; $ meta = \ array_merge ( $ meta , $ v ) ; unset ( $ args [ $ i ] ) ; } } $ args = \ array_values ( $ args ) ; if ( $ defaultArgs ) { $ args = \ array_slice ( $ args , 0 , \ count ( $ defaultArgs ) ) ; $ args = \ array_combine ( \ array_keys ( $ defaultArgs ) , \ array_replace ( \ array_values ( $ defaultArgs ) , $ args ) ) ; } foreach ( $ argsToMeta as $ argk => $ metak ) { if ( \ is_int ( $ argk ) ) { $ argk = $ metak ; } $ defaultMeta [ $ metak ] = $ args [ $ argk ] ; unset ( $ args [ $ argk ] ) ; } $ meta = \ array_merge ( $ defaultMeta , $ meta ) ; return $ meta ; }
11941	public function onExecuteAction ( ExecuteActionEvent $ event ) { $ request = $ event -> getRequest ( ) ; $ position = 1 ; foreach ( $ request -> getConfig ( ) -> getArray ( 'argument' ) as $ argument ) { $ this -> validateArgument ( $ request , $ argument , $ position ++ ) ; } }
2078	public function purgePageCache ( ) { $ strCacheDir = StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ) ; $ objFolder = new Folder ( $ strCacheDir . '/http_cache' ) ; $ objFolder -> purge ( ) ; $ this -> log ( 'Purged the page cache' , __METHOD__ , TL_CRON ) ; }
12554	public function createTable ( ) { $ stmt = $ this -> pdoConnection -> prepare ( sprintf ( self :: $ CREATE_TABLE , $ this -> tableName ) ) ; return $ stmt -> execute ( ) ; }
5216	public static function createInstance ( $ className , $ projectPath ) { Runtime :: reset ( ) ; self :: $ projectPath = $ projectPath ; $ binder = new Binder ( ) ; foreach ( static :: getBindingsForApp ( $ className ) as $ bindingModule ) { if ( is_string ( $ bindingModule ) ) { $ bindingModule = new $ bindingModule ( ) ; } if ( $ bindingModule instanceof BindingModule ) { $ bindingModule -> configure ( $ binder , $ projectPath ) ; } elseif ( $ bindingModule instanceof \ Closure ) { $ bindingModule ( $ binder , $ projectPath ) ; } else { throw new \ InvalidArgumentException ( 'Given module class ' . get_class ( $ bindingModule ) . ' is not an instance of stubbles\ioc\module\BindingModule' ) ; } } return $ binder -> getInjector ( ) -> getInstance ( $ className ) ; }
7959	public function getPairsNumber ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> pairsNumber ; }
17	public function getLockedRepository ( $ withDevReqs = false ) { $ lockData = $ this -> getLockData ( ) ; $ packages = new ArrayRepository ( ) ; $ lockedPackages = $ lockData [ 'packages' ] ; if ( $ withDevReqs ) { if ( isset ( $ lockData [ 'packages-dev' ] ) ) { $ lockedPackages = array_merge ( $ lockedPackages , $ lockData [ 'packages-dev' ] ) ; } else { throw new \ RuntimeException ( 'The lock file does not contain require-dev information, run install with the --no-dev option or run update to install those packages.' ) ; } } if ( empty ( $ lockedPackages ) ) { return $ packages ; } if ( isset ( $ lockedPackages [ 0 ] [ 'name' ] ) ) { foreach ( $ lockedPackages as $ info ) { $ packages -> addPackage ( $ this -> loader -> load ( $ info ) ) ; } return $ packages ; } throw new \ RuntimeException ( 'Your composer.lock was created before 2012-09-15, and is not supported anymore. Run "composer update" to generate a new one.' ) ; }
11409	public function showAction ( Request $ request , Application $ app ) { $ options = array ( 'twig' => $ app [ "twig" ] , 'template_assets' => $ app [ "red_kite_cms.template_assets" ] , "configuration_handler" => $ app [ "red_kite_cms.configuration_handler" ] , "plugin_manager" => $ app [ "red_kite_cms.plugin_manager" ] , ) ; return parent :: show ( $ options ) ; }
11020	public function handle ( IEvent $ event , $ name , IDispatcher $ dispatcher ) { if ( $ event instanceof BeforeControllerRunEvent ) { return $ this -> onBeforeAction ( ) ; } elseif ( $ event instanceof AfterControllerRunEvent ) { return $ this -> onAfterAction ( ) ; } }
3474	public function handle ( ) { if ( ! $ this -> token ) { $ this -> error ( 'You must paste your Discord token (App Bot User token) into your `services.php` config file.' ) ; $ this -> error ( 'View the README for more info: https://github.com/laravel-notification-channels/discord#installation' ) ; return - 1 ; } if ( ! $ this -> confirm ( 'Is the bot already added to your server?' ) ) { $ clientId = $ this -> ask ( 'What is your Discord app client ID?' ) ; $ this -> warn ( 'Add the bot to your server by visiting this link: https://discordapp.com/oauth2/authorize?&client_id=' . $ clientId . '&scope=bot&permissions=0' ) ; if ( ! $ this -> confirm ( 'Continue?' , true ) ) { return - 1 ; } } $ this -> warn ( "Attempting to identify the bot with Discord's websocket gateway..." ) ; $ this -> gateway = $ this -> getGateway ( ) ; $ this -> warn ( "Connecting to '$this->gateway'..." ) ; $ client = $ this -> getSocket ( $ this -> gateway ) ; $ client -> send ( json_encode ( [ 'op' => 2 , 'd' => [ 'token' => $ this -> token , 'v' => 3 , 'compress' => false , 'properties' => [ '$os' => PHP_OS , '$browser' => 'laravel-notification-channels-discord' , '$device' => 'laravel-notification-channels-discord' , '$referrer' => '' , '$referring_domain' => '' , ] , ] , ] ) ) ; $ response = $ client -> receive ( ) ; $ identified = Arr :: get ( json_decode ( $ response , true ) , 'op' ) === 10 ; if ( ! $ identified ) { $ this -> error ( "Discord responded with an error while trying to identify the bot: $response" ) ; return - 1 ; } $ this -> info ( 'Your bot has been identified by Discord and can now send API requests!' ) ; }
12248	public function xpathSingle ( $ strXpathQuery ) { $ arrResults = $ this -> xpath ( $ strXpathQuery ) ; if ( $ arrResults === false ) { return null ; } if ( is_array ( $ arrResults ) && count ( $ arrResults ) == 0 ) { return null ; } else { if ( count ( $ arrResults ) > 1 ) { throw new Exception ( 'xpathSingle expects a single element as result, got ' . count ( $ arrResults ) . ' elements instead.' ) ; } else { return current ( $ arrResults ) ; } } }
5788	public function runExecute ( bool $ alterBooleanArgs = false ) { if ( ! isset ( $ this -> sql ) ) { $ this -> setSql ( ) ; } if ( isset ( $ this -> primaryKeyName ) ) { return parent :: executeWithReturnField ( $ this -> primaryKeyName , $ alterBooleanArgs ) ; } else { return parent :: execute ( $ alterBooleanArgs ) ; } }
1799	public function help ( $ strClass = '' ) { $ return = $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'label' ] [ 1 ] ; if ( ! Config :: get ( 'showHelp' ) || $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'inputType' ] == 'password' || $ return == '' ) { return '' ; } return ' <p class="tl_help tl_tip' . $ strClass . '">' . $ return . '</p>' ; }
10139	private function writeCFHeader ( ) { $ record = 0x01B0 ; $ length = 0x0016 ; $ numColumnMin = null ; $ numColumnMax = null ; $ numRowMin = null ; $ numRowMax = null ; $ arrConditional = [ ] ; foreach ( $ this -> phpSheet -> getConditionalStylesCollection ( ) as $ cellCoordinate => $ conditionalStyles ) { foreach ( $ conditionalStyles as $ conditional ) { if ( $ conditional -> getConditionType ( ) == Conditional :: CONDITION_EXPRESSION || $ conditional -> getConditionType ( ) == Conditional :: CONDITION_CELLIS ) { if ( ! in_array ( $ conditional -> getHashCode ( ) , $ arrConditional ) ) { $ arrConditional [ ] = $ conditional -> getHashCode ( ) ; } $ arrCoord = Coordinate :: coordinateFromString ( $ cellCoordinate ) ; if ( ! is_numeric ( $ arrCoord [ 0 ] ) ) { $ arrCoord [ 0 ] = Coordinate :: columnIndexFromString ( $ arrCoord [ 0 ] ) ; } if ( $ numColumnMin === null || ( $ numColumnMin > $ arrCoord [ 0 ] ) ) { $ numColumnMin = $ arrCoord [ 0 ] ; } if ( $ numColumnMax === null || ( $ numColumnMax < $ arrCoord [ 0 ] ) ) { $ numColumnMax = $ arrCoord [ 0 ] ; } if ( $ numRowMin === null || ( $ numRowMin > $ arrCoord [ 1 ] ) ) { $ numRowMin = $ arrCoord [ 1 ] ; } if ( $ numRowMax === null || ( $ numRowMax < $ arrCoord [ 1 ] ) ) { $ numRowMax = $ arrCoord [ 1 ] ; } } } } $ needRedraw = 1 ; $ cellRange = pack ( 'vvvv' , $ numRowMin - 1 , $ numRowMax - 1 , $ numColumnMin - 1 , $ numColumnMax - 1 ) ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'vv' , count ( $ arrConditional ) , $ needRedraw ) ; $ data .= $ cellRange ; $ data .= pack ( 'v' , 0x0001 ) ; $ data .= $ cellRange ; $ this -> append ( $ header . $ data ) ; }
9902	private static function cellAddressInDeleteRange ( $ cellAddress , $ beforeRow , $ pNumRows , $ beforeColumnIndex , $ pNumCols ) { list ( $ cellColumn , $ cellRow ) = Coordinate :: coordinateFromString ( $ cellAddress ) ; $ cellColumnIndex = Coordinate :: columnIndexFromString ( $ cellColumn ) ; if ( $ pNumRows < 0 && ( $ cellRow >= ( $ beforeRow + $ pNumRows ) ) && ( $ cellRow < $ beforeRow ) ) { return true ; } elseif ( $ pNumCols < 0 && ( $ cellColumnIndex >= ( $ beforeColumnIndex + $ pNumCols ) ) && ( $ cellColumnIndex < $ beforeColumnIndex ) ) { return true ; } return false ; }
3643	public function except ( $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> request -> except ( ( array ) $ keys ) ; return $ this -> clean ( $ values , $ trim , $ clean ) ; }
6544	public function currentShardingKey ( ) { return isset ( $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] ) ? $ this -> options [ SelectorSourceInterface :: SHARDING_KEY ] : null ; }
2990	public function uploadFromPath ( $ path ) { $ file = new FormUpload ( $ path ) ; $ this -> request -> setParam ( 'content' , $ file ) ; return $ this ; }
12164	private function createAuthorityTable ( ) { $ this -> database -> query ( "DROP TABLE IF EXISTS `?authority`;" ) ; $ this -> database -> query ( "CREATE TABLE IF NOT EXISTS `?authority` ( `authority_id` bigint(20) NOT NULL AUTO_INCREMENT, `authority_title` varchar(100) NOT NULL, `authority_parent_id` bigint(20) NOT NULL, `authority_name` varchar(45) NOT NULL COMMENT ' ', `authority_description` varchar(255) DEFAULT NULL, `lft` int(11) NOT NULL, `rgt` int(11) NOT NULL, PRIMARY KEY (`authority_id`), UNIQUE KEY `authority_name_UNIQUE` (`authority_name`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=5 ;" ) ; $ this -> database -> query ( "INSERT INTO `?authority` (`authority_id`, `authority_title`, `authority_parent_id`, `authority_name`, `authority_description`, `lft`, `rgt`) VALUES (1, 'PUBLIC', 0, 'PUBLIC', 'All unregistered nodes, users and applications', 1, 8), (2, 'Registered Users', 1, 'REGISTEREDUSERS', 'All registered nodes with a known unique identifier', 2, 7), (3, 'Moderators', 2, 'MODERATORS', 'System moderators, Users allowed to manage user generated import', 3, 6), (4, 'Super Administrators', 3, 'MASTERADMINISTRATORS', 'Special users with awesome powers', 4, 5);" ) ; }
8744	protected function runLoop ( ) { while ( $ this -> isListening ) { $ this -> stream -> select ( ) ; if ( true === $ this -> charSequenceEnabled && null !== $ this -> escapePressedAt ) { if ( $ this -> escapeKeyHasExpired ( ) ) { $ this -> disableKeySequence ( ) ; $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ this -> matcher -> getEscapeKey ( ) ) ) ; $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } if ( $ this -> stream -> isAvailable ( ) ) { $ char = $ this -> stream -> getChar ( ) ; if ( $ this -> matcher -> getEscapeKey ( ) === $ char ) { $ this -> enableKeySequence ( ) ; $ this -> setCurrentKey ( $ char ) ; } else { $ this -> escapePressedAt = null ; if ( $ this -> charSequenceEnabled ) { $ this -> concatCurrentKey ( $ char ) ; $ mapped = $ this -> matcher -> getKey ( $ this -> getCurrentKey ( ) ) ; if ( $ mapped ) { $ this -> setCurrentKey ( $ mapped ) ; $ this -> disableKeySequence ( ) ; } else { continue ; } } else { if ( $ this -> matcher -> isBasicLatin ( $ char ) ) { continue ; } else { $ this -> setCurrentKey ( $ this -> matcher -> getKey ( $ char ) ? : $ char ) ; } } $ this -> dispatchKeyPressEvents ( $ this -> getCurrentKey ( ) ) ; } } } return $ this ; }
1457	protected function next ( Cursor $ cursor , $ columns ) { if ( $ cursor -> isAfter ( ) ) { $ this -> whereId ( $ cursor -> getAfter ( ) , $ this -> descending ? '<' : '>' ) ; } $ items = $ this -> orderForNext ( ) -> get ( $ cursor -> getLimit ( ) + 1 , $ columns ) ; $ more = $ items -> count ( ) > $ cursor -> getLimit ( ) ; return new CursorPaginator ( $ items -> slice ( 0 , $ cursor -> getLimit ( ) ) , $ more , $ cursor , $ this -> key ) ; }
11652	protected function _initRestRoute ( ) { $ front = Zend_Controller_Front :: getInstance ( ) ; $ front -> setResponse ( new Benri_Controller_Response_Http ( ) ) ; $ front -> setRequest ( new Benri_Controller_Request_Http ( ) ) ; $ front -> getRouter ( ) -> addRoute ( 'benri-app' , new Zend_Rest_Route ( $ front ) ) ; }
6173	public function read ( $ path , $ file ) { return $ this -> driver -> read ( $ this -> root . $ path , $ file ) ; }
6375	public function first ( ) : Optional { try { return Optional :: ofNullable ( $ this -> get ( 0 ) ) ; } catch ( OutOfBoundsException $ e ) { return Optional :: absent ( ) ; } }
10061	public function create ( $ key , $ value ) { $ exists = $ this -> metaModel :: where ( 'key' , $ key ) -> exists ( ) ; if ( $ exists ) { $ message = "Can't create meta (key: $key). " ; $ message .= "Meta already exists" ; throw new \ Exception ( $ message ) ; } $ meta = new $ this -> metaModel ; $ meta -> key = $ key ; $ meta -> value = $ value ; $ meta -> save ( ) ; }
284	private function getFixturesConfig ( $ fixtures ) { $ config = [ ] ; foreach ( $ fixtures as $ fixture ) { $ isNamespaced = ( strpos ( $ fixture , '\\' ) !== false ) ; $ fixture = str_replace ( '/' , '\\' , $ fixture ) ; $ fullClassName = $ isNamespaced ? $ fixture : $ this -> namespace . '\\' . $ fixture ; if ( class_exists ( $ fullClassName ) ) { $ config [ ] = $ fullClassName ; } elseif ( class_exists ( $ fullClassName . 'Fixture' ) ) { $ config [ ] = $ fullClassName . 'Fixture' ; } } return $ config ; }
5834	protected function setCode ( $ code ) { $ this -> code = $ code ; $ this -> statusText = $ code ; list ( $ this -> statusCode , ) = explode ( ' ' , $ code ) ; }
11668	public static function getRemoteClient ( array $ params ) { return new m62Sftp ( [ 'host' => $ params [ 'sftp_host' ] , 'username' => $ params [ 'sftp_username' ] , 'password' => $ params [ 'sftp_password' ] , 'port' => $ params [ 'sftp_port' ] , 'privateKey' => ( isset ( $ params [ 'sftp_private_key' ] ) ? $ params [ 'sftp_private_key' ] : '' ) , 'timeout' => ( ! empty ( $ params [ 'sftp_timeout' ] ) ? $ params [ 'sftp_timeout' ] : '30' ) , 'root' => $ params [ 'sftp_root' ] ] ) ; }
715	public function double ( $ precision = null ) { return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_DOUBLE , $ precision ) ; }
4760	public function updateStats ( $ stats , $ delta = 1 , $ sampleRate = 1 ) { if ( ! is_array ( $ stats ) ) { $ stats = array ( $ stats ) ; } $ data = array ( ) ; foreach ( $ stats as $ stat ) { $ data [ $ stat ] = "$delta|c" ; } $ this -> queue ( $ data , $ sampleRate ) ; }
5080	public function postIndex ( ) { $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ this -> userCan ( static :: ACTION_CREATE ) ; $ aData = $ oInput -> post ( ) ; if ( empty ( $ aData ) ) { $ sData = stream_get_contents ( fopen ( 'php://input' , 'r' ) ) ; $ aData = json_decode ( $ sData , JSON_OBJECT_AS_ARRAY ) ? : [ ] ; } $ aData = $ this -> validateUserInput ( $ aData ) ; $ iItemId = $ this -> oModel -> create ( $ aData ) ; if ( empty ( $ iItemId ) ) { throw new ApiException ( 'Failed to create resource. ' . $ this -> oModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } $ oItem = $ this -> oModel -> getById ( $ iItemId , static :: CONFIG_LOOKUP_DATA ) ; $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
8904	public function delete_many ( $ primary_values , $ time = 'NOW()' ) { $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) ; return $ this -> _delete ( $ primary_values , $ time ) ; }
5794	private function addBooleanColumnFalse ( array $ columnValues ) : array { foreach ( $ this -> getBooleanColumnNames ( ) as $ booleanColumnName ) { if ( ! isset ( $ columnValues [ $ booleanColumnName ] ) ) { $ columnValues [ $ booleanColumnName ] = Postgres :: BOOLEAN_FALSE ; } } return $ columnValues ; }
33	protected function addReason ( $ id , $ reason ) { if ( ! isset ( $ this -> reasonSeen [ $ id ] ) ) { $ this -> reasonSeen [ $ id ] = true ; $ this -> reasons [ $ this -> section ] [ ] = $ reason ; } }
3489	private function createTemporaryFile ( ) : string { $ tmpDir = $ this -> tmpDir ; $ tmpFileName = md5 ( uniqid ( ( string ) mt_rand ( ) , true ) ) . '.p8' ; $ tmpFilePath = $ tmpDir . '/' . $ tmpFileName ; $ errorCode = $ errorMessage = null ; set_error_handler ( function ( $ errCode , $ errMessage ) use ( & $ errorCode , & $ errorMessage ) { $ errorCode = $ errCode ; $ errorMessage = $ errMessage ; } ) ; if ( ! file_exists ( $ tmpDir ) ) { mkdir ( $ tmpDir , 0600 , true ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary directory "%s". Error: %s [%d].' , $ tmpDir , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } } touch ( $ tmpFilePath ) ; if ( $ errorCode || $ errorMessage ) { restore_error_handler ( ) ; throw new \ RuntimeException ( sprintf ( 'Can not create temporary certificate file "%s". Error: %s [%d].' , $ tmpFilePath , $ errorMessage ? : 'Undefined' , $ errorCode ? : '0' ) ) ; } restore_error_handler ( ) ; return $ tmpFilePath ; }
1438	protected function buildClass ( $ name ) { $ stub = $ this -> files -> get ( $ this -> getStub ( ) ) ; $ this -> replaceNamespace ( $ stub , $ name ) -> replaceClassName ( $ stub , $ name ) -> replaceResourceType ( $ stub ) -> replaceApplicationNamespace ( $ stub ) -> replaceRecord ( $ stub ) ; return $ stub ; }
10327	function fromXML ( $ xmlElement ) { $ this -> author = $ xmlElement -> author ; $ this -> countContacts = $ xmlElement -> count_contacts ; $ this -> countRules = $ xmlElement -> count_rules ; $ this -> created = $ xmlElement -> created ; $ this -> id = $ xmlElement -> id ; $ this -> name = $ xmlElement -> name ; $ this -> state = $ xmlElement -> state ; if ( $ xmlElement -> rules ) { $ rules = $ xmlElement -> rules ; foreach ( $ rules as $ rule ) { array_push ( $ this -> rules , new Rule ( $ rule -> is_customfield , $ rule -> field , $ rule -> operator , $ rule -> value , $ rule -> type ) ) ; } } }
1089	protected function getStub ( $ name ) { if ( stripos ( $ name , '.php' ) === FALSE ) $ name = $ name . '.php' ; return $ this -> files -> get ( $ this -> getStubPath ( ) . '/' . $ name ) ; }
5272	protected function translateOrderBy ( ) { $ build = array ( ) ; foreach ( $ this -> statements [ 'orders' ] as $ column => $ direction ) { if ( is_array ( $ direction ) ) { list ( $ column , $ direction ) = $ direction ; } if ( ! is_null ( $ direction ) ) { $ column .= ' ' . $ direction ; } $ build [ ] = $ column ; } return 'order by ' . join ( ', ' , $ build ) ; }
8491	public static function getCpuCores ( ) { $ wmi = Windows :: getInstance ( ) ; $ object = $ wmi -> ExecQuery ( "SELECT NumberOfLogicalProcessors FROM Win32_Processor" ) ; $ cores = 0 ; foreach ( $ object as $ obj ) { $ cores = $ obj -> NumberOfLogicalProcessors ; } return $ cores ; }
9996	protected function checkSeparator ( ) { $ line = fgets ( $ this -> fileHandle ) ; if ( $ line === false ) { return ; } if ( ( strlen ( trim ( $ line , "\r\n" ) ) == 5 ) && ( stripos ( $ line , 'sep=' ) === 0 ) ) { $ this -> delimiter = substr ( $ line , 4 , 1 ) ; return ; } return $ this -> skipBOM ( ) ; }
3699	private function parseListing ( ) { $ listing = $ this -> definition -> getListingConfig ( ) ; if ( null === $ listing -> getRootLabel ( ) ) { $ listing -> setRootLabel ( $ this -> metaModel -> get ( 'name' ) ) ; } if ( null === $ listing -> getRootIcon ( ) ) { $ listing -> setRootIcon ( $ this -> iconBuilder -> getBackendIcon ( $ this -> inputScreen [ 'meta' ] [ 'backendicon' ] ) ) ; } $ this -> parseListSorting ( $ listing ) ; $ this -> parseListLabel ( $ listing ) ; $ listing -> setShowColumns ( ( bool ) $ this -> inputScreen [ 'meta' ] [ 'showColumns' ] ) ; }
6097	protected function get ( $ endpoint , array $ parameters = [ ] , CachePolicy $ cachePolicy = null , $ fireAndForget = false ) { return $ this -> call ( $ endpoint , $ parameters , self :: METHOD_GET , $ cachePolicy , $ fireAndForget ) ; }
6093	public function section ( $ separator , $ first = 0 , $ last = 0 ) { $ sections = explode ( $ separator , $ this -> string ) ; $ total = count ( $ sections ) ; $ first = intval ( $ first ) ; $ last = intval ( $ last ) ; if ( $ first > $ total ) { return null ; } if ( $ first > $ last ) { $ last = $ first ; } for ( $ i = 0 ; $ i < $ total ; $ i ++ ) { if ( $ i < $ first || $ i > $ last ) { unset ( $ sections [ $ i ] ) ; } } $ string = implode ( $ separator , $ sections ) ; return new self ( $ string ) ; }
7909	protected function renderSearchInput ( ) { $ lines = [ ] ; $ lines [ ] = Html :: beginTag ( 'div' , [ 'class' => 'ui icon search input' ] ) ; $ lines [ ] = Html :: tag ( 'i' , '' , [ 'class' => 'search icon' ] ) ; $ lines [ ] = Html :: input ( 'text' , $ this -> getId ( ) . '-search' , '' , $ this -> searchInputOptions ) ; $ lines [ ] = Html :: endTag ( 'div' ) ; $ lines [ ] = Html :: tag ( 'div' , '' , [ 'class' => 'divider' ] ) ; return implode ( "\n" , $ lines ) ; }
323	public static function titleize ( $ words , $ ucAll = false ) { $ words = static :: humanize ( static :: underscore ( $ words ) , $ ucAll ) ; return $ ucAll ? StringHelper :: mb_ucwords ( $ words , self :: encoding ( ) ) : StringHelper :: mb_ucfirst ( $ words , self :: encoding ( ) ) ; }
8855	public function getArchiveDate ( ) { $ year = $ this -> getArchiveYear ( ) ; $ month = $ this -> getArchiveMonth ( ) ; $ day = $ this -> getArchiveDay ( ) ; if ( $ year ) { if ( $ month ) { $ date = $ year . '-' . $ month . '-01' ; if ( $ day ) { $ date = $ year . '-' . $ month . '-' . $ day ; } } else { $ date = $ year . '-01-01' ; } return DBField :: create_field ( "Date" , $ date ) ; } }
10427	private function initShops ( ContainerBuilder $ container , array $ config ) { $ activeShop = ! empty ( $ config [ 'active_shop' ] ) ? $ config [ 'active_shop' ] : null ; if ( $ activeShop !== null && ! isset ( $ config [ 'shops' ] [ $ activeShop ] ) ) { throw new LogicException ( "Parameter 'ongr_connections.active_shop' must be set to one" . "of the values defined in 'ongr_connections.shops'." ) ; } $ container -> setParameter ( 'ongr_connections.active_shop' , $ activeShop ) ; $ container -> setParameter ( 'ongr_connections.shops' , $ config [ 'shops' ] ) ; $ container -> setDefinition ( 'ongr_connections.shop_service' , new Definition ( 'ONGR\ConnectionsBundle\Service\ShopService' , [ $ activeShop , $ config [ 'shops' ] , ] ) ) ; }
7998	private function getOpenSslEncryptionOptions ( ) { $ options = self :: DEFAULT_OPENSSL_OPTIONS ; if ( $ this -> zero_pad ) { $ options = $ options | OPENSSL_ZERO_PADDING ; } return $ options ; }
8889	public function set ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value , false ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
12163	public function getFormSegment ( $ primaryModel = null , $ settings = [ ] ) { if ( empty ( $ primaryModel ) ) { return false ; } return $ primaryModel -> form ( $ settings ) ; }
1497	public function push ( Encoding ... $ encodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ encodings ) -> all ( ) ; return $ copy ; }
2398	public static function changeSubscriptionStatus ( FrontendTemplate $ objTemplate ) { if ( strncmp ( Input :: get ( 'token' ) , 'com-' , 4 ) === 0 ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; if ( ( ! $ optInToken = $ optIn -> find ( Input :: get ( 'token' ) ) ) || ! $ optInToken -> isValid ( ) || \ count ( $ arrRelated = $ optInToken -> getRelatedRecords ( ) ) != 1 || key ( $ arrRelated ) != 'tl_comments_notify' || \ count ( $ arrIds = current ( $ arrRelated ) ) != 1 || ( ! $ objNotify = CommentsNotifyModel :: findByPk ( $ arrIds [ 0 ] ) ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } if ( $ optInToken -> isConfirmed ( ) ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenConfirmed' ] ; return ; } if ( $ optInToken -> getEmail ( ) != $ objNotify -> email ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tokenEmailMismatch' ] ; return ; } $ objNotify -> active = '1' ; $ objNotify -> save ( ) ; $ optInToken -> confirm ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInConfirm' ] ; } elseif ( strncmp ( Input :: get ( 'token' ) , 'cor-' , 4 ) === 0 ) { $ objNotify = CommentsNotifyModel :: findOneByTokenRemove ( Input :: get ( 'token' ) ) ; if ( $ objNotify === null ) { $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'invalidToken' ] ; return ; } $ objNotify -> delete ( ) ; $ objTemplate -> confirm = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_optInCancel' ] ; } }
10950	private function xorTokens ( $ token1 , $ token2 ) { $ n1 = StringHelper :: byteLength ( $ token1 ) ; $ n2 = StringHelper :: byteLength ( $ token2 ) ; if ( $ n1 > $ n2 ) { $ token2 = str_pad ( $ token2 , $ n1 , $ token2 ) ; } elseif ( $ n1 < $ n2 ) { $ token1 = str_pad ( $ token1 , $ n2 , $ n1 === 0 ? ' ' : $ token1 ) ; } return $ token1 ^ $ token2 ; }
9792	public function setDataType ( $ pDataType ) { if ( $ pDataType == DataType :: TYPE_STRING2 ) { $ pDataType = DataType :: TYPE_STRING ; } $ this -> dataType = $ pDataType ; return $ this -> updateInCollection ( ) ; }
11612	protected function _resolveContainer ( BaseContainerInterface $ container ) { $ parent = null ; while ( $ container instanceof ContainerAwareInterface ) { $ parent = $ container -> getContainer ( ) ; if ( ! ( $ parent instanceof BaseContainerInterface ) ) { break ; } $ container = $ parent ; } return $ container ; }
12461	private function createMakeDefaultForm ( CustomFieldsGroup $ group = null ) { return $ this -> createFormBuilder ( $ group , array ( 'method' => 'POST' , 'action' => $ this -> generateUrl ( 'customfieldsgroup_makedefault' ) ) ) -> add ( 'id' , 'hidden' ) -> add ( 'submit' , 'submit' , array ( 'label' => 'Make default' ) ) -> getForm ( ) ; }
7562	protected function parse_pipe ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_PREFIX ) ; } else { return ( $ this -> token = self :: TOK_PIPE ) ; } }
3211	static function checkArg ( $ argName , $ argValue ) { if ( ! ( $ argValue instanceof self ) ) Checker :: throwError ( $ argName , $ argValue , __CLASS__ ) ; }
2129	protected function initialize ( ) { if ( static :: $ blnHasLcf === null ) { static :: preload ( ) ; } $ strCacheDir = System :: getContainer ( ) -> getParameter ( 'kernel.cache_dir' ) ; if ( file_exists ( $ strCacheDir . '/contao/config/config.php' ) ) { include $ strCacheDir . '/contao/config/config.php' ; } else { try { $ files = System :: getContainer ( ) -> get ( 'contao.resource_locator' ) -> locate ( 'config/config.php' , null , false ) ; } catch ( \ InvalidArgumentException $ e ) { $ files = array ( ) ; } foreach ( $ files as $ file ) { include $ file ; } } if ( static :: $ blnHasLcf ) { include $ this -> strRootDir . '/system/config/localconfig.php' ; } static :: loadParameters ( ) ; }
940	public function override ( $ other ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ prototype = $ other instanceof self ? $ other -> getPrototype ( ) : $ other ; if ( $ this -> equals ( $ prototype ) ) { return ; } $ this -> changed = true ; if ( \ is_array ( $ prototype ) ) { $ this -> isArray = true ; $ this -> id = $ prototype [ 0 ] ; $ this -> content = $ prototype [ 1 ] ; return ; } $ this -> isArray = false ; $ this -> id = null ; $ this -> content = $ prototype ; }
8280	public function onPagesLoaded ( array & $ pages ) { unset ( $ pages [ "403" ] ) ; if ( ! $ this -> config [ "alterPageArray" ] ) { return ; } if ( $ this -> errorOccurred ) { $ pages = array ( ) ; return ; } foreach ( $ pages as $ id => $ page ) { try { $ allowed = $ this -> checkAccess ( $ id ) ; } catch ( \ Exception $ e ) { $ this -> errorHandler ( $ e , $ this -> requestUrl ) ; $ pages = array ( ) ; return ; } if ( ! $ allowed ) { unset ( $ pages [ $ id ] ) ; } } }
7051	private function addViolation ( $ value , Constraint $ constraint ) { if ( $ this -> context instanceof ExecutionContextInterface ) { $ this -> context -> buildViolation ( $ constraint -> getMessage ( ) ) -> setParameter ( '{{ type }}' , $ constraint -> getType ( ) ) -> setParameter ( '{{ value }}' , $ this -> formatValue ( $ value ) ) -> setCode ( PhoneNumber :: INVALID_PHONE_NUMBER_ERROR ) -> addViolation ( ) ; } else { $ this -> context -> addViolation ( $ constraint -> getMessage ( ) , array ( '{{ type }}' => $ constraint -> getType ( ) , '{{ value }}' => $ value ) ) ; } }
3035	protected function exists ( $ key ) { return isset ( $ this -> cache [ $ key ] ) && in_array ( $ this -> cache [ $ key ] [ 'state' ] , [ self :: STATE_ALIGNED , self :: STATE_PENDING_WRITE ] ) ; }
6068	public function listVersions ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/versions' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new MediaVersion ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7499	protected function renderStringTemplate ( $ template , $ parameters = array ( ) ) { $ template = $ this -> environment -> createTemplate ( $ template ) ; return $ template -> render ( $ parameters ) ; }
579	public static function ensureScheme ( $ url , $ scheme ) { if ( static :: isRelative ( $ url ) || ! is_string ( $ scheme ) ) { return $ url ; } if ( substr ( $ url , 0 , 2 ) === '//' ) { return $ scheme === '' ? $ url : "$scheme:$url" ; } if ( ( $ pos = strpos ( $ url , '://' ) ) !== false ) { if ( $ scheme === '' ) { $ url = substr ( $ url , $ pos + 1 ) ; } else { $ url = $ scheme . substr ( $ url , $ pos ) ; } } return $ url ; }
1806	public function setNewPassword ( $ strPassword , $ user ) { if ( ! $ user ) { return $ strPassword ; } $ objUser = $ this -> Database -> prepare ( "SELECT * FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ user -> id ) ; if ( $ objUser -> numRows ) { if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'setNewPassword' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objUser , $ strPassword ) ; } } } return $ strPassword ; }
2197	public function onAuthenticationSuccess ( Request $ request , TokenInterface $ token ) : RedirectResponse { $ this -> user = $ token -> getUser ( ) ; if ( ! $ this -> user instanceof User ) { return $ this -> getRedirectResponse ( $ request ) ; } $ this -> user -> lastLogin = $ this -> user -> currentLogin ; $ this -> user -> currentLogin = time ( ) ; $ this -> user -> save ( ) ; if ( null !== $ this -> logger ) { $ this -> logger -> info ( sprintf ( 'User "%s" has logged in' , $ this -> user -> username ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ this -> user -> username ) ] ) ; } $ this -> triggerPostLoginHook ( ) ; return $ this -> getRedirectResponse ( $ request ) ; }
4260	public function hasSubscribers ( $ eventName = null ) { if ( $ eventName !== null ) { return ! empty ( $ this -> subscribers [ $ eventName ] ) ; } foreach ( $ this -> subscribers as $ subscribers ) { if ( $ subscribers ) { return true ; } } return false ; }
2554	protected static function makePricingOptionFareFamilyOverride ( $ fareFamily ) { $ opt = [ ] ; if ( $ fareFamily !== null ) { $ po = new PricingOptionGroup ( PricingOptionKey :: OPTION_FARE_FAMILY ) ; $ po -> optionDetail = new OptionDetail ( [ [ 'FF' => $ fareFamily ] ] ) ; $ opt [ ] = $ po ; } return $ opt ; }
12285	public function end ( ) : string { $ property = static :: END_ASSETS_NAME . static :: BLOCK_PROPERTY_SUFFIX ; return isset ( $ this -> $ property ) ? trim ( $ this -> make ( static :: END_ASSETS_NAME ) ) . PHP_EOL : PHP_EOL ; }
3720	protected function validator ( $ varInput ) { if ( is_array ( $ varInput ) ) { $ value = array ( ) ; foreach ( $ varInput as $ key => $ input ) { $ value [ $ key ] = parent :: validator ( $ input ) ; } return $ value ; } return parent :: validator ( trim ( $ varInput ) ) ; }
5929	public function updateCategory ( $ id , Category $ category ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'category' => $ category ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/categories/' . $ id . '' , $ parameters ) ; $ result = new CategoryResponse ( $ result ) ; return $ result ; }
972	public function forget ( ) { $ keys = [ self :: DOMAIN , self :: USER , self :: TOKEN ] ; foreach ( $ keys as $ key ) { Session :: forget ( $ key ) ; } }
4113	public function getBlockInfo ( Mage_Core_Block_Abstract $ block , $ fullInfo = true ) { $ info = array ( 'name' => $ block -> getNameInLayout ( ) , 'alias' => $ block -> getBlockAlias ( ) , ) ; if ( ! $ fullInfo ) { return $ info ; } $ info [ 'class' ] = get_class ( $ block ) ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ fileAndLine = Mage :: helper ( 'aoe_templatehints/classInfo' ) -> findFileAndLine ( $ info [ 'class' ] ) ; if ( $ fileAndLine ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , $ fileAndLine [ 'file' ] , $ fileAndLine [ 'line' ] ) ; $ info [ 'class' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ info [ 'class' ] ) ; } } $ info [ 'module' ] = $ block -> getModuleName ( ) ; if ( $ block instanceof Mage_Cms_Block_Block ) { $ info [ 'cms-blockId' ] = $ block -> getBlockId ( ) ; } if ( $ block instanceof Mage_Cms_Block_Page ) { $ info [ 'cms-pageId' ] = $ block -> getPage ( ) -> getIdentifier ( ) ; } $ templateFile = $ block -> getTemplateFile ( ) ; if ( $ templateFile ) { $ info [ 'template' ] = $ templateFile ; if ( $ this -> getRemoteCallEnabled ( ) ) { $ url = sprintf ( $ this -> getRemoteCallUrlTemplate ( ) , Mage :: getBaseDir ( 'design' ) . DS . $ templateFile , 0 ) ; $ info [ 'template' ] = sprintf ( $ this -> getRemoteCallLinkTemplate ( ) , $ url , $ templateFile ) ; } } $ info [ 'cache-status' ] = self :: TYPE_NOTCACHED ; $ cacheLifeTime = $ block -> getCacheLifetime ( ) ; if ( ! is_null ( $ cacheLifeTime ) ) { $ info [ 'cache-lifetime' ] = ( intval ( $ cacheLifeTime ) == 0 ) ? 'forever' : intval ( $ cacheLifeTime ) . ' sec' ; $ info [ 'cache-key' ] = $ block -> getCacheKey ( ) ; $ info [ 'cache-key-info' ] = is_array ( $ block -> getCacheKeyInfo ( ) ) ? implode ( ', ' , $ block -> getCacheKeyInfo ( ) ) : $ block -> getCacheKeyInfo ( ) ; $ info [ 'tags' ] = implode ( ',' , $ block -> getCacheTags ( ) ) ; $ info [ 'cache-status' ] = self :: TYPE_CACHED ; } elseif ( $ this -> isWithinCachedBlock ( $ block ) ) { $ info [ 'cache-status' ] = self :: TYPE_IMPLICITLYCACHED ; } $ info [ 'methods' ] = $ this -> getClassMethods ( get_class ( $ block ) ) ; return $ info ; }
5801	protected function getDeleteCell ( bool $ showDeleteLink , ? string $ primaryKeyValue ) : string { if ( $ showDeleteLink && $ this -> deleteRoute == null ) { throw new \ Exception ( "Must have deleteRoute" ) ; } if ( $ showDeleteLink && $ primaryKeyValue === null ) { throw new \ Exception ( "Must have primaryKeyValue to delete" ) ; } $ cellValue = ( $ showDeleteLink ) ? '<a href="' . $ this -> router -> pathFor ( $ this -> deleteRoute , [ "primaryKey" => $ primaryKeyValue ] ) . '" title="delete" onclick="return confirm(\'Are you sure you want to delete ' . $ primaryKeyValue . '?\');">X</a>' : '&nbsp;' ; return '<td>' . $ cellValue . '</td>' ; }
4666	protected function configure ( array $ config ) { $ this -> config = $ config ; $ this -> registerSwiftTransport ( ) ; $ this -> registerSwiftMailer ( ) ; $ this -> registerQueue ( ) ; }
4963	public function addViewTemplate ( $ name , $ template , $ vars = [ ] , $ priority = 0 ) { if ( is_int ( $ vars ) ) { $ priority = $ vars ; $ vars = [ ] ; } $ model = new ViewModel ( $ vars ) ; $ model -> setTemplate ( $ template ) ; return $ this -> addViewModel ( $ name , $ model , $ priority ) ; }
912	private function moveParamAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ params = $ doc -> getAnnotationsOfType ( 'param' ) ; if ( empty ( $ params ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'throws' , 'return' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ end = end ( $ params ) -> getEnd ( ) ; $ line = $ doc -> getLine ( $ end ) ; foreach ( $ others as $ other ) { if ( $ other -> getStart ( ) < $ end ) { $ line -> setContent ( $ line -> getContent ( ) . $ other -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
8899	public function update_many ( $ primary_values , $ data ) { $ data = $ this -> _do_pre_update ( $ data ) ; if ( $ data !== FALSE ) { $ result = $ this -> _database -> where_in ( $ this -> primary_key , $ primary_values ) -> set ( $ data ) -> update ( $ this -> _table ) ; $ this -> trigger ( 'after_update' , array ( $ data , $ result ) ) ; return $ result ; } return FALSE ; }
3758	public function encodeValue ( EncodePropertyValueFromWidgetEvent $ event ) { if ( ! ( $ this -> wantToHandle ( $ event ) && \ in_array ( $ event -> getProperty ( ) , [ 'name' , 'description' ] ) ) ) { return ; } $ metaModel = $ this -> getMetaModelByModelPid ( $ event -> getModel ( ) ) ; $ values = Helper :: encodeLangArray ( $ event -> getValue ( ) , $ metaModel ) ; $ event -> setValue ( $ values ) ; }
12200	public function getData ( $ object ) { if ( ! $ this -> validateObject ( $ object ) ) { throw new InvalidArgumentException ( "Given object isn't instance of {$this->localName}" ) ; } $ reflection = new ReflectionObject ( $ object ) ; $ data = [ ] ; foreach ( array_keys ( $ this -> properties ) as $ localProperty ) { $ property = $ reflection -> getProperty ( $ localProperty ) ; $ property -> setAccessible ( true ) ; $ data [ $ localProperty ] = $ property -> getValue ( $ object ) ; } return $ data ; }
12042	public function update ( $ usernameId , $ data = array ( ) ) { if ( empty ( $ usernameId ) ) return false ; $ existing = ( array ) $ this -> getPropertyData ( ) ; $ data = empty ( $ data ) ? $ existing : array_merge ( $ data , $ existing ) ; $ profile = $ this -> loadObjectByURI ( $ usernameId , array_keys ( $ this -> getPropertyModel ( ) ) ) ; $ this -> setObjectId ( $ profile -> getObjectId ( ) ) ; $ this -> setObjectURI ( $ profile -> getObjectURI ( ) ) ; $ profileData = $ profile -> getPropertyData ( ) ; $ updatedProfile = array_merge ( $ profileData , $ data ) ; foreach ( $ updatedProfile as $ property => $ value ) : $ this -> setPropertyValue ( $ property , $ value ) ; endforeach ; $ this -> defineValueGroup ( "user" ) ; if ( ! $ this -> saveObject ( $ this -> getPropertyValue ( "user_name_id" ) , "user" , $ this -> getObjectId ( ) ) ) { $ profile -> setError ( "Could not save the profile data" ) ; return false ; } return true ; }
2172	private function purgeSymfonyCache ( ) : void { $ filesystem = new Filesystem ( ) ; $ cacheDir = $ this -> getContainerParameter ( 'kernel.cache_dir' ) ; $ ref = new \ ReflectionObject ( $ this -> container ) ; $ containerDir = basename ( \ dirname ( $ ref -> getFileName ( ) ) ) ; $ finder = Finder :: create ( ) -> depth ( 0 ) -> exclude ( $ containerDir ) -> in ( $ cacheDir ) ; foreach ( $ finder as $ file ) { $ filesystem -> remove ( $ file -> getPathname ( ) ) ; } if ( \ function_exists ( 'opcache_reset' ) ) { opcache_reset ( ) ; } if ( \ function_exists ( 'apc_clear_cache' ) && ! ini_get ( 'apc.stat' ) ) { apc_clear_cache ( ) ; } }
6046	protected function registerPlugin ( $ name ) { $ view = $ this -> getView ( ) ; AdminUiAsset :: register ( $ view ) ; $ id = $ this -> options [ 'id' ] ; if ( $ this -> clientOptions !== false ) { $ options = empty ( $ this -> clientOptions ) ? '' : Json :: encode ( $ this -> clientOptions ) ; $ js = "jQuery('#$id').$name($options);" ; $ view -> registerJs ( $ js ) ; } if ( ! empty ( $ this -> clientEvents ) ) { $ js = [ ] ; foreach ( $ this -> clientEvents as $ event => $ handler ) { $ js [ ] = "jQuery('#$id').on('$event', $handler);" ; } $ view -> registerJs ( implode ( "\n" , $ js ) ) ; } }
1072	private function getSuggestedTypeNames ( Schema $ schema , $ type , $ fieldName ) { if ( Type :: isAbstractType ( $ type ) ) { $ suggestedObjectTypes = [ ] ; $ interfaceUsageCount = [ ] ; foreach ( $ schema -> getPossibleTypes ( $ type ) as $ possibleType ) { $ fields = $ possibleType -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ suggestedObjectTypes [ ] = $ possibleType -> name ; foreach ( $ possibleType -> getInterfaces ( ) as $ possibleInterface ) { $ fields = $ possibleInterface -> getFields ( ) ; if ( ! isset ( $ fields [ $ fieldName ] ) ) { continue ; } $ interfaceUsageCount [ $ possibleInterface -> name ] = ! isset ( $ interfaceUsageCount [ $ possibleInterface -> name ] ) ? 0 : $ interfaceUsageCount [ $ possibleInterface -> name ] + 1 ; } } arsort ( $ interfaceUsageCount ) ; $ suggestedInterfaceTypes = array_keys ( $ interfaceUsageCount ) ; return array_merge ( $ suggestedInterfaceTypes , $ suggestedObjectTypes ) ; } return [ ] ; }
10020	public function removeCellXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellXfCollection ) - 1 ) { throw new Exception ( 'CellXf index is out of bounds.' ) ; } array_splice ( $ this -> cellXfCollection , $ pIndex , 1 ) ; foreach ( $ this -> workSheetCollection as $ worksheet ) { foreach ( $ worksheet -> getCoordinates ( false ) as $ coordinate ) { $ cell = $ worksheet -> getCell ( $ coordinate ) ; $ xfIndex = $ cell -> getXfIndex ( ) ; if ( $ xfIndex > $ pIndex ) { $ cell -> setXfIndex ( $ xfIndex - 1 ) ; } elseif ( $ xfIndex == $ pIndex ) { $ cell -> setXfIndex ( 0 ) ; } } } }
10586	protected static function registerEntity ( entity \ EntityInterface $ entity ) { if ( count ( self :: $ entities ) === 0 ) { register_shutdown_function ( "sndsgd\\fs\\Temp::cleanup" ) ; } self :: $ entities [ $ entity -> getPath ( ) ] = $ entity ; }
11685	public function getCachePath ( ) { if ( empty ( $ this -> basePath ) ) { return false ; } $ cachePath = $ this -> basePath . DIRECTORY_SEPARATOR . 'cache' ; if ( ! is_dir ( $ cachePath ) ) { @ mkdir ( $ cachePath , 0777 , true ) ; } if ( ! is_dir ( $ cachePath ) ) { return false ; } return $ cachePath ; }
10669	public static function fromArray ( $ input , array $ options = [ ] ) { if ( ! \ is_array ( $ input ) || \ count ( $ input ) !== 1 ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'Invalid input.' ) ) ; } $ key = key ( $ input ) ; if ( \ is_int ( $ key ) ) { throw new \ RuntimeException ( Tools :: poorManTranslate ( 'fts-shared' , 'The key of input must be alphanumeric.' ) ) ; } if ( ! \ is_array ( $ options ) ) { $ options = [ 'format' => ( string ) $ options ] ; } $ defaults = [ 'format' => 'tags' , 'version' => '1.0' , 'encoding' => 'utf-8' , 'return' => 'simplexml' , ] ; $ options = array_merge ( $ defaults , $ options ) ; $ dom = new \ DOMDocument ( $ options [ 'version' ] , $ options [ 'encoding' ] ) ; self :: _fromArray ( $ dom , $ dom , $ input , $ options [ 'format' ] ) ; $ options [ 'return' ] = strtolower ( $ options [ 'return' ] ) ; if ( $ options [ 'return' ] === 'simplexml' || $ options [ 'return' ] === 'simplexmlelement' ) { return new \ SimpleXMLElement ( $ dom -> saveXML ( ) ) ; } return $ dom ; }
8386	public function having ( $ having ) { $ this -> having = ( $ having instanceof Condition ? $ having : new Condition ( $ having ) ) ; return $ this ; }
220	private function formatNumber ( $ value , $ decimals , $ maxPosition , $ formatBase , $ options , $ textOptions ) { $ value = $ this -> normalizeNumericValue ( $ value ) ; $ position = 0 ; if ( is_array ( $ formatBase ) ) { $ maxPosition = count ( $ formatBase ) - 1 ; } do { if ( is_array ( $ formatBase ) ) { if ( ! isset ( $ formatBase [ $ position + 1 ] ) ) { break ; } if ( abs ( $ value ) < $ formatBase [ $ position + 1 ] ) { break ; } } else { if ( abs ( $ value ) < $ formatBase ) { break ; } $ value /= $ formatBase ; } $ position ++ ; } while ( $ position < $ maxPosition + 1 ) ; if ( is_array ( $ formatBase ) && $ position !== 0 ) { $ value /= $ formatBase [ $ position ] ; } if ( $ position === 0 ) { $ decimals = 0 ; } elseif ( $ decimals !== null ) { $ value = round ( $ value , $ decimals ) ; } $ oldThousandSeparator = $ this -> thousandSeparator ; $ this -> thousandSeparator = '' ; if ( $ this -> _intlLoaded && ! isset ( $ options [ NumberFormatter :: GROUPING_USED ] ) ) { $ options [ NumberFormatter :: GROUPING_USED ] = false ; } $ params = [ 'n' => abs ( $ value ) , 'nFormatted' => $ this -> asDecimal ( $ value , $ decimals , $ options , $ textOptions ) , ] ; $ this -> thousandSeparator = $ oldThousandSeparator ; return [ $ params , $ position ] ; }
12850	private function _checkCache ( \ stdClass $ oCache ) { $ sHearderValidity = false ; $ sHeader = "Cache-Control:" ; if ( isset ( $ oCache -> visibility ) && ( $ oCache -> visibility = 'public' || $ oCache -> visibility = 'private' ) ) { $ sHearderValidity = true ; $ sHeader .= " " . $ oCache -> visibility . "," ; } if ( isset ( $ oCache -> max_age ) ) { $ sHearderValidity = true ; $ sHeader .= " maxage=" . $ oCache -> max_age . "," ; } if ( isset ( $ oCache -> must_revalidate ) && $ oCache -> must_revalidate === true ) { $ sHearderValidity = true ; $ sHeader .= " must-revalidate," ; } if ( $ sHearderValidity === true ) { $ sHeader = substr ( $ sHeader , 0 , - 1 ) ; if ( ! headers_sent ( ) ) { header ( $ sHeader ) ; } } if ( isset ( $ oCache -> ETag ) ) { header ( "ETag: \"" . $ oCache -> ETag . "\"" ) ; } if ( isset ( $ oCache -> max_age ) ) { if ( ! headers_sent ( ) ) { header ( 'Expires: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> max_age ) . ' GMT' ) ; } } if ( isset ( $ oCache -> last_modified ) ) { if ( ! headers_sent ( ) ) { header ( 'Last-Modified: ' . gmdate ( 'D, d M Y H:i:s' , time ( ) + $ oCache -> last_modified ) . ' GMT' ) ; } } if ( isset ( $ oCache -> vary ) ) { header ( 'Vary: ' . $ oCache -> vary ) ; } }
11901	private function assembleUrl ( ) { $ address = '' ; if ( ! empty ( $ this -> scheme ) ) { $ address .= $ this -> scheme . '://' ; } if ( ! empty ( $ this -> user ) ) { $ address .= $ this -> user ; } if ( ! empty ( $ this -> pass ) ) { $ address .= ':' . $ this -> pass . '@' ; } if ( ! empty ( $ this -> host ) ) { $ address .= $ this -> host ; } if ( ! empty ( $ this -> port ) ) { $ address .= ':' . $ this -> port ; } if ( ! empty ( $ this -> path ) ) { $ address .= $ this -> path ; } if ( count ( $ this -> query ) > 0 ) { $ this -> query_string = http_build_query ( $ this -> query ) ; $ address .= '?' . $ this -> query_string ; } if ( ! empty ( $ this -> fragment ) ) { $ address .= '#' . $ this -> fragment ; } $ this -> full_address = $ address ; }
1011	private function readNumber ( $ line , $ col , Token $ prev ) { $ value = '' ; $ start = $ this -> position ; [ $ char , $ code ] = $ this -> readChar ( ) ; $ isFloat = false ; if ( $ code === 45 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; } if ( $ code === 48 ) { $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code >= 48 && $ code <= 57 ) { throw new SyntaxError ( $ this -> source , $ this -> position , 'Invalid number, unexpected digit after 0: ' . Utils :: printCharCode ( $ code ) ) ; } } else { $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 46 ) { $ isFloat = true ; $ this -> moveStringCursor ( 1 , 1 ) ; $ value .= $ char ; $ value .= $ this -> readDigits ( ) ; [ $ char , $ code ] = $ this -> readChar ( ) ; } if ( $ code === 69 || $ code === 101 ) { $ isFloat = true ; $ value .= $ char ; [ $ char , $ code ] = $ this -> moveStringCursor ( 1 , 1 ) -> readChar ( ) ; if ( $ code === 43 || $ code === 45 ) { $ value .= $ char ; $ this -> moveStringCursor ( 1 , 1 ) ; } $ value .= $ this -> readDigits ( ) ; } return new Token ( $ isFloat ? Token :: FLOAT : Token :: INT , $ start , $ this -> position , $ line , $ col , $ prev , $ value ) ; }
11544	public function confirmPasswordReset ( $ token ) { $ user = $ this -> getMapper ( ) -> findOneBy ( [ 'registrationToken' => $ token ] ) ; if ( ! $ user instanceof UserInterface ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ user -> setRegistrationToken ( $ this -> getRegistrationToken ( ) ) ; $ user -> setEmailConfirmed ( true ) ; $ password = $ this -> getPasswordGenerator ( ) -> generate ( ) ; $ passwordService = $ this -> getMapper ( ) -> getPasswordService ( ) ; $ user -> setPassword ( $ passwordService -> create ( $ password ) ) ; $ viewModel = new ViewModel ( compact ( 'user' , 'password' ) ) ; $ viewModel -> setTemplate ( 'mail-message/user-change-password-success' ) ; $ mailService = $ this -> getMailService ( ) ; $ message = $ mailService -> getMessage ( ) ; $ message -> setTo ( $ user -> getEmail ( ) , $ user -> getDisplayName ( ) ) ; $ subject = 'Your password has been changed!' ; if ( $ this -> getTranslator ( ) && $ this -> isTranslatorEnabled ( ) ) { $ subject = $ this -> getTranslator ( ) -> translate ( $ subject , $ this -> getTranslatorTextDomain ( ) ) ; } $ message -> setSubject ( $ subject ) ; $ mailService -> setBody ( $ viewModel ) -> sendMessage ( ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
3507	private function doDiff ( $ from_text , $ to_text ) { $ this -> last_edit = false ; $ this -> stackpointer = 0 ; $ this -> from_text = $ from_text ; $ this -> from_offset = 0 ; if ( empty ( $ this -> granularityStack ) ) { return ; } $ this -> _processGranularity ( $ from_text , $ to_text ) ; }
11179	protected function get ( $ key ) { $ cache = apc_fetch ( $ this -> getKey ( ) ) ; if ( ! is_array ( $ cache ) ) { return false ; } else { if ( isset ( $ cache [ $ key ] ) ) { return $ cache [ $ key ] ; } return false ; } }
2145	public function replace ( $ strBuffer , $ blnCache = true ) { $ strBuffer = $ this -> doReplace ( $ strBuffer , $ blnCache ) ; while ( strpos ( $ strBuffer , '{{' ) !== false && ( $ strTmp = $ this -> doReplace ( $ strBuffer , $ blnCache ) ) != $ strBuffer ) { $ strBuffer = $ strTmp ; } return $ strBuffer ; }
4423	protected function doInteract ( ) { $ siteAccess = $ this -> askForData ( 'site-access-name' , 'Enter the name of the Netgen Admin UI siteaccess' , 'ngadminui' , function ( $ siteaccess ) { if ( ! preg_match ( '/^[a-z][a-z0-9_]*$/' , $ siteaccess ) ) { throw new InvalidArgumentException ( 'Siteaccess name is not valid. It must start with a letter, followed by any combination of letters, numbers and underscore.' ) ; } $ existingSiteAccesses = $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.list' ) ; if ( in_array ( $ siteaccess , $ existingSiteAccesses , true ) ) { throw new InvalidArgumentException ( sprintf ( 'Siteaccess "%s" already exists.' , $ siteaccess ) ) ; } return $ siteaccess ; } ) ; $ this -> output -> writeln ( '' ) ; $ languageCode = $ this -> askForData ( 'language-code' , 'Enter the language code in which the Netgen Admin UI will be translated' , 'eng-GB' , function ( $ languageCode ) { $ languageService = $ this -> getContainer ( ) -> get ( 'ezpublish.api.repository' ) -> getContentLanguageService ( ) ; try { $ languageService -> loadLanguage ( $ languageCode ) ; } catch ( NotFoundException $ e ) { throw new InvalidArgumentException ( sprintf ( 'Language code "%s" does not exist.' , $ languageCode ) ) ; } return $ languageCode ; } ) ; $ this -> output -> writeln ( '' ) ; $ availableGroups = array_keys ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish.siteaccess.groups' ) ) ; $ availableGroups [ ] = 'default' ; $ siteAccessGroup = $ this -> askForChoiceData ( 'site-access-group' , 'Enter the siteaccess group name on which the Netgen Admin UI configuration will be based. This is usually the name of your frontend siteaccess group' , $ availableGroups , current ( $ availableGroups ) ) ; $ this -> writeSection ( 'Summary before installation' ) ; $ this -> output -> writeln ( array ( 'You are going to generate legacy <info>' . $ siteAccess . '</info> siteaccess with <info>' . $ languageCode . '</info> language code based on <info>' . $ siteAccessGroup . '</info> siteaccess group.' , '' , ) ) ; if ( ! $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ this -> getConfirmationQuestion ( 'Do you confirm installation (answering <comment>no</comment> will restart the process)' , true ) ) ) { $ this -> output -> writeln ( '' ) ; return false ; } return true ; }
12457	protected function onSuccessLoad ( ) { if ( $ this -> Web2All -> DebugLevel > Web2All_Manager_Main :: DEBUGLEVEL_MEDIUM ) { $ this -> Web2All -> debugLog ( 'Web2All_Table_Object::loadFromTable(): loaded: ' . $ this -> asDebugString ( ) ) ; } }
2940	public static function addUnit ( UnitOfMeasureInterface $ unit ) { if ( static :: unitNameOrAliasesAlreadyRegistered ( $ unit ) ) { throw new Exception \ DuplicateUnitNameOrAlias ( [ ':labels' => implode ( ', ' , array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ) ] ) ; } static :: $ unitDefinitions [ ] = $ unit ; }
6048	public function retrieveObjectType ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/objecttypes/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new ObjectType ( $ result ) ; return $ result ; }
8885	private function send ( ) { $ ch = curl_init ( $ this -> url ) ; curl_setopt ( $ ch , CURLOPT_HEADER , 1 ) ; curl_setopt ( $ ch , CURLOPT_POST , 1 ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , 60 ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , 1 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , 0 ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYHOST , 0 ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ this -> xml ) ; $ result = curl_exec ( $ ch ) ; $ this -> xml = strstr ( $ result , '<?' ) ; $ this -> xml_result = new \ SimpleXMLElement ( $ this -> xml ) ; return $ this -> parseResult ( ) ; }
10749	protected function sendDeleted ( Response $ response , string $ type , array $ ids , array $ extra = [ ] ) : Response { return $ this -> sendVerb ( 'deleted' , $ response , $ type , $ ids , $ extra ) ; }
9077	public function addCollection ( RuleCollection $ collection ) { foreach ( $ collection -> all ( ) as $ name => $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; } $ this -> resources = array_merge ( $ this -> resources , $ collection -> getResources ( ) ) ; }
10472	public function checkInItem ( $ item_id ) { $ request = new CheckInRequest ( $ this -> connector -> agency_id , $ item_id ) ; $ this -> emit ( 'request.checkin' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckInResponse ( $ response ) ; }
4085	public function createStore ( ) { $ request = $ this -> requestStack -> getCurrentRequest ( ) ; return new BreadcrumbStore ( $ this -> iconBuilder , $ this -> translator , $ request ? $ request -> getUri ( ) : '' ) ; }
9875	private function writeLegacyDrawingHF ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getHeaderFooter ( ) -> getImages ( ) ) > 0 ) { $ objWriter -> startElement ( 'legacyDrawingHF' ) ; $ objWriter -> writeAttribute ( 'r:id' , 'rId_headerfooter_vml1' ) ; $ objWriter -> endElement ( ) ; } }
8516	public function updateInboundShipment ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_UpdateInboundShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'UpdateInboundShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_UpdateInboundShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
60	public function addSuggestionsFromPackage ( PackageInterface $ package ) { $ source = $ package -> getPrettyName ( ) ; foreach ( $ package -> getSuggests ( ) as $ target => $ reason ) { $ this -> addPackage ( $ source , $ target , $ reason ) ; } return $ this ; }
11013	protected function importDataFile ( string $ dataFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { $ query = $ this -> db -> createQueryBuilder ( ) ; $ query -> select ( 'count(*) AS count' ) -> from ( $ controlTableName ) ; $ data = $ query -> execute ( ) -> fetchAll ( ) ; $ contentCount = ( int ) $ data [ 0 ] [ 'count' ] ; if ( $ contentCount > 0 ) { $ this -> output -> writeln ( '<comment>Data already exists in the database, skipping data import for file <info>' . $ dataFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ dataFile ) ; }
578	public static function to ( $ url = '' , $ scheme = false ) { if ( is_array ( $ url ) ) { return static :: toRoute ( $ url , $ scheme ) ; } $ url = Yii :: getAlias ( $ url ) ; if ( $ url === '' ) { $ url = Yii :: $ app -> getRequest ( ) -> getUrl ( ) ; } if ( $ scheme === false ) { return $ url ; } if ( static :: isRelative ( $ url ) ) { $ url = static :: getUrlManager ( ) -> getHostInfo ( ) . '/' . ltrim ( $ url , '/' ) ; } return static :: ensureScheme ( $ url , $ scheme ) ; }
3496	private function doSend ( Receiver $ receiver , Notification $ notification , bool $ sandbox ) : void { $ payloadEncoded = $ this -> payloadEncoder -> encode ( $ notification -> getPayload ( ) ) ; $ uri = $ this -> uriFactory -> create ( $ receiver -> getToken ( ) , $ sandbox ) ; $ request = new Request ( $ uri , $ payloadEncoded ) ; $ headers = [ 'content-type' => 'application/json' , 'accept' => 'application/json' , 'apns-topic' => $ receiver -> getTopic ( ) , ] ; $ request = $ request -> withHeaders ( $ headers ) ; $ request = $ this -> authenticator -> authenticate ( $ request ) ; $ request = $ this -> visitor -> visit ( $ notification , $ request ) ; $ response = $ this -> httpSender -> send ( $ request ) ; if ( $ response -> getStatusCode ( ) !== 200 ) { throw $ this -> exceptionFactory -> create ( $ response ) ; } }
4129	public function createQuery ( $ designDocName , $ viewName ) { $ designDoc = $ this -> config -> getDesignDocument ( $ designDocName ) ; if ( $ designDoc ) { $ designDoc = new $ designDoc [ 'className' ] ( $ designDoc [ 'options' ] ) ; } $ query = new ODMQuery ( $ this -> couchDBClient -> getHttpClient ( ) , $ this -> couchDBClient -> getDatabase ( ) , $ designDocName , $ viewName , $ designDoc ) ; $ query -> setDocumentManager ( $ this ) ; return $ query ; }
6509	public function createHandlers ( JobInterface $ job , $ level , $ bubble ) { $ handlers = [ ] ; foreach ( $ this -> factories as $ factory ) { $ handlers [ ] = $ factory -> createHandler ( $ job , $ level , $ bubble ) ; } return $ handlers ; }
10612	public function confirmedAction ( ) { $ user = $ this -> getUser ( ) ; if ( ! is_object ( $ user ) || ! $ user instanceof UserInterface ) { throw $ this -> createAccessDeniedException ( 'This user does not have access to this section.' ) ; } return $ this -> render ( "@MikyUser/Frontend/Registration/confirmed.html.twig" , array ( 'user' => $ user , ) ) ; }
890	public function getTypes ( ) { if ( null === $ this -> types ) { $ this -> types = [ ] ; $ content = $ this -> getTypesContent ( ) ; while ( '' !== $ content && false !== $ content ) { Preg :: match ( '{^' . self :: REGEX_TYPES . '$}x' , $ content , $ matches ) ; $ this -> types [ ] = $ matches [ 'type' ] ; $ content = substr ( $ content , \ strlen ( $ matches [ 'type' ] ) + 1 ) ; } } return $ this -> types ; }
11784	public function update ( $ pageId , $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'page_id' => intval ( $ pageId ) , 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_UPDATE , $ params ] ) ; }
1915	protected function getQuestion ( ) { $ this -> generateCaptcha ( ) ; $ question = $ GLOBALS [ 'TL_LANG' ] [ 'SEC' ] [ 'question' . random_int ( 1 , 3 ) ] ; $ question = sprintf ( $ question , $ this -> arrCaptcha [ 'int1' ] , $ this -> arrCaptcha [ 'int2' ] ) ; $ strEncoded = '' ; $ arrCharacters = Utf8 :: str_split ( $ question ) ; foreach ( $ arrCharacters as $ strCharacter ) { $ strEncoded .= sprintf ( '&#%s;' , Utf8 :: ord ( $ strCharacter ) ) ; } return $ strEncoded ; }
1660	public function reply ( $ reply ) { if ( is_string ( $ reply ) ) { $ this -> replies = [ $ reply ] ; } elseif ( is_array ( $ reply ) ) { $ this -> replies = $ reply ; } return $ this ; }
10871	public function existLogin ( string $ login ) : int { return ( int ) $ this -> connection -> select ( self :: COLUMN_ID ) -> from ( $ this -> tableIdentity ) -> where ( [ 'login' => $ login ] ) -> fetchSingle ( ) ; }
3511	protected function adjustTranslationTable ( $ sql ) { $ adjustedSql = $ this -> tableRenameNeeded ? str_replace ( ' ltm_translations ' , ' ' . $ this -> tableName . ' ' , $ sql ) : $ sql ; return $ adjustedSql ; }
9264	protected function createController ( $ controller ) { $ parts = explode ( ':' , $ controller ) ; if ( count ( $ parts ) === 2 ) { $ service = $ this -> container -> get ( $ parts [ 0 ] ) ; return array ( $ service , $ parts [ 1 ] ) ; } $ controller = parent :: createController ( $ controller ) ; if ( $ controller [ 0 ] instanceof ContainerAwareInterface ) { $ controller [ 0 ] -> setContainer ( $ this -> container ) ; } return $ controller ; }
5012	public function injectLogger ( bool $ flag = null ) : bool { if ( null === $ flag ) { return $ this -> injectLogger ; } $ this -> injectLogger = $ flag ; return $ flag ; }
4951	public function getTargetFQCN ( ) { return is_object ( $ this -> target ) ? get_class ( $ this -> target ) : ( string ) $ this -> target ; }
11789	public function filesAction ( Request $ request , Application $ app ) { $ options = array ( "connector" => $ app [ "red_kite_cms.elfinder_files_connector" ] , ) ; return parent :: show ( $ options ) ; }
3805	public function generate ( ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/metamodelscore/css/style.css' ; $ arrModule = $ GLOBALS [ 'BE_MOD' ] [ 'metamodels' ] [ 'metamodels' ] ; if ( \ Input :: get ( 'key' ) && isset ( $ arrModule [ \ Input :: get ( 'key' ) ] ) ) { Callbacks :: call ( $ arrModule [ \ Input :: get ( 'key' ) ] , $ this , $ arrModule ) ; } $ act = \ Input :: get ( 'act' ) ; if ( ! strlen ( $ act ) ) { $ act = 'showAll' ; } return $ this -> dataContainer -> getEnvironment ( ) -> getController ( ) -> handle ( new Action ( $ act ) ) ; }
7417	protected function setView ( string $ name = '' , array $ data = [ ] ) { if ( ! empty ( $ data ) ) { $ this -> data = array_replace ( $ this -> data , $ data ) ; } $ content = ( new Native ( $ this -> packageRoot , $ this -> request -> language ( ) , ! Wrap :: isEnabled ( ) ) ) -> getContent ( $ name , $ this -> data ) ; $ this -> response -> setContent ( $ content ) ; }
5869	protected static function getVirtualFileObject ( $ fileName , array $ metadata ) { $ resourceFactory = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: class ) ; $ recordData = [ 'uid' => 0 , 'pid' => 0 , 'name' => 'Temporary Upload Storage' , 'description' => 'Internal storage, mounting the temporary PHP upload directory.' , 'driver' => 'Local' , 'processingfolder' => '' , 'configuration' => '' , 'is_online' => true , 'is_browsable' => false , 'is_public' => false , 'is_writable' => false , 'is_default' => false , ] ; $ storageConfiguration = [ 'basePath' => PathUtility :: dirname ( $ fileName ) , 'pathType' => 'absolute' ] ; $ virtualStorage = $ resourceFactory -> createStorageObject ( $ recordData , $ storageConfiguration ) ; $ name = PathUtility :: basename ( $ fileName ) ; $ extension = strtolower ( substr ( $ name , strrpos ( $ name , '.' ) + 1 ) ) ; $ virtualFileObject = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ File :: class , [ 'identifier' => '/' . $ name , 'name' => $ name , 'extension' => $ extension , ] , $ virtualStorage , $ metadata ) ; return $ virtualFileObject ; }
11488	public function setName ( string $ name ) : void { if ( ! empty ( $ name ) ) { if ( ! is_numeric ( $ name ) ) { @ session_name ( $ name ) ; } else { throw new Exception ( 'The session name can\'t consist only of digits, ' . 'at least one letter must be presented.' ) ; } } else { throw new Exception ( 'Empty session name value was passed.' ) ; } }
11766	public function indexOf ( $ expressionOrColumn ) { if ( $ expressionOrColumn instanceof ExpressionContract ) { return $ this -> indexOfExpression ( $ expressionOrColumn ) ; } return $ this -> indexOfColumn ( $ expressionOrColumn ) ; }
9724	public function getFilename ( $ filename , $ extension = 'xlsx' ) { $ originalExtension = pathinfo ( $ filename , PATHINFO_EXTENSION ) ; return $ this -> getTemporaryFolder ( ) . '/' . str_replace ( '.' . $ originalExtension , '.' . $ extension , basename ( $ filename ) ) ; }
3585	protected function getMetaOperator ( $ method , ArgumentBag $ args ) { if ( $ not = $ args -> get ( 'not' ) ) { $ args -> set ( 'not' , false ) ; } return ( $ not ^ $ this -> isWhereNull ( $ method , $ args ) ) ? '<' : '>=' ; }
10478	protected function resolveItemAction ( AbstractDiffItem $ item ) { if ( $ item instanceof CreateDiffItem ) { $ action = ActionTypes :: CREATE ; return $ action ; } elseif ( $ item instanceof DeleteDiffItem ) { $ action = ActionTypes :: DELETE ; return $ action ; } elseif ( $ item instanceof UpdateDiffItem ) { $ action = ActionTypes :: UPDATE ; return $ action ; } else { throw new \ InvalidArgumentException ( 'Unsupported diff item type. Got: ' . get_class ( $ item ) ) ; } }
10825	public static function choice ( $ question , array $ choices , $ defaultValue = null ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( ( string ) $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( count ( $ choices ) > 0 ) { foreach ( $ choices as $ index => $ choice ) { self :: write ( ' [' ) ; self :: write ( ( string ) ( $ index + 1 ) , 'comment' ) ; self :: writeln ( '] ' . $ choice ) ; } } if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( ! isset ( $ choices [ intval ( $ value ) - 1 ] ) ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] Value "' . $ value . '" is invalid' , 'error' ) ; $ value = '' ; } elseif ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
7365	protected function resolveOutstandingDate ( SaleInterface $ sale ) { if ( ! $ sale instanceof InvoiceSubjectInterface ) { return null ; } if ( ! $ sale instanceof ShipmentSubjectInterface ) { return null ; } if ( null === $ term = $ sale -> getPaymentTerm ( ) ) { return null ; } if ( ! $ this -> saleHasOutstandingPayments ( $ sale ) ) { return null ; } $ from = null ; switch ( $ term -> getTrigger ( ) ) { case PaymentTermTriggers :: TRIGGER_SHIPPED : $ from = $ sale -> getShippedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_SHIPPED : if ( $ sale -> getShipmentState ( ) === ShipmentStates :: STATE_COMPLETED ) { $ from = $ sale -> getShippedAt ( true ) ; } break ; case PaymentTermTriggers :: TRIGGER_INVOICED : $ from = $ sale -> getInvoicedAt ( ) ; break ; case PaymentTermTriggers :: TRIGGER_FULLY_INVOICED : if ( $ sale -> getInvoiceState ( ) === InvoiceStates :: STATE_COMPLETED ) { $ from = $ sale -> getInvoicedAt ( true ) ; } break ; } if ( null === $ from ) { return null ; } $ date = clone $ from ; $ date -> setTime ( 23 , 59 , 59 ) ; $ date -> modify ( sprintf ( '+%s days' , $ term -> getDays ( ) ) ) ; if ( $ term -> getEndOfMonth ( ) ) { $ date -> modify ( 'last day of this month' ) ; } return $ date ; }
9042	private function emptyEnvironment ( ) { foreach ( array_keys ( $ _ENV ) as $ key ) { putenv ( $ key ) ; unset ( $ _ENV [ $ key ] ) ; unset ( $ _SERVER [ $ key ] ) ; } }
4680	public function render ( ContainerInterface $ di = null ) { switch ( $ this -> type ) { case "file" : if ( $ di -> has ( "viewRenderFile" ) ) { $ viewRender = $ di -> get ( "viewRenderFile" ) ; } else { $ viewRender = new ViewRenderFile ( $ di ) ; $ viewRender -> setDI ( $ di ) ; } $ viewRender -> render ( $ this -> template , $ this -> templateData ) ; break ; case "callback" : if ( ! is_callable ( $ this -> template ) ) { throw new Exception ( "View is expecting a valid callback, provided callback seems to not be a callable." ) ; } echo call_user_func ( $ this -> template , $ this -> templateData ) ; break ; case "string" : echo $ this -> template ; break ; case "empty" : break ; default : throw new Exception ( "Not a valid template type: '{$this->type}'." ) ; } }
4246	private function logRequest ( ) { $ this -> logRequestHeaders ( ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.cookies' ) ) { $ cookieVals = $ _COOKIE ; \ ksort ( $ cookieVals , SORT_NATURAL ) ; $ this -> debug -> log ( '$_COOKIE' , $ cookieVals ) ; } $ noBody = ! isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) || \ in_array ( $ _SERVER [ 'REQUEST_METHOD' ] , array ( 'CONNECT' , 'GET' , 'HEAD' , 'OPTIONS' , 'TRACE' ) ) ; if ( $ this -> debug -> getCfg ( 'logEnvInfo.post' ) && ! $ noBody ) { if ( $ _POST ) { $ this -> debug -> log ( '$_POST' , $ _POST ) ; } else { $ input = \ file_get_contents ( 'php://input' ) ; if ( $ input ) { $ this -> debug -> log ( 'php://input' , $ input ) ; } elseif ( isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) && empty ( $ _FILES ) ) { $ this -> debug -> warn ( $ _SERVER [ 'REQUEST_METHOD' ] . ' request with no body' ) ; } } if ( ! empty ( $ _FILES ) ) { $ this -> debug -> log ( '$_FILES' , $ _FILES ) ; } } }
2506	public static function exaluateXpathQueryOnWsdl ( $ wsdlId , $ wsdlFilePath , $ xpath ) { WsdlAnalyser :: loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) ; return self :: $ wsdlDomXpath [ $ wsdlId ] -> evaluate ( $ xpath ) ; }
1835	public static function findByIdOrAlias ( $ varId , array $ arrOptions = array ( ) ) { $ isAlias = ! preg_match ( '/^[1-9]\d*$/' , $ varId ) ; if ( ! $ isAlias && empty ( $ arrOptions ) ) { $ objModel = Registry :: getInstance ( ) -> fetch ( static :: $ strTable , $ varId ) ; if ( $ objModel !== null ) { return $ objModel ; } } $ t = static :: $ strTable ; $ arrOptions = array_merge ( array ( 'limit' => 1 , 'column' => $ isAlias ? array ( "$t.alias=?" ) : array ( "$t.id=?" ) , 'value' => $ varId , 'return' => 'Model' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
4914	private function addTraversable ( \ Traversable $ result ) { foreach ( $ result as $ item ) { break ; } if ( ! $ item instanceof EntityInterface ) { throw new \ InvalidArgumentException ( 'Traversable objects must be a non-empty collection of Entity instances.' ) ; } $ name = get_class ( $ item ) ; return $ this -> addArray ( [ 'name' => $ name , 'entities' => $ result , ] ) ; }
9525	public function parse ( $ argv = null , ParameterCluster $ parameterCluster = null ) { $ this -> initialize ( $ argv , $ parameterCluster ) ; return $ this -> checkValidityAndContinueParse ( ) ; }
144	public function insert ( RuleWatchNode $ node ) { if ( $ node -> getRule ( ) -> isAssertion ( ) ) { return ; } foreach ( array ( $ node -> watch1 , $ node -> watch2 ) as $ literal ) { if ( ! isset ( $ this -> watchChains [ $ literal ] ) ) { $ this -> watchChains [ $ literal ] = new RuleWatchChain ; } $ this -> watchChains [ $ literal ] -> unshift ( $ node ) ; } }
11805	public function get ( $ columns = array ( '*' ) ) { $ columnsPassed = ( func_num_args ( ) > 1 ) ; $ columns = $ columnsPassed ? $ columns : $ this -> getQueryColumns ( ) ; $ query = $ this -> buildQuery ( $ columns ) ; if ( ! $ columnsPassed ) { return $ query -> get ( $ this -> getQueryColumns ( ) ) ; } if ( ! $ columns ) { return $ query -> get ( ) ; } return $ query -> get ( $ columns ) ; }
2893	public function canCaptureBlock ( $ block ) { $ blockClass = get_class ( $ block ) ; if ( ! $ this -> canCaptureCoreBlocks ( ) && strpos ( $ blockClass , 'Mage_' ) === 0 ) { return false ; } if ( strpos ( $ blockClass , 'Sheep_Debug_Block' ) > 0 ) { return false ; } return true ; }
6496	public function getCurrentId ( ) { $ args = arg ( ) ; return count ( $ args ) > 1 && $ this -> entityType ( ) === $ args [ 0 ] && $ args [ 1 ] > 0 ? ( int ) $ args [ 1 ] : 0 ; }
328	public static function instance ( $ refresh = false ) { $ className = get_called_class ( ) ; if ( $ refresh || ! isset ( self :: $ _instances [ $ className ] ) ) { self :: $ _instances [ $ className ] = Yii :: createObject ( $ className ) ; } return self :: $ _instances [ $ className ] ; }
8144	public function tokenize ( $ source , $ name = null ) { if ( ! $ source instanceof Twig_Source ) { @ trigger_error ( sprintf ( 'Passing a string as the $source argument of %s() is deprecated since version 1.27. Pass a Twig_Source instance instead.' , __METHOD__ ) , E_USER_DEPRECATED ) ; $ source = new Twig_Source ( $ source , $ name ) ; } if ( null === $ this -> lexer ) { $ this -> lexer = new Twig_Lexer ( $ this ) ; } return $ this -> lexer -> tokenize ( $ source ) ; }
3066	public function process ( QtiRunnerServiceContext $ context , array $ data = [ ] ) { return $ this -> getServiceManager ( ) -> get ( SynchronisationService :: SERVICE_ID ) -> process ( $ data , $ context ) ; }
3644	public function map ( array $ keys , bool $ trim = true , bool $ clean = true ) { $ values = $ this -> only ( array_keys ( $ keys ) , $ trim , $ clean ) ; $ new = [ ] ; foreach ( $ keys as $ key => $ value ) { $ new [ $ value ] = array_get ( $ values , $ key ) ; } return $ new ; }
5603	public function paintException ( $ exception ) { if ( ! $ this -> fail && ! $ this -> error ) { $ this -> error = true ; $ message = 'Unexpected exception of type[' . get_class ( $ exception ) . '] with message [' . $ exception -> getMessage ( ) . '] in [' . $ exception -> getFile ( ) . ' line ' . $ exception -> getLine ( ) . ']' ; $ this -> message = self :: escapeVal ( $ message ) ; $ this -> listener -> write ( '{status:"error",message:"' . $ this -> message . '",group:"' . $ this -> group . '",case:"' . $ this -> case . '",method:"' . $ this -> method . '"}' ) ; } }
12689	public function get ( $ namespace , $ name , $ default = null , $ require = false ) { $ configuration = $ this -> load ( $ namespace , $ require ) ; return array_key_exists ( $ name , $ configuration ) ? $ configuration [ $ name ] : $ default ; }
10716	public function deleteMany ( ArrayAccess $ models ) { $ results = [ ] ; foreach ( $ models as $ model ) { $ results [ ] = $ this -> delete ( $ model ) ; } return $ this -> returnResults ( $ results ) ; }
8332	public function listSequences ( $ database = null ) { $ query = "SELECT name FROM sysobjects WHERE xtype = 'U'" ; $ tableNames = $ this -> _conn -> fetchAll ( $ query ) ; return array_map ( [ $ this -> _conn -> formatter , 'fixSequenceName' ] , $ tableNames ) ; }
3998	protected function getAttribute ( $ metaModelIdOrName , $ intDataId , $ strAttributeName , $ strOutput = 'raw' ) { $ objMM = $ this -> loadMetaModel ( $ metaModelIdOrName ) ; if ( null === $ objMM ) { return false ; } if ( empty ( $ strOutput ) ) { $ strOutput = 'raw' ; } $ objMetaModelItem = $ objMM -> findById ( $ intDataId ) ; if ( null === $ objMetaModelItem ) { throw new \ RuntimeException ( 'MetaModel item not found: ' . $ intDataId ) ; } $ arrAttr = $ objMetaModelItem -> parseAttribute ( $ strAttributeName ) ; return $ arrAttr [ $ strOutput ] ; }
622	public function with ( ) { $ with = func_get_args ( ) ; if ( isset ( $ with [ 0 ] ) && is_array ( $ with [ 0 ] ) ) { $ with = $ with [ 0 ] ; } if ( empty ( $ this -> with ) ) { $ this -> with = $ with ; } elseif ( ! empty ( $ with ) ) { foreach ( $ with as $ name => $ value ) { if ( is_int ( $ name ) ) { $ this -> with [ ] = $ value ; } else { $ this -> with [ $ name ] = $ value ; } } } return $ this ; }
6910	public function addExtraCopy ( Recipient $ copy ) { if ( ! $ this -> extraCopies -> contains ( $ copy ) ) { $ this -> extraCopies -> add ( $ copy ) ; } return $ this ; }
9401	public function setHttp ( ServerRequestInterface $ request , ResponseInterface $ response ) { $ this -> set ( 'Psr\Http\Message\ServerRequestInterface' , $ request ) ; return $ this -> set ( 'Psr\Http\Message\ResponseInterface' , $ response ) ; }
8021	public function payload ( array $ payload ) { $ client = new GuzzleClient ( [ 'base_uri' => $ this -> server ] ) ; $ client -> request ( 'POST' , $ this -> getUri ( ) , [ 'form_params' => [ 'payload' => json_encode ( $ payload ) ] ] ) ; }
2871	public function getModules ( ) { $ items = array ( ) ; $ items [ ] = array ( 'module' => 'Magento' , 'codePool' => 'core' , 'active' => true , 'version' => $ this -> getMagentoVersion ( ) ) ; $ modulesConfig = Mage :: getConfig ( ) -> getModuleConfig ( ) ; foreach ( $ modulesConfig as $ node ) { foreach ( $ node as $ module => $ data ) { $ items [ ] = array ( 'module' => $ module , 'codePool' => ( string ) $ data -> codePool , 'active' => $ data -> active == 'true' , 'version' => ( string ) $ data -> version ) ; } } return $ items ; }
12144	public static function login ( $ rank = 1 , $ id = null ) { static :: provider ( ) -> set ( 'valid' , true ) ; static :: provider ( ) -> set ( 'rank' , $ rank ) ; static :: provider ( ) -> set ( 'id' , $ id ) ; return static :: user ( ) ; }
2268	public function isUniqueValue ( $ strTable , $ strField , $ varValue , $ intId = null ) { $ strQuery = "SELECT * FROM $strTable WHERE " . static :: quoteIdentifier ( $ strField ) . "=?" ; if ( $ intId !== null ) { $ strQuery .= " AND id!=?" ; } $ objUnique = $ this -> prepare ( $ strQuery ) -> limit ( 1 ) -> execute ( $ varValue , $ intId ) ; return $ objUnique -> numRows ? false : true ; }
4657	public function run ( Job $ job , $ command ) { if ( is_string ( $ command ) ) { $ command = [ '/bin/bash' , '-c' , $ command ] ; } $ image = $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; $ hostConfig = new HostConfig ( ) ; $ config = new ContainerConfig ( ) ; $ config -> setCmd ( $ command ) ; $ config -> setImage ( $ image -> getId ( ) ) ; $ config -> setHostConfig ( $ hostConfig ) ; $ config -> setLabels ( new \ ArrayObject ( [ 'com.jolici.container=true' ] ) ) ; $ config -> setAttachStderr ( true ) ; $ config -> setAttachStdout ( true ) ; $ links = [ ] ; foreach ( $ job -> getServices ( ) as $ service ) { if ( $ service -> getContainer ( ) ) { $ serviceContainer = $ this -> docker -> getContainerManager ( ) -> find ( $ service -> getContainer ( ) ) ; $ links [ ] = sprintf ( '%s:%s' , $ serviceContainer -> getName ( ) , $ service -> getName ( ) ) ; } } $ hostConfig -> setLinks ( $ links ) ; $ containerCreateResult = $ this -> docker -> getContainerManager ( ) -> create ( $ config ) ; $ attachStream = $ this -> docker -> getContainerManager ( ) -> attach ( $ containerCreateResult -> getId ( ) , [ 'stream' => true , 'stdout' => true , 'stderr' => true , ] , ContainerManager :: FETCH_STREAM ) ; $ attachStream -> onStdout ( $ this -> logger -> getRunStdoutCallback ( ) ) ; $ attachStream -> onStderr ( $ this -> logger -> getRunStderrCallback ( ) ) ; $ this -> docker -> getContainerManager ( ) -> start ( $ containerCreateResult -> getId ( ) ) ; $ attachStream -> wait ( ) ; $ containerWait = $ this -> docker -> getContainerManager ( ) -> wait ( $ containerCreateResult -> getId ( ) ) ; return $ containerWait -> getStatusCode ( ) ; }
3672	private function getPageCandidates ( string $ alias ) { $ aliases = [ $ alias ] ; while ( '/' !== $ alias && false !== strpos ( $ alias , '/' ) ) { $ alias = \ dirname ( $ alias ) ; $ aliases [ ] = $ alias ; } $ pages = $ this -> pageModelAdapter -> findByAliases ( $ aliases ) ; if ( null === $ pages ) { return null ; } $ arrPages = [ ] ; while ( $ pages -> next ( ) ) { $ objModel = $ pages -> current ( ) ; $ objPage = $ objModel -> loadDetails ( ) ; $ domain = $ objPage -> domain ? : '*' ; $ arrPages [ $ domain ] [ $ objPage -> rootLanguage ] [ ] = $ objPage ; if ( $ objPage -> rootIsFallback ) { $ arrPages [ $ domain ] [ '*' ] [ ] = $ objPage ; } } return $ arrPages ; }
9812	protected function putRaw ( string $ path , $ body = null , array $ headers = [ ] ) { $ response = $ this -> client -> put ( $ path , $ headers , $ body ) ; return ResponseMediator :: getContent ( $ response ) ; }
7064	protected function supports ( PaymentInterface $ payment ) { if ( null === $ method = $ payment -> getMethod ( ) ) { throw new RuntimeException ( "Payment method must be set." ) ; } if ( $ method -> isCredit ( ) || $ method -> isOutstanding ( ) ) { return true ; } return false ; }
807	public function generate ( $ input ) { $ tokens = [ ] ; $ parts = explode ( '\\' , $ input ) ; foreach ( $ parts as $ index => $ part ) { $ tokens [ ] = new Token ( [ T_STRING , $ part ] ) ; if ( $ index !== \ count ( $ parts ) - 1 ) { $ tokens [ ] = new Token ( [ T_NS_SEPARATOR , '\\' ] ) ; } } return $ tokens ; }
1395	public function withEncoding ( int $ options = 0 , int $ depth = 512 , string $ mediaType = MediaTypeInterface :: JSON_API_MEDIA_TYPE ) { $ encoding = Encoding :: create ( $ mediaType , $ options , $ this -> api -> getUrl ( ) -> toString ( ) , $ depth ) ; $ codec = $ this -> factory -> createCodec ( $ this -> api -> getContainer ( ) , $ encoding , null ) ; return $ this -> withCodec ( $ codec ) ; }
2334	public function onSwitchUser ( SwitchUserEvent $ event ) : void { $ token = $ this -> tokenStorage -> getToken ( ) ; if ( null === $ token ) { throw new \ RuntimeException ( 'The token storage did not contain a token.' ) ; } $ sourceUser = $ token -> getUser ( ) ; if ( $ sourceUser instanceof UserInterface ) { $ sourceUser = $ sourceUser -> getUsername ( ) ; } $ targetUser = $ event -> getTargetUser ( ) ; if ( $ targetUser instanceof UserInterface ) { $ targetUser = $ targetUser -> getUsername ( ) ; } $ this -> logger -> info ( sprintf ( 'User "%s" has switched to user "%s"' , $ sourceUser , $ targetUser ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ sourceUser ) ] ) ; }
6235	public function mkdir ( ) : self { if ( ! $ this -> storage -> isDir ( ) ) { if ( ! $ this -> storage -> mkdir ( ) ) { throw new AccessDeniedException ( sprintf ( 'unable to create directory at: "%s"' , $ this -> storage -> path ( ) -> raw ) , 500 ) ; } } return $ this ; }
9733	public function setARGB ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: COLOR_BLACK ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'argb' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> argb = $ pValue ; } return $ this ; }
3257	public function scopeWhereSKU ( $ query , $ sku ) { return $ query -> join ( config ( 'shop.item_table' ) , config ( 'shop.item_table' ) . '.order_id' , '=' , $ this -> table . '.id' ) -> where ( config ( 'shop.item_table' ) . '.sku' , $ sku ) ; }
11480	private function getJsonBody ( RequestInterface $ request , ResponseInterface $ response ) : array { $ data = json_decode ( $ response -> getBody ( ) , true ) ; if ( ! $ data || ! is_array ( $ data ) || ! array_key_exists ( "data" , $ data ) ) { throw new ClientException ( "Response body does not contain a valid JSON object." , $ request , $ response ) ; } if ( ! is_array ( $ data ) || ! is_array ( $ data [ "data" ] ) ) { throw new ClientException ( "Not sure what happened. The list jobs endpoint didn't return a list. :worried:" , $ request , $ response ) ; } return $ data [ "data" ] ; }
6841	public function getCache ( $ key ) { return isset ( $ this -> caches [ $ key ] ) ? $ this -> caches [ $ key ] : null ; }
12550	public function installAssets ( ) { $ this -> doInstallAssets ( $ this -> core ) ; $ this -> doInstallAssets ( $ this -> blocks ) ; $ this -> doInstallAssets ( $ this -> themes ) ; }
4238	public function hasLog ( ) { $ entryCountInitial = $ this -> debug -> getData ( 'entryCountInitial' ) ; $ entryCountCurrent = $ this -> debug -> getData ( 'log/__count__' ) ; $ haveLog = $ entryCountCurrent > $ entryCountInitial ; $ lastEntryMethod = $ this -> debug -> getData ( 'log/__end__/0' ) ; return $ haveLog && $ lastEntryMethod !== 'clear' ; }
10860	protected function createObject ( string $ typeName , ? bool $ nullable = false , ? bool $ checkCycles = true , ? bool $ treatAsNotFound = true ) : ? object { if ( $ checkCycles ) { $ this -> underConstruction [ $ typeName ] = true ; } try { if ( ! isset ( $ this -> typeCache [ $ typeName ] ) ) { if ( \ class_exists ( $ typeName ) || \ interface_exists ( $ typeName , false ) ) { $ this -> typeCache [ $ typeName ] = new \ ReflectionClass ( $ typeName ) ; } else { $ this -> typeCache [ $ typeName ] = false ; } } if ( $ this -> typeCache [ $ typeName ] === false ) { if ( $ nullable ) { return null ; } if ( $ treatAsNotFound ) { throw new NotFoundException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } throw new ContainerException ( \ sprintf ( 'Cannot load type: %s' , $ typeName ) ) ; } if ( ! $ this -> typeCache [ $ typeName ] -> isInstantiable ( ) ) { if ( $ nullable ) { return null ; } throw new NotFoundException ( \ sprintf ( 'Type is not instantiable: %s' , $ typeName ) ) ; } if ( isset ( $ this -> constructorCache [ $ typeName ] ) ) { $ con = $ this -> constructorCache [ $ typeName ] ; } else { $ con = $ this -> constructorCache [ $ typeName ] = $ this -> typeCache [ $ typeName ] -> getConstructor ( ) ? : false ; } return ( $ con === false ) ? new $ typeName ( ) : new $ typeName ( ... $ this -> populateArguments ( $ con , null , $ typeName ) ) ; } finally { if ( $ checkCycles ) { unset ( $ this -> underConstruction [ $ typeName ] ) ; } } }
12041	public function getFullName ( $ first = NULL , $ middle = NULL , $ last = NULL ) { $ user_first_name = $ this -> getPropertyValue ( "user_first_name" ) ; $ user_middle_name = $ this -> getPropertyValue ( "user_middle_name" ) ; $ user_last_name = $ this -> getPropertyValue ( "user_last_name" ) ; $ user_full_name = implode ( ' ' , array ( empty ( $ user_first_name ) ? $ first : $ user_first_name , empty ( $ user_middle_name ) ? $ middle : $ user_middle_name , empty ( $ user_last_name ) ? $ last : $ user_last_name ) ) ; if ( ! empty ( $ user_full_name ) ) { return $ user_full_name ; } }
5729	public function bindGridField ( Form $ form , GridFieldDetailForm_ItemRequest $ request ) { $ this -> setForm ( $ form ) ; $ this -> gridFieldRequest = $ request ; foreach ( $ this -> children as $ child ) { if ( ! $ child instanceof BetterButton && ! $ child instanceof BetterButtonAction ) { throw new Exception ( "DropdownFormAction must be passed instances of BetterButton" ) ; } $ child -> bindGridField ( $ form , $ request ) ; $ child -> setIsGrouped ( true ) ; if ( $ child instanceof FormAction ) { $ child -> setUseButtonTag ( true ) ; } } return $ this ; }
3392	public function resendConfirmation ( Request $ request ) { $ model = $ this -> guard ( ) -> getProvider ( ) -> createModel ( ) ; $ user = $ model -> findOrFail ( $ request -> session ( ) -> pull ( 'confirmation_user_id' ) ) ; $ this -> sendConfirmationToUser ( $ user ) ; return redirect ( $ this -> redirectAfterResendConfirmationPath ( ) ) -> with ( 'confirmation' , __ ( 'confirmation::confirmation.confirmation_resent' ) ) ; }
3386	public function authenticate ( $ identity , $ credential ) { $ adapter = $ this -> auth -> getAdapter ( ) ; $ adapter -> setIdentity ( $ identity ) ; $ adapter -> setCredential ( $ credential ) ; return $ this -> auth -> authenticate ( ) ; }
10854	protected function buildCol ( ) { $ result = [ ] ; foreach ( $ this -> col_defs as $ col ) { $ res = [ ] ; $ res [ ] = $ this -> quote ( $ col [ 'name' ] ) ; $ res [ ] = $ col [ 'type' ] ; if ( isset ( $ col [ 'notNull' ] ) ) { $ res [ ] = 'NOT NULL' . ( $ col [ 'notNull' ] ? ( ' ' . $ col [ 'notNull' ] ) : '' ) ; } if ( isset ( $ col [ 'default' ] ) ) { $ res [ ] = 'DEFAULT ' . ( $ col [ 'default' ] [ 1 ] ? $ col [ 'default' ] [ 0 ] : $ this -> processValue ( $ col [ 'default' ] [ 0 ] ) ) ; } if ( isset ( $ col [ 'autoincrement' ] ) ) { $ res [ ] = 'AUTO_INCREMENT' ; } if ( isset ( $ col [ 'unique' ] ) ) { $ res [ ] = 'UNIQUE' . ( $ col [ 'unique' ] ? ( ' ' . $ col [ 'unique' ] ) : '' ) ; } if ( isset ( $ col [ 'primary' ] ) ) { $ res [ ] = 'PRIMARY KEY' . ( $ col [ 'primary' ] ? ( ' ' . $ col [ 'primary' ] ) : '' ) ; } if ( isset ( $ col [ 'constraint' ] ) ) { $ res [ ] = join ( ' ' , $ col [ 'constraint' ] ) ; } array_walk ( $ res , function ( $ m ) { return trim ( $ m ) ; } ) ; $ result [ ] = join ( ' ' , $ res ) ; } return $ result ; }
6626	public function processRequest ( Request $ request , Controller $ controller , array $ requestChain = null ) { $ reflectionController = $ this -> getControllerReflector ( ) -> reflectController ( $ controller ) ; if ( is_null ( $ requestChain ) ) { $ requestChain = $ request -> getRequestChain ( ) ; } $ nextLink = array_shift ( $ requestChain ) ; if ( $ nextLink ) { if ( $ reflectionController -> hasChildController ( $ nextLink ) ) { return $ this -> processRequest ( $ request , $ reflectionController -> getChildController ( $ nextLink ) , $ requestChain ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , $ nextLink ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , $ nextLink , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } $ message = "Could not find controller or endpoint matching '$nextLink'" ; throw new Exception ( $ message , 404 ) ; } if ( $ reflectionController -> hasEndpoint ( $ request -> getMethod ( ) , 'index' ) ) { $ data = $ reflectionController -> getEndpointResult ( $ request -> getMethod ( ) , 'index' , $ request ) ; $ this -> setStatus ( $ reflectionController -> getStatus ( ) ) ; return $ data ; } return $ reflectionController -> getDocumentation ( ) ; }
6769	public function onStateChange ( ResourceEventInterface $ event ) { $ sale = $ this -> getSaleFromEvent ( $ event ) ; if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ sale ) ) { $ event -> stopPropagation ( ) ; return ; } $ this -> handleStateChange ( $ sale ) ; }
1067	private function findConflictsBetweenSubSelectionSets ( ValidationContext $ context , $ areMutuallyExclusive , $ parentType1 , SelectionSetNode $ selectionSet1 , $ parentType2 , SelectionSetNode $ selectionSet2 ) { $ conflicts = [ ] ; [ $ fieldMap1 , $ fragmentNames1 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType1 , $ selectionSet1 ) ; [ $ fieldMap2 , $ fragmentNames2 ] = $ this -> getFieldsAndFragmentNames ( $ context , $ parentType2 , $ selectionSet2 ) ; $ this -> collectConflictsBetween ( $ context , $ conflicts , $ areMutuallyExclusive , $ fieldMap1 , $ fieldMap2 ) ; $ fragmentNames2Length = count ( $ fragmentNames2 ) ; if ( $ fragmentNames2Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap1 , $ fragmentNames2 [ $ j ] ) ; } } $ fragmentNames1Length = count ( $ fragmentNames1 ) ; if ( $ fragmentNames1Length !== 0 ) { $ comparedFragments = [ ] ; for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { $ this -> collectConflictsBetweenFieldsAndFragment ( $ context , $ conflicts , $ comparedFragments , $ areMutuallyExclusive , $ fieldMap2 , $ fragmentNames1 [ $ i ] ) ; } } for ( $ i = 0 ; $ i < $ fragmentNames1Length ; $ i ++ ) { for ( $ j = 0 ; $ j < $ fragmentNames2Length ; $ j ++ ) { $ this -> collectConflictsBetweenFragments ( $ context , $ conflicts , $ areMutuallyExclusive , $ fragmentNames1 [ $ i ] , $ fragmentNames2 [ $ j ] ) ; } } return $ conflicts ; }
6723	protected function validateAuthParams ( ) { if ( empty ( $ this -> authUrl ) || filter_var ( $ this -> authUrl , FILTER_VALIDATE_URL ) === false ) { throw new Oauth2ClientException ( sprintf ( self :: INVALID_AUTH_URL , $ this -> authUrl ) ) ; } if ( empty ( $ this -> clientId ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_ID ) ; } if ( empty ( $ this -> clientSecret ) ) { throw new Oauth2ClientException ( self :: INVALID_CLIENT_SECRET ) ; } return true ; }
7025	public function addRememberMeCookie ( $ userId , $ options = [ ] ) { $ options = Hash :: merge ( [ 'expires' => '+14 days' , 'httpOnly' => true , 'secure' => false ] , $ options ) ; $ this -> Cookie -> config ( $ options ) ; $ this -> Cookie -> write ( 'User.id' , $ userId ) ; }
9375	public function render ( $ template , array $ data = array ( ) ) { list ( $ file , $ name ) = array ( null , str_replace ( '.' , '/' , $ template ) ) ; foreach ( ( array ) $ this -> paths as $ key => $ path ) { $ files = ( array ) $ this -> files ( $ path ) ; $ item = $ this -> check ( $ files , $ path , $ key , $ name . '.php' ) ; $ item !== null && $ file = $ item ; } if ( is_null ( $ file ) === true ) { $ message = 'Template file "' . $ name . '" not found.' ; throw new \ InvalidArgumentException ( ( string ) $ message ) ; } return $ this -> extract ( $ file , $ data ) ; }
8640	public function setShipmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ShipmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3636	public function rpcMiddles ( Request $ request ) : array { $ beanName = 'serviceDispatcher' ; if ( ! \ Swoft :: hasBean ( $ beanName ) ) { return [ ] ; } $ dispatcher = \ bean ( $ beanName ) ; $ middleType = ( int ) $ request -> query ( 'type' ) ; if ( $ middleType === 1 ) { return $ dispatcher -> getMiddlewares ( ) ; } return $ dispatcher -> requestMiddleware ( ) ; }
11237	public function saveUrl ( $ url = false , $ append = '' ) { if ( $ url == false ) { $ url = '//' . $ this -> config [ 'base_url' ] . $ _SERVER [ 'REQUEST_URI' ] ; } $ this -> saved = $ this -> getRedirect ( $ url ) . $ append ; $ this -> session -> savedUrl = $ this -> saved ; }
10544	public function setSites ( array $ sites ) { $ this -> sites = array ( ) ; foreach ( $ sites as $ site ) $ this -> addSite ( $ site ) ; return $ this ; }
12780	public function setState ( $ key , $ value ) { return Yii :: $ app -> webState -> set ( $ this -> stateKeyName ( $ key ) , $ value ) ; }
12411	public function lists ( $ begin , $ count ) { $ params = [ 'begin' => intval ( $ begin ) , 'count' => intval ( $ count ) , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_LIST , $ params ] ) ; }
428	public function init ( ) { if ( $ this -> controllerNamespace === null ) { $ class = get_class ( $ this ) ; if ( ( $ pos = strrpos ( $ class , '\\' ) ) !== false ) { $ this -> controllerNamespace = substr ( $ class , 0 , $ pos ) . '\\controllers' ; } } }
8542	public function setPluralForm ( $ key , $ plural ) { if ( ! is_array ( $ plural ) ) $ plural = [ $ plural ] ; if ( ! $ this -> msgstr_plural ) $ this -> msgstr_plural = [ ] ; $ this -> msgstr_plural [ $ key ] = $ plural ; }
6725	public static function getAccessToken ( ) { $ oauthClientParams = ArrayHelper :: getValue ( \ Yii :: $ app -> params , 'oauth' ) ; $ oauthClient = new Oauth2Client ( $ oauthClientParams ) ; $ code = $ oauthClient -> authorize ( ) ; $ token = $ oauthClient -> fetchAccessToken ( $ code ) ; $ accessToken = ArrayHelper :: getValue ( $ token , 'access_token' ) ; return $ accessToken ; }
689	public function addRules ( $ rules , $ append = true ) { if ( ! $ this -> enablePrettyUrl ) { return ; } $ rules = $ this -> buildRules ( $ rules ) ; if ( $ append ) { $ this -> rules = array_merge ( $ this -> rules , $ rules ) ; } else { $ this -> rules = array_merge ( $ rules , $ this -> rules ) ; } }
7682	function Ext_DeductFormat ( & $ Ext , $ Search ) { if ( strpos ( ',odt,ods,odg,odf,odp,odm,ott,ots,otg,otp,' , ',' . $ Ext . ',' ) !== false ) return 'odf' ; if ( strpos ( ',docx,xlsx,xlsm,pptx,' , ',' . $ Ext . ',' ) !== false ) return 'openxml' ; if ( ! $ Search ) return false ; if ( $ this -> FileExists ( 'content.xml' ) ) { if ( $ this -> FileExists ( 'META-INF/manifest.xml' ) ) { $ Ext = '?' ; return 'odf' ; } } elseif ( $ this -> FileExists ( '[Content_Types].xml' ) ) { if ( $ this -> FileExists ( 'word/document.xml' ) ) { $ Ext = 'docx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'xl/workbook.xml' ) ) { $ Ext = 'xlsx' ; return 'openxml' ; } elseif ( $ this -> FileExists ( 'ppt/presentation.xml' ) ) { $ Ext = 'pptx' ; return 'openxml' ; } } return false ; }
4262	public function subscribe ( $ eventName , $ callable , $ priority = 0 ) { unset ( $ this -> sorted [ $ eventName ] ) ; $ this -> subscribers [ $ eventName ] [ $ priority ] [ ] = $ callable ; }
5820	protected function transformFiles ( $ files ) { $ result = [ ] ; foreach ( $ files as $ file ) { $ result [ ] = [ 'type' => $ file [ 'content_type' ] === 'application/directory' ? 'dir' : 'file' , 'path' => $ file [ 'name' ] , 'size' => intval ( $ file [ 'bytes' ] ) , 'timestamp' => strtotime ( $ file [ 'last_modified' ] ) , 'mimetype' => $ file [ 'content_type' ] , ] ; } return $ result ; }
7059	public function addClass ( $ class ) { $ classes = $ this -> getClasses ( ) ; if ( ! in_array ( $ class , $ classes ) ) { $ classes [ ] = $ class ; } $ this -> setClasses ( $ classes ) ; return $ this ; }
3501	public function withCollapseId ( CollapseId $ collapseId = null ) : Notification { $ cloned = clone $ this ; $ cloned -> collapseId = $ collapseId ; return $ cloned ; }
7717	function FileGetState ( $ NameOrIdx ) { $ idx = $ this -> FileGetIdx ( $ NameOrIdx ) ; if ( $ idx === false ) { $ idx = $ this -> FileGetIdxAdd ( $ NameOrIdx ) ; if ( $ idx === false ) { return false ; } else { return 'a' ; } } elseif ( isset ( $ this -> ReplInfo [ $ idx ] ) ) { if ( $ this -> ReplInfo [ $ idx ] === false ) { return 'd' ; } else { return 'm' ; } } else { return 'u' ; } }
10076	public static function controlCharacterPHP2OOXML ( $ value ) { self :: buildCharacterSets ( ) ; return str_replace ( array_values ( self :: $ controlCharacters ) , array_keys ( self :: $ controlCharacters ) , $ value ) ; }
7113	public function urlAllowed ( $ user , $ url ) { if ( empty ( $ url ) ) { return false ; } if ( is_array ( $ url ) ) { $ url = Hash :: merge ( [ 'plugin' => null ] , $ url ) ; $ url = Router :: url ( $ url ) ; $ url = Router :: normalize ( $ url ) ; } $ route = Router :: parse ( $ url ) ; if ( empty ( $ route [ 'controller' ] ) || empty ( $ route [ 'action' ] ) ) { return false ; } return $ this -> isAuthorized ( $ user , $ route [ 'plugin' ] , $ route [ 'controller' ] , $ route [ 'action' ] ) ; }
151	public function createCommand ( $ db = null ) { if ( $ db === null ) { $ db = Yii :: $ app -> getDb ( ) ; } list ( $ sql , $ params ) = $ db -> getQueryBuilder ( ) -> build ( $ this ) ; $ command = $ db -> createCommand ( $ sql , $ params ) ; $ this -> setCommandCache ( $ command ) ; return $ command ; }
2608	public function getCurrentVersion ( array $ versions ) { if ( ! empty ( $ versions ) ) { foreach ( $ versions as $ version ) { if ( $ version -> active ) { return $ activeVersion = $ version -> number ; } } } throw new LocalizedException ( __ ( 'Error fetching current version.' ) ) ; }
30	public function appendPackages ( array $ packages , array $ bucket ) { foreach ( $ packages as $ package ) { $ bucket [ $ package -> getName ( ) ] = $ package ; } return $ bucket ; }
8586	public function setCompetitivePrice ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'CompetitivePrice' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2467	private function setImpersonatedLogout ( ) { $ token = System :: getContainer ( ) -> get ( 'security.token_storage' ) -> getToken ( ) ; if ( ! $ token instanceof TokenInterface ) { return ; } $ impersonatorUser = null ; foreach ( $ token -> getRoles ( ) as $ role ) { if ( $ role instanceof SwitchUserRole ) { $ impersonatorUser = $ role -> getSource ( ) -> getUsername ( ) ; break ; } } if ( ! $ impersonatorUser ) { return ; } $ request = System :: getContainer ( ) -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( $ request === null ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } $ firewallMap = System :: getContainer ( ) -> get ( 'security.firewall.map' ) ; if ( ( $ firewallConfig = $ firewallMap -> getFirewallConfig ( $ request ) ) === null || ( $ switchUserConfig = $ firewallConfig -> getSwitchUser ( ) ) === null ) { return ; } $ arrParams = array ( 'do' => 'user' , urlencode ( $ switchUserConfig [ 'parameter' ] ) => SwitchUserListener :: EXIT_VALUE ) ; $ this -> Template -> logout = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'switchBT' ] , $ impersonatorUser ) ; $ this -> Template -> logoutLink = System :: getContainer ( ) -> get ( 'router' ) -> generate ( 'contao_backend' , $ arrParams ) ; }
10474	public function lookupItem ( $ item_id ) { $ request = new ItemRequest ( $ item_id ) ; $ this -> emit ( 'request.item' , array ( $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new ItemResponse ( $ response ) ; }
1955	public function getStyleSheets ( Contao \ DataContainer $ dc ) { $ intPid = $ dc -> activeRecord -> pid ; if ( Contao \ Input :: get ( 'act' ) == 'overrideAll' ) { $ intPid = Contao \ Input :: get ( 'id' ) ; } $ objStyleSheet = $ this -> Database -> prepare ( "SELECT id, name FROM tl_style_sheet WHERE pid=?" ) -> execute ( $ intPid ) ; if ( $ objStyleSheet -> numRows < 1 ) { return array ( ) ; } $ return = array ( ) ; while ( $ objStyleSheet -> next ( ) ) { $ return [ $ objStyleSheet -> id ] = $ objStyleSheet -> name ; } return $ return ; }
3793	private function hasVariants ( ) { $ metaModel = $ this -> factory -> getMetaModel ( $ this -> providerName ) ; if ( $ metaModel === null ) { throw new \ RuntimeException ( sprintf ( 'Could not find a MetaModels with the name %s' , $ this -> providerName ) ) ; } return $ metaModel -> hasVariants ( ) ; }
12369	public function authenticate ( $ accountKey , $ uniqueUserId , $ authMethod = null ) { if ( null === $ authMethod ) { $ authMethod = self :: AUTH_HTTP_TOKEN ; } $ this -> getHttpClient ( ) -> authenticate ( $ accountKey , $ uniqueUserId , $ authMethod ) ; }
185	protected function renderInputHtml ( $ type ) { if ( $ this -> hasModel ( ) ) { return Html :: activeInput ( $ type , $ this -> model , $ this -> attribute , $ this -> options ) ; } return Html :: input ( $ type , $ this -> name , $ this -> value , $ this -> options ) ; }
3152	protected function onTimeout ( RunnerServiceContext $ context , AssessmentTestSessionException $ timeOutException ) { $ session = $ context -> getTestSession ( ) ; $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , true ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ isLinear = $ session -> getCurrentNavigationMode ( ) === NavigationMode :: LINEAR ; switch ( $ timeOutException -> getCode ( ) ) { case AssessmentTestSessionException :: ASSESSMENT_TEST_DURATION_OVERFLOW : \ common_Logger :: i ( 'TIMEOUT: closing the assessment test session' ) ; $ session -> endTestSession ( ) ; break ; case AssessmentTestSessionException :: TEST_PART_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next test part' ) ; $ session -> moveNextTestPart ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment test part' ) ; $ session -> closeTestPart ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_SECTION_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next assessment section' ) ; $ session -> moveNextAssessmentSection ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment section session' ) ; $ session -> closeAssessmentSection ( ) ; } break ; case AssessmentTestSessionException :: ASSESSMENT_ITEM_DURATION_OVERFLOW : if ( $ isLinear ) { \ common_Logger :: i ( 'TIMEOUT: moving to the next item' ) ; $ session -> moveNextAssessmentItem ( ) ; } else { \ common_Logger :: i ( 'TIMEOUT: closing the assessment item session' ) ; $ session -> closeAssessmentItem ( ) ; } break ; } $ event = new TestTimeoutEvent ( $ session , $ timeOutException -> getCode ( ) , false ) ; $ this -> getServiceManager ( ) -> get ( EventManager :: SERVICE_ID ) -> trigger ( $ event ) ; $ this -> continueInteraction ( $ context ) ; }
5072	public function getHtmlMenu ( $ markup , $ topLevel = 1 , $ depth = 6 , RendererInterface $ renderer = null ) { if ( ! $ renderer ) { $ renderer = new ListRenderer ( new Matcher ( ) , [ 'currentClass' => 'active' , 'ancestorClass' => 'active_ancestor' ] ) ; } return $ renderer -> render ( $ this -> getMenu ( $ markup , $ topLevel , $ depth ) ) ; }
5213	private function getBinding ( $ type , $ name = null ) { $ binding = $ this -> findBinding ( $ type , $ name ) ; if ( null === $ binding ) { throw new BindingException ( 'No binding for ' . $ type . ' defined' ) ; } return $ binding ; }
1039	private static function printPath ( ? array $ path = null ) { $ pathStr = '' ; $ currentPath = $ path ; while ( $ currentPath ) { $ pathStr = ( is_string ( $ currentPath [ 'key' ] ) ? '.' . $ currentPath [ 'key' ] : '[' . $ currentPath [ 'key' ] . ']' ) . $ pathStr ; $ currentPath = $ currentPath [ 'prev' ] ; } return $ pathStr ? 'value' . $ pathStr : '' ; }
10835	private function compileOn ( array $ join ) { $ sql = array ( ) ; list ( $ on , $ table , $ type , $ c1 , $ op , $ c2 ) = $ join ; if ( $ type !== null ) { $ sql [ ] = $ type ; } array_push ( $ sql , "JOIN" , $ table , "ON" , $ c1 , $ op , $ c2 ) ; return join ( ' ' , $ sql ) ; }
9131	public function load ( $ file , $ type = null ) { $ path = $ this -> locator -> locate ( $ file ) ; if ( ! stream_is_local ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'This is not a local file "%s".' , $ path ) ) ; } if ( ! file_exists ( $ path ) ) { throw new \ InvalidArgumentException ( sprintf ( 'File "%s" not found.' , $ path ) ) ; } if ( null === $ this -> yamlParser ) { $ this -> yamlParser = new YamlParser ( ) ; } $ config = $ this -> yamlParser -> parse ( file_get_contents ( $ path ) ) ; $ collection = new RuleCollection ( ) ; $ collection -> addResource ( new FileResource ( $ path ) ) ; if ( null === $ config ) { return $ collection ; } if ( ! is_array ( $ config ) ) { throw new \ InvalidArgumentException ( sprintf ( 'The file "%s" must contain a YAML array.' , $ path ) ) ; } foreach ( $ config as $ name => $ subConfig ) { $ this -> validate ( $ subConfig , $ name , $ path ) ; if ( isset ( $ subConfig [ 'resource' ] ) ) { $ this -> parseImport ( $ collection , $ subConfig , $ path , $ file ) ; } else { $ this -> parseRule ( $ collection , $ name , $ subConfig , $ path ) ; } } return $ collection ; }
10824	public static function confirm ( $ question , $ allowShort , $ defaultValue = false ) { $ value = $ defaultValue ? 'yes' : 'no' ; $ value = self :: ask ( $ question . ' (yes/no)' , $ value ) ; return $ value == 'yes' || ( $ value == 'y' && $ allowShort ) ; }
4170	public function prettify ( Collection $ packages ) { $ summary = [ ] ; foreach ( $ packages as $ key => $ package ) { $ summary [ ] = [ 'id' => $ key + 1 , 'name' => $ this -> prettifyPackageInfo ( $ package ) , ] ; } return $ packages [ $ this -> askPackageKey ( $ summary ) ] [ 'name' ] ; }
3450	public function getDirectChildren ( array $ filter = [ ] ) { return static :: query ( ) -> filter ( $ filter ) -> filter ( [ 'SECTION_ID' => $ this -> id ] ) -> select ( 'ID' ) -> getList ( ) -> transform ( function ( $ section ) { return ( int ) $ section [ 'ID' ] ; } ) -> all ( ) ; }
8945	public function replacePreferences ( $ preferences ) { $ token = $ this -> oauth -> getToken ( ) ; $ parameters = array ( 'oauth_token' => $ token [ 'key' ] , ) ; $ base = 'user/preferences' ; $ path = $ this -> getOption ( 'api.url' ) . $ base ; $ preferenceList = '' ; if ( ! empty ( $ preferences ) ) { foreach ( $ preferences as $ key => $ value ) { $ preferenceList .= '<preference k="' . $ key . '" v="' . $ value . '"/>' ; } } $ xml = '<?xml version="1.0" encoding="UTF-8"?> <osm version="0.6" generator="JoomlaOpenStreetMap"> <preferences>' . $ preferenceList . '</preferences> </osm>' ; $ header [ 'Content-Type' ] = 'text/xml' ; $ response = $ this -> oauth -> oauthRequest ( $ path , 'PUT' , $ parameters , $ xml , $ header ) ; return $ response -> body ; }
7006	private function formatD ( & $ str ) { if ( strstr ( $ str , '%D' ) ) $ str = str_replace ( '%D' , $ this -> dayName ( false ) , $ str ) ; }
9341	public function set ( $ key , $ value , $ fromFile = false ) { $ keys = array_filter ( explode ( '.' , $ key ) ) ; $ value = ( $ fromFile ) ? require $ value : $ value ; $ this -> save ( $ keys , $ this -> data , $ value ) ; return $ this ; }
3838	protected function build ( IMetaModelDataDefinition $ container ) { $ this -> inputScreen = $ this -> viewCombination -> getScreen ( $ container -> getName ( ) ) ; if ( $ container -> hasDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ) { $ view = $ container -> getDefinition ( Contao2BackendViewDefinitionInterface :: NAME ) ; } else { return ; } $ panelLayout = $ this -> inputScreen [ 'meta' ] [ 'panelLayout' ] ; if ( empty ( $ panelLayout ) ) { return ; } $ arrRows = StringUtil :: trimsplit ( ';' , $ panelLayout ) ; $ panel = $ view -> getPanelLayout ( ) ; $ panelRows = $ panel -> getRows ( ) ; foreach ( $ arrRows as $ rowNo => $ rowElements ) { if ( $ panelRows -> getRowCount ( ) < ( $ rowNo + 1 ) ) { $ panelRow = $ panelRows -> addRow ( ) ; } else { $ panelRow = $ panelRows -> getRow ( $ rowNo ) ; } $ fields = StringUtil :: trimsplit ( ',' , $ rowElements ) ; $ fields = array_reverse ( $ fields ) ; $ this -> parsePanelRow ( $ fields , $ panelRow ) ; if ( $ panelRow -> getCount ( ) == 0 ) { $ panelRows -> deleteRow ( $ rowNo ) ; } } $ this -> ensureSubmitElement ( $ panelRows ) ; $ this -> inputScreen = null ; }
2812	public function getObservers ( ) { if ( $ this -> observers === null ) { $ this -> observers = array ( ) ; foreach ( $ this -> getTimers ( ) as $ timerName => $ timer ) { if ( strpos ( $ timerName , 'OBSERVER' ) === 0 ) { $ this -> observers [ ] = array ( 'name' => $ timerName , 'count' => $ timer [ 'count' ] , 'sum' => round ( $ timer [ 'sum' ] * 1000 , 2 ) , 'mem_diff' => $ timer [ 'realmem' ] / pow ( 1024 , 2 ) , ) ; } } } return $ this -> observers ; }
11742	public function add ( Theme $ theme , array $ pageValues ) { $ pageName = $ pageValues [ "name" ] ; $ pageDir = $ this -> pagesDir . '/' . $ pageName ; $ this -> pageExists ( $ pageDir ) ; if ( ! @ mkdir ( $ pageDir ) ) { $ this -> folderNotCreated ( $ pageDir ) ; } $ seoValues = $ pageValues [ "seo" ] ; unset ( $ pageValues [ "seo" ] ) ; $ encodedPage = json_encode ( $ pageValues ) ; $ pageFile = $ pageDir . '/' . $ this -> pageFile ; $ event = Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDING , new PageCollectionAddingEvent ( $ pageFile , $ encodedPage ) ) ; $ encodedPage = $ event -> getFileContent ( ) ; FilesystemTools :: writeFile ( $ pageFile , $ encodedPage ) ; if ( $ this -> pageFile != 'page.json' ) { FilesystemTools :: writeFile ( $ pageDir . '/page.json' , $ encodedPage ) ; } foreach ( $ seoValues as $ seoValue ) { $ languageName = $ seoValue [ "language" ] ; unset ( $ seoValue [ "language" ] ) ; $ languageDir = $ pageDir . '/' . $ languageName ; @ mkdir ( $ languageDir ) ; FilesystemTools :: writeFile ( $ languageDir . '/' . $ this -> seoFile , json_encode ( $ seoValue ) ) ; $ theme -> addTemplateSlots ( $ pageValues [ "template" ] , $ this -> username ) ; } Dispatcher :: dispatch ( PageCollectionEvents :: PAGE_COLLECTION_ADDED , new PageCollectionAddedEvent ( $ pageFile , $ encodedPage ) ) ; DataLogger :: log ( sprintf ( 'Page "%s" was successfully added to the website' , $ pageName ) ) ; return $ pageValues ; }
7722	function meth_Misc_Alert ( $ Src , $ Msg , $ NoErrMsg = false , $ SrcType = false ) { $ this -> ErrCount ++ ; if ( $ this -> NoErr || ( php_sapi_name === 'cli' ) ) { $ t = array ( '' , '' , '' , '' , '' ) ; } else { $ t = array ( '<br /><b>' , '</b>' , '<em>' , '</em>' , '<br />' ) ; $ Msg = htmlentities ( $ Msg ) ; } if ( ! is_string ( $ Src ) ) { if ( $ SrcType === false ) $ SrcType = 'in field' ; if ( isset ( $ Src -> PrmLst [ 'tbstype' ] ) ) { $ Msg = 'Column \'' . $ Src -> SubName . '\' is expected but missing in the current record.' ; $ Src = 'Parameter \'' . $ Src -> PrmLst [ 'tbstype' ] . '=' . $ Src -> SubName . '\'' ; $ NoErrMsg = false ; } else { $ Src = $ SrcType . ' ' . $ this -> _ChrOpen . $ Src -> FullName . '...' . $ this -> _ChrClose ; } } $ x = $ t [ 0 ] . 'TinyButStrong Error' . $ t [ 1 ] . ' ' . $ Src . ': ' . $ Msg ; if ( $ NoErrMsg ) $ x = $ x . ' ' . $ t [ 2 ] . 'This message can be cancelled using parameter \'noerr\'.' . $ t [ 3 ] ; $ x = $ x . $ t [ 4 ] . "\n" ; if ( $ this -> NoErr ) { $ this -> ErrMsg .= $ x ; } else { if ( php_sapi_name !== 'cli' ) { $ x = str_replace ( $ this -> _ChrOpen , $ this -> _ChrProtect , $ x ) ; } echo $ x ; } return false ; }
528	public function actionInfo ( ) { $ items = [ 'framework' , 'app-basic' , 'app-advanced' , ] ; $ extensionPath = "{$this->basePath}/extensions" ; foreach ( scandir ( $ extensionPath ) as $ extension ) { if ( ctype_alpha ( $ extension ) && is_dir ( $ extensionPath . '/' . $ extension ) ) { $ items [ ] = $ extension ; } } if ( $ this -> update ) { foreach ( $ items as $ item ) { $ this -> stdout ( "fetching tags for $item..." ) ; if ( $ item === 'framework' ) { $ this -> gitFetchTags ( ( string ) $ this -> basePath ) ; } elseif ( strncmp ( 'app-' , $ item , 4 ) === 0 ) { $ this -> gitFetchTags ( "{$this->basePath}/apps/" . substr ( $ item , 4 ) ) ; } else { $ this -> gitFetchTags ( "{$this->basePath}/extensions/$item" ) ; } $ this -> stdout ( "done.\n" , Console :: FG_GREEN , Console :: BOLD ) ; } } else { $ this -> stdout ( "\nInformation may be outdated, re-run with `--update` to fetch latest tags.\n\n" ) ; } $ versions = $ this -> getCurrentVersions ( $ items ) ; $ nextVersions = $ this -> getNextVersions ( $ versions , self :: PATCH ) ; $ w = $ this -> minWidth ( array_keys ( $ versions ) ) ; $ this -> stdout ( str_repeat ( ' ' , $ w + 2 ) . "Current Version Next Version\n" , Console :: BOLD ) ; foreach ( $ versions as $ ext => $ version ) { $ this -> stdout ( $ ext . str_repeat ( ' ' , $ w + 3 - mb_strlen ( $ ext ) ) . $ version . '' ) ; $ this -> stdout ( str_repeat ( ' ' , 17 - mb_strlen ( $ version ) ) . $ nextVersions [ $ ext ] . "\n" ) ; } }
1216	public static function stableSort ( array $ data , callable $ sortFn ) { array_walk ( $ data , function ( & $ v , $ k ) { $ v = [ $ v , $ k ] ; } ) ; uasort ( $ data , function ( $ a , $ b ) use ( $ sortFn ) { return $ sortFn ( $ a [ 0 ] , $ b [ 0 ] ) ? : ( $ a [ 1 ] < $ b [ 1 ] ? - 1 : 1 ) ; } ) ; return array_map ( function ( $ v ) { return $ v [ 0 ] ; } , array_values ( $ data ) ) ; }
10032	function unsubscribeContactByEmail ( $ email , $ mailingId = "" , $ reasons = null ) { $ queryParameters = array ( ) ; if ( ! empty ( $ mailingId ) ) { $ queryParameters [ 'mailingId' ] = $ mailingId ; } if ( ! empty ( $ reasons ) ) { if ( is_array ( $ reasons ) ) { $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'reason' , $ reasons ) ; } else { $ queryParameters [ 'reason' ] = urlencode ( $ reasons ) ; } } $ encodedEmail = utf8_encode ( $ email ) ; return $ this -> delete ( "contacts/email/${encodedEmail}/unsubscribe" , $ queryParameters ) ; }
7291	private function getByMethodAndStatesFromDateQuery ( ) { if ( null !== $ this -> byMethodAndStatesFromDateQuery ) { return $ this -> byMethodAndStatesFromDateQuery ; } $ qb = $ this -> createQueryBuilder ( 'p' ) ; $ query = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( 'p.method' , ':method' ) ) -> andWhere ( $ qb -> expr ( ) -> in ( 'p.state' , ':states' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'p.createdAt' , ':date' ) ) -> addOrderBy ( 'p.createdAt' , 'ASC' ) -> getQuery ( ) -> useQueryCache ( true ) ; return $ this -> byMethodAndStatesFromDateQuery = $ query ; }
2571	public static function isValidFopType ( $ fopType ) { return ( $ fopType == self :: IDENT_CASH || $ fopType == self :: IDENT_CHECK || $ fopType == self :: IDENT_CREDITCARD || $ fopType == self :: IDENT_MISC ) ; }
7582	protected function verifyRequiredData ( ) { $ errors = array ( ) ; foreach ( $ this -> _REQUIRED_DATA as $ property => $ defaultValue ) { if ( ( ! isset ( $ this -> Data [ $ property ] ) ) && empty ( $ defaultValue ) ) { $ errors [ ] = $ property ; } } if ( count ( $ errors ) > 0 ) { throw new RequiredDataException ( get_called_class ( ) , "Missing data for " . implode ( "," , $ errors ) ) ; } return true ; }
4217	private function clearErrorsHelper ( & $ log , $ clear = true ) { $ errorsNotCleared = array ( ) ; foreach ( $ log as $ k => $ entry ) { if ( ! \ in_array ( $ entry [ 0 ] , array ( 'error' , 'warn' ) ) ) { continue ; } $ clear2 = $ clear ; if ( $ this -> channelName ) { $ channel = isset ( $ entry [ 2 ] [ 'channel' ] ) ? $ entry [ 2 ] [ 'channel' ] : null ; $ clear2 = $ clear && $ channel === $ this -> channelName ; } if ( $ clear2 ) { unset ( $ log [ $ k ] ) ; } elseif ( isset ( $ entry [ 2 ] [ 'errorHash' ] ) ) { $ errorsNotCleared [ ] = $ entry [ 2 ] [ 'errorHash' ] ; } } $ log = \ array_values ( $ log ) ; return $ errorsNotCleared ; }
3153	public function storeTraceVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getTraceVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
8213	protected function renderJob ( $ job ) { $ stats = $ this -> getJobStats ( $ job ) ; $ format = '<info>id</info>: %u, <info>length</info>: %u, <info>priority</info>: %u, <info>delay</info>: %u, <info>age</info>: %u, <info>ttr</info>: %u' ; $ line = sprintf ( $ format , $ job -> getId ( ) , strlen ( $ job -> getData ( ) ) , $ stats [ 'pri' ] , $ stats [ 'delay' ] , $ stats [ 'age' ] , $ stats [ 'ttr' ] ) ; $ this -> output -> writeln ( $ line ) ; $ format = '<comment>reserves</comment>: %u, <comment>releases</comment>: %u, <comment>buries</comment>: %u, <comment>kicks</comment>: %u, <comment>timeouts</comment>: %u' ; $ line = sprintf ( $ format , $ stats [ 'reserves' ] , $ stats [ 'releases' ] , $ stats [ 'buries' ] , $ stats [ 'kicks' ] , $ stats [ 'timeouts' ] ) ; $ this -> output -> writeln ( $ line ) ; $ this -> output -> writeln ( '<comment>body:</comment>' ) ; $ data = $ job -> getData ( ) ; $ this -> output -> writeln ( "\"$data\"" ) ; }
1733	protected function getBookPages ( $ intParentId , $ groups , $ time ) { $ objPages = PageModel :: findPublishedSubpagesWithoutGuestsByPid ( $ intParentId , $ this -> showHidden ) ; if ( $ objPages === null ) { return ; } foreach ( $ objPages as $ objPage ) { $ _groups = StringUtil :: deserialize ( $ objPage -> groups ) ; if ( ! $ objPage -> protected || $ this -> showProtected || ( \ is_array ( $ groups ) && \ is_array ( $ _groups ) && \ count ( array_intersect ( $ groups , $ _groups ) ) ) ) { $ this -> arrPages [ $ objPage -> id ] = $ objPage ; if ( $ objPage -> subpages > 0 ) { $ this -> getBookPages ( $ objPage -> id , $ groups , $ time ) ; } } } }
7273	public static function tableName ( ) { $ cc = static :: modelName ( ) ; $ cc [ 0 ] = strtolower ( $ cc [ 0 ] ) ; return preg_replace_callback ( "/[A-Z]/" , function ( $ uppercase ) { return "_" . strtolower ( $ uppercase [ 0 ] ) ; } , $ cc ) . "s" ; }
8755	public function buildTracker ( $ numItems = Tracker :: UNKNOWN , array $ extraSubscribers = [ ] ) { $ tracker = new Tracker ( $ numItems ) ; foreach ( array_merge ( $ this -> defaultSubscribers , $ extraSubscribers ) as $ listener ) { $ tracker -> getDispatcher ( ) -> addSubscriber ( $ listener ) ; } return $ tracker ; }
5268	public function esc_like ( $ value , $ start = '%' , $ end = '%' ) { global $ wpdb ; return $ start . $ wpdb -> esc_like ( $ value ) . $ end ; }
6281	public static function buildDnsResolver ( LoopInterface $ loop , $ dns = '8.8.8.8' ) { $ factory = new DnsResolverFactory ( ) ; return $ factory -> createCached ( $ dns , $ loop ) ; }
7431	public static function getInstance ( ) : MimeType { if ( null === self :: $ instance ) { self :: $ instance = new self ( ) ; } return self :: $ instance ; }
12886	public function setRawPhoto ( $ photo ) { if ( empty ( $ photo ) ) { return true ; } if ( ! ( $ photo instanceof FileInterface ) ) { $ photo = RawFile :: createRawInstance ( $ photo ) ; } return $ this -> setStorage ( $ photo ) ; }
39	protected function generatePackageTree ( PackageInterface $ package , RepositoryInterface $ installedRepo , RepositoryInterface $ distantRepos ) { $ requires = $ package -> getRequires ( ) ; ksort ( $ requires ) ; $ children = array ( ) ; foreach ( $ requires as $ requireName => $ require ) { $ packagesInTree = array ( $ package -> getName ( ) , $ requireName ) ; $ treeChildDesc = array ( 'name' => $ requireName , 'version' => $ require -> getPrettyConstraint ( ) , ) ; $ deepChildren = $ this -> addTree ( $ requireName , $ require , $ installedRepo , $ distantRepos , $ packagesInTree ) ; if ( $ deepChildren ) { $ treeChildDesc [ 'requires' ] = $ deepChildren ; } $ children [ ] = $ treeChildDesc ; } $ tree = array ( 'name' => $ package -> getPrettyName ( ) , 'version' => $ package -> getPrettyVersion ( ) , 'description' => $ package -> getDescription ( ) , ) ; if ( $ children ) { $ tree [ 'requires' ] = $ children ; } return $ tree ; }
9269	public function setPhase ( $ value ) { $ value = ( int ) $ value ; if ( $ value ) $ this -> phase = $ value ; else $ this -> phase = null ; return $ this ; }
10340	public static function checkErrorCode ( $ pValue ) { $ pValue = ( string ) $ pValue ; if ( ! isset ( self :: $ errorCodes [ $ pValue ] ) ) { $ pValue = '#NULL!' ; } return $ pValue ; }
2017	protected function resizeUploadedImage ( $ strImage ) { if ( Config :: get ( 'imageWidth' ) < 1 && Config :: get ( 'imageHeight' ) < 1 ) { return false ; } $ objFile = new File ( $ strImage ) ; if ( ! $ objFile -> isSvgImage && ! $ objFile -> isGdImage ) { return false ; } $ arrImageSize = $ objFile -> imageSize ; if ( $ objFile -> isGdImage && ( $ arrImageSize [ 0 ] > Config :: get ( 'gdMaxImgWidth' ) || $ arrImageSize [ 1 ] > Config :: get ( 'gdMaxImgHeight' ) ) ) { Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileExceeds' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" is too big to be resized automatically' , __METHOD__ , TL_FILES ) ; return false ; } $ blnResize = false ; if ( $ arrImageSize [ 0 ] > Config :: get ( 'imageWidth' ) ) { $ blnResize = true ; $ intWidth = Config :: get ( 'imageWidth' ) ; $ intHeight = round ( Config :: get ( 'imageWidth' ) * $ arrImageSize [ 1 ] / $ arrImageSize [ 0 ] ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ arrImageSize [ 1 ] > Config :: get ( 'imageHeight' ) ) { $ blnResize = true ; $ intWidth = round ( Config :: get ( 'imageHeight' ) * $ arrImageSize [ 0 ] / $ arrImageSize [ 1 ] ) ; $ intHeight = Config :: get ( 'imageHeight' ) ; $ arrImageSize = array ( $ intWidth , $ intHeight ) ; } if ( $ blnResize ) { $ container = System :: getContainer ( ) ; $ rootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; $ container -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ strImage , array ( $ arrImageSize [ 0 ] , $ arrImageSize [ 1 ] ) , $ rootDir . '/' . $ strImage ) ; Message :: addInfo ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'fileResized' ] , $ objFile -> basename ) ) ; $ this -> log ( 'File "' . $ strImage . '" was scaled down to the maximum dimensions' , __METHOD__ , TL_FILES ) ; $ this -> blnHasResized = true ; return true ; } return false ; }
7795	protected function statementBody ( $ text ) { switch ( substr ( $ this -> getLine ( '20' , $ text ) , 0 , 4 ) ) { case '940A' : $ this -> format = self :: FORMAT_CLASSIC ; break ; case '940S' : $ this -> format = self :: FORMAT_STRUCTURED ; break ; default : throw new \ RuntimeException ( 'Unknown file format' ) ; } return parent :: statementBody ( $ text ) ; }
1343	public function isIndex ( ) : bool { return $ this -> isMethod ( 'get' ) && $ this -> getRoute ( ) -> isNotResource ( ) && $ this -> getRoute ( ) -> isNotProcesses ( ) ; }
9910	function toArray ( ) { $ result = array ( ) ; $ object_vars = get_object_vars ( $ this ) ; foreach ( $ object_vars as $ key => $ value ) { if ( $ value == null ) { continue ; } if ( gettype ( $ value ) == "object" && is_subclass_of ( $ value , 'AbstractJSONWrapper' ) ) { if ( ! $ value -> isEmpty ( ) ) { $ result [ $ key ] = $ value -> toArray ( ) ; } } else { $ result [ $ key ] = $ value ; } } return $ result ; }
12436	public function addExtra ( $ id , IFormField $ formField ) { $ formField -> setId ( $ id ) ; return $ this -> addFormField ( $ formField , true ) ; }
9515	private function _initLoggerCascade ( $ configFile , $ loggerName ) { $ err = '' ; try { $ fs = $ this -> _obm -> get ( Filesystem :: class ) ; if ( $ fs -> isAbsolutePath ( $ configFile ) ) { $ fileName = $ configFile ; } else { $ fileName = BP . '/' . $ configFile ; } $ realPath = realpath ( $ fileName ) ; if ( $ realPath ) { Cascade :: fileConfig ( $ realPath ) ; $ this -> _logger = Cascade :: getLogger ( $ loggerName ) ; } else { $ err = "Cannot open logging configuration file '$fileName'. Default Magento logger is used." ; } } catch ( \ Exception $ e ) { $ err = $ e -> getMessage ( ) ; } finally { if ( is_null ( $ this -> _logger ) ) { $ this -> _logger = $ this -> _obm -> get ( \ Magento \ Framework \ Logger \ Monolog :: class ) ; $ this -> warning ( $ err ) ; } } }
5841	public function addRole ( $ role ) { if ( is_string ( $ role ) ) { $ role = new Role ( $ role ) ; } elseif ( ! $ role instanceof RoleInterface ) { throw new \ InvalidArgumentException ( sprintf ( 'Role must be a string or RoleInterface instance, but got %s.' , gettype ( $ role ) ) ) ; } if ( ! \ in_array ( $ role , $ this -> roles ) ) { $ this -> roles [ ] = $ role ; } }
12438	public function get ( $ id ) { if ( isset ( $ this -> children [ $ id ] ) ) { return $ this -> children [ $ id ] ; } throw new FormalException ( "Unknown form field '$id' on form '" . get_called_class ( ) . "'. Available fields are: " . implode ( ', ' , array_keys ( $ this -> children ) ) ) ; }
4729	public function isSingular ( $ word ) { $ inflection = $ this -> getCachedPlural ( $ word ) ; if ( $ inflection !== false ) { return true ; } $ pluralWord = $ this -> toPlural ( $ word ) ; if ( $ pluralWord === false ) { return false ; } return $ this -> toSingular ( $ pluralWord ) == $ word ; }
3041	public function persist ( $ userId = null , $ callId = null ) { if ( $ userId && $ callId ) { $ keys = [ $ this -> getCacheKey ( $ userId , $ callId ) ] ; } else { $ keys = array_keys ( $ this -> cache ) ; } $ success = true ; foreach ( $ keys as $ key ) { if ( ! $ this -> persistCacheEntry ( $ key ) ) { $ success = false ; } } return $ success ; }
257	public function init ( ) { parent :: init ( ) ; if ( is_array ( $ this -> theme ) ) { if ( ! isset ( $ this -> theme [ 'class' ] ) ) { $ this -> theme [ 'class' ] = 'yii\base\Theme' ; } $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } elseif ( is_string ( $ this -> theme ) ) { $ this -> theme = Yii :: createObject ( $ this -> theme ) ; } }
1895	private function addHtaccess ( string $ webDir ) : void { $ htaccess = __DIR__ . '/../Resources/skeleton/web/.htaccess' ; if ( ! file_exists ( $ webDir . '/.htaccess' ) ) { $ this -> fs -> copy ( $ htaccess , $ webDir . '/.htaccess' , true ) ; $ this -> io -> writeln ( 'Added the <comment>web/.htaccess</comment> file.' ) ; return ; } $ existingContent = file_get_contents ( $ webDir . '/.htaccess' ) ; if ( preg_match ( '/^\s*RewriteRule\s/im' , $ existingContent ) ) { return ; } $ this -> fs -> dumpFile ( $ webDir . '/.htaccess' , $ existingContent . "\n\n" . file_get_contents ( $ htaccess ) ) ; $ this -> io -> writeln ( 'Updated the <comment>web/.htaccess</comment> file.' ) ; }
8724	public function translations ( ) { $ localKey = $ this -> getKeyName ( ) ; $ foreignKey = $ this -> getForeignKey ( ) ; $ instance = $ this -> translationModel ( ) ; return new HasMany ( $ instance -> newQuery ( ) , $ this , $ instance -> getTable ( ) . '.' . $ foreignKey , $ localKey ) ; }
10823	public static function ask ( $ question , $ defaultValue = null , $ secret = false ) { $ value = '' ; while ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: write ( ' ' . $ question , 'info' ) ; if ( $ defaultValue !== null ) { self :: write ( ' [' ) ; self :: write ( $ defaultValue , 'comment' ) ; self :: write ( ']' ) ; } self :: writeln ( ':' ) ; if ( $ secret ) { self :: write ( ' > ' ) ; if ( self :: $ testValue === null ) { system ( 'stty -echo' ) ; $ value = trim ( fgets ( STDIN ) ) ; system ( 'stty echo' ) ; } else { $ value = self :: $ testValue ; } } else { if ( self :: $ testValue === null ) { $ value = readline ( ' > ' ) ; } else { $ value = self :: $ testValue ; } } if ( trim ( $ value ) == '' ) { $ value = $ defaultValue ; } if ( trim ( $ value ) == '' ) { self :: writeln ( '' ) ; self :: block ( '[ERROR] A value is required' , 'error' ) ; } self :: writeln ( '' ) ; } return trim ( $ value ) ; }
1287	private function fetchCollectionFromApi ( array $ resourceIds , string $ type , string $ locale = null ) : array { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , $ resourceIds ) ; if ( 'Asset' === $ type || 'Entry' === $ type ) { $ query -> setLocale ( $ locale ) ; } switch ( $ type ) { case 'Asset' : return $ this -> client -> getAssets ( $ query ) -> getItems ( ) ; case 'ContentType' : return $ this -> client -> getContentTypes ( $ query ) -> getItems ( ) ; case 'Entry' : return $ this -> client -> getEntries ( $ query ) -> getItems ( ) ; case 'Environment' : return [ $ this -> client -> getEnvironment ( ) ] ; case 'Space' : return [ $ this -> client -> getSpace ( ) ] ; default : throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to resolve link for unknown type "%s".' , $ type ) ) ; } }
2561	public function loadSpecificChanges ( $ changeTicketing , $ changeQueueing , $ changeOptQueueEl ) { if ( $ changeTicketing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_TICKETING_OFFICE ) ; } if ( $ changeQueueing ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_QUEUEING_OFFICE ) ; } if ( $ changeOptQueueEl ) { $ this -> specificChanges [ ] = new SpecificChanges ( SpecificChanges :: ACTION_OPT_QUEUE_ELEMENT ) ; } }
12589	protected function sendEmails ( ContactInquiry $ inquiry ) { $ recipients = $ this -> container -> getParameter ( 'c33s_contact_form.email.recipients' ) ; if ( $ this -> container -> getParameter ( 'c33s_contact_form.email.send_copy_to_user' ) && $ inquiry -> hasSenderEmail ( ) ) { $ recipients [ ] = $ inquiry -> getSenderEmail ( ) ; } if ( empty ( $ recipients ) ) { return ; } $ translator = $ this -> get ( 'translator' ) ; $ subject = $ this -> container -> getParameter ( 'c33s_contact_form.email.subject' ) ; $ message = \ Swift_Message :: newInstance ( ) -> setSubject ( $ translator -> trans ( $ subject , array ( ) , 'C33sContactForm' ) ) -> setFrom ( $ this -> container -> getParameter ( 'c33s_contact_form.email.sender_email' ) ) -> setTo ( $ recipients ) -> setBody ( $ this -> renderView ( 'C33sContactFormBundle:ContactForm:email.txt.twig' , array ( 'inquiry' => $ inquiry ) ) ) ; $ this -> get ( 'mailer' ) -> send ( $ message ) ; }
11016	public function addDefaultListeners ( ) { $ this -> dispatcher -> addListener ( Events :: EVENT_BEFORE_CONTROLLER_RUN , $ this ) ; $ this -> dispatcher -> addListener ( Events :: EVENT_AFTER_CONTROLLER_RUN , $ this ) ; }
10085	public function setMapping ( $ severity , $ pipe ) { if ( ! isset ( $ this -> mapping [ $ severity ] ) ) { throw new \ RuntimeException ( "Unknown severity: " . $ severity ) ; } if ( ( $ pipe !== self :: SILENCE ) && ( $ pipe !== self :: STDOUT ) && ( $ pipe !== self :: STDERR ) ) { throw new \ RuntimeException ( "Unknown output pipe: " . $ pipe ) ; } $ this -> mapping [ $ severity ] = $ pipe ; }
7188	private function buildCombinations ( $ quantity ) { if ( empty ( $ this -> map ) ) { return [ ] ; } $ combinations = [ ] ; foreach ( $ this -> map as $ id => $ qty ) { $ combinations [ ] = new AssignmentCombination ( [ $ id => $ qty ] , $ diff = $ qty - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } for ( $ length = 2 ; $ length < count ( $ this -> map ) ; $ length ++ ) { foreach ( combine_assoc ( $ this -> map , $ length ) as $ map ) { $ combinations [ ] = new AssignmentCombination ( $ map , $ diff = array_sum ( $ map ) - $ quantity ) ; if ( $ diff == 0 ) { return $ combinations ; } } } $ combinations [ ] = new AssignmentCombination ( $ this -> map , array_sum ( $ this -> map ) - $ quantity ) ; return $ combinations ; }
9978	public function request ( $ url ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; curl_setopt ( $ ch , CURLOPT_CONNECTTIMEOUT , $ this -> timeout ) ; $ response = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; if ( $ response === false ) { throw new \ RuntimeException ( 'Connection timeout.' ) ; } return $ response ; }
10563	private function _buildActionName ( $ controllerName , $ actionName ) { $ actionName = $ actionName . 'Action' ; if ( ! method_exists ( $ controllerName , $ actionName ) ) { $ actionName = $ this -> defaultAction . 'Action' ; } return $ actionName ; }
11995	public function getCatalog ( array $ catalogData ) { $ skuIndex = [ ] ; $ slugIndex = [ ] ; $ index = 1 ; $ products = [ ] ; foreach ( $ catalogData as $ catalogItem ) { try { $ product = $ this -> productMapper -> getProduct ( $ catalogItem ) ; $ sku = strtolower ( $ product -> getSku ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ sku , $ skuIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the SKU '%s' to the catalog" , $ sku ) ) ; } $ skuIndex [ $ sku ] = 1 ; $ slug = strtolower ( $ product -> getSlug ( ) -> __toString ( ) ) ; if ( array_key_exists ( $ slug , $ slugIndex ) ) { throw new CatalogException ( sprintf ( "Cannot add a second product with the Slug '%s' to the catalog" , $ slug ) ) ; } $ slugIndex [ $ slug ] = 1 ; $ products [ ] = $ product ; } catch ( \ Exception $ productException ) { throw new CatalogException ( sprintf ( "Cannot convert catalog item %s into a product: %s" , $ index , $ productException -> getMessage ( ) ) , $ productException ) ; } $ index ++ ; } return new Catalog ( $ products ) ; }
1006	public function resolveType ( $ objectValue , $ context , ResolveInfo $ info ) { if ( isset ( $ this -> config [ 'resolveType' ] ) ) { $ fn = $ this -> config [ 'resolveType' ] ; return $ fn ( $ objectValue , $ context , $ info ) ; } return null ; }
9776	function throw ( string $ className = '' ) : self { if ( ! is_callable ( $ this -> target ) ) throw new \ BadMethodCallException ( 'The function target is not callable.' ) ; $ exception = null ; try { call_user_func ( $ this -> target ) ; } catch ( \ Throwable $ e ) { $ exception = $ e ; } $ constraint = logicalNot ( isNull ( ) ) ; return $ this -> expect ( $ exception , mb_strlen ( $ className ) ? logicalAnd ( $ constraint , isInstanceOf ( $ className ) ) : $ constraint ) ; }
10305	private function recursiveReplace ( $ path ) { $ patterns = [ '/*.md' , '/*.php' , '/*.phtml' , '/*.txt' , '/*.TXT' , ] ; $ from = array_keys ( $ this -> getMapping ( ) ) ; $ to = array_values ( $ this -> getMapping ( ) ) ; foreach ( $ patterns as $ pattern ) { foreach ( glob ( $ path . $ pattern ) as $ file ) { $ original = file_get_contents ( $ file ) ; $ converted = str_replace ( $ from , $ to , $ original ) ; if ( $ original !== $ converted ) { echo $ file . " converted\n" ; file_put_contents ( $ file , $ converted ) ; } } } foreach ( glob ( $ path . '/*' , GLOB_ONLYDIR ) as $ subpath ) { if ( strpos ( $ subpath , $ path . '/' ) === 0 ) { $ this -> recursiveReplace ( $ subpath ) ; } } }
6195	protected function findControllerFiles ( ) { $ result = [ ] ; foreach ( $ this -> controllerDirs as $ dir ) { $ directoryIterator = new \ RecursiveDirectoryIterator ( $ dir ) ; $ iterator = new \ RecursiveIteratorIterator ( $ directoryIterator ) ; $ files = new \ RegexIterator ( $ iterator , '/\.php$/i' , \ RecursiveRegexIterator :: GET_MATCH ) ; foreach ( $ files as $ k => $ v ) { $ result [ $ k ] = filemtime ( $ k ) ; } } return $ result ; }
254	public static function end ( ) { if ( ! empty ( self :: $ stack ) ) { $ widget = array_pop ( self :: $ stack ) ; if ( get_class ( $ widget ) === get_called_class ( ) ) { if ( $ widget -> beforeRun ( ) ) { $ result = $ widget -> run ( ) ; $ result = $ widget -> afterRun ( $ result ) ; echo $ result ; } return $ widget ; } throw new InvalidCallException ( 'Expecting end() of ' . get_class ( $ widget ) . ', found ' . get_called_class ( ) ) ; } throw new InvalidCallException ( 'Unexpected ' . get_called_class ( ) . '::end() call. A matching begin() is not found.' ) ; }
16	public static function getContentHash ( $ composerFileContents ) { $ content = json_decode ( $ composerFileContents , true ) ; $ relevantKeys = array ( 'name' , 'version' , 'require' , 'require-dev' , 'conflict' , 'replace' , 'provide' , 'minimum-stability' , 'prefer-stable' , 'repositories' , 'extra' , ) ; $ relevantContent = array ( ) ; foreach ( array_intersect ( $ relevantKeys , array_keys ( $ content ) ) as $ key ) { $ relevantContent [ $ key ] = $ content [ $ key ] ; } if ( isset ( $ content [ 'config' ] [ 'platform' ] ) ) { $ relevantContent [ 'config' ] [ 'platform' ] = $ content [ 'config' ] [ 'platform' ] ; } ksort ( $ relevantContent ) ; return md5 ( json_encode ( $ relevantContent ) ) ; }
5597	protected function createErrorQueue ( ) { $ context = SimpleTest :: getContext ( ) ; $ test = $ this -> getTestCase ( ) ; $ queue = $ context -> get ( 'SimpleErrorQueue' ) ; $ queue -> setTestCase ( $ test ) ; return $ queue ; }
9041	public function getEnvValue ( array $ expectedEnv , array $ actualEnv ) { $ actualValue = '' ; $ isStarted = false ; foreach ( $ expectedEnv as $ key => $ defaultValue ) { if ( array_key_exists ( $ key , $ actualEnv ) ) { if ( $ this -> option ( 'force' ) ) { $ defaultValue = $ actualEnv [ $ key ] ; } else { $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ actualEnv [ $ key ] ) ; continue ; } } if ( ! $ isStarted ) { $ isStarted = true ; if ( $ this -> option ( 'force' ) ) { $ this -> comment ( 'Update all parameters. Please provide them.' ) ; } else { $ this -> comment ( 'Some parameters are missing. Please provide them.' ) ; } } $ value = $ this -> ask ( $ key , $ defaultValue ) ; $ actualValue .= sprintf ( "%s=%s\n" , $ key , $ value ) ; } return $ actualValue ; }
1617	public function column ( $ column , $ db = null ) { if ( $ this -> emulateExecution ) { return [ ] ; } return $ this -> executeScript ( $ db , 'Column' , $ column ) ; }
6804	public function installCustomerGroups ( ) { $ groups = ( array ) $ this -> customerGroupRepository -> findBy ( [ ] , [ ] , 1 ) -> getIterator ( ) ; if ( ! empty ( $ groups ) ) { call_user_func ( $ this -> log , 'All' , 'skipped' ) ; return ; } $ groups = [ 'Particuliers' => [ 'default' => true , 'business' => false , 'registration' => true , ] , 'Entreprise' => [ 'default' => false , 'business' => true , 'registration' => true , ] , ] ; foreach ( $ groups as $ name => $ config ) { $ result = 'already exists' ; if ( null === $ this -> customerGroupRepository -> findOneBy ( [ 'name' => $ name ] ) ) { $ customerGroup = $ this -> customerGroupRepository -> createNew ( ) ; $ customerGroup -> setName ( $ name ) -> setDefault ( $ config [ 'default' ] ) -> setBusiness ( $ config [ 'business' ] ) -> setRegistration ( $ config [ 'registration' ] ) -> translate ( ) -> setTitle ( $ name ) ; $ this -> manager -> persist ( $ customerGroup ) ; $ result = 'done' ; } call_user_func ( $ this -> log , $ name , $ result ) ; } $ this -> manager -> flush ( ) ; }
10287	protected function parseCrontab ( $ crontab ) { $ lines = preg_split ( '(\r\n|\r|\n)' , $ crontab ) ; $ this -> crontab = array ( ) ; foreach ( $ lines as $ line ) { $ line = trim ( $ line ) ; if ( ! empty ( $ line ) && ( $ line [ 0 ] !== '#' ) && ( $ line [ 0 ] !== ';' ) ) { $ this -> crontab [ ] = new Cronjob ( $ line ) ; } } }
11207	public function getIterator ( ) { if ( ! $ this -> content || $ this -> contentModified ) { $ this -> generateContent ( ) ; } return new \ ArrayIterator ( $ this -> content ) ; }
12094	public function getMd5Url ( $ address , $ scheme = true , $ www = true ) { $ this -> urlAddress -> setAddress ( $ address ) ; return $ this -> urlAddress -> getMd5Address ( $ scheme , $ www ) ; }
1092	public function reload ( ) { if ( $ this -> exists || ( $ this -> areSoftDeletesEnabled ( ) && $ this -> trashed ( ) ) ) { $ fresh = $ this -> getFreshInstance ( ) ; if ( is_null ( $ fresh ) ) throw with ( new ModelNotFoundException ) -> setModel ( get_called_class ( ) ) ; $ this -> setRawAttributes ( $ fresh -> getAttributes ( ) , true ) ; $ this -> setRelations ( $ fresh -> getRelations ( ) ) ; $ this -> exists = $ fresh -> exists ; } else { $ this -> attributes = $ this -> original ; } return $ this ; }
12536	public function authenticate ( ClientInterface $ client ) { $ attributes = $ client -> getUserAttributes ( ) ; $ provider = $ client -> getId ( ) ; $ clientId = $ attributes [ 'id' ] ; $ account = $ this -> finder -> findAccountByProviderAndClientId ( $ provider , $ clientId ) ; if ( $ account === null ) { $ account = \ Yii :: createObject ( [ 'class' => Account :: className ( ) , 'provider' => $ provider , 'client_id' => $ clientId , 'data' => json_encode ( $ attributes ) , ] ) ; $ account -> save ( false ) ; } if ( null === ( $ user = $ account -> user ) ) { $ this -> action -> successUrl = Url :: to ( [ '/user/registration/connect' , 'account_id' => $ account -> id ] ) ; } else { \ Yii :: $ app -> user -> login ( $ user , $ this -> module -> rememberFor ) ; } }
11973	private function genericParamValidation ( Event $ event ) { $ params = $ event -> getCustomParams ( ) ; return ( count ( $ params ) >= 1 && count ( $ params ) <= 2 ) ; }
3446	private function getAccessorForLanguageField ( $ field ) { $ method = 'getValueFromLanguageField' ; return in_array ( $ field , $ this -> languageAccessors ) && method_exists ( $ this , $ method ) ? $ method : false ; }
5088	public function queryMap ( $ key = 0 , $ value = 1 ) { $ fetchMode = $ this -> resolveFetchMode ( is_string ( $ key ) || is_string ( $ value ) ) ; $ result = $ this -> execute ( ) ; $ map = [ ] ; try { while ( $ row = $ result -> fetch ( $ fetchMode ) ) { if ( ! isset ( $ row [ $ key ] ) || ! key_exists ( $ value , $ row ) ) throw new MySqlException ( "Key '$key' or Value '$value' columns not found in the query result: " . implode ( array_keys ( $ row ) ) ) ; $ map [ $ row [ $ key ] ] = $ row [ $ value ] ; } } finally { $ result -> closeCursor ( ) ; } return $ map ; }
4425	protected function generateLegacyAutoloads ( ) { $ this -> output -> writeln ( '' ) ; $ this -> output -> write ( 'Generating legacy autoloads... ' ) ; $ currentWorkingDirectory = getcwd ( ) ; try { chdir ( $ this -> getContainer ( ) -> getParameter ( 'ezpublish_legacy.root_dir' ) ) ; $ processBuilder = new ProcessBuilder ( array ( 'php' , 'bin/php/ezpgenerateautoloads.php' , '--quiet' , ) ) ; $ process = $ processBuilder -> getProcess ( ) ; $ process -> setTimeout ( 3600 ) ; $ process -> run ( function ( $ type , $ buffer ) { echo $ buffer ; } ) ; chdir ( $ currentWorkingDirectory ) ; if ( ! $ process -> isSuccessful ( ) ) { return array ( '- Run the following command from your ezpublish_legacy root to generate legacy autoloads:' , '' , ' <comment>php bin/php/ezpgenerateautoloads.php</comment>' , '' , ) ; } } catch ( Exception $ e ) { chdir ( $ currentWorkingDirectory ) ; return array ( 'There was an error generating legacy autoloads: ' . $ e -> getMessage ( ) , '' , ) ; } }
8083	public function & getFormErrors ( $ channel = '' ) { $ channel = $ this -> namespaceChannel ( $ channel ) ; if ( ! isset ( $ this -> console [ 'form' ] [ $ channel ] ) ) { $ this -> console [ 'form' ] [ $ channel ] = array ( ) ; } return $ this -> console [ 'form' ] [ $ channel ] ; }
6929	private function checkShipmentInvoice ( Invoice \ InvoiceInterface $ invoice ) { if ( null === $ shipment = $ invoice -> getShipment ( ) ) { throw new LogicException ( "Invoice's shipment must be set at this point." ) ; } if ( $ shipment -> getSale ( ) !== $ sale = $ invoice -> getSale ( ) ) { throw new LogicException ( "Shipment/Invoice sale miss match." ) ; } if ( ! $ sale instanceof Invoice \ InvoiceSubjectInterface ) { throw new LogicException ( "Expected instance of " . Invoice \ InvoiceSubjectInterface :: class ) ; } if ( $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isCredit ( $ invoice ) ) { throw new LogicException ( "Invoice should not be associated with Return." ) ; } elseif ( ! $ shipment -> isReturn ( ) && ! Invoice \ InvoiceTypes :: isInvoice ( $ invoice ) ) { throw new LogicException ( "Credit should not be associated with Shipment." ) ; } }
10684	private function bootstrap ( ) { ErrorInterceptor :: registerErrorHandler ( ) ; set_exception_handler ( array ( static :: class , 'handleException' ) ) ; ini_set ( 'default_charset' , 'UTF-8' ) ; mb_internal_encoding ( 'UTF-8' ) ; ini_set ( 'log_errors' , '1' ) ; $ this -> loadConfig ( ) ; $ this -> injector -> setInstance ( Configuration :: class , $ this -> config ) ; $ this -> cachemanager = $ this -> injector -> getInstance ( Cache \ Manager :: class ) ; $ this -> dev = $ this -> config -> dget ( 'site' , 'dev' , true ) ; $ this -> configureAutoloaderAndResolver ( ) ; try { $ this -> path_config -> checkPaths ( ) ; } catch ( PermissionError $ e ) { return $ this -> showPermissionError ( $ e ) ; } $ test = defined ( 'WEDETO_TEST' ) && WEDETO_TEST === 1 ? 'test' : '' ; if ( PHP_SAPI === 'cli' ) ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php-cli' . $ test . '.log' ) ; else ini_set ( 'error_log' , $ this -> path_config -> log . '/error-php' . $ test . '.log' ) ; $ this -> setCreatePermissions ( ) ; LoggerFactory :: setLoggerFactory ( new LoggerFactory ( ) ) ; Autoloader :: setLogger ( LoggerFactory :: getLogger ( [ 'class' => Autoloader :: class ] ) ) ; $ this -> setupLogging ( ) ; if ( $ this -> path_config -> cache ) { $ this -> cachemanager -> setCachePath ( $ this -> path_config -> cache ) ; $ this -> cachemanager -> setHook ( $ this -> config -> dget ( 'cache' , 'expiry' , 60 ) ) ; } $ this -> module_manager = new Module \ Manager ( $ this -> resolver ) ; $ this -> request = Request :: createFromGlobals ( ) ; $ this -> setupPlugins ( ) ; }
10501	public function autoComplete ( $ data ) { static $ counter = 0 ; $ this -> inputOptions [ 'class' ] .= ' typeahead typeahead-' . ( ++ $ counter ) ; foreach ( $ data as & $ item ) { $ item = [ 'word' => $ item ] ; } $ this -> form -> getView ( ) -> registerJs ( "yii.gii.autocomplete($counter, " . Json :: htmlEncode ( $ data ) . ");" ) ; return $ this ; }
7359	public static function getDefaultPriceMapLoader ( ) { if ( null === self :: $ defaultPriceMapLoader ) { $ currencyDir = realpath ( __DIR__ . '/../../../data/prices' ) ; self :: $ defaultPriceMapLoader = new PhpFileLoader ( array ( $ currencyDir ) ) ; } return self :: $ defaultPriceMapLoader ; }
1443	protected function replaceApplicationNamespace ( & $ stub ) { $ namespace = rtrim ( $ this -> laravel -> getNamespace ( ) , '\\' ) ; $ stub = str_replace ( 'DummyApplicationNamespace' , $ namespace , $ stub ) ; return $ this ; }
12261	private function _cacheCustomFieldsGroup ( CustomFieldsGroup $ group ) { foreach ( $ group -> getCustomFields ( ) as $ field ) { $ this -> cache [ $ group -> getEntity ( ) ] [ $ field -> getSlug ( ) ] = $ field ; } }
10605	public function addHeaders ( array $ headers ) : void { foreach ( $ headers as $ name => $ value ) { $ this -> addHeader ( ( string ) $ name , $ value ) ; } }
3610	public function getDeviceSchedule ( $ serial_number = NULL ) { $ this -> prepareForGet ( ) ; $ serial_number = $ this -> getDefaultSerial ( $ serial_number ) ; $ schedule_days = $ this -> last_status -> schedule -> { $ serial_number } -> days ; $ schedule = array ( ) ; foreach ( ( array ) $ schedule_days as $ day => $ scheduled_events ) { $ events = array ( ) ; foreach ( $ scheduled_events as $ scheduled_event ) { if ( $ scheduled_event -> entry_type == 'setpoint' ) { $ events [ ( int ) $ scheduled_event -> time ] = ( object ) array ( 'time' => $ scheduled_event -> time / 60 , 'target_temperature' => $ scheduled_event -> type == 'RANGE' ? array ( $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-min' } ) , $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> { 'temp-max' } ) ) : $ this -> temperatureInUserScale ( ( float ) $ scheduled_event -> temp ) , 'mode' => $ scheduled_event -> type == 'HEAT' ? TARGET_TEMP_MODE_HEAT : ( $ scheduled_event -> type == 'COOL' ? TARGET_TEMP_MODE_COOL : TARGET_TEMP_MODE_RANGE ) ) ; } } if ( ! empty ( $ events ) ) { ksort ( $ events ) ; $ schedule [ ( int ) $ day ] = array_values ( $ events ) ; } } ksort ( $ schedule ) ; $ sorted_schedule = array ( ) ; foreach ( $ schedule as $ day => $ events ) { $ sorted_schedule [ $ this -> days_maps [ ( int ) $ day ] ] = $ events ; } return $ sorted_schedule ; }
235	protected function getColumnPhpType ( $ column ) { static $ typeMap = [ self :: TYPE_TINYINT => 'integer' , self :: TYPE_SMALLINT => 'integer' , self :: TYPE_INTEGER => 'integer' , self :: TYPE_BIGINT => 'integer' , self :: TYPE_BOOLEAN => 'boolean' , self :: TYPE_FLOAT => 'double' , self :: TYPE_DOUBLE => 'double' , self :: TYPE_BINARY => 'resource' , self :: TYPE_JSON => 'array' , ] ; if ( isset ( $ typeMap [ $ column -> type ] ) ) { if ( $ column -> type === 'bigint' ) { return PHP_INT_SIZE === 8 && ! $ column -> unsigned ? 'integer' : 'string' ; } elseif ( $ column -> type === 'integer' ) { return PHP_INT_SIZE === 4 && $ column -> unsigned ? 'string' : 'integer' ; } return $ typeMap [ $ column -> type ] ; } return 'string' ; }
1560	protected function modelKeyForField ( $ field , $ model ) { if ( isset ( $ this -> attributes [ $ field ] ) ) { return $ this -> attributes [ $ field ] ; } $ key = $ model :: $ snakeAttributes ? Str :: underscore ( $ field ) : Str :: camelize ( $ field ) ; return $ this -> attributes [ $ field ] = $ key ; }
10548	public function setTemplate ( Template $ template ) { $ this -> template = $ template ; $ this -> setVariable ( 'template' , $ template ) ; $ this -> setVariable ( 'tpl' , $ template ) ; return $ this ; }
11741	private function _getPerson ( $ id ) { $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ person = $ em -> getRepository ( 'ChillPersonBundle:Person' ) -> find ( $ id ) ; return $ person ; }
10812	protected function callAPI ( $ data ) { $ apiUtility = new PipedriveApi ( $ this -> apiEndpoint ) ; $ apiUtility -> setData ( $ data ) ; $ formState = $ this -> finisherContext -> getFormRuntime ( ) -> getFormState ( ) ; $ response = $ apiUtility -> execute ( ) ; if ( $ response -> data -> id ) { $ formState -> setFormValue ( $ this -> getIdentifier ( ) . ".ID" , $ response -> data -> id ) ; return true ; } else { throw new FinisherException ( "Something went wrong while calling the API!" ) ; } }
1095	public function children ( $ node ) { $ query = $ this -> node -> newQuery ( ) ; $ query -> where ( $ this -> node -> getQualifiedParentColumnName ( ) , '=' , $ node -> getKey ( ) ) ; foreach ( $ this -> scopedAttributes ( $ node ) as $ fld => $ value ) $ query -> where ( $ this -> qualify ( $ fld ) , '=' , $ value ) ; $ query -> orderBy ( $ this -> node -> getQualifiedLeftColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedRightColumnName ( ) ) ; $ query -> orderBy ( $ this -> node -> getQualifiedKeyName ( ) ) ; return $ query -> get ( ) ; }
10038	function renameCustomField ( $ oldName , $ newName ) { $ encodedOldName = urlencode ( mb_convert_encoding ( $ oldName , "UTF-8" ) ) ; $ encodedNewName = urlencode ( mb_convert_encoding ( $ newName , "UTF-8" ) ) ; return $ this -> put ( "contacts/fields/custom/${encodedOldName}/${encodedNewName}" ) ; }
702	protected function findDirs ( $ dir ) { $ list = [ ] ; $ handle = @ opendir ( $ dir ) ; if ( $ handle === false ) { return [ ] ; } while ( ( $ file = readdir ( $ handle ) ) !== false ) { if ( $ file === '.' || $ file === '..' ) { continue ; } $ path = $ dir . DIRECTORY_SEPARATOR . $ file ; if ( is_dir ( $ path ) && preg_match ( '/^yii2-(.*)$/' , $ file , $ matches ) ) { $ list [ ] = $ matches [ 1 ] ; } } closedir ( $ handle ) ; foreach ( $ list as $ i => $ e ) { if ( $ e === 'composer' ) { unset ( $ list [ $ i ] ) ; } } return $ list ; }
1422	protected function createModelIdentity ( $ modelClass , $ id , $ keyName = null ) { if ( is_null ( $ id ) ) { return null ; } $ model = new $ modelClass ( ) ; if ( ! $ model instanceof Model ) { throw new RuntimeException ( sprintf ( 'Expecting a model class, got %s.' , $ modelClass ) ) ; } $ model -> setAttribute ( $ keyName ? : $ model -> getRouteKeyName ( ) , $ id ) ; return $ model ; }
7590	public function renderTemplate ( CollectionElement $ collection ) { if ( false != ( $ sElementLayout = $ collection -> getOption ( 'twb-layout' ) ) ) { $ elementOrFieldset = $ collection -> getTemplateElement ( ) ; $ elementOrFieldset -> setOption ( 'twb-layout' , $ sElementLayout ) ; } return parent :: renderTemplate ( $ collection ) ; }
5455	public function addContent ( $ text ) { if ( isset ( $ this -> private_content_tag ) ) { $ this -> private_content_tag -> addContent ( $ text ) ; } else { $ this -> addContentToAllOpenTags ( $ text ) ; } return true ; }
2879	public function enableTemplateHintsAction ( ) { try { $ this -> getService ( ) -> setTemplateHints ( 1 ) ; $ this -> getService ( ) -> flushCache ( ) ; } catch ( Exception $ e ) { $ message = $ this -> __ ( 'Template hints cannot be enabled: %s' , $ e -> getMessage ( ) ) ; $ this -> getSession ( ) -> addError ( $ message ) ; } $ this -> _redirectReferer ( ) ; }
11983	public function getConfig ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> settings ) ? $ this -> settings [ $ name ] : $ default ; }
1200	public function get ( $ menu , array $ path = array ( ) , array $ options = array ( ) ) { if ( ! $ menu instanceof ItemInterface ) { if ( null === $ this -> menuProvider ) { throw new \ BadMethodCallException ( 'A menu provider must be set to retrieve a menu' ) ; } $ menuName = $ menu ; $ menu = $ this -> menuProvider -> get ( $ menuName , $ options ) ; if ( ! $ menu instanceof ItemInterface ) { throw new \ LogicException ( sprintf ( 'The menu "%s" exists, but is not a valid menu item object. Check where you created the menu to be sure it returns an ItemInterface object.' , $ menuName ) ) ; } } foreach ( $ path as $ child ) { $ menu = $ menu -> getChild ( $ child ) ; if ( null === $ menu ) { throw new \ InvalidArgumentException ( sprintf ( 'The menu has no child named "%s"' , $ child ) ) ; } } return $ menu ; }
4436	public function get ( string $ name , $ default = null ) { $ res = $ this -> client -> call ( 'config.get' , $ name ) ; return $ res === null ? $ default : $ res ; }
4138	public function postMedia ( $ call , $ filename ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'POST' ; $ this -> withMedia = true ; $ mimeBoundary = sha1 ( $ call . microtime ( ) ) ; $ params = array ( 'post' => $ this -> buildMultipart ( $ mimeBoundary , $ filename ) , 'headers' => $ this -> buildUploadMediaHeader ( $ mimeBoundary ) , ) ; $ response = $ this -> curl -> send ( $ this -> getUrl ( ) , $ params ) ; $ obj = json_decode ( $ response [ 'body' ] ) ; if ( ! $ obj || ! isset ( $ obj -> token_type ) || $ obj -> token_type != 'bearer' ) { $ this -> findExceptions ( $ response ) ; } $ this -> headers = $ response [ 'headers' ] ; $ this -> withMedia = null ; unset ( $ call , $ filename , $ mimeBoundary , $ params , $ obj ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
9954	public function mergeCellsByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { $ cellRange = Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ; return $ this -> mergeCells ( $ cellRange ) ; }
4251	protected function methodTable ( $ array , $ columns = array ( ) ) { if ( ! \ is_array ( $ array ) ) { return $ this -> dump ( $ array ) ; } $ table = array ( ) ; $ keys = $ columns ? : $ this -> debug -> methodTable -> colKeys ( $ array ) ; $ headerVals = $ keys ; foreach ( $ headerVals as $ i => $ val ) { if ( $ val === MethodTable :: SCALAR ) { $ headerVals [ $ i ] = 'value' ; } } \ array_unshift ( $ headerVals , '' ) ; $ table [ ] = $ headerVals ; $ classNames = array ( ) ; if ( $ this -> debug -> abstracter -> isAbstraction ( $ array ) && $ array [ 'traverseValues' ] ) { $ array = $ array [ 'traverseValues' ] ; } foreach ( $ array as $ k => $ row ) { $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; foreach ( $ values as $ k2 => $ val ) { if ( $ val === $ this -> debug -> abstracter -> UNDEFINED ) { $ values [ $ k2 ] = null ; } } $ classNames [ ] = $ objInfo [ 'row' ] ? $ objInfo [ 'row' ] [ 'className' ] : '' ; \ array_unshift ( $ values , $ k ) ; $ table [ ] = \ array_values ( $ values ) ; } if ( \ array_filter ( $ classNames ) ) { \ array_unshift ( $ table [ 0 ] , '' ) ; foreach ( $ classNames as $ i => $ className ) { \ array_splice ( $ table [ $ i + 1 ] , 1 , 0 , $ className ) ; } } return $ table ; }
4695	public function limitBy ( ? int $ limit , int $ offset = null ) : self { $ this -> dirty ( ) ; $ this -> limit = $ limit || $ offset ? [ $ limit , $ offset ] : null ; return $ this ; }
9202	public function createBearerToken ( ) { $ bearerCredentials = $ this -> createBearerCredentials ( ) ; $ headers = array ( 'Authorization' => 'Basic ' . $ bearerCredentials , 'Content-Type' => 'application/x-www-form-urlencoded;charset=UTF-8' ) ; $ body = 'grant_type=client_credentials' ; $ data = $ this -> guzzleClient -> post ( Config :: get ( 'oauth2_token' ) , array ( 'headers' => $ headers , 'body' => $ body ) ) -> json ( ) ; $ this -> credentials -> setBearerToken ( $ data [ 'access_token' ] ) ; return $ this ; }
2492	protected function defineEndpoint ( ContainerBuilder $ container , $ alias , $ params ) { $ definition = new Definition ( self :: ENDPOINT_CLASS , array ( $ params ) ) ; $ definition -> addTag ( self :: ENDPOINT_TAG , array ( 'alias' => $ alias ) ) ; $ container -> setDefinition ( sprintf ( $ this -> getAlias ( ) . '.endpoints.%s' , $ alias ) , $ definition ) ; }
4469	public function cancel ( $ dependents = false ) : array { if ( $ dependents && ! empty ( $ this -> rawData [ 'dependents' ] ) ) { return call_user_func_array ( [ $ this -> client , 'cancel' ] , array_merge ( [ $ this -> jid ] , $ this -> rawData [ 'dependents' ] ) ) ; } return $ this -> client -> cancel ( $ this -> jid ) ; }
2053	public function getTemplateData ( ) { $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ image = System :: getContainer ( ) -> get ( 'contao.image.image_factory' ) -> create ( $ rootDir . '/' . $ this -> image -> getOriginalPath ( ) ) ; $ config = new PictureConfiguration ( ) ; $ config -> setSize ( $ this -> getConfigurationItem ( $ this -> imageSize ) ) ; $ sizeItems = array ( ) ; foreach ( $ this -> imageSizeItems as $ imageSizeItem ) { $ sizeItems [ ] = $ this -> getConfigurationItem ( $ imageSizeItem ) ; } $ config -> setSizeItems ( $ sizeItems ) ; $ importantPart = $ this -> image -> getImportantPart ( ) ; $ image -> setImportantPart ( new ImportantPart ( new Point ( $ importantPart [ 'x' ] , $ importantPart [ 'y' ] ) , new Box ( $ importantPart [ 'width' ] , $ importantPart [ 'height' ] ) ) ) ; $ container = System :: getContainer ( ) ; $ staticUrl = $ container -> get ( 'contao.assets.files_context' ) -> getStaticUrl ( ) ; $ picture = $ container -> get ( 'contao.image.picture_generator' ) -> generate ( $ image , $ config , ( new ResizeOptions ( ) ) -> setImagineOptions ( $ container -> getParameter ( 'contao.image.imagine_options' ) ) -> setBypassCache ( $ container -> getParameter ( 'contao.image.bypass_cache' ) ) ) ; return array ( 'img' => $ picture -> getImg ( $ rootDir , $ staticUrl ) , 'sources' => $ picture -> getSources ( $ rootDir , $ staticUrl ) , ) ; }
4859	public function getNeighbours ( $ namespace , $ callback , $ id ) { $ list = $ this -> getList ( $ namespace , $ callback ) ; $ list -> setCurrent ( $ id ) ; return [ $ list -> getPrevious ( ) , $ list -> getNext ( ) ] ; }
2	private function buildDependency10Info ( $ depArray ) { static $ dep10toOperatorMap = array ( 'has' => '==' , 'eq' => '==' , 'ge' => '>=' , 'gt' => '>' , 'le' => '<=' , 'lt' => '<' , 'not' => '!=' ) ; $ result = array ( ) ; foreach ( $ depArray as $ depItem ) { if ( empty ( $ depItem [ 'rel' ] ) || ! array_key_exists ( $ depItem [ 'rel' ] , $ dep10toOperatorMap ) ) { continue ; } $ depType = ! empty ( $ depItem [ 'optional' ] ) && 'yes' == $ depItem [ 'optional' ] ? 'optional' : 'required' ; $ depType = 'not' == $ depItem [ 'rel' ] ? 'conflicts' : $ depType ; $ depVersion = ! empty ( $ depItem [ 'version' ] ) ? $ this -> parseVersion ( $ depItem [ 'version' ] ) : '*' ; $ depVersionConstraint = ( 'has' == $ depItem [ 'rel' ] || 'not' == $ depItem [ 'rel' ] ) && '*' == $ depVersion ? '*' : $ dep10toOperatorMap [ $ depItem [ 'rel' ] ] . $ depVersion ; switch ( $ depItem [ 'type' ] ) { case 'php' : $ depChannelName = 'php' ; $ depPackageName = '' ; break ; case 'pkg' : $ depChannelName = ! empty ( $ depItem [ 'channel' ] ) ? $ depItem [ 'channel' ] : 'pear.php.net' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'ext' : $ depChannelName = 'ext' ; $ depPackageName = $ depItem [ 'name' ] ; break ; case 'os' : case 'sapi' : $ depChannelName = '' ; $ depPackageName = '' ; break ; default : $ depChannelName = '' ; $ depPackageName = '' ; break ; } if ( '' != $ depChannelName ) { $ result [ ] = new DependencyConstraint ( $ depType , $ depVersionConstraint , $ depChannelName , $ depPackageName ) ; } } return $ result ; }
2261	public function prepare ( $ strQuery ) { $ objStatement = new Statement ( $ this -> resConnection , $ this -> blnDisableAutocommit ) ; return $ objStatement -> prepare ( $ strQuery ) ; }
11527	public function registerPackageHelpers ( ) { foreach ( $ this -> packageHelpers as $ helper ) { $ dashName = last ( explode ( '/' , $ helper ) ) ; $ underscoreName = str_replace ( '-' , '_' , $ dashName ) ; if ( in_array ( '*' , $ this -> packageInclude ) || in_array ( $ dashName , $ this -> packageInclude ) || in_array ( $ underscoreName , $ this -> packageInclude ) ) { require_once $ this -> replaceVariables ( $ this -> packageHelperPattern , compact ( 'dashName' , 'underscoreName' ) ) ; } } }
2118	public function generateSqlForm ( ) { @ trigger_error ( 'Using the Installer::generateSqlForm() method has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ count = 0 ; $ return = '' ; $ sql_command = $ this -> compileCommands ( ) ; if ( empty ( $ sql_command ) ) { return '' ; } $ _SESSION [ 'sql_commands' ] = array ( ) ; $ arrOperations = array ( 'CREATE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'CREATE' ] , 'ALTER_ADD' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_ADD' ] , 'ALTER_CHANGE' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_CHANGE' ] , 'ALTER_DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'ALTER_DROP' ] , 'DROP' => $ GLOBALS [ 'TL_LANG' ] [ 'tl_install' ] [ 'DROP' ] ) ; foreach ( $ arrOperations as $ command => $ label ) { if ( \ is_array ( $ sql_command [ $ command ] ) ) { $ return .= ' <tr> <td colspan="2" class="tl_col_0">' . $ label . '</td> </tr>' ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" id="check_all_' . $ count . '" class="tl_checkbox" onclick="Backend.toggleCheckboxElements(this, \'' . strtolower ( $ command ) . '\')"></td> <td class="tl_col_2"><label for="check_all_' . $ count . '" style="color:#a6a6a6"><em>' . $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'selectAll' ] . '</em></label></td> </tr>' ; foreach ( $ sql_command [ $ command ] as $ vv ) { $ key = md5 ( $ vv ) ; $ _SESSION [ 'sql_commands' ] [ $ key ] = $ vv ; $ return .= ' <tr> <td class="tl_col_1"><input type="checkbox" name="sql[]" id="sql_' . $ count . '" class="tl_checkbox ' . strtolower ( $ command ) . '" value="' . $ key . '"' . ( ( stripos ( $ command , 'DROP' ) === false ) ? ' checked="checked"' : '' ) . '></td> <td class="tl_col_2"><pre><label for="sql_' . $ count ++ . '">' . $ vv . '</label></pre></td> </tr>' ; } } } return '<div id="sql_wrapper"> <table id="sql_table">' . $ return . ' </table></div>' ; }
10600	public function returnUrl ( ) { $ return = '' ; $ return .= empty ( $ this -> _urlParts [ 'scheme' ] ) ? '' : $ this -> _urlParts [ 'scheme' ] . '://' ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : $ this -> _urlParts [ 'user' ] ; $ return .= empty ( $ this -> _urlParts [ 'pass' ] ) || empty ( $ this -> _urlParts [ 'user' ] ) ? '' : ':' . $ this -> _urlParts [ 'pass' ] ; $ return .= empty ( $ this -> _urlParts [ 'user' ] ) ? '' : '@' ; $ return .= empty ( $ this -> _urlParts [ 'host' ] ) ? '' : $ this -> _urlParts [ 'host' ] ; $ return .= empty ( $ this -> _urlParts [ 'port' ] ) ? '' : ':' . $ this -> _urlParts [ 'port' ] ; $ return .= empty ( $ this -> _urlParts [ 'path' ] ) ? '' : '/' . ltrim ( $ this -> _urlParts [ 'path' ] , '/' ) ; $ return .= empty ( $ this -> _urlParts [ 'query' ] ) ? '' : '?' . $ this -> _urlParts [ 'query' ] ; $ return .= empty ( $ this -> _urlParts [ 'fragment' ] ) ? '' : '#' . $ this -> _urlParts [ 'fragment' ] ; return $ return ; }
6412	public static function all ( IteratorAggregate $ iterable , callable $ predicate ) : bool { return Iterators :: all ( Iterators :: from ( $ iterable -> getIterator ( ) ) , $ predicate ) ; }
3165	public function switchClientStoreId ( RunnerServiceContext $ context , $ receivedStoreId ) { if ( $ context instanceof QtiRunnerServiceContext ) { $ session = $ context -> getTestSession ( ) ; $ sessionId = $ session -> getSessionId ( ) ; $ stateService = $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) ; $ lastStoreId = $ stateService -> getStoreId ( $ sessionId ) ; if ( $ lastStoreId == false || $ lastStoreId != $ receivedStoreId ) { $ stateService -> setStoreId ( $ sessionId , $ receivedStoreId ) ; } return $ lastStoreId ; } else { throw new \ common_exception_InvalidArgumentType ( 'QtiRunnerService' , 'switchClientStoreId' , 0 , 'oat\taoQtiTest\models\runner\QtiRunnerServiceContext' , $ context ) ; } }
9075	public function add ( $ name , Rule $ rule ) { unset ( $ this -> rules [ $ name ] ) ; $ this -> rules [ $ name ] = $ rule ; }
5493	public function add ( $ parameters , $ action ) { $ place = count ( $ this -> map ) ; $ this -> map [ $ place ] = array ( ) ; $ this -> map [ $ place ] [ 'params' ] = new ParametersExpectation ( $ parameters ) ; $ this -> map [ $ place ] [ 'content' ] = $ action ; }
2121	public static function getActive ( ) { @ trigger_error ( 'Using ModuleLoader::getActive() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ bundles = array_keys ( System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ) ; foreach ( static :: $ legacy as $ bundleName => $ module ) { if ( \ in_array ( $ bundleName , $ bundles ) ) { $ bundles [ ] = $ module ; } } return $ bundles ; }
489	protected function findTableConstraints ( $ table , $ type ) { $ keyColumnUsageTableName = 'INFORMATION_SCHEMA.KEY_COLUMN_USAGE' ; $ tableConstraintsTableName = 'INFORMATION_SCHEMA.TABLE_CONSTRAINTS' ; if ( $ table -> catalogName !== null ) { $ keyColumnUsageTableName = $ table -> catalogName . '.' . $ keyColumnUsageTableName ; $ tableConstraintsTableName = $ table -> catalogName . '.' . $ tableConstraintsTableName ; } $ keyColumnUsageTableName = $ this -> quoteTableName ( $ keyColumnUsageTableName ) ; $ tableConstraintsTableName = $ this -> quoteTableName ( $ tableConstraintsTableName ) ; $ sql = <<<SQLSELECT [kcu].[constraint_name] AS [index_name], [kcu].[column_name] AS [field_name]FROM {$keyColumnUsageTableName} AS [kcu]LEFT JOIN {$tableConstraintsTableName} AS [tc] ON [kcu].[table_schema] = [tc].[table_schema] AND [kcu].[table_name] = [tc].[table_name] AND [kcu].[constraint_name] = [tc].[constraint_name]WHERE [tc].[constraint_type] = :type AND [kcu].[table_name] = :tableName AND [kcu].[table_schema] = :schemaNameSQL ; return $ this -> db -> createCommand ( $ sql , [ ':tableName' => $ table -> name , ':schemaName' => $ table -> schemaName , ':type' => $ type , ] ) -> queryAll ( ) ; }
3263	public static function format ( $ value ) { return preg_replace ( [ '/:symbol/' , '/:price/' , '/:currency/' ] , [ Config :: get ( 'shop.currency_symbol' ) , $ value , Config :: get ( 'shop.currency' ) ] , Config :: get ( 'shop.display_price_format' ) ) ; }
11469	public function show ( ResponseRequest $ request , Response $ response ) { if ( $ response -> exists ) { $ view = 'forum::response.show' ; } else { $ view = 'forum::response.new' ; } return $ this -> response -> title ( trans ( 'app.view' ) . ' ' . trans ( 'forum::response.name' ) ) -> data ( compact ( 'response' ) ) -> view ( $ view , true ) -> output ( ) ; }
4811	public function create ( ) { $ language = new ExpressionLanguage ( ) ; foreach ( $ this -> providers as $ provider ) { $ language -> registerProvider ( $ provider ) ; } return $ language ; }
10392	protected static function parseXml ( $ xmlFile ) { $ reader = new \ XMLReader ( ) ; $ libXmlErrors = libxml_use_internal_errors ( true ) ; $ errors = array ( ) ; if ( ! $ reader -> open ( $ xmlFile ) ) { throw new XmlParserException ( $ xmlFile , array ( ) ) ; } $ current = $ root = new Document ( ) ; $ parents = array ( $ root ) ; while ( @ $ reader -> read ( ) ) { switch ( $ reader -> nodeType ) { case \ XMLReader :: ELEMENT : $ nodeName = $ reader -> name ; array_push ( $ parents , $ current ) ; $ current = $ current -> $ nodeName = new Node ( ) ; $ emptyElement = $ reader -> isEmptyElement ; if ( $ reader -> hasAttributes ) { while ( $ reader -> moveToNextAttribute ( ) ) { $ current [ $ reader -> name ] = $ reader -> value ; } } if ( ! $ emptyElement ) { break ; } case \ XMLReader :: END_ELEMENT : $ current = array_pop ( $ parents ) ; break ; case \ XMLReader :: TEXT : case \ XMLReader :: CDATA : $ current -> setContent ( ( string ) $ current . $ reader -> value ) ; break ; } } if ( count ( $ errors = libxml_get_errors ( ) ) ) { libxml_use_internal_errors ( $ libXmlErrors ) ; libxml_clear_errors ( ) ; throw new XmlParserException ( $ xmlFile , $ errors ) ; } libxml_use_internal_errors ( $ libXmlErrors ) ; return $ root -> skipRoot ( ) ; }
983	public function process ( Plan $ plan ) { $ shop = ShopifyApp :: shop ( ) ; $ bp = new BillingPlan ( $ shop , $ plan ) ; $ bp -> setChargeId ( Request :: query ( 'charge_id' ) ) ; $ bp -> activate ( ) ; $ bp -> save ( ) ; $ shop -> update ( [ 'freemium' => false , 'plan_id' => $ plan -> id , ] ) ; return Redirect :: route ( 'home' ) -> with ( 'success' , 'billing' ) ; }
5660	private function collectSelectOptions ( $ node ) { $ options = array ( ) ; if ( $ node -> name === 'option' ) { $ options [ ] = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; } if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ options = array_merge ( $ options , $ this -> collectSelectOptions ( $ child ) ) ; } } return $ options ; }
10637	public function uploadAction ( Request $ request ) { $ rawMedias = array_merge ( $ this -> processUploadedFiles ( $ request -> files ) , $ this -> processUrls ( $ request ) ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ mtm = $ this -> get ( 'mm_media.mediatype.manager' ) ; $ returnData = array ( ) ; foreach ( $ rawMedias as $ rawmedia ) { if ( null != ( $ mt = $ mtm -> getMediaTypeMatch ( $ rawmedia ) ) ) { $ ms = $ mt -> getEntity ( ) ; $ em -> persist ( $ ms ) ; $ em -> flush ( ) ; $ returnData [ ] = array ( 'id' => $ ms -> getId ( ) , 'path' => $ rawmedia , 'mediatype' => ( string ) $ ms -> getMediaType ( ) , ) ; } } return new JsonResponse ( array ( 'success' => true , 'data' => $ returnData , ) ) ; }
7922	private function isValidPath ( $ path ) { $ pathParts = explode ( '/' , $ path ) ; if ( ! strncmp ( $ path , '/' , 1 ) || array_search ( '..' , $ pathParts ) !== false || strpos ( $ path , ':' ) !== false ) { return false ; } return true ; }
5344	public function make ( $ wsdl , array $ classMap = [ ] ) { return new SoapClient ( $ wsdl , [ 'trace' => true , 'exceptions' => true , 'encoding' => 'utf-8' , 'features' => SOAP_SINGLE_ELEMENT_ARRAYS , 'classmap' => $ classMap , 'cache_wsdl' => WSDL_CACHE_MEMORY , ] ) ; }
7767	public function loadMetadataForClass ( $ className ) { foreach ( $ this -> drivers as $ namespace => $ driver ) { if ( strpos ( $ className , $ namespace ) === 0 ) { return $ driver -> loadMetadataForClass ( $ className ) ; } } return null ; }
594	private function composeCircularDependencyTrace ( $ circularDependencyName , array $ registered ) { $ dependencyTrace = [ ] ; $ startFound = false ; foreach ( $ registered as $ name => $ value ) { if ( $ name === $ circularDependencyName ) { $ startFound = true ; } if ( $ startFound && $ value === false ) { $ dependencyTrace [ ] = $ name ; } } $ dependencyTrace [ ] = $ circularDependencyName ; return implode ( ' -> ' , $ dependencyTrace ) ; }
3659	public static function getSubscribedServices ( ) { return [ Connection :: class => Connection :: class , Input :: class => Input :: class , InsertTags :: class => InsertTags :: class , Session :: class => Session :: class , IMetaModelsServiceContainer :: class => IMetaModelsServiceContainer :: class ] ; }
5359	protected function createUrlStatements ( Operation $ operation , $ queryParamVariable ) { $ urlVariable = new Expr \ Variable ( 'url' ) ; $ statements = [ new Expr \ Assign ( $ urlVariable , new Scalar \ String_ ( $ operation -> getPath ( ) ) ) ] ; if ( $ operation -> getOperation ( ) -> getParameters ( ) ) { foreach ( $ operation -> getOperation ( ) -> getParameters ( ) as $ parameter ) { if ( $ parameter instanceof Reference ) { $ parameter = $ this -> resolveParameter ( $ parameter ) ; } if ( $ parameter instanceof PathParameterSubSchema ) { $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ FuncCall ( new Name ( 'str_replace' ) , [ new Arg ( new Scalar \ String_ ( '{' . $ parameter -> getName ( ) . '}' ) ) , new Arg ( new Expr \ FuncCall ( new Name ( 'urlencode' ) , [ new Arg ( new Expr \ Variable ( Inflector :: camelize ( $ parameter -> getName ( ) ) ) ) , ] ) ) , new Arg ( $ urlVariable ) ] ) ) ; } } } $ statements [ ] = new Expr \ Assign ( $ urlVariable , new Expr \ BinaryOp \ Concat ( $ urlVariable , new Expr \ BinaryOp \ Concat ( new Scalar \ String_ ( '?' ) , new Expr \ MethodCall ( $ queryParamVariable , 'buildQueryString' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ) ) ; return [ $ statements , $ urlVariable ] ; }
5570	public function retry ( ) { $ frames = $ this -> page -> getFrameFocus ( ) ; if ( count ( $ frames ) > 0 ) { $ this -> loadFrame ( $ frames , $ this -> page -> getUrl ( ) , $ this -> page -> getRequestData ( ) ) ; return $ this -> page -> getRaw ( ) ; } if ( $ url = $ this -> history -> getUrl ( ) ) { $ this -> page = $ this -> fetch ( $ url , $ this -> history -> getParameters ( ) ) ; return $ this -> page -> getRaw ( ) ; } return false ; }
8959	private function prepareArrayParameter ( $ name ) { if ( isset ( $ this -> parameters [ $ name ] ) ) { $ parameterArray = $ this -> parameters [ $ name ] ; $ count = count ( $ parameterArray ) ; $ str = "['" . $ parameterArray [ 0 ] . "'" ; for ( $ i = 1 ; $ i < $ count ; ++ $ i ) { $ str .= ", '" . $ parameterArray [ $ i ] . "'" ; } $ str .= ']' ; return $ str ; } }
9982	private function writeVMLComment ( XMLWriter $ objWriter , $ pCellReference , Comment $ pComment ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ pCellReference ) ; $ column = Coordinate :: columnIndexFromString ( $ column ) ; $ id = 1024 + $ column + $ row ; $ id = substr ( $ id , 0 , 4 ) ; $ objWriter -> startElement ( 'v:shape' ) ; $ objWriter -> writeAttribute ( 'id' , '_x0000_s' . $ id ) ; $ objWriter -> writeAttribute ( 'type' , '#_x0000_t202' ) ; $ objWriter -> writeAttribute ( 'style' , 'position:absolute;margin-left:' . $ pComment -> getMarginLeft ( ) . ';margin-top:' . $ pComment -> getMarginTop ( ) . ';width:' . $ pComment -> getWidth ( ) . ';height:' . $ pComment -> getHeight ( ) . ';z-index:1;visibility:' . ( $ pComment -> getVisible ( ) ? 'visible' : 'hidden' ) ) ; $ objWriter -> writeAttribute ( 'fillcolor' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> writeAttribute ( 'o:insetmode' , 'auto' ) ; $ objWriter -> startElement ( 'v:fill' ) ; $ objWriter -> writeAttribute ( 'color2' , '#' . $ pComment -> getFillColor ( ) -> getRGB ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:shadow' ) ; $ objWriter -> writeAttribute ( 'on' , 't' ) ; $ objWriter -> writeAttribute ( 'color' , 'black' ) ; $ objWriter -> writeAttribute ( 'obscured' , 't' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:path' ) ; $ objWriter -> writeAttribute ( 'o:connecttype' , 'none' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'v:textbox' ) ; $ objWriter -> writeAttribute ( 'style' , 'mso-direction-alt:auto' ) ; $ objWriter -> startElement ( 'div' ) ; $ objWriter -> writeAttribute ( 'style' , 'text-align:left' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'x:ClientData' ) ; $ objWriter -> writeAttribute ( 'ObjectType' , 'Note' ) ; $ objWriter -> writeElement ( 'x:MoveWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:SizeWithCells' , '' ) ; $ objWriter -> writeElement ( 'x:AutoFill' , 'False' ) ; $ objWriter -> writeElement ( 'x:Row' , ( $ row - 1 ) ) ; $ objWriter -> writeElement ( 'x:Column' , ( $ column - 1 ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
8538	public function setOffer ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'Offer' ] [ 'FieldValue' ] = $ value ; return $ this ; }
9767	function least ( $ value ) : self { $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , greaterThanOrEqual ( $ value ) ) ; }
11037	function store_reduce ( & $ elts , $ value ) { switch ( strtoupper ( $ value ) ) { case 'OFF' : case 'NOTHING' : $ elts [ '0reduce' ] = _ETS_REDUCE_OFF ; return TRUE ; case 'SPACE' : case 'SPACES' : $ elts [ '0reduce' ] = _ETS_REDUCE_SPACES ; return TRUE ; case 'CRLF' : case 'ON' : case 'ALL' : $ elts [ '0reduce' ] = _ETS_REDUCE_ALL ; return TRUE ; default : return FALSE ; } }
7305	protected function scheduleParentChangeEvents ( CustomerInterface $ customer ) { if ( ! $ customer -> hasChildren ( ) ) { return ; } foreach ( $ customer -> getChildren ( ) as $ child ) { $ this -> persistenceHelper -> scheduleEvent ( CustomerEvents :: PARENT_CHANGE , $ child ) ; } }
644	public function addDefaultValue ( $ name , $ table , $ column , $ value ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> addDefaultValue ( $ name , $ table , $ column , $ value ) ; return $ this -> setSql ( $ sql ) -> requireTableSchemaRefresh ( $ table ) ; }
5957	public function channelGetByName ( $ name ) { foreach ( $ this -> channelList ( ) as $ channel ) { if ( $ channel [ "channel_name" ] == $ name ) { return $ channel ; } } throw new Ts3Exception ( "invalid channelID" , 0x300 ) ; }
4427	protected function askForChoiceData ( $ optionIdentifier , $ optionName , array $ choices , $ defaultValue ) { $ optionValue = $ this -> input -> getOption ( $ optionIdentifier ) ; $ optionValue = ! empty ( $ optionValue ) ? $ optionValue : $ defaultValue ; $ question = $ this -> getChoiceQuestion ( $ optionName , $ optionValue , $ choices ) ; $ optionValue = $ this -> questionHelper -> ask ( $ this -> input , $ this -> output , $ question ) ; $ this -> input -> setOption ( $ optionIdentifier , $ optionValue ) ; return $ optionValue ; }
12738	public function addClass ( $ name ) { $ classParts = explode ( ' ' , $ this -> tags [ 'class' ] ) ; foreach ( $ classParts as $ part ) { if ( $ name == $ part ) return ; } $ this -> tags [ 'class' ] .= ' ' . $ name ; $ this -> tags [ 'class' ] = trim ( $ this -> tags [ 'class' ] ) ; }
5432	protected function isAbstractMethod ( $ name ) { $ interface = new ReflectionClass ( $ this -> interface ) ; if ( ! $ interface -> hasMethod ( $ name ) ) { return false ; } return $ interface -> getMethod ( $ name ) -> isAbstract ( ) ; }
7391	public function assign ( $ in ) { $ this -> _massageBlockInput ( $ in ) ; if ( empty ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { $ this -> __unset ( $ publicName ) ; } } elseif ( is_object ( $ in ) ) { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in -> { $ publicName } ) ) { $ this -> _setByName ( $ publicName , $ in -> { $ publicName } ) ; } else { $ this -> __unset ( $ publicName ) ; } } } else { foreach ( $ this -> _publicNames as $ publicName ) { if ( isset ( $ in [ $ publicName ] ) ) { $ this -> _setByName ( $ publicName , $ in [ $ publicName ] ) ; } else { $ this -> __unset ( $ publicName ) ; } } } $ this -> _checkRelatedProperties ( ) ; }
10503	private function setParameter ( $ subject , string $ key , $ value ) { $ setter = 'set' . $ this -> snakeToCamelCase ( $ key ) ; if ( is_callable ( [ $ subject , $ setter ] ) ) { call_user_func ( [ $ subject , $ setter ] , $ value ) ; } }
8058	public function setWorkerPoolSize ( $ size ) { if ( $ this -> created ) { throw new WorkerPoolException ( 'Cannot set the Worker Pool Size for a created pool.' ) ; } $ size = ( int ) $ size ; if ( $ size <= 0 ) { throw new \ InvalidArgumentException ( '"' . $ size . '" is not an integer greater than 0.' ) ; } $ this -> workerPoolSize = $ size ; return $ this ; }
5168	private function convertNonAscii ( string $ string ) : string { $ search = $ replace = [ ] ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 152 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 153 ) ; $ replace [ ] = "'" ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 156 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 157 ) ; $ replace [ ] = '"' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 147 ) ; $ replace [ ] = '--' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 148 ) ; $ replace [ ] = '---' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 162 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 194 ) . chr ( 183 ) ; $ replace [ ] = '*' ; $ search [ ] = chr ( 226 ) . chr ( 128 ) . chr ( 166 ) ; $ replace [ ] = '...' ; $ string = str_replace ( $ search , $ replace , $ string ) ; return preg_replace ( "/[^\x01-\x7F]/" , '' , $ string ) ; }
4566	public function getForms ( $ id ) { $ forms = [ ] ; $ form = $ this -> getForm ( $ id ) ; $ form -> setMethod ( 'POST' ) -> setPrimary ( true ) ; $ forms [ ] = $ form ; switch ( $ form -> getType ( ) ) { case Form :: TYPE_FORMIO : $ components = $ form -> getSchema ( ) ; $ resolverCollection = $ this -> resolverCollection ; $ extract = function ( & $ container , $ key , & $ component ) use ( & $ extract , & $ forms , $ resolverCollection ) { switch ( true ) { case property_exists ( $ component , 'components' ) : foreach ( $ component -> components as $ key => & $ subComponent ) { $ extract ( $ component -> components , $ key , $ subComponent ) ; } break ; case property_exists ( $ component , 'columns' ) : foreach ( $ component -> columns as & $ column ) { foreach ( $ column -> components as $ key => & $ subComponent ) { $ extract ( $ column -> components , $ key , $ subComponent ) ; } } break ; case property_exists ( $ component , 'properties' ) && is_object ( $ component -> properties ) && property_exists ( $ component -> properties , 'ds_form' ) : $ form = $ this -> getForm ( $ component -> properties -> ds_form ) ; $ data = [ ] ; if ( property_exists ( $ component , 'defaultValue' ) ) { try { $ data = $ resolverCollection -> resolve ( $ component -> defaultValue ) ; } catch ( UnresolvedException $ exception ) { $ data = [ ] ; } catch ( UnmatchedException $ exception ) { } } $ form -> setData ( $ data ) ; $ forms [ ] = $ form ; unset ( $ container [ $ key ] ) ; break ; } } ; foreach ( $ components as $ key => & $ component ) { $ extract ( $ components , $ key , $ component ) ; } $ form -> setSchema ( array_values ( $ components ) ) ; break ; case Form :: TYPE_SYMFONY : break ; default : throw new DomainException ( 'Form type does not exist.' ) ; } return $ forms ; }
4864	public function pop ( array $ options = [ ] ) { $ time = microtime ( true ) ; $ micro = sprintf ( "%06d" , ( $ time - floor ( $ time ) ) * 1000000 ) ; $ this -> now = new \ DateTime ( date ( 'Y-m-d H:i:s.' . $ micro , $ time ) , new \ DateTimeZone ( date_default_timezone_get ( ) ) ) ; $ now = $ this -> dateTimeToUTCDateTime ( $ this -> now ) ; $ envelope = $ this -> mongoCollection -> findOneAndUpdate ( [ 'queue' => $ this -> getName ( ) , 'status' => self :: STATUS_PENDING , 'scheduled' => [ '$lte' => $ now ] , ] , [ '$set' => [ 'status' => self :: STATUS_RUNNING , 'executed' => $ now , ] , ] , [ 'sort' => [ 'priority' => 1 , 'scheduled' => 1 ] , 'returnDocument' => \ MongoDB \ Operation \ FindOneAndUpdate :: RETURN_DOCUMENT_AFTER ] ) ; if ( ! $ envelope ) { return null ; } return $ this -> unserializeJob ( $ envelope [ 'data' ] , [ '__id__' => $ envelope [ '_id' ] ] ) ; }
5994	public function setSubFolders ( array $ subFolders ) { $ this -> subFolders = [ ] ; foreach ( $ subFolders as $ item ) { $ this -> addFolderResponse ( $ item ) ; } return $ this ; }
9398	protected function selectBuilder ( ) { if ( PHP_OS === 'Darwin' ) { if ( exec ( 'which growlnotify' ) ) { return new GrowlNotifyBuilder ; } if ( exec ( 'which terminal-notifier' ) ) { return new TerminalNotifierBuilder ; } } if ( PHP_OS === 'Linux' ) { if ( exec ( 'which notify-send' ) ) { return new NotifySendBuilder ; } } if ( PHP_OS === 'WINNT' ) { if ( exec ( 'where growlnotify' ) ) { return new GrowlNotifyWindowsBuilder ; } } }
1862	public function move_uploaded_file ( $ strSource , $ strDestination ) { $ this -> validate ( $ strSource , $ strDestination ) ; return move_uploaded_file ( $ strSource , $ this -> strRootDir . '/' . $ strDestination ) ; }
5592	protected function fetchWhileRedirected ( $ url , $ encoding ) { $ redirects = 0 ; do { $ response = $ this -> fetch ( $ url , $ encoding ) ; if ( $ response -> isError ( ) ) { return $ response ; } $ headers = $ response -> getHeaders ( ) ; if ( $ this -> cookies_enabled ) { $ headers -> writeCookiesToJar ( $ this -> cookie_jar , $ url ) ; } if ( ! $ headers -> isRedirect ( ) ) { break ; } $ location = new SimpleUrl ( $ headers -> getLocation ( ) ) ; $ url = $ location -> makeAbsolute ( $ url ) ; $ encoding = new SimpleGetEncoding ( ) ; } while ( ! $ this -> isTooManyRedirects ( ++ $ redirects ) ) ; return $ response ; }
6211	protected function cleanBacktrace ( $ backtrace ) { foreach ( $ backtrace as & $ item ) { if ( isset ( $ item [ 'file' ] ) ) { $ item [ 'file' ] = $ this -> cleanFilePath ( $ item [ 'file' ] ) ; } unset ( $ item [ 'args' ] ) ; } return $ backtrace ; }
6499	public function beforeStep ( Scope \ StepScope $ scope ) { self :: $ pageUrl = $ this -> getCurrentUrl ( ) ; $ _GET [ 'q' ] = ltrim ( parse_url ( static :: $ pageUrl ) [ 'path' ] , '/' ) ; drupal_path_initialize ( ) ; }
2418	protected function addFolderToArchive ( ZipWriter $ objArchive , $ strFolder , \ DOMDocument $ xml , \ DOMElement $ table , array $ arrOrder = array ( ) ) { $ strFolder = preg_replace ( '@^' . preg_quote ( Config :: get ( 'uploadPath' ) , '@' ) . '/@' , '' , $ strFolder ) ; if ( $ strFolder == '' ) { $ strTarget = 'files' ; $ strFolder = Config :: get ( 'uploadPath' ) ; } else { $ strTarget = 'files/' . $ strFolder ; $ strFolder = Config :: get ( 'uploadPath' ) . '/' . $ strFolder ; } if ( Validator :: isInsecurePath ( $ strFolder ) ) { throw new \ RuntimeException ( 'Insecure path ' . $ strFolder ) ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { return ; } foreach ( scan ( $ this -> strRootDir . '/' . $ strFolder ) as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ this -> strRootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ this -> addFolderToArchive ( $ objArchive , $ strFolder . '/' . $ strFile , $ xml , $ table , $ arrOrder ) ; } else { $ objArchive -> addFile ( $ strFolder . '/' . $ strFile , $ strTarget . '/' . $ strFile ) ; $ arrRow = array ( ) ; $ objFile = new File ( $ strFolder . '/' . $ strFile ) ; $ objModel = FilesModel :: findByPath ( $ strFolder . '/' . $ strFile ) ; if ( $ objModel !== null ) { $ arrRow = $ objModel -> row ( ) ; foreach ( array ( 'id' , 'pid' , 'tstamp' , 'uuid' , 'type' , 'extension' , 'found' , 'name' ) as $ key ) { unset ( $ arrRow [ $ key ] ) ; } } $ arrRow [ 'path' ] = $ strTarget . '/' . $ strFile ; $ arrRow [ 'hash' ] = $ objFile -> hash ; $ this -> addDataRow ( $ xml , $ table , $ arrRow , $ arrOrder ) ; } } }
6850	public static function years ( $ start = false , $ end = false ) { $ start = ( $ start === false ) ? ( date ( 'Y' ) - 5 ) : ( int ) $ start ; $ end = ( $ end === false ) ? ( date ( 'Y' ) + 5 ) : ( int ) $ end ; $ years = array ( ) ; for ( $ i = $ start ; $ i <= $ end ; $ i ++ ) { $ years [ $ i ] = ( string ) $ i ; } return $ years ; }
2910	public function runSql ( $ query , $ queryParams = array ( ) ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ statement = $ connection -> query ( $ query , $ queryParams ) ; return $ statement -> fetchAll ( PDO :: FETCH_ASSOC ) ; }
2111	private function askForPassword ( string $ label , InputInterface $ input , OutputInterface $ output ) : string { $ question = new Question ( $ label ) ; $ question -> setHidden ( true ) ; $ question -> setMaxAttempts ( 3 ) ; $ helper = $ this -> getHelper ( 'question' ) ; return $ helper -> ask ( $ input , $ output , $ question ) ; }
7771	protected function fetchMessage ( $ field , $ rule ) { if ( isset ( $ this -> fieldMessages [ $ field ] [ $ rule ] ) ) { return $ this -> fieldMessages [ $ field ] [ $ rule ] ; } if ( isset ( $ this -> ruleMessages [ $ rule ] ) ) { return $ this -> ruleMessages [ $ rule ] ; } return $ this -> usedRules [ $ rule ] -> error ( ) ; }
7565	protected function parse_callback ( $ conditions , $ recursive = true , $ check_root = false ) { return ( $ this -> result = $ this -> root -> getChildrenByMatch ( $ conditions , $ recursive , $ check_root , $ this -> custom_filter_map ) ) ; }
1474	public function createResourceValidator ( ResourceObject $ resource , array $ rules , array $ messages = [ ] , array $ customAttributes = [ ] ) { return $ this -> createValidator ( $ resource -> all ( ) , $ rules , $ messages , $ customAttributes , function ( $ key , $ detail , $ failed ) use ( $ resource ) { return $ this -> invalidResource ( $ resource -> pointer ( $ key , '/data' ) , $ detail , $ failed ) ; } ) ; }
11651	public function getProduct ( array $ productData ) { foreach ( $ this -> mandatoryFields as $ mandatoryField ) { if ( ! array_key_exists ( $ mandatoryField , $ productData ) ) { throw new ProductException ( "The field '$mandatoryField' is missing in the given product data" ) ; } } try { $ sku = new SKU ( $ productData [ self :: FIELD_SKU ] ) ; $ slug = new Slug ( $ productData [ self :: FIELD_SLUG ] ) ; $ content = $ this -> contentMapper -> getContent ( $ productData ) ; $ product = new Product ( $ sku , $ slug , $ content ) ; return $ product ; } catch ( \ Exception $ productException ) { throw new ProductException ( sprintf ( "Failed to create a product from the given data: %s" , $ productException -> getMessage ( ) ) , $ productException ) ; } }
1553	protected function resourceAttributes ( $ record = null ) { return $ this -> validatorFactory ( ) -> attributes ( $ this -> attributeRules ( $ record ) , $ this -> attributeMessages ( $ record ) , $ this -> attributeCustomAttributes ( $ record ) , function ( Validator $ validator ) use ( $ record ) { return $ this -> conditionalAttributes ( $ validator , $ record ) ; } , function ( ResourceObjectInterface $ resource , $ record ) { return $ this -> extractAttributes ( $ resource , $ record ) ; } ) ; }
1827	public function markModified ( $ strKey ) { if ( ! isset ( $ this -> arrModified [ $ strKey ] ) ) { $ this -> arrModified [ $ strKey ] = $ this -> arrData [ $ strKey ] ?? null ; } }
6483	private static function filterPath ( ? string $ path ) : ? string { if ( $ path === null ) { return null ; } return preg_replace_callback ( '/(?:[^a-zA-Z0-9_\-\.~:@&=\+\$,\/;%]+|%(?![A-Fa-f0-9]{2}))/' , function ( $ match ) { return rawurlencode ( $ match [ 0 ] ) ; } , $ path ) ; }
12045	public function destroy ( UserPolicy $ user , Question $ question ) { return $ question -> user_id == user_id ( ) && $ question -> user_type == user_type ( ) ; }
8074	public function delete ( $ endpoint , $ headers = [ ] ) { $ request = new Request ( 'DELETE' , $ endpoint , $ headers ) ; $ response = $ this -> guzzle -> send ( $ request ) ; return $ this -> handle ( $ response ) ; }
6770	protected function handleStateChange ( SaleInterface $ sale ) { if ( $ this -> configureAcceptedSale ( $ sale ) ) { $ this -> persistenceHelper -> persistAndRecompute ( $ sale , false ) ; } }
10533	public function last ( ) { if ( is_array ( $ this -> items ) && count ( $ this -> items ) > 0 ) { return end ( $ this -> items ) ; } return null ; }
12746	protected function onMovedResponse ( CommandInterface $ command , $ details ) { list ( $ slot , $ connectionID ) = explode ( ' ' , $ details , 2 ) ; if ( ! $ connection = $ this -> getConnectionById ( $ connectionID ) ) { $ connection = $ this -> createConnection ( $ connectionID ) ; } if ( $ this -> useClusterSlots ) { $ this -> askSlotMap ( $ connection ) ; } $ this -> move ( $ connection , $ slot ) ; $ response = $ this -> executeCommand ( $ command ) ; return $ response ; }
412	public function getPort ( ) { if ( $ this -> _port === null ) { $ serverPort = $ this -> getServerPort ( ) ; $ this -> _port = ! $ this -> getIsSecureConnection ( ) && $ serverPort !== null ? $ serverPort : 80 ; } return $ this -> _port ; }
4763	public function createUser ( ) { if ( false == $ this -> validateRegistrationOptin ( ) ) { if ( $ this -> getRequestParameter ( 'stoken' ) ) { \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true ) ; \ OxidEsales \ Eshop \ Core \ Registry :: get ( \ OxidEsales \ Eshop \ Core \ UtilsView :: class ) -> addErrorToDisplay ( 'OEGDPROPTIN_CONFIRM_USER_REGISTRATION_OPTIN' , false , true , 'oegdproptin_userregistration' ) ; } } else { return parent :: createUser ( ) ; } }
12156	public function getOwner ( ) { if ( ! $ this -> isOwnable ) { return ; } $ ownerObject = $ this -> getOwnerObject ( ) ; if ( is_object ( $ ownerObject ) ) { return $ ownerObject -> primaryKey ; } return $ ownerObject ; }
3105	public function getStoreId ( ) { return isset ( $ this -> state [ self :: VAR_STORE_ID ] ) ? $ this -> state [ self :: VAR_STORE_ID ] : false ; }
9886	private function writeDefinedNameForAutofilter ( XMLWriter $ objWriter , Worksheet $ pSheet , $ pSheetId = 0 ) { $ autoFilterRange = $ pSheet -> getAutoFilter ( ) -> getRange ( ) ; if ( ! empty ( $ autoFilterRange ) ) { $ objWriter -> startElement ( 'definedName' ) ; $ objWriter -> writeAttribute ( 'name' , '_xlnm._FilterDatabase' ) ; $ objWriter -> writeAttribute ( 'localSheetId' , $ pSheetId ) ; $ objWriter -> writeAttribute ( 'hidden' , '1' ) ; $ range = Coordinate :: splitRange ( $ autoFilterRange ) ; $ range = $ range [ 0 ] ; if ( strpos ( $ range [ 0 ] , '!' ) !== false ) { list ( $ ws , $ range [ 0 ] ) = explode ( '!' , $ range [ 0 ] ) ; } $ range [ 0 ] = Coordinate :: absoluteCoordinate ( $ range [ 0 ] ) ; $ range [ 1 ] = Coordinate :: absoluteCoordinate ( $ range [ 1 ] ) ; $ range = implode ( ':' , $ range ) ; $ objWriter -> writeRawData ( '\'' . str_replace ( "'" , "''" , $ pSheet -> getTitle ( ) ) . '\'!' . $ range ) ; $ objWriter -> endElement ( ) ; } }
1559	protected function fillAttributes ( $ record , Collection $ attributes ) { $ record -> fill ( $ this -> deserializeAttributes ( $ attributes , $ record ) ) ; }
7997	public static function getSpecificationString ( $ reversed = false ) { $ reflection = new ReflectionClass ( get_class ( ) ) ; $ constants = $ reflection -> getConstants ( ) ; if ( $ reversed ) { $ constants = array_reverse ( $ constants ) ; } $ string = '' ; foreach ( $ constants as $ name => $ int_val ) { $ binary_val_string = base_convert ( ( string ) $ int_val , '10' , '2' ) ; $ string .= sprintf ( '0b%s : %s' , str_pad ( $ binary_val_string , 32 , '0' , STR_PAD_LEFT ) , $ name ) ; $ string .= PHP_EOL ; } return $ string ; }
12243	public function XSLT ( $ filepath , $ use_xslcache = true ) { if ( $ use_xslcache && extension_loaded ( 'xslcache' ) ) { $ xslt = new XSLTCache ; $ xslt -> importStylesheet ( $ filepath ) ; } else { $ xsl = new DOMDocument ; $ xsl -> load ( $ filepath ) ; $ xslt = new XSLTProcessor ; $ xslt -> importStylesheet ( $ xsl ) ; } return $ xslt -> transformToXML ( dom_import_simplexml ( $ this ) ) ; }
10192	public static function parseDsn ( $ string = null ) { $ opts = null ; if ( ! empty ( $ string ) ) { $ dsn = ( object ) DsnParser :: parseUrl ( $ string ) -> toArray ( ) ; $ opts = [ 'driver' => $ dsn -> driver , 'host' => $ dsn -> host , 'database' => $ dsn -> dbname , 'username' => $ dsn -> user , 'password' => isset ( $ dsn -> pass ) ? $ dsn -> pass : null ] ; } return $ opts ; }
1599	protected function authenticate ( ) { if ( empty ( $ this -> guards ) && Auth :: check ( ) ) { return ; } foreach ( $ this -> guards as $ guard ) { if ( Auth :: guard ( $ guard ) -> check ( ) ) { Auth :: shouldUse ( $ guard ) ; return ; } } throw new AuthenticationException ( 'Unauthenticated.' , $ this -> guards ) ; }
5906	public function listSettings ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/settings' , $ parameters , $ cachePolicy ) ; return $ result ; }
9834	public static function pixelsToCellDimension ( $ pValue , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ pDefaultFont ) { $ name = $ pDefaultFont -> getName ( ) ; $ size = $ pDefaultFont -> getSize ( ) ; if ( isset ( Font :: $ defaultColumnWidths [ $ name ] [ $ size ] ) ) { $ colWidth = $ pValue * Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'width' ] / Font :: $ defaultColumnWidths [ $ name ] [ $ size ] [ 'px' ] ; } else { $ colWidth = $ pValue * 11 * Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'width' ] / Font :: $ defaultColumnWidths [ 'Calibri' ] [ 11 ] [ 'px' ] / $ size ; } return $ colWidth ; }
9128	private function checkContentLengthExceeded ( ) : bool { if ( isset ( $ this -> headers [ 'Content-Length' ] ) ) { if ( $ this -> payload -> count ( ) >= $ this -> headers [ 'Content-Length' ] ) { return true ; } } return false ; }
10852	public function echo ( $ type , $ content ) { if ( $ this -> option ( 'debug' ) == false ) { return ; } if ( trim ( $ content ) ) { $ this -> { $ type } ( $ content ) ; } }
5594	protected function createRequest ( $ url , $ encoding ) { $ request = $ this -> createHttpRequest ( $ url , $ encoding ) ; $ this -> addAdditionalHeaders ( $ request ) ; if ( $ this -> cookies_enabled ) { $ request -> readCookiesFromJar ( $ this -> cookie_jar , $ url ) ; } $ this -> authenticator -> addHeaders ( $ request , $ url ) ; if ( $ this -> http_referer ) { $ headers = $ request -> getHeaders ( ) ; if ( is_array ( $ headers ) ) { $ custom_referer = false ; foreach ( $ headers as $ header ) { if ( preg_match ( '~^referer:~i' , $ header ) ) { $ custom_referer = true ; break ; } } if ( ! $ custom_referer ) { $ request -> addHeaderLine ( 'Referer: ' . $ this -> http_referer ) ; } } } return $ request ; }
8481	public static function getNameById ( $ id , $ attributeName = 'name' ) { $ model = static :: loadModel ( $ id ) ; return empty ( $ model [ $ attributeName ] ) === false ? $ model [ $ attributeName ] : \ Yii :: t ( 'app' , 'Unknown' ) ; }
9026	public function hasEmail ( $ string ) { $ result = false ; $ tokenizer = new General ( ) ; $ words = $ tokenizer -> tokenize ( $ string ) ; foreach ( $ words as $ word ) { if ( filter_var ( $ word , FILTER_VALIDATE_EMAIL ) ) { $ result = true ; } } return $ result ; }
4028	protected function getLabelImage ( ModelInterface $ model ) { $ typeFactory = $ this -> factory -> getTypeFactory ( $ model -> getProperty ( 'type' ) ) ; $ image = $ this -> iconBuilder -> getBackendIconImageTag ( $ this -> updateImageWithDisabled ( $ model , $ typeFactory -> getTypeIcon ( ) ) , '' , '' , $ this -> updateImageWithDisabled ( $ model , 'bundles/metamodelscore/images/icons/filter_default.png' ) ) ; $ urlEvent = $ this -> dispatcher -> dispatch ( ContaoEvents :: BACKEND_ADD_TO_URL , new AddToUrlEvent ( 'act=edit&amp;id=' . $ model -> getId ( ) ) ) ; return sprintf ( '<a href="%s">%s</a>' , $ urlEvent -> getUrl ( ) , $ image ) ; }
7840	public function addNumber ( int $ id , string $ number ) : ? array { $ response = Request :: put ( $ this -> baseUrl . sprintf ( 'contact/%d/phone-number/%s' , $ id , $ number ) ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
1283	public function addUnknownField ( string $ name ) : Field { $ this -> fields [ $ name ] = new Field ( $ name , $ name , 'Unknown' ) ; return $ this -> fields [ $ name ] ; }
1833	public function onUnregister ( Registry $ registry ) { foreach ( static :: getUniqueFields ( ) as $ strColumn ) { $ varAliasValue = $ this -> { $ strColumn } ; if ( $ registry -> isRegisteredAlias ( $ this , $ strColumn , $ varAliasValue ) ) { $ registry -> unregisterAlias ( $ this , $ strColumn , $ varAliasValue ) ; } } }
11174	public static function hash ( $ string , $ algorithm = 'blowfish' ) { switch ( strtolower ( $ algorithm ) ) : case ( 'md5' ) : $ salt = '$1$' . ( static :: rand ( 12 ) ) . '$' ; break ; case ( 'sha256' ) : $ salt = '$5$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'sha512' ) : $ salt = '$6$rounds=5000$' . ( static :: rand ( 16 ) ) . '$' ; break ; case ( 'blowfish' ) : default : $ salt = '$2a$09$' . ( static :: rand ( 22 ) ) . '$' ; break ; endswitch ; return base64_encode ( crypt ( $ string , $ salt ) ) ; }
1151	protected function getViewData ( ) { $ this -> validator -> setRemote ( $ this -> remote ) ; $ data = $ this -> validator -> validationData ( ) ; $ data [ 'selector' ] = $ this -> selector ; if ( ! is_null ( $ this -> ignore ) ) { $ data [ 'ignore' ] = $ this -> ignore ; } return $ data ; }
11025	public function __isset ( $ name ) : bool { if ( strrpos ( $ name , 'facet_' , - strlen ( $ name ) ) !== false ) { return true ; } return false ; }
10610	public function checkEmailAction ( ) { $ email = $ this -> get ( 'session' ) -> get ( 'fos_user_send_confirmation_email/email' ) ; $ this -> get ( 'session' ) -> remove ( 'fos_user_send_confirmation_email/email' ) ; $ user = $ this -> get ( 'fos_user.user_manager' ) -> findUserByEmail ( $ email ) ; if ( null === $ user ) { throw new NotFoundHttpException ( sprintf ( 'The user with email "%s" does not exist' , $ email ) ) ; } return $ this -> render ( '@MikyUser/Frontend/Registration/checkEmail.html.twig' , array ( 'user' => $ user , ) ) ; }
10097	private function writeBIFF8CellRangeAddressFixed ( $ range ) { $ explodes = explode ( ':' , $ range ) ; $ firstCell = $ explodes [ 0 ] ; if ( count ( $ explodes ) == 1 ) { $ lastCell = $ firstCell ; } else { $ lastCell = $ explodes [ 1 ] ; } $ firstCellCoordinates = Coordinate :: coordinateFromString ( $ firstCell ) ; $ lastCellCoordinates = Coordinate :: coordinateFromString ( $ lastCell ) ; return pack ( 'vvvv' , $ firstCellCoordinates [ 1 ] - 1 , $ lastCellCoordinates [ 1 ] - 1 , Coordinate :: columnIndexFromString ( $ firstCellCoordinates [ 0 ] ) - 1 , Coordinate :: columnIndexFromString ( $ lastCellCoordinates [ 0 ] ) - 1 ) ; }
12355	public function setVariables ( array $ data ) : void { foreach ( $ data as $ key => $ value ) { $ this -> $ key = $ value ; } }
6466	private static function createDefaultBoundary ( ) : string { try { $ string = random_bytes ( 16 ) ; $ string [ 6 ] = chr ( ord ( $ string [ 6 ] ) & 0x0f | 0x40 ) ; $ string [ 8 ] = chr ( ord ( $ string [ 8 ] ) & 0x3f | 0x80 ) ; return vsprintf ( '%s%s-%s-%s-%s-%s%s%s' , str_split ( bin2hex ( $ string ) , 4 ) ) ; } catch ( Exception $ ex ) { throw new RuntimeException ( 'Failed to generate random bytes' , 0 , $ ex ) ; } }
8972	protected function paginate ( array $ rates , $ criteria ) { if ( ! array_key_exists ( 'offset' , $ criteria ) && ! array_key_exists ( 'limit' , $ criteria ) ) { return $ rates ; } $ range = array ( ) ; $ offset = array_key_exists ( 'offset' , $ criteria ) ? $ criteria [ 'offset' ] : 0 ; $ limit = min ( ( array_key_exists ( 'limit' , $ criteria ) ? $ criteria [ 'limit' ] : count ( $ rates ) ) + $ offset , count ( $ rates ) ) ; for ( $ i = $ offset ; $ i < $ limit ; $ i ++ ) { $ range [ ] = $ rates [ $ i ] ; } return $ range ; }
2059	public function generateSitemap ( ) { $ objSession = Contao \ System :: getContainer ( ) -> get ( 'session' ) ; $ session = $ objSession -> get ( 'sitemap_updater' ) ; if ( empty ( $ session ) || ! \ is_array ( $ session ) ) { return ; } $ this -> import ( 'Contao\Automator' , 'Automator' ) ; foreach ( $ session as $ id ) { $ this -> Automator -> generateSitemap ( $ id ) ; } $ objSession -> set ( 'sitemap_updater' , null ) ; }
8363	public static function translate ( $ key , array $ args = array ( ) ) { if ( self :: $ isInit === false ) { throw new BadUse ( 'locale doesn\'t seem to have been initialized' ) ; } $ oldKey = $ key ; $ section = self :: $ translations ; while ( isset ( $ section [ $ key ] ) === false && ( $ pos = strpos ( $ key , '.' ) ) !== false ) { if ( ! is_int ( $ pos ) ) { break ; } $ subSection = substr ( $ key , 0 , $ pos ) ; if ( isset ( $ section [ $ subSection ] ) === false ) { break ; } $ section = $ section [ $ subSection ] ; $ key = substr ( $ key , $ pos + 1 ) ; } if ( isset ( $ section [ $ key ] ) === false ) { Logger :: get ( ) -> error ( 'can\'t find translation for key "' . $ oldKey . '"' ) ; return '(null)' ; } return $ section [ $ key ] ; }
164	public static function create ( $ from ) { return new self ( [ 'where' => $ from -> where , 'limit' => $ from -> limit , 'offset' => $ from -> offset , 'orderBy' => $ from -> orderBy , 'indexBy' => $ from -> indexBy , 'select' => $ from -> select , 'selectOption' => $ from -> selectOption , 'distinct' => $ from -> distinct , 'from' => $ from -> from , 'groupBy' => $ from -> groupBy , 'join' => $ from -> join , 'having' => $ from -> having , 'union' => $ from -> union , 'params' => $ from -> params , ] ) ; }
10819	public static function comment ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'comment' , $ length , $ separator ) ; }
8260	protected function saveLoginInfo ( $ resourceOwner ) { $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ attrMap = $ this -> providerConfig [ 'attributeMap' ] ; $ userIdAttr = $ attrMap [ 'userId' ] ; $ userId = $ this -> getResourceAttribute ( $ userIdAttr , $ resourceOwner ) ; $ u -> setId ( $ userId ) ; unset ( $ attrMap [ 'userId' ] ) ; if ( isset ( $ attrMap [ 'displayName' ] ) ) { $ name = $ this -> getResourceAttribute ( $ attrMap [ 'displayName' ] , $ resourceOwner ) ; $ u -> setDisplayName ( $ name ) ; unset ( $ attrMap [ 'displayName' ] ) ; } foreach ( $ attrMap as $ mapKey => $ mapValue ) { $ value = $ this -> getResourceAttribute ( $ mapValue , $ resourceOwner ) ; $ u -> setAttribute ( $ mapKey , $ value ) ; } $ u -> setGroups ( $ this -> providerConfig [ 'default' ] [ 'groups' ] ) ; foreach ( $ this -> providerConfig [ 'default' ] [ 'attributes' ] as $ key => $ value ) { if ( null === $ u -> getAttribute ( $ key ) ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; $ this -> picoAuth -> afterLogin ( ) ; }
12587	public function init ( ) { parent :: init ( ) ; $ db = $ this -> getDbConnection ( ) ; $ db -> setActive ( true ) ; if ( $ this -> autoCreateTokenTable ) { $ sql = "DELETE FROM {$this->tokenTableName} WHERE (expires>0 AND expires<" . time ( ) . ") OR (uses_allowed>0 AND uses_remaining<1)" ; try { $ db -> createCommand ( $ sql ) -> execute ( ) ; } catch ( Exception $ e ) { $ this -> createTokenTable ( $ db , $ this -> tokenTableName ) ; } } }
10439	protected function nextBufferLine ( ) { $ query = $ this -> parseQuery ( ) ; if ( ! empty ( $ query ) ) { $ this -> buffer [ $ this -> key ] [ self :: PARAM_QUERY ] = $ query ; } else { $ this -> buffer [ $ this -> key ] = false ; } }
10116	private function writeHcenter ( ) { $ record = 0x0083 ; $ length = 0x0002 ; $ fHCenter = $ this -> phpSheet -> getPageSetup ( ) -> getHorizontalCentered ( ) ? 1 : 0 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ fHCenter ) ; $ this -> append ( $ header . $ data ) ; }
7199	protected function assignSaleItemRecursively ( SaleItemInterface $ item ) { $ this -> stockAssigner -> assignSaleItem ( $ item ) ; foreach ( $ item -> getChildren ( ) as $ child ) { $ this -> assignSaleItemRecursively ( $ child ) ; } }
7601	protected function renderButtons ( array $ aButtons , $ bJustified = false ) { $ sMarkup = '' ; foreach ( $ aButtons as $ oButton ) { if ( is_array ( $ oButton ) || ( $ oButton instanceof Traversable && ! ( $ oButton instanceof ElementInterface ) ) ) { $ oFactory = new Factory ( ) ; $ oButton = $ oFactory -> create ( $ oButton ) ; } elseif ( ! ( $ oButton instanceof ElementInterface ) ) { throw new LogicException ( sprintf ( 'Button expects an instanceof Zend\Form\ElementInterface or an array / Traversable, "%s" given' , is_object ( $ oButton ) ? get_class ( $ oButton ) : gettype ( $ oButton ) ) ) ; } $ sButtonMarkup = $ this -> getFormElementHelper ( ) -> __invoke ( $ oButton ) ; $ sMarkup .= $ bJustified ? sprintf ( static :: $ buttonGroupJustifiedFormat , $ sButtonMarkup ) : $ sButtonMarkup ; } return $ sMarkup ; }
4991	public function getEntity ( $ key = '*' ) { return isset ( $ this -> entities [ $ key ] ) ? $ this -> entities [ $ key ] : null ; }
3958	protected function registerAssets ( $ objSettings ) { if ( ! $ objSettings ) { return ; } $ arrCss = $ objSettings -> get ( 'additionalCss' ) ; foreach ( ( array ) $ arrCss as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_CSS' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } $ arrJs = $ objSettings -> get ( 'additionalJs' ) ; foreach ( ( array ) $ arrJs as $ arrFile ) { if ( $ arrFile [ 'published' ] ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ md5 ( $ arrFile [ 'file' ] ) ] = $ arrFile [ 'file' ] ; } } }
4210	private function phpDocParam ( $ param , $ className ) { $ constantName = null ; $ defaultValue = $ this -> abstracter -> UNDEFINED ; if ( \ array_key_exists ( 'defaultValue' , $ param ) ) { $ defaultValue = $ param [ 'defaultValue' ] ; if ( \ in_array ( $ defaultValue , array ( 'true' , 'false' , 'null' ) ) ) { $ defaultValue = \ json_decode ( $ defaultValue ) ; } elseif ( \ is_numeric ( $ defaultValue ) ) { $ defaultValue = $ defaultValue * 1 ; } elseif ( \ preg_match ( '/^array\(\s*\)|\[\s*\]$/i' , $ defaultValue ) ) { $ defaultValue = array ( ) ; } elseif ( \ preg_match ( '/^(self::)?([^\(\)\[\]]+)$/i' , $ defaultValue , $ matches ) ) { if ( $ matches [ 1 ] ) { if ( \ defined ( $ className . '::' . $ matches [ 2 ] ) ) { $ constantName = $ matches [ 0 ] ; $ defaultValue = \ constant ( $ className . '::' . $ matches [ 2 ] ) ; } } elseif ( \ defined ( $ defaultValue ) ) { $ constantName = $ defaultValue ; $ defaultValue = \ constant ( $ defaultValue ) ; } } else { $ defaultValue = \ trim ( $ defaultValue , '\'"' ) ; } } return array ( 'constantName' => $ constantName , 'defaultValue' => $ defaultValue , ) ; }
11831	public static function create ( $ command , $ app ) { static $ cache = [ ] ; $ cacheKey = $ command ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ command = $ cache [ $ cacheKey ] [ 'command' ] ; } else { if ( false === strpos ( $ command , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ command ) ; } else { $ class = explode ( '.' , $ command ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ command = substr ( $ command , strrpos ( $ command , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'command' => $ command ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow command ' . $ cacheKey ) ; } return new $ class ( $ app ) ; }
4813	public function get ( $ name , $ default = null ) { return array_key_exists ( $ name , $ this -> storage ) ? $ this -> storage [ $ name ] : $ default ; }
9617	public function registerSubscriber ( $ class , callable $ callback ) { $ service_id = "event." . strtolower ( str_replace ( "\\" , "." , $ class ) ) ; $ this [ $ service_id ] = $ callback ; $ this [ "dispatcher" ] -> addSubscriberService ( $ service_id , $ class ) ; }
5106	public function _set ( $ exp , $ bind = false ) { return $ this -> appendPart ( CmdUpdate :: PART_SET , $ exp , $ bind ) ; }
969	public function getType ( ) { $ config = Config :: get ( 'shopify-app.api_grant_mode' ) ; if ( $ config === self :: GRANT_PERUSER ) { return self :: GRANT_PERUSER ; } return self :: GRANT_OFFLINE ; }
6659	protected function getEndpoints ( ) { if ( ! $ this -> endpointsCache ) { $ isHidden = $ this -> getControllerMethod ( 'isMethodHidden' ) ; $ endpoints = [ ] ; $ parts = [ ] ; $ methods = $ this -> reflectedController -> getMethods ( \ ReflectionMethod :: IS_PUBLIC ) ; foreach ( $ methods as $ method ) { if ( preg_match ( '/([a-z]+)([A-Z]\w+)Endpoint$/' , $ method -> getName ( ) , $ parts ) ) { if ( ! $ isHidden ( $ method -> getName ( ) ) ) { $ httpVerb = strtolower ( $ parts [ 1 ] ) ; $ endpoint = $ this -> camelcaseToHyphenated ( $ parts [ 2 ] ) ; if ( ! array_key_exists ( $ httpVerb , $ endpoints ) ) { $ endpoints [ $ httpVerb ] = array ( ) ; } $ endpoints [ $ httpVerb ] [ $ endpoint ] = $ this -> documentation -> getMethodDocumentation ( $ method ) ; } } } $ this -> endpointsCache = $ endpoints ; } return $ this -> endpointsCache ; }
9729	function toDateTime ( ) { return $ this -> date . " " . str_pad ( $ this -> hours , 2 , '0' , STR_PAD_LEFT ) . ":" . str_pad ( $ this -> minutes , 2 , '0' , STR_PAD_LEFT ) ; }
868	private function isInConditionWithoutBraces ( Tokens $ tokens , $ index , $ lowerLimitIndex ) { do { if ( $ tokens [ $ index ] -> isComment ( ) || $ tokens [ $ index ] -> isWhitespace ( ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_IF , T_ELSEIF , T_ELSE ] ) ) { return true ; } if ( $ token -> equals ( ';' , '}' ) ) { return false ; } if ( $ token -> equals ( '{' ) ) { $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( T_DO ) ) { -- $ index ; continue ; } if ( ! $ tokens [ $ index ] -> equals ( ')' ) ) { return false ; } $ index = $ tokens -> findBlockStart ( Tokens :: BLOCK_TYPE_PARENTHESIS_BRACE , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; if ( $ tokens [ $ index ] -> isGivenKind ( [ T_IF , T_ELSEIF ] ) ) { return false ; } } elseif ( $ token -> equals ( ')' ) ) { $ type = Tokens :: detectBlockType ( $ token ) ; $ index = $ tokens -> findBlockStart ( $ type [ 'type' ] , $ index ) ; $ index = $ tokens -> getPrevMeaningfulToken ( $ index ) ; } else { -- $ index ; } } while ( $ index > $ lowerLimitIndex ) ; return false ; }
2933	public function deleteKeys ( $ keys = [ ] ) { foreach ( $ keys as $ key ) { $ this -> writer -> deleteSetter ( $ key ) ; } return $ this ; }
10112	private function writeRangeProtection ( ) { foreach ( $ this -> phpSheet -> getProtectedCells ( ) as $ range => $ password ) { $ cellRanges = explode ( ' ' , $ range ) ; $ cref = count ( $ cellRanges ) ; $ recordData = pack ( 'vvVVvCVvVv' , 0x0868 , 0x00 , 0x0000 , 0x0000 , 0x02 , 0x0 , 0x0000 , $ cref , 0x0000 , 0x00 ) ; foreach ( $ cellRanges as $ cellRange ) { $ recordData .= $ this -> writeBIFF8CellRangeAddressFixed ( $ cellRange ) ; } $ recordData .= pack ( 'VV' , 0x0000 , hexdec ( $ password ) ) ; $ recordData .= StringHelper :: UTF8toBIFF8UnicodeLong ( 'p' . md5 ( $ recordData ) ) ; $ length = strlen ( $ recordData ) ; $ record = 0x0868 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ this -> append ( $ header . $ recordData ) ; } }
4236	public function emailLog ( ) { $ errorStr = $ this -> buildErrorList ( ) ; $ subject = 'Debug Log' ; $ subjectMore = '' ; if ( ! empty ( $ _SERVER [ 'HTTP_HOST' ] ) ) { $ subjectMore .= ' ' . $ _SERVER [ 'HTTP_HOST' ] ; } if ( $ errorStr ) { $ subjectMore .= ' ' . ( $ subjectMore ? '(Error)' : 'Error' ) ; } $ subject = \ rtrim ( $ subject . ':' . $ subjectMore , ':' ) ; $ body = ( ! isset ( $ _SERVER [ 'REQUEST_URI' ] ) && ! empty ( $ _SERVER [ 'argv' ] ) ? 'Command: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) : 'Request: ' . $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] ) . "\n\n" ; if ( $ errorStr ) { $ body .= 'Error(s):' . "\n" . $ errorStr . "\n" ; } $ data = \ array_intersect_key ( $ this -> debug -> getData ( ) , \ array_flip ( array ( 'alerts' , 'log' , 'logSummary' , 'requestId' , 'runtime' , ) ) ) ; $ data [ 'rootChannel' ] = $ this -> debug -> getCfg ( 'channel' ) ; $ body .= $ this -> debug -> utilities -> serializeLog ( $ data ) ; $ this -> email ( $ this -> debug -> getCfg ( 'emailTo' ) , $ subject , $ body ) ; return ; }
1186	protected function resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) { $ validateAll = Arr :: get ( $ data , $ field . '_validate_all' , false ) ; $ validationRule = 'bail|' . Validator :: EXTENSION_NAME . ':' . $ validateAll ; $ rules = [ $ field => $ validationRule ] + $ rules ; $ validator = $ this -> createValidator ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) ; return $ validator ; }
2693	private function compileFastlyParameters ( ) { if ( isset ( $ this -> fastlyParameters [ 'width' ] ) == false ) { $ this -> fastlyParameters [ 'height' ] = $ this -> _height ; $ this -> fastlyParameters [ 'width' ] = $ this -> _width ; } $ params = [ ] ; foreach ( $ this -> fastlyParameters as $ key => $ value ) { $ params [ ] = $ key . '=' . $ value ; } return implode ( '&' , $ params ) ; }
3175	private function getItemLabel ( RunnerServiceContext $ context , $ itemUri , $ useTitle = false ) { $ label = '' ; if ( $ useTitle ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'title' ) ; } if ( ! $ label ) { $ label = $ context -> getItemIndexValue ( $ itemUri , 'label' ) ; } if ( ! $ label ) { $ item = new \ core_kernel_classes_Resource ( $ itemUri ) ; $ label = $ item -> getLabel ( ) ; } return $ label ; }
10471	public function checkOutItem ( $ user_id , $ item_id ) { $ request = new CheckOutRequest ( $ this -> connector -> agency_id , $ user_id , $ item_id ) ; $ this -> emit ( 'request.checkout' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new CheckOutResponse ( $ response ) ; }
1901	public function validate ( ) { $ mandatory = $ this -> mandatory ; $ options = $ this -> getPost ( $ this -> strName ) ; if ( $ mandatory && \ is_array ( $ options ) ) { foreach ( $ options as $ option ) { if ( \ strlen ( $ option ) ) { $ this -> mandatory = false ; break ; } } } $ varInput = $ this -> validator ( $ options ) ; if ( ! empty ( $ varInput ) && ! $ this -> isValidOption ( $ varInput ) ) { $ this -> addError ( $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalid' ] ) ; } if ( $ this -> hasErrors ( ) ) { $ this -> class = 'error' ; } else { $ this -> varValue = $ varInput ; } if ( $ mandatory ) { $ this -> mandatory = true ; } }
137	public function install ( RepositoryInterface $ repo , InstallOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; $ installer -> install ( $ repo , $ package ) ; $ this -> markForNotification ( $ package ) ; }
6438	public function completeLogin ( $ extrainputs = array ( ) ) { $ request_token = [ ] ; $ request_token [ 'oauth_token' ] = $ this -> request_token [ 'oauth_token' ] ; $ request_token [ 'oauth_token_secret' ] = $ this -> request_token [ 'oauth_token_secret' ] ; $ this -> logQ ( 'session token ' . print_r ( $ request_token , true ) , 'twitter' ) ; $ this -> logQ ( 'extra options ' . print_r ( $ extrainputs , true ) , 'twitter' ) ; if ( isset ( $ extrainputs [ 'oauth_token' ] ) && $ request_token [ 'oauth_token' ] !== $ extrainputs [ 'oauth_token' ] ) { throw new \ Exception ( 'Twitter oauth. Somethign went wrong. No token in the session' ) ; } $ connection = new TwitterOAuth ( $ this -> options [ 'consumer_key' ] , $ this -> options [ 'consumer_secret' ] , $ request_token [ 'oauth_token' ] , $ request_token [ 'oauth_token_secret' ] ) ; $ connection -> setTimeouts ( 10 , 15 ) ; $ access_token = $ connection -> oauth ( "oauth/access_token" , array ( "oauth_verifier" => $ extrainputs [ 'oauth_verifier' ] ) ) ; $ this -> access_token = $ access_token ; return $ this -> getUserProfile ( ) ; }
8320	public function getCaptchaResultBulk ( array $ captchaIds ) { $ response = $ this -> getHttpClient ( ) -> request ( 'GET' , '/res.php?' . http_build_query ( [ 'key' => $ this -> apiKey , 'action' => 'get' , 'ids' => join ( ',' , $ captchaIds ) ] ) ) ; $ captchaTexts = $ response -> getBody ( ) -> __toString ( ) ; $ this -> getLogger ( ) -> info ( "Got bulk response: `{$captchaTexts}`." ) ; $ captchaTexts = explode ( "|" , $ captchaTexts ) ; $ result = [ ] ; foreach ( $ captchaTexts as $ index => $ captchaText ) { $ captchaText = html_entity_decode ( trim ( $ captchaText ) ) ; $ result [ $ captchaIds [ $ index ] ] = ( $ captchaText == self :: STATUS_CAPTCHA_NOT_READY ) ? false : $ captchaText ; } return $ result ; }
10697	public function send ( ResponseInterface $ response ) : ResponseInterface { $ response -> getBody ( ) -> write ( json_encode ( $ this -> toArray ( ) ) ) ; return $ response -> withHeader ( 'Content-Type' , self :: MIME_TYPE_JSON ) ; }
10355	public function incrementAttempts ( ) { $ this -> cache -> add ( $ this -> key , 0 , $ this -> getExpiry ( ) ) ; $ this -> cache -> increment ( $ this -> key ) ; }
8078	protected function buildUri ( $ endpoint , $ options = [ ] ) { if ( $ this -> token !== '' ) { $ options [ 'auth' ] = $ this -> token ; } return $ this -> base . '/' . ltrim ( $ endpoint , '/' ) . '.json?' . http_build_query ( $ options , '' , '&' ) ; }
12913	public function cache ( $ flag , $ expiry = null ) { $ this -> cache = ( boolean ) $ flag ; if ( ! is_null ( $ expiry ) ) { $ this -> cacheExpiry = $ expiry ; } return $ this ; }
9193	public function init ( ) { if ( $ this -> isInitialized ( ) ) return $ this ; if ( ! $ this -> getThemesPath ( ) || ! $ this -> getName ( ) ) throw new \ Exception ( 'Theme Cant initialize because theme name or theme paths not present.' ) ; $ themePathname = $ this -> getThemesPath ( ) . DS . $ this -> getName ( ) ; if ( ! is_dir ( $ themePathname ) ) throw new \ Exception ( sprintf ( 'Theme "%s" not found in "%s".' , $ this -> getName ( ) , $ themePathname ) ) ; $ bootstrap = $ themePathname . DS . 'theme.bootstrap.php' ; if ( file_exists ( $ bootstrap ) ) { ob_start ( ) ; set_error_handler ( function ( $ errno , $ errstr ) { throw new \ ErrorException ( $ errstr , $ errno ) ; } , E_ALL ) ; include $ bootstrap ; restore_error_handler ( ) ; ob_get_clean ( ) ; } $ this -> initialized = true ; return $ this ; }
3519	public function getWebUITranslations ( ) { $ TITLE_SAVE_CHANGES = $ this -> get ( $ this -> package . '::messages.title-save-changes' ) ; $ TITLE_CANCEL_CHANGES = $ this -> get ( $ this -> package . '::messages.title-cancel-changes' ) ; $ TITLE_TRANSLATE = $ this -> get ( $ this -> package . '::messages.title-translate' ) ; $ TITLE_CONVERT_KEY = $ this -> get ( $ this -> package . '::messages.title-convert-key' ) ; $ TITLE_GENERATE_PLURALS = $ this -> get ( $ this -> package . '::messages.title-generate-plurals' ) ; $ TITLE_CLEAN_HTML_MARKDOWN = $ this -> get ( $ this -> package . '::messages.title-clean-html-markdown' ) ; $ TITLE_CAPITALIZE = $ this -> get ( $ this -> package . '::messages.title-capitalize' ) ; $ TITLE_LOWERCASE = $ this -> get ( $ this -> package . '::messages.title-lowercase' ) ; $ TITLE_CAPITALIZE_FIRST_WORD = $ this -> get ( $ this -> package . '::messages.title-capitalize-first-word' ) ; $ TITLE_SIMULATED_COPY = $ this -> get ( $ this -> package . '::messages.title-simulated-copy' ) ; $ TITLE_SIMULATED_PASTE = $ this -> get ( $ this -> package . '::messages.title-simulated-paste' ) ; $ TITLE_RESET_EDITOR = $ this -> get ( $ this -> package . '::messages.title-reset-editor' ) ; $ TITLE_LOAD_LAST = $ this -> get ( $ this -> package . '::messages.title-load-last' ) ; return <<<HTML<script>var TITLE_SAVE_CHANGES = "$TITLE_SAVE_CHANGES";var TITLE_CANCEL_CHANGES = "$TITLE_CANCEL_CHANGES";var TITLE_TRANSLATE = "$TITLE_TRANSLATE";var TITLE_CONVERT_KEY = "$TITLE_CONVERT_KEY";var TITLE_GENERATE_PLURALS = "$TITLE_GENERATE_PLURALS";var TITLE_CLEAN_HTML_MARKDOWN = "$TITLE_CLEAN_HTML_MARKDOWN";var TITLE_CAPITALIZE = "$TITLE_CAPITALIZE";var TITLE_LOWERCASE = "$TITLE_LOWERCASE";var TITLE_CAPITALIZE_FIRST_WORD = "$TITLE_CAPITALIZE_FIRST_WORD";var TITLE_SIMULATED_COPY = "$TITLE_SIMULATED_COPY";var TITLE_SIMULATED_PASTE = "$TITLE_SIMULATED_PASTE";var TITLE_RESET_EDITOR = "$TITLE_RESET_EDITOR";var TITLE_LOAD_LAST = "$TITLE_LOAD_LAST";</script>HTML ; }
5991	public function setDeploymentDateRange ( $ deploymentDateRange ) { if ( $ deploymentDateRange instanceof DateTimeRange ) { $ this -> deploymentDateRange = $ deploymentDateRange ; } elseif ( is_array ( $ deploymentDateRange ) ) { $ this -> deploymentDateRange = new DateTimeRange ( $ deploymentDateRange ) ; } else { $ this -> deploymentDateRange = null ; trigger_error ( 'Argument must be an object of class DateTimeRange. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
4052	private function fetchPropertiesFor ( $ inputScreenId , IMetaModel $ metaModel ) : array { $ builder = $ this -> connection -> createQueryBuilder ( ) ; return array_map ( function ( $ column ) use ( $ inputScreenId , $ metaModel ) { if ( 'attribute' !== $ column [ 'dcatype' ] ) { return $ column ; } if ( ! ( $ attribute = $ metaModel -> getAttributeById ( $ column [ 'attr_id' ] ) ) ) { @ trigger_error ( 'Unknown attribute "' . $ column [ 'attr_id' ] . '" in input screen "' . $ inputScreenId . '"' , E_USER_WARNING ) ; return $ column ; } $ column = array_merge ( $ column , $ attribute -> getFieldDefinition ( $ column ) , [ 'col_name' => $ attribute -> getColName ( ) ] ) ; return $ column ; } , $ builder -> select ( '*' ) -> from ( 'tl_metamodel_dcasetting' ) -> where ( 'pid=:pid' ) -> andWhere ( 'published=:published' ) -> setParameter ( 'pid' , $ inputScreenId ) -> setParameter ( 'published' , 1 ) -> orderBy ( 'sorting' ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ) ; }
5029	public function findForView ( $ id ) { $ type = $ this -> doctrine -> getConnection ( ) -> fetchColumn ( 'SELECT type FROM page WHERE id=:id' , array ( 'id' => $ id ) ) ; if ( ! $ type ) { throw new NotFoundHttpException ; } $ types = $ this -> em -> getClassMetadata ( $ this -> pageClassName ) -> discriminatorMap ; $ class = $ types [ $ type ] ; $ repos = $ this -> em -> getRepository ( $ class ) ; if ( $ repos instanceof ViewablePageRepository ) { $ ret = $ repos -> findForView ( $ id ) ; } else { $ ret = $ repos -> find ( $ id ) ; } if ( ! $ ret ) { throw new NotFoundHttpException ; } $ this -> setLoadedPage ( $ ret ) ; return $ ret ; }
2717	public function render ( AbstractElement $ element ) { $ element -> unsScope ( ) -> unsCanUseWebsiteValue ( ) -> unsCanUseDefaultValue ( ) ; return parent :: render ( $ element ) ; }
12766	public function run ( ) : void { $ this -> isRan = true ; foreach ( $ this -> getAll ( ) as $ header ) { header ( $ header ) ; } }
2210	public function fetchAssoc ( ) { if ( $ this -> intIndex >= $ this -> count ( ) - 1 ) { return false ; } $ this -> arrCache = $ this -> resultSet [ ++ $ this -> intIndex ] ; return $ this -> arrCache ; }
11629	private function createOperation ( $ trans , $ dsBegin ) { $ datePerformed = $ this -> hlpDate -> getUtcNowForDb ( ) ; $ req = new \ Praxigento \ Accounting \ Api \ Service \ Operation \ Create \ Request ( ) ; $ req -> setOperationTypeCode ( Cfg :: CODE_TYPE_OPER_PV_WRITE_OFF ) ; $ req -> setDatePerformed ( $ datePerformed ) ; $ req -> setTransactions ( $ trans ) ; $ period = substr ( $ dsBegin , 0 , 6 ) ; $ note = "PV Write Off ($period)" ; $ req -> setOperationNote ( $ note ) ; $ resp = $ this -> servOperation -> exec ( $ req ) ; $ result = $ resp -> getOperationId ( ) ; return $ result ; }
758	protected function renderImageByImagick ( $ code ) { $ backColor = $ this -> transparent ? new \ ImagickPixel ( 'transparent' ) : new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> backColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ foreColor = new \ ImagickPixel ( '#' . str_pad ( dechex ( $ this -> foreColor ) , 6 , 0 , STR_PAD_LEFT ) ) ; $ image = new \ Imagick ( ) ; $ image -> newImage ( $ this -> width , $ this -> height , $ backColor ) ; $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( 30 ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code ) ; $ length = strlen ( $ code ) ; $ w = ( int ) $ fontMetrics [ 'textWidth' ] - 8 + $ this -> offset * ( $ length - 1 ) ; $ h = ( int ) $ fontMetrics [ 'textHeight' ] - 8 ; $ scale = min ( ( $ this -> width - $ this -> padding * 2 ) / $ w , ( $ this -> height - $ this -> padding * 2 ) / $ h ) ; $ x = 10 ; $ y = round ( $ this -> height * 27 / 40 ) ; for ( $ i = 0 ; $ i < $ length ; ++ $ i ) { $ draw = new \ ImagickDraw ( ) ; $ draw -> setFont ( $ this -> fontFile ) ; $ draw -> setFontSize ( ( int ) ( mt_rand ( 26 , 32 ) * $ scale * 0.8 ) ) ; $ draw -> setFillColor ( $ foreColor ) ; $ image -> annotateImage ( $ draw , $ x , $ y , mt_rand ( - 10 , 10 ) , $ code [ $ i ] ) ; $ fontMetrics = $ image -> queryFontMetrics ( $ draw , $ code [ $ i ] ) ; $ x += ( int ) $ fontMetrics [ 'textWidth' ] + $ this -> offset ; } $ image -> setImageFormat ( 'png' ) ; return $ image -> getImageBlob ( ) ; }
7438	public static function handleException ( \ Throwable $ e ) { self :: render ( $ e -> getCode ( ) , $ e -> getMessage ( ) , $ e -> getFile ( ) , $ e -> getLine ( ) , null , $ e -> getTrace ( ) , get_class ( $ e ) ) ; }
8381	public function execute ( ) { if ( $ this -> statement == null ) { $ this -> statement = Database :: get ( $ this -> database ) -> { ( $ this -> isCritical === true ? 'getMasterLink' : 'getLink' ) } ( ) -> prepare ( $ this -> toSql ( ) ) ; } foreach ( $ this -> parameters as $ name => $ value ) { $ type = \ PDO :: PARAM_STR ; if ( is_int ( $ value ) === true ) { $ type = \ PDO :: PARAM_INT ; } elseif ( is_bool ( $ value ) === true ) { $ type = \ PDO :: PARAM_BOOL ; } elseif ( is_null ( $ value ) === true ) { $ type = \ PDO :: PARAM_NULL ; } $ this -> statement -> bindValue ( $ name , $ value , $ type ) ; } $ result = $ this -> statement -> execute ( ) ; $ this -> errorInfo = $ this -> statement -> errorInfo ( ) ; if ( $ this -> getErrorState ( ) != '00000' ) { Logger :: get ( ) -> error ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; if ( constant ( 'STRAY_ENV' ) === 'development' ) { throw new AppException ( 'select query failed : ' . $ this -> getErrorMessage ( ) . ' (' . $ this -> toSql ( ) . ')' ) ; } } return $ result ; }
8685	public static function set ( & $ data , $ path , $ value ) { Assert :: isArrayAccessible ( $ data ) ; Assert :: stringNotEmpty ( $ path ) ; $ queue = explode ( '/' , $ path ) ; if ( count ( $ queue ) === 1 ) { if ( $ path === '[]' ) { $ data [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ data [ $ path ] ) ; } else { $ data [ $ path ] = $ value ; } return ; } $ invalidKey = null ; $ current = & $ data ; while ( ( $ key = array_shift ( $ queue ) ) !== null ) { if ( ! is_array ( $ current ) && ! ( $ current instanceof ArrayAccess ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is already set and not an array or an object implementing ArrayAccess." , $ path , $ invalidKey ) ) ; } if ( ! $ queue ) { if ( $ key === '[]' ) { $ current [ ] = $ value ; } elseif ( static :: $ unsetMarker && $ value === static :: $ unsetMarker ) { unset ( $ current [ $ key ] ) ; } else { $ current [ $ key ] = $ value ; } return ; } if ( $ current instanceof Bag && ! ( $ current instanceof MutableBag ) ) { Deprecated :: warn ( 'Mutating items in a ' . Bag :: class , 1.1 , 'Use a ' . MutableBag :: class . ' instead.' ) ; } if ( ! isset ( $ current [ $ key ] ) ) { $ current [ $ key ] = [ ] ; } $ next = null ; if ( $ current instanceof ArrayAccess && ! static :: canReturnArraysByReference ( $ current , $ key , $ next , $ e ) ) { throw new RuntimeException ( sprintf ( "Cannot set '%s', because '%s' is an %s which does not return arrays by reference from its offsetGet() method. See %s for an example of how to do this." , $ path , $ invalidKey , get_class ( $ current ) , MutableBag :: class ) , 0 , $ e ) ; } if ( $ next !== null ) { $ current = & $ next ; unset ( $ next ) ; } else { $ current = & $ current [ $ key ] ; } $ invalidKey = $ key ; } }
9991	private function writeChartInCell ( Worksheet $ pSheet , $ coordinates ) { $ html = '' ; foreach ( $ pSheet -> getChartCollection ( ) as $ chart ) { if ( $ chart instanceof Chart ) { $ chartCoordinates = $ chart -> getTopLeftPosition ( ) ; if ( $ chartCoordinates [ 'cell' ] == $ coordinates ) { $ chartFileName = File :: sysGetTempDir ( ) . '/' . uniqid ( '' , true ) . '.png' ; if ( ! $ chart -> render ( $ chartFileName ) ) { return ; } $ html .= PHP_EOL ; $ imageDetails = getimagesize ( $ chartFileName ) ; if ( $ fp = fopen ( $ chartFileName , 'rb' , 0 ) ) { $ picture = fread ( $ fp , filesize ( $ chartFileName ) ) ; fclose ( $ fp ) ; $ base64 = chunk_split ( base64_encode ( $ picture ) ) ; $ imageData = 'data:' . $ imageDetails [ 'mime' ] . ';base64,' . $ base64 ; $ html .= '<div style="position: relative;">' ; $ html .= '<img style="position: absolute; z-index: 1; left: ' . $ chartCoordinates [ 'xOffset' ] . 'px; top: ' . $ chartCoordinates [ 'yOffset' ] . 'px; width: ' . $ imageDetails [ 0 ] . 'px; height: ' . $ imageDetails [ 1 ] . 'px;" src="' . $ imageData . '" border="0" />' . PHP_EOL ; $ html .= '</div>' ; unlink ( $ chartFileName ) ; } } } } return $ html ; }
2193	protected function sendActivationMail ( $ arrData ) { $ optIn = System :: getContainer ( ) -> get ( 'contao.opt-in' ) ; $ optInToken = $ optIn -> create ( 'reg' , $ arrData [ 'email' ] , array ( 'tl_member' => array ( $ arrData [ 'id' ] ) ) ) ; $ arrTokenData = $ arrData ; $ arrTokenData [ 'activation' ] = $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'domain' ] = Idna :: decode ( Environment :: get ( 'host' ) ) ; $ arrTokenData [ 'link' ] = Idna :: decode ( Environment :: get ( 'base' ) ) . Environment :: get ( 'request' ) . ( ( strpos ( Environment :: get ( 'request' ) , '?' ) !== false ) ? '&' : '?' ) . 'token=' . $ optInToken -> getIdentifier ( ) ; $ arrTokenData [ 'channels' ] = '' ; $ bundles = System :: getContainer ( ) -> getParameter ( 'kernel.bundles' ) ; if ( isset ( $ bundles [ 'ContaoNewsletterBundle' ] ) ) { if ( ! \ is_array ( $ arrData [ 'newsletter' ] ) ) { if ( $ arrData [ 'newsletter' ] != '' ) { $ arrData [ 'newsletter' ] = array ( $ arrData [ 'newsletter' ] ) ; } else { $ arrData [ 'newsletter' ] = array ( ) ; } } if ( ! empty ( $ arrData [ 'newsletter' ] ) ) { $ objChannels = NewsletterChannelModel :: findByIds ( $ arrData [ 'newsletter' ] ) ; if ( $ objChannels !== null ) { $ arrTokenData [ 'channels' ] = implode ( "\n" , $ objChannels -> fetchEach ( 'title' ) ) ; } } } $ arrTokenData [ 'channel' ] = $ arrTokenData [ 'channels' ] ; $ optInToken -> send ( sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'emailSubject' ] , Idna :: decode ( Environment :: get ( 'host' ) ) ) , StringUtil :: parseSimpleTokens ( $ this -> reg_text , $ arrTokenData ) ) ; }
6265	public function resolve ( ResponseInterface $ response ) { if ( HttpPromise :: PENDING !== $ this -> state ) { throw new \ RuntimeException ( 'Promise is already resolved' ) ; } $ this -> state = HttpPromise :: FULFILLED ; $ this -> response = $ response ; $ this -> doResolve ( $ response ) ; }
3024	public function getBlogPosts ( $ blogName , $ options = null ) { $ path = $ this -> blogPath ( $ blogName , '/posts' ) ; if ( $ options && isset ( $ options [ 'type' ] ) ) { $ path .= '/' . $ options [ 'type' ] ; unset ( $ options [ 'type' ] ) ; } return $ this -> getRequest ( $ path , $ options , true ) ; }
225	protected function asPercentStringFallback ( $ value , $ decimals = null ) { if ( empty ( $ value ) ) { $ value = 0 ; } if ( $ decimals === null ) { $ decimals = 0 ; } $ value = $ this -> normalizeNumericStringValue ( ( string ) $ value ) ; $ separatorPosition = strrpos ( $ value , '.' ) ; if ( $ separatorPosition !== false ) { $ integerPart = substr ( $ value , 0 , $ separatorPosition ) ; $ fractionalPart = str_pad ( substr ( $ value , $ separatorPosition + 1 ) , 2 , '0' ) ; $ integerPart .= substr ( $ fractionalPart , 0 , 2 ) ; $ fractionalPart = substr ( $ fractionalPart , 2 ) ; if ( $ fractionalPart === '' ) { $ multipliedValue = $ integerPart ; } else { $ multipliedValue = $ integerPart . '.' . $ fractionalPart ; } } else { $ multipliedValue = $ value . '00' ; } return $ this -> asDecimalStringFallback ( $ multipliedValue , $ decimals ) . '%' ; }
8811	public function header ( $ key , $ value ) { if ( is_array ( $ key ) && ! empty ( $ key ) ) { foreach ( $ key as $ k => $ v ) { $ this -> headers -> set ( $ k , $ v ) ; } } elseif ( is_string ( $ key ) && ! empty ( $ key ) ) { $ this -> headers -> set ( $ key , $ value ) ; } return $ this ; }
5972	public function deployment ( ) { if ( ! $ this -> deployment instanceof DeploymentController ) { $ this -> deployment = new DeploymentController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> deployment -> setLogger ( $ this -> logger ) ; } return $ this -> deployment ; }
6708	protected function getReaderFactory ( ) { if ( ! $ this -> readerFactory ) { $ this -> readerFactory = new ReaderFactory ( [ new Json ( ) , new Xml ( ) , ] ) ; } return $ this -> readerFactory ; }
11496	public static function end ( ) { if ( self :: $ startTime ) { $ time = round ( ( microtime ( true ) - self :: $ startTime ) , 4 ) ; self :: $ startTime = false ; } return ( isset ( $ time ) ) ? $ time : false ; }
8533	public function setDebtRecoveryItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'DebtRecoveryItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
12465	private function getOptionsAvailable ( $ entity ) { $ options = $ this -> getParameter ( 'chill_custom_fields.' . 'customizables_entities' ) ; foreach ( $ options as $ key => $ definition ) { if ( $ definition [ 'class' ] == $ entity ) { foreach ( $ definition [ 'options' ] as $ key => $ value ) { yield $ key ; } } } }
10907	public static function get ( array $ server ) : array { $ params = [ ] ; if ( isset ( $ server [ 'QUERY_STRING' ] ) ) { $ query = ltrim ( $ server [ 'QUERY_STRING' ] , '?' ) ; foreach ( explode ( '&' , $ query ) as $ pair ) { if ( $ pair ) { list ( $ name , $ value ) = self :: normalize ( array_map ( 'urldecode' , explode ( '=' , $ pair , 2 ) ) ) ; $ params [ $ name ] [ ] = $ value ; } } } return $ params ? array_map ( function ( $ v ) { return count ( $ v ) === 1 ? $ v [ 0 ] : $ v ; } , $ params ) : $ params ; }
4349	private function normalizeArray ( $ cfg ) { $ return = array ( 'debug' => array ( ) , ) ; $ configKeys = $ this -> getConfigKeys ( ) ; foreach ( $ cfg as $ k => $ v ) { $ translated = false ; foreach ( $ configKeys as $ objName => $ objKeys ) { if ( $ k == $ objName && \ is_array ( $ v ) ) { $ return [ $ objName ] = isset ( $ return [ $ objName ] ) ? \ array_merge ( $ return [ $ objName ] , $ v ) : $ v ; $ translated = true ; break ; } elseif ( \ is_array ( $ v ) && isset ( $ configKeys [ $ k ] ) ) { continue ; } elseif ( \ in_array ( $ k , $ objKeys ) ) { $ return [ $ objName ] [ $ k ] = $ v ; $ translated = true ; break ; } } if ( ! $ translated ) { $ return [ 'debug' ] [ $ k ] = $ v ; } } if ( ! $ return [ 'debug' ] ) { unset ( $ return [ 'debug' ] ) ; } return $ return ; }
9205	public function init ( ) { $ path = $ this -> absolutePath ( $ this -> getFile ( ) ) ; $ this -> quiet ( 'Initializing seed file: ' . $ this -> shortPath ( $ path ) ) ; $ this -> existsOrCreate ( $ path ) ; }
8914	public function decode ( $ value , $ b = 62 ) { $ limit = strlen ( $ value ) ; $ result = strpos ( $ this -> base , $ value [ 0 ] ) ; for ( $ i = 1 ; $ i < $ limit ; $ i ++ ) { $ result = $ b * $ result + strpos ( $ this -> base , $ value [ $ i ] ) ; } return $ result ; }
1468	public static function wantsJsonApi ( $ request ) { $ acceptable = $ request -> getAcceptableContentTypes ( ) ; return isset ( $ acceptable [ 0 ] ) && IlluminateStr :: contains ( $ acceptable [ 0 ] , MediaType :: JSON_API_SUB_TYPE ) ; }
2202	public static function stripTags ( $ varValue , $ strAllowedTags = '' ) { if ( $ varValue === null || $ varValue == '' ) { return $ varValue ; } if ( \ is_array ( $ varValue ) ) { foreach ( $ varValue as $ k => $ v ) { $ varValue [ $ k ] = static :: stripTags ( $ v , $ strAllowedTags ) ; } return $ varValue ; } $ varValue = preg_replace_callback ( '@</?([^\s<>/]*)@' , function ( $ matches ) use ( $ strAllowedTags ) { if ( $ matches [ 1 ] == '' || stripos ( $ strAllowedTags , '<' . strtolower ( $ matches [ 1 ] ) . '>' ) === false ) { $ matches [ 0 ] = str_replace ( '<' , '&lt;' , $ matches [ 0 ] ) ; } return $ matches [ 0 ] ; } , $ varValue ) ; $ varValue = strip_tags ( $ varValue , $ strAllowedTags ) ; $ varValue = str_replace ( array ( '&lt;!--' , '&lt;![' ) , array ( '<!--' , '<![' ) , $ varValue ) ; while ( strpos ( $ varValue , '\\0' ) !== false ) { $ varValue = str_replace ( '\\0' , '' , $ varValue ) ; } return $ varValue ; }
384	protected function validateImage ( $ image ) { if ( false === ( $ imageInfo = getimagesize ( $ image -> tempName ) ) ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } list ( $ width , $ height ) = $ imageInfo ; if ( $ width == 0 || $ height == 0 ) { return [ $ this -> notImage , [ 'file' => $ image -> name ] ] ; } if ( $ this -> minWidth !== null && $ width < $ this -> minWidth ) { return [ $ this -> underWidth , [ 'file' => $ image -> name , 'limit' => $ this -> minWidth ] ] ; } if ( $ this -> minHeight !== null && $ height < $ this -> minHeight ) { return [ $ this -> underHeight , [ 'file' => $ image -> name , 'limit' => $ this -> minHeight ] ] ; } if ( $ this -> maxWidth !== null && $ width > $ this -> maxWidth ) { return [ $ this -> overWidth , [ 'file' => $ image -> name , 'limit' => $ this -> maxWidth ] ] ; } if ( $ this -> maxHeight !== null && $ height > $ this -> maxHeight ) { return [ $ this -> overHeight , [ 'file' => $ image -> name , 'limit' => $ this -> maxHeight ] ] ; } return null ; }
1795	private function addFrontendRoute ( RouteCollection $ routes , array $ defaults ) : void { $ route = new Route ( '/{alias}' . $ this -> urlSuffix , $ defaults , [ 'alias' => '.+' ] ) ; $ this -> addLocaleToRoute ( $ route ) ; $ routes -> add ( 'contao_frontend' , $ route ) ; }
237	protected function setTableMetadata ( $ name , $ type , $ data ) { $ this -> _tableMetadata [ $ this -> getRawTableName ( $ name ) ] [ $ type ] = $ data ; }
5971	public function categories ( ) { if ( ! $ this -> categories instanceof CategoriesController ) { $ this -> categories = new CategoriesController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> categories -> setLogger ( $ this -> logger ) ; } return $ this -> categories ; }
3246	public function onCallbackFail ( $ order , $ data = null ) { $ this -> statusCode = 'failed' ; $ this -> detail = 'failed callback' ; $ this -> didCallback = true ; }
10079	public static function strCaseReverse ( $ pValue ) { $ characters = self :: mbStrSplit ( $ pValue ) ; foreach ( $ characters as & $ character ) { if ( self :: mbIsUpper ( $ character ) ) { $ character = mb_strtolower ( $ character , 'UTF-8' ) ; } else { $ character = mb_strtoupper ( $ character , 'UTF-8' ) ; } } return implode ( '' , $ characters ) ; }
2300	public static function getSystemMessages ( ) { $ strMessages = '' ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] ) ) { $ arrMessages = array ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getSystemMessages' ] as $ callback ) { $ strBuffer = System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( ) ; if ( $ strBuffer != '' ) { $ arrMessages [ ] = $ strBuffer ; } } if ( ! empty ( $ arrMessages ) ) { $ strMessages .= implode ( "\n" , $ arrMessages ) ; } } return $ strMessages ; }
12528	public function getLocalDataSource ( $ localModelClass ) { foreach ( $ this -> dataSources as $ dataSource ) { if ( $ dataSource -> localModel === $ localModelClass ) { return $ dataSource ; } } return false ; }
2889	public function onCollectionLoad ( Varien_Event_Observer $ observer ) { if ( ! $ this -> canCollect ( ) ) { return ; } $ collection = $ observer -> getData ( 'collection' ) ; $ this -> getRequestInfo ( ) -> addCollection ( $ collection ) ; }
3674	private function extractPostData ( FilterUrl $ filterUrl , $ options , Request $ request ) : void { if ( empty ( $ options [ 'postAsSlug' ] ) && empty ( $ options [ 'postAsGet' ] ) ) { return ; } foreach ( $ request -> request -> all ( ) as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsSlug' ] ) ) { $ filterUrl -> setSlug ( $ name , $ value ) ; } if ( in_array ( $ name , $ options [ 'postAsGet' ] ) ) { $ filterUrl -> setGet ( $ name , $ value ) ; } } }
5860	public function getAllFileTypes ( ) { $ fileTypes = [ ] ; foreach ( $ this -> rulesets as $ ruleset ) { if ( is_array ( $ ruleset [ 'file_types' ] ) ) { $ fileTypes = array_merge ( $ fileTypes , $ ruleset [ 'file_types' ] ) ; } } $ fileTypes = array_unique ( $ fileTypes ) ; return $ fileTypes ; }
1303	public function get ( string $ path , array $ headers = [ ] , $ cache = true ) : Response { if ( null === $ this -> endpoint ) { return new Response ( [ ] ) ; } $ headers [ ] = 'Package-Session: ' . $ this -> sess ; $ url = $ this -> endpoint . '/' . ltrim ( $ path , '/' ) ; $ cacheKey = $ cache ? ltrim ( $ path , '/' ) : '' ; if ( $ cacheKey && $ contents = $ this -> cache -> read ( $ cacheKey ) ) { $ cachedResponse = Response :: fromJson ( json_decode ( $ contents , true ) ) ; if ( $ lastModified = $ cachedResponse -> getHeader ( 'last-modified' ) ) { $ response = $ this -> fetchFileIfLastModified ( $ url , $ cacheKey , $ lastModified , $ headers ) ; if ( 304 === $ response -> getStatusCode ( ) ) { $ response = new Response ( $ cachedResponse -> getBody ( ) , $ response -> getOrigHeaders ( ) , 304 ) ; } return $ response ; } } return $ this -> fetchFile ( $ url , $ cacheKey , $ headers ) ; }
9597	protected function flashMessages ( $ messages ) { $ flashBag = $ this -> getSession ( ) -> getFlashBag ( ) ; foreach ( ( array ) $ messages as $ message ) { $ flashBag -> add ( '_messages' , $ message ) ; } }
4478	public function getInstance ( ) { if ( $ this -> instance === null ) { $ this -> instance = $ this -> jobFactory -> create ( $ this -> klass , $ this -> getPerformMethod ( ) ) ; } return $ this -> instance ; }
11416	private function saveLog ( $ operId , $ calcId ) { $ entity = new ELogOper ( ) ; $ entity -> setOperId ( $ operId ) ; $ entity -> setCalcId ( $ calcId ) ; $ this -> daoLogOper -> create ( $ entity ) ; }
10585	public static function createFile ( string $ name , int $ maxAttempts = 10 ) : entity \ FileEntity { $ tmpdir = static :: getDir ( ) ; $ name = \ sndsgd \ Fs :: sanitizeName ( $ name ) ; $ pos = strrpos ( $ name , "." ) ; if ( $ pos === false ) { $ extension = "" ; } else { $ extension = substr ( $ name , $ pos ) ; $ name = substr ( $ name , 0 , $ pos ) ; } $ attempts = 1 ; do { if ( $ attempts > $ maxAttempts ) { throw new \ RuntimeException ( "failed to create temp file; " . "reached max number ($maxAttempts) of attempts" ) ; } $ rand = \ sndsgd \ Str :: random ( 10 ) ; $ path = "$tmpdir/$name-$rand$extension" ; $ attempts ++ ; } while ( file_exists ( $ path ) ) ; touch ( $ path ) ; $ file = new entity \ FileEntity ( $ path ) ; static :: registerEntity ( $ file ) ; return $ file ; }
2460	protected function paginationMenu ( ) { $ objSessionBag = System :: getContainer ( ) -> get ( 'session' ) -> getBag ( 'contao_backend' ) ; $ session = $ objSessionBag -> all ( ) ; $ filter = ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'list' ] [ 'sorting' ] [ 'mode' ] == 4 ) ? $ this -> strTable . '_' . CURRENT_ID : $ this -> strTable ; list ( $ offset , $ limit ) = explode ( ',' , $ this -> limit ) ; if ( isset ( $ _GET [ 'lp' ] ) ) { $ lp = ( int ) Input :: get ( 'lp' ) - 1 ; if ( $ lp >= 0 && $ lp < ceil ( $ this -> total / $ limit ) ) { $ session [ 'filter' ] [ $ filter ] [ 'limit' ] = ( $ lp * $ limit ) . ',' . $ limit ; $ objSessionBag -> replace ( $ session ) ; } $ this -> redirect ( preg_replace ( '/&(amp;)?lp=[^&]+/i' , '' , Environment :: get ( 'request' ) ) ) ; } if ( $ limit ) { Input :: setGet ( 'lp' , $ offset / $ limit + 1 ) ; } $ objPagination = new Pagination ( $ this -> total , $ limit , 7 , 'lp' , new BackendTemplate ( 'be_pagination' ) , true ) ; return $ objPagination -> generate ( ) ; }
3959	public function parseValue ( $ strOutputFormat = 'text' , $ objSettings = null ) { $ this -> registerAssets ( $ objSettings ) ; $ arrResult = [ 'raw' => $ this -> arrData , 'text' => [ ] , 'attributes' => [ ] , $ strOutputFormat => [ ] , 'class' => '' , 'actions' => [ ] ] ; if ( ! $ objSettings ) { foreach ( $ this -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , null ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } return $ arrResult ; } $ jumpTo = $ this -> buildJumpToLink ( $ objSettings ) ; if ( true === $ jumpTo [ 'deep' ] ) { $ arrResult [ 'actions' ] [ 'jumpTo' ] = [ 'href' => $ jumpTo [ 'url' ] , 'label' => $ this -> getCaptionText ( 'details' ) , 'class' => 'details' ] ; } $ arrResult [ 'jumpTo' ] = $ jumpTo ; foreach ( $ objSettings -> getSettingNames ( ) as $ strAttrName ) { $ objAttribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strAttrName ) ; if ( $ objAttribute ) { $ arrResult [ 'attributes' ] [ $ objAttribute -> getColName ( ) ] = $ objAttribute -> getName ( ) ; foreach ( $ this -> internalParseAttribute ( $ objAttribute , $ strOutputFormat , $ objSettings ) as $ strKey => $ varValue ) { $ arrResult [ $ strKey ] [ $ objAttribute -> getColName ( ) ] = $ varValue ; } } } if ( $ this -> getMetaModel ( ) -> hasVariants ( ) ) { $ arrResult [ 'class' ] = $ this -> variantCssClass ( ) ; } $ event = new ParseItemEvent ( $ objSettings , $ this , $ strOutputFormat , $ arrResult ) ; $ this -> getEventDispatcher ( ) -> dispatch ( MetaModelsEvents :: PARSE_ITEM , $ event ) ; return $ event -> getResult ( ) ; }
7661	function SetWordWrap ( ) { if ( $ this -> WordWrap < 1 ) return ; switch ( $ this -> message_type ) { case "alt" : case "alt_attachments" : $ this -> AltBody = $ this -> WrapText ( $ this -> AltBody , $ this -> WordWrap ) ; break ; default : $ this -> Body = $ this -> WrapText ( $ this -> Body , $ this -> WordWrap ) ; break ; } }
8077	public function delete ( $ endpoint , $ query = [ ] ) { $ endpoint = $ this -> buildUri ( $ endpoint , $ query ) ; $ headers = $ this -> buildHeaders ( ) ; $ this -> response = $ this -> client -> delete ( $ endpoint , $ headers ) ; return $ this -> response ; }
580	public static function current ( array $ params = [ ] , $ scheme = false ) { $ currentParams = Yii :: $ app -> getRequest ( ) -> getQueryParams ( ) ; $ currentParams [ 0 ] = '/' . Yii :: $ app -> controller -> getRoute ( ) ; $ route = array_replace_recursive ( $ currentParams , $ params ) ; return static :: toRoute ( $ route , $ scheme ) ; }
11054	public static function printts ( $ datatree , $ containers , $ entry = 'main' ) { $ this -> printt ( $ datatree , $ containers , $ entry , _ETS_STRING_READ , '' , '' ) ; }
3513	public function getPublish ( $ group ) { if ( $ group && $ group != '*' ) { $ this -> manager -> exportTranslations ( $ group ) ; } else { $ this -> manager -> exportAllTranslations ( ) ; } $ errors = $ this -> manager -> errors ( ) ; event ( new TranslationsPublished ( $ group , $ errors ) ) ; return Response :: json ( array ( 'status' => $ errors ? 'errors' : 'ok' , 'errors' => $ errors ) ) ; }
2298	public static function findSearchablePages ( $ pid = 0 , $ domain = '' , $ blnIsSitemap = false ) { $ objPages = PageModel :: findPublishedByPid ( $ pid , array ( 'ignoreFePreview' => true ) ) ; if ( $ objPages === null ) { return array ( ) ; } $ arrPages = array ( ) ; foreach ( $ objPages as $ objPage ) { if ( $ objPage -> type == 'regular' ) { if ( ( ! $ objPage -> noSearch || $ blnIsSitemap ) && ( ! $ objPage -> protected || ( Config :: get ( 'indexProtected' ) && ( ! $ blnIsSitemap || $ objPage -> sitemap == 'map_always' ) ) ) && ( ! $ blnIsSitemap || $ objPage -> sitemap != 'map_never' ) && ! $ objPage -> requireItem ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( ) ; if ( ( $ objArticles = ArticleModel :: findPublishedWithTeaserByPid ( $ objPage -> id , array ( 'ignoreFePreview' => true ) ) ) !== null ) { foreach ( $ objArticles as $ objArticle ) { $ arrPages [ ] = $ objPage -> getAbsoluteUrl ( '/articles/' . ( $ objArticle -> alias ? : $ objArticle -> id ) ) ; } } } } if ( ( ! $ objPage -> protected || Config :: get ( 'indexProtected' ) ) && ( $ arrSubpages = static :: findSearchablePages ( $ objPage -> id , $ domain , $ blnIsSitemap ) ) ) { $ arrPages = array_merge ( $ arrPages , $ arrSubpages ) ; } } return $ arrPages ; }
562	public static function debug ( $ message , $ category = 'application' ) { if ( YII_DEBUG ) { static :: getLogger ( ) -> log ( $ message , Logger :: LEVEL_TRACE , $ category ) ; } }
2858	public function layoutUpdatesAction ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; if ( ! $ token ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { return $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; } $ layoutUpdates = $ requestProfile -> getDesign ( ) -> getLayoutUpdates ( ) ; $ this -> renderArray ( $ layoutUpdates , 'No Data' , array ( '#' , 'XML' ) ) ; }
2973	public static function wrapClosures ( & $ data , SerializerInterface $ serializer ) { if ( $ data instanceof \ Closure ) { $ reflection = new \ ReflectionFunction ( $ data ) ; if ( $ binding = $ reflection -> getClosureThis ( ) ) { self :: wrapClosures ( $ binding , $ serializer ) ; $ scope = $ reflection -> getClosureScopeClass ( ) ; $ scope = $ scope ? $ scope -> getName ( ) : 'static' ; $ data = $ data -> bindTo ( $ binding , $ scope ) ; } $ data = new SerializableClosure ( $ data , $ serializer ) ; } elseif ( is_array ( $ data ) || $ data instanceof \ stdClass || $ data instanceof \ Traversable ) { foreach ( $ data as & $ value ) { self :: wrapClosures ( $ value , $ serializer ) ; } } elseif ( is_object ( $ data ) && ! $ data instanceof \ Serializable ) { $ reflection = new \ ReflectionObject ( $ data ) ; if ( ! $ reflection -> hasMethod ( '__sleep' ) ) { foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( $ property -> isPrivate ( ) || $ property -> isProtected ( ) ) { $ property -> setAccessible ( true ) ; } $ value = $ property -> getValue ( $ data ) ; self :: wrapClosures ( $ value , $ serializer ) ; $ property -> setValue ( $ data , $ value ) ; } } } }
4598	public function generateIdentity ( Identitiable $ model , bool $ overwrite = false ) { if ( null === $ model -> getIdentity ( ) || $ overwrite ) { $ user = $ this -> tokenStorage -> getToken ( ) -> getUser ( ) ; $ model -> setIdentity ( $ user -> getIdentity ( ) -> getType ( ) ) -> setIdentityUuid ( $ user -> getIdentity ( ) -> getUuid ( ) ) ; } return $ this ; }
7015	private function format_y ( & $ str ) { if ( strstr ( $ str , '%y' ) ) $ str = str_replace ( '%y' , substr ( $ this -> year , strlen ( $ this -> year ) - 2 , 2 ) , $ str ) ; }
5746	public function getForm ( string $ csrfNameKey , string $ csrfNameValue , string $ csrfValueKey , string $ csrfValueValue , string $ action , ? string $ usernameValue = null ) { $ administratorsTableMapper = AdministratorsTableMapper :: getInstance ( ) ; $ fields = [ ] ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: USERNAME_FIELD ) , null , $ usernameValue ) ; $ fields [ ] = DatabaseTableForm :: getFieldFromDatabaseColumn ( $ administratorsTableMapper -> getColumnByName ( self :: PASSWORD_FIELD ) , null , null , 'Password' , 'password' ) ; $ fields [ ] = FormHelper :: getCsrfNameField ( $ csrfNameKey , $ csrfNameValue ) ; $ fields [ ] = FormHelper :: getCsrfValueField ( $ csrfValueKey , $ csrfValueValue ) ; $ fields [ ] = FormHelper :: getSubmitField ( ) ; return new Form ( $ fields , [ 'method' => 'post' , 'action' => $ action , 'novalidate' => 'novalidate' ] , FormHelper :: getGeneralError ( ) ) ; }
12613	private function checkOptions ( $ options ) { foreach ( $ this -> required as $ req ) { if ( ! array_key_exists ( $ req , $ options ) ) { throw new \ Exception ( '"' . $ req . '" option has not been defined' ) ; } } }
1926	public function countColors ( $ max = null ) { if ( ! imageistruecolor ( $ this -> gdResource ) ) { return imagecolorstotal ( $ this -> gdResource ) ; } $ colors = array ( ) ; $ width = imagesx ( $ this -> gdResource ) ; $ height = imagesy ( $ this -> gdResource ) ; for ( $ x = 0 ; $ x < $ width ; $ x ++ ) { for ( $ y = 0 ; $ y < $ height ; $ y ++ ) { $ colors [ imagecolorat ( $ this -> gdResource , $ x , $ y ) ] = true ; if ( $ max !== null && \ count ( $ colors ) > $ max ) { break 2 ; } } } return \ count ( $ colors ) ; }
8002	private function resolveInputEncoding ( $ string ) { $ encoding = null ; if ( $ this -> detect ) { $ encoding = mb_detect_encoding ( $ string , null , true ) ; } if ( false === $ encoding || null === $ encoding ) { $ encoding = mb_internal_encoding ( ) ; } if ( false === $ encoding || null === $ encoding ) { throw EncodingDetectionException :: forString ( $ string ) ; } return $ encoding ; }
11978	public function transform ( $ message ) { if ( is_array ( $ message ) ) { $ class = News :: class ; } else { if ( is_string ( $ message ) ) { $ message = new Text ( [ 'content' => $ message ] ) ; } $ class = get_class ( $ message ) ; } $ handle = 'transform' . substr ( $ class , strlen ( 'EasyWeChat\Message\\' ) ) ; return method_exists ( $ this , $ handle ) ? $ this -> $ handle ( $ message ) : [ ] ; }
2818	public function getModelsAsArray ( ) { $ data = array ( ) ; foreach ( $ this -> getModels ( ) as $ model ) { $ data [ ] = array ( 'resource_name' => $ model -> getResource ( ) , 'class' => $ model -> getClass ( ) , 'count' => $ model -> getCount ( ) ) ; } return $ data ; }
10784	public function parse ( UriInterface $ uri ) : ParsedURL { $ matches = [ ] ; if ( preg_match ( $ this -> pattern , $ uri -> getPath ( ) , $ matches ) === 0 ) { throw new InvalidRequestURLException ( "Unable to parse request path: did not match regex" ) ; } if ( ! ( $ endpoint = $ matches [ "endpoint" ] ?? null ) ) { throw new InvalidRequestURLException ( "Unable to match endpoint in url" ) ; } $ element = $ matches [ "element" ] ?? null ; $ version = $ matches [ "version" ] ?? null ; $ apiKey = $ matches [ "apiKey" ] ?? null ; $ acceptableMimeTypes = [ ] ; if ( ( $ acceptableExtension = $ matches [ "acceptableExtension" ] ?? null ) ) { if ( ! $ this -> MIMEProvider ) { throw new UnableToParseURLException ( "Unable to accept acceptable extensions" ) ; } else { try { $ acceptableMimeTypes [ ] = $ this -> MIMEProvider -> provideMIME ( $ acceptableExtension ) ; } catch ( UnableToProvideMIMEException $ exception ) { throw new UnableToParseURLException ( $ exception -> getMessage ( ) ) ; } } } return new ParsedURL ( $ endpoint , $ element , $ version , $ apiKey , $ acceptableMimeTypes , $ uri -> getQuery ( ) ) ; }
1615	public function readSession ( $ id ) { $ data = $ this -> redis -> executeCommand ( 'GET' , [ $ this -> calculateKey ( $ id ) ] ) ; return $ data === false || $ data === null ? '' : $ data ; }
195	public function sendContentAsFile ( $ content , $ attachmentName , $ options = [ ] ) { $ headers = $ this -> getHeaders ( ) ; $ contentLength = StringHelper :: byteLength ( $ content ) ; $ range = $ this -> getHttpRange ( $ contentLength ) ; if ( $ range === false ) { $ headers -> set ( 'Content-Range' , "bytes */$contentLength" ) ; throw new RangeNotSatisfiableHttpException ( ) ; } list ( $ begin , $ end ) = $ range ; if ( $ begin != 0 || $ end != $ contentLength - 1 ) { $ this -> setStatusCode ( 206 ) ; $ headers -> set ( 'Content-Range' , "bytes $begin-$end/$contentLength" ) ; $ this -> content = StringHelper :: byteSubstr ( $ content , $ begin , $ end - $ begin + 1 ) ; } else { $ this -> setStatusCode ( 200 ) ; $ this -> content = $ content ; } $ mimeType = isset ( $ options [ 'mimeType' ] ) ? $ options [ 'mimeType' ] : 'application/octet-stream' ; $ this -> setDownloadHeaders ( $ attachmentName , $ mimeType , ! empty ( $ options [ 'inline' ] ) , $ end - $ begin + 1 ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
8117	public function onBeforeWrite ( ) { $ changedFields = $ this -> owner -> getChangedFields ( true , 2 ) ; if ( $ changedFields ) { $ this -> owner -> LastEditedByName = $ this -> owner -> getEditorName ( ) ; $ this -> owner -> OwnerNames = $ this -> owner -> getOwnerNames ( ) ; } if ( $ this -> owner -> isChanged ( "ContentReviewType" , 2 ) ) { if ( $ this -> owner -> ContentReviewType == "Disabled" ) { $ this -> setDefaultReviewDateForDisabled ( ) ; } elseif ( $ this -> owner -> ContentReviewType == "Custom" ) { $ this -> setDefaultReviewDateForCustom ( ) ; } else { $ this -> setDefaultReviewDateForInherited ( ) ; } } if ( $ this -> owner -> ContentReviewType == "Inherit" && ! $ this -> owner -> NextReviewDate ) { $ this -> setDefaultReviewDateForInherited ( ) ; } if ( ! $ this -> owner -> exists ( ) ) { return ; } if ( $ this -> owner -> isChanged ( 'ReviewPeriodDays' , 2 ) ) { $ nextReviewUnixSec = strtotime ( ' + ' . $ this -> owner -> ReviewPeriodDays . ' days' , DBDatetime :: now ( ) -> getTimestamp ( ) ) ; $ this -> owner -> NextReviewDate = DBDate :: create ( ) -> setValue ( $ nextReviewUnixSec ) -> Format ( 'y-MM-dd' ) ; } }
2592	public static function createRequestCreator ( $ params , $ libIdentifier ) { $ params -> receivedFrom = self :: makeReceivedFrom ( $ params -> receivedFrom , $ libIdentifier ) ; $ theRequestCreator = new Base ( $ params ) ; return $ theRequestCreator ; }
11098	public static function secondsBetweenWorkingDays ( $ dateFrom , $ dateTo , $ workDayFrom , $ workDayTo , $ weekends = false , $ holidays = false , $ timeZone = 'Europe/Prague' ) { $ timeZoneObj = new \ DateTimeZone ( $ timeZone ) ; $ dateFromObj = new DateTime ( $ dateFrom , $ timeZoneObj ) ; $ dateToObj = new DateTime ( $ dateTo , $ timeZoneObj ) ; $ workDayFromObj = new DateTime ( $ workDayFrom , $ timeZoneObj ) ; $ workDayToObj = new DateTime ( $ workDayTo , $ timeZoneObj ) ; $ workDayLength = self :: secondsBetweenDates ( $ workDayFrom , $ workDayTo , true , $ timeZone ) ; $ period = new \ DatePeriod ( new DateTime ( $ dateFromObj -> format ( 'Y-m-d 00:00:00' ) , $ timeZoneObj ) , new \ DateInterval ( 'P1D' ) , new DateTime ( $ dateToObj -> format ( 'Y-m-d 23:59:59' ) , $ timeZoneObj ) ) ; $ workedTime = 0 ; foreach ( $ period as $ date ) { if ( ( ! $ weekends && ( int ) $ date -> format ( 'N' ) > 5 ) || ( ! $ holidays && self :: isCzechHoliday ( $ date ) ) ) { continue ; } if ( $ date -> format ( 'Y-m-d' ) === $ dateFromObj -> format ( 'Y-m-d' ) ) { $ endOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayToObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateFromObj < $ endOfDay && $ dateFromObj -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ diff = $ dateToObj -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } else { $ diff = $ endOfDay -> diff ( $ dateFromObj ) -> format ( '%H:%I:%S' ) ; } $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } elseif ( $ date -> format ( 'Y-m-d' ) === $ dateToObj -> format ( 'Y-m-d' ) ) { $ startOfDay = new DateTime ( $ date -> format ( 'Y-m-d ' . $ workDayFromObj -> format ( 'H:i:s' ) ) , $ timeZoneObj ) ; if ( $ dateToObj > $ startOfDay ) { $ diff = $ startOfDay -> diff ( $ dateToObj ) -> format ( '%H:%I:%S' ) ; $ diff = explode ( ':' , $ diff ) ; $ diff = $ diff [ 0 ] * 3600 + $ diff [ 1 ] * 60 + $ diff [ 0 ] ; $ workedTime += $ diff ; } } else { $ workedTime += $ workDayLength ; } } return $ workedTime ; }
7489	public function insert ( $ offset , $ string ) { $ offset = ( int ) $ offset ; $ string = static :: convertString ( $ string , $ this -> encoding ) ; if ( $ offset < 0 || $ offset >= $ this -> length ( ) ) { throw new \ OutOfBoundsException ( ) ; } $ this -> string = mb_substr ( $ this -> string , 0 , $ offset , $ this -> encoding ) . $ string . mb_substr ( $ this -> string , $ offset , $ this -> length ( ) , $ this -> encoding ) ; return $ this ; }
3456	public static function fromString ( string $ aggregateTypeString ) : AggregateType { if ( empty ( $ aggregateTypeString ) ) { throw new Exception \ InvalidArgumentException ( 'AggregateType must be a non empty string' ) ; } $ self = new static ( ) ; $ self -> aggregateType = $ aggregateTypeString ; return $ self ; }
6384	public function readFeedbackQuestions ( $ id ) { $ questions = $ this -> readStoreRecords ( 'feedback_item' , [ 'feedback' => $ id ] ) ; $ expandedQuestions = [ ] ; foreach ( $ questions as $ index => $ question ) { $ expandedQuestion = $ question ; $ expandedQuestion -> template = $ this -> readStoreRecord ( 'feedback_template' , [ 'id' => $ question -> template ] ) ; $ expandedQuestion -> url = $ this -> cfg -> wwwroot . '/mod/feedback/edit_item.php?id=' . $ question -> id ; $ expandedQuestions [ $ index ] = $ expandedQuestion ; } return $ expandedQuestions ; }
568	private function formatTimestamp ( $ timestamp , $ format ) { if ( strncmp ( $ format , 'php:' , 4 ) === 0 ) { $ format = substr ( $ format , 4 ) ; } else { $ format = FormatConverter :: convertDateIcuToPhp ( $ format , 'date' ) ; } $ date = new DateTime ( ) ; $ date -> setTimestamp ( $ timestamp ) ; $ date -> setTimezone ( new \ DateTimeZone ( $ this -> timestampAttributeTimeZone ) ) ; return $ date -> format ( $ format ) ; }
8906	public function count_by ( ) { $ where = func_get_args ( ) ; $ this -> _set_where ( $ where ) ; $ this -> apply_soft_delete_filter ( ) ; return $ this -> _database -> count_all_results ( $ this -> _table ) ; }
3764	private function getVisibleCondition ( $ property ) { $ condition = $ property -> getVisibleCondition ( ) ; if ( $ condition instanceof PropertyConditionChain ) { return $ condition ; } $ conditionChain = new PropertyConditionChain ( ) ; $ property -> setVisibleCondition ( $ conditionChain ) ; if ( $ condition ) { $ conditionChain -> addCondition ( $ condition ) ; } return $ conditionChain ; }
4363	public static function toUtf8 ( $ str ) { if ( \ extension_loaded ( 'mbstring' ) && \ function_exists ( 'iconv' ) ) { $ encoding = \ mb_detect_encoding ( $ str , \ mb_detect_order ( ) , true ) ; if ( ! $ encoding ) { $ str_conv = false ; if ( \ function_exists ( 'iconv' ) ) { $ str_conv = \ iconv ( 'cp1252' , 'UTF-8' , $ str ) ; } if ( $ str_conv === false ) { $ str_conv = \ htmlentities ( $ str , ENT_COMPAT ) ; $ str_conv = \ html_entity_decode ( $ str_conv , ENT_COMPAT , 'UTF-8' ) ; } $ str = $ str_conv ; } elseif ( ! \ in_array ( $ encoding , array ( 'ASCII' , 'UTF-8' ) ) ) { $ str_new = \ iconv ( $ encoding , 'UTF-8' , $ str ) ; if ( $ str_new !== false ) { $ str = $ str_new ; } } } return $ str ; }
8244	public function login ( $ id , $ userData ) { $ this -> abortIfExpired ( $ id , $ userData ) ; $ u = new User ( ) ; $ u -> setAuthenticated ( true ) ; $ u -> setAuthenticator ( $ this -> getName ( ) ) ; $ u -> setId ( $ id ) ; if ( isset ( $ userData [ 'groups' ] ) ) { $ u -> setGroups ( $ userData [ 'groups' ] ) ; } if ( isset ( $ userData [ 'displayName' ] ) ) { $ u -> setDisplayName ( $ userData [ 'displayName' ] ) ; } if ( isset ( $ userData [ 'attributes' ] ) ) { foreach ( $ userData [ 'attributes' ] as $ key => $ value ) { $ u -> setAttribute ( $ key , $ value ) ; } } $ this -> picoAuth -> setUser ( $ u ) ; }
3802	private function getOrCreatePaletteDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasDefinition ( PalettesDefinitionInterface :: NAME ) ) { return $ container -> getDefinition ( PalettesDefinitionInterface :: NAME ) ; } $ container -> setDefinition ( PalettesDefinitionInterface :: NAME , $ palettesDefinition = new DefaultPalettesDefinition ( ) ) ; return $ palettesDefinition ; }
11987	private function isEndOfLine ( $ i ) { $ ch = $ this -> data [ $ i ] ; if ( $ this -> getLineEndingModeCrlf ( ) ) { if ( $ ch == "\r" ) { $ more_ch = $ i + 1 < strlen ( $ this -> data ) ; if ( $ more_ch ) { $ next_n = $ this -> data [ $ i + 1 ] == "\n" ; if ( $ next_n ) return true ; } } } else { if ( $ ch == "\n" ) return true ; } return false ; }
10968	public static function getPath ( ) { $ uri = isset ( $ _SERVER [ 'REQUEST_URI' ] ) ? $ _SERVER [ 'REQUEST_URI' ] : '' ; if ( strpos ( $ uri , '?' ) > 0 ) { $ uri = substr ( $ uri , 0 , strpos ( $ uri , '?' ) ) ; } $ uri = preg_replace ( "/^\\/(.*)$/" , "$1" , $ uri ) ; $ uri = preg_replace ( "/^(.*)\\/$/" , "$1" , $ uri ) ; return $ uri ; }
1763	public function onKernelTerminate ( PostResponseEvent $ event ) : void { if ( ! $ this -> framework -> isInitialized ( ) || ! $ this -> canRunController ( $ event -> getRequest ( ) ) ) { return ; } $ controller = $ this -> framework -> createInstance ( FrontendCron :: class ) ; $ controller -> run ( ) ; }
9352	public function cofactor ( ) { $ c = new self ( $ this -> size -> rows , $ this -> size -> cols ) ; for ( $ m = 0 ; $ m < $ this -> size -> rows ; $ m ++ ) { $ arr_row = array ( ) ; for ( $ n = 0 ; $ n < $ this -> size -> cols ; $ n ++ ) { if ( $ this -> size -> cols == 2 ) { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> get ( 0 , 0 ) ; } else { $ arr_row [ ] = pow ( - 1 , $ m + $ n ) * $ this -> subMatrix ( $ m , $ n ) -> det ( ) ; } } $ c -> addRow ( $ arr_row ) ; } return $ c ; }
6408	public static function filterBy ( IteratorAggregate $ unfiltered , string $ className ) : IteratorAggregate { return self :: from ( Iterators :: filterBy ( Iterators :: from ( $ unfiltered -> getIterator ( ) ) , $ className ) ) ; }
9164	protected function parseNode ( RuleCollection $ collection , \ DOMElement $ node , $ path , $ file ) { if ( self :: NAMESPACE_URI !== $ node -> namespaceURI ) { return ; } switch ( $ node -> localName ) { case 'rule' : $ this -> parseRule ( $ collection , $ node , $ path ) ; break ; case 'import' : $ this -> parseImport ( $ collection , $ node , $ path , $ file ) ; break ; default : throw new \ InvalidArgumentException ( sprintf ( 'Unknown tag "%s" used in file "%s". Expected "rule" or "import".' , $ node -> localName , $ path ) ) ; } }
7736	private function documentProperties ( ClassMetadata $ metadata , ReflectionClass $ class ) { $ properties = array ( ) ; $ elements = array_merge ( $ class -> getProperties ( ) , $ class -> getMethods ( ) ) ; foreach ( $ elements as $ element ) { $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Expose' ) ; if ( null === $ annotation ) { continue ; } $ property = new PropertyDefinition ( $ class -> name , $ element -> name ) ; $ property -> setExposeAs ( $ annotation -> as ) ; $ property -> setIri ( $ annotation -> getIri ( ) ) ; if ( null !== $ annotation -> required ) { $ property -> setRequired ( $ annotation -> required ) ; } if ( null !== $ annotation -> readonly ) { $ property -> setReadOnly ( $ annotation -> readonly ) ; } if ( null !== $ annotation -> writeonly ) { $ property -> setWriteOnly ( $ annotation -> writeonly ) ; } $ tmp = $ this -> getDocBlockText ( $ element ) ; $ property -> setTitle ( $ tmp [ 'title' ] ) ; $ property -> setDescription ( $ tmp [ 'description' ] ) ; $ tmp = $ this -> getType ( $ element ) ; $ property -> setType ( $ tmp [ 'type' ] ) ; $ this -> documentRouteAndOperations ( $ property , $ element ) ; if ( null !== ( $ annotation = $ this -> getAnnotation ( $ element , 'ML\HydraBundle\Mapping\Collection' ) ) ) { $ property -> setRoute ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; if ( false === $ property -> supportsOperation ( $ annotation -> route ) ) { $ property -> addOperation ( $ this -> getRouteMetadata ( $ annotation -> route ) ) ; } $ property -> setType ( 'ML\HydraBundle\Entity\Collection' ) ; $ property -> setReadOnly ( true ) ; } $ properties [ ] = $ property ; } $ metadata -> setProperties ( $ properties ) ; }
4822	public function set ( $ name , $ value ) { if ( ! array_key_exists ( $ name , $ this -> row ) ) { $ this -> addField ( $ name , $ value ) ; } else { $ this -> row [ $ name ] = $ value ; } $ this -> informChanges ( ) ; }
9669	private function writeFont ( XMLWriter $ objWriter , Font $ pFont ) { $ objWriter -> startElement ( 'font' ) ; if ( $ pFont -> getBold ( ) !== null ) { $ objWriter -> startElement ( 'b' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getBold ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getItalic ( ) !== null ) { $ objWriter -> startElement ( 'i' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getItalic ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getStrikethrough ( ) !== null ) { $ objWriter -> startElement ( 'strike' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getStrikethrough ( ) ? '1' : '0' ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getUnderline ( ) !== null ) { $ objWriter -> startElement ( 'u' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getUnderline ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSuperscript ( ) === true || $ pFont -> getSubscript ( ) === true ) { $ objWriter -> startElement ( 'vertAlign' ) ; if ( $ pFont -> getSuperscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'superscript' ) ; } elseif ( $ pFont -> getSubscript ( ) === true ) { $ objWriter -> writeAttribute ( 'val' , 'subscript' ) ; } $ objWriter -> endElement ( ) ; } if ( $ pFont -> getSize ( ) !== null ) { $ objWriter -> startElement ( 'sz' ) ; $ objWriter -> writeAttribute ( 'val' , StringHelper :: formatNumber ( $ pFont -> getSize ( ) ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getColor ( ) -> getARGB ( ) !== null ) { $ objWriter -> startElement ( 'color' ) ; $ objWriter -> writeAttribute ( 'rgb' , $ pFont -> getColor ( ) -> getARGB ( ) ) ; $ objWriter -> endElement ( ) ; } if ( $ pFont -> getName ( ) !== null ) { $ objWriter -> startElement ( 'name' ) ; $ objWriter -> writeAttribute ( 'val' , $ pFont -> getName ( ) ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; }
8619	public function getBlockWithKey ( $ key ) { if ( isset ( $ this -> blocks [ $ key ] ) ) return $ this -> blocks [ $ key ] ; return null ; }
3932	private function setLabel ( PropertyInterface $ property , $ propInfo , IAttribute $ attribute ) { if ( $ property -> getLabel ( ) ) { return ; } if ( ! isset ( $ propInfo [ 'label' ] ) ) { $ property -> setLabel ( $ attribute -> getName ( ) ) ; return ; } $ lang = $ propInfo [ 'label' ] ; if ( is_array ( $ lang ) ) { $ property -> setLabel ( reset ( $ lang ) ) ; $ property -> setDescription ( next ( $ lang ) ) ; return ; } $ property -> setLabel ( $ lang ) ; }
6497	public function iSwitchToWindow ( ) { $ windows = $ this -> getWindowNames ( ) ; if ( empty ( $ this -> mainWindow ) ) { $ this -> mainWindow [ 'name' ] = array_shift ( $ windows ) ; $ this -> mainWindow [ 'element' ] = $ this -> getWorkingElement ( ) ; $ window = reset ( $ windows ) ; } else { $ window = $ this -> mainWindow [ 'name' ] ; $ element = $ this -> mainWindow [ 'element' ] ; $ this -> mainWindow = [ ] ; } $ this -> getSession ( ) -> switchToWindow ( $ window ) ; $ this -> setWorkingElement ( isset ( $ element ) ? $ element : $ this -> getBodyElement ( ) ) ; }
2164	public static function convertSingleField ( $ table , $ field ) { $ objDatabase = Database :: getInstance ( ) ; $ objRow = $ objDatabase -> query ( "SELECT id, $field FROM $table WHERE $field!=''" ) ; $ objDesc = $ objDatabase -> query ( "DESC $table $field" ) ; if ( $ objDesc -> Type != 'binary(16)' ) { $ objDatabase -> query ( "ALTER TABLE `$table` CHANGE `$field` `$field` binary(16) NULL" ) ; $ objDatabase -> query ( "UPDATE `$table` SET `$field`=NULL WHERE `$field`='' OR `$field`=0" ) ; } while ( $ objRow -> next ( ) ) { $ objHelper = static :: generateHelperObject ( $ objRow -> $ field ) ; if ( $ objHelper -> isUuid ) { continue ; } if ( $ objHelper -> isNumeric ) { $ objFile = FilesModel :: findByPk ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } else { $ objFile = FilesModel :: findByPath ( $ objHelper -> value ) ; $ objDatabase -> prepare ( "UPDATE $table SET $field=? WHERE id=?" ) -> execute ( $ objFile -> uuid , $ objRow -> id ) ; } } }
11219	protected static function invokeObject ( $ callback , $ matched = null ) { $ last = explode ( '/' , $ callback ) ; $ last = end ( $ last ) ; $ segments = explode ( '@' , $ last ) ; $ class = $ segments [ 0 ] ; $ method = $ segments [ 1 ] ; $ matched = $ matched ? $ matched : [ ] ; if ( method_exists ( $ class , self :: $ singleton ) ) { $ instance = call_user_func ( [ $ class , self :: $ singleton ] ) ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } if ( class_exists ( $ class ) ) { $ instance = new $ class ; return call_user_func_array ( [ $ instance , $ method ] , $ matched ) ; } return false ; }
8035	public function isMemberOf ( $ group ) { foreach ( $ this -> attributes [ 'member_of' ] as $ groups ) { if ( preg_match ( '/^CN=' . $ group . '/' , $ groups ) ) { return true ; } } return false ; }
9924	public function filter ( Parameters $ params , array $ permitted = array ( ) ) { $ this -> cleanUnwanted ( $ params , $ permitted ) ; $ this -> handleArrays ( $ params , $ permitted ) ; $ this -> handleCollections ( $ params , $ permitted ) ; }
7047	protected function buildAddressData ( Common \ AddressInterface $ address , string $ locale ) { $ country = Intl :: getRegionBundle ( ) -> getCountryName ( $ address -> getCountry ( ) -> getCode ( ) , $ locale ) ; $ fullName = trim ( $ address -> getFirstName ( ) . ' ' . $ address -> getLastName ( ) ) ; $ data = [ 'company' => $ address -> getCompany ( ) , 'full_name' => $ fullName , 'street' => $ address -> getStreet ( ) , 'complement' => $ address -> getComplement ( ) , 'supplement' => $ address -> getSupplement ( ) , 'postal_code' => $ address -> getPostalCode ( ) , 'city' => $ address -> getCity ( ) , 'country' => $ country , 'state' => '' , 'phone' => $ this -> formatPhoneNumber ( $ address -> getPhone ( ) ) , 'mobile' => $ this -> formatPhoneNumber ( $ address -> getMobile ( ) ) , ] ; if ( $ address instanceof RelayPointInterface ) { $ data [ 'number' ] = $ address -> getNumber ( ) ; } return $ data ; }
12687	public function init ( $ confPath , $ useCache = true ) { $ this -> confPath = $ confPath ; if ( $ useCache ) { $ cachedConfig = new PhpConfiguration ( ) ; $ this -> cache = $ cachedConfig -> get ( ) ; unset ( $ cachedConfig ) ; } }
9073	protected function getRoutes ( ) { return collect ( $ this -> routes ) -> map ( function ( $ route ) { return $ this -> getRouteInformation ( $ route ) ; } ) -> reject ( function ( $ item ) { return is_null ( $ item ) ; } ) -> sortBy ( 'name' ) -> pluck ( 'name' ) ; }
810	private function toComparableNames ( array $ types , array $ symbolShortNames ) { $ normalized = array_map ( function ( $ type ) use ( $ symbolShortNames ) { $ type = strtolower ( $ type ) ; if ( isset ( $ symbolShortNames [ $ type ] ) ) { return $ symbolShortNames [ $ type ] ; } return $ type ; } , $ types ) ; sort ( $ normalized ) ; return $ normalized ; }
12130	public function clear ( ) { $ this -> _repeat = 1 ; $ this -> _startTime = 0 ; $ this -> _duration = 0 ; $ this -> _average = 0 ; $ this -> _rate = 0 ; $ this -> _startMem = 0 ; $ this -> _memory = 0 ; }
2324	public static function validate ( $ strToken ) { if ( Config :: get ( 'disableRefererCheck' ) || \ defined ( 'BYPASS_TOKEN_CHECK' ) ) { return true ; } if ( Config :: get ( 'requestTokenWhitelist' ) ) { $ strHostname = gethostbyaddr ( $ _SERVER [ 'REMOTE_ADDR' ] ) ; foreach ( Config :: get ( 'requestTokenWhitelist' ) as $ strDomain ) { if ( $ strDomain == $ strHostname || preg_match ( '/\.' . preg_quote ( $ strDomain , '/' ) . '$/' , $ strHostname ) ) { return true ; } } } $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> isTokenValid ( new CsrfToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) , $ strToken ) ) ; }
2963	public function isAuthorized ( ) { $ hasSession = Yii :: $ app -> session -> has ( $ this -> sessionParam ) ; $ sessionVal = Yii :: $ app -> session -> get ( $ this -> sessionParam ) ; return ( $ hasSession && ! empty ( $ sessionVal ) ) ; }
1513	public function create ( StoreInterface $ store , CreateResource $ request ) { $ record = $ this -> transaction ( function ( ) use ( $ store , $ request ) { return $ this -> doCreate ( $ store , $ request ) ; } ) ; if ( $ this -> isResponse ( $ record ) ) { return $ record ; } return $ this -> reply ( ) -> created ( $ record ) ; }
5110	private function appendBind ( $ part , $ bind ) { if ( $ bind === false ) return $ this ; if ( ! is_array ( $ bind ) ) $ bind = [ $ bind ] ; if ( ! $ this -> bind [ $ part ] ) { $ this -> bind [ $ part ] = $ bind ; } else { $ this -> bind [ $ part ] = array_merge ( $ this -> bind [ $ part ] , $ bind ) ; } return $ this ; }
3557	protected function setType ( $ value ) { $ this -> attributes [ 'meta_type' ] = $ this -> hasMutator ( $ value , 'setter' ) ? $ this -> getMutatedType ( $ value , 'setter' ) : $ this -> getValueType ( $ value ) ; }
591	protected function compressCssFiles ( $ inputFiles , $ outputFile ) { if ( empty ( $ inputFiles ) ) { return ; } $ this -> stdout ( " Compressing CSS files...\n" ) ; if ( is_string ( $ this -> cssCompressor ) ) { $ tmpFile = $ outputFile . '.tmp' ; $ this -> combineCssFiles ( $ inputFiles , $ tmpFile ) ; $ this -> stdout ( shell_exec ( strtr ( $ this -> cssCompressor , [ '{from}' => escapeshellarg ( $ tmpFile ) , '{to}' => escapeshellarg ( $ outputFile ) , ] ) ) ) ; @ unlink ( $ tmpFile ) ; } else { call_user_func ( $ this -> cssCompressor , $ this , $ inputFiles , $ outputFile ) ; } if ( ! file_exists ( $ outputFile ) ) { throw new Exception ( "Unable to compress CSS files into '{$outputFile}'." ) ; } $ this -> stdout ( " CSS files compressed into '{$outputFile}'.\n" ) ; }
12700	public function createServiceWithName ( ServiceLocatorInterface $ serviceLocator , $ name , $ requestedName ) { $ config = $ serviceLocator -> get ( 'config' ) ; if ( isset ( $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ) ) { $ config = $ config [ 'rznviewcomponent' ] [ 'cache_adapter' ] ; } else $ config = array ( 'name' => 'filesystem' , 'options' => array ( 'ttl' => 3600 , 'dirLevel' => 2 , 'file_locking' => false , 'cacheDir' => 'data/cache' , 'dirPermission' => 0755 , 'filePermission' => 0666 , ) , ) ; return \ Zend \ Cache \ StorageFactory :: factory ( array ( 'adapter' => $ config , 'plugins' => array ( 'serializer' ) , ) ) ; }
6461	public function shouldSeeThumbnail ( ) { $ thumb = false ; foreach ( [ '.upload-preview' , '.media-thumbnail img' , '.image-preview img' ] as $ selector ) { if ( $ thumb ) { break ; } $ thumb = $ this -> findByCss ( $ selector ) ; } if ( null === $ thumb ) { throw new \ Exception ( 'An expected image tag was not found.' ) ; } $ file = explode ( '?' , $ thumb -> getAttribute ( 'src' ) ) ; $ file = reset ( $ file ) ; $ curl = new CurlService ( ) ; list ( , $ info ) = $ curl -> execute ( 'GET' , $ file ) ; if ( empty ( $ info ) || strpos ( $ info [ 'content_type' ] , 'image/' ) === false ) { throw new FileNotFoundException ( sprintf ( '%s did not return an image' , $ file ) ) ; } }
7268	public function hasMany ( $ forClass , $ forColumn = null , $ condition = "" , array $ conditionParams = [ ] ) { $ refTable = static :: tableName ( ) ; $ forTable = $ forClass :: tableName ( ) ; $ refColumn = static :: $ idColumn ; $ forColumn = $ forColumn ? : strtolower ( static :: modelName ( ) ) . "_id" ; $ rows = Db :: query ( " select F.* from $refTable as R, $forTable as F where R.$refColumn = F.$forColumn and R.$refColumn = :id $condition " , array_merge ( [ "id" => $ this -> $ refColumn ] , $ conditionParams ) , static :: getDbName ( ) ) ; if ( $ rows === false ) return false ; if ( empty ( $ rows ) ) return new Collection ( [ ] ) ; $ collection = [ ] ; foreach ( $ rows as $ row ) { $ forModel = new $ forClass ; foreach ( $ row as $ column => $ val ) $ forModel -> $ column = $ forModel -> decodeValue ( $ val , $ column ) ; $ collection [ ] = $ forModel ; } return new Collection ( $ collection ) ; }
11626	private function isrunning ( ) { $ pids = explode ( PHP_EOL , `ps -e | awk '{print $1}'` ) ; if ( in_array ( $ this -> pid , $ pids ) ) return true ; return false ; }
1954	public static function findExpiredSubscriptions ( array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ objDatabase = Database :: getInstance ( ) ; $ objResult = $ objDatabase -> prepare ( "SELECT * FROM $t WHERE active='' AND EXISTS (SELECT * FROM tl_opt_in_related r LEFT JOIN tl_opt_in o ON r.pid=o.id WHERE r.relTable='$t' AND r.relId=$t.id AND o.createdOn<=? AND o.confirmedOn=0)" ) -> execute ( strtotime ( '-24 hours' ) ) ; if ( $ objResult -> numRows < 1 ) { return null ; } return static :: createCollectionFromDbResult ( $ objResult , $ t ) ; }
1495	public static function createCustom ( ... $ mediaTypes ) : self { $ encodings = new self ( ) ; $ encodings -> stack = collect ( $ mediaTypes ) -> map ( function ( $ mediaType ) { return Encoding :: custom ( $ mediaType ) ; } ) -> all ( ) ; return $ encodings ; }
11690	protected function processAuth ( string $ actionName , array $ actionArgs ) : void { $ callAction = function ( string $ actionName , array $ actionArgs ) { if ( empty ( $ actionArgs ) ) { $ this -> ctrl -> { $ actionName } ( ) ; } else { ( new \ ReflectionMethod ( $ this -> ctrl , $ actionName ) ) -> invokeArgs ( $ this -> ctrl , $ actionArgs ) ; } } ; if ( class_exists ( '\extensions\core\Auth' ) ) { $ auth = new \ extensions \ core \ Auth ( $ this -> ctrl -> getRequest ( ) ) ; $ auth -> run ( ) ; if ( $ auth -> isValid ( ) ) { $ callAction ( $ actionName , $ actionArgs ) ; } else { $ auth -> onFail ( ) ; } } else { $ callAction ( $ actionName , $ actionArgs ) ; } }
2004	public function addAttributes ( $ arrAttributes ) { parent :: addAttributes ( $ arrAttributes ) ; if ( $ this -> type != 'number' ) { return ; } foreach ( array ( 'minlength' , 'minval' , 'maxlength' , 'maxval' ) as $ name ) { if ( isset ( $ arrAttributes [ $ name ] ) ) { $ this -> $ name = $ arrAttributes [ $ name ] ; } } }
9611	public function getAssetUrl ( $ path , $ relative = false ) { if ( substr ( $ path , 0 , 1 ) !== '/' ) { $ path = '/' . $ path ; } if ( $ this -> assetRoot !== null ) { $ base = $ this -> assetRoot ; } else if ( $ relative ) { $ base = $ this -> requests -> getCurrentRequest ( ) -> getBaseUrl ( ) ; } else { $ base = $ this -> getRootUrl ( ) ; } return $ base . $ path ; }
896	private function findComparisonStart ( Tokens $ tokens , $ index ) { -- $ index ; $ nonBlockFound = false ; while ( 0 <= $ index ) { $ token = $ tokens [ $ index ] ; if ( $ token -> isGivenKind ( [ T_WHITESPACE , T_COMMENT , T_DOC_COMMENT ] ) ) { -- $ index ; continue ; } if ( $ this -> isOfLowerPrecedence ( $ token ) ) { break ; } $ block = Tokens :: detectBlockType ( $ token ) ; if ( null === $ block ) { -- $ index ; $ nonBlockFound = true ; continue ; } if ( $ block [ 'isStart' ] || ( $ nonBlockFound && Tokens :: BLOCK_TYPE_CURLY_BRACE === $ block [ 'type' ] ) ) { break ; } $ index = $ tokens -> findBlockStart ( $ block [ 'type' ] , $ index ) - 1 ; } return $ tokens -> getNextMeaningfulToken ( $ index ) ; }
5658	private function addWidgetToForm ( $ node , $ form , $ enclosing_label ) { $ widget = $ this -> tags ( ) -> createTag ( $ node -> name , $ this -> attributes ( $ node ) ) ; if ( ! $ widget ) { return ; } $ widget -> setLabel ( $ enclosing_label ) -> addContent ( $ this -> innerHtml ( $ node ) ) ; if ( $ node -> name == 'select' ) { $ widget -> addTags ( $ this -> collectSelectOptions ( $ node ) ) ; } $ form -> addWidget ( $ widget ) ; $ this -> indexWidgetById ( $ widget ) ; }
2664	public function sendWebHook ( $ message ) { $ url = $ this -> config -> getIncomingWebhookURL ( ) ; $ messagePrefix = $ this -> config -> getWebhookMessagePrefix ( ) ; $ currentUsername = 'System' ; try { if ( $ this -> state -> getAreaCode ( ) == 'adminhtml' ) { $ getUser = $ this -> authSession -> getUser ( ) ; if ( ! empty ( $ getUser ) ) { $ currentUsername = $ getUser -> getUserName ( ) ; } } } catch ( \ Exception $ e ) { $ this -> log -> log ( 100 , 'Failed to retrieve Area Code' ) ; } $ storeName = $ this -> helper -> getStoreName ( ) ; $ storeUrl = $ this -> helper -> getStoreUrl ( ) ; $ text = $ messagePrefix . ' user=' . $ currentUsername . ' ' . $ message . ' on <' . $ storeUrl . '|Store> | ' . $ storeName ; $ headers = [ 'Content-type: application/json' ] ; $ body = json_encode ( [ "text" => $ text , "username" => "fastly-magento-bot" , "icon_emoji" => ":airplane:" ] ) ; $ client = $ this -> curlFactory -> create ( ) ; $ client -> addOption ( CURLOPT_CONNECTTIMEOUT , 2 ) ; $ client -> addOption ( CURLOPT_TIMEOUT , 3 ) ; $ client -> write ( \ Zend_Http_Client :: POST , $ url , '1.1' , $ headers , $ body ) ; $ response = $ client -> read ( ) ; $ responseCode = \ Zend_Http_Response :: extractCode ( $ response ) ; if ( $ responseCode != 200 ) { $ this -> log -> log ( 100 , 'Failed to send message to the following Webhook: ' . $ url ) ; } $ client -> close ( ) ; }
11484	protected function getFunctionArguments ( ReflectionFunctionAbstract $ func , array $ params = array ( ) ) { $ args = [ ] ; foreach ( $ func -> getParameters ( ) as $ param ) { $ class = $ param -> getClass ( ) ; if ( $ class ) { $ args [ ] = $ this -> resolveClassArg ( $ class , $ param , $ params ) ; } else { $ args [ ] = $ this -> resolveNonClassArg ( $ param , $ params , $ func ) ; } } return $ args ; }
9414	public function variance ( ) { $ float_variance = pow ( $ this -> float_sigma , 2 ) ; if ( $ this -> int_precision ) { return round ( $ float_variance , $ this -> int_precision ) ; } return $ float_variance ; }
9172	public function getViewHelpers ( ) { return [ 'aliases' => [ 'formmulticheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'formradio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFlashMessenger' => View \ Helper \ FlashMessenger :: class , 'zettaFormMultiCheckbox' => Form \ View \ Helper \ FormMultiCheckbox :: class , 'zettaFormRadio' => Form \ View \ Helper \ FormRadio :: class , 'zettaFormRow' => Form \ View \ Helper \ FormRow :: class , 'zettaPaginator' => View \ Helper \ Paginator :: class , 'zettaReferer' => View \ Helper \ Referer :: class , 'settings' => View \ Helper \ Settings :: class , 'thumbnail' => View \ Helper \ Thumbnail :: class , 'zettaUrl' => View \ Helper \ Url :: class , ] , 'factories' => [ Form \ View \ Helper \ FormMultiCheckbox :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRadio :: class => InvokableFactory :: class , Form \ View \ Helper \ FormRow :: class => InvokableFactory :: class , View \ Helper \ FlashMessenger :: class => InvokableFactory :: class , View \ Helper \ Paginator :: class => View \ Helper \ Factory \ PaginatorFactory :: class , View \ Helper \ Referer :: class => View \ Helper \ Factory \ RefererFactory :: class , View \ Helper \ Settings :: class => Factory \ WithSettingsFactory :: class , View \ Helper \ Thumbnail :: class => Factory \ WithThumbnailFactory :: class , View \ Helper \ Url :: class => View \ Helper \ Factory \ UrlFactory :: class ] , ] ; }
6007	public static function fromHex ( $ hex ) { if ( strlen ( $ hex ) != 2 ) { throw new Ts3Exception ( "given parameter '" . $ hex . "' is not a valid hexadecimal number" ) ; } return new self ( chr ( hexdec ( $ hex ) ) ) ; }
4372	public function onOutput ( Event $ event ) { $ this -> data = $ this -> debug -> getData ( ) ; $ this -> channels = array ( ) ; $ str = '<div' . $ this -> debug -> utilities -> buildAttribString ( array ( 'class' => 'debug' , 'data-channels' => '{{channels}}' , 'data-channel-root' => $ this -> channelNameRoot , ) ) . ">\n" ; if ( $ this -> debug -> getCfg ( 'output.outputCss' ) ) { $ str .= '<style type="text/css">' . "\n" . $ this -> debug -> output -> getCss ( ) . "\n" . '</style>' . "\n" ; } if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<script type="text/javascript">' . \ file_get_contents ( $ this -> debug -> getCfg ( 'filepathScript' ) ) . '</script>' . "\n" ; } $ str .= '<div class="debug-bar"><h3>Debug Log</h3></div>' . "\n" ; $ str .= $ this -> processAlerts ( ) ; if ( $ this -> debug -> getCfg ( 'output.outputScript' ) ) { $ str .= '<div class="loading">Loading <i class="fa fa-spinner fa-pulse fa-2x fa-fw" aria-hidden="true"></i></div>' . "\n" ; } $ str .= '<div class="debug-header m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processSummary ( ) ; $ str .= '</div>' . "\n" ; $ str .= '<div class="debug-content m_group"' . ( $ this -> debug -> getCfg ( 'outputScript' ) ? ' style="display:none;"' : '' ) . '>' . "\n" ; $ str .= $ this -> processLog ( ) ; $ str .= '</div>' . "\n" ; $ str .= '</div>' . "\n" ; $ str = \ strtr ( $ str , array ( '{{channels}}' => \ htmlspecialchars ( \ json_encode ( $ this -> buildChannelTree ( ) , JSON_FORCE_OBJECT ) ) , ) ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
12343	public function newAction ( Request $ request ) { $ post = new Post ( ) ; $ form = $ this -> createForm ( 'BlogBundle\Form\PostType' , $ post , array ( 'translator' => $ this -> get ( 'translator' ) ) ) ; $ form -> handleRequest ( $ request ) ; if ( $ form -> isSubmitted ( ) && $ form -> isValid ( ) ) { $ user = $ this -> container -> get ( 'security.token_storage' ) -> getToken ( ) -> getUser ( ) ; $ post -> setActor ( $ user ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ post ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> add ( 'success' , 'post.created' ) ; return $ this -> redirectToRoute ( 'blog_post_index' ) ; } return array ( 'category' => $ post , 'form' => $ form -> createView ( ) , ) ; }
9136	public function clearTag ( $ name ) { if ( isset ( $ this -> tags [ $ name ] ) ) { unset ( $ this -> tags [ $ name ] ) ; } return $ this ; }
1429	protected function fillSoftDelete ( Model $ record , $ field , $ value ) { $ value = $ this -> deserializeSoftDelete ( $ value , $ field , $ record ) ; $ record -> forceFill ( [ $ this -> getSoftDeleteKey ( $ record ) => $ value , ] ) ; }
8185	public function getParent ( array $ context ) { if ( null !== $ this -> parent ) { return $ this -> parent ; } try { $ parent = $ this -> doGetParent ( $ context ) ; if ( false === $ parent ) { return false ; } if ( $ parent instanceof self ) { return $ this -> parents [ $ parent -> getTemplateName ( ) ] = $ parent ; } if ( ! isset ( $ this -> parents [ $ parent ] ) ) { $ this -> parents [ $ parent ] = $ this -> loadTemplate ( $ parent ) ; } } catch ( Twig_Error_Loader $ e ) { $ e -> setSourceContext ( null ) ; $ e -> guess ( ) ; throw $ e ; } return $ this -> parents [ $ parent ] ; }
2566	protected function checkAnyNotEmpty ( ) { $ foundNotEmpty = false ; $ args = func_get_args ( ) ; foreach ( $ args as $ arg ) { if ( ! empty ( $ arg ) ) { $ foundNotEmpty = true ; break ; } } return $ foundNotEmpty ; }
4481	public function setInterval ( int $ interval ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'interval' , $ interval ) ) { $ this -> interval = $ interval ; } }
4383	protected function buildArgString ( $ args ) { $ numArgs = \ count ( $ args ) ; if ( $ numArgs == 1 && \ is_string ( $ args [ 0 ] ) ) { $ args [ 0 ] = \ strip_tags ( $ args [ 0 ] ) ; } foreach ( $ args as $ k => $ v ) { if ( $ k > 0 || ! \ is_string ( $ v ) ) { $ args [ $ k ] = $ this -> dump ( $ v ) ; } $ this -> valDepth = 0 ; } $ glue = ', ' ; $ glueAfterFirst = true ; if ( $ numArgs && \ is_string ( $ args [ 0 ] ) ) { if ( \ preg_match ( '/[=:] ?$/' , $ args [ 0 ] ) ) { $ glueAfterFirst = false ; } elseif ( \ count ( $ args ) == 2 ) { $ glue = ' = ' ; } } if ( ! $ glueAfterFirst ) { return $ args [ 0 ] . \ implode ( $ glue , \ array_slice ( $ args , 1 ) ) ; } else { return \ implode ( $ glue , $ args ) ; } }
8313	protected function beginPasswordReset ( ) { if ( ! $ this -> config [ "enabled" ] ) { return ; } $ this -> picoAuth -> addAllowed ( "password_reset" ) ; $ this -> picoAuth -> setRequestFile ( $ this -> picoAuth -> getPluginPath ( ) . '/content/pwbeginreset.md' ) ; if ( count ( $ this -> session -> getFlash ( '_pwresetsent' ) ) ) { $ this -> picoAuth -> addOutput ( "resetSent" , true ) ; return ; } $ post = $ this -> httpRequest -> request ; if ( $ post -> has ( "reset_email" ) ) { if ( ! $ this -> picoAuth -> isValidCSRF ( $ post -> get ( "csrf_token" ) ) ) { $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } $ email = trim ( $ post -> get ( "reset_email" ) ) ; if ( ! filter_var ( $ email , FILTER_VALIDATE_EMAIL ) ) { $ this -> session -> addFlash ( "error" , "Email address does not have a valid format." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( ! $ this -> limit -> action ( "passwordReset" , true , array ( "email" => $ email ) ) ) { $ this -> session -> addFlash ( "error" , $ this -> limit -> getError ( ) ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } if ( $ userData = $ this -> storage -> getUserByEmail ( $ email ) ) { $ this -> sendResetMail ( $ userData ) ; } $ this -> session -> addFlash ( "_pwresetsent" , true ) ; $ this -> session -> addFlash ( "success" , "Reset link sent via email." ) ; $ this -> picoAuth -> redirectToPage ( "password_reset" ) ; } }
11648	public function authenticate ( ) { $ this -> _authenticateSetup ( ) ; $ dbSelect = $ this -> _authenticateCreateSelect ( ) ; $ identity = $ this -> _authenticateQuerySelect ( $ dbSelect ) ; $ authResult = $ this -> _authenticateValidateResultSet ( $ identity ) ; if ( $ authResult instanceof Zend_Auth_Result ) { return $ authResult ; } return $ this -> _authenticateValidateResult ( array_shift ( $ identity ) ) ; }
11012	protected function importSchemaFile ( string $ schemaFile , string $ controlTableName = null ) : void { if ( $ controlTableName !== null ) { if ( $ this -> db -> getSchemaManager ( ) -> tablesExist ( [ $ controlTableName ] ) ) { $ this -> output -> writeln ( '<comment>Schema already exists in the database, skipping schema import for file <info>' . $ schemaFile . '</info></comment>' ) ; return ; } } $ this -> runQueriesFromFile ( $ schemaFile ) ; }
9207	public function importTable ( Table $ Table , $ records , array $ options = [ ] ) { $ defaultOptions = [ 'checkRules' => true , 'checkExisting' => true , ] ; $ options = $ options + $ defaultOptions ; foreach ( $ records as $ record ) { $ action = ( $ record -> isNew ( ) ? 'Create' : 'Update' ) ; $ result = $ Table -> save ( $ record , $ options ) ; $ key = $ this -> findKey ( $ Table , $ record ) ; if ( $ result ) { $ this -> verbose ( "<success>{$Table->alias()} ({$key}): {$action} successful.</success>" ) ; } else { $ this -> quiet ( "<warning>{$Table->alias()} ({$key}): {$action} failed.</warning>" ) ; $ this -> printValidationErrors ( $ Table -> alias ( ) , $ this -> findKey ( $ Table , $ record ) , $ record -> errors ( ) ) ; } } }
10201	private function writeCellMerge ( XMLWriter $ objWriter , Cell $ cell ) { if ( ! $ cell -> isMergeRangeValueCell ( ) ) { return ; } $ mergeRange = Coordinate :: splitRange ( $ cell -> getMergeRange ( ) ) ; list ( $ startCell , $ endCell ) = $ mergeRange [ 0 ] ; $ start = Coordinate :: coordinateFromString ( $ startCell ) ; $ end = Coordinate :: coordinateFromString ( $ endCell ) ; $ columnSpan = Coordinate :: columnIndexFromString ( $ end [ 0 ] ) - Coordinate :: columnIndexFromString ( $ start [ 0 ] ) + 1 ; $ rowSpan = $ end [ 1 ] - $ start [ 1 ] + 1 ; $ objWriter -> writeAttribute ( 'table:number-columns-spanned' , $ columnSpan ) ; $ objWriter -> writeAttribute ( 'table:number-rows-spanned' , $ rowSpan ) ; }
1929	public function generate ( ) { if ( TL_MODE == 'BE' ) { $ return = '<pre>' . StringUtil :: specialchars ( $ this -> code ) . '</pre>' ; if ( $ this -> headline != '' ) { $ return = '<' . $ this -> hl . '>' . $ this -> headline . '</' . $ this -> hl . '>' . $ return ; } return $ return ; } return parent :: generate ( ) ; }
10526	public function setFieldFromData ( $ name ) { $ value = $ this -> getFieldFormData ( $ name ) ; return $ this -> setFieldValue ( $ name , $ value ) ; }
737	protected function saveToFile ( $ data , $ file ) { file_put_contents ( $ file , "<?php\nreturn " . VarDumper :: export ( $ data ) . ";\n" , LOCK_EX ) ; $ this -> invalidateScriptCache ( $ file ) ; }
12563	public function sendNews ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_NEWS , $ message , $ to ) ; }
8774	public function base ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . $ data : $ this -> url . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
10891	public function syntax ( $ error = "Please specify valid options" ) { $ ostr = ( ! $ error ) ? STDOUT : STDERR ; if ( is_string ( $ error ) ) fprintf ( $ ostr , "Error: %s\n" , $ error ) ; fprintf ( $ ostr , "Syntax: php " . $ _SERVER [ 'argv' ] [ 0 ] . " <options> <action>\n\n" ) ; fprintf ( $ ostr , "Options: \n" ) ; $ max_opt_length = 0 ; $ max_arg_length = 0 ; $ params = $ this -> parameters ; usort ( $ params , function ( $ a , $ b ) { $ lo = ! empty ( $ a [ 0 ] ) ? $ a [ 0 ] : $ a [ 1 ] ; $ ro = ! empty ( $ b [ 0 ] ) ? $ b [ 0 ] : $ b [ 1 ] ; return strcmp ( $ lo , $ ro ) ; } ) ; foreach ( $ params as $ param ) { $ max_opt_length = max ( strlen ( $ param [ 1 ] ) + 3 , $ max_opt_length ) ; $ max_arg_length = max ( strlen ( $ param [ 2 ] ) + 3 , $ max_arg_length ) ; } foreach ( $ this -> parameters as $ param ) { fprintf ( $ ostr , " " ) ; $ so = $ param [ 0 ] ? "-" . $ param [ 0 ] : "" ; $ lo = $ param [ 1 ] ? "--" . $ param [ 1 ] : "" ; $ arg = $ param [ 2 ] ? '<' . $ param [ 2 ] . '>' : "" ; $ pstr = sprintf ( "%-2s %-" . $ max_opt_length . "s %-" . $ max_arg_length . "s " , $ so , $ lo , $ arg ) ; $ indent = strlen ( $ pstr ) + 4 ; fprintf ( $ ostr , $ pstr ) ; self :: formatText ( $ indent , self :: MAX_LINE_LENGTH , $ param [ 3 ] , $ ostr ) ; } exit ( $ error === false ? 0 : 1 ) ; }
7478	public function getFormFor ( $ entity , $ className = null , array $ options = array ( ) ) { if ( empty ( $ this -> _formHelper ) && ( $ this -> _formHelper = $ this -> get ( 'orkestra.application.helper.form' ) ) == null ) { throw new \ RuntimeException ( 'Orkestra FormHelper is not registered as a service' ) ; } $ type = $ this -> container -> get ( 'orkestra.application.helper.form' ) -> getType ( $ entity , $ className ) ; return $ this -> createForm ( $ type , $ entity , $ options ) ; }
2476	private function logWarning ( OutputInterface $ output , ProgressBar $ progress , $ message ) { $ progress -> clear ( ) ; $ this -> logger -> warning ( $ message ) ; $ progress -> display ( ) ; }
3403	protected function loadFromYml ( $ file ) { $ this -> parser = new Parser ( $ file ) ; $ this -> parser -> load ( $ this ) ; }
11397	public static function parseFault ( \ SimpleXMLElement $ fault ) { $ faultData = static :: parseStruct ( $ fault -> value -> struct ) ; return new \ Devedge \ XmlRpc \ Client \ RemoteException ( $ faultData [ 'faultString' ] , $ faultData [ 'faultCode' ] ) ; }
8216	private function getNextJob ( $ tube , $ state ) { if ( 'ready' == $ this -> state ) { return $ this -> reserveJob ( $ tube ) ; } return $ this -> peekJob ( $ tube , $ state ) ; }
12213	public function getMiddleware ( $ name , $ arguments = null ) { if ( $ this -> existsMiddleware ( $ name ) ) { return $ this -> middlewares [ $ name ] ( ) ; } return false ; }
10329	public function set_images ( $ post_id , $ post , $ update ) { App :: setCurrentID ( 'EFG' ) ; if ( Module :: CustomImagesGrifus ( ) -> getOption ( 'replace-when-add' ) ) { $ is_insert_post = App :: main ( ) -> is_after_insert_post ( $ post , $ update ) ; $ is_update_post = App :: main ( ) -> is_after_update_post ( $ post , $ update ) ; if ( $ is_insert_post || $ is_update_post ) { $ this -> model -> set_images ( $ post_id ) ; } } }
2124	public function getFileUrls ( ) { $ return = array ( ) ; $ strTarget = substr ( $ this -> strMode , 1 ) ; foreach ( $ this -> arrFiles as $ arrFile ) { if ( $ arrFile [ 'extension' ] == self :: SCSS || $ arrFile [ 'extension' ] == self :: LESS ) { $ strPath = 'assets/' . $ strTarget . '/' . str_replace ( '/' , '_' , $ arrFile [ 'name' ] ) . $ this -> strMode ; if ( Config :: get ( 'debugMode' ) || ! file_exists ( $ this -> strRootDir . '/' . $ strPath ) ) { $ objFile = new File ( $ strPath ) ; $ objFile -> write ( $ this -> handleScssLess ( file_get_contents ( $ this -> strRootDir . '/' . $ arrFile [ 'name' ] ) , $ arrFile ) ) ; $ objFile -> close ( ) ; } $ return [ ] = $ strPath . '|' . $ arrFile [ 'version' ] ; } else { $ name = $ arrFile [ 'name' ] ; if ( strncmp ( $ name , $ this -> strWebDir . '/' , \ strlen ( $ this -> strWebDir ) + 1 ) === 0 ) { $ name = substr ( $ name , \ strlen ( $ this -> strWebDir ) + 1 ) ; } if ( $ this -> strMode == self :: CSS && $ arrFile [ 'media' ] != '' && $ arrFile [ 'media' ] != 'all' && ! $ this -> hasMediaTag ( $ arrFile [ 'name' ] ) ) { $ name .= '|' . $ arrFile [ 'media' ] ; } $ return [ ] = $ name . '|' . $ arrFile [ 'version' ] ; } } return $ return ; }
7613	public function sendEmail ( ) { $ user = User :: findOne ( [ 'status' => User :: STATUS_ACTIVE , 'email' => $ this -> email , ] ) ; if ( $ user ) { $ user -> generatePasswordResetToken ( ) ; if ( $ user -> save ( ) ) { return \ Yii :: $ app -> mailer -> compose ( '@auth/views/mail/passwordResetToken' , [ 'user' => $ user ] ) -> setFrom ( [ \ Yii :: $ app -> getModule ( 'auth' ) -> supportEmail => \ Yii :: $ app -> name ] ) -> setTo ( $ this -> email ) -> setSubject ( Yii :: t ( 'auth.reset-password' , 'Password reset for {name}' , [ 'name' => \ Yii :: $ app -> name ] ) ) -> send ( ) ; } } return false ; }
3532	public static function sendFortnitePostRequest ( $ endpoint , $ access_token , $ params = null ) { $ client = new Client ( ) ; try { $ response = $ client -> post ( $ endpoint , [ 'json' => $ params , 'headers' => [ 'User-Agent' => self :: FORTNITE_USER_AGENT , 'Authorization' => 'bearer ' . $ access_token ] ] ) ; return json_decode ( $ response -> getBody ( ) -> getContents ( ) ) ; } catch ( GuzzleException $ e ) { throw $ e ; } }
3512	public function getInsertTranslationsElement ( $ translation , $ timeStamp ) { return '(' . self :: dbValue ( $ translation -> status , Translation :: STATUS_SAVED ) . ',' . self :: dbValue ( $ translation -> locale ) . ',' . self :: dbValue ( $ translation -> group ) . ',' . self :: dbValue ( $ translation -> key ) . ',' . self :: dbValue ( $ translation -> value ) . ',' . self :: dbValue ( $ translation -> created_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> updated_at , $ timeStamp ) . ',' . self :: dbValue ( $ translation -> source ) . ',' . self :: dbValue ( $ translation -> saved_value ) . ',' . self :: dbValue ( $ translation -> is_deleted , 0 ) . ',' . self :: dbValue ( $ translation -> was_used , 0 ) . ')' ; }
2854	public function getFileUpdatesWithHandle ( $ handle , $ storeId , $ area ) { $ updateFiles = Mage :: helper ( 'sheep_debug' ) -> getLayoutUpdatesFiles ( $ storeId , $ area ) ; $ designPackage = Mage :: getModel ( 'core/design_package' ) ; $ designPackage -> setStore ( $ storeId ) ; $ designPackage -> setArea ( $ area ) ; $ designPackageName = $ designPackage -> getPackageName ( ) ; $ layoutTheme = $ designPackage -> getTheme ( 'layout' ) ; $ handleFiles = array ( ) ; foreach ( $ updateFiles as $ file ) { $ filename = $ designPackage -> getLayoutFilename ( $ file , array ( '_area' => $ area , '_package' => $ designPackageName , '_theme' => $ layoutTheme ) ) ; if ( ! is_readable ( $ filename ) ) { continue ; } $ fileXml = $ this -> loadXmlFile ( $ filename ) ; if ( $ fileXml === false ) { continue ; } $ relativeFilename = str_replace ( $ this -> getBaseDir ( ) , '' , $ filename ) ; $ results = $ fileXml -> xpath ( "/layout/{$handle}" ) ; if ( $ results ) { $ handleFiles [ $ relativeFilename ] = array ( ) ; foreach ( $ results as $ result ) { $ handleFiles [ $ relativeFilename ] [ ] = $ result -> asXML ( ) ; } } } return $ handleFiles ; }
10711	public function getManyByIds ( array $ ids , $ columns = [ '*' ] ) { $ results = $ this -> getQuery ( ) -> findMany ( $ ids , $ columns ) ; return $ this -> returnResults ( $ results ) ; }
12562	public function sendText ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_TEXT , $ message , $ to ) ; }
2100	public static function getNumericTimeFormat ( ) { if ( TL_MODE == 'FE' ) { global $ objPage ; if ( $ objPage -> timeFormat != '' && static :: isNumericFormat ( $ objPage -> timeFormat ) ) { return $ objPage -> timeFormat ; } } return Config :: get ( 'timeFormat' ) ; }
12346	private function createDeleteForm ( Post $ post ) { return $ this -> createFormBuilder ( ) -> setAction ( $ this -> generateUrl ( 'blog_category_delete' , array ( 'id' => $ post -> getId ( ) ) ) ) -> setMethod ( 'DELETE' ) -> getForm ( ) ; }
4911	protected function injectComponents ( array $ pages , $ routeMatch = null , $ router = null , $ request = null ) { if ( $ routeMatch ) { $ routeName = $ routeMatch -> getMatchedRouteName ( ) ; foreach ( $ pages as & $ page ) { if ( isset ( $ page [ 'active_on' ] ) && in_array ( $ routeName , ( array ) $ page [ 'active_on' ] ) ) { $ page [ 'active' ] = true ; } } } return parent :: injectComponents ( $ pages , $ routeMatch , $ router , $ request ) ; }
3178	public function getItemClasses ( ) { $ itemClass = $ this -> getClass ( self :: ITEM_ROOT_CLASS_URI ) ; return $ this -> getResourceService ( ) -> getAllClasses ( $ itemClass ) ; }
3002	public function setContent ( $ data , $ mime , $ charset = NULL ) { if ( ! $ charset ) $ charset = $ this -> charset ; $ this -> message [ $ mime ] = [ 'content' => $ data , 'type' => $ mime . '; ' . $ charset ] ; }
5340	public function setBalancingMode ( $ haipName , $ balancingMode , $ cookieName = '' ) { return $ this -> call ( self :: SERVICE , 'setBalancingMode' , [ $ haipName , $ balancingMode , $ cookieName ] ) ; }
1369	protected function bindInboundRequest ( ) { $ this -> app -> singleton ( JsonApiRequest :: class ) ; $ this -> app -> alias ( JsonApiRequest :: class , 'json-api.request' ) ; $ this -> app -> singleton ( Route :: class , function ( Application $ app ) { return new Route ( $ app -> make ( ResolverInterface :: class ) , $ app -> make ( 'router' ) -> current ( ) ) ; } ) ; $ this -> app -> bind ( StoreInterface :: class , function ( ) { return json_api ( ) -> getStore ( ) ; } ) ; $ this -> app -> bind ( ResolverInterface :: class , function ( ) { return json_api ( ) -> getResolver ( ) ; } ) ; $ this -> app -> bind ( ErrorRepositoryInterface :: class , function ( ) { return json_api ( ) -> getErrors ( ) ; } ) ; $ this -> app -> bind ( ContainerInterface :: class , function ( ) { return json_api ( ) -> getContainer ( ) ; } ) ; $ this -> app -> singleton ( HeaderParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createHeaderParametersParser ( ) ; $ serverRequest = $ app -> make ( ServerRequestInterface :: class ) ; return $ parser -> parse ( $ serverRequest , http_contains_body ( $ serverRequest ) ) ; } ) ; $ this -> app -> singleton ( EncodingParametersInterface :: class , function ( Application $ app ) { $ parser = $ app -> make ( HttpFactoryInterface :: class ) -> createQueryParametersParser ( ) ; return $ parser -> parseQueryParameters ( request ( ) -> query ( ) ) ; } ) ; }
5724	protected function getToplevelController ( ) { $ c = $ this -> owner -> getController ( ) ; while ( $ c && $ c instanceof GridFieldDetailForm_ItemRequest ) { $ c = $ c -> getController ( ) ; } return $ c ; }
12055	public function get ( $ name ) { if ( ! isset ( $ this -> container [ $ name ] ) ) { throw new RuntimeException ( sprintf ( 'Module "%s" is not found' , $ name ) ) ; } return $ this -> container [ $ name ] ; }
4689	public function groupBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> group = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'group' ] = $ args ; return $ this ; }
5909	public function retrieveUser ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/accounts/users/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new User ( $ result ) ; return $ result ; }
7817	public function secret ( string $ secret = '' ) : self { if ( empty ( $ secret ) ) { $ secret = str_random ( 15 ) ; } $ this -> secret = $ secret ; return $ this ; }
8103	private function buildQuery ( $ sql , $ arguments = null ) { if ( is_array ( $ arguments ) ) { $ finalArgs = array ( ) ; foreach ( $ arguments as $ field => $ val ) { $ finalArgs [ ] = " {$field}=:{$field}" ; } $ finalArgs = implode ( ' AND' , $ finalArgs ) ; if ( strpos ( $ sql , ' _arguments_' ) ) { $ sql = str_replace ( ' _arguments_' , $ finalArgs , $ sql ) ; } else { } } $ sql = str_replace ( ' _table_' , " {$this->tableName} " , $ sql ) ; return $ sql ; }
1315	public function get ( $ path , array $ parameters = [ ] ) { return $ this -> http ( 'GET' , self :: API_HOST , $ path , $ parameters , false ) ; }
1156	public function sometimes ( $ attribute , $ rules , callable $ callback ) { $ this -> validator -> sometimes ( $ attribute , $ rules , $ callback ) ; }
11521	public function off ( $ eventType , $ listener = null ) { foreach ( $ this -> _eventListeners as $ i => $ l ) { if ( $ l -> getType ( ) == $ eventType ) { if ( $ listener === null || $ l -> getListener ( ) === $ listener ) { unset ( $ this -> _eventListeners [ $ i ] ) ; } } } }
8036	public static function convert ( $ input , $ outputFormat = Code :: FORMAT_ALNUM , $ minLength = null ) { if ( is_int ( $ minLength ) ) { $ input += self :: getMinForlength ( $ outputFormat , $ minLength ) ; } static :: throwUnlessAcceptable ( $ outputFormat , $ input ) ; return self :: convertBase ( $ input , self :: FORMAT_NUMBER , $ outputFormat ) ; }
8034	private function buildAttributesFromLdap ( $ entry ) { $ this -> attributes [ 'dn' ] = $ entry [ 'dn' ] ; foreach ( $ entry as $ index => $ key ) { if ( array_key_exists ( $ index , config ( 'ldap.search_fields' ) ) ) { $ this -> attributes [ $ key ] = isset ( $ entry [ $ key ] [ 1 ] ) ? $ entry [ $ key ] : $ entry [ $ key ] [ 0 ] ; } } ; }
612	public function setSingleton ( $ class , $ definition = [ ] , array $ params = [ ] ) { $ this -> _definitions [ $ class ] = $ this -> normalizeDefinition ( $ class , $ definition ) ; $ this -> _params [ $ class ] = $ params ; $ this -> _singletons [ $ class ] = null ; return $ this ; }
5399	public function setHost ( $ host ) { if ( $ host = $ this -> truncateHost ( $ host ) ) { $ this -> host = $ host ; return true ; } return false ; }
5782	public function routeGetDelete ( Request $ request , Response $ response , $ args ) { if ( ! $ this -> authorization -> isAuthorized ( ROLES_DELETE_RESOURCE ) ) { throw new \ Exception ( 'No permission.' ) ; } $ primaryKey = $ args [ ROUTEARG_PRIMARY_KEY ] ; $ tableName = $ this -> tableMapper -> getFormalTableName ( false ) ; $ primaryKeyColumnName = $ this -> tableMapper -> getPrimaryKeyColumnName ( ) ; try { $ this -> tableMapper -> deleteByPrimaryKey ( $ primaryKey ) ; $ this -> events -> insertInfo ( EVENT_ROLE_DELETE , [ $ primaryKeyColumnName => $ primaryKey ] ) ; SlimPostgres :: setAdminNotice ( "Deleted $tableName $primaryKey" ) ; } catch ( Exceptions \ UnallowedActionException $ e ) { $ this -> events -> insertWarning ( EVENT_UNALLOWED_ACTION , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryResultsNotFoundException $ e ) { define ( 'EVENT_QUERY_NO_RESULTS' , 'Query Results Not Found' ) ; $ this -> events -> insertWarning ( EVENT_QUERY_NO_RESULTS , $ e -> getMessage ( ) ) ; SlimPostgres :: setAdminNotice ( $ e -> getMessage ( ) , 'failure' ) ; } catch ( Exceptions \ QueryFailureException $ e ) { $ this -> events -> insertError ( EVENT_QUERY_FAIL , [ 'error' => $ e -> getMessage ( ) ] ) ; SlimPostgres :: setAdminNotice ( 'Delete Failed' , 'failure' ) ; } return $ response -> withRedirect ( $ this -> router -> pathFor ( SlimPostgres :: getRouteName ( true , $ this -> routePrefix , 'index' ) ) ) ; }
396	public static function deleteAll ( $ condition = null , $ params = [ ] ) { $ command = static :: getDb ( ) -> createCommand ( ) ; $ command -> delete ( static :: tableName ( ) , $ condition , $ params ) ; return $ command -> execute ( ) ; }
7513	function next_no_whitespace ( ) { $ this -> token_start = null ; while ( ++ $ this -> pos < $ this -> size ) { if ( ! isset ( $ this -> whitespace [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( isset ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { if ( is_string ( $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ) { return ( $ this -> token = $ this -> { $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] } ( ) ) ; } else { return ( $ this -> token = $ this -> char_map [ $ this -> doc [ $ this -> pos ] ] ) ; } } else { return ( $ this -> token = self :: TOK_UNKNOWN ) ; } } else { $ this -> parse_linebreak ( ) ; } } return ( $ this -> token = self :: TOK_NULL ) ; }
9862	private function writeSheetFormatPr ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'sheetFormatPr' ) ; if ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'customHeight' , 'true' ) ; $ objWriter -> writeAttribute ( 'defaultRowHeight' , StringHelper :: formatNumber ( $ pSheet -> getDefaultRowDimension ( ) -> getRowHeight ( ) ) ) ; } else { $ objWriter -> writeAttribute ( 'defaultRowHeight' , '14.4' ) ; } if ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) == '1' || strtolower ( ( string ) $ pSheet -> getDefaultRowDimension ( ) -> getZeroHeight ( ) ) == 'true' ) { $ objWriter -> writeAttribute ( 'zeroHeight' , '1' ) ; } if ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) >= 0 ) { $ objWriter -> writeAttribute ( 'defaultColWidth' , StringHelper :: formatNumber ( $ pSheet -> getDefaultColumnDimension ( ) -> getWidth ( ) ) ) ; } $ outlineLevelRow = 0 ; foreach ( $ pSheet -> getRowDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelRow ) { $ outlineLevelRow = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelRow' , ( int ) $ outlineLevelRow ) ; $ outlineLevelCol = 0 ; foreach ( $ pSheet -> getColumnDimensions ( ) as $ dimension ) { if ( $ dimension -> getOutlineLevel ( ) > $ outlineLevelCol ) { $ outlineLevelCol = $ dimension -> getOutlineLevel ( ) ; } } $ objWriter -> writeAttribute ( 'outlineLevelCol' , ( int ) $ outlineLevelCol ) ; $ objWriter -> endElement ( ) ; }
2158	public function run292Update ( ) { $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startTime` `startTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endTime` `endTime` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `startDate` `startDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "ALTER TABLE `tl_calendar_events` CHANGE `endDate` `endDate` int(10) unsigned NULL" ) ; $ this -> Database -> query ( "UPDATE tl_calendar_events SET endDate=null WHERE endDate=0" ) ; }
3949	private function buildCaption ( $ metaModel , $ inputScreen ) : array { $ caption = [ sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'metamodel_edit_as_child' ] [ 'label' ] , $ metaModel -> getName ( ) ) , '' ] ; foreach ( $ inputScreen [ 'label' ] as $ langCode => $ label ) { if ( $ label !== '' && $ langCode === $ GLOBALS [ 'TL_LANGUAGE' ] ) { $ caption = [ $ label , $ inputScreen [ 'description' ] [ $ langCode ] ] ; } } return $ caption ; }
11102	public static function countryCodeThreeToTwo ( $ code ) { if ( ! array_key_exists ( $ code , self :: $ _countryCodes ) ) { return false ; } return self :: $ _countryCodes [ $ code ] ; }
12678	public function toJSON ( $ pretty = false ) { if ( $ pretty ) { return json_encode ( $ this -> scope -> results , JSON_PRETTY_PRINT ) ; } return json_encode ( $ this -> scope -> results ) ; }
2562	protected function loadGeoCode ( PointOfRefSearchOptions $ params ) { if ( $ this -> checkAllNotEmpty ( $ params -> latitude , $ params -> longitude ) ) { $ this -> porFndQryParams -> geoCode = new GeoCode ( $ params -> longitude , $ params -> latitude ) ; } }
10006	public function getRibbonXMLData ( $ what = 'all' ) { $ returnData = null ; $ what = strtolower ( $ what ) ; switch ( $ what ) { case 'all' : $ returnData = $ this -> ribbonXMLData ; break ; case 'target' : case 'data' : if ( is_array ( $ this -> ribbonXMLData ) && isset ( $ this -> ribbonXMLData [ $ what ] ) ) { $ returnData = $ this -> ribbonXMLData [ $ what ] ; } break ; } return $ returnData ; }
5227	public function bindList ( $ name ) { if ( ! isset ( $ this -> listBindings [ $ name ] ) ) { $ this -> listBindings [ $ name ] = $ this -> addBinding ( new ListBinding ( $ name ) ) ; } return $ this -> listBindings [ $ name ] ; }
2323	public static function get ( ) { $ container = System :: getContainer ( ) ; return $ container -> get ( 'contao.csrf.token_manager' ) -> getToken ( $ container -> getParameter ( 'contao.csrf_token_name' ) ) -> getValue ( ) ; }
5634	protected function handle ( & $ test , $ filename ) { if ( preg_match ( $ this -> pattern , $ filename ) ) { parent :: handle ( $ test , $ filename ) ; } }
12254	public function addCompiler ( $ compiler ) { if ( $ compiler instanceof CompilerFactoryInterface || $ compiler instanceof CompilerInterface ) { $ this -> compilers [ ] = $ compiler ; $ this -> orderedCompilers = NULL ; } else throw new CompilerException ( "Can only add objects that implement CompilerInterface or CompilerFactoryInterface to context" ) ; }
7726	public function postback ( $ text , $ title , $ postback ) { $ payload = [ 'template_type' => 'button' , 'text' => $ text , 'buttons' => [ [ 'type' => 'postback' , 'title' => $ title , 'payload' => $ postback ] ] , ] ; $ this -> setAttachment ( 'template' , $ payload ) ; return $ this ; }
6503	public function produce ( Message $ message ) { $ type = $ message -> getType ( ) ; $ body = array ( 'ticket' => $ message -> getTicket ( ) ) ; try { $ this -> logger -> debug ( sprintf ( 'Publish message for job %s to sonata backend' , $ message -> getTicket ( ) ) , [ 'type' => $ type , 'body' => $ body ] ) ; $ queue = $ this -> registry -> get ( $ message -> getType ( ) ) -> getQueue ( ) ; $ this -> backendProvider -> getBackend ( $ queue ) -> createAndPublish ( $ type , $ body ) ; } catch ( \ Exception $ e ) { $ this -> logger -> error ( sprintf ( 'Failed to publish message (Error: %s)' , $ e -> getMessage ( ) ) , [ 'exception' => $ e ] ) ; if ( ! $ e instanceof \ RuntimeException ) { $ e = new \ RuntimeException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } throw $ e ; } }
2429	public static function initializeApplication ( Event $ event ) : void { $ webDir = self :: getWebDir ( $ event ) ; static :: purgeCacheFolder ( ) ; static :: addAppDirectory ( ) ; static :: executeCommand ( 'contao:install-web-dir' , $ event ) ; static :: executeCommand ( 'cache:clear --no-warmup' , $ event ) ; static :: executeCommand ( 'cache:warmup' , $ event ) ; static :: executeCommand ( sprintf ( 'assets:install %s --symlink --relative' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:install %s' , $ webDir ) , $ event ) ; static :: executeCommand ( sprintf ( 'contao:symlinks %s' , $ webDir ) , $ event ) ; $ event -> getIO ( ) -> write ( '<info>Done! Please open the Contao install tool and make sure the database is up-to-date.</info>' ) ; }
3853	public function overrideOutputFormat ( $ strOutputFormat = null ) { $ strOutputFormat = strval ( $ strOutputFormat ) ; if ( strlen ( $ strOutputFormat ) ) { $ this -> strOutputFormat = $ strOutputFormat ; } else { unset ( $ this -> strOutputFormat ) ; } return $ this ; }
11154	public function getArrayKeyByPowers ( array $ powers ) { if ( empty ( $ powers ) ) { throw new InvalidArgumentException ( 'Empty powers set' ) ; } $ powersSum = 0 ; foreach ( $ powers as $ power ) { if ( $ power < 0 ) { throw new InvalidArgumentException ( 'Negative power found' ) ; } $ powersSum += $ power ; } if ( $ powersSum <= 0 ) { throw new InvalidArgumentException ( 'The sum of powers must be positive' ) ; } $ randomValue = $ this -> generator -> getFloat ( 0 , $ powersSum ) ; $ currentSum = 0 ; $ result = null ; foreach ( $ powers as $ key => $ power ) { $ currentSum += $ power ; if ( $ currentSum >= $ randomValue ) { $ result = $ key ; break ; } } return $ key ; }
1425	protected function getRelationshipPaths ( $ includePaths ) { return $ this -> convertIncludePaths ( $ includePaths ) -> merge ( $ this -> defaultWith ) -> unique ( ) -> all ( ) ; }
3782	public function modelToLabel ( ModelToLabelEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ model = $ event -> getModel ( ) ; $ type = $ model -> getProperty ( 'type' ) ; $ image = '<img src="' . $ this -> attributeFactory -> getIconForType ( $ type ) . '" />' ; $ metaModel = $ this -> getMetaModelByModelPid ( $ model ) ; $ attribute = $ this -> attributeFactory -> createAttribute ( $ model -> getPropertiesAsArray ( ) , $ metaModel ) ; if ( ! $ attribute ) { $ translator = $ event -> getEnvironment ( ) -> getTranslator ( ) ; $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> <strong>%s</strong><br /> </div>' ) -> setArgs ( array ( $ translator -> translate ( 'error_unknown_attribute.0' , 'tl_metamodel_attribute' ) , $ type , $ translator -> translate ( 'error_unknown_attribute.1' , 'tl_metamodel_attribute' , array ( $ type ) ) , ) ) ; return ; } $ colName = $ attribute -> getColName ( ) ; $ name = $ attribute -> getName ( ) ; $ arrDescription = StringUtil :: deserialize ( $ attribute -> get ( 'description' ) ) ; if ( is_array ( $ arrDescription ) ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getActiveLanguage ( ) ] ; if ( ! $ description ) { $ description = $ arrDescription [ $ attribute -> getMetaModel ( ) -> getFallbackLanguage ( ) ] ; } } else { $ description = $ arrDescription ? : $ attribute -> getName ( ) ; } $ event -> setLabel ( '<div class="field_heading cte_type"><strong>%s</strong> <em>[%s]</em></div> <div class="field_type block"> %s<strong>%s</strong> - %s </div>' ) -> setArgs ( array ( $ colName , $ type , $ image , $ name , $ description ) ) ; }
932	public function clearChanged ( ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0.' , E_USER_DEPRECATED ) ; Tokens :: setLegacyMode ( true ) ; $ this -> changed = false ; }
7568	protected function parse ( ) { $ p = & $ this -> parser ; $ p -> setPos ( 0 ) ; $ this -> result = array ( ) ; if ( ! $ this -> parse_single ( ) ) { return false ; } while ( count ( $ this -> result ) > 0 ) { switch ( $ p -> token ) { case CSSQueryTokenizer :: TOK_CHILD : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( false , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_SIBLING : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_result ( true , 1 ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_PLUS : $ this -> parser -> next_no_whitespace ( ) ; if ( ! $ this -> parse_adjacent ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_ALL : case CSSQueryTokenizer :: TOK_IDENTIFIER : case CSSQueryTokenizer :: TOK_STRING : case CSSQueryTokenizer :: TOK_BRACE_OPEN : case CSSQueryTokenizer :: TOK_BRACKET_OPEN : case CSSQueryTokenizer :: TOK_ID : case CSSQueryTokenizer :: TOK_CLASS : case CSSQueryTokenizer :: TOK_COLON : if ( ! $ this -> parse_result ( ) ) { return false ; } break ; case CSSQueryTokenizer :: TOK_NULL : break 2 ; default : $ this -> error ( 'Invalid search pattern(3): No result modifier found!' ) ; return false ; } } return true ; }
10859	protected function cacheMarkers ( string $ marker ) : void { $ this -> marked [ $ marker ] = [ ] ; foreach ( $ this -> definitions as $ definition ) { foreach ( ( array ) $ definition -> markers as $ m ) { if ( $ m instanceof $ marker ) { $ this -> marked [ $ marker ] [ ] = [ $ definition , $ m ] ; } } } }
12360	public static function encodeHashId ( $ id ) { if ( ! config ( 'odin.hashid.active' ) ) { return $ id ; } $ hashids = App :: make ( 'Hashids' ) ; return $ hashids -> encode ( $ id , date ( 'd' ) ) ; }
8171	public function renderString ( $ tplString = '' , $ tplData = [ ] ) { try { return $ this -> twig -> createTemplate ( $ tplString ) -> render ( $ tplData ) ; } catch ( Twig_Error $ err ) { return $ this -> error ( $ err , false , $ tplString ) ; } }
8228	protected function assertLimits ( ) { if ( $ this -> storage -> getUsersCount ( ) >= $ this -> config [ "maxUsers" ] ) { $ this -> session -> addFlash ( "error" , "New registrations are currently disabled." ) ; $ this -> picoAuth -> redirectToPage ( "register" ) ; } }
4519	public function get ( string $ key ) { $ parameter = $ this -> repository -> findOneBy ( [ 'key' => $ key ] ) ; if ( ! $ parameter ) { throw new OutOfRangeException ( 'Parameter "' . $ key . '" does not exist.' ) ; } $ this -> manager -> detach ( $ parameter ) ; return $ parameter -> getValue ( ) ; }
9263	private function addNamedRoute ( $ name , $ httpMethod , $ route , $ handler ) { if ( ! ( $ this -> dataGenerator instanceof NamedDataGeneratorInterface ) ) { throw new \ RuntimeException ( 'The injected generator does not support named routes' ) ; } $ routeData = $ this -> routeParser -> parse ( $ route ) ; foreach ( $ routeData as $ routeDatum ) { $ this -> dataGenerator -> addNamedRoute ( $ name , $ httpMethod , $ routeDatum , $ handler ) ; } }
7449	public function exec ( string $ execfile , array $ args ) : bool { return $ this -> process -> exec ( $ execfile , $ args ) ; }
231	public function insert ( $ table , $ columns ) { $ command = $ this -> db -> createCommand ( ) -> insert ( $ table , $ columns ) ; if ( ! $ command -> execute ( ) ) { return false ; } $ tableSchema = $ this -> getTableSchema ( $ table ) ; $ result = [ ] ; foreach ( $ tableSchema -> primaryKey as $ name ) { if ( $ tableSchema -> columns [ $ name ] -> autoIncrement ) { $ result [ $ name ] = $ this -> getLastInsertID ( $ tableSchema -> sequenceName ) ; break ; } $ result [ $ name ] = isset ( $ columns [ $ name ] ) ? $ columns [ $ name ] : $ tableSchema -> columns [ $ name ] -> defaultValue ; } return $ result ; }
1930	public function attachFile ( $ strFile , $ strMime = 'application/octet-stream' ) { $ this -> objMessage -> attach ( \ Swift_Attachment :: fromPath ( $ strFile , $ strMime ) -> setFilename ( basename ( $ strFile ) ) ) ; }
2475	public function deleteContent ( $ contentId , $ versionId = null ) { $ idPrefix = $ this -> mapper -> generateContentDocumentId ( $ contentId ) ; $ this -> gateway -> deleteByQuery ( "_root_:{$idPrefix}*" ) ; }
8576	public function setItemChargeAdjustmentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ItemChargeAdjustmentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
7602	public function render ( FormInterface $ oForm , $ sMessage , $ bDismissable = false ) { $ errorHtml = sprintf ( $ this -> messageOpenFormat , $ sMessage ) ; $ sMessagesArray = array ( ) ; foreach ( $ oForm -> getMessages ( ) as $ fieldName => $ sMessages ) { foreach ( $ sMessages as $ sMessage ) { if ( $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) ) { $ sMessagesArray [ ] = sprintf ( '<a href="#%s">%s</a>' , $ oForm -> get ( $ fieldName ) -> getAttribute ( 'id' ) , $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ) ; } else { $ sMessagesArray [ ] = $ oForm -> get ( $ fieldName ) -> getLabel ( ) . ': ' . $ sMessage ; } } } return $ this -> dangerAlert ( $ errorHtml . implode ( $ this -> messageSeparatorString , $ sMessagesArray ) . $ this -> messageCloseString , $ bDismissable ) ; }
3228	function doGet ( $ host , $ path , $ params = null ) { Checker :: argString ( "host" , $ host ) ; Checker :: argString ( "path" , $ path ) ; return RequestUtil :: doGet ( $ this -> clientIdentifier , $ this -> accessToken , $ this -> userLocale , $ host , $ path , $ params ) ; }
5325	protected function lockExecute ( callable $ task ) { if ( $ this -> mutex -> isAcquired ( ) ) { return $ task ( ) ; } return $ this -> mutex -> lockExecute ( $ task ) ; }
11568	public function count ( ) { if ( is_null ( $ this -> recordSet ) ) { $ this -> fetchData ( ) ; } if ( is_null ( $ this -> recordcount ) ) { $ this -> recordcount = $ this -> recordSet -> RecordCount ( ) ; } return $ this -> recordcount ; }
4404	public function getPath ( $ locationId ) { $ pathArray = array ( ) ; $ startingLocation = $ this -> locationService -> loadLocation ( $ locationId ) ; $ path = $ startingLocation -> path ; array_shift ( $ path ) ; $ rootLocationFound = false ; foreach ( $ path as $ index => $ pathItem ) { if ( ( int ) $ pathItem === $ this -> rootLocationId ) { $ rootLocationFound = true ; } if ( ! $ rootLocationFound ) { continue ; } try { $ location = $ this -> locationService -> loadLocation ( $ pathItem ) ; } catch ( UnauthorizedException $ e ) { return array ( ) ; } $ pathArray [ ] = array ( 'text' => $ this -> translationHelper -> getTranslatedContentNameByContentInfo ( $ location -> contentInfo ) , 'url' => $ location -> id !== $ startingLocation -> id ? $ this -> router -> generate ( $ location ) : false , 'locationId' => $ location -> id , 'contentId' => $ location -> contentId , ) ; } return $ pathArray ; }
8721	protected function getTranslatableAttributesFromSchema ( ) { if ( ( ! $ con = $ this -> getConnection ( ) ) || ( ! $ builder = $ con -> getSchemaBuilder ( ) ) ) { return [ ] ; } if ( $ columns = TranslatableConfig :: cacheGet ( $ this -> getI18nTable ( ) ) ) { return $ columns ; } $ columns = $ builder -> getColumnListing ( $ this -> getI18nTable ( ) ) ; unset ( $ columns [ array_search ( $ this -> getForeignKey ( ) , $ columns ) ] ) ; TranslatableConfig :: cacheSet ( $ this -> getI18nTable ( ) , $ columns ) ; return $ columns ; }
10211	function fromXML ( $ xmlElement ) { if ( isset ( $ xmlElement -> id ) ) $ this -> id = $ xmlElement -> id ; $ this -> email = ( string ) $ xmlElement -> email ; if ( isset ( $ xmlElement -> permission ) ) $ this -> permission = Permission :: getPermission ( ( string ) $ xmlElement -> permission ) ; if ( isset ( $ xmlElement -> external_id ) ) ( string ) $ this -> external_id = $ xmlElement -> external_id ; if ( isset ( $ xmlElement -> anonymous ) ) ( string ) $ this -> anonymous = $ xmlElement -> anonymous ; if ( isset ( $ xmlElement [ 'anonymous' ] ) ) $ this -> anonymous = $ xmlElement [ 'anonymous' ] ; if ( isset ( $ xmlElement -> created ) ) $ this -> created = $ xmlElement -> created ; if ( isset ( $ xmlElement -> updated ) ) $ this -> updated = $ xmlElement -> updated ; if ( isset ( $ xmlElement -> standard_fields ) ) { $ this -> standard_fields = array ( ) ; foreach ( $ xmlElement -> standard_fields -> children ( ) as $ field ) { $ this -> standard_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } if ( isset ( $ xmlElement -> custom_fields ) ) { foreach ( $ xmlElement -> custom_fields -> children ( ) as $ field ) { $ this -> custom_fields [ trim ( $ field -> name ) ] = ( string ) $ field -> value ; } } }
6513	public function copyJob ( JobInterface $ from , \ Abc \ Bundle \ JobBundle \ Model \ JobInterface $ to ) { $ to -> setType ( $ from -> getType ( ) ) ; $ to -> setResponse ( $ from -> getResponse ( ) ) ; $ to -> setParameters ( $ from -> getParameters ( ) ) ; if ( null != $ from -> getStatus ( ) ) { $ to -> setStatus ( $ from -> getStatus ( ) ) ; } foreach ( $ from -> getSchedules ( ) as $ schedule ) { $ to -> addSchedule ( $ schedule ) ; } return $ to ; }
12944	function setDefaultQueues ( array $ defaultQueues ) { $ this -> _defaults = $ defaultQueues ; $ queues = StdArray :: of ( $ this -> queues ) -> withMergeRecursive ( $ defaultQueues , true ) ; $ this -> queues = $ queues -> value ; return $ this ; }
4115	public function getRemoteCallUrlTemplate ( ) { if ( is_null ( $ this -> remoteCallUrlTemplate ) ) { $ this -> remoteCallUrlTemplate = Mage :: getStoreConfig ( 'dev/aoe_templatehints/remoteCallUrlTemplate' ) ; } return $ this -> remoteCallUrlTemplate ; }
9198	public function getRedirectUrlForAuth ( ) { $ oauth = new Oauth1 ( array ( 'consumer_key' => $ this -> credentials -> getConsumerKey ( ) , 'consumer_secret' => $ this -> credentials -> getConsumerSecret ( ) , 'callback' => $ this -> credentials -> getCallbackUrl ( ) ) ) ; $ this -> guzzleClient -> getEmitter ( ) -> attach ( $ oauth ) ; $ requestTokenResponse = $ this -> guzzleClient -> post ( Config :: get ( 'oauth_request_token' ) , array ( 'auth' => 'oauth' ) ) ; $ oauthToken = array ( ) ; parse_str ( $ requestTokenResponse -> getBody ( ) , $ oauthToken ) ; $ params = http_build_query ( array ( 'oauth_token' => $ oauthToken [ 'oauth_token' ] ) ) ; return ( Config :: get ( 'base_url' ) . Config :: get ( 'oauth_authenticate' ) . '?' . $ params ) ; }
3957	public function save ( $ timestamp = null ) { if ( null === $ timestamp ) { @ \ trigger_error ( 'Not passing a timestamp has been deprecated and will cause an error in MetaModels 3' , E_USER_DEPRECATED ) ; } $ objMetaModel = $ this -> getMetaModel ( ) ; $ objMetaModel -> saveItem ( $ this , $ timestamp ) ; }
4581	private function getProperties ( Encryptable $ model ) : array { $ properties = [ ] ; $ reflection = new ReflectionObject ( $ model ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { $ annotation = $ this -> annotationReader -> getPropertyAnnotation ( $ property , Encrypt :: class ) ; if ( ! $ annotation ) { continue ; } if ( null !== $ annotation -> applicable && ! $ this -> expressionLanguage -> evaluate ( $ annotation -> applicable , [ 'object' => $ model ] ) ) { continue ; } $ properties [ ] = $ property ; } return $ properties ; }
9694	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ beginning = $ this -> readBeginning ( ) ; $ startWithTag = self :: startsWithTag ( $ beginning ) ; $ containsTags = self :: containsTags ( $ beginning ) ; $ endsWithTag = self :: endsWithTag ( $ this -> readEnding ( ) ) ; fclose ( $ this -> fileHandle ) ; return $ startWithTag && $ containsTags && $ endsWithTag ; }
8768	protected function registerApplicationAliases ( ) { foreach ( $ this -> config [ 'services' ] [ 'aliases' ] as $ key => $ alias ) { $ this -> alias ( $ key , $ alias ) ; if ( ! class_exists ( $ key ) ) { class_alias ( $ alias , $ key ) ; } } }
12257	public function getProjectSearchPaths ( string $ name ) : array { $ srcPaths = $ this -> getProject ( ) -> getAttribute ( AttributeInterface :: SEARCH_PATHS_ATTR_NAME ) ; if ( $ srcPaths instanceof SearchPathCollection ) { return $ srcPaths -> getSearchPaths ( $ name ) ?? [ ] ; } return [ ] ; }
5763	protected function getFilterFieldValue ( ) : string { if ( isset ( $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMIN_LIST_VIEW_FILTER ] [ $ this -> getFilterKey ( ) ] [ self :: SESSION_FILTER_VALUE_KEY ] ) ) { return $ _SESSION [ SlimPostgres :: SESSION_KEY_ADMIN_LIST_VIEW_FILTER ] [ $ this -> getFilterKey ( ) ] [ self :: SESSION_FILTER_VALUE_KEY ] ; } else { return '' ; } }
6298	public function addToMain ( array $ item , $ name = 'default' , $ first = false ) { if ( ! array_key_exists ( $ name , $ this -> main ) ) { $ this -> main [ $ name ] = [ ] ; } if ( $ first ) { $ this -> main [ $ name ] = array_merge ( [ $ item ] , $ this -> main [ $ name ] ) ; } else { $ this -> main [ $ name ] [ ] = $ item ; } return $ this ; }
7838	public function create ( string $ name , array $ numbers ) : ? array { $ body = Body :: json ( [ [ 'name' => $ name , 'phone_numbers' => $ numbers , ] , ] ) ; $ response = Request :: post ( $ this -> baseUrl . 'contact' , [ ] , $ body ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return [ 'code' => $ response -> code , 'message' => ( $ response -> code == 200 ) ? 'OK' : $ response -> body -> message ?? '' , 'data' => $ response -> body , ] ; }
11357	public function add ( $ blockFile , $ blockContent ) { $ this -> removeBlock ( $ blockFile ) ; $ blockPermalinks = $ this -> fetchPermalinksFromBlock ( $ blockContent , $ blockFile ) ; if ( ! empty ( $ blockPermalinks ) ) { $ this -> permalinks = array_merge_recursive ( $ this -> permalinks , $ blockPermalinks ) ; } return $ this ; }
4293	public function getAbstraction ( & $ mixed , $ method = null , $ hist = array ( ) ) { if ( \ is_array ( $ mixed ) ) { return $ this -> abstractArray -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_object ( $ mixed ) ) { return $ this -> abstractObject -> getAbstraction ( $ mixed , $ method , $ hist ) ; } elseif ( \ is_resource ( $ mixed ) || \ strpos ( \ print_r ( $ mixed , true ) , 'Resource' ) === 0 ) { return array ( 'debug' => self :: ABSTRACTION , 'type' => 'resource' , 'value' => \ print_r ( $ mixed , true ) . ': ' . \ get_resource_type ( $ mixed ) , ) ; } }
7032	public function run ( $ prog = "migrate" ) { switch ( trim ( $ prog ) ) { case "migrate" : return $ this -> migrate ( ) ; case "drop" : return $ this -> drop ( ) ; case "reset" : return $ this -> drop ( ) & $ this -> migrate ( ) ; default : error_log ( "\n\e[1;31m!\e[0m program $prog not applicable\n" ) ; return false ; } }
136	public function execute ( RepositoryInterface $ repo , OperationInterface $ operation ) { $ method = $ operation -> getJobType ( ) ; $ this -> $ method ( $ repo , $ operation ) ; }
2379	public static function deserialize ( $ varValue , $ blnForceArray = false ) { if ( \ is_array ( $ varValue ) ) { return $ varValue ; } if ( $ varValue === null ) { return $ blnForceArray ? array ( ) : null ; } if ( ! \ is_string ( $ varValue ) ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( trim ( $ varValue ) == '' ) { return $ blnForceArray ? array ( ) : '' ; } if ( strncmp ( $ varValue , 'a:' , 2 ) !== 0 ) { return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } if ( preg_match ( '/[OoC]:\+?[0-9]+:"/' , $ varValue ) ) { trigger_error ( 'StringUtil::deserialize() does not allow serialized objects' , E_USER_WARNING ) ; return $ blnForceArray ? array ( $ varValue ) : $ varValue ; } $ varUnserialized = @ unserialize ( $ varValue , array ( 'allowed_classes' => false ) ) ; if ( \ is_array ( $ varUnserialized ) ) { $ varValue = $ varUnserialized ; } elseif ( $ blnForceArray ) { $ varValue = array ( $ varValue ) ; } return $ varValue ; }
131	protected function updateLocalRepo ( ) { $ fs = new Filesystem ( ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( ! is_writable ( dirname ( $ this -> checkoutDir ) ) ) { throw new \ RuntimeException ( 'Can not clone ' . $ this -> url . ' to access package information. The "' . $ this -> checkoutDir . '" directory is not writable by the current user.' ) ; } if ( is_file ( $ this -> repoFile ) && is_dir ( $ this -> checkoutDir ) && 0 === $ this -> process -> execute ( 'fossil info' , $ output , $ this -> checkoutDir ) ) { if ( 0 !== $ this -> process -> execute ( 'fossil pull' , $ output , $ this -> checkoutDir ) ) { $ this -> io -> writeError ( '<error>Failed to update ' . $ this -> url . ', package information from this repository may be outdated (' . $ this -> process -> getErrorOutput ( ) . ')</error>' ) ; } } else { $ fs -> removeDirectory ( $ this -> checkoutDir ) ; $ fs -> remove ( $ this -> repoFile ) ; $ fs -> ensureDirectoryExists ( $ this -> checkoutDir ) ; if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil clone %s %s' , ProcessExecutor :: escape ( $ this -> url ) , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to clone ' . $ this -> url . ' to repository ' . $ this -> repoFile . "\n\n" . $ output ) ; } if ( 0 !== $ this -> process -> execute ( sprintf ( 'fossil open %s --nested' , ProcessExecutor :: escape ( $ this -> repoFile ) ) , $ output , $ this -> checkoutDir ) ) { $ output = $ this -> process -> getErrorOutput ( ) ; throw new \ RuntimeException ( 'Failed to open repository ' . $ this -> repoFile . ' in ' . $ this -> checkoutDir . "\n\n" . $ output ) ; } } }
12535	public function fetchByApplyId ( $ applyId , $ lastSeen , $ count ) { $ params = [ 'type' => 3 , 'apply_id' => intval ( $ applyId ) , 'last_seen' => intval ( $ lastSeen ) , 'count' => intval ( $ count ) , ] ; return $ this -> fetch ( $ params ) ; }
8661	private function convertGetFeedSubmissionResult ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetFeedSubmissionResult' ; if ( $ request -> isSetMarketplace ( ) ) { $ parameters [ 'Marketplace' ] = $ request -> getMarketplace ( ) ; } if ( $ request -> isSetMerchant ( ) ) { $ parameters [ 'Merchant' ] = $ request -> getMerchant ( ) ; } if ( $ request -> isSetFeedSubmissionId ( ) ) { $ parameters [ 'FeedSubmissionId' ] = $ request -> getFeedSubmissionId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } return array ( CONVERTED_PARAMETERS_KEY => $ parameters , CONVERTED_HEADERS_KEY => $ this -> defaultHeaders ) ; }
6061	public function listDeploymentSites ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/deployment/sites' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new DeploymentSiteResponse ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
12537	public function setRelatedObjects ( $ relatedObjects ) { foreach ( $ relatedObjects as $ modelName => $ objects ) { if ( ! isset ( $ this -> _relatedObjects [ $ modelName ] ) ) { $ this -> _relatedObjects [ $ modelName ] = [ ] ; } foreach ( $ objects as $ tabId => $ objectAttributes ) { if ( ! isset ( $ objectAttributes [ '_moduleHandler' ] ) ) { continue ; } list ( $ relationship , $ role ) = $ this -> owner -> objectType -> getRelationship ( $ objectAttributes [ '_moduleHandler' ] ) ; $ relatedHandler = $ this -> owner -> objectType -> getRelatedType ( $ objectAttributes [ '_moduleHandler' ] ) ; if ( ! $ relatedHandler ) { continue ; } $ objectAttributes = array_merge ( [ 'companionObject' => $ this -> owner , 'companionRelationship' => $ relationship , 'companionRole' => $ role , ] , $ objectAttributes ) ; $ object = $ relatedHandler -> getModel ( null , $ objectAttributes ) ; $ object -> tabularId = $ objectAttributes [ '_moduleHandler' ] ; if ( ( ! $ object || $ object -> isEmptyObject ( ) ) && ! ( $ relationship -> required ) ) { continue ; } $ object -> companionObject = $ object -> indirectObject = $ this -> owner ; $ object -> companionRelationship = $ relationship ; $ object -> companionRole = $ role ; $ this -> _relatedObjects [ $ modelName ] [ $ tabId ] = $ object ; $ this -> _relatedObjectsFlat [ ] = $ object ; } } }
8339	public static function get ( string $ fileName ) : array { if ( isset ( self :: $ files [ $ fileName ] ) === false ) { if ( ( $ content = file_get_contents ( $ fileName ) ) === false ) { throw new FileNotReadable ( 'file "' . $ fileName . '" can\'t be read' ) ; } $ content = ( string ) $ content ; try { $ content = Yaml :: parse ( $ content ) ; } catch ( ParseException $ e ) { throw new FileNotParsable ( 'file "' . $ fileName . '" can\'t be parsed' ) ; } self :: $ files [ $ fileName ] = $ content ; } return self :: $ files [ $ fileName ] ; }
6148	public function setBody ( $ body ) { if ( is_string ( $ body ) ) { $ this -> body = $ body ; } elseif ( is_array ( $ body ) ) { $ this -> setJsonBody ( $ body ) ; } elseif ( is_callable ( $ body ) ) { ob_start ( ) ; $ res1 = call_user_func ( $ body ) ; $ res2 = ob_get_contents ( ) ; $ this -> body = $ res2 . $ res1 ; ob_end_clean ( ) ; } return $ this ; }
4549	public function get ( string $ alias ) { $ stat = $ this -> statCollection -> filter ( function ( $ element ) use ( $ alias ) { return $ element -> getAlias ( ) === $ alias ; } ) -> first ( ) ; if ( ! $ stat ) { throw new InvalidAliasException ( 'Stat alias "' . $ alias . '" does not exist.' ) ; } $ datum = $ stat -> get ( ) ; return $ datum ; }
3461	public function use ( $ middleware ) : void { if ( ! is_subclass_of ( $ middleware , MiddlewareInterface :: class ) ) { if ( ! is_callable ( $ middleware ) ) { throw new ApplicationException ( sprintf ( 'Middleware must be either class or object that implements `%s`' , MiddlewareInterface :: class ) ) ; } $ middleware = new CallableMiddleware ( $ middleware ) ; } $ this -> middleware [ ] = $ middleware ; }
11688	public function setCenter ( \ Chill \ MainBundle \ Entity \ Center $ center ) { $ this -> center = $ center ; return $ this ; }
10385	protected static function unify_params ( $ type , $ field , $ default = '' ) { $ data = array_column ( self :: $ data [ $ type ] , $ field ) ; switch ( $ field ) { case 'media' : case 'footer' : case 'version' : foreach ( $ data as $ key => $ value ) { if ( $ data [ 0 ] !== $ value ) { return $ default ; } } return ( isset ( $ data [ 0 ] ) && $ data [ 0 ] ) ? $ data [ 0 ] : $ default ; default : $ params = [ ] ; foreach ( $ data as $ key => $ value ) { $ params = array_merge ( $ params , $ value ) ; } return array_unique ( $ params ) ; } }
4582	public function created ( JWTCreatedEvent $ event ) { $ payload = $ event -> getData ( ) ; $ user = $ event -> getUser ( ) ; $ payload [ $ this -> attribute ] = $ user -> getTenant ( ) ; $ event -> setData ( $ payload ) ; }
1304	public function show ( $ category , $ slug = null ) { if ( ! isset ( $ category ) || ! isset ( $ slug ) ) { return redirect ( config ( 'chatter.routes.home' ) ) ; } $ discussion = Models :: discussion ( ) -> where ( 'slug' , '=' , $ slug ) -> first ( ) ; if ( is_null ( $ discussion ) ) { abort ( 404 ) ; } $ discussion_category = Models :: category ( ) -> find ( $ discussion -> chatter_category_id ) ; if ( $ category != $ discussion_category -> slug ) { return redirect ( config ( 'chatter.routes.home' ) . '/' . config ( 'chatter.routes.discussion' ) . '/' . $ discussion_category -> slug . '/' . $ discussion -> slug ) ; } $ posts = Models :: post ( ) -> with ( 'user' ) -> where ( 'chatter_discussion_id' , '=' , $ discussion -> id ) -> orderBy ( config ( 'chatter.order_by.posts.order' ) , config ( 'chatter.order_by.posts.by' ) ) -> paginate ( 10 ) ; $ chatter_editor = config ( 'chatter.editor' ) ; if ( $ chatter_editor == 'simplemde' ) { \ App :: register ( 'GrahamCampbell\Markdown\MarkdownServiceProvider' ) ; } $ discussion -> increment ( 'views' ) ; return view ( 'chatter::discussion' , compact ( 'discussion' , 'posts' , 'chatter_editor' ) ) ; }
541	protected function serializeModelErrors ( $ model ) { $ this -> response -> setStatusCode ( 422 , 'Data Validation Failed.' ) ; $ result = [ ] ; foreach ( $ model -> getFirstErrors ( ) as $ name => $ message ) { $ result [ ] = [ 'field' => $ name , 'message' => $ message , ] ; } return $ result ; }
1572	public function getProcess ( ) : ? AsynchronousProcess { $ process = $ this -> parameter ( ResourceRegistrar :: PARAM_PROCESS_ID ) ; return ( $ process instanceof AsynchronousProcess ) ? $ process : null ; }
12637	public static function connect ( string $ host = "" , int $ port = 0 , string $ dbname = "" , string $ user = "" , string $ pass = "" , bool $ reconnect = false ) : ? \ PDO { if ( self :: $ pdo !== null && ! $ reconnect ) return self :: $ pdo ; if ( $ host === "" && ( self :: $ databaseHost === null || self :: $ databaseHost === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid host name was not provided!" ) ; $ host = $ host ? : self :: $ databaseHost ; if ( $ port === 0 && ( self :: $ databasePort === null || self :: $ databasePort === 0 ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid port number was not provided!" ) ; $ port = $ port ? : self :: $ databasePort ; if ( $ dbname === "" && ( self :: $ databaseName === null || self :: $ databaseName === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid database name was not provided!" ) ; $ dbname = $ dbname ? : self :: $ databaseName ; if ( $ user === "" && ( self :: $ databaseUser === null || self :: $ databaseUser === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid username was not provided!" ) ; $ user = $ user ? : self :: $ databaseUser ; if ( $ pass === "" && ( self :: $ databasePass === null || self :: $ databasePass === "" ) ) throw new Exceptions \ DatabaseConnectionException ( "A valid password was not provided!" ) ; $ pass = $ pass ? : self :: $ databasePass ; try { self :: $ pdo = new \ PDO ( "pgsql:host=$host;port=$port;dbname=$dbname" , $ user , $ pass , [ \ PDO :: ATTR_DEFAULT_FETCH_MODE => \ PDO :: FETCH_ASSOC , ] ) ; if ( self :: $ pdo ) return self :: $ pdo ; } catch ( \ PDOException $ e ) { throw new Exceptions \ DatabaseConnectionException ( $ e -> getMessage ( ) ) ; } return null ; }
4420	public function onKernelBuilt ( PostBuildKernelEvent $ event ) { $ currentRequest = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ currentRequest === null || ! $ event -> getKernelHandler ( ) instanceof ezpWebBasedKernelHandler || $ this -> configResolver -> getParameter ( 'legacy_mode' ) === true || ! $ this -> isUserAuthenticated ( ) ) { return ; } $ currentRequest -> getSession ( ) -> set ( 'eZUserLoggedInID' , $ this -> repository -> getCurrentUser ( ) -> id ) ; }
90	private static function throwEncodeError ( $ code ) { switch ( $ code ) { case JSON_ERROR_DEPTH : $ msg = 'Maximum stack depth exceeded' ; break ; case JSON_ERROR_STATE_MISMATCH : $ msg = 'Underflow or the modes mismatch' ; break ; case JSON_ERROR_CTRL_CHAR : $ msg = 'Unexpected control character found' ; break ; case JSON_ERROR_UTF8 : $ msg = 'Malformed UTF-8 characters, possibly incorrectly encoded' ; break ; default : $ msg = 'Unknown error' ; } throw new \ RuntimeException ( 'JSON encoding failed: ' . $ msg ) ; }
5980	public function socialmedia ( ) { if ( ! $ this -> socialmedia instanceof SocialmediaController ) { $ this -> socialmedia = new SocialmediaController ( $ this -> getClient ( ) , $ this -> cachePolicy , $ this -> cache ) ; $ this -> socialmedia -> setLogger ( $ this -> logger ) ; } return $ this -> socialmedia ; }
11073	public function setString ( string $ key , $ value , string $ ignoredDefaultValue = null ) { $ this -> set ( $ key , ( string ) $ value , $ ignoredDefaultValue ) ; return $ this ; }
108	private function addExtension ( $ name , $ prettyVersion ) { $ extraDescription = null ; try { $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } catch ( \ UnexpectedValueException $ e ) { $ extraDescription = ' (actual version: ' . $ prettyVersion . ')' ; if ( preg_match ( '{^(\d+\.\d+\.\d+(?:\.\d+)?)}' , $ prettyVersion , $ match ) ) { $ prettyVersion = $ match [ 1 ] ; } else { $ prettyVersion = '0' ; } $ version = $ this -> versionParser -> normalize ( $ prettyVersion ) ; } $ packageName = $ this -> buildPackageName ( $ name ) ; $ ext = new CompletePackage ( $ packageName , $ version , $ prettyVersion ) ; $ ext -> setDescription ( 'The ' . $ name . ' PHP extension' . $ extraDescription ) ; $ this -> addPackage ( $ ext ) ; }
2589	protected function addReceivedFrom ( $ explicitRf , $ doAutoAdd , $ defaultRf , & $ tattooCounter ) { if ( $ this -> dataElementsMaster === null ) { $ this -> dataElementsMaster = new DataElementsMaster ( ) ; } if ( ! empty ( $ explicitRf ) || ( $ doAutoAdd && ! empty ( $ defaultRf ) ) ) { $ tattooCounter ++ ; $ rfToAdd = ( ! empty ( $ explicitRf ) ) ? $ explicitRf : $ defaultRf ; $ this -> dataElementsMaster -> dataElementsIndiv [ ] = $ this -> createElement ( new ReceivedFrom ( [ 'receivedFrom' => $ rfToAdd ] ) , $ tattooCounter ) ; } }
11473	public function destroy ( ResponseRequest $ request , Response $ response ) { try { $ id = $ response [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> delete ( ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
9010	public function char ( int $ size = 36 , string $ charset = null ) : self { $ this -> type = 'char(' . $ size . ')' . $ this -> stringOptions ( $ charset ) ; return $ this ; }
5877	protected static function findExistingFile ( $ fileName ) { $ file = null ; $ relativePath = substr ( PathUtility :: dirname ( $ fileName ) , strlen ( PATH_site ) ) ; $ resourceFactory = \ TYPO3 \ CMS \ Core \ Resource \ ResourceFactory :: getInstance ( ) ; $ targetFolder = $ resourceFactory -> retrieveFileOrFolderObject ( $ relativePath ) ; $ storageConfiguration = $ targetFolder -> getStorage ( ) -> getConfiguration ( ) ; if ( isset ( $ storageConfiguration [ 'basePath' ] ) ) { $ basePath = rtrim ( $ storageConfiguration [ 'basePath' ] , '/' ) . '/' ; $ basePath = GeneralUtility :: getFileAbsFileName ( $ basePath ) ; $ identifier = substr ( $ fileName , strlen ( $ basePath ) - 1 ) ; $ row = GeneralUtility :: makeInstance ( ConnectionPool :: class ) -> getConnectionForTable ( 'sys_file' ) -> select ( [ 'uid' ] , 'sys_file' , [ 'storage' => $ targetFolder -> getStorage ( ) -> getUid ( ) , 'identifier' => $ identifier , ] ) -> fetch ( ) ; if ( ! empty ( $ row [ 'uid' ] ) ) { $ fileRepository = GeneralUtility :: makeInstance ( \ TYPO3 \ CMS \ Core \ Resource \ FileRepository :: class ) ; $ file = $ fileRepository -> findByUid ( $ row [ 'uid' ] ) ; } } return $ file ; }
4684	public function setValueNormalization ( bool $ enabled = false ) { if ( $ enabled === true ) { $ this -> initColumnConversions ( ) ; } else { $ this -> toIntColumns = [ ] ; $ this -> toFloatColumns = [ ] ; $ this -> toStringColumns = [ ] ; $ this -> toBoolColumns = [ ] ; $ this -> toDateTimeColumns = [ ] ; $ this -> toDriverColumns = [ ] ; } }
485	public function addCommentOnColumn ( $ table , $ column , $ comment ) { $ time = $ this -> beginCommand ( "add comment on column $column" ) ; $ this -> db -> createCommand ( ) -> addCommentOnColumn ( $ table , $ column , $ comment ) -> execute ( ) ; $ this -> endCommand ( $ time ) ; }
7436	protected function prepareProductMediaGalleryValueToEntityAttributes ( ) { return $ this -> initializeEntity ( array ( MemberNames :: VALUE_ID => $ this -> valueId , MemberNames :: ROW_ID => $ this -> parentId ) ) ; }
10516	protected function createPhotosCollection ( Product $ product , $ values ) { $ photos = new ArrayCollection ( ) ; $ identifiers = $ this -> getMediaIdentifiers ( $ values ) ; $ hierarchy = 0 ; foreach ( $ identifiers as $ id ) { $ media = $ this -> getMediaById ( $ id ) ; $ photo = $ this -> getProductPhoto ( $ media , $ product , $ values ) ; $ photo -> setHierarchy ( $ hierarchy ++ ) ; if ( ! $ photos -> contains ( $ photo ) ) { $ photos -> add ( $ photo ) ; } } return $ photos ; }
6350	public static function get ( Iterator $ iterator , int $ position ) { Iterators :: advance ( $ iterator , $ position ) ; if ( ! $ iterator -> valid ( ) ) { throw new OutOfBoundsException ( "The requested index '{$position}' is invalid" ) ; } return $ iterator -> current ( ) ; }
11585	public function setSpoolDirectory ( $ dir ) { if ( ! DirectoryHelper :: ensureExists ( $ dir ) ) { throw new \ Exception ( sprintf ( 'Can not create emails spooling directory "%s"!' , $ dir ) ) ; } $ this -> spool_dir = $ dir ; return $ this ; }
3562	protected function hasMutator ( $ value , $ dir = 'setter' , $ type = null ) { return ( bool ) $ this -> getMutator ( $ value , $ dir , $ type ) ; }
10528	protected function getIpAddressFromProxy ( ) { if ( ! $ this -> useProxy || ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) && ! in_array ( $ _SERVER [ 'REMOTE_ADDR' ] , $ this -> trustedProxies ) ) ) { return false ; } $ header = $ this -> proxyHeader ; if ( ! isset ( $ _SERVER [ $ header ] ) || empty ( $ _SERVER [ $ header ] ) ) { return false ; } $ ips = explode ( ',' , $ _SERVER [ $ header ] ) ; $ ips = array_map ( 'trim' , $ ips ) ; $ ips = array_diff ( $ ips , $ this -> trustedProxies ) ; if ( empty ( $ ips ) ) { return false ; } $ ip = array_pop ( $ ips ) ; return $ ip ; }
9315	public function checkAcceptHeader ( Request $ request ) { $ headers = $ request -> getAcceptableContentTypes ( ) ; if ( array_intersect ( $ headers , [ 'application/json' , 'text/json' ] ) ) { return 'json' ; } elseif ( array_intersect ( $ headers , [ 'application/xml' , 'text/xml' ] ) ) { return 'xml' ; } return $ this -> defaultAcceptType ; }
671	public function run ( $ id ) { $ model = $ this -> findModel ( $ id ) ; if ( $ this -> checkAccess ) { call_user_func ( $ this -> checkAccess , $ this -> id , $ model ) ; } $ model -> scenario = $ this -> scenario ; $ model -> load ( Yii :: $ app -> getRequest ( ) -> getBodyParams ( ) , '' ) ; if ( $ model -> save ( ) === false && ! $ model -> hasErrors ( ) ) { throw new ServerErrorHttpException ( 'Failed to update the object for unknown reason.' ) ; } return $ model ; }
5576	public function clickSubmitById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormBySubmit ( new SelectById ( $ id ) ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submitButton ( new SelectById ( $ id ) , $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
11187	public static function get ( array $ arr , $ k , $ default = null ) { if ( isset ( $ arr [ $ k ] ) ) return $ arr [ $ k ] ; $ nested = explode ( '.' , $ k ) ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) ) { $ arr = $ arr [ $ part ] ; continue ; } else { $ arr = $ default ; break ; } } return $ arr ; }
2594	protected function loadCurrencyOverride ( $ currency ) { if ( is_string ( $ currency ) && strlen ( $ currency ) === 3 ) { $ this -> addPriceType ( PricingTicketing :: PRICETYPE_OVERRIDE_CURRENCY_CONVERSION ) ; $ this -> conversionRate = new ConversionRate ( $ currency ) ; } }
9603	public function crossProduct ( self $ b ) { $ this -> _checkVectorSpace ( $ b ) ; if ( $ this -> dimension ( ) !== 3 ) { throw new Exception ( 'Both vectors must be 3-dimensional' ) ; } $ tc = $ this -> components ( ) ; $ bc = $ b -> components ( ) ; list ( $ k0 , $ k1 , $ k2 ) = array_keys ( $ tc ) ; $ product = [ $ k0 => $ tc [ $ k1 ] * $ bc [ $ k2 ] - $ tc [ $ k2 ] * $ bc [ $ k1 ] , $ k1 => $ tc [ $ k2 ] * $ bc [ $ k0 ] - $ tc [ $ k0 ] * $ bc [ $ k2 ] , $ k2 => $ tc [ $ k0 ] * $ bc [ $ k1 ] - $ tc [ $ k1 ] * $ bc [ $ k0 ] , ] ; return new static ( $ product ) ; }
3021	public function getBlogAvatar ( $ blogName , $ size = null ) { $ path = $ this -> blogPath ( $ blogName , '/avatar' ) ; if ( $ size ) { $ path .= "/$size" ; } return $ this -> getRedirect ( $ path , null , true ) ; }
5296	public function setOptions ( $ options = array ( ) ) { $ this -> options = array_merge ( $ this -> options , $ options ) ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'id' ] = $ this -> options [ 'id' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'units-per-em' ] = $ this -> options [ 'units-per-em' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'ascent' ] = $ this -> options [ 'ascent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'descent' ] = $ this -> options [ 'descent' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'x-height' ] = $ this -> options [ 'x-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'font-face' } [ 0 ] [ 'cap-height' ] = $ this -> options [ 'cap-height' ] ; $ this -> xmlDocument -> defs [ 0 ] -> font [ 0 ] -> { 'missing-glyph' } [ 0 ] [ 'horiz-adv-x' ] = $ this -> options [ 'horiz-adv-x' ] ; }
70	public function createLoader ( array $ autoloads ) { $ loader = new ClassLoader ( ) ; if ( isset ( $ autoloads [ 'psr-0' ] ) ) { foreach ( $ autoloads [ 'psr-0' ] as $ namespace => $ path ) { $ loader -> add ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'psr-4' ] ) ) { foreach ( $ autoloads [ 'psr-4' ] as $ namespace => $ path ) { $ loader -> addPsr4 ( $ namespace , $ path ) ; } } if ( isset ( $ autoloads [ 'classmap' ] ) ) { $ blacklist = null ; if ( ! empty ( $ autoloads [ 'exclude-from-classmap' ] ) ) { $ blacklist = '{(' . implode ( '|' , $ autoloads [ 'exclude-from-classmap' ] ) . ')}' ; } foreach ( $ autoloads [ 'classmap' ] as $ dir ) { try { $ loader -> addClassMap ( $ this -> generateClassMap ( $ dir , $ blacklist , null , false ) ) ; } catch ( \ RuntimeException $ e ) { $ this -> io -> writeError ( '<warning>' . $ e -> getMessage ( ) . '</warning>' ) ; } } } return $ loader ; }
7038	public function getShipments ( $ filter = null ) { if ( null === $ filter ) { return $ this -> shipments ; } return $ this -> shipments -> filter ( function ( ShipmentInterface $ shipment ) use ( $ filter ) { return $ filter xor $ shipment -> isReturn ( ) ; } ) ; }
6891	protected function createAssignmentsForQuantity ( SaleItemInterface $ item , $ quantity ) { if ( 0 >= $ quantity ) { return ; } $ stockUnits = $ this -> sortStockUnits ( $ this -> unitResolver -> findAssignable ( $ item ) ) ; foreach ( $ stockUnits as $ stockUnit ) { $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; if ( 0 == $ quantity ) { return ; } } if ( 0 < $ quantity ) { $ stockUnit = $ this -> unitResolver -> createBySubjectRelative ( $ item ) ; $ assignment = $ this -> saleFactory -> createStockAssignmentForItem ( $ item ) ; $ assignment -> setSaleItem ( $ item ) -> setStockUnit ( $ stockUnit ) ; $ quantity -= $ this -> assignmentUpdater -> updateSold ( $ assignment , $ quantity ) ; } if ( 0 < $ quantity ) { throw new StockLogicException ( sprintf ( 'Failed to create assignments for item "%s".' , $ item -> getDesignation ( ) ) ) ; } }
12274	public static function createFromFormat ( $ format , $ time , $ object = null ) { if ( empty ( $ object ) ) { $ object = new DateTimeZone ( 'America/Sao_Paulo' ) ; } return self :: cast ( parent :: createFromFormat ( $ format , $ time , $ object ) ) ; }
7435	public function scan ( ) { $ files = $ this -> extensionsFile ( $ this -> files ) ; foreach ( $ files as $ file ) { $ content = file_get_contents ( $ file ) ; if ( str_contains ( $ file , '.php' ) && ! str_contains ( $ file , $ this -> exceptionsValid ) && ! $ this -> checkForValidPhp ( $ content ) ) { $ this -> notValid [ ] = $ file ; } if ( str_contains ( $ content , $ this -> signatures ) ) { $ this -> dangerFiles [ ] = $ file ; } } return $ this ; }
866	public function isType ( $ types ) { if ( ! \ is_array ( $ types ) ) { $ types = [ $ types ] ; } return \ in_array ( $ this -> getType ( ) , $ types , true ) ; }
6528	public static function registerMap ( array $ map ) { @ trigger_error ( sprintf ( '"%s" is deprecated. Use "registerManifest" instead.' , __CLASS__ ) , E_USER_DEPRECATED ) ; $ nextId = count ( self :: $ curies ) + 30000 ; foreach ( $ map as $ curie => $ class ) { ++ $ nextId ; self :: $ curies [ $ curie ] = $ nextId ; self :: $ classes [ $ nextId ] = $ class ; } }
3755	public function sameModels ( $ objModel1 , $ objModel2 ) { if ( ! ( $ objModel1 instanceof Model && $ objModel2 instanceof Model ) ) { throw new \ InvalidArgumentException ( 'Passed models are not valid.' ) ; } $ objNative1 = $ objModel1 -> getItem ( ) ; $ objNative2 = $ objModel2 -> getItem ( ) ; if ( $ objNative1 -> getMetaModel ( ) === $ objNative2 -> getMetaModel ( ) ) { return true ; } foreach ( $ objNative1 -> getMetaModel ( ) -> getAttributes ( ) as $ objAttribute ) { if ( $ objNative1 -> get ( $ objAttribute -> getColName ( ) ) != $ objNative2 -> get ( $ objAttribute -> getColName ( ) ) ) { return false ; } } return true ; }
8817	public function delete ( $ key = null , $ filter = true ) { parse_str ( file_get_contents ( "php://input" ) , $ _DELETE ) ; if ( $ key == null ) { return $ _DELETE ; } return $ this -> filter ( $ _DELETE [ $ key ] , $ filter ) ; }
5599	public function tally ( ) { while ( list ( $ severity , $ message , $ file , $ line ) = $ this -> extract ( ) ) { $ severity = $ this -> getSeverityAsString ( $ severity ) ; $ this -> test -> error ( $ severity , $ message , $ file , $ line ) ; } while ( list ( $ expected , $ message ) = $ this -> extractExpectation ( ) ) { $ this -> test -> assert ( $ expected , false , '%s -> Expected error not caught' ) ; } }
3886	public function collectRules ( $ filterSettings ) { $ information = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_filtersetting' ) -> where ( 'fid=:fid' ) -> andWhere ( 'pid=0' ) -> andWhere ( 'enabled=1' ) -> orderBy ( 'sorting' , 'ASC' ) -> setParameter ( 'fid' , $ filterSettings -> get ( 'id' ) ) -> execute ( ) ; foreach ( $ information -> fetchAll ( \ PDO :: FETCH_ASSOC ) as $ item ) { $ newSetting = $ this -> createSetting ( $ item , $ filterSettings ) ; if ( $ newSetting ) { $ filterSettings -> addSetting ( $ newSetting ) ; } } }
9880	private function writeWorkbookProtection ( XMLWriter $ objWriter , Spreadsheet $ spreadsheet ) { if ( $ spreadsheet -> getSecurity ( ) -> isSecurityEnabled ( ) ) { $ objWriter -> startElement ( 'workbookProtection' ) ; $ objWriter -> writeAttribute ( 'lockRevision' , ( $ spreadsheet -> getSecurity ( ) -> getLockRevision ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockStructure' , ( $ spreadsheet -> getSecurity ( ) -> getLockStructure ( ) ? 'true' : 'false' ) ) ; $ objWriter -> writeAttribute ( 'lockWindows' , ( $ spreadsheet -> getSecurity ( ) -> getLockWindows ( ) ? 'true' : 'false' ) ) ; if ( $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'revisionsPassword' , $ spreadsheet -> getSecurity ( ) -> getRevisionsPassword ( ) ) ; } if ( $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) != '' ) { $ objWriter -> writeAttribute ( 'workbookPassword' , $ spreadsheet -> getSecurity ( ) -> getWorkbookPassword ( ) ) ; } $ objWriter -> endElement ( ) ; } }
11450	public function getParentUri ( ) { if ( $ this -> getParentName ( ) ) { $ func = $ this -> getParentName ( ) ; if ( ! is_string ( $ func ) ) { return ; } $ relat = $ this -> $ func ( ) ; $ parentResourceName = $ relat -> getRelated ( ) -> getResourceName ( ) ; $ field = $ relat -> getForeignKey ( ) ; if ( ! $ this -> $ field ) { return Api :: url ( ) ; } return Api :: url ( ) . '/' . $ parentResourceName . '/' . Api :: encodeHashId ( $ this -> $ field ) ; } return Api :: url ( ) ; }
2234	public function showDeletedRecords ( $ data , $ row ) { $ arrData = Contao \ StringUtil :: deserialize ( $ row [ 'data' ] ) ; foreach ( $ arrData as $ strTable => $ arrTableData ) { Contao \ System :: loadLanguageFile ( $ strTable ) ; Contao \ Controller :: loadDataContainer ( $ strTable ) ; foreach ( $ arrTableData as $ arrRow ) { $ arrBuffer = array ( ) ; foreach ( $ arrRow as $ i => $ v ) { if ( \ is_array ( Contao \ StringUtil :: deserialize ( $ v ) ) ) { continue ; } if ( isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ) { $ label = \ is_array ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ) ? $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] [ 0 ] : $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'fields' ] [ $ i ] [ 'label' ] ; } else { $ label = \ is_array ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ) ? $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] [ 0 ] : $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ $ i ] ; } if ( ! $ label ) { $ label = $ i ; } $ arrBuffer [ $ label ] = $ v ; } $ data [ $ strTable ] [ ] = $ arrBuffer ; } } return $ data ; }
6756	public static function createApp ( string $ appPath , string $ environment , bool $ debug ) : BaseKernel { $ envPath = $ appPath . '/.env' ; if ( file_exists ( $ envPath ) ) { $ dotenv = new Dotenv ( ) ; $ dotenv -> load ( $ envPath ) ; } $ oneBundleAppConfig = new \ OneBundleApp \ App \ OneBundleAppConfig ( $ appPath , $ environment ) ; \ Symfony \ Component \ Debug \ ErrorHandler :: register ( ) ; \ Symfony \ Component \ Debug \ ExceptionHandler :: register ( ) ; return new \ Mmoreram \ BaseBundle \ Kernel \ BaseKernel ( $ oneBundleAppConfig -> getBundles ( ) , $ oneBundleAppConfig -> getConfig ( ) , $ oneBundleAppConfig -> getRoutes ( ) , $ environment , $ debug , $ appPath . '/var' ) ; }
2278	public function setPagesFlags ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord && $ dc -> activeRecord -> type == 'search' ) { $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'mandatory' ] = false ; unset ( $ GLOBALS [ 'TL_DCA' ] [ $ dc -> table ] [ 'fields' ] [ $ dc -> field ] [ 'eval' ] [ 'orderField' ] ) ; } return $ varValue ; }
6617	protected function mapRequestToArguments ( \ ReflectionMethod $ method , Request $ request ) { $ map = [ ] ; foreach ( $ method -> getParameters ( ) as $ parameter ) { $ value = $ request -> getParameter ( $ parameter -> getName ( ) , $ parameter -> isDefaultValueAvailable ( ) ? $ parameter -> getDefaultValue ( ) : null ) ; if ( $ parameter -> getClass ( ) && $ parameter -> getClass ( ) -> implementsInterface ( Deserializable :: class ) ) { $ value = $ parameter -> getClass ( ) -> newInstanceWithoutConstructor ( ) -> ayeAyeDeserialize ( $ value ) ; $ className = $ parameter -> getClass ( ) -> getName ( ) ; if ( ! is_object ( $ value ) || get_class ( $ value ) !== $ className ) { throw new \ RuntimeException ( "$className::ayeAyeDeserialize did not return an instance of itself" ) ; } } $ map [ $ parameter -> getName ( ) ] = $ value ; } return $ map ; }
5136	public static function handleShutdown ( ) { if ( ! empty ( $ error = error_get_last ( ) ) ) { self :: handleException ( new FatalException ( $ error [ 'message' ] , $ error [ 'type' ] , 0 , $ error [ 'file' ] , $ error [ 'line' ] ) ) ; } }
6420	public function stop ( ) : Stopwatch { $ tick = $ this -> ticker -> read ( ) ; Preconditions :: checkState ( $ this -> isRunning , 'This stopwatch is already stopped.' ) ; $ this -> isRunning = false ; $ this -> elapsedMicros += ( $ tick - $ this -> startTick ) ; return $ this ; }
7470	public function newAction ( ) { $ user = new User ( ) ; $ form = $ this -> createForm ( UserType :: class , $ user ) ; return array ( 'user' => $ user , 'form' => $ form -> createView ( ) ) ; }
6193	protected function loadModels ( $ path ) { $ this -> app -> config [ 'model' ] = array_unique ( array_merge ( $ this -> app -> config [ 'model' ] ?? [ ] , $ path ) ) ; }
2253	protected function getParentEntries ( $ strTable , $ intId ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) { return '' ; } $ arrParent = array ( ) ; do { $ objParent = $ this -> Database -> prepare ( "SELECT pid FROM " . $ strTable . " WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intId ) ; if ( $ objParent -> numRows < 1 ) { break ; } $ strTable = $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ; $ intId = $ objParent -> pid ; $ arrParent [ ] = $ strTable . '.id=' . $ intId ; $ this -> loadDataContainer ( $ strTable ) ; } while ( $ intId && isset ( $ GLOBALS [ 'TL_DCA' ] [ $ strTable ] [ 'config' ] [ 'ptable' ] ) ) ; if ( empty ( $ arrParent ) ) { return '' ; } return ' (parent records: ' . implode ( ', ' , $ arrParent ) . ')' ; }
12681	public function send ( ) { if ( empty ( $ this -> message ) ) { throw new RuntimeException ( 'No message to send.' ) ; } $ transformer = new Transformer ( ) ; if ( $ this -> message instanceof RawMessage ) { $ message = $ this -> message -> get ( 'content' ) ; } else { $ content = $ transformer -> transform ( $ this -> message ) ; $ message = [ 'touser' => $ this -> to , ] ; if ( $ this -> account ) { $ message [ 'customservice' ] = [ 'kf_account' => $ this -> account ] ; } $ message = array_merge ( $ message , $ content ) ; } return $ this -> staff -> send ( $ message ) ; }
180	protected function loadDummyBundle ( $ name ) { if ( ! isset ( $ this -> _dummyBundles [ $ name ] ) ) { $ this -> _dummyBundles [ $ name ] = $ this -> loadBundle ( $ name , [ 'sourcePath' => null , 'js' => [ ] , 'css' => [ ] , 'depends' => [ ] , ] ) ; } return $ this -> _dummyBundles [ $ name ] ; }
12499	public static function insertMany ( $ document , $ connection ) { if ( gettype ( $ document ) != "array" && gettype ( $ document ) != "object" ) { throw new ClusterpointException ( "\"->insert()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid document format." , 9002 ) ; } if ( gettype ( $ document ) == "object" ) { $ document_array = array ( ) ; foreach ( $ document as $ value ) { $ document_array [ ] = $ value ; } $ document = $ document_array ; } $ connection -> query = json_encode ( array_values ( $ document ) ) ; $ connection -> multiple = true ; return self :: insert ( $ connection ) ; }
10108	private function writeSelection ( ) { $ selectedCells = Coordinate :: splitRange ( $ this -> phpSheet -> getSelectedCells ( ) ) ; $ selectedCells = $ selectedCells [ 0 ] ; if ( count ( $ selectedCells ) == 2 ) { list ( $ first , $ last ) = $ selectedCells ; } else { $ first = $ selectedCells [ 0 ] ; $ last = $ selectedCells [ 0 ] ; } list ( $ colFirst , $ rwFirst ) = Coordinate :: coordinateFromString ( $ first ) ; $ colFirst = Coordinate :: columnIndexFromString ( $ colFirst ) - 1 ; -- $ rwFirst ; list ( $ colLast , $ rwLast ) = Coordinate :: coordinateFromString ( $ last ) ; $ colLast = Coordinate :: columnIndexFromString ( $ colLast ) - 1 ; -- $ rwLast ; $ colFirst = min ( $ colFirst , 255 ) ; $ colLast = min ( $ colLast , 255 ) ; $ rwFirst = min ( $ rwFirst , 65535 ) ; $ rwLast = min ( $ rwLast , 65535 ) ; $ record = 0x001D ; $ length = 0x000F ; $ pnn = $ this -> activePane ; $ rwAct = $ rwFirst ; $ colAct = $ colFirst ; $ irefAct = 0 ; $ cref = 1 ; if ( ! isset ( $ rwLast ) ) { $ rwLast = $ rwFirst ; } if ( ! isset ( $ colLast ) ) { $ colLast = $ colFirst ; } if ( $ rwFirst > $ rwLast ) { list ( $ rwFirst , $ rwLast ) = [ $ rwLast , $ rwFirst ] ; } if ( $ colFirst > $ colLast ) { list ( $ colFirst , $ colLast ) = [ $ colLast , $ colFirst ] ; } $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'CvvvvvvCC' , $ pnn , $ rwAct , $ colAct , $ irefAct , $ cref , $ rwFirst , $ rwLast , $ colFirst , $ colLast ) ; $ this -> append ( $ header . $ data ) ; }
142	public function getInstallPath ( PackageInterface $ package ) { $ installer = $ this -> getInstaller ( $ package -> getType ( ) ) ; return $ installer -> getInstallPath ( $ package ) ; }
10162	private function readSelection ( ) { $ length = self :: getUInt2d ( $ this -> data , $ this -> pos + 2 ) ; $ recordData = $ this -> readRecordData ( $ this -> data , $ this -> pos + 4 , $ length ) ; $ this -> pos += 4 + $ length ; if ( ! $ this -> readDataOnly ) { $ paneId = ord ( $ recordData [ 0 ] ) ; $ r = self :: getUInt2d ( $ recordData , 1 ) ; $ c = self :: getUInt2d ( $ recordData , 3 ) ; $ index = self :: getUInt2d ( $ recordData , 5 ) ; $ data = substr ( $ recordData , 7 ) ; $ cellRangeAddressList = $ this -> readBIFF5CellRangeAddressList ( $ data ) ; $ selectedCells = $ cellRangeAddressList [ 'cellRangeAddresses' ] [ 0 ] ; if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)16384$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)16384$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^([A-Z]+1\:[A-Z]+)65536$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^([A-Z]+1\:[A-Z]+)65536$/' , '${1}1048576' , $ selectedCells ) ; } if ( preg_match ( '/^(A\d+\:)IV(\d+)$/' , $ selectedCells ) ) { $ selectedCells = preg_replace ( '/^(A\d+\:)IV(\d+)$/' , '${1}XFD${2}' , $ selectedCells ) ; } $ this -> phpSheet -> setSelectedCells ( $ selectedCells ) ; } }
4244	private function buildErrorList ( ) { $ errorStr = '' ; $ errors = $ this -> debug -> errorHandler -> get ( 'errors' ) ; \ uasort ( $ errors , function ( $ a1 , $ a2 ) { return \ strcmp ( $ a1 [ 'file' ] . $ a1 [ 'line' ] , $ a2 [ 'file' ] . $ a2 [ 'line' ] ) ; } ) ; $ lastFile = '' ; foreach ( $ errors as $ error ) { if ( $ error [ 'isSuppressed' ] ) { continue ; } if ( $ error [ 'file' ] !== $ lastFile ) { $ errorStr .= $ error [ 'file' ] . ':' . "\n" ; $ lastFile = $ error [ 'file' ] ; } $ typeStr = $ error [ 'type' ] === E_STRICT ? 'Strict' : $ error [ 'typeStr' ] ; $ errorStr .= ' Line ' . $ error [ 'line' ] . ': (' . $ typeStr . ') ' . $ error [ 'message' ] . "\n" ; } return $ errorStr ; }
10302	private function writePrintSettings ( $ objWriter ) { $ objWriter -> startElement ( 'c:printSettings' ) ; $ objWriter -> startElement ( 'c:headerFooter' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageMargins' ) ; $ objWriter -> writeAttribute ( 'footer' , 0.3 ) ; $ objWriter -> writeAttribute ( 'header' , 0.3 ) ; $ objWriter -> writeAttribute ( 'r' , 0.7 ) ; $ objWriter -> writeAttribute ( 'l' , 0.7 ) ; $ objWriter -> writeAttribute ( 't' , 0.75 ) ; $ objWriter -> writeAttribute ( 'b' , 0.75 ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'c:pageSetup' ) ; $ objWriter -> writeAttribute ( 'orientation' , 'portrait' ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; }
5678	protected function extractResponse ( $ response ) { $ this -> transport_error = $ response -> getError ( ) ; $ this -> raw = $ response -> getContent ( ) ; $ this -> sent = $ response -> getSent ( ) ; $ this -> headers = $ response -> getHeaders ( ) ; $ this -> method = $ response -> getMethod ( ) ; $ this -> url = $ response -> getUrl ( ) ; $ this -> request_data = $ response -> getRequestData ( ) ; }
4072	private function scanFiles ( $ extension ) { $ files = [ ] ; foreach ( Finder :: create ( ) -> in ( $ this -> uploadPath ) -> name ( '*.' . $ extension ) -> getIterator ( ) as $ item ) { $ files [ ] = 'files/' . Path :: normalize ( $ item -> getRelativePathname ( ) ) ; } return $ files ; }
6351	public static function size ( Iterator $ iterator ) { $ result = 0 ; Iterators :: each ( $ iterator , function ( ) use ( & $ result ) { $ result ++ ; } ) ; return $ result ; }
9764	function equal ( $ value ) : self { if ( $ this -> hasFlag ( 'file' ) ) { if ( $ this -> hasFlag ( 'negate' ) ) assertFileNotEquals ( $ value , $ this -> target , $ this -> message ) ; else assertFileEquals ( $ value , $ this -> target , $ this -> message ) ; return $ this ; } $ target = $ this -> hasFlag ( 'length' ) ? $ this -> getLength ( $ this -> target ) : $ this -> target ; return $ this -> expect ( $ target , equalTo ( $ value ) ) ; }
12433	private function getMaxPercentForInfinityBonus ( $ cfgParams , $ scheme ) { $ result = 0 ; $ params = $ cfgParams [ $ scheme ] ; foreach ( $ params as $ item ) { $ percent = $ item -> getInfinity ( ) ; if ( $ percent > $ result ) { $ result = $ percent ; } } return $ result ; }
3014	public function unlike ( $ postId , $ reblogKey ) { $ options = array ( 'id' => $ postId , 'reblog_key' => $ reblogKey ) ; return $ this -> postRequest ( 'v2/user/unlike' , $ options , false ) ; }
9852	public function setPath ( $ pValue , $ pVerifyFile = true ) { if ( $ pVerifyFile ) { if ( file_exists ( $ pValue ) ) { $ this -> path = $ pValue ; if ( $ this -> width == 0 && $ this -> height == 0 ) { list ( $ this -> width , $ this -> height ) = getimagesize ( $ pValue ) ; } } else { throw new PhpSpreadsheetException ( "File $pValue not found!" ) ; } } else { $ this -> path = $ pValue ; } return $ this ; }
5693	public function Form ( ) { $ formAction = $ this -> getFormActionFromRequest ( $ this -> request ) ; $ fields = $ formAction -> getFields ( ) ; $ fields -> push ( HiddenField :: create ( 'action' , '' , $ formAction -> getButtonName ( ) ) ) ; $ form = Form :: create ( $ this , 'Form' , $ fields , FieldList :: create ( FormAction :: create ( 'nestedFormSave' , 'Save' ) ) ) ; return $ form ; }
12962	public function getTables ( ) { $ tables = $ this -> getDb ( ) -> getAllTables ( ) ; $ return = array ( ) ; foreach ( $ tables as $ name => $ table ) { foreach ( $ table as $ key => $ value ) { $ return [ $ table [ $ key ] ] = $ table [ $ key ] ; } } return $ return ; }
12114	protected function loadForeignDataItems ( ) { $ this -> _foreignDataItems = [ ] ; if ( $ this -> lazyForeign ) { $ primaryKeys = $ this -> foreignModel -> findPrimaryKeys ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ primaryKeys as $ primaryKey ) { $ this -> createForeignDataItem ( null , [ 'foreignPrimaryKey' => $ primaryKey ] ) ; } } else { $ foreignModels = $ this -> foreignModel -> findAll ( $ this -> settings [ 'foreignPullParams' ] ) ; foreach ( $ foreignModels as $ key => $ model ) { $ this -> createForeignDataItem ( $ model , [ ] ) ; } } }
10721	public function getLabel ( ) { $ label = $ this -> label ; $ title = $ this -> title ; if ( $ label ) { return $ label ; } else { return $ title ; } }
5138	public static function handleException ( \ Throwable $ e ) { if ( php_sapi_name ( ) == 'cli' ) { $ handler = new ConsoleHandler ( self :: $ output ) ; } else { $ handler = new HtmlHandler ( HtmlHandler :: INVERTED ) ; } fwrite ( self :: $ output , $ handler -> renderException ( $ e , AbstractHandler :: VERBOSITY_VERBOSE ) ) ; }
7825	protected function getTotalWidth ( ) { $ borders = ( static :: BORDER_WIDTH + static :: MIN_SPACE_FROM_BORDER_X ) * 2 ; if ( empty ( $ this -> pipes ) ) { return $ borders + $ this -> getCoreLength ( ) ; } $ borders *= count ( $ this -> pipes ) ; $ name = ( $ this -> getLongestPipeLength ( ) + static :: SPACE_FROM_ARROW ) * 2 ; return $ borders + $ name + static :: ARROW_WIDTH ; }
4374	protected function buildChannelTree ( ) { if ( $ this -> channels == array ( $ this -> channelNameRoot ) ) { return array ( ) ; } \ sort ( $ this -> channels ) ; $ rootKey = \ array_search ( $ this -> channelNameRoot , $ this -> channels ) ; if ( $ rootKey !== false ) { unset ( $ this -> channels [ $ rootKey ] ) ; \ array_unshift ( $ this -> channels , $ this -> channelName ) ; } $ tree = array ( ) ; foreach ( $ this -> channels as $ channel ) { $ ref = & $ tree ; $ path = \ explode ( '.' , $ channel ) ; foreach ( $ path as $ k ) { if ( ! isset ( $ ref [ $ k ] ) ) { $ ref [ $ k ] = array ( ) ; } $ ref = & $ ref [ $ k ] ; } } return $ tree ; }
106	public function moveWatch ( $ from , $ to ) { if ( $ this -> watch1 == $ from ) { $ this -> watch1 = $ to ; } else { $ this -> watch2 = $ to ; } }
6052	public function retrieveFolder ( $ id , $ depth = 0 , $ includeProperties = true , $ includeObjectCounts = false , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'depth' => $ depth , 'includeProperties' => $ includeProperties , 'includeObjectCounts' => $ includeObjectCounts ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new FolderResponse ( $ result ) ; return $ result ; }
6581	public function translate ( $ shift , $ y = null , $ z = null ) { if ( $ shift instanceof self ) return new static ( $ this -> gps [ 'x' ] + $ shift -> gps [ 'x' ] , $ this -> gps [ 'y' ] + $ shift -> gps [ 'y' ] , $ this -> gps [ 'z' ] + $ shift -> gps [ 'z' ] ) ; else return new static ( $ this -> gps [ 'x' ] + $ shift , $ this -> gps [ 'y' ] + $ y , $ this -> gps [ 'z' ] + $ z ) ; }
4400	protected function saveTransationRef ( \ Aimeos \ MShop \ Order \ Item \ Base \ Iface $ baseItem , $ ref ) { $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ serviceItem = $ this -> getBasketService ( $ baseItem , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ attr = array ( 'TRANSACTIONID' => $ ref ) ; $ this -> setAttributes ( $ serviceItem , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ baseItem ) ; }
4396	public function refund ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsRefund ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ type = \ Aimeos \ MShop \ Order \ Item \ Base \ Service \ Base :: TYPE_PAYMENT ; $ service = $ this -> getBasketService ( $ base , $ type , $ this -> getServiceItem ( ) -> getCode ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> refund ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ attr = array ( 'REFUNDID' => $ response -> getTransactionReference ( ) ) ; $ this -> setAttributes ( $ service , $ attr , 'payment/omnipay' ) ; $ this -> saveOrderBase ( $ base ) ; $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_REFUND ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
5011	public function getLogger ( ) : LoggerInterface { if ( ! $ this -> logger ) { $ logger = new class implements LoggerInterface { public function emerg ( $ message , $ extra = [ ] ) : void { } public function alert ( $ message , $ extra = [ ] ) : void { } public function crit ( $ message , $ extra = [ ] ) : void { } public function err ( $ message , $ extra = [ ] ) : void { } public function warn ( $ message , $ extra = [ ] ) : void { } public function notice ( $ message , $ extra = [ ] ) : void { } public function info ( $ message , $ extra = [ ] ) : void { } public function debug ( $ message , $ extra = [ ] ) : void { } } ; $ this -> setLogger ( $ logger ) ; } return $ this -> logger ; }
3540	public static function getSyncOptions ( $ optionName , $ individualSyncOptions = null ) { if ( $ individualSyncOptions != null && is_array ( $ individualSyncOptions ) && array_key_exists ( $ optionName , $ individualSyncOptions ) ) { return $ individualSyncOptions [ $ optionName ] ; } else if ( isset ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && is_array ( Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) && array_key_exists ( $ optionName , Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] ) ) { return Yii :: $ app -> params [ 'LDAP-User-Sync-Options' ] [ $ optionName ] ; } else if ( array_key_exists ( $ optionName , static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK ) ) { return static :: SYNC_OPTIONS_TEMPLATE_WITHOUT_BACKEND_TASK [ $ optionName ] ; } else { throw new \ yii \ base \ Exception ( 'Sync-option ' . $ optionName . ' not found. Please define settings in the config/params.php of the yii2 framework as described on top of the UserDbLdap.php' ) ; } }
8307	public function assertStringContaining ( $ config , $ key , $ searchedPart ) { $ this -> assertString ( $ config , $ key ) ; if ( array_key_exists ( $ key , $ config ) && strpos ( $ config [ $ key ] , $ searchedPart ) === false ) { throw new ConfigurationException ( $ key . " must contain " . $ searchedPart ) ; } return $ this ; }
7728	public function quickReplies ( $ text , $ quickReplies ) { $ this -> setText ( $ text ) ; foreach ( $ quickReplies as $ quickReplie ) { $ this -> setQuickReplies ( $ quickReplie ) ; } return $ this ; }
7593	public function openTag ( FormInterface $ form = null ) { $ this -> setFormClass ( $ form , $ this -> formLayout ) ; return parent :: openTag ( $ form ) ; }
6920	static public function validateIdentity ( ExecutionContextInterface $ context , IdentityInterface $ identity , array $ config = [ ] , $ pathPrefix = null ) { $ violationList = $ context -> getValidator ( ) -> validate ( $ identity , [ new Identity ( $ config ) ] ) ; if ( ! empty ( $ pathPrefix ) ) { $ pathPrefix = rtrim ( $ pathPrefix , '.' ) . '.' ; } foreach ( $ violationList as $ violation ) { $ context -> buildViolation ( $ violation -> getMessage ( ) ) -> atPath ( $ pathPrefix . $ violation -> getPropertyPath ( ) ) -> addViolation ( ) ; } }
5454	protected function hasNamedTagOnOpenTagStack ( $ name ) { return isset ( $ this -> tags [ $ name ] ) && ( count ( $ this -> tags [ $ name ] ) > 0 ) ; }
4805	public function getLowestFreeIndexNumber ( ) { $ query = $ this -> createQuery ( ) ; $ query -> statement ( 'SELECT index_number from ' . strtolower ( $ this -> objectType ) . ' WHERE deleted=0' ) ; $ index = 1 ; $ results = $ query -> execute ( true ) ; if ( false === is_array ( $ results ) || sizeof ( $ results ) < 1 ) { return $ index ; } $ indexes = array ( ) ; foreach ( $ results as $ result ) { $ indexes [ ] = ( integer ) $ result [ 'index_number' ] ; } for ( $ index = 1 ; $ index <= sizeof ( $ indexes ) + 1 ; $ index ++ ) { if ( false === in_array ( $ index , $ indexes ) ) { break ; } } return $ index ; }
9958	public function unprotectCells ( $ pRange ) { $ pRange = strtoupper ( $ pRange ) ; if ( isset ( $ this -> protectedCells [ $ pRange ] ) ) { unset ( $ this -> protectedCells [ $ pRange ] ) ; } else { throw new Exception ( 'Cell range ' . $ pRange . ' not known as protected.' ) ; } return $ this ; }
7497	public function createMessageFromTemplateFile ( $ template , $ params , $ subject , $ recipient , $ sender = null ) { $ body = $ this -> templating -> render ( $ template , $ params ) ; if ( ! $ sender ) { $ sender = $ this -> defaultSender ; } $ message = new \ Swift_Message ( ) ; $ message -> setFrom ( $ sender ) -> setReplyTo ( $ sender ) -> setTo ( $ recipient ) -> setSubject ( $ subject ) -> setBody ( $ body , 'text/html' ) ; return $ message ; }
6231	public function used ( ) { return $ this -> core -> api ( ) -> response ( $ this -> makeContainer ( $ this -> core -> auth ( ) -> getAllPermissions ( ) ) ) ; }
9898	private function convertFunction ( $ token , $ num_args ) { $ args = $ this -> functions [ $ token ] [ 1 ] ; if ( $ args >= 0 ) { return pack ( 'Cv' , $ this -> ptg [ 'ptgFuncV' ] , $ this -> functions [ $ token ] [ 0 ] ) ; } if ( $ args == - 1 ) { return pack ( 'CCv' , $ this -> ptg [ 'ptgFuncVarV' ] , $ num_args , $ this -> functions [ $ token ] [ 0 ] ) ; } }
11990	public function toggleFiltrable ( $ entityName , $ id ) { $ entity = $ this -> entityManager -> getRepository ( $ entityName ) -> find ( $ id ) ; if ( ! $ entity ) { throw new NotFoundHttpException ( ) ; } $ entity -> toggleFiltrable ( ) ; $ this -> entityManager -> persist ( $ entity ) ; $ this -> entityManager -> flush ( ) ; return $ entity -> isFiltrable ( ) ; }
7561	protected function parse_sibling ( ) { if ( ( ( $ this -> pos + 1 ) < $ this -> size ) && ( $ this -> doc [ $ this -> pos + 1 ] === '=' ) ) { ++ $ this -> pos ; return ( $ this -> token = self :: TOK_COMPARE_CONTAINS_WORD ) ; } else { return ( $ this -> token = self :: TOK_SIBLING ) ; } }
12429	public function getAuthorizerList ( $ offset = 0 , $ count = 500 ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'offset' => $ offset , 'count' => $ count , ] ; return $ this -> parseJSON ( 'json' , [ self :: GET_AUTHORIZER_LIST , $ params ] ) ; }
12321	protected function prepareData ( InputInterface $ input ) { $ return = [ ] ; foreach ( $ this -> validators as $ validator ) { $ result = $ validator -> validate ( $ input ) ; if ( isset ( $ result ) && is_array ( $ result ) ) { $ return = NestedArray :: mergeDeep ( $ return , $ result ) ; } elseif ( isset ( $ result ) ) { $ return [ ] = $ result ; } } return $ return ; }
12516	public static function delete ( $ path ) { if ( ! Folder :: exists ( $ path ) ) { return true ; } $ path = Path :: clean ( $ path ) ; if ( trim ( $ path ) === '' ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' : Cannot delete root path' ) ; } $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
4371	public function markupClassname ( $ str , $ tagName = 'span' , $ attribs = array ( ) ) { if ( \ preg_match ( '/^(.+)(::|->)(.+)$/' , $ str , $ matches ) ) { $ classname = $ matches [ 1 ] ; $ opMethod = '<span class="t_operator">' . \ htmlspecialchars ( $ matches [ 2 ] ) . '</span>' . '<span class="method-name">' . $ matches [ 3 ] . '</span>' ; } else { $ classname = $ str ; $ opMethod = '' ; } $ idx = \ strrpos ( $ classname , '\\' ) ; if ( $ idx ) { $ classname = '<span class="namespace">' . \ substr ( $ classname , 0 , $ idx + 1 ) . '</span>' . \ substr ( $ classname , $ idx + 1 ) ; } $ attribs = \ array_merge ( array ( 'class' => 't_classname' , ) , $ attribs ) ; return $ this -> debug -> utilities -> buildTag ( $ tagName , $ attribs , $ classname ) . $ opMethod ; }
6829	protected function prioritizeAssignment ( Stock \ StockAssignmentInterface $ assignment ) { if ( $ assignment -> isFullyShipped ( ) || $ assignment -> isFullyShippable ( ) ) { return false ; } if ( 0 >= $ quantity = $ assignment -> getSoldQuantity ( ) - $ assignment -> getShippableQuantity ( ) ) { return false ; } $ changed = false ; $ helper = new PrioritizeHelper ( $ this -> unitResolver ) ; $ sourceUnit = $ assignment -> getStockUnit ( ) ; $ candidates = $ helper -> getUnitCandidates ( $ assignment , $ quantity ) ; foreach ( $ candidates as $ candidate ) { $ targetUnit = $ candidate -> unit ; if ( ( 0 < $ quantity - $ targetUnit -> getReservableQuantity ( ) ) && ( $ combination = $ candidate -> combination ) ) { foreach ( $ combination -> map as $ id => $ qty ) { if ( null === $ a = $ candidate -> getAssignmentById ( $ id ) ) { throw new StockLogicException ( "Assignment not found." ) ; } $ this -> moveAssignment ( $ a , $ sourceUnit , min ( $ qty , $ quantity ) ) ; } } $ delta = min ( $ quantity , $ targetUnit -> getReservableQuantity ( ) ) ; $ quantity -= $ this -> moveAssignment ( $ assignment , $ targetUnit , $ delta ) ; $ changed = true ; if ( 0 >= $ quantity ) { break ; } } return $ changed ; }
7545	function getNamespace ( ) { if ( $ this -> tag_ns === null ) { $ a = explode ( ':' , $ this -> tag , 2 ) ; if ( empty ( $ a [ 1 ] ) ) { $ this -> tag_ns = array ( '' , $ a [ 0 ] ) ; } else { $ this -> tag_ns = array ( $ a [ 0 ] , $ a [ 1 ] ) ; } } return $ this -> tag_ns [ 0 ] ; }
10454	public function resetPassword ( $ user , $ password ) { $ user -> password = $ password ; $ user -> reset_token = null ; $ user -> save ( ) ; }
6699	public function setBuild ( $ build ) { $ this -> build = array_values ( ( array ) $ build ) ; array_walk ( $ this -> build , function ( & $ v ) { if ( preg_match ( '/^[0-9]+$/' , $ v ) ) { $ v = ( int ) $ v ; } } ) ; }
7525	function select ( $ query = '*' , $ index = false , $ recursive = true , $ check_self = false ) { return $ this -> root -> select ( $ query , $ index , $ recursive , $ check_self ) ; }
5345	public function requestAccess ( $ when , $ duration , array $ visitors , $ phoneNumber ) { return $ this -> call ( self :: SERVICE , 'requestAccess' , [ $ when , $ duration , $ visitors , $ phoneNumber ] ) ; }
4771	public function status ( Request $ request , WidgetInterface $ widget , string $ widgetId , bool $ status = true ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'status' => $ status ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
12501	private static function updateRecursion ( $ document ) { $ result = array ( ) ; foreach ( self :: toDotted ( $ document , '' , 1 ) as $ path => $ value ) { $ result [ ] = $ path . $ value ; } return implode ( ' ' , $ result ) ; }
10504	private function registerLogLevels ( ) { $ this -> app -> singleton ( Contracts \ Utilities \ LogLevels :: class , function ( $ app ) { $ translator = $ app [ 'translator' ] ; return new Utilities \ LogLevels ( $ translator , 'en' ) ; } ) ; $ this -> app -> singleton ( 'arcanedev.log-viewer.levels' , Contracts \ Utilities \ LogLevels :: class ) ; }
8717	public static function forceCreate ( array $ attributes , $ translations = [ ] ) { $ model = new static ; return static :: unguarded ( function ( ) use ( $ model , $ attributes , $ translations ) { return $ model -> create ( $ attributes , $ translations ) ; } ) ; }
3296	protected function domDocumentArray ( $ root ) { $ result = [ ] ; if ( $ root -> hasAttributes ( ) ) { foreach ( $ root -> attributes as $ attribute ) { $ result [ '@attributes' ] [ $ attribute -> name ] = $ attribute -> value ; } } if ( $ root -> hasChildNodes ( ) ) { if ( 1 == $ root -> childNodes -> length ) { $ child = $ root -> childNodes -> item ( 0 ) ; if ( in_array ( $ child -> nodeType , [ XML_TEXT_NODE , XML_CDATA_SECTION_NODE ] ) && ! empty ( $ child -> nodeValue ) ) { $ result [ '_value' ] = $ child -> nodeValue ; return 1 == count ( $ result ) ? $ result [ '_value' ] : $ result ; } } $ groups = [ ] ; foreach ( $ root -> childNodes as $ child ) { if ( ! isset ( $ result [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = $ this -> domDocumentArray ( $ child ) ; } else { if ( ! isset ( $ groups [ $ child -> nodeName ] ) ) { $ result [ $ child -> nodeName ] = [ $ result [ $ child -> nodeName ] ] ; $ groups [ $ child -> nodeName ] = 1 ; } $ result [ $ child -> nodeName ] [ ] = $ this -> domDocumentArray ( $ child ) ; } } } return $ result ; }
6555	public function stop ( $ reason ) { $ this -> log ( $ reason , LogLevel :: INFO ) ; $ this -> stopped = true ; }
9445	public function getEntityMappings ( Container $ app ) { static $ mappings = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ mappings [ $ me ] ) ) { $ subns = $ this -> packOptions [ 'entity_subnamespace' ] ; $ subns = trim ( $ subns , '\\' ) ; $ simple = $ this -> packOptions [ 'entity_use_simple_annotation' ] ; $ ns = $ this -> getReflector ( ) -> getNamespaceName ( ) . '\\' . $ subns ; $ subpath = str_replace ( '\\' , '/' , $ subns ) ; $ path = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; if ( is_dir ( $ path ) ) { $ mappings [ $ me ] = [ 'type' => 'annotation' , 'namespace' => $ ns , 'path' => $ path , 'use_simple_annotation_reader' => $ simple , ] ; } } if ( empty ( $ mappings [ $ me ] ) ) { return [ ] ; } return [ $ mappings [ $ me ] ] ; }
497	public function calculateTimings ( $ messages ) { $ timings = [ ] ; $ stack = [ ] ; foreach ( $ messages as $ i => $ log ) { list ( $ token , $ level , $ category , $ timestamp , $ traces ) = $ log ; $ memory = isset ( $ log [ 5 ] ) ? $ log [ 5 ] : 0 ; $ log [ 6 ] = $ i ; $ hash = md5 ( json_encode ( $ token ) ) ; if ( $ level == self :: LEVEL_PROFILE_BEGIN ) { $ stack [ $ hash ] = $ log ; } elseif ( $ level == self :: LEVEL_PROFILE_END ) { if ( isset ( $ stack [ $ hash ] ) ) { $ timings [ $ stack [ $ hash ] [ 6 ] ] = [ 'info' => $ stack [ $ hash ] [ 0 ] , 'category' => $ stack [ $ hash ] [ 2 ] , 'timestamp' => $ stack [ $ hash ] [ 3 ] , 'trace' => $ stack [ $ hash ] [ 4 ] , 'level' => count ( $ stack ) - 1 , 'duration' => $ timestamp - $ stack [ $ hash ] [ 3 ] , 'memory' => $ memory , 'memoryDiff' => $ memory - ( isset ( $ stack [ $ hash ] [ 5 ] ) ? $ stack [ $ hash ] [ 5 ] : 0 ) , ] ; unset ( $ stack [ $ hash ] ) ; } } } ksort ( $ timings ) ; return array_values ( $ timings ) ; }
10927	private function updateWidth ( $ columnNumber , $ width ) { if ( $ width > $ this -> getWidth ( $ columnNumber ) ) { $ this -> widths [ $ columnNumber ] = $ width ; } }
3845	protected static function upgradeDcaSettingsPublished ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dcasetting' , null , true ) && ! $ objDB -> fieldExists ( 'published' , 'tl_metamodel_dcasetting' , true ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dcasetting' , 'published' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( 'UPDATE tl_metamodel_dcasetting SET published=1;' ) ; } }
3895	protected function getMetaModel ( $ metaModelId ) { if ( null === $ this -> factory ) { throw new \ RuntimeException ( 'No factory set.' ) ; } $ metaModelName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ; $ metaModel = $ this -> factory -> getMetaModel ( $ metaModelName ) ; return $ metaModel ; }
4290	private function processExistingData ( ) { $ data = $ this -> debug -> getData ( ) ; $ channelName = $ this -> debug -> getCfg ( 'channel' ) ; foreach ( $ data [ 'alerts' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } foreach ( $ data [ 'logSummary' ] as $ priority => $ entries ) { $ this -> processLogEntryWEvent ( 'groupSummary' , array ( ) , array ( 'channel' => $ channelName , 'priority' => $ priority , ) ) ; foreach ( $ entries as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } $ this -> processLogEntryWEvent ( 'groupEnd' , array ( ) , array ( 'channel' => $ channelName , 'closesSummary' => true , ) ) ; } foreach ( $ data [ 'log' ] as $ entry ) { $ this -> processLogEntryWEvent ( $ entry [ 0 ] , $ entry [ 1 ] , $ entry [ 2 ] ) ; } }
292	public function hasAttribute ( $ name ) { return isset ( $ this -> _attributes [ $ name ] ) || in_array ( $ name , $ this -> attributes ( ) , true ) ; }
363	public function renderItems ( ) { $ caption = $ this -> renderCaption ( ) ; $ columnGroup = $ this -> renderColumnGroup ( ) ; $ tableHeader = $ this -> showHeader ? $ this -> renderTableHeader ( ) : false ; $ tableBody = $ this -> renderTableBody ( ) ; $ tableFooter = false ; $ tableFooterAfterBody = false ; if ( $ this -> showFooter ) { if ( $ this -> placeFooterAfterBody ) { $ tableFooterAfterBody = $ this -> renderTableFooter ( ) ; } else { $ tableFooter = $ this -> renderTableFooter ( ) ; } } $ content = array_filter ( [ $ caption , $ columnGroup , $ tableHeader , $ tableFooter , $ tableBody , $ tableFooterAfterBody , ] ) ; return Html :: tag ( 'table' , implode ( "\n" , $ content ) , $ this -> tableOptions ) ; }
4693	public function orderBy ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> order = $ expression === null ? null : [ $ expression ] ; $ this -> args [ 'order' ] = $ args ; return $ this ; }
6857	protected static function equinoxSeptember ( $ year , $ vsop = true ) { $ month = 9 ; if ( $ vsop ) return static :: accurate ( $ year , static :: meanTerms ( $ month , $ year ) , $ month ) ; else return static :: approx ( $ year , static :: meanTerms ( $ month , $ year ) ) ; }
9769	function match ( string $ pattern ) : self { return $ this -> expect ( $ this -> target , matchesRegularExpression ( $ pattern ) ) ; }
4898	private static function checkCache ( array $ configuration ) { $ config = $ configuration [ 'module_listener_options' ] ; $ options = new ListenerOptions ( $ config ) ; $ cache = new ClearCacheService ( $ options ) ; $ cache -> checkCache ( ) ; }
10778	private function create_image ( ) { $ total = $ this -> total_size ( ) ; $ sprite = imagecreatetruecolor ( $ total [ "width" ] , $ total [ "height" ] ) ; imagesavealpha ( $ sprite , true ) ; $ transparent = imagecolorallocatealpha ( $ sprite , 0 , 0 , 0 , 127 ) ; imagefill ( $ sprite , 0 , 0 , $ transparent ) ; $ top = 0 ; foreach ( $ this -> images as $ image ) { $ func = "imagecreatefrom" . $ image [ 'type' ] ; $ img = $ func ( $ image [ "path" ] ) ; imagecopy ( $ sprite , $ img , ( $ total [ "width" ] - $ image [ "width" ] ) , $ top , 0 , 0 , $ image [ "width" ] , $ image [ "height" ] ) ; $ top += $ image [ "height" ] ; } return $ sprite ; }
4616	protected function validate ( ) { if ( ! $ this -> config -> getHost ( ) || ! $ this -> config -> getPort ( ) ) { throw new Node \ Builder \ Exception ( 'Node host address and port number are required.' ) ; } if ( $ this -> config -> getUser ( ) && $ this -> config -> getCertificate ( ) ) { throw new Node \ Builder \ Exception ( 'Connect with password OR certificate authentication, not both.' ) ; } if ( $ this -> config -> isAuth ( ) && ! $ this -> config -> getCaDirectory ( ) && ! $ this -> config -> getCaFile ( ) ) { throw new Node \ Builder \ Exception ( 'Certificate authority file is required for authentication.' ) ; } }
4213	public static function colKeys ( $ rows ) { if ( ! \ is_array ( $ rows ) ) { return array ( ) ; } if ( Abstracter :: isAbstraction ( $ rows ) && $ rows [ 'traverseValues' ] ) { $ rows = $ rows [ 'traverseValues' ] ; } $ lastKeys = array ( ) ; $ newKeys = array ( ) ; $ curKeys = array ( ) ; foreach ( $ rows as $ row ) { $ curKeys = self :: keys ( $ row ) ; if ( empty ( $ lastKeys ) ) { $ lastKeys = $ curKeys ; } elseif ( $ curKeys != $ lastKeys ) { $ newKeys = array ( ) ; $ count = \ count ( $ curKeys ) ; for ( $ i = 0 ; $ i < $ count ; $ i ++ ) { $ curKey = $ curKeys [ $ i ] ; if ( $ lastKeys && $ curKey === $ lastKeys [ 0 ] ) { \ array_push ( $ newKeys , $ curKey ) ; \ array_shift ( $ lastKeys ) ; } elseif ( false !== $ position = \ array_search ( $ curKey , $ lastKeys , true ) ) { $ segment = \ array_splice ( $ lastKeys , 0 , $ position + 1 ) ; \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ segment ) ; } elseif ( ! \ in_array ( $ curKey , $ newKeys , true ) ) { \ array_push ( $ newKeys , $ curKey ) ; } } \ array_splice ( $ newKeys , \ count ( $ newKeys ) , 0 , $ lastKeys ) ; $ lastKeys = \ array_unique ( $ newKeys ) ; } } return $ lastKeys ; }
4853	public function getCurrentRealRows ( $ table = null ) { $ table = $ table ? : $ this -> getCurrentTable ( ) ; if ( ! isset ( $ this -> currentRealRows [ $ table ] ) || ! $ this -> currentRealRows [ $ table ] ) { $ fields = $ this -> getPreparedFields ( ) [ $ table ] ; $ this -> currentRealRows [ $ table ] = $ this -> getRealRow ( $ fields , $ table ) ; } return $ this -> currentRealRows [ $ table ] ; }
198	public function xSendFile ( $ filePath , $ attachmentName = null , $ options = [ ] ) { if ( $ attachmentName === null ) { $ attachmentName = basename ( $ filePath ) ; } if ( isset ( $ options [ 'mimeType' ] ) ) { $ mimeType = $ options [ 'mimeType' ] ; } elseif ( ( $ mimeType = FileHelper :: getMimeTypeByExtension ( $ filePath ) ) === null ) { $ mimeType = 'application/octet-stream' ; } if ( isset ( $ options [ 'xHeader' ] ) ) { $ xHeader = $ options [ 'xHeader' ] ; } else { $ xHeader = 'X-Sendfile' ; } $ disposition = empty ( $ options [ 'inline' ] ) ? 'attachment' : 'inline' ; $ this -> getHeaders ( ) -> setDefault ( $ xHeader , $ filePath ) -> setDefault ( 'Content-Type' , $ mimeType ) -> setDefault ( 'Content-Disposition' , $ this -> getDispositionHeaderValue ( $ disposition , $ attachmentName ) ) ; $ this -> format = self :: FORMAT_RAW ; return $ this ; }
7083	public function method ( $ method = NULL ) { if ( $ method === NULL ) { return $ this -> _method ; } $ this -> _method = strtoupper ( $ method ) ; return $ this ; }
10269	function setHTMLContent ( $ mailingId , $ html , $ doImageGrabbing = true , $ doLinkTracking = false ) { $ queryParameters = array ( 'doImageGrabbing' => ( $ doImageGrabbing == TRUE ) ? "true" : "false" , 'doLinkTracking' => ( $ doLinkTracking == TRUE ) ? "true" : "false" ) ; return $ this -> post ( 'mailings/' . $ mailingId . '/contents/html' , $ html , $ queryParameters , "text/html" ) ; }
10423	public function setTriggerType ( $ type ) { if ( ! array_key_exists ( $ type , $ this -> validTypes ) ) { throw new \ InvalidArgumentException ( 'The type MUST be one of:' . implode ( ',' , $ this -> validTypes ) ) ; } $ this -> type = $ this -> validTypes [ $ type ] ; $ this -> typeAlias = $ type ; }
399	protected function deleteInternal ( ) { if ( ! $ this -> beforeDelete ( ) ) { return false ; } $ condition = $ this -> getOldPrimaryKey ( true ) ; $ lock = $ this -> optimisticLock ( ) ; if ( $ lock !== null ) { $ condition [ $ lock ] = $ this -> $ lock ; } $ result = static :: deleteAll ( $ condition ) ; if ( $ lock !== null && ! $ result ) { throw new StaleObjectException ( 'The object being deleted is outdated.' ) ; } $ this -> setOldAttributes ( null ) ; $ this -> afterDelete ( ) ; return $ result ; }
2364	public static function generateAlias ( $ strString ) { $ strString = static :: decodeEntities ( $ strString ) ; $ strString = static :: restoreBasicEntities ( $ strString ) ; $ strString = static :: standardize ( strip_tags ( $ strString ) ) ; if ( strncmp ( $ strString , 'id-' , 3 ) === 0 && ! is_numeric ( $ strSubstr = substr ( $ strString , 3 ) ) ) { $ strString = $ strSubstr ; } return $ strString ; }
5580	public function submitFormById ( $ id , $ additional = false ) { if ( ! ( $ form = $ this -> page -> getFormById ( $ id ) ) ) { return false ; } $ success = $ this -> load ( $ form -> getAction ( ) , $ form -> submit ( $ additional ) ) ; return ( $ success ? $ this -> getContent ( ) : $ success ) ; }
5595	protected function createRoute ( $ url ) { if ( $ this -> proxy ) { return new SimpleProxyRoute ( $ url , $ this -> proxy , $ this -> proxy_username , $ this -> proxy_password ) ; } return new SimpleRoute ( $ url ) ; }
2866	public function getTotalLineCount ( ) { if ( $ this -> logLineCount === null ) { $ this -> logLineCount = 0 ; foreach ( $ this -> getFiles ( ) as $ log ) { $ this -> logLineCount += $ this -> getLineCount ( $ log ) ; } } return $ this -> logLineCount ; }
8190	public function actionRegister ( ) { $ model = new User ( ) ; $ model -> scenario = 'register' ; if ( $ model -> load ( Yii :: $ app -> request -> post ( ) ) && $ model -> register ( FALSE , User :: STATUS_PENDING ) ) { Mailer :: sendWelcomeMessage ( $ model ) ; Yii :: $ app -> session -> setFlash ( 'success' , Yii :: t ( 'user' , 'You\'ve successfully been registered. Check your mail to activate your account' ) ) ; return $ this -> redirect ( Yii :: $ app -> urlManager -> createUrl ( '//user/auth/login' ) ) ; } return $ this -> render ( 'register' , [ 'model' => $ model ] ) ; }
3537	public function getGroupsAssignedInLdap ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; $ ldapGroupsConverted = [ ] ; if ( $ ldapUser != null ) { if ( static :: getGroupAssigmentOptions ( 'SEARCH_NESTED_GROUPS' , $ this -> individualGroupAssignmentOptions ) == true ) { $ ldapGroups = static :: getAdldapProvider ( ) -> search ( ) -> rawFilter ( '(member:1.2.840.113556.1.4.1941:=' . $ ldapUser -> getDn ( ) . ')' ) -> select ( 'cn' ) -> raw ( ) -> get ( ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { if ( is_array ( $ groupDn ) && array_key_exists ( 'cn' , $ groupDn ) ) { array_push ( $ ldapGroupsConverted , $ groupDn [ 'cn' ] [ 0 ] ) ; } } } else { $ ldapGroups = $ ldapUser -> getAttribute ( 'memberof' ) ; if ( $ ldapGroups == null ) { $ ldapGroups = [ ] ; } foreach ( $ ldapGroups as $ groupDn ) { $ n = Utilities :: explodeDn ( $ groupDn ) [ 0 ] ; array_push ( $ ldapGroupsConverted , $ n ) ; } } } if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'getGroupsAssignedInLdap' , static :: YII2_PROFILE_NAME . 'getGroupsAssignedInLdap' ) ; } return $ ldapGroupsConverted ; }
9489	public function getFileData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return null ; } $ obFile = $ this -> $ sFieldName ; if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { return null ; } return $ this -> getFileDataValue ( $ obFile ) ; }
6377	public function toArray ( ) : array { $ res = [ ] ; Iterators :: each ( $ this -> iterator ( ) , function ( $ element ) use ( & $ res ) { $ res [ ] = $ element ; } ) ; return $ res ; }
3158	public function getResponseVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_ResponseVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
11165	protected function getDurationFormat ( array $ config ) { if ( isset ( $ config [ 'durationFormat' ] ) ) { if ( ! is_string ( $ config [ 'durationFormat' ] ) ) { throw new \ DomainException ( 'durationFormat must reference a string' , self :: ERR_INVALID_DURATIONFORMAT ) ; } return $ config [ 'durationFormat' ] ; } return '%im%ss' ; }
8408	public static function set ( $ name , $ value , $ expire = 0 , $ path = null ) { if ( $ path === null ) { setcookie ( $ name , $ value , $ expire ) ; } else { setcookie ( $ name , $ value , $ expire , $ path ) ; } }
3039	public function has ( $ userId , $ callId ) { $ key = $ this -> getCacheKey ( $ userId , $ callId ) ; if ( ! isset ( $ this -> cache [ $ key ] ) ) { return $ this -> getStorage ( ) -> has ( $ userId , $ callId ) ; } return $ this -> exists ( $ key ) ; }
5719	public function cancel ( ) { Controller :: curr ( ) -> getResponse ( ) -> addHeader ( "X-Pjax" , "Content" ) ; return Controller :: curr ( ) -> redirect ( $ this -> getBackLink ( ) ) ; }
1719	public function getNewsArchives ( ) { if ( ! $ this -> User -> isAdmin && ! \ is_array ( $ this -> User -> news ) ) { return array ( ) ; } $ arrArchives = array ( ) ; $ objArchives = $ this -> Database -> execute ( "SELECT id, title FROM tl_news_archive ORDER BY title" ) ; while ( $ objArchives -> next ( ) ) { if ( $ this -> User -> hasAccess ( $ objArchives -> id , 'news' ) ) { $ arrArchives [ $ objArchives -> id ] = $ objArchives -> title ; } } return $ arrArchives ; }
11524	public function parseBotUA ( $ botName ) { $ dom = $ this -> getDom ( 'https://udger.com/resources/ua-list/bot-detail?bot=' . $ botName ) ; if ( false === $ dom ) { echo "Can not parse DOM" . PHP_EOL ; return false ; } $ this -> currentBotName = $ botName ; $ crawlerBot = new Crawler ( ) ; $ crawlerBot -> addContent ( $ dom ) ; $ crawlerBot -> filter ( 'body #container table tr td > a' ) -> each ( function ( $ el , $ i ) { if ( strpos ( $ el -> attr ( 'href' ) , '/resources/online-parser' ) !== false ) { $ botUA = $ el -> text ( ) ; $ this -> addBotUA ( $ botUA ) ; } } ) ; return true ; }
2153	public function updateAccount ( ) { $ intUser = Input :: get ( 'id' ) ; if ( TL_MODE == 'FE' ) { $ this -> import ( FrontendUser :: class , 'User' ) ; $ intUser = $ this -> User -> id ; } if ( ! $ intUser ) { return ; } if ( TL_MODE == 'FE' || Input :: get ( 'act' ) == 'edit' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email, disable FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ strEmail = Input :: post ( 'email' , true ) ; if ( ! empty ( $ _POST ) && $ strEmail != '' && $ strEmail != $ objUser -> email ) { $ objCount = $ this -> Database -> prepare ( "SELECT COUNT(*) AS count FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ strEmail ) ; if ( $ objCount -> count > 0 ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET email=? WHERE email=?" ) -> execute ( $ strEmail , $ objUser -> email ) ; } $ objUser -> email = $ strEmail ; } $ objSubscriptions = $ this -> Database -> prepare ( "SELECT pid FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; if ( $ objSubscriptions -> numRows ) { $ strNewsletters = serialize ( $ objSubscriptions -> fetchEach ( 'pid' ) ) ; } else { $ strNewsletters = '' ; } $ this -> Database -> prepare ( "UPDATE tl_member SET newsletter=? WHERE id=?" ) -> execute ( $ strNewsletters , $ intUser ) ; if ( TL_MODE == 'FE' ) { $ this -> User -> newsletter = $ strNewsletters ; } elseif ( ! empty ( $ _POST ) && Input :: post ( 'disable' ) != $ objUser -> disable ) { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active=? WHERE email=?" ) -> execute ( ( Input :: post ( 'disable' ) ? '' : 1 ) , $ objUser -> email ) ; $ objUser -> disable = Input :: post ( 'disable' ) ; } } } elseif ( Input :: get ( 'act' ) == 'delete' ) { $ objUser = $ this -> Database -> prepare ( "SELECT email FROM tl_member WHERE id=?" ) -> limit ( 1 ) -> execute ( $ intUser ) ; if ( $ objUser -> numRows ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=?" ) -> execute ( $ objUser -> email ) ; } } }
4065	public function getReferencedAttributes ( ) { $ arrAttributes = array ( ) ; foreach ( $ this -> arrChildren as $ objSetting ) { $ arrAttributes = array_merge ( $ arrAttributes , $ objSetting -> getReferencedAttributes ( ) ) ; } return $ arrAttributes ; }
6053	public function retrieveParents ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/folders/' . $ id . '/parents' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new FolderParent ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
7823	protected function updateWorkflow ( $ workflow ) { $ attachments = $ this -> getNamespacedPipesByOption ( 'attach' ) ; $ detachments = $ this -> getNamespacedPipesByOption ( 'detach' ) ; $ this -> pipelines -> update ( $ workflow , $ attachments , $ detachments ) ; }
4707	public function processMultipleUnderScore ( Text $ text ) { $ text -> replace ( '{<pre>.*?</pre>}m' , function ( Text $ w ) { $ md5 = md5 ( $ w ) ; $ this -> hashes [ $ md5 ] = $ w ; return "{gfm-extraction-$md5}" ; } ) ; $ text -> replace ( '/^(?! {4}|\t)(\[?\w+_\w+_\w[\w_]*\]?)/' , function ( Text $ w , Text $ word ) { $ underscores = $ word -> split ( '//' ) -> filter ( function ( Text $ item ) { return $ item == '_' ; } ) ; if ( count ( $ underscores ) >= 2 ) { $ word -> replaceString ( '_' , '\\_' ) ; } return $ word ; } ) ; $ text -> replace ( '/\{gfm-extraction-([0-9a-f]{32})\}/m' , function ( Text $ w , Text $ md5 ) { return "\n\n" . $ this -> hashes [ ( string ) $ md5 ] ; } ) ; }
2240	public static function getTemplateGroup ( $ strPrefix ) { $ arrTemplates = array ( ) ; foreach ( TemplateLoader :: getPrefixedFiles ( $ strPrefix ) as $ strTemplate ) { $ arrTemplates [ $ strTemplate ] [ ] = 'root' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrCustomized = self :: braceGlob ( $ rootDir . '/templates/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrCustomized ) ) { foreach ( $ arrCustomized as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'global' ] ; } } if ( $ strPrefix != 'be_' && $ strPrefix != 'mail_' ) { try { $ objTheme = ThemeModel :: findAll ( array ( 'order' => 'name' ) ) ; } catch ( \ Exception $ e ) { $ objTheme = null ; } if ( $ objTheme !== null ) { while ( $ objTheme -> next ( ) ) { if ( $ objTheme -> templates != '' ) { $ arrThemeTemplates = self :: braceGlob ( $ rootDir . '/' . $ objTheme -> templates . '/' . $ strPrefix . '*.html5' ) ; if ( \ is_array ( $ arrThemeTemplates ) ) { foreach ( $ arrThemeTemplates as $ strFile ) { $ strTemplate = basename ( $ strFile , strrchr ( $ strFile , '.' ) ) ; $ arrTemplates [ $ strTemplate ] [ ] = $ objTheme -> name ; } } } } } } foreach ( $ arrTemplates as $ k => $ v ) { $ v = array_filter ( $ v , function ( $ a ) { return $ a != 'root' ; } ) ; if ( empty ( $ v ) ) { $ arrTemplates [ $ k ] = $ k ; } else { $ arrTemplates [ $ k ] = $ k . ' (' . implode ( ', ' , $ v ) . ')' ; } } ksort ( $ arrTemplates ) ; return $ arrTemplates ; }
7802	protected function statement ( $ text ) { $ text = trim ( $ text ) ; if ( ( $ pos = strpos ( $ text , ':20:' ) ) === false ) { throw new \ RuntimeException ( 'Not an MT940 statement' ) ; } $ this -> statementHeader ( substr ( $ text , 0 , $ pos ) ) ; return $ this -> statementBody ( substr ( $ text , $ pos ) ) ; }
5133	public static function create ( string $ string = '' ) : \ One \ Uri { if ( empty ( $ string ) ) { $ string = '/' ; } return self :: createFromString ( $ string ) ; }
1484	public static function create ( $ mediaType , $ decoder ) : self { if ( is_string ( $ mediaType ) ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } if ( ! $ mediaType instanceof MediaTypeInterface ) { throw new \ InvalidArgumentException ( 'Expecting a media type object or string.' ) ; } if ( is_string ( $ decoder ) ) { $ decoder = app ( $ decoder ) ; } if ( ! $ decoder instanceof DecoderInterface ) { throw new \ InvalidArgumentException ( 'Expecting a decoder or decoder service name.' ) ; } return new self ( $ mediaType , $ decoder ) ; }
6618	protected function parseEndpointName ( $ method , $ endpoint ) { $ endpoint = str_replace ( ' ' , '' , ucwords ( str_replace ( [ '-' , '+' , '%20' ] , ' ' , $ endpoint ) ) ) ; $ method = strtolower ( $ method ) ; return $ method . $ endpoint . 'Endpoint' ; }
9001	public function column_user ( AbstractLog $ item ) { $ user = $ item -> get_user ( ) ; if ( empty ( $ user ) ) { echo '-' ; } else { echo $ user -> display_name ; } }
12500	public static function update ( $ id , $ document , $ connection ) { $ from = $ connection -> db ; if ( strpos ( $ from , '.' ) !== false ) { $ tmp = explode ( '.' , $ connection -> db ) ; $ from = end ( $ tmp ) ; } $ connection -> method = 'PATCH' ; $ connection -> action = '[' . urlencode ( $ id ) . ']' ; switch ( gettype ( $ document ) ) { case "string" : $ connection -> query = $ document ; break ; case "array" : case "object" : $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; $ connection -> query = 'UPDATE ' . $ from . '["' . $ id . '"] SET ' . self :: updateRecursion ( $ document ) ; break ; default : throw new ClusterpointException ( "\"->update()\" function: parametr passed " . json_encode ( self :: escape_string ( $ document ) ) . " is not in valid format." , 9002 ) ; break ; } return self :: sendQuery ( $ connection ) ; }
989	public function save ( ) { if ( ! $ this -> response ) { throw new Exception ( 'No activation response was recieved.' ) ; } $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } $ charge = Charge :: firstOrNew ( [ 'charge_id' => $ this -> chargeId , 'shop_id' => $ this -> shop -> id , ] ) ; $ charge -> plan_id = $ this -> plan -> id ; $ charge -> type = $ this -> plan -> type ; $ charge -> status = $ this -> response -> status ; if ( $ this -> plan -> isType ( Plan :: PLAN_RECURRING ) ) { $ charge -> billing_on = $ this -> response -> billing_on ; $ charge -> trial_ends_on = $ this -> response -> trial_ends_on ; } $ charge -> activated_on = $ this -> response -> activated_on ?? Carbon :: today ( ) -> format ( 'Y-m-d' ) ; $ planDetails = $ this -> chargeParams ( ) ; unset ( $ planDetails [ 'return_url' ] ) ; foreach ( $ planDetails as $ key => $ value ) { $ charge -> { $ key } = $ value ; } return $ charge -> save ( ) ; }
3554	public function getValue ( ) { if ( $ this -> hasMutator ( $ this -> attributes [ 'meta_value' ] , 'getter' , $ this -> attributes [ 'meta_type' ] ) ) { return $ this -> mutateValue ( $ this -> attributes [ 'meta_value' ] , 'getter' ) ; } return $ this -> castValue ( ) ; }
9288	public function truncate ( ) { $ adapter = $ this -> dbAdapter ; $ mapper = new \ CronHelper \ Model \ JobMapper ( $ adapter ) ; $ where = new \ Zend \ Db \ Sql \ Where ( ) ; $ mapper -> deleteByWhere ( $ where ) ; }
9158	protected function addControls ( Response & $ response , Request $ request , View $ view ) { $ matches = array ( ) ; while ( preg_match ( "/\{(\w+)=(\w+)\}/" , $ response -> getBody ( ) , $ matches ) ) { $ controlIdentifier = $ matches [ 1 ] ; $ controlName = $ matches [ 2 ] ; $ currentBody = $ response -> getBody ( ) ; if ( ! isset ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) || ! $ view -> hasControl ( $ controlIdentifier ) ) { $ response -> setBody ( str_replace ( $ matches [ 0 ] , '' , $ currentBody ) ) ; continue ; } if ( $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] instanceof Control ) { $ repl = $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] -> render ( $ request ) ; } else { $ control = $ view -> createControl ( $ controlIdentifier ) ; $ repl = $ control -> render ( $ request , $ this -> viewParams [ $ controlIdentifier ] [ $ controlName ] ) ; } $ response -> setBody ( str_replace ( $ matches [ 0 ] , $ repl , $ currentBody ) ) ; } }
1956	public function styleSheetLink ( Contao \ DataContainer $ dc ) { return ' <a href="contao/main.php?do=themes&amp;table=tl_style_sheet&amp;id=' . $ dc -> activeRecord -> pid . '&amp;popup=1&amp;nb=1&amp;rt=' . REQUEST_TOKEN . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) . '" onclick="Backend.openModalIframe({\'title\':\'' . Contao \ StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'tl_layout' ] [ 'edit_styles' ] ) ) . '\',\'url\':this.href});return false">' . Contao \ Image :: getHtml ( 'edit.svg' ) . '</a>' ; }
10731	public function getMinute ( ) { if ( $ this -> value !== null ) { preg_match ( '/^(?P<year>[0-9]{4,4})-(?P<month>[0-9]{2,2})-(?P<day>[0-9]{2,2}) (?P<hour>[0-9]{2,2}):(?P<minute>[0-9]{2,2}):(?P<second>[0-9]{2,2})$/ui' , $ this -> value , $ m ) ; return ( int ) $ m [ 'minute' ] ; } }
11623	public function close ( ) { if ( $ this -> id == null ) { throw new InternalException ( 'Session not loaded' ) ; } if ( ! $ this -> cli ) { session_write_close ( ) ; } $ this -> id = null ; }
2625	protected function _toHtml ( ) { if ( $ this -> config -> isGeoIpEnabled ( ) == false || $ this -> config -> isFastlyEnabled ( ) == false ) { return parent :: _toHtml ( ) ; } $ actionUrl = $ this -> getUrl ( 'fastlyCdn/geoip/getaction' ) ; $ header = $ this -> response -> getHeader ( 'x-esi' ) ; if ( empty ( $ header ) ) { $ this -> response -> setHeader ( "x-esi" , "1" ) ; } return sprintf ( '<esi:include src=\'%s\' />' , preg_replace ( "/^https/" , "http" , $ actionUrl ) ) ; }
3536	public function updateAccountStatus ( ) { if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: beginProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } $ ldapUser = $ this -> queryLdapUserObject ( ) ; if ( $ ldapUser == null ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ ldapAccountState = $ ldapUser -> getUserAccountControl ( ) ; $ disabledUser = ( $ ldapAccountState & AccountControl :: ACCOUNTDISABLE ) === AccountControl :: ACCOUNTDISABLE ; $ lockedUser = ( $ ldapAccountState & AccountControl :: LOCKOUT ) === AccountControl :: LOCKOUT ; $ pwExpired = ( $ ldapAccountState & AccountControl :: PASSWORD_EXPIRED ) === AccountControl :: PASSWORD_EXPIRED ; if ( $ disabledUser == true || $ lockedUser == true || $ pwExpired == true ) { $ this -> status = static :: STATUS_DISABLED ; } else { $ this -> status = static :: STATUS_ENABLED ; } } $ this -> save ( ) ; if ( static :: getExtensionOptions ( 'ENABLE_YII2_PROFILING' ) == true ) { Yii :: endProfile ( 'LDAP updateAccountStatus function' , static :: YII2_PROFILE_NAME . 'updateAccountStatus' ) ; } return $ this -> status ; }
857	public function overrideRange ( $ indexStart , $ indexEnd , $ items ) { $ oldCode = $ this -> generatePartialCode ( $ indexStart , $ indexEnd ) ; $ newCode = '' ; foreach ( $ items as $ item ) { $ newCode .= $ item -> getContent ( ) ; } if ( $ oldCode === $ newCode ) { return ; } $ indexToChange = $ indexEnd - $ indexStart + 1 ; $ itemsCount = \ count ( $ items ) ; if ( $ itemsCount > $ indexToChange ) { $ placeholders = [ ] ; while ( $ itemsCount > $ indexToChange ) { $ placeholders [ ] = new Token ( '__PLACEHOLDER__' ) ; ++ $ indexToChange ; } $ this -> insertAt ( $ indexEnd + 1 , $ placeholders ) ; } foreach ( $ items as $ itemIndex => $ item ) { $ this [ $ indexStart + $ itemIndex ] = $ item ; } if ( $ itemsCount < $ indexToChange ) { $ this -> clearRange ( $ indexStart + $ itemsCount , $ indexEnd ) ; } }
11856	public function isAjax ( ) : bool { $ param = $ this -> getServerParam ( 'HTTP_X_REQUESTED_WITH' , \ FILTER_SANITIZE_STRING ) ; return ! is_null ( $ param ) && strtolower ( $ param ) === 'xmlhttprequest' ; }
7052	public function logoutCurrentUser ( ) { $ this -> getAuthGuard ( ) -> logout ( ) ; \ Session :: remove ( $ this -> originalUserFromLoginAsActionSessionKey ) ; \ Session :: invalidate ( ) ; $ this -> getCmfConfig ( ) -> resetLocale ( ) ; }
5460	protected function acceptLabelEnd ( ) { if ( isset ( $ this -> label ) ) { if ( isset ( $ this -> last_widget ) ) { $ this -> last_widget -> setLabel ( $ this -> label -> getText ( ) ) ; unset ( $ this -> last_widget ) ; } else { $ this -> left_over_labels [ ] = ( clone $ this -> label ) ; } unset ( $ this -> label ) ; } }
6248	public function getAll ( ) { $ permissions = $ this -> modules -> getAllPermissions ( ) ; $ permissions = array_merge ( $ permissions , $ this -> getCustom ( ) ) ; return array_unique ( $ permissions ) ; }
11656	public function getShortName ( ) { preg_match ( '/Widget([A-Za-z]+)\\\Module/' , get_class ( $ this ) , $ matches ) ; if ( ! isset ( $ matches [ 1 ] ) ) { throw new Exception ( get_class ( $ this ) . " is not set up correctly!" ) ; } return $ matches [ 1 ] ; }
12215	protected function compileConfiguration ( Traversable $ source , string $ target , CompilerContext $ context ) { $ compiler = new StandardCompiler ( ) ; $ compiler -> setSource ( $ source ) ; $ compiler -> setTarget ( $ target ) ; $ compiler -> compile ( ) ; }
654	protected function internalExecute ( $ rawSql ) { $ attempt = 0 ; while ( true ) { try { if ( ++ $ attempt === 1 && $ this -> _isolationLevel !== false && $ this -> db -> getTransaction ( ) === null ) { $ this -> db -> transaction ( function ( ) use ( $ rawSql ) { $ this -> internalExecute ( $ rawSql ) ; } , $ this -> _isolationLevel ) ; } else { $ this -> pdoStatement -> execute ( ) ; } break ; } catch ( \ Exception $ e ) { $ rawSql = $ rawSql ? : $ this -> getRawSql ( ) ; $ e = $ this -> db -> getSchema ( ) -> convertException ( $ e , $ rawSql ) ; if ( $ this -> _retryHandler === null || ! call_user_func ( $ this -> _retryHandler , $ e , $ attempt ) ) { throw $ e ; } } } }
6316	public function setDeleteAction ( $ deleteAction ) { $ deleteAction = strtoupper ( $ deleteAction ) ; if ( ! in_array ( $ deleteAction , $ this -> getAvailableActions ( ) ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Action %s does not exist.' , $ deleteAction ) ) ; } $ this -> deleteAction = $ deleteAction ; }
3881	private function getPageDetails ( $ pageId ) { if ( empty ( $ pageId ) ) { return array ( ) ; } $ event = new GetPageDetailsEvent ( $ pageId ) ; $ this -> getEventDispatcher ( ) -> dispatch ( ContaoEvents :: CONTROLLER_GET_PAGE_DETAILS , $ event ) ; return $ event -> getPageDetails ( ) ; }
6608	public static function getAllProvider ( $ relatedRecords = [ ] , $ sort = [ ] , $ limit = null ) { $ query = self :: find ( ) -> with ( $ relatedRecords ) -> orderBy ( $ sort ) ; return self :: convertToProvider ( $ query , [ ] , $ limit ) ; }
10906	public function remove ( ) : bool { if ( $ this -> test ( \ sndsgd \ Fs :: EXISTS | \ sndsgd \ Fs :: READABLE | \ sndsgd \ Fs :: WRITABLE ) === false ) { $ this -> error = "failed to remove directory; {$this->error}" ; return false ; } foreach ( $ this -> getList ( ) as $ entity ) { if ( $ entity -> remove ( ) === false ) { $ this -> error = $ entity -> getError ( ) ; return false ; } } if ( @ rmdir ( $ this -> path ) === false ) { $ this -> setError ( "failed to remove directory '{$this->path}'" ) ; return false ; } return true ; }
8907	public function get_next_id ( ) { return ( int ) $ this -> _database -> select ( 'AUTO_INCREMENT' ) -> from ( 'information_schema.TABLES' ) -> where ( 'TABLE_NAME' , $ this -> _database -> dbprefix ( $ this -> get_table ( ) ) ) -> where ( 'TABLE_SCHEMA' , $ this -> _database -> database ) -> get ( ) -> row ( ) -> AUTO_INCREMENT ; }
1284	private function resolveLinksForResourceType ( string $ type , array $ links , string $ locale = null ) : array { $ resourceIds = \ array_map ( function ( Link $ link ) : string { return $ link -> getId ( ) ; } , \ array_filter ( $ links , function ( Link $ link ) use ( $ type ) : bool { return $ link -> getLinkType ( ) === $ type ; } ) ) ; $ resources = [ ] ; $ collection = $ this -> fetchResourcesForGivenIds ( $ resourceIds , $ type , $ locale ) ; foreach ( $ collection as $ resource ) { $ resources [ $ type . '.' . $ resource -> getId ( ) ] = $ resource ; } return $ resources ; }
1794	private function getAutoItems ( array $ parameters ) : array { if ( isset ( $ parameters [ 'auto_item' ] ) ) { return [ $ parameters [ 'auto_item' ] ] ; } if ( isset ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) && \ is_array ( $ GLOBALS [ 'TL_AUTO_ITEM' ] ) ) { return $ GLOBALS [ 'TL_AUTO_ITEM' ] ; } return [ ] ; }
1146	public function addConditionalRules ( $ attribute , $ rules = [ ] ) { foreach ( ( array ) $ attribute as $ key ) { $ current = isset ( $ this -> conditional [ $ key ] ) ? $ this -> conditional [ $ key ] : [ ] ; $ merge = head ( $ this -> validator -> explodeRules ( ( array ) $ rules ) ) ; $ this -> conditional [ $ key ] = array_merge ( $ current , $ merge ) ; } }
9426	public function build ( $ options ) { $ command = $ this -> path ; if ( isset ( $ options [ 'title' ] ) ) { $ command .= " -title {$options['title']}" ; } if ( isset ( $ options [ 'subtitle' ] ) ) { $ command .= " -subtitle {$options['subtitle']}" ; } if ( isset ( $ options [ 'message' ] ) ) { $ command .= " -message {$options['message']}" ; } if ( isset ( $ options [ 'image' ] ) ) { $ command .= " -appIcon {$options['image']}" ; } if ( isset ( $ options [ 'contentImage' ] ) ) { $ command .= " -contentImage {$options['contentImage']}" ; } if ( isset ( $ options [ 'url' ] ) ) { $ command .= " -open {$options['url']}" ; } return $ command ; }
5898	public function retrieveVideoTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/videos/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new VideoTemplate ( $ result ) ; return $ result ; }
1472	public function createRelationshipDocumentValidator ( $ document ) { return new Validation \ Spec \ RelationValidator ( $ this -> container -> make ( StoreInterface :: class ) , $ this -> createErrorTranslator ( ) , $ document ) ; }
11981	public function isAccessible ( AcquirerInterface $ acquirer , ResourceInterface $ resource ) { if ( ! $ resource -> isLocked ( ) ) { return true ; } $ lock = $ resource -> getLock ( ) ; if ( $ lock instanceof ExpiringLockInterface and $ this -> isLockExpired ( $ lock ) ) { $ this -> release ( $ lock ) ; return true ; } return $ lock -> getAcquirer ( ) -> getIdentifier ( ) === $ acquirer -> getIdentifier ( ) ; }
8710	public function where ( $ column , $ operator = null , $ value = null , $ boolean = 'and' ) { if ( is_array ( $ column ) ) { return $ this -> addArrayOfWheres ( $ column , $ boolean ) ; } if ( in_array ( $ column , $ this -> model -> translatableAttributes ( ) ) ) { return $ this -> whereTranslated ( $ column , $ operator , $ value , $ boolean ) ; } return parent :: where ( $ column , $ operator , $ value , $ boolean ) ; }
1441	protected function replaceResourceType ( & $ stub ) { $ resource = $ this -> getResourceName ( ) ; $ stub = str_replace ( 'dummyResourceType' , Str :: dasherize ( $ resource ) , $ stub ) ; return $ this ; }
9548	public function validate ( UploadedFile $ file ) { foreach ( $ this -> constraints as $ constraint ) { if ( ! $ constraint -> validate ( $ file ) ) { throw new ConstraintException ( $ constraint , $ file ) ; } } return true ; }
2859	public function getHttpMethodsSelect ( ) { $ options = $ this -> getHttpMethodOptions ( ) ; array_unshift ( $ options , array ( 'value' => '' , 'label' => 'Any' ) ) ; $ select = $ this -> getLayout ( ) -> createBlock ( 'core/html_select' ) ; $ select -> setName ( 'method' ) -> setId ( 'method' ) -> setValue ( $ this -> getRequest ( ) -> getParam ( 'method' ) ) -> setOptions ( $ options ) ; return $ select -> getHtml ( ) ; }
8994	private function update ( ) { if ( null !== $ this -> namespace ) { $ _SESSION [ $ this -> namespace ] = $ this -> sessionData ; } else { $ _SESSION = $ this -> sessionData ; } }
7585	public static function getSDKEndpointRegistry ( ) { $ entryPoints = array ( ) ; require __DIR__ . DIRECTORY_SEPARATOR . 'registry.php' ; foreach ( $ entryPoints as $ funcName => $ className ) { $ className = "SugarAPI\\SDK\\Endpoint\\" . $ className ; $ entryPoints [ $ funcName ] = $ className ; } return $ entryPoints ; }
523	protected function includeMigrationFile ( $ class ) { $ class = trim ( $ class , '\\' ) ; if ( strpos ( $ class , '\\' ) === false ) { if ( is_array ( $ this -> migrationPath ) ) { foreach ( $ this -> migrationPath as $ path ) { $ file = $ path . DIRECTORY_SEPARATOR . $ class . '.php' ; if ( is_file ( $ file ) ) { require_once $ file ; break ; } } } else { $ file = $ this -> migrationPath . DIRECTORY_SEPARATOR . $ class . '.php' ; require_once $ file ; } } }
4430	protected function writeInstallerSummary ( $ errors ) { if ( ! $ errors ) { $ this -> writeSection ( 'You can now continue installation as per instructions in the README.md file!' ) ; return ; } $ this -> writeSection ( array ( 'The command was not able to install everything automatically.' , 'You must do the following changes manually.' , ) , 'error' ) ; $ this -> output -> writeln ( $ errors ) ; }
11296	public function getAttributeValueExtended ( $ name , $ convertDates = true ) { if ( isset ( $ this -> model_data [ $ name ] ) ) { $ result = $ this -> model_data [ $ name ] ; if ( $ result instanceof \ DateTime && $ convertDates == true ) { $ result = $ result -> format ( 'Y-m-d H:i:s' ) ; } return $ result ; } if ( isset ( $ this -> data -> { $ name } ) ) { return $ this -> data -> { $ name } ; } else if ( isset ( $ this -> model_extends ) && isset ( $ this -> model_attributes [ $ this -> model_extends ] ) ) { $ extendedModel = $ this -> { $ this -> model_extends } ; if ( $ extendedModel && $ result = $ extendedModel -> getAttributeValue ( $ name ) ) { return $ result ; } } return null ; }
7088	public function error ( Callable $ action = null ) { if ( $ action ) $ this -> errorAction = $ action ; return $ this -> errorAction ; }
12616	public function setAttributes ( array $ attributes ) { foreach ( $ attributes as $ key => $ attribute ) { if ( ! ( $ attribute instanceof AttributeInterface ) ) { if ( is_array ( $ attribute ) ) { $ attr = new AttributeCollection ( $ key ) ; $ attr -> setAttributes ( $ attribute ) ; $ attribute = $ attr ; } else { $ attribute = new Attribute ( $ key , $ attribute ) ; } } $ this -> attributes [ $ attribute -> getName ( ) ] = $ attribute ; } }
6273	public static function haveExtension ( ) { if ( ! function_exists ( 'dba_handlers' ) ) { return false ; } $ handlers = dba_handlers ( ) ; if ( ! in_array ( 'cdb' , $ handlers ) || ! in_array ( 'cdb_make' , $ handlers ) ) { return false ; } return true ; }
12231	public function copyAttributesFrom ( SimpleXMLElement $ src , $ overwrite = true ) { $ dom = dom_import_simplexml ( $ this ) ; foreach ( dom_import_simplexml ( $ src ) -> attributes as $ attr ) { if ( $ overwrite || ! $ dom -> hasAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName ) ) { $ dom -> setAttributeNS ( $ attr -> namespaceURI , $ attr -> nodeName , $ attr -> nodeValue ) ; } } return $ this ; }
11375	public function upload ( string $ sFile ) { if ( $ _FILES [ $ sFile ] [ 'error' ] > 0 ) { $ this -> _sError = "Error while the upload" ; return false ; } if ( $ _FILES [ $ sFile ] [ 'size' ] > $ this -> _iMaxFile ) { $ this -> _sError = "The file is too big" ; return false ; } $ sExtension = strtolower ( substr ( strrchr ( $ _FILES [ $ sFile ] [ 'name' ] , '.' ) , 1 ) ) ; if ( count ( $ this -> _aAllowExtension ) > 0 && ! in_array ( $ sExtension , $ this -> _aAllowExtension ) ) { $ this -> _sError = "The extension is not good" ; return false ; } $ sPath = str_replace ( 'bundles' . DIRECTORY_SEPARATOR . 'lib' , 'data' . DIRECTORY_SEPARATOR . 'upload' . DIRECTORY_SEPARATOR , __DIR__ ) ; if ( $ this -> _sExtension === null ) { $ this -> setExtension ( $ sExtension ) ; } if ( $ this -> _sName ) { $ sName = $ sPath . $ this -> _sName . '.' . $ this -> _sExtension ; } else { $ sName = $ sPath . md5 ( uniqid ( rand ( ) , true ) ) . '.' . $ this -> _sExtension ; } if ( $ this -> _bProportion === true && ( $ this -> _iWidth || $ this -> _iHeight ) ) { $ aImageSizes = getimagesize ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ fRatio = min ( $ aImageSizes [ 0 ] / $ this -> _iWidth , $ aImageSizes [ 1 ] / $ this -> _iHeight ) ; $ iHeight = $ aImageSizes [ 1 ] / $ fRatio ; $ iWidth = $ aImageSizes [ 0 ] / $ fRatio ; $ fY = ( $ iHeight - $ this -> _iHeight ) / 2 * $ fRatio ; $ fX = ( $ iWidth - $ this -> _iWidth ) / 2 * $ fRatio ; $ rNewImage = imagecreatefromjpeg ( $ _FILES [ $ sFile ] [ 'tmp_name' ] ) ; $ rNewImgTrueColor = imagecreatetruecolor ( $ this -> _iWidth , $ this -> _iHeight ) ; imagecopyresampled ( $ rNewImgTrueColor , $ rNewImage , 0 , 0 , $ fX , $ fY , $ this -> _iWidth , $ this -> _iHeight , $ iWidth * $ fRatio - $ fX * 2 , $ iHeight * $ fRatio - $ fY * 2 ) ; imagejpeg ( $ rNewImgTrueColor , $ sName , 100 ) ; } else { $ bResultat = move_uploaded_file ( $ _FILES [ $ sFile ] [ 'tmp_name' ] , $ sName ) ; if ( $ bResultat ) { return true ; } } }
2192	public function isRegisteredAlias ( Model $ objModel , $ strAlias , $ varValue ) { $ strTable = $ objModel -> getTable ( ) ; return isset ( $ this -> arrAliases [ $ strTable ] [ $ strAlias ] [ $ varValue ] ) ; }
10628	public static function cpuPercentages ( $ cpuCoreInfo1 , $ cpuCoreInfo2 ) { $ cpus = array ( ) ; foreach ( $ cpuCoreInfo1 as $ idx => $ core ) { $ dif = array ( ) ; $ cpu = array ( ) ; $ dif [ 'user' ] = $ cpuCoreInfo2 [ $ idx ] [ 'user' ] - $ cpuCoreInfo1 [ $ idx ] [ 'user' ] ; $ dif [ 'nice' ] = $ cpuCoreInfo2 [ $ idx ] [ 'nice' ] - $ cpuCoreInfo1 [ $ idx ] [ 'nice' ] ; $ dif [ 'sys' ] = $ cpuCoreInfo2 [ $ idx ] [ 'sys' ] - $ cpuCoreInfo1 [ $ idx ] [ 'sys' ] ; $ dif [ 'idle' ] = $ cpuCoreInfo2 [ $ idx ] [ 'idle' ] - $ cpuCoreInfo1 [ $ idx ] [ 'idle' ] ; $ dif [ 'iowait' ] = $ cpuCoreInfo2 [ $ idx ] [ 'iowait' ] - $ cpuCoreInfo1 [ $ idx ] [ 'iowait' ] ; $ dif [ 'irq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'irq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'irq' ] ; $ dif [ 'softirq' ] = $ cpuCoreInfo2 [ $ idx ] [ 'softirq' ] - $ cpuCoreInfo1 [ $ idx ] [ 'softirq' ] ; $ total = array_sum ( $ dif ) ; foreach ( $ dif as $ x => $ y ) { $ cpu [ $ x ] = round ( $ y / $ total * 100 , 2 ) ; } $ cpus [ 'cpu' . $ idx ] = $ cpu ; } return $ cpus ; }
550	public function actionIndex ( ) { $ caches = $ this -> findCaches ( ) ; if ( ! empty ( $ caches ) ) { $ this -> notifyCachesCanBeFlushed ( $ caches ) ; } else { $ this -> notifyNoCachesFound ( ) ; } }
3156	public function getOutcomeVariable ( $ variableIdentifier , $ variableValue ) { if ( ! is_string ( $ variableValue ) && ! is_numeric ( $ variableValue ) ) { $ variableValue = json_encode ( $ variableValue ) ; } $ metaVariable = new \ taoResultServer_models_classes_OutcomeVariable ( ) ; $ metaVariable -> setIdentifier ( $ variableIdentifier ) ; $ metaVariable -> setBaseType ( 'string' ) ; $ metaVariable -> setCardinality ( Cardinality :: getNameByConstant ( Cardinality :: SINGLE ) ) ; $ metaVariable -> setValue ( $ variableValue ) ; return $ metaVariable ; }
3988	public function getChildrenOf ( $ parentTable ) { $ inputScreens = array_filter ( $ this -> getInputScreens ( ) , function ( $ inputScreen ) use ( $ parentTable ) { return ( $ inputScreen [ 'meta' ] [ 'rendertype' ] === 'ctable' ) && ( $ inputScreen [ 'meta' ] [ 'ptable' ] === $ parentTable ) ; } ) ; return $ inputScreens ; }
11803	public static function importFromApp ( $ path ) { $ importPath = APPS_ROOT . DS . $ path . '.php' ; if ( file_exists ( $ importPath ) ) { include_once $ importPath ; } else { throw new SetupException ( "The object to import ($path) not exists." ) ; } }
4974	private function hydrateTree ( NodeInterface $ object , \ ArrayObject $ currentData = null ) { if ( null === $ currentData ) { $ currentData = $ this -> hydrateData [ '__root__' ] ; } if ( 'set' == $ currentData [ 'do' ] ) { $ object -> setName ( $ currentData [ 'name' ] ) -> setValue ( $ currentData [ 'value' ] ) -> setPriority ( $ currentData [ 'priority' ] ) ; } if ( isset ( $ this -> hydrateData [ $ currentData [ 'current' ] ] ) ) { foreach ( $ this -> hydrateData [ $ currentData [ 'current' ] ] as $ childData ) { $ child = $ this -> findOrCreateChild ( $ object , $ childData [ 'id' ] ) ; if ( 'remove' == $ childData [ 'do' ] ) { $ object -> removeChild ( $ child ) ; } else { $ this -> hydrateTree ( $ child , $ childData ) ; } } } return $ object ; }
7707	function _ApplyDiffToAll ( $ Diff ) { $ this -> PosBeg += $ Diff ; $ this -> PosEnd += $ Diff ; $ this -> pST_PosEnd += $ Diff ; if ( $ this -> pET_PosBeg !== false ) $ this -> pET_PosBeg += $ Diff ; }
1975	public static function findMultipleFilesByFolder ( $ strPath , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ strPath = str_replace ( array ( '\\' , '%' , '_' ) , array ( '\\\\' , '\\%' , '\\_' ) , $ strPath ) ; return static :: findBy ( array ( "$t.type='file' AND $t.path LIKE ? AND $t.path NOT LIKE ?" ) , array ( $ strPath . '/%' , $ strPath . '/%/%' ) , $ arrOptions ) ; }
8933	private function addDependency ( $ name , $ template ) { $ this -> commands [ ] = strtr ( $ template , [ '$namespace' => $ this -> namespaceRoot , '$name' => $ name ] ) ; }
12498	public static function insertOne ( $ document , $ connection ) { $ connection -> query = self :: singleDocument ( $ document ) ; return self :: insert ( $ connection ) ; }
11718	protected function basicFetchQuery ( $ context , array $ args ) { if ( $ context !== 'person' ) { throw new \ LogicException ( 'TimelineAccompanyingPeriod is not able ' . 'to render context ' . $ context ) ; } $ metadata = $ this -> em -> getClassMetadata ( 'ChillPersonBundle:AccompanyingPeriod' ) ; return array ( 'id' => $ metadata -> getColumnName ( 'id' ) , 'date' => $ metadata -> getColumnName ( 'openingDate' ) , 'FROM' => $ metadata -> getTableName ( ) , ) ; }
4103	public function search ( $ query , array $ options = array ( ) ) { $ start = microtime ( true ) ; $ result = $ this -> transport -> search ( $ query , $ options ) ; $ result [ 'time' ] = microtime ( true ) - $ start ; return $ result ; }
2633	public function execute ( ) { $ output = $ this -> layoutFactory -> create ( ) -> createBlock ( 'Fastly\Cdn\Block\Dashboard\Tab\Stats\Historic' ) -> toHtml ( ) ; $ resultRaw = $ this -> resultRawFactory -> create ( ) ; return $ resultRaw -> setContents ( $ output ) ; }
6696	protected function hideMethod ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } $ this -> hiddenMethods [ $ methodName ] = true ; return $ this ; }
4473	public function heartbeat ( array $ data = [ ] ) : float { try { $ this -> expires = $ this -> client -> heartbeat ( $ this -> jid , $ this -> worker , json_encode ( $ data , JSON_UNESCAPED_SLASHES ) ) ; } catch ( QlessException $ e ) { throw new LostLockException ( $ e -> getMessage ( ) , 'Heartbeat' , $ this -> jid , $ e -> getCode ( ) , $ e ) ; } return $ this -> expires ; }
9258	protected function dumpContainer ( ConfigCache $ cache , ContainerBuilder $ container , $ class , $ baseClass ) { $ dumper = new PhpDumper ( $ container ) ; $ content = $ dumper -> dump ( array ( 'class' => $ class , 'base_class' => $ baseClass ) ) ; $ cache -> write ( $ content , $ container -> getResources ( ) ) ; }
6665	public function parseFb ( $ raw_profile ) { $ profile = $ raw_profile ; $ profile -> avatar = sprintf ( 'http://graph.facebook.com/%s/picture' , $ profile -> id ) ; return ( array ) $ profile ; }
4192	protected function dumpPhpDoc ( $ phpDoc ) { $ str = '' ; foreach ( $ phpDoc as $ k => $ values ) { if ( ! \ is_array ( $ values ) ) { continue ; } foreach ( $ values as $ value ) { if ( $ k == 'link' ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } elseif ( $ k == 'see' && $ value [ 'uri' ] ) { $ value = '<a href="' . $ value [ 'uri' ] . '" target="_blank">' . \ htmlspecialchars ( $ value [ 'desc' ] ? : $ value [ 'uri' ] ) . '</a>' ; } else { $ value = \ htmlspecialchars ( \ implode ( ' ' , $ value ) ) ; } $ str .= '<dd class="phpdoc phpdoc-' . $ k . '">' . '<span class="phpdoc-tag">' . $ k . '</span>' . '<span class="t_operator">:</span> ' . $ value . '</dd>' . "\n" ; } } if ( $ str ) { $ str = '<dt class="phpDoc">phpDoc</dt>' . "\n" . $ str ; } return $ str ; }
1565	public function getResource ( ) { if ( ! $ this -> resource_type || ! $ this -> resource_id ) { return null ; } return $ this -> getApi ( ) -> getStore ( ) -> find ( ResourceIdentifier :: create ( $ this -> resource_type , ( string ) $ this -> resource_id ) ) ; }
3417	protected function getValueFromLanguageField ( $ field ) { $ key = $ field . '_' . $ this -> getCurrentLanguage ( ) ; return isset ( $ this -> fields [ $ key ] ) ? $ this -> fields [ $ key ] : null ; }
12625	public function get ( $ url , $ data = array ( ) ) { $ client = $ this -> getClient ( ) ; return $ client -> request ( 'GET' , $ url , array ( 'query' => $ data ) ) ; }
8045	public static function select ( array $ readSockets = array ( ) , array $ writeSockets = array ( ) , array $ exceptSockets = array ( ) , $ sec = 0 , $ usec = 0 ) { $ out = array ( ) ; $ out [ 'read' ] = array ( ) ; $ out [ 'write' ] = array ( ) ; $ out [ 'except' ] = array ( ) ; if ( count ( $ readSockets ) === 0 ) { return $ out ; } $ readSocketsResources = array ( ) ; $ writeSocketsResources = array ( ) ; $ exceptSocketsResources = array ( ) ; $ readSockets = self :: createSocketsIndex ( $ readSockets , $ readSocketsResources ) ; $ writeSockets = self :: createSocketsIndex ( $ writeSockets , $ writeSocketsResources ) ; $ exceptSockets = self :: createSocketsIndex ( $ exceptSockets , $ exceptSocketsResources ) ; $ socketsSelected = @ socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { $ socketError = socket_last_error ( ) ; if ( $ socketError === SOCKET_EINTR ) { socket_clear_error ( ) ; $ socketsSelected = socket_select ( $ readSocketsResources , $ writeSocketsResources , $ exceptSocketsResources , $ sec , $ usec ) ; if ( $ socketsSelected === FALSE ) { return $ out ; } } else { trigger_error ( sprintf ( 'socket_select(): unable to select [%d]: %s' , $ socketError , socket_strerror ( $ socketError ) ) , E_USER_WARNING ) ; return $ out ; } } foreach ( $ readSocketsResources as $ socketResource ) { $ out [ 'read' ] [ ] = $ readSockets [ intval ( $ socketResource ) ] ; } foreach ( $ writeSocketsResources as $ socketResource ) { $ out [ 'write' ] [ ] = $ writeSockets [ intval ( $ socketResource ) ] ; } foreach ( $ exceptSocketsResources as $ socketResource ) { $ out [ 'except' ] [ ] = $ exceptSockets [ intval ( $ socketResource ) ] ; } return $ out ; }
3333	public function createGroup ( $ files ) { $ data = array ( 'pub_key' => $ this -> api -> getPublicKey ( ) , ) ; foreach ( $ files as $ i => $ file ) { $ data [ "files[$i]" ] = $ file -> getUrl ( ) ; } $ ch = $ this -> __initRequest ( 'group' ) ; $ this -> __setRequestType ( $ ch ) ; $ this -> __setData ( $ ch , $ data ) ; $ this -> __setHeaders ( $ ch ) ; $ resp = $ this -> __runRequest ( $ ch ) ; $ group = $ this -> api -> getGroup ( $ resp -> id ) ; return $ group ; }
4039	protected function getClassForOption ( $ index ) { $ intSub = ( $ this -> arrConfiguration [ 'includeBlankOption' ] ? - 1 : 1 ) ; $ strClass = $ this -> strName ; if ( $ index == 0 ) { $ strClass .= ' first' ; } elseif ( $ index === ( count ( $ this -> options ) - $ intSub ) ) { $ strClass .= ' last' ; } if ( ( $ index % 2 ) == 1 ) { $ strClass .= ' even' ; } else { $ strClass .= ' odd' ; } return ( ( strlen ( $ this -> strClass ) ) ? ' ' . $ this -> strClass : '' ) . $ strClass ; }
7123	protected function updateTicket ( TicketMessageInterface $ message ) { $ ticket = $ message -> getTicket ( ) -> setUpdatedAt ( new \ DateTime ( ) ) ; if ( $ message -> isLatest ( ) && ( $ ticket -> getState ( ) !== TicketStates :: STATE_CLOSED ) ) { if ( $ message -> isCustomer ( ) ) { if ( $ ticket -> getState ( ) === TicketStates :: STATE_PENDING ) { $ ticket -> setState ( TicketStates :: STATE_OPENED ) ; } } elseif ( $ ticket -> getState ( ) === TicketStates :: STATE_OPENED ) { $ ticket -> setState ( TicketStates :: STATE_PENDING ) ; } } $ this -> persistenceHelper -> persistAndRecompute ( $ ticket , false ) ; }
11244	public function setUp ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startUp = $ start -> normalize ( ) ; $ this -> endUp = $ end -> normalize ( ) ; }
10335	public function setSuperscript ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = false ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'superscript' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> superscript = $ pValue ; $ this -> subscript = ! $ pValue ; } return $ this ; }
9434	public function rho ( $ float_min , $ float_max ) { self :: checkOrder ( $ float_min , $ float_max ) ; if ( $ float_min < 0 || $ float_max < 0 ) { throw new \ InvalidArgumentException ( 'Rho value must be a positive number!' ) ; } if ( $ this -> r || $ this -> i ) { throw new \ RuntimeException ( 'You cannot set rho value, because algebraic form is in use.' ) ; } $ this -> rho = new \ stdClass ( ) ; $ this -> rho -> min = $ float_min ; $ this -> rho -> max = $ float_max ; return $ this ; }
5626	public function addRequestParameter ( $ key , $ value ) { $ this -> raw = false ; $ this -> request -> add ( $ key , $ value ) ; }
1479	public function removeRelationship ( $ resourceType , $ id , $ relationshipKey , array $ queryParams = [ ] ) { $ name = RouteName :: removeRelationship ( $ resourceType , $ relationshipKey ) ; return $ this -> resource ( $ name , $ id , $ queryParams ) ; }
7951	public function orderCacheRule ( $ nbCacheRule , $ duration ) { return json_decode ( self :: getClient ( ) -> orderCacheRule ( $ this -> sn , $ nbCacheRule , $ duration ) ) ; }
5389	public function setValue ( $ value ) { if ( ! $ this -> valueIsPossible ( $ value ) ) { return false ; } $ index = false ; $ widgets = $ this -> getWidgets ( ) ; for ( $ i = 0 , $ count = count ( $ widgets ) ; $ i < $ count ; $ i ++ ) { if ( ! $ widgets [ $ i ] -> setValue ( $ value ) ) { $ widgets [ $ i ] -> setValue ( false ) ; } } return true ; }
7857	public function register ( ) { $ this -> registerPipelineRepository ( ) ; $ this -> registerInflector ( ) ; $ this -> registerDispatcher ( ) ; $ this -> registerWorkflow ( ) ; $ this -> registerWorkflowRunnersHook ( ) ; $ this -> registerCommands ( ) ; }
7572	public function post ( Array $ postVars , Array $ headers , $ url = null ) { try { $ this -> guzzleResponse = $ this -> _client -> request ( 'POST' , $ url , array ( 'multipart' => $ postVars , 'headers' => $ headers ) ) ; } catch ( RequestException $ e ) { throw new GreenhouseAPIResponseException ( $ e -> getMessage ( ) , 0 , $ e ) ; } return ( string ) $ this -> guzzleResponse -> getBody ( ) ; }
3099	public function getItems ( RunnerServiceContext $ serviceContext ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ serviceContext ) ; $ runnerService = $ this -> getRunnerService ( ) ; $ testMap = $ runnerService -> getTestMap ( $ serviceContext ) ; $ items = [ ] ; foreach ( $ this -> getItemIdentifiersFromTestMap ( $ testMap ) as $ itemIdentifier ) { $ itemRef = $ runnerService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; $ items [ $ itemIdentifier ] = [ 'baseUrl' => $ runnerService -> getItemPublicUrl ( $ serviceContext , $ itemRef ) , 'itemData' => $ this -> getItemData ( $ serviceContext , $ itemRef ) , 'itemState' => $ runnerService -> getItemState ( $ serviceContext , $ itemIdentifier ) , 'itemIdentifier' => $ itemIdentifier , 'portableElements' => $ runnerService -> getItemPortableElements ( $ serviceContext , $ itemRef ) , ] ; } return $ items ; }
8258	protected function finishAuthentication ( Request $ httpRequest ) { $ sessionCode = $ this -> session -> get ( "oauth2state" ) ; $ this -> session -> remove ( "oauth2state" ) ; if ( $ httpRequest -> query -> get ( "state" ) !== $ sessionCode ) { $ this -> onStateMismatch ( ) ; } if ( $ httpRequest -> query -> has ( "error" ) ) { $ this -> onOAuthError ( $ httpRequest -> query -> get ( "error" ) ) ; } if ( ! $ httpRequest -> query -> has ( "code" ) ) { $ this -> onOAuthError ( "no_code" ) ; } try { $ accessToken = $ this -> provider -> getAccessToken ( 'authorization_code' , [ 'code' => $ httpRequest -> query -> get ( "code" ) , ] ) ; $ resourceOwner = $ this -> provider -> getResourceOwner ( $ accessToken ) ; $ this -> saveLoginInfo ( $ resourceOwner ) ; } catch ( IdentityProviderException $ e ) { $ this -> onOauthResourceError ( $ e ) ; } }
6824	protected function getTaxAccountNumber ( float $ rate , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_TAX ) { continue ; } if ( 0 !== bccomp ( $ account -> getTax ( ) -> getRate ( ) , $ rate , 5 ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No tax account number configured for tax rate '%s' (%s)" , $ rate , $ origin ) ) ; }
2200	public static function findPublishedByPidAndColumn ( $ intPid , $ strColumn , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.inColumn=?" ) ; $ arrValues = array ( $ intPid , $ strColumn ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ arrValues , $ arrOptions ) ; }
2903	public function downloadAsText ( Mage_Core_Model_Config_Element $ configNode ) { $ items = array ( ) ; Mage :: helper ( 'sheep_debug' ) -> xml2array ( $ configNode , $ items ) ; $ content = '' ; foreach ( $ items as $ key => $ value ) { $ content .= "$key = $value\n" ; } $ this -> _prepareDownloadResponse ( 'config.txt' , $ content , 'text/plain' ) ; }
3701	private function convertRenderGroupType ( $ type ) { $ lookup = [ 'char' => GroupAndSortingInformationInterface :: GROUP_CHAR , 'digit' => GroupAndSortingInformationInterface :: GROUP_DIGIT , 'day' => GroupAndSortingInformationInterface :: GROUP_DAY , 'weekday' => GroupAndSortingInformationInterface :: GROUP_WEEKDAY , 'week' => GroupAndSortingInformationInterface :: GROUP_WEEK , 'month' => GroupAndSortingInformationInterface :: GROUP_MONTH , 'year' => GroupAndSortingInformationInterface :: GROUP_YEAR , ] ; if ( array_key_exists ( $ type , $ lookup ) ) { return $ lookup [ $ type ] ; } return GroupAndSortingInformationInterface :: GROUP_NONE ; }
11621	public function view ( ) : \ TheCMSThread \ Core \ Main \ View { static $ view ; if ( $ view === null ) { $ view = $ this -> container -> get ( "TheCMSThread\\Core\\Main\\View" ) ; } $ view -> __construct ( $ this -> auth ( ) ) ; return $ view ; }
10018	public function removeNamedRange ( $ namedRange , Worksheet $ pSheet = null ) { if ( $ pSheet === null ) { if ( isset ( $ this -> namedRanges [ $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ namedRange ] ) ; } } else { if ( isset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ) { unset ( $ this -> namedRanges [ $ pSheet -> getTitle ( ) . '!' . $ namedRange ] ) ; } } return $ this ; }
761	public function getSql ( ) { $ code = $ this ; while ( $ code -> parent !== null ) { $ code = $ code -> parent ; } return mb_substr ( $ code -> content , $ this -> startOffset , $ this -> endOffset - $ this -> startOffset , 'UTF-8' ) ; }
7447	function decrypt ( $ data , $ password ) { $ data = base64_decode ( $ data ) ; $ salt = substr ( $ data , 0 , 16 ) ; $ ct = substr ( $ data , 16 ) ; $ rounds = 3 ; $ data00 = $ password . $ salt ; $ hash = array ( ) ; $ hash [ 0 ] = hash ( 'sha256' , $ data00 , true ) ; $ result = $ hash [ 0 ] ; for ( $ i = 1 ; $ i < $ rounds ; $ i ++ ) { $ hash [ $ i ] = hash ( 'sha256' , $ hash [ $ i - 1 ] . $ data00 , true ) ; $ result .= $ hash [ $ i ] ; } $ key = substr ( $ result , 0 , 32 ) ; $ iv = substr ( $ result , 32 , 16 ) ; return openssl_decrypt ( $ ct , 'AES-256-CBC' , $ key , true , $ iv ) ; }
11546	public function changeSecurityQuestion ( $ data ) { if ( ! ( $ user = $ this -> hydrate ( $ data , $ this -> getChangeSecurityQuestionForm ( ) ) ) ) { return ; } $ eventManager = $ this -> getEventManager ( ) ; $ eventManager -> trigger ( __METHOD__ , $ this , $ user ) ; $ this -> getMapper ( ) -> update ( $ user ) -> save ( ) ; $ eventManager -> trigger ( __METHOD__ . '.post' , $ this , $ user ) ; return $ user ; }
12565	public function sendImage ( $ message , $ to = null ) { return $ this -> send ( self :: MSG_TYPE_IMAGE , $ message , $ to ) ; }
1247	public static function ini ( $ profile = null , $ filename = null ) { $ filename = $ filename ? : ( self :: getHomeDir ( ) . '/.ebay_sdk/credentials' ) ; $ profile = $ profile ? : ( getenv ( self :: ENV_PROFILE ) ? : 'default' ) ; return function ( ) use ( $ filename , $ profile ) { if ( ! is_readable ( $ filename ) ) { return new \ InvalidArgumentException ( "Cannot read credentials from $filename" ) ; } $ data = parse_ini_file ( $ filename , true ) ; if ( $ data === false ) { return new \ InvalidArgumentException ( "Invalid credentials file $filename" ) ; } if ( ! isset ( $ data [ $ profile ] ) ) { return new \ InvalidArgumentException ( "'$profile' not found in credentials file" ) ; } if ( ! isset ( $ data [ $ profile ] [ 'ebay_app_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_cert_id' ] ) || ! isset ( $ data [ $ profile ] [ 'ebay_dev_id' ] ) ) { return new \ InvalidArgumentException ( "No credentials present in INI profile '$profile' ($filename)" ) ; } return new Credentials ( $ data [ $ profile ] [ 'ebay_app_id' ] , $ data [ $ profile ] [ 'ebay_cert_id' ] , $ data [ $ profile ] [ 'ebay_dev_id' ] ) ; } ; }
3467	public function patch ( string $ route , callable $ controller ) : void { $ this -> register ( $ controller , Route :: patch ( $ route ) ) ; }
10276	public static function getTextWidthPixelsApprox ( $ columnText , \ PhpOffice \ PhpSpreadsheet \ Style \ Font $ font , $ rotation = 0 ) { $ fontName = $ font -> getName ( ) ; $ fontSize = $ font -> getSize ( ) ; switch ( $ fontName ) { case 'Calibri' : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; case 'Arial' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; case 'Verdana' : $ columnWidth = ( int ) ( 8 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 10 ; break ; default : $ columnWidth = ( int ) ( 8.26 * StringHelper :: countCharacters ( $ columnText ) ) ; $ columnWidth = $ columnWidth * $ fontSize / 11 ; break ; } if ( $ rotation !== 0 ) { if ( $ rotation == - 165 ) { $ columnWidth = 4 ; } else { $ columnWidth = $ columnWidth * cos ( deg2rad ( $ rotation ) ) + $ fontSize * abs ( sin ( deg2rad ( $ rotation ) ) ) / 5 ; } } return ( int ) $ columnWidth ; }
8529	public function listFinancialEvents ( $ request ) { if ( ! ( $ request instanceof MWSFinancesService_Model_ListFinancialEventsRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsRequest.php' ) ; $ request = new MWSFinancesService_Model_ListFinancialEventsRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListFinancialEvents' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/ListFinancialEventsResponse.php' ) ; $ response = MWSFinancesService_Model_ListFinancialEventsResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
1831	public function detach ( $ blnKeepClone = true ) { $ registry = Registry :: getInstance ( ) ; if ( ! $ registry -> isRegistered ( $ this ) ) { return ; } $ registry -> unregister ( $ this ) ; if ( $ blnKeepClone ) { $ this -> cloneOriginal ( ) -> attach ( ) ; } }
10683	public function preferred ( array $ types ) : ? string { if ( empty ( $ types ) ) { return null ; } foreach ( $ this -> types as $ type ) { if ( in_array ( $ type , $ types , true ) ) { return $ type ; } elseif ( '*/*' == $ type ) { return current ( $ types ) ; } elseif ( strlen ( $ type ) > 2 && substr ( $ type , - 2 , 2 ) == '/*' ) { $ prefix = substr ( $ type , 0 , strpos ( $ type , '/' ) + 1 ) ; $ plen = strlen ( $ prefix ) ; foreach ( $ types as $ t ) { if ( strncmp ( $ prefix , $ t , $ plen ) === 0 ) { return $ t ; } } } } return null ; }
7927	public function registerNamespace ( $ ns , $ def ) { list ( $ ns , $ def ) = $ this -> fireEvent ( 'namespace.register' , [ $ ns , $ def ] ) ; $ this -> namespaces [ $ ns ] = $ def ; return $ this ; }
7039	public function getShippedAt ( $ latest = false ) { if ( 0 == $ this -> shipments -> count ( ) ) { return null ; } $ criteria = Criteria :: create ( ) ; $ criteria -> andWhere ( Criteria :: expr ( ) -> eq ( 'return' , false ) ) -> andWhere ( Criteria :: expr ( ) -> in ( 'state' , [ ShipmentStates :: STATE_READY , ShipmentStates :: STATE_SHIPPED ] ) ) -> orderBy ( [ 'createdAt' => $ latest ? Criteria :: DESC : Criteria :: ASC ] ) ; $ shipments = $ this -> shipments ; $ shipments = $ shipments -> matching ( $ criteria ) ; if ( false !== $ shipment = $ shipments -> first ( ) ) { return $ shipment -> getCreatedAt ( ) ; } return null ; }
6359	public function limit ( int $ limit ) : BufferedIterable { Preconditions :: checkArgument ( 0 < $ limit , 'Limit must be a positive integer!' ) ; return new BufferedIterable ( $ this -> chunkProvider , $ this -> filter , $ limit , $ this -> providerCallLimit ) ; }
1696	public static function findByIds ( $ arrIds ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ objDatabase = Database :: getInstance ( ) ; $ arrIds = array_map ( '\intval' , $ arrIds ) ; $ objResult = $ objDatabase -> execute ( "SELECT *, (SELECT tstamp FROM tl_theme WHERE tl_theme.id=tl_style_sheet.pid) AS tstamp3, (SELECT MAX(tstamp) FROM tl_style WHERE tl_style.pid=tl_style_sheet.id) AS tstamp2, (SELECT COUNT(*) FROM tl_style WHERE tl_style.selector='@font-face' AND tl_style.invisible='' AND tl_style.pid=tl_style_sheet.id) AS hasFontFace FROM tl_style_sheet WHERE id IN (" . implode ( ',' , $ arrIds ) . ") ORDER BY " . $ objDatabase -> findInSet ( 'id' , $ arrIds ) ) ; return static :: createCollectionFromDbResult ( $ objResult , 'tl_style_sheet' ) ; }
4354	protected function setFile ( $ file ) { if ( $ file == $ this -> file ) { return ; } if ( $ this -> fileHandle ) { \ fclose ( $ this -> fileHandle ) ; $ this -> fileHandle = null ; } $ this -> file = $ file ; if ( empty ( $ file ) ) { return ; } $ fileExists = \ file_exists ( $ file ) ; $ this -> fileHandle = \ fopen ( $ file , 'a' ) ; if ( $ this -> fileHandle ) { \ fwrite ( $ this -> fileHandle , '***** ' . \ date ( 'Y-m-d H:i:s' ) . ' *****' . "\n" ) ; if ( ! $ fileExists ) { \ chmod ( $ file , 0660 ) ; } } }
5380	public function setValue ( $ value ) { for ( $ i = 0 , $ count = count ( $ this -> options ) ; $ i < $ count ; $ i ++ ) { if ( $ this -> options [ $ i ] -> isValue ( $ value ) ) { $ this -> choice = $ i ; return true ; } } return false ; }
1744	public function deleteFile ( $ row , $ href , $ label , $ title , $ icon , $ attributes ) { $ rootDir = Contao \ System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ path = $ rootDir . '/' . urldecode ( $ row [ 'id' ] ) ; if ( ! is_dir ( $ path ) ) { return ( $ this -> User -> hasAccess ( 'f3' , 'fop' ) || $ this -> User -> hasAccess ( 'f4' , 'fop' ) ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } $ finder = Symfony \ Component \ Finder \ Finder :: create ( ) -> in ( $ path ) ; if ( $ finder -> count ( ) > 0 ) { return $ this -> User -> hasAccess ( 'f4' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; } return $ this -> User -> hasAccess ( 'f3' , 'fop' ) ? '<a href="' . $ this -> addToUrl ( $ href . '&amp;id=' . $ row [ 'id' ] ) . '" title="' . Contao \ StringUtil :: specialchars ( $ title ) . '"' . $ attributes . '>' . Contao \ Image :: getHtml ( $ icon , $ label ) . '</a> ' : Contao \ Image :: getHtml ( preg_replace ( '/\.svg$/i' , '_.svg' , $ icon ) ) . ' ' ; }
6613	public function settings ( $ setting = null ) { if ( ! is_null ( $ setting ) ) { return isset ( $ this -> settings [ $ setting ] ) ? $ this -> settings [ $ setting ] : null ; } return $ this -> settings ; }
9175	public function fromRoute ( $ route = null , $ params = [ ] , $ options = [ ] , $ reuseMatchedParams = false ) { $ controller = $ this -> getController ( ) ; if ( ! $ controller || ! method_exists ( $ controller , 'plugin' ) ) { throw new Exception \ DomainException ( 'Redirect plugin requires a controller that defines the plugin() method' ) ; } $ referer = $ controller -> getRequest ( ) -> getHeader ( 'Referer' ) ; if ( $ referer ) { $ refererUrl = $ referer -> uri ( ) -> getPath ( ) ; $ refererHost = $ referer -> uri ( ) -> getHost ( ) ; $ host = $ controller -> getRequest ( ) -> getUri ( ) -> getHost ( ) ; if ( $ refererUrl && ( $ refererHost == $ host ) ) { return $ refererUrl ; } } $ urlPlugin = $ controller -> plugin ( 'url' ) ; return $ urlPlugin -> fromRoute ( $ route , $ params , $ options , $ reuseMatchedParams ) ; }
5915	public function sendPasswordReset ( $ id , $ link = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'link' => $ link ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '/resetpassword' , $ parameters ) ; return $ result ; }
1262	protected function compileEndpointUrl ( $ segment ) { $ base = ( $ this -> useIntegration ? $ this -> integrationBaseUrl : $ this -> productionBaseUrl ) ; return $ base . $ segment ; }
12823	protected function createContributorDir ( $ sourceDir , array $ options , $ username ) { if ( null === $ username ) { return ; } $ this -> init ( $ sourceDir , $ options , $ username ) ; if ( is_dir ( $ this -> contributorDir ) ) { return ; } $ this -> filesystem -> copy ( $ this -> productionDir . '/slot.json' , $ this -> contributorDir . '/slot.json' , true ) ; $ this -> filesystem -> mirror ( $ this -> productionDir . '/blocks' , $ this -> contributorDir . '/blocks' ) ; }
8704	public function apply ( EloquentBuilder $ builder , Eloquent $ model ) { $ this -> table = $ model -> getTable ( ) ; $ this -> locale = $ model -> getLocale ( ) ; $ this -> i18nTable = $ model -> getI18nTable ( ) ; $ this -> fallback = $ model -> getFallbackLocale ( ) ; if ( ! starts_with ( $ this -> table , 'laravel_reserved_' ) ) { $ this -> createJoin ( $ builder , $ model ) ; $ this -> createWhere ( $ builder , $ model ) ; $ this -> createSelect ( $ builder , $ model ) ; } }
9446	public function getConfigsPath ( Container $ app ) { static $ paths = [ ] ; $ me = get_class ( $ this ) ; if ( empty ( $ paths [ $ me ] ) ) { $ subpath = $ this -> packOptions [ 'configs_subpath' ] ; $ paths [ $ me ] = dirname ( $ this -> getReflector ( ) -> getFileName ( ) ) . '/' . $ subpath ; } return $ paths [ $ me ] ; }
2340	protected function getEditUrl ( ) { if ( $ this -> strEditUrl !== null ) { return sprintf ( $ this -> strEditUrl , $ this -> intPid ) ; } $ strUrl = Environment :: get ( 'request' ) ; if ( preg_match ( '/&(amp;)?state=/' , $ strUrl ) ) { $ strUrl = preg_replace ( array ( '/&(amp;)?id=[^&]+/' , '/(&(amp;)?)t(id=[^&]+)/' , '/(&(amp;)?)state=[^&]*/' ) , array ( '' , '$1$3' , '$1act=edit' ) , $ strUrl ) ; } if ( preg_match ( '/do=login(&|$)/' , $ strUrl ) ) { $ strUrl = preg_replace ( '/do=login(&|$)/' , 'do=user$1' , $ strUrl ) ; $ strUrl .= '&amp;act=edit&amp;id=' . $ this -> User -> id . '&amp;rt=' . REQUEST_TOKEN ; } $ strUrl = preg_replace ( '/act=(edit|override)All/' , 'act=edit&id=' . $ this -> intPid , $ strUrl ) ; return $ strUrl ; }
812	private function fixSpaceBelowClassMethod ( Tokens $ tokens , $ classEndIndex , $ elementEndIndex ) { $ nextNotWhite = $ tokens -> getNextNonWhitespace ( $ elementEndIndex ) ; $ this -> correctLineBreaks ( $ tokens , $ elementEndIndex , $ nextNotWhite , $ nextNotWhite === $ classEndIndex ? 1 : 2 ) ; }
6203	public static function start ( $ apiKey , $ notifyOnWarning = false , array $ options = array ( ) ) { if ( ! isset ( self :: $ instance ) ) { $ config = new Configuration ( $ apiKey , $ options ) ; $ client = new Client ( $ config ) ; self :: $ instance = new self ( $ client , $ notifyOnWarning ) ; if ( null !== $ config -> get ( 'errorReportingLevel' ) ) { self :: $ instance -> addErrorFilter ( new ErrorReporting ( $ config ) ) ; } self :: $ instance -> addExceptionFilter ( new AirbrakeExceptionFilter ( ) ) ; set_error_handler ( array ( self :: $ instance , 'onError' ) ) ; set_exception_handler ( array ( self :: $ instance , 'onException' ) ) ; register_shutdown_function ( array ( self :: $ instance , 'onShutdown' ) ) ; } return self :: $ instance ; }
8135	public function displayBlock ( $ name , $ context = array ( ) ) { $ this -> template -> displayBlock ( $ name , $ this -> env -> mergeGlobals ( $ context ) ) ; }
11837	public function getLogo ( $ size = null ) { if ( ! $ this -> logoPath || ! file_exists ( $ this -> logoPath ) ) { return ; } $ cacheLogo = $ this -> sizeImageCache ( $ this -> logoPath , $ size ) ; if ( $ cacheLogo ) { return $ this -> getCacheAssetUrl ( $ cacheLogo ) ; } return false ; }
12932	protected function generateContentAttribute ( $ name , $ value , $ type = 'text' ) { $ attribute = new ContentAttribute ( ) ; $ attribute -> setName ( $ name ) ; $ attribute -> setValue ( $ value ) ; if ( is_array ( $ value ) ) { $ value = '' ; } $ attribute -> setStringValue ( $ value ) ; $ attribute -> setType ( $ type ) ; return $ attribute ; }
10473	public function renewItem ( $ user_id , $ item_id ) { $ request = new RenewRequest ( $ user_id , $ item_id ) ; $ this -> emit ( 'request.renew' , array ( $ user_id , $ item_id ) ) ; $ response = $ this -> post ( $ request ) ; return new RenewResponse ( $ response ) ; }
11461	public static function enable ( $ state = true , $ enable_assert = false ) { $ state = ( bool ) $ state ; self :: enableAssert ( ( bool ) $ enable_assert ) ; if ( $ state && self :: $ _enabled || ! $ state && ! self :: $ _enabled ) { return ; } if ( $ state ) { set_exception_handler ( __CLASS__ . '::exception' ) ; set_error_handler ( __CLASS__ . '::error' , error_reporting ( ) ) ; assert_options ( ASSERT_CALLBACK , __CLASS__ . '::assert' ) ; self :: $ _enabled = true ; } else { restore_exception_handler ( ) ; restore_error_handler ( ) ; assert_options ( ASSERT_CALLBACK , function ( ) { } ) ; self :: $ _enabled = false ; } }
8433	public function migrate ( Request $ req ) { if ( count ( $ req -> getArgs ( ) ) != 1 ) { echo 'Wrong arguments.' . PHP_EOL . 'Usage : db/migration/migrate mapping_name' . PHP_EOL ; } else { $ mappingName = $ req -> getArgs ( ) [ 0 ] ; $ mapping = Mapping :: get ( $ mappingName ) ; $ cl = '\\' . ltrim ( rtrim ( $ mapping [ 'config' ] [ 'provider' ] , '\\' ) , '\\' ) . '\\Migration::migrate' ; if ( is_callable ( $ cl ) === false ) { throw new RuntimeException ( 'Migration migrate method is not callable on configured provider!' ) ; } call_user_func ( $ cl , $ mapping ) ; echo 'Migrate - Done' . PHP_EOL ; } }
3868	protected function getConfigs ( ) { if ( ! count ( $ this -> configs ) ) { $ statement = $ this -> connection -> query ( 'SELECT * FROM tl_metamodel_searchable_pages' ) ; $ this -> configs = $ statement -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; } return $ this -> configs ; }
8600	public function deleteSubscription ( $ request ) { if ( ! ( $ request instanceof MWSSubscriptionsService_Model_DeleteSubscriptionInput ) ) { require_once ( dirname ( __FILE__ ) . '/Model/DeleteSubscriptionInput.php' ) ; $ request = new MWSSubscriptionsService_Model_DeleteSubscriptionInput ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'DeleteSubscription' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/DeleteSubscriptionResponse.php' ) ; $ response = MWSSubscriptionsService_Model_DeleteSubscriptionResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6431	public function getUserProfile ( ) { $ facebook = $ this -> getFacebookObject ( ) ; $ response = $ facebook -> get ( '/me' , $ this -> accesstoken ) ; $ me = $ response -> getGraphUser ( ) ; return array ( 'userid' => $ me -> getId ( ) , 'name' => $ me -> getName ( ) , 'email' => $ me -> getField ( 'email' ) , 'imageurl' => 'https://graph.facebook.com/' . $ me -> getId ( ) . '/picture?type=large' ) ; }
4672	public function setPaths ( array $ paths ) : object { foreach ( $ paths as $ path ) { if ( ! ( is_dir ( $ path ) && is_readable ( $ path ) ) ) { throw new Exception ( "Directory '$path' is not readable." ) ; } } $ this -> paths = $ paths ; return $ this ; }
5939	public function setExtraData ( array $ extraData ) { $ this -> extraData = [ ] ; foreach ( $ extraData as $ item ) { $ this -> addExtraData ( $ item ) ; } return $ this ; }
5114	private function conv ( $ str ) { if ( $ this -> supportsExtMbstring ) { return mb_convert_encoding ( $ str , 'UTF-16BE' , 'UTF-8' ) ; } return preg_replace_callback ( '/./su' , function ( $ m ) { if ( ! isset ( $ m [ 0 ] [ 1 ] ) ) { return "\x00" . $ m [ 0 ] ; } if ( isset ( $ m [ 0 ] [ 3 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x07 ) << 18 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 3 ] ) & 0x3F ) ; return pack ( 'nn' , ( $ code - 0x10000 >> 10 ) | 0xD800 , ( $ code & 0x03FF ) | 0xDC00 ) ; } if ( isset ( $ m [ 0 ] [ 2 ] ) ) { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x0F ) << 12 ) + ( ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) << 6 ) + ( ord ( $ m [ 0 ] [ 2 ] ) & 0x3F ) ; } else { $ code = ( ( ord ( $ m [ 0 ] [ 0 ] ) & 0x1F ) << 6 ) + ( ord ( $ m [ 0 ] [ 1 ] ) & 0x3F ) ; } return chr ( $ code >> 8 ) . chr ( $ code & 0xFF ) ; } , $ str ) ; }
11698	public function getService ( $ name ) { if ( array_key_exists ( $ name , $ this -> services ) ) { return $ this -> services [ $ name ] ; } throw new KeyNotFoundInSetException ( $ name , array_keys ( $ this -> services ) , 'services' ) ; }
358	function compareByteSize ( $ a , $ b , $ compare = '>=' ) { $ compareExpression = '(' . $ this -> getByteSize ( $ a ) . $ compare . $ this -> getByteSize ( $ b ) . ')' ; return $ this -> evaluateExpression ( $ compareExpression ) ; }
253	protected function freeze ( ) { if ( $ this -> getIsActive ( ) ) { if ( isset ( $ _SESSION ) ) { $ this -> frozenSessionData = $ _SESSION ; } $ this -> close ( ) ; Yii :: info ( 'Session frozen' , __METHOD__ ) ; } }
2777	public function init ( string $ directory , array $ options = [ ] ) : GitWorkingCopy { $ git = $ this -> workingCopy ( $ directory ) ; $ git -> init ( $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
11010	public function addDefaultSrc ( string $ source ) : bool { if ( ! in_array ( $ source , $ this -> tags [ 'default-src' ] ) ) { $ this -> tags [ 'default-src' ] [ ] = $ source ; return true ; } return false ; }
12153	public function getPossibleRoles ( ) { $ roles = [ ] ; foreach ( Yii :: $ app -> collectors [ 'roles' ] -> getAll ( ) as $ roleItem ) { $ test = true ; switch ( $ roleItem -> systemId ) { case 'owner' : $ test = $ this -> isOwnable ; break ; } if ( $ test ) { $ roles [ ] = $ roleItem -> object -> primaryKey ; } } return $ roles ; }
5318	public function wait ( ) { $ this -> internalWait ( ) ; $ event = $ this -> isSuccessExit ( ) ? 'success' : 'error' ; $ this -> internalEmit ( 'exit' , $ this -> pid ) ; $ this -> internalEmit ( $ event ) ; return $ this ; }
3645	public function old ( string $ key , $ default = null , bool $ trim = true , bool $ clean = true ) { $ value = $ this -> request -> old ( $ key , $ default ) ; return $ this -> clean ( $ value , $ trim , $ clean ) ; }
2626	protected function _construct ( ) { $ this -> addColumn ( 'backend_name' , [ 'label' => __ ( 'Name' ) ] ) ; $ this -> _addAfter = false ; $ this -> _template = 'Fastly_Cdn::system/config/form/field/acl.phtml' ; parent :: _construct ( ) ; }
2518	public function pnrRetrieveAndDisplay ( RequestOptions \ PnrRetrieveAndDisplayOptions $ options , $ messageOptions = [ ] ) { $ msgName = 'PNR_RetrieveAndDisplay' ; return $ this -> callMessage ( $ msgName , $ options , $ messageOptions ) ; }
5519	protected function emulateCall ( $ method , $ args , $ step ) { return $ this -> actions -> respond ( $ step , $ method , $ args ) ; }
3204	protected function detect_manual_editing ( $ version ) { if ( false === $ version || true === version_compare ( $ version , '2.2.0' , '<' ) ) { return ; } $ checkTokens = array ( T_FUNCTION => true , T_CLASS => true , T_ARRAY => true , T_OPEN_SHORT_ARRAY => true , ) ; for ( $ ptr = 0 ; $ ptr < $ this -> phpcsFile -> numTokens ; $ ptr ++ ) { if ( ! isset ( $ checkTokens [ $ this -> tokens [ $ ptr ] [ 'code' ] ] ) ) { continue ; } if ( T_CLASS === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; continue ; } elseif ( T_OPEN_SHORT_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'bracket_closer' ] ; continue ; } elseif ( T_ARRAY === $ this -> tokens [ $ ptr ] [ 'code' ] && isset ( $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'parenthesis_closer' ] ; continue ; } if ( T_FUNCTION === $ this -> tokens [ $ ptr ] [ 'code' ] ) { $ function_name = $ this -> phpcsFile -> getDeclarationName ( $ ptr ) ; if ( 'tgmpa' !== $ function_name ) { if ( isset ( $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ) ) { $ ptr = $ this -> tokens [ $ ptr ] [ 'scope_closer' ] ; } continue ; } $ function_exists = $ this -> phpcsFile -> findPrevious ( T_STRING , ( $ ptr - 1 ) , null , false , 'function_exists' ) ; $ param = false ; if ( false !== $ function_exists ) { $ param = $ this -> get_function_call_parameter ( $ function_exists , 1 ) ; $ param = $ this -> strip_quotes ( $ param [ 'raw' ] ) ; } if ( false === $ function_exists || 'tgmpa' !== $ param ) { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'yes' ) ; $ this -> phpcsFile -> addError ( 'Manual editing of the TGM Plugin Activation file detected. Your edit will cause fatal errors for end-users. Download an official copy using the Custom TGMPA Generator. http://tgmpluginactivation.com/download/' , 0 , 'ManualEditDetected' , array ( ) , 9 ) ; } else { $ this -> phpcsFile -> recordMetric ( 0 , 'Manual editing detected' , 'no' ) ; } break ; } } }
9700	protected function generate ( ) { $ params = array_keys ( $ this -> params ) ; if ( $ this -> paragraphs ) { $ params [ ] = $ this -> paragraphs ; } $ url = self :: API_URL . implode ( '/' , $ params ) ; return $ this -> conn -> request ( $ url ) ; }
7692	function MsExcel_ConvertToExplicit_Item ( & $ Txt , $ Tag , $ Att , $ CellRow ) { $ tag_pc = strlen ( $ Tag ) + 1 ; $ rpl = '<' . $ Tag . ' ' . $ Att . '="' ; $ rpl_len = strlen ( $ rpl ) ; $ rpl_nbr = 0 ; $ p = 0 ; $ empty_first_pos = false ; $ empty_nbr = 0 ; $ item_num = 0 ; $ rpl_nbr = 0 ; while ( ( $ p = clsTinyButStrong :: f_Xml_FindTagStart ( $ Txt , $ Tag , true , $ p , true , true ) ) !== false ) { $ item_num ++ ; if ( $ empty_first_pos === false ) $ empty_first_pos = $ p ; $ p = $ p + $ tag_pc ; if ( substr ( $ Txt , $ p , 1 ) == '/' ) { $ empty_nbr ++ ; } else { $ ref = ( $ CellRow === false ) ? $ item_num : $ this -> Misc_CellRef ( $ item_num , $ CellRow ) ; $ x = $ rpl . $ ref . '"' ; $ len = $ p - $ empty_first_pos ; $ Txt = substr_replace ( $ Txt , $ x , $ empty_first_pos , $ len ) ; $ rpl_nbr ++ ; if ( $ CellRow === false ) { $ loc = new clsTbsXmlLoc ( $ Txt , $ Tag , $ p ) ; $ loc -> FindEndTag ( ) ; $ src = $ loc -> GetSrc ( ) ; $ nbr = $ this -> MsExcel_ConvertToExplicit_Item ( $ src , 'c' , 'r' , $ item_num ) ; if ( $ nbr > 0 ) { $ loc -> ReplaceSrc ( $ src ) ; } $ p = $ loc -> PosEnd ; } else { $ p = $ empty_first_pos + $ tag_pc ; } $ empty_nbr = 0 ; $ empty_first_pos = false ; } } return $ rpl_nbr ; }
6245	public function storages ( ) : \ Generator { foreach ( $ this -> storage -> list ( $ this -> recursive ) as $ storage ) { foreach ( $ this -> storageFilters as $ filter ) { if ( ! call_user_func ( $ filter , $ storage ) ) { continue 2 ; } } yield $ storage ; } }
1893	public function onAuthenticationFailure ( Request $ request , AuthenticationException $ exception ) : Response { if ( null === $ this -> logger ) { return parent :: onAuthenticationFailure ( $ request , $ exception ) ; } if ( $ exception instanceof AccountStatusException && ( $ user = $ exception -> getUser ( ) ) instanceof UserInterface ) { $ username = $ user -> getUsername ( ) ; } else { $ username = $ request -> request -> get ( 'username' ) ; } $ this -> logger -> info ( $ exception -> getMessage ( ) , [ 'contao' => new ContaoContext ( __METHOD__ , ContaoContext :: ACCESS , $ username ) ] ) ; return parent :: onAuthenticationFailure ( $ request , $ exception ) ; }
7135	public function getPercent ( ) : float { $ amount = $ this -> getAmount ( ) ; if ( 0 < $ this -> sellingPrice ) { return round ( $ amount * 100 / $ this -> sellingPrice , 2 ) ; } return 0 ; }
10806	protected function getConfig ( ) { $ config = array_replace ( $ this -> config , $ this -> dialect_config ) ; ksort ( $ config ) ; return $ config ; }
11925	public function generate ( string $ outputDir ) : array { $ generatedFiles = [ ] ; foreach ( $ this -> generators as $ generator ) { $ this -> logger -> info ( 'Running generator ' . get_class ( $ generator ) ) ; $ result = $ generator -> generate ( ) ; foreach ( $ result -> all ( ) as $ phpFile ) { $ path = str_replace ( [ '/' , "\\" ] , DIRECTORY_SEPARATOR , $ outputDir . '/' . $ phpFile -> getFqcn ( ) -> getNamespace ( ) ) ; BaseUtil :: ensureDirectory ( $ path , 0711 ) ; $ filePath = $ path . DIRECTORY_SEPARATOR . $ phpFile -> getFqcn ( ) -> getName ( ) . '.php' ; $ this -> logger -> info ( 'Writing to file ' . $ filePath ) ; file_put_contents ( $ filePath , $ phpFile -> getText ( ) ) ; $ generatedFiles [ ] = new GeneratedFile ( $ filePath , $ phpFile ) ; } } return $ generatedFiles ; }
3484	public function withThreadId ( string $ threadId ) : Aps { $ cloned = clone $ this ; $ cloned -> threadId = $ threadId ; return $ cloned ; }
3826	protected function isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) { if ( empty ( $ strKeyOption ) && ! isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ) { return true ; } $ blnIsActive = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) && ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ strKeyOption ) ; if ( ! $ blnIsActive && $ this -> get ( 'defaultid' ) ) { $ blnIsActive = ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] == $ this -> get ( 'defaultid' ) ) ; } return $ blnIsActive ; }
2819	public function initQueries ( ) { $ this -> queries = array ( ) ; $ profiler = Mage :: helper ( 'sheep_debug' ) -> getSqlProfiler ( ) ; if ( $ profiler -> getEnabled ( ) && $ profiler instanceof Sheep_Debug_Model_Db_Profiler ) { $ this -> queries = $ profiler -> getQueryModels ( ) ? : array ( ) ; $ this -> setQueryCount ( $ profiler -> getTotalNumQueries ( ) ) ; $ this -> setQueryTime ( $ profiler -> getTotalElapsedSecs ( ) ) ; } }
5436	protected function getParameterSignatures ( $ method ) { $ signatures = [ ] ; $ parameters = $ method -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ signature = '' ; $ signature .= $ this -> getParameterTypeHint ( $ parameter ) ; if ( $ parameter -> isPassedByReference ( ) ) { $ signature .= '&' ; } $ isVariadic = ( PHP_VERSION_ID >= 50600 ) && $ parameter -> isVariadic ( ) ; if ( $ isVariadic ) { $ signature .= '...' ; } $ signature .= '$' . $ parameter -> getName ( ) ; if ( ! $ isVariadic ) { if ( $ parameter -> isDefaultValueAvailable ( ) ) { $ signature .= ' = ' . var_export ( $ parameter -> getDefaultValue ( ) , true ) ; } elseif ( $ parameter -> isOptional ( ) ) { $ signature .= ' = null' ; } } $ signatures [ ] = $ signature ; } return implode ( ', ' , $ signatures ) ; }
9443	public function setPackOptions ( Container $ app ) { foreach ( $ this -> packOptions as $ key => & $ value ) { $ key = $ this -> _ns ( $ key ) ; if ( isset ( $ app [ $ key ] ) ) { $ value = $ app [ $ key ] ; } } }
2929	public function keyExists ( $ key ) { $ allKeys = $ this -> getKeys ( ) ; if ( array_key_exists ( $ key , $ allKeys ) ) { return true ; } return false ; }
5249	public function save ( $ child ) { $ children = ! is_array ( $ child ) ? [ $ child ] : $ child ; foreach ( $ children as $ child ) { $ child -> setParent ( $ this -> parent ) ; $ child -> save ( ) ; } }
7140	protected function handleQuantityChange ( SupplierDeliveryItemInterface $ item ) { $ changeSet = $ this -> persistenceHelper -> getChangeSet ( $ item ) ; if ( null === $ orderItem = $ item -> getOrderItem ( ) ) { throw new RuntimeException ( "Failed to retrieve order item." ) ; } if ( null !== $ stockUnit = $ orderItem -> getStockUnit ( ) ) { if ( 0 != $ deltaQuantity = floatval ( $ changeSet [ 'quantity' ] [ 1 ] ) - floatval ( $ changeSet [ 'quantity' ] [ 0 ] ) ) { $ this -> stockUnitUpdater -> updateReceived ( $ stockUnit , $ deltaQuantity , true ) ; } } elseif ( $ orderItem -> hasSubjectIdentity ( ) ) { throw new RuntimeException ( "Failed to retrieve stock unit." ) ; } if ( null === $ order = $ orderItem -> getOrder ( ) ) { throw new RuntimeException ( "Failed to retrieve order." ) ; } $ this -> scheduleSupplierOrderContentChangeEvent ( $ order ) ; }
5732	public function getLeague ( int $ leagueID , array $ filter = [ 'areas' => '' ] ) { $ league = $ this -> run ( "v2/competitions/{$leagueID}" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ league ) ; }
3689	public function createButton ( GetOperationButtonEvent $ event ) { if ( 'createvariant' !== $ event -> getCommand ( ) -> getName ( ) ) { return ; } $ model = $ event -> getModel ( ) ; $ metamodel = $ model -> getItem ( ) -> getMetaModel ( ) ; if ( ! $ metamodel -> hasVariants ( ) || $ model -> getProperty ( 'varbase' ) === '0' ) { $ event -> setHtml ( '' ) ; } }
12829	public function setConfig ( $ name , $ value ) { if ( is_null ( $ name ) ) { $ this -> _config = new ArrayStorage ( $ value ) ; } else { $ this -> _config -> setDeepValue ( $ name , $ value ) ; } return $ this ; }
9897	private function convertString ( $ string ) { $ string = substr ( $ string , 1 , - 1 ) ; if ( strlen ( $ string ) > 255 ) { throw new WriterException ( 'String is too long' ) ; } return pack ( 'C' , $ this -> ptg [ 'ptgStr' ] ) . StringHelper :: UTF8toBIFF8UnicodeShort ( $ string ) ; }
9186	protected function mergeParams ( & $ data , $ params ) { foreach ( $ params as $ paramName => $ paramValue ) { if ( is_array ( $ paramValue ) ) { foreach ( $ paramValue as $ key => $ value ) { foreach ( $ value as $ name => $ x ) { $ data [ $ paramName ] [ $ key ] [ $ name ] = $ x ; } } } else { $ data [ $ paramName ] = $ paramValue ; } } }
9416	public function max ( ) { $ float_max = 1 / ( $ this -> float_sigma * sqrt ( 2 * pi ( ) ) ) ; if ( $ this -> int_precision ) { return round ( $ float_max , $ this -> int_precision ) ; } return $ float_max ; }
10865	protected function setInstProperty ( $ inst , $ propertyName , $ mappingDefinition , $ propertyValue = null ) { if ( $ mappingDefinition === false ) { return false ; } if ( func_num_args ( ) <= 3 ) { $ propertyValue = $ this -> $ propertyName ; } if ( $ mappingDefinition === true || is_string ( $ mappingDefinition ) ) { $ instPropertyName = $ mappingDefinition === true ? $ propertyName : $ mappingDefinition ; $ setInstPropertyMethod = 'setInstProperty' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ this , $ setInstPropertyMethod ) ) { $ this -> $ setInstPropertyMethod ( $ propertyValue , $ inst ) ; return ; } else { $ instSetterMethod = 'set' . ucfirst ( $ instPropertyName ) ; if ( method_exists ( $ inst , $ instSetterMethod ) ) { $ inst -> $ instSetterMethod ( $ propertyValue ) ; return ; } else { $ inst -> $ instPropertyName = $ propertyValue ; return ; } } } elseif ( is_array ( $ mappingDefinition ) ) { if ( reset ( $ mappingDefinition ) === null ) { $ mappingDefinition [ 0 ] = $ inst ; call_user_func_array ( $ mappingDefinition , [ $ propertyValue ] ) ; return ; } elseif ( reset ( $ mappingDefinition ) === $ this ) { call_user_func_array ( $ mappingDefinition , [ $ propertyValue , $ inst ] ) ; return ; } } throw new \ yii \ base \ ErrorException ( 'Could not set property ' . $ propertyName . ' in wrapped object' ) ; }
11247	public function getLast ( ) : array { $ sql = "select migration from {$this->table} as b where exists (select max(batch) from {$this->table} as a where b.batch = a.batch) order by migration desc" ; $ stmt = $ this -> pdo -> prepare ( $ sql ) ; $ stmt -> execute ( ) ; return $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; }
10022	public function removeCellStyleXfByIndex ( $ pIndex ) { if ( $ pIndex > count ( $ this -> cellStyleXfCollection ) - 1 ) { throw new Exception ( 'CellStyleXf index is out of bounds.' ) ; } array_splice ( $ this -> cellStyleXfCollection , $ pIndex , 1 ) ; }
722	public function json ( ) { if ( version_compare ( PHP_VERSION , '5.6' , '<' ) && $ this -> getDb ( ) -> getDriverName ( ) === 'mysql' ) { throw new \ yii \ base \ Exception ( 'JSON column type is not supported in PHP < 5.6' ) ; } return $ this -> getDb ( ) -> getSchema ( ) -> createColumnSchemaBuilder ( Schema :: TYPE_JSON ) ; }
12407	public function set ( $ key , $ value ) { try { $ filenameCache = $ this -> location . DS . $ key ; file_put_contents ( $ filenameCache , $ value ) ; } catch ( \ Exception $ e ) { return false ; } return true ; }
3766	private function addInputScreenTranslations ( StaticTranslator $ translator , $ inputScreen , $ containerName ) { $ currentLocale = $ GLOBALS [ 'TL_LANGUAGE' ] ; foreach ( $ inputScreen [ 'legends' ] as $ legendName => $ legendInfo ) { foreach ( $ legendInfo [ 'label' ] as $ langCode => $ label ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName , $ langCode ) ; if ( $ currentLocale === $ langCode ) { $ translator -> setValue ( $ legendName . '_legend' , $ label , $ containerName ) ; } } } }
5610	public function paintCaseStart ( $ message ) { parent :: paintCaseStart ( $ message ) ; $ node = new TreemapNode ( 'TestCase' , $ message ) ; $ this -> _stack -> push ( $ node ) ; }
6746	public function getCatalogue ( $ locale = null ) { if ( $ this -> translator instanceof TranslatorBagInterface ) { return $ this -> translator -> getCatalogue ( $ locale ) ; } return null ; }
10632	private function getFiles ( $ pattern ) { $ files = $ this -> filesystem -> glob ( $ this -> storagePath . DIRECTORY_SEPARATOR . $ pattern , GLOB_BRACE ) ; return array_filter ( array_map ( 'realpath' , $ files ) ) ; }
8098	protected function toCollection ( $ data ) { if ( is_array ( $ data ) ) { return new Collection ( $ data ) ; } else { if ( ! ( $ data instanceof Collection ) ) { $ data = new Collection ( ) ; } } return $ data ; }
9928	protected function valueIsEmpty ( $ value ) { return ( is_object ( $ value ) && $ value instanceof Parameters && $ value -> isEmpty ( ) ) || ( is_array ( $ value ) && ! count ( $ value ) ) ; }
7321	public function dayOfYear ( ) { $ k = $ this -> isLeapYear ( ) ? 1 : 2 ; $ n = intval ( 275 * ( int ) $ this -> month / 9 ) - $ k * intval ( ( ( int ) $ this -> month + 9 ) / 12 ) + ( int ) $ this -> day - 30 ; return ( int ) $ n ; }
4873	public function init ( ) { $ this -> setName ( 'buttons' ) ; if ( ! isset ( $ this -> options [ 'render_summary' ] ) ) { $ this -> options [ 'render_summary' ] = false ; } $ this -> setAttribute ( 'class' , 'text-right' ) ; $ this -> add ( array ( 'type' => 'Core/Spinner-Submit' , 'name' => 'submit' , 'options' => array ( 'label' => 'Save' , ) , 'attributes' => array ( 'id' => 'submit' , 'type' => 'submit' , 'value' => 'Save' , 'class' => 'sf-submit btn btn-primary btn-xs' ) , ) ) ; $ this -> add ( array ( 'type' => 'Button' , 'name' => 'cancel' , 'options' => array ( 'label' => 'Cancel' , ) , 'attributes' => array ( 'id' => 'cancel' , 'type' => 'reset' , 'value' => 'Cancel' , 'class' => 'sf-cancel btn btn-default btn-xs' ) , ) ) ; }
447	private function attachBehaviorInternal ( $ name , $ behavior ) { if ( ! ( $ behavior instanceof Behavior ) ) { $ behavior = Yii :: createObject ( $ behavior ) ; } if ( is_int ( $ name ) ) { $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ ] = $ behavior ; } else { if ( isset ( $ this -> _behaviors [ $ name ] ) ) { $ this -> _behaviors [ $ name ] -> detach ( ) ; } $ behavior -> attach ( $ this ) ; $ this -> _behaviors [ $ name ] = $ behavior ; } return $ behavior ; }
6834	private function getFindNewBySupplierQuery ( ) { if ( null !== $ this -> findNewBySupplierQuery ) { return $ this -> findNewBySupplierQuery ; } $ qb = $ this -> createQueryBuilder ( ) ; $ as = $ this -> getAlias ( ) ; return $ this -> findNewBySupplierQuery = $ qb -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.supplier' , ':supplier' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( $ as . '.state' , ':state' ) ) -> getQuery ( ) -> setParameter ( 'state' , Model \ SupplierOrderStates :: STATE_NEW ) ; }
645	public function resetSequence ( $ table , $ value = null ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> resetSequence ( $ table , $ value ) ; return $ this -> setSql ( $ sql ) ; }
10578	public function multipleToAPIResponseData ( ? array $ resources ) : APIResponseData { if ( is_null ( $ resources ) ) { return $ this -> toAPIResponseData ( null ) ; } return new APIResponseData ( array_map ( function ( Resource $ resource ) { return $ this -> toAPIResponseData ( $ resource ) -> getData ( ) ; } , $ resources ) ) ; }
751	protected function validateSlug ( $ slug ) { $ validator = Yii :: createObject ( array_merge ( [ 'class' => UniqueValidator :: className ( ) , ] , $ this -> uniqueValidator ) ) ; $ model = clone $ this -> owner ; $ model -> clearErrors ( ) ; $ model -> { $ this -> slugAttribute } = $ slug ; $ validator -> validateAttribute ( $ model , $ this -> slugAttribute ) ; return ! $ model -> hasErrors ( ) ; }
4062	private static function isEmptyArrayEquivalent ( $ expected , $ actual ) { return ( gettype ( $ expected ) == 'string' ) && ( ( gettype ( $ actual ) == 'array' ) || ( gettype ( $ actual ) == 'NULL' ) ) && empty ( $ actual ) && empty ( $ expected ) ; }
2466	protected function welcomeScreen ( ) { System :: loadLanguageFile ( 'explain' ) ; $ objTemplate = new BackendTemplate ( 'be_welcome' ) ; $ objTemplate -> messages = Message :: generateUnwrapped ( ) . Backend :: getSystemMessages ( ) ; $ objTemplate -> loginMsg = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'firstLogin' ] ; if ( $ this -> User -> lastLogin > 0 ) { $ formatter = new DateTimeFormatter ( System :: getContainer ( ) -> get ( 'translator' ) ) ; $ diff = $ formatter -> formatDiff ( new \ DateTime ( date ( 'Y-m-d H:i:s' , $ this -> User -> lastLogin ) ) , new \ DateTime ( ) ) ; $ objTemplate -> loginMsg = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lastLogin' ] [ 1 ] , '<time title="' . Date :: parse ( Config :: get ( 'datimFormat' ) , $ this -> User -> lastLogin ) . '">' . $ diff . '</time>' ) ; } Versions :: addToTemplate ( $ objTemplate ) ; $ objTemplate -> showDifferences = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'showDifferences' ] ) ) ; $ objTemplate -> recordOfTable = StringUtil :: specialchars ( str_replace ( "'" , "\\'" , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'recordOfTable' ] ) ) ; $ objTemplate -> systemMessages = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'systemMessages' ] ; $ objTemplate -> shortcuts = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 0 ] ; $ objTemplate -> shortcutsLink = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'shortcuts' ] [ 1 ] ; $ objTemplate -> editElement = StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'editElement' ] ) ; return $ objTemplate -> parse ( ) ; }
7126	static public function copy ( AddressInterface $ source , AddressInterface $ target ) { $ target -> setCompany ( $ source -> getCompany ( ) ) -> setGender ( $ source -> getGender ( ) ) -> setFirstName ( $ source -> getFirstName ( ) ) -> setLastName ( $ source -> getLastName ( ) ) -> setStreet ( $ source -> getStreet ( ) ) -> setComplement ( $ source -> getComplement ( ) ) -> setSupplement ( $ source -> getSupplement ( ) ) -> setExtra ( $ source -> getExtra ( ) ) -> setCity ( $ source -> getCity ( ) ) -> setPostalCode ( $ source -> getPostalCode ( ) ) -> setCountry ( $ source -> getCountry ( ) ) -> setState ( $ source -> getState ( ) ) -> setDigicode1 ( $ source -> getDigicode1 ( ) ) -> setDigicode2 ( $ source -> getDigicode2 ( ) ) -> setIntercom ( $ source -> getIntercom ( ) ) -> setLatitude ( $ source -> getLatitude ( ) ) -> setLongitude ( $ source -> getLongitude ( ) ) ; if ( is_object ( $ phone = $ source -> getPhone ( ) ) ) { $ target -> setPhone ( clone $ phone ) ; } else { $ target -> setPhone ( $ phone ) ; } if ( is_object ( $ mobile = $ source -> getMobile ( ) ) ) { $ target -> setMobile ( clone $ mobile ) ; } else { $ target -> setMobile ( $ mobile ) ; } }
856	public function overrideAt ( $ index , $ token ) { @ trigger_error ( __METHOD__ . ' is deprecated and will be removed in 3.0, use offsetSet instead.' , E_USER_DEPRECATED ) ; self :: $ isLegacyMode = true ; $ this [ $ index ] -> override ( $ token ) ; $ this -> registerFoundToken ( $ token ) ; }
7332	private function configureStockUnitDiscriminatorMap ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; if ( ! is_subclass_of ( $ metadata -> name , Stock \ StockUnitInterface :: class ) ) { return ; } $ this -> getStockUnitMapper ( $ eventArgs -> getEntityManager ( ) ) -> processClassMetadata ( $ metadata ) ; }
12449	static function run_check_gnu_files ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; if ( $ opts [ 'files' ] [ 'gnu_dir' ] ) { $ destdir .= '/' . $ opts [ 'files' ] [ 'gnu_dir' ] ; } $ files = pakeFinder :: type ( 'file' ) -> name ( array ( 'README' , 'LICENSE' ) ) -> maxdepth ( 0 ) -> in ( $ destdir ) ; if ( count ( $ files ) != 2 ) { SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; throw new pakeException ( "README and/or LICENSE files missing. Please fix" ) ; } SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
7961	public function canResetDslamPort ( $ forceReload = false ) { if ( ! $ this -> properties || $ forceReload ) $ this -> getProperties ( ) ; return $ this -> properties -> capabilities -> canResetDslamPort ; }
5467	protected function findRealmFromUrl ( $ url ) { if ( ! isset ( $ this -> realms [ $ url -> getHost ( ) ] ) ) { return false ; } foreach ( $ this -> realms [ $ url -> getHost ( ) ] as $ name => $ realm ) { if ( $ realm -> isWithin ( $ url ) ) { return $ realm ; } } return false ; }
3072	protected function getItemRef ( $ itemIdentifier ) { $ serviceContext = $ this -> getServiceContext ( ) ; $ mapService = $ this -> getServiceLocator ( ) -> get ( QtiRunnerMap :: SERVICE_ID ) ; return $ mapService -> getItemHref ( $ serviceContext , $ itemIdentifier ) ; }
6773	protected function isTaxationUpdateNeeded ( SaleInterface $ sale ) { if ( $ this -> persistenceHelper -> isChanged ( $ sale , [ 'taxExempt' , 'customer' , 'vatValid' ] ) ) { return true ; } return $ this -> didDeliveryCountryChanged ( $ sale ) ; }
9624	public function makeHandler ( $ ident ) { if ( ! isset ( $ this -> factories [ $ ident ] ) ) { throw new \ InvalidArgumentException ( "Unknown session handler: $ident" ) ; } return $ this -> factories [ $ ident ] ( ) ; }
6620	public function getChildController ( $ controllerName ) { $ methodName = $ this -> parseControllerName ( $ controllerName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ controller = $ this -> reflection -> getMethod ( $ methodName ) -> invokeArgs ( $ this -> controller , [ ] ) ; if ( ! is_object ( $ controller ) || ! $ controller instanceof Controller ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} did not return a Controller" ) ; } return $ controller ; }
11350	public function getData ( ) { $ data = [ ] ; foreach ( $ this -> fields as $ field ) { if ( preg_match ( '/^(.*?)(\[.*\])$/' , $ field -> getName ( ) , $ result ) ) { if ( $ result [ 2 ] == '' ) { } else { if ( ! preg_match_all ( "/\[(.*?)\]/" , $ result [ 2 ] , $ resultDeep ) ) { throw new \ Exception ( 'Invalid field name.' ) ; } $ storage = & $ data [ $ result [ 1 ] ] ; foreach ( $ resultDeep [ 1 ] as $ deep ) { if ( ! isset ( $ storage [ $ deep ] ) ) { $ storage [ $ deep ] = [ ] ; } $ storage = & $ storage [ $ deep ] ; } $ storage = $ field -> getData ( ) ; } } else { $ data [ $ field -> getName ( ) ] = $ field -> getData ( ) ; } } return $ this -> transformer -> decode ( $ data ) ; }
1184	protected function wrapValidator ( ) { $ resolver = new Resolver ( $ this -> factory ) ; $ this -> factory -> resolver ( $ resolver -> resolver ( $ this -> field ) ) ; $ this -> factory -> extend ( RemoteValidator :: EXTENSION_NAME , $ resolver -> validatorClosure ( ) ) ; }
967	protected function cleanShop ( ) { $ this -> shop -> shopify_token = null ; $ this -> shop -> plan_id = null ; $ this -> shop -> save ( ) ; }
2357	public function getFrontendUsername ( ) : ? string { $ token = $ this -> getToken ( FrontendUser :: SECURITY_SESSION_KEY ) ; if ( null === $ token || ! $ token -> getUser ( ) instanceof FrontendUser ) { return null ; } return $ token -> getUser ( ) -> getUsername ( ) ; }
12049	public static function showImageInSize ( int $ iImageUri , int $ iWidth , int $ iHeight , bool $ bKeepDimension = false ) { $ aSize = getimagesize ( $ iImageUri ) ; $ rActualImage = imagecreatefromjpeg ( $ iImageUri ) ; $ ImageChoisie = imagecreatefromjpeg ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ TailleImageChoisie = getimagesize ( $ _FILES [ 'ImageNews' ] [ 'tmp_name' ] ) ; $ rNewImage = imagecreatetruecolor ( $ iWidth , $ iHeight ) ; if ( $ bKeepDimension === false ) { imagecopyresampled ( $ rNewImage , $ rActualImage , 0 , 0 , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } else { if ( $ aSize [ 0 ] > $ aSize [ 1 ] ) { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 1 ] / $ aSize [ 0 ] ; $ iHeight = round ( $ iWidth * $ fCoef ) ; $ iDestY = round ( ( $ iWidth - $ iHeight ) / 2 ) ; $ iDestX = 0 ; } else { $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; $ fCoef = $ aSize [ 0 ] / $ aSize [ 1 ] ; $ iWidth = round ( $ iHeight * $ fCoef ) ; $ iDestX = round ( ( $ iHeight - $ iWidth ) / 2 ) ; $ iDestY = 0 ; } $ rWhite = imagecolorallocate ( $ rNewImage , 255 , 255 , 255 ) ; imagefilledrectangle ( $ rNewImage , 0 , 0 , $ iWidth , $ iHeight , $ rWhite ) ; imagecopyresampled ( $ rNewImage , $ rActualImage , $ iDestX , $ iDestY , 0 , 0 , $ iWidth , $ iHeight , $ aSize [ 0 ] , $ aSize [ 1 ] ) ; } imagedestroy ( $ rActualImage ) ; $ NomImageChoisie = explode ( '.' , $ rNewImage ) ; $ NomImageExploitable = time ( ) ; header ( 'Content-Type: image/jpeg' ) ; imagejpeg ( $ rNewImage , null , 100 ) ; }
10621	public static function percentage ( $ value , $ from ) { $ value = floatval ( $ value ) ; $ from = floatval ( $ from ) ; return floatval ( $ value / $ from * 100 ) ; }
8274	public function assertUsername ( $ username , $ config ) { if ( ! is_string ( $ username ) ) { throw new ConfigurationException ( "Username $username must be a string." ) ; } $ len = strlen ( $ username ) ; $ minLen = $ config [ "registration" ] [ "nameLenMin" ] ; $ maxLen = $ config [ "registration" ] [ "nameLenMax" ] ; if ( $ len < $ minLen || $ len > $ maxLen ) { throw new ConfigurationException ( sprintf ( "Length of a username $username must be between %d-%d characters." , $ minLen , $ maxLen ) ) ; } if ( ! $ this -> checkValidNameFormat ( $ username ) ) { throw new ConfigurationException ( "Username $username contains invalid character/s." ) ; } }
4123	public function generateProxyClasses ( array $ classes , $ toDir = null ) { $ proxyDir = $ toDir ? : $ this -> proxyDir ; $ proxyDir = rtrim ( $ proxyDir , DIRECTORY_SEPARATOR ) . DIRECTORY_SEPARATOR ; foreach ( $ classes as $ class ) { if ( $ class -> isMappedSuperclass ) { continue ; } $ proxyFileName = $ this -> getProxyFileName ( $ class -> name , $ toDir ) ; $ this -> generateProxyClass ( $ class , $ proxyFileName , self :: $ proxyClassTemplate ) ; } }
1259	private function write ( $ str ) { $ this -> source .= $ this -> indentation ; if ( func_num_args ( ) == 1 ) { $ this -> source .= $ str . "\n" ; return $ this ; } $ this -> source .= vsprintf ( $ str , array_slice ( func_get_args ( ) , 1 ) ) . "\n" ; return $ this ; }
3831	protected function prepareFrontendFilterWidget ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , FrontendFilterOptions $ objFrontendFilterOptions ) { $ strClass = $ GLOBALS [ 'TL_FFL' ] [ $ arrWidget [ 'inputType' ] ] ; if ( ! $ strClass ) { return array ( ) ; } $ arrWidget [ 'value' ] = isset ( $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] ) ? $ arrFilterUrl [ $ arrWidget [ 'eval' ] [ 'urlparam' ] ] : null ; $ event = new GetAttributesFromDcaEvent ( $ arrWidget , $ arrWidget [ 'eval' ] [ 'urlparam' ] ) ; $ this -> eventDispatcher -> dispatch ( ContaoEvents :: WIDGET_GET_ATTRIBUTES_FROM_DCA , $ event ) ; if ( $ objFrontendFilterOptions -> isAutoSubmit ( ) && TL_MODE == 'FE' ) { $ GLOBALS [ 'TL_JAVASCRIPT' ] [ 'metamodels' ] = 'bundles/metamodelscore/js/metamodels.js' ; } $ objWidget = new $ strClass ( $ event -> getResult ( ) ) ; $ this -> validateWidget ( $ objWidget , $ arrWidget [ 'value' ] ) ; $ strField = $ objWidget -> generateWithError ( ) ; return array ( 'class' => sprintf ( 'mm_%s %s%s%s' , $ arrWidget [ 'inputType' ] , $ arrWidget [ 'eval' ] [ 'urlparam' ] , ( ( $ arrWidget [ 'value' ] !== null ) ? ' used' : ' unused' ) , ( $ objFrontendFilterOptions -> isAutoSubmit ( ) ? ' submitonchange' : '' ) ) , 'label' => $ objWidget -> generateLabel ( ) , 'formfield' => $ strField , 'raw' => $ arrWidget , 'urlparam' => $ arrWidget [ 'eval' ] [ 'urlparam' ] , 'options' => $ this -> prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ objFrontendFilterOptions -> isAutoSubmit ( ) ) , 'count' => isset ( $ arrWidget [ 'count' ] ) ? $ arrWidget [ 'count' ] : null , 'showCount' => $ objFrontendFilterOptions -> isShowCountValues ( ) , 'autosubmit' => $ objFrontendFilterOptions -> isAutoSubmit ( ) , 'urlvalue' => array_key_exists ( 'urlvalue' , $ arrWidget ) ? $ arrWidget [ 'urlvalue' ] : $ arrWidget [ 'value' ] , 'errors' => $ objWidget -> hasErrors ( ) ? $ objWidget -> getErrors ( ) : array ( ) ) ; }
1000	public function getDirective ( $ name ) { foreach ( $ this -> getDirectives ( ) as $ directive ) { if ( $ directive -> name === $ name ) { return $ directive ; } } return null ; }
12475	public function getCurrentTheme ( ) { $ theme = $ this -> getDefaultTheme ( ) ; if ( $ this -> container -> get ( 'session' ) -> has ( '_admin_theme' ) ) { $ theme = $ this -> container -> get ( 'session' ) -> get ( '_admin_theme' ) ; } return $ theme ; }
2799	public static function generate ( $ mutantFile = null , $ bootstrap = '' , $ replacingFile = null ) { $ loadHumbug = '' ; if ( 'phar:' === substr ( __FILE__ , 0 , 5 ) ) { $ loadHumbug = '\Phar::loadPhar(\'' . str_replace ( 'phar://' , '' , \ Phar :: running ( ) ) . '\', \'humbug.phar\');' ; $ humbugBootstrap = 'phar://humbug.phar' . '/bootstrap.php' ; } else { $ humbugBootstrap = realpath ( __DIR__ . '/../../../bootstrap.php' ) ; } $ file = sys_get_temp_dir ( ) . '/humbug.phpunit.bootstrap.php' ; if ( ! is_null ( $ mutantFile ) ) { $ mutantFile = addslashes ( $ mutantFile ) ; $ replacingFile = addslashes ( $ replacingFile ) ; $ prepend = <<<PREPEND<?php{$loadHumbug}require_once '{$humbugBootstrap}';use Humbug\StreamWrapper\IncludeInterceptor;IncludeInterceptor::intercept('{$replacingFile}', '{$mutantFile}');IncludeInterceptor::enable();PREPEND ; if ( ! empty ( $ bootstrap ) ) { $ buffer = $ prepend . "\nrequire_once '{$bootstrap}';" ; } else { $ buffer = $ prepend ; } file_put_contents ( $ file , $ buffer ) ; } else { if ( ! empty ( $ bootstrap ) ) { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';\nrequire_once '{$bootstrap}';" ; } else { $ buffer = "<?php\n{$loadHumbug}\nrequire_once '{$humbugBootstrap}';" ; } file_put_contents ( $ file , $ buffer ) ; } }
7159	protected function compileKeyboard ( Keyboard $ keyboard ) { $ firstButton = collect ( $ keyboard -> getButtons ( ) ) -> first ( ) ; if ( $ firstButton instanceof PayloadButton || $ firstButton instanceof UrlButton ) { return $ this -> compileInlineKeyboard ( $ keyboard ) ; } return $ this -> compileReplyKeyboard ( $ keyboard ) ; }
6541	public function fetchOne ( $ tableName , array $ identifier , $ shardingKey = null , $ forceFromMaster = true ) { return $ this -> fetch ( $ tableName , $ identifier , $ shardingKey , array ( '*' ) , false , $ forceFromMaster ) ; }
219	public function asBoolean ( $ value ) { if ( $ value === null ) { return $ this -> nullDisplay ; } return $ value ? $ this -> booleanFormat [ 1 ] : $ this -> booleanFormat [ 0 ] ; }
11443	public function getMessage ( $ id = null ) { if ( ! is_null ( $ id ) ) { return array_key_exists ( $ id , $ this -> messages ) ? $ this -> messages [ $ id ] : null ; } elseif ( count ( $ this -> messages ) > 0 ) { return current ( $ this -> messages ) ; } else { $ message_class = $ this -> getDefault ( 'messager' ) ; if ( class_exists ( $ message_class ) ) { $ this -> addMessage ( new $ message_class ) ; return current ( $ this -> messages ) ; } else { throw new \ Exception ( sprintf ( 'Default message class "%s" not found!' , $ message_class ) ) ; } } }
11799	public function setReplyTo ( $ mail = '' , $ name = null ) { if ( strlen ( $ mail ) && Helper :: isEmail ( $ mail ) ) { if ( ! empty ( $ name ) ) { $ _m = Helper :: mailTagger ( $ mail , $ name ) ; } else { $ _m = $ mail ; } $ this -> getMailer ( ) -> setRegistry ( 'Reply-To' , $ _m , 'headers' ) ; } return $ this ; }
11593	public function getAction ( ) { $ id = $ this -> getPageId ( ) ; if ( $ id !== null ) { $ result = $ this -> pageList -> getPage ( $ id ) -> getJSON ( ) ; } else { $ result = array ( ) ; foreach ( $ this -> pageList -> getPages ( ) as $ pageName ) { $ result [ ] = $ this -> pageList -> getPage ( $ pageName ) -> getJSON ( ) ; } } $ this -> environment -> sendJSONResult ( $ result ) ; }
3575	public function forget ( $ key ) { if ( $ attribute = $ this -> get ( $ key ) ) { $ attribute -> setValue ( null ) ; } return $ this ; }
9218	protected function pageNumberToKey ( $ pageNumber ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { return ( $ pageNumber - 1 ) * $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getPerPage ( ) ; } return false ; }
10587	public static function cleanup ( ) : bool { $ ret = true ; foreach ( self :: $ entities as $ path => $ entity ) { if ( ! $ entity -> remove ( ) ) { $ ret = false ; } } self :: $ entities = [ ] ; return $ ret ; }
12863	protected function getCachedIdentityService ( Cache $ cache , array $ options ) : CachedIdentityService { if ( ! isset ( $ options [ 'authUrl' ] ) ) { throw new \ InvalidArgumentException ( "'authUrl' is a required option" ) ; } $ stack = HandlerStack :: create ( ) ; if ( ! empty ( $ options [ 'debugLog' ] ) && ! empty ( $ options [ 'logger' ] ) && ! empty ( $ options [ 'messageFormatter' ] ) ) { $ stack -> push ( GuzzleMiddleware :: log ( $ options [ 'logger' ] , $ options [ 'messageFormatter' ] ) ) ; } $ clientOptions = [ 'base_uri' => Utils :: normalizeUrl ( $ options [ 'authUrl' ] ) , 'handler' => $ stack , ] ; if ( isset ( $ options [ 'requestOptions' ] ) ) { $ clientOptions = array_merge ( $ options [ 'requestOptions' ] , $ clientOptions ) ; } $ service = CachedIdentityService :: factory ( new Client ( $ clientOptions ) ) ; $ service -> setCache ( $ cache ) ; return $ service ; }
5662	private function mergeAttribute ( $ attributes , $ raw ) { $ parts = explode ( '=' , $ raw ) ; list ( $ name , $ value ) = count ( $ parts ) === 1 ? array ( $ parts [ 0 ] , $ parts [ 0 ] ) : $ parts ; $ attributes [ trim ( $ name ) ] = html_entity_decode ( $ this -> dequote ( trim ( $ value ) ) , ENT_QUOTES ) ; return $ attributes ; }
3777	protected function getParamName ( ) { if ( $ this -> get ( 'urlparam' ) ) { return $ this -> get ( 'urlparam' ) ; } $ objAttribute = $ this -> getFilteredAttribute ( ) ; if ( $ objAttribute ) { return $ objAttribute -> getColName ( ) ; } return null ; }
7022	private function formatO ( & $ str ) { if ( strstr ( $ str , '%O' ) ) { $ o = $ this -> timezone -> offset ; $ os = $ o >= 0 ? '+' : '-' ; $ oh = sprintf ( '%02d' , abs ( intval ( $ o ) ) ) ; $ om = sprintf ( '%02d' , abs ( $ o - intval ( $ o ) ) * 60 ) ; $ ofs = "{$os}{$oh}{$om}" ; $ str = str_replace ( '%O' , $ ofs , $ str ) ; } }
10694	protected function startOrRestart ( ) { if ( session_status ( ) == PHP_SESSION_ACTIVE ) return ; if ( $ this -> SessionDir ) { if ( ! file_exists ( $ this -> SessionDir ) ) { mkdir ( $ this -> SessionDir , 0777 , true ) ; } session_save_path ( $ this -> SessionDir ) ; } session_start ( ) ; $ FingerPrint = "" ; if ( $ this -> IpAddress ) { if ( ! $ this -> IpAddress -> isValid ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid IP " . $ this -> IpAddress -> getValue ( ) . " detected" , 403 ) ; } else $ FingerPrint = $ this -> IpAddress -> getValue ( ) ; } if ( $ this -> Browser ) { if ( ! $ this -> Browser -> isKnownBrowser ( ) ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: Invalid Browser " . $ this -> Browser -> getSignature ( ) . " detected." , 403 ) ; } else $ FingerPrint .= $ this -> Browser -> getSignature ( ) ; } $ currFp = md5 ( $ FingerPrint ) ; $ prevFp = isset ( $ _SESSION [ "FingerPrint" ] ) ? $ _SESSION [ "FingerPrint" ] : null ; if ( $ prevFp ) { if ( $ prevFp != $ currFp ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Cannot start session. Reason: IP changed. Current is $currFp, previous was: $prevFp" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ currTime = time ( ) ; $ prevTime = isset ( $ _SESSION [ "LastSessionStart" ] ) ? $ _SESSION [ "LastSessionStart" ] : null ; $ timeOutSecs = isset ( $ _SESSION [ "TimeOutSecs" ] ) ? $ _SESSION [ "TimeOutSecs" ] : null ; if ( $ prevTime && $ timeOutSecs ) { if ( $ prevTime + $ timeOutSecs < $ currTime ) { session_unset ( ) ; session_destroy ( ) ; throw new \ Exception ( "Session timeout" , Interfaces \ HttpResponder :: EXIT_CODE_UNAUTHORIZED ) ; } } $ _SESSION [ "FingerPrint" ] = $ currFp ; $ _SESSION [ "LastSessionStart" ] = $ currTime ; }
3075	public function process ( ) { $ this -> validate ( ) ; try { $ serviceContext = $ this -> getServiceContext ( ) ; $ this -> saveToolStates ( ) ; if ( $ this -> getRequestParameter ( 'offline' ) === true ) { $ this -> setOffline ( ) ; } $ result = $ this -> getRunnerService ( ) -> pause ( $ serviceContext ) ; $ response = [ 'success' => $ result ] ; } catch ( Exception $ e ) { $ response = $ this -> getErrorResponse ( $ e ) ; } return $ response ; }
6009	public function setDeleted ( $ deleted ) { if ( $ deleted instanceof DateTime ) { $ this -> deleted = $ deleted ; } else { try { $ this -> deleted = new DateTime ( $ deleted ) ; } catch ( \ Exception $ e ) { $ this -> deleted = null ; } } return $ this ; }
11580	public function getStatus ( ) { $ message = 'Tracking ' ; $ numRepos = 0 ; if ( isset ( $ this [ 'repositories' ] ) && ( 1 === ( $ numRepos = count ( $ this [ 'repositories' ] ) ) ) ) { $ message .= '1 repository.' ; } else { $ message .= $ numRepos . ' repositories.' ; } return $ message ; }
2927	protected function resetContent ( ) { $ this -> filePath = null ; $ this -> reader -> load ( null ) ; $ this -> writer -> setBuffer ( null ) ; }
9739	public function setFitToWidth ( $ pValue , $ pUpdate = true ) { $ this -> fitToWidth = $ pValue ; if ( $ pUpdate ) { $ this -> fitToPage = true ; } return $ this ; }
7235	protected function assertItemAdjustmentClass ( Common \ AdjustmentInterface $ adjustment ) { if ( ! $ adjustment instanceof Model \ CartItemAdjustmentInterface ) { throw new InvalidArgumentException ( "Expected instance of " . Model \ CartItemAdjustmentInterface :: class ) ; } }
2738	private function setToken ( $ token ) { $ this -> configWriter -> save ( Config :: XML_FASTLY_API_KEY , $ token ) ; $ this -> output -> writeln ( '<info>Token updated.</info>' , OutputInterface :: OUTPUT_NORMAL ) ; }
1359	public static function jsonApi ( int $ options = 0 , string $ urlPrefix = null , int $ depth = 512 ) : self { return self :: create ( MediaTypeInterface :: JSON_API_MEDIA_TYPE , $ options , $ urlPrefix , $ depth ) ; }
7573	public function validateRequiredFields ( $ postVars ) { $ requiredFields = $ this -> getRequiredFields ( $ postVars [ 'id' ] ) ; $ missingKeys = array ( ) ; foreach ( $ requiredFields as $ human => $ keys ) { if ( ! $ this -> hasRequiredValue ( $ postVars , $ keys ) ) { $ missingKeys [ ] = $ human ; } } if ( ! empty ( $ missingKeys ) ) { throw new GreenhouseApplicationException ( 'Submission missing required answers for: ' . implode ( ', ' , $ missingKeys ) ) ; } return true ; }
3305	public function getFixedFormat ( $ images , array $ options = [ ] ) { $ images = is_array ( $ images ) ? $ images [ 0 ] : $ images ; if ( FileConverter :: isUrl ( $ images ) ) { throw new RuntimeException ( "Aliyun ocr not support online picture." ) ; } if ( $ this -> simpleRequestBody ) { return [ 'image' => FileConverter :: toBase64Encode ( $ images ) , 'configure' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ; } return [ 'inputs' => [ [ 'image' => [ 'dataType' => 50 , 'dataValue' => FileConverter :: toBase64Encode ( $ images ) ] , 'configure' => [ 'dataType' => 50 , 'dataValue' => json_encode ( $ options , JSON_UNESCAPED_UNICODE ) ] ] ] ] ; }
11062	public static function isEncodingSupported ( $ encoding ) { $ encoding = strtolower ( $ encoding ) ; if ( isset ( static :: supportedEncodings ( ) [ $ encoding ] ) ) { return true ; } return false ; }
11946	protected function getCurrentUser ( ) { try { return JWTAuth :: parseToken ( ) -> authenticate ( ) ; } catch ( \ Tymon \ JWTAuth \ Exceptions \ JWTException $ ex ) { return null ; } }
12911	public function getCountSQL ( ) { $ statement = [ ] ; if ( $ this -> distinct ) { $ distinct = 'DISTINCT ' ; } else { $ distinct = '' ; } $ statement [ ] = "(SELECT $distinct`" . $ this -> table . "`.*" ; $ statement [ ] = $ this -> getFrom ( ) ; $ statement [ ] = $ this -> getJoin ( ) ; $ statement [ ] = $ this -> getWhere ( ) ; $ statement [ ] = $ this -> getOrder ( ) ; $ statement [ ] = ")" ; foreach ( $ this -> unions as $ union ) { $ statement [ ] = "UNION " . $ distinct ; $ statement [ ] = $ union -> getCountSQL ( ) ; } $ statement = array_filter ( $ statement ) ; $ sql = implode ( "\n" , $ statement ) ; return $ sql ; }
2586	protected function loadBare ( PnrAddMultiElementsOptions $ params ) { $ tattooCounter = 0 ; if ( ! is_null ( $ params -> actionCode ) ) { $ this -> pnrActions = new AddMultiElements \ PnrActions ( $ params -> actionCode ) ; } if ( ! is_null ( $ params -> recordLocator ) ) { $ this -> reservationInfo = new AddMultiElements \ ReservationInfo ( $ params -> recordLocator ) ; } if ( $ params -> travellerGroup !== null ) { $ this -> addTravellerGroup ( $ params -> travellerGroup ) ; } else { $ this -> addTravellers ( $ params -> travellers ) ; } $ this -> addItineraries ( $ params -> itineraries , $ params -> tripSegments , $ tattooCounter ) ; if ( ! empty ( $ params -> elements ) ) { $ this -> addElements ( $ params -> elements , $ tattooCounter , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ params -> receivedFrom ) ; } else { $ this -> addReceivedFrom ( $ params -> receivedFrom , $ params -> autoAddReceivedFrom , $ params -> defaultReceivedFrom , $ tattooCounter ) ; } }
11788	private function updateTv ( $ dwnl ) { $ entity = new EBonDwnl ( ) ; foreach ( $ dwnl as $ one ) { $ tv = $ one -> getTv ( ) ; $ calcId = $ one -> getCalculationRef ( ) ; $ custId = $ one -> getCustomerRef ( ) ; $ entity -> setTv ( $ tv ) ; $ id = [ EBonDwnl :: A_CALC_REF => $ calcId , EBonDwnl :: A_CUST_REF => $ custId ] ; $ this -> daoBonDwnl -> updateById ( $ id , $ entity ) ; } }
2106	public function getMaxUploadFileSize ( ) { $ objResult = Database :: getInstance ( ) -> prepare ( "SELECT MAX(maxlength) AS maxlength FROM tl_form_field WHERE pid=? AND invisible='' AND type='upload' AND maxlength>0" ) -> execute ( $ this -> id ) ; if ( $ objResult -> numRows > 0 && $ objResult -> maxlength > 0 ) { return $ objResult -> maxlength ; } else { return Config :: get ( 'maxFileSize' ) ; } }
4878	public function setUser ( UserInterface $ user ) { if ( $ this -> user ) { $ this -> getPermissions ( ) -> revoke ( $ this -> user , Permissions :: PERMISSION_ALL , false ) ; } $ this -> user = $ user ; $ this -> getPermissions ( ) -> grant ( $ user , Permissions :: PERMISSION_ALL ) ; return $ this ; }
8456	public function drush ( $ command , $ assumeYes = true ) { if ( is_array ( $ command ) ) { $ command = implode ( ' ' , array_filter ( $ command ) ) ; } return $ this -> exec ( $ this -> injectArguments ( $ command , $ assumeYes ) ) ; }
3209	function createOAuth2AccessToken ( $ oauth1AccessToken ) { OAuth1AccessToken :: checkArg ( "oauth1AccessToken" , $ oauth1AccessToken ) ; $ response = self :: doPost ( $ oauth1AccessToken , "1/oauth2/token_from_oauth1" ) ; if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; $ parts = RequestUtil :: parseResponseJson ( $ response -> body ) ; if ( ! array_key_exists ( 'token_type' , $ parts ) || ! is_string ( $ parts [ 'token_type' ] ) ) { throw new Exception_BadResponse ( "Missing \"token_type\" field." ) ; } $ tokenType = $ parts [ 'token_type' ] ; if ( ! array_key_exists ( 'access_token' , $ parts ) || ! is_string ( $ parts [ 'access_token' ] ) ) { throw new Exception_BadResponse ( "Missing \"access_token\" field." ) ; } $ accessToken = $ parts [ 'access_token' ] ; if ( $ tokenType !== "Bearer" && $ tokenType !== "bearer" ) { throw new Exception_BadResponse ( "Unknown \"token_type\"; expecting \"Bearer\", got " . Util :: q ( $ tokenType ) ) ; } return $ accessToken ; }
2833	protected function _initQuery ( ) { $ token = $ this -> getRequest ( ) -> getParam ( 'token' ) ; $ index = $ this -> getRequest ( ) -> getParam ( 'index' ) ; if ( $ token === null || $ index === null ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 400 ) -> setBody ( 'Invalid parameters' ) ; return null ; } $ requestProfile = Mage :: getModel ( 'sheep_debug/requestInfo' ) -> load ( $ token , 'token' ) ; if ( ! $ requestProfile -> getId ( ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Request profile not found' ) ; return null ; } $ queries = $ requestProfile -> getQueries ( ) ; if ( ! $ queries || ! ( $ index < count ( $ queries ) ) ) { $ this -> getResponse ( ) -> setHttpResponseCode ( 404 ) -> setBody ( 'Query not found' ) ; return null ; } return $ queries [ ( int ) $ index ] ; }
9960	public function setAutoFilterByColumnAndRow ( $ columnIndex1 , $ row1 , $ columnIndex2 , $ row2 ) { return $ this -> setAutoFilter ( Coordinate :: stringFromColumnIndex ( $ columnIndex1 ) . $ row1 . ':' . Coordinate :: stringFromColumnIndex ( $ columnIndex2 ) . $ row2 ) ; }
10960	private function prepareFilePathTo ( \ SplFileInfo $ file ) { if ( $ this -> currentCommand -> isUsePathReplace ( ) ) { $ fileWhereToMovePath = $ file -> getPath ( ) . DIRECTORY_SEPARATOR ; if ( $ this -> direction === self :: DIRECTION_FORWARD ) { $ filePathTo = $ this -> currentCommand -> replacePath ( $ fileWhereToMovePath ) ; } elseif ( $ this -> direction === self :: DIRECTION_BACK ) { $ filePathTo = $ this -> currentCommand -> replacePathBack ( $ fileWhereToMovePath ) ; } else { throw new \ Exception ( __METHOD__ . " wrong direction" ) ; } $ this -> currentCommand -> setToDirectory ( $ filePathTo ) ; } else { $ filePathTo = $ this -> currentCommand -> getToDirectory ( ) ; } if ( ! file_exists ( $ filePathTo ) && ! is_dir ( $ filePathTo ) ) { mkdir ( $ filePathTo , $ this -> defaultDirMod , TRUE ) ; } else { chmod ( $ filePathTo , $ this -> defaultDirMod ) ; } if ( $ this -> currentCommand -> getDestinationFileName ( ) ) { $ fileName = $ this -> currentCommand -> getDestinationFileName ( ) ; } else { $ fileName = $ file -> getFilename ( ) ; } $ filePathTo .= $ fileName ; return $ filePathTo ; }
5731	public function getLeagues ( array $ filter = [ 'areas' => '' ] ) { $ leagues = $ this -> run ( "v2/competitions" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ leagues -> competitions ) ; }
1841	public static function parse ( $ file ) { if ( ! file_exists ( $ file ) ) { throw new \ InvalidArgumentException ( 'Invalid file ' . $ file ) ; } $ table = '' ; $ return = array ( ) ; $ data = file ( $ file ) ; foreach ( $ data as $ k => $ v ) { $ key_name = array ( ) ; $ subpatterns = array ( ) ; if ( preg_match ( '/^[#-]+/' , $ v ) || ! \ strlen ( trim ( $ v ) ) ) { unset ( $ data [ $ k ] ) ; continue ; } if ( preg_match ( '/^CREATE TABLE `([^`]+)`/i' , $ v , $ subpatterns ) ) { $ table = $ subpatterns [ 1 ] ; } elseif ( $ table != '' && preg_match ( '/^\)([^;]+);/' , $ v , $ subpatterns ) ) { $ return [ $ table ] [ 'TABLE_OPTIONS' ] = $ subpatterns [ 1 ] ; $ table = '' ; } elseif ( $ table != '' ) { preg_match ( '/^[^`]*`([^`]+)`/' , trim ( $ v ) , $ key_name ) ; $ first = preg_replace ( '/\s[^\n\r]+/' , '' , $ key_name [ 0 ] ) ; $ key = $ key_name [ 1 ] ; if ( \ in_array ( $ first , array ( 'KEY' , 'PRIMARY' , 'PRIMARY KEY' , 'FOREIGN' , 'FOREIGN KEY' , 'INDEX' , 'UNIQUE' , 'FULLTEXT' , 'CHECK' ) ) ) { if ( strncmp ( $ first , 'PRIMARY' , 7 ) === 0 ) { $ key = 'PRIMARY' ; } $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } else { $ return [ $ table ] [ 'TABLE_FIELDS' ] [ $ key ] = preg_replace ( '/,$/' , '' , trim ( $ v ) ) ; } } } foreach ( array_keys ( $ return ) as $ table ) { if ( ! isset ( $ return [ $ table ] [ 'TABLE_CREATE_DEFINITIONS' ] [ 'PRIMARY' ] ) ) { unset ( $ return [ $ table ] [ 'TABLE_OPTIONS' ] ) ; } } return $ return ; }
10551	public function determineVirtualHost ( ) { $ cfg = $ this -> config -> getSection ( 'site' ) ; $ vhost = self :: findVirtualHost ( $ this -> request -> webroot , $ this -> sites ) ; if ( $ vhost === null ) { $ result = $ this -> handleUnknownHost ( $ this -> request -> webroot , $ this -> request -> url , $ this -> sites , $ cfg ) ; if ( $ result === null ) throw new HTTPError ( 404 , "Not found: " . $ this -> url ) ; if ( $ result instanceof URL ) throw new RedirectRequest ( $ result , 301 ) ; if ( $ result instanceof VirtualHost ) { $ vhost = $ result ; $ site = $ vhost -> getSite ( ) ; if ( isset ( $ this -> sites [ $ site -> getName ( ) ] ) ) $ this -> sites [ $ site -> getName ( ) ] = $ site ; } else throw \ RuntimeException ( "Unexpected response from handleUnknownWebsite" ) ; } else { $ target = $ vhost -> getRedirect ( $ this -> request -> url ) ; if ( $ target ) throw new RedirectRequest ( $ target , 301 ) ; } $ this -> setVirtualHost ( $ vhost ) ; return $ this ; }
10490	public function neg ( ) { if ( $ this -> value === null ) { return new FloatType ( $ this -> value ) ; } return new FloatType ( $ this -> value * - 1 ) ; }
9223	public function unserialize ( $ data ) { $ _data = unserialize ( $ data ) ; $ this -> page = $ _data [ 'page' ] ; $ this -> key = $ _data [ 'key' ] ; $ this -> data = $ _data [ 'data' ] ; $ this -> api = null ; $ this -> endpoint = null ; $ this -> pagination = array ( ) ; }
3232	static function findError ( $ path ) { Checker :: argStringNonEmpty ( "path" , $ path ) ; $ matchResult = preg_match ( '%^(?: [\x09\x0A\x0D\x20-\x7E] # ASCII | [\xC2-\xDF][\x80-\xBF] # non-overlong 2-byte | \xE0[\xA0-\xBF][\x80-\xBD] # excluding overlongs, FFFE, and FFFF | [\xE1-\xEC\xEE\xEF][\x80-\xBF]{2} # straight 3-byte | \xED[\x80-\x9F][\x80-\xBF] # excluding surrogates )*$%xs' , $ path ) ; if ( $ matchResult !== 1 ) { return "must be valid UTF-8; BMP only, no surrogates, no U+FFFE or U+FFFF" ; } if ( $ path [ 0 ] !== "/" ) return "must start with \"/\"" ; $ l = strlen ( $ path ) ; if ( $ l === 1 ) return null ; if ( $ path [ $ l - 1 ] === "/" ) return "must not end with \"/\"" ; return null ; }
2932	public function setKey ( $ key , $ value = null , $ comment = null , $ export = false ) { $ data = [ compact ( 'key' , 'value' , 'comment' , 'export' ) ] ; return $ this -> setKeys ( $ data ) ; }
5215	private function getAnnotatedBinding ( \ ReflectionClass $ class ) { $ annotations = annotationsOf ( $ class ) ; if ( $ class -> isInterface ( ) && $ annotations -> contain ( 'ImplementedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> to ( $ this -> findImplementation ( $ annotations , $ class -> getName ( ) ) ) ; } elseif ( $ annotations -> contain ( 'ProvidedBy' ) ) { return $ this -> bind ( $ class -> getName ( ) ) -> toProviderClass ( $ annotations -> firstNamed ( 'ProvidedBy' ) -> getProviderClass ( ) ) ; } return $ this -> getImplicitBinding ( $ class ) ; }
861	public function isMonolithicPhp ( ) { $ size = $ this -> count ( ) ; if ( 0 === $ size ) { return false ; } if ( self :: isLegacyMode ( ) ) { if ( $ this [ 0 ] -> isGivenKind ( T_INLINE_HTML ) || $ this [ $ size - 1 ] -> isGivenKind ( T_INLINE_HTML ) ) { return false ; } for ( $ index = 1 ; $ index < $ size ; ++ $ index ) { if ( $ this [ $ index ] -> isGivenKind ( [ T_INLINE_HTML , T_OPEN_TAG , T_OPEN_TAG_WITH_ECHO ] ) ) { return false ; } } return true ; } if ( $ this -> isTokenKindFound ( T_INLINE_HTML ) ) { return false ; } return 1 >= ( $ this -> countTokenKind ( T_OPEN_TAG ) + $ this -> countTokenKind ( T_OPEN_TAG_WITH_ECHO ) ) ; }
1829	public function delete ( ) { $ intPk = $ this -> { static :: $ strPk } ; if ( isset ( $ this -> arrModified [ static :: $ strPk ] ) ) { $ intPk = $ this -> arrModified [ static :: $ strPk ] ; } $ intAffected = Database :: getInstance ( ) -> prepare ( "DELETE FROM " . static :: $ strTable . " WHERE " . Database :: quoteIdentifier ( static :: $ strPk ) . "=?" ) -> execute ( $ intPk ) -> affectedRows ; if ( $ intAffected ) { Registry :: getInstance ( ) -> unregister ( $ this ) ; $ this -> arrData [ static :: $ strPk ] = null ; } return $ intAffected ; }
8902	public function delete ( $ id , $ time = 'NOW()' ) { $ this -> _database -> where ( $ this -> primary_key , $ id ) ; return $ this -> _delete ( $ id , $ time ) ; }
9100	private function bind ( ) { if ( ! @ socket_bind ( $ this -> handle , $ this -> endpoint -> getAddress ( ) , $ this -> endpoint -> getPort ( ) ) ) { $ code = socket_last_error ( $ this -> handle ) ; throw new SocketException ( socket_strerror ( $ code ) , array ( ) , $ code ) ; } }
8342	public static function addData ( string $ title , array $ data ) { if ( self :: $ isInit === true ) { self :: $ prettyPageHandler -> AddDataTable ( $ title , $ data ) ; } }
4942	public function fileCountValidationCallback ( ) { if ( $ this -> form && ( $ object = $ this -> form -> getObject ( ) ) ) { if ( $ this -> getMaxFileCount ( ) - 1 < count ( $ object ) ) { return false ; } } return true ; }
12559	public function fixFile ( $ file ) { $ contents = preg_split ( "/\\r\\n|\\r|\\n/" , file_get_contents ( $ file ) ) ; $ changed = false ; if ( $ this -> fixFileSlashes ( $ file , $ contents ) ) { $ changed = true ; } if ( $ changed ) { file_put_contents ( $ file , implode ( "\n" , $ contents ) ) ; } return $ changed ; }
5150	protected function getEmailRecipients ( $ email ) { $ recipients = $ email -> Headers -> to . ' ' . $ email -> Headers -> cc ; if ( $ email -> Headers -> bcc != NULL ) { $ recipients .= ' ' . $ email -> Headers -> bcc ; } return $ recipients ; }
1373	public function all ( ) { if ( is_array ( $ this -> data ) ) { return $ this -> data ; } return $ this -> data = $ this -> route -> getCodec ( ) -> all ( $ this -> request ) ; }
4600	public function postLoad ( LifecycleEventArgs $ args ) { $ entity = $ args -> getEntity ( ) ; if ( ! $ entity instanceof Translatable ) { return ; } $ this -> translationService -> translate ( $ entity ) ; }
1390	protected function resourceDoesNotExist ( string $ path ) : void { $ this -> errors -> add ( $ this -> translator -> resourceDoesNotExist ( $ path ) ) ; }
1643	public function getCenter ( ) : Coordinate { $ centerLat = ( $ this -> getNorth ( ) + $ this -> getSouth ( ) ) / 2 ; return new Coordinate ( $ centerLat , $ this -> getCenterLng ( ) ) ; }
6216	public static function realmNameToSlug ( string $ name ) : string { $ name = \ mb_strtolower ( $ name , 'UTF-8' ) ; $ slug = \ str_replace ( static :: $ replaceTable [ 0 ] , static :: $ replaceTable [ 1 ] , $ name ) ; $ slug = \ preg_replace ( static :: $ regexTable [ 0 ] , static :: $ regexTable [ 1 ] , $ slug ) ; return \ trim ( ( string ) $ slug , '-' ) ; }
5468	public function addHeaders ( $ request , $ url ) { if ( $ url -> getUsername ( ) && $ url -> getPassword ( ) ) { $ username = $ url -> getUsername ( ) ; $ password = $ url -> getPassword ( ) ; } elseif ( $ realm = $ this -> findRealmFromUrl ( $ url ) ) { $ username = $ realm -> getUsername ( ) ; $ password = $ realm -> getPassword ( ) ; } else { return ; } $ this -> addBasicHeaders ( $ request , $ username , $ password ) ; }
1393	protected function prepareJsonApiException ( JsonApiException $ ex ) { $ error = collect ( $ ex -> getErrors ( ) ) -> map ( function ( ErrorInterface $ err ) { return $ err -> getDetail ( ) ? : $ err -> getTitle ( ) ; } ) -> filter ( ) -> first ( ) ; return new HttpException ( $ ex -> getHttpCode ( ) , $ error , $ ex ) ; }
2621	public function sendValidationRequest ( $ validatedFlag , $ serviceId = null ) { if ( $ serviceId != null ) { $ this -> validationServiceId = $ serviceId ; } if ( $ validatedFlag ) { $ validationState = self :: FASTLY_VALIDATED_FLAG ; } else { $ validationState = self :: FASTLY_NON_VALIDATED_FLAG ; } $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . $ validationState , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . $ validationState , 'dt' => ucfirst ( $ validationState ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . $ validationState , 'el' => $ this -> getWebsiteName ( ) , 'ev' => $ this -> daysFromInstallation ( ) , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
5554	public function getHeaders ( ) { if ( is_integer ( $ this -> focus ) ) { return $ this -> frames [ $ this -> focus ] -> getHeaders ( ) ; } return $ this -> frameset -> getHeaders ( ) ; }
3830	protected function prepareFrontendFilterOptions ( $ arrWidget , $ arrFilterUrl , $ arrJumpTo , $ blnAutoSubmit ) { $ arrOptions = array ( ) ; if ( ! isset ( $ arrWidget [ 'options' ] ) ) { return $ arrOptions ; } $ filterUrl = new FilterUrl ( $ arrJumpTo ) ; foreach ( $ arrFilterUrl as $ name => $ value ) { if ( is_array ( $ value ) ) { $ value = implode ( ',' , array_filter ( $ value ) ) ; } $ filterUrl -> setSlug ( $ name , ( string ) $ value ) ; } $ parameterName = $ arrWidget [ 'eval' ] [ 'urlparam' ] ; if ( $ arrWidget [ 'eval' ] [ 'includeBlankOption' ] ) { $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , '' ) ; $ arrOptions [ ] = array ( 'key' => '' , 'value' => ( $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] ? $ arrWidget [ 'eval' ] [ 'blankOptionLabel' ] : $ GLOBALS [ 'TL_LANG' ] [ 'metamodels_frontendfilter' ] [ 'do_not_filter' ] ) , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , '' ) ) , 'active' => $ blnActive , 'class' => 'doNotFilter' . ( $ blnActive ? ' active' : '' ) , ) ; } foreach ( $ arrWidget [ 'options' ] as $ strKeyOption => $ strOption ) { $ strValue = $ this -> getFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ blnActive = $ this -> isActiveFrontendFilterValue ( $ arrWidget , $ arrFilterUrl , $ strKeyOption ) ; $ arrOptions [ ] = array ( 'key' => $ strKeyOption , 'value' => $ strOption , 'href' => $ this -> filterUrlBuilder -> generate ( $ filterUrl -> clone ( ) -> setSlug ( $ parameterName , $ strValue ) ) , 'active' => $ blnActive , 'class' => StringUtil :: standardize ( $ strKeyOption ) . ( $ blnActive ? ' active' : '' ) ) ; } return $ arrOptions ; }
5245	private function replace ( string $ pattern , string $ replacement , string $ targetFile ) { $ this -> filesystem -> put ( $ targetFile , preg_replace ( $ pattern , $ replacement , $ this -> filesystem -> get ( $ targetFile ) ) ) ; }
4292	public function getCfg ( $ path = null ) { if ( ! \ strlen ( $ path ) ) { return $ this -> cfg ; } if ( isset ( $ this -> cfg [ $ path ] ) ) { return $ this -> cfg [ $ path ] ; } return null ; }
951	public function activate ( ) { $ currentCharge = $ this -> shop -> planCharge ( ) ; if ( ! $ currentCharge -> isType ( Charge :: CHARGE_RECURRING ) ) { throw new Exception ( 'Can only create usage charges for recurring charge.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/recurring_application_charges/{$currentCharge->charge_id}/usage_charges.json" , [ 'usage_charge' => [ 'price' => $ this -> data [ 'price' ] , 'description' => $ this -> data [ 'description' ] , ] , ] ) -> body -> usage_charge ; return $ this -> response ; }
4807	public function schedule_event ( ) { if ( $ this -> is_scheduled ( $ this -> args [ 'name' ] ) ) { return ; } if ( $ this -> args [ 'run_on_creation' ] ) { call_user_func ( $ this -> args [ 'cb' ] , $ this -> args [ 'args' ] ) ; } if ( $ this -> args [ 'schedule' ] === 'schedule' ) { wp_schedule_event ( $ this -> args [ 'time' ] , $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } elseif ( $ this -> args [ 'schedule' ] === 'single' ) { wp_schedule_single_event ( $ this -> args [ 'recurrence' ] , $ this -> args [ 'name' ] , $ this -> args [ 'args' ] ) ; } if ( is_multisite ( ) && ! wp_is_large_network ( ) ) { $ sites = ( array ) get_site_option ( $ this -> args [ 'name' ] . '_sites' , array ( ) ) ; $ sites [ ] = get_current_blog_id ( ) ; update_site_option ( $ this -> args [ 'name' ] . '_sites' , $ sites ) ; } return true ; }
8266	public function lock ( $ lockType ) { if ( ! $ this -> isOpened ( ) ) { return false ; } if ( $ this -> options [ "blocking" ] ) { return flock ( $ this -> handle , $ lockType ) ; } else { $ tries = 0 ; do { if ( flock ( $ this -> handle , $ lockType | LOCK_NB ) ) { return true ; } else { ++ $ tries ; usleep ( self :: LOCK_RETRY_WAIT ) ; } } while ( $ tries < self :: LOCK_MAX_TRIES ) ; return false ; } }
8457	protected function injectArguments ( $ command , $ assumeYes ) { $ cmd = $ this -> siteAlias . ' ' . $ command . ( $ assumeYes ? ' -y' : '' ) . $ this -> arguments . $ this -> argumentsForNextCommand ; $ this -> argumentsForNextCommand = '' ; return $ cmd ; }
10337	public static function oneAnchor2twoAnchor ( $ sheet , $ coordinates , $ offsetX , $ offsetY , $ width , $ height ) { list ( $ column , $ row ) = Coordinate :: coordinateFromString ( $ coordinates ) ; $ col_start = Coordinate :: columnIndexFromString ( $ column ) ; $ row_start = $ row - 1 ; $ x1 = $ offsetX ; $ y1 = $ offsetY ; $ col_end = $ col_start ; $ row_end = $ row_start ; if ( $ x1 >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) ) { $ x1 = 0 ; } if ( $ y1 >= self :: sizeRow ( $ sheet , $ row_start + 1 ) ) { $ y1 = 0 ; } $ width = $ width + $ x1 - 1 ; $ height = $ height + $ y1 - 1 ; while ( $ width >= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ) { $ width -= self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) ; ++ $ col_end ; } while ( $ height >= self :: sizeRow ( $ sheet , $ row_end + 1 ) ) { $ height -= self :: sizeRow ( $ sheet , $ row_end + 1 ) ; ++ $ row_end ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) == 0 ) { return ; } if ( self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_start + 1 ) == 0 ) { return ; } if ( self :: sizeRow ( $ sheet , $ row_end + 1 ) == 0 ) { return ; } $ x1 = $ x1 / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_start ) ) * 1024 ; $ y1 = $ y1 / self :: sizeRow ( $ sheet , $ row_start + 1 ) * 256 ; $ x2 = ( $ width + 1 ) / self :: sizeCol ( $ sheet , Coordinate :: stringFromColumnIndex ( $ col_end ) ) * 1024 ; $ y2 = ( $ height + 1 ) / self :: sizeRow ( $ sheet , $ row_end + 1 ) * 256 ; $ startCoordinates = Coordinate :: stringFromColumnIndex ( $ col_start ) . ( $ row_start + 1 ) ; $ endCoordinates = Coordinate :: stringFromColumnIndex ( $ col_end ) . ( $ row_end + 1 ) ; $ twoAnchor = [ 'startCoordinates' => $ startCoordinates , 'startOffsetX' => $ x1 , 'startOffsetY' => $ y1 , 'endCoordinates' => $ endCoordinates , 'endOffsetX' => $ x2 , 'endOffsetY' => $ y2 , ] ; return $ twoAnchor ; }
2028	public static function findPublishedRegularWithoutGuestsByPid ( $ intPid , array $ arrOptions = array ( ) ) { $ t = static :: $ strTable ; $ arrColumns = array ( "$t.pid=? AND $t.type!='root' AND $t.type!='error_401' AND $t.type!='error_403' AND $t.type!='error_404'" ) ; if ( FE_USER_LOGGED_IN ) { $ arrColumns [ ] = "$t.guests=''" ; } if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.sorting" ; } return static :: findBy ( $ arrColumns , $ intPid , $ arrOptions ) ; }
5792	private function setConstraints ( ) { $ q = new QueryBuilder ( "SELECT ccu.column_name, tc.constraint_type FROM INFORMATION_SCHEMA.constraint_column_usage ccu JOIN information_schema.table_constraints tc ON ccu.constraint_name = tc.constraint_name WHERE tc.table_name = ccu.table_name AND ccu.table_name = $1" , $ this -> tableName ) ; $ qResult = $ q -> execute ( ) ; while ( $ qRow = pg_fetch_assoc ( $ qResult ) ) { switch ( $ qRow [ 'constraint_type' ] ) { case 'PRIMARY KEY' : $ this -> primaryKeyColumnName = $ qRow [ 'column_name' ] ; break ; case 'UNIQUE' : $ this -> uniqueColumnNames [ ] = $ qRow [ 'column_name' ] ; } } }
9929	protected function handleUnpermittedParam ( $ key , $ params ) { if ( $ this -> getThrowExceptions ( ) ) { $ message = "Parameter '$key' is not allowed" ; throw new UnpermittedParameterException ( $ message ) ; } $ params -> delete ( $ key ) ; }
3100	private function getItemData ( RunnerServiceContext $ context , $ itemRef ) { $ this -> getRunnerService ( ) -> assertQtiRunnerServiceContext ( $ context ) ; $ itemData = $ this -> getRunnerService ( ) -> getItemData ( $ context , $ itemRef ) ; $ itemDataVariable = $ this -> getRunnerService ( ) -> getItemVariableElementsData ( $ context , $ itemRef ) ; $ responses = $ itemData [ 'data' ] [ 'responses' ] ; foreach ( array_keys ( $ responses ) as $ responseId ) { if ( array_key_exists ( $ responseId , $ itemDataVariable ) ) { $ itemData [ 'data' ] [ 'responses' ] [ $ responseId ] = array_merge ( ... [ $ responses [ $ responseId ] , $ itemDataVariable [ $ responseId ] , ] ) ; } } return $ itemData ; }
7342	protected function scheduleSupplierOrderContentChangeEvent ( Model \ SupplierOrderInterface $ order ) { $ this -> persistenceHelper -> scheduleEvent ( SupplierOrderEvents :: CONTENT_CHANGE , $ order ) ; }
7906	protected function renderMenu ( $ items , $ parentItem ) { $ options = ArrayHelper :: getValue ( $ parentItem , 'options' ) ; $ label = $ this -> getLabel ( $ parentItem ) ; $ items = Html :: tag ( 'div' , $ this -> renderItems ( $ items ) , [ 'class' => 'menu' ] ) ; Html :: addCssClass ( $ options , 'ui' ) ; Html :: addCssClass ( $ options , 'header' ) ; return Html :: tag ( 'div' , Html :: tag ( 'div' , $ label , $ options ) . $ items , [ 'class' => 'item' ] ) ; }
3858	public function setFilterSettings ( $ intFilter ) { $ this -> intFilter = $ intFilter ; $ this -> objFilterSettings = $ this -> getFilterFactory ( ) -> createCollection ( $ this -> intFilter ) ; if ( ! $ this -> objFilterSettings ) { throw new \ RuntimeException ( 'Error: no filter object defined.' ) ; } return $ this ; }
1307	private static function replaceUrlParameter ( $ url , $ source ) { $ parameter = static :: urlParameter ( $ url ) ; return str_replace ( '{' . $ parameter . '}' , $ source [ $ parameter ] , $ url ) ; }
4393	public function cancel ( \ Aimeos \ MShop \ Order \ Item \ Iface $ order ) { $ provider = $ this -> getProvider ( ) ; if ( ! $ provider -> supportsVoid ( ) ) { return ; } $ base = $ this -> getOrderBase ( $ order -> getBaseId ( ) ) ; $ data = array ( 'transactionReference' => $ this -> getTransactionReference ( $ base ) , 'currency' => $ base -> getPrice ( ) -> getCurrencyId ( ) , 'amount' => $ this -> getAmount ( $ base -> getPrice ( ) ) , 'transactionId' => $ order -> getId ( ) , ) ; $ response = $ provider -> void ( $ data ) -> send ( ) ; if ( $ response -> isSuccessful ( ) ) { $ status = \ Aimeos \ MShop \ Order \ Item \ Base :: PAY_CANCELED ; $ order -> setPaymentStatus ( $ status ) ; $ this -> saveOrder ( $ order ) ; } }
8477	public function run ( $ id ) { $ model = $ this -> controller -> findModel ( $ id ) ; if ( $ model -> is_system ) { \ Yii :: $ app -> session -> setFlash ( 'warning' , \ Yii :: t ( 'app' , 'You cannot update or delete system handlers' ) ) ; } else { $ model -> delete ( ) ; } return $ this -> controller -> redirect ( [ 'index' ] ) ; }
11090	public static function getGreeting ( $ time = null ) { if ( $ time === null ) { $ time = time ( ) ; } elseif ( \ is_string ( $ time ) ) { $ time = strtotime ( $ time ) ; } switch ( date ( 'G' , $ time ) ) { case 0 : case 1 : case 2 : case 3 : case 4 : case 5 : case 6 : case 7 : return self :: poorManTranslate ( 'fts-shared' , 'Good morning' ) ; case 8 : case 9 : case 10 : case 11 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good morning' ) , '_' ) ; case 12 : return self :: poorManTranslate ( 'fts-shared' , 'Good noon' ) ; case 13 : case 14 : case 15 : case 16 : return self :: poorManTranslate ( 'fts-shared' , 'Good afternoon' ) ; case 17 : case 18 : case 19 : return trim ( self :: poorManTranslate ( 'fts-shared' , '_Good afternoon' ) , '_' ) ; case 20 : case 21 : case 22 : case 23 : return self :: poorManTranslate ( 'fts-shared' , 'Good evening' ) ; default : return '' ; } }
12255	public function removeCompiler ( $ compiler ) { if ( ( $ idx = array_search ( $ compiler , $ this -> compilers ) ) !== false ) { unset ( $ this -> compilers [ $ idx ] ) ; $ this -> orderedCompilers = NULL ; } }
12309	public function resetPasswordAction ( ) { if ( $ this -> cmsAuthentication ( ) -> hasIdentity ( ) ) { return $ this -> redirect ( ) -> toRoute ( $ this -> getOptions ( ) -> getDefaultUserRoute ( ) ) ; } if ( $ token = $ this -> params ( ) -> fromRoute ( 'token' ) ) { $ identity = $ this -> getUserService ( ) -> confirmPasswordReset ( $ token ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-success' ) ; return $ viewModel ; } return $ this -> redirect ( ) -> toRoute ( ) ; } $ url = $ this -> url ( ) -> fromRoute ( ) ; $ prg = $ this -> prg ( $ url , true ) ; if ( $ prg instanceof ResponseInterface ) { return $ prg ; } $ post = $ prg ; $ form = $ this -> getUserService ( ) -> getResetPasswordForm ( ) ; $ form -> setAttribute ( 'action' , $ url ) ; if ( $ post && $ form -> setData ( $ post ) -> isValid ( ) ) { $ identity = $ this -> getUserService ( ) -> resetPassword ( $ form -> get ( 'identity' ) -> getValue ( ) ) ; if ( $ identity instanceof ResponseInterface ) { return $ identity ; } elseif ( $ identity ) { $ viewModel = new ViewModel ( compact ( 'identity' ) ) ; $ viewModel -> setTemplate ( 'cms-user/authentication/reset-password-warning' ) ; return $ viewModel ; } } return new ViewModel ( compact ( 'form' ) ) ; }
5100	public function values ( $ values ) { if ( isset ( $ values [ 0 ] ) ) return $ this -> appendByPosition ( $ values ) ; $ this -> fixDefaultValues ( $ values ) ; if ( ! $ this -> fields ) { $ this -> placeholder = false ; $ this -> fields = array_keys ( $ values ) ; return $ this -> appendByPosition ( array_values ( $ values ) ) ; } return $ this -> appendByField ( $ values ) ; }
4340	private function uncollapseErrors ( & $ log ) { $ groupStack = array ( ) ; for ( $ i = 0 , $ count = \ count ( $ log ) ; $ i < $ count ; $ i ++ ) { $ method = $ log [ $ i ] [ 0 ] ; if ( \ in_array ( $ method , array ( 'group' , 'groupCollapsed' ) ) ) { $ groupStack [ ] = $ i ; } elseif ( $ method == 'groupEnd' ) { \ array_pop ( $ groupStack ) ; } elseif ( \ in_array ( $ method , array ( 'error' , 'warn' ) ) ) { foreach ( $ groupStack as $ i2 ) { $ log [ $ i2 ] [ 0 ] = 'group' ; } } } }
6855	private function transform ( SaleInterface $ sale ) { $ order = $ this -> newOrder ( ) ; $ this -> saleTransformer -> initialize ( $ sale , $ order ) ; if ( null === $ event = $ this -> saleTransformer -> transform ( ) ) { return $ order ; } return null ; }
2838	public function getRequestInfo ( ) { if ( $ this -> requestInfo === null ) { $ this -> requestInfo = Mage :: registry ( 'sheep_debug_request_info' ) ; } return $ this -> requestInfo ; }
1266	private function createRecoverLabelRequest ( $ trackingData , $ labelSpecificationOpts = null , $ labelDeliveryOpts = null , $ translateOpts = null ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ container = $ xml -> appendChild ( $ xml -> createElement ( 'LabelRecoveryRequest' ) ) ; $ request = $ container -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LabelRecovery' ) ) ; if ( is_string ( $ trackingData ) ) { $ container -> appendChild ( $ xml -> createElement ( 'TrackingNumber' , $ trackingData ) ) ; } elseif ( is_array ( $ trackingData ) ) { $ referenceNumber = $ container -> appendChild ( $ xml -> createElement ( 'ReferenceNumber' ) ) ; $ referenceNumber -> appendChild ( $ xml -> createElement ( 'Value' , $ trackingData [ 'value' ] ) ) ; $ container -> appendChild ( $ xml -> createElement ( 'ShipperNumber' , $ trackingData [ 'shipperNumber' ] ) ) ; } if ( ! empty ( $ labelSpecificationOpts ) ) { $ labelSpec = $ request -> appendChild ( $ xml -> createElement ( 'LabelSpecification' ) ) ; if ( isset ( $ labelSpecificationOpts [ 'userAgent' ] ) ) { $ labelSpec -> appendChild ( $ xml -> createElement ( 'HTTPUserAgent' , $ labelSpecificationOpts [ 'userAgent' ] ) ) ; } if ( isset ( $ labelSpecificationOpts [ 'imageFormat' ] ) ) { $ format = $ labelSpec -> appendChild ( $ xml -> createElement ( 'LabelImageFormat' ) ) ; $ format -> appendChild ( $ xml -> createElement ( 'Code' , $ labelSpecificationOpts [ 'imageFormat' ] ) ) ; } } if ( ! empty ( $ labelDeliveryOpts ) ) { $ labelDelivery = $ request -> appendChild ( $ xml -> createElement ( 'LabelDelivery' ) ) ; $ labelDelivery -> appendChild ( $ xml -> createElement ( 'LabelLinkIndicator' , $ labelDeliveryOpts [ 'link' ] ) ) ; } if ( ! empty ( $ translateOpts ) ) { $ translate = $ request -> appendChild ( $ xml -> createElement ( 'Translate' ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'LanguageCode' , $ translateOpts [ 'language' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'DialectCode' , $ translateOpts [ 'dialect' ] ) ) ; $ translate -> appendChild ( $ xml -> createElement ( 'Code' , '01' ) ) ; } return $ xml -> saveXML ( ) ; }
3962	private function createOrGetDefinition ( IMetaModelDataDefinition $ container ) { if ( $ container -> hasMetaModelDefinition ( ) ) { return $ container -> getMetaModelDefinition ( ) ; } $ container -> setMetaModelDefinition ( $ definition = new MetaModelDefinition ( ) ) ; return $ definition ; }
7426	private function isValid ( $ source = '' ) { if ( empty ( $ source ) ) { return false ; } else { $ extension = substr ( $ source , - 3 ) ; if ( strtolower ( $ extension ) !== 'swf' ) { return false ; } } return true ; }
646	public function checkIntegrity ( $ check = true , $ schema = '' , $ table = '' ) { $ sql = $ this -> db -> getQueryBuilder ( ) -> checkIntegrity ( $ check , $ schema , $ table ) ; return $ this -> setSql ( $ sql ) ; }
1665	public function getListForSelect ( $ display = 'name' ) { foreach ( $ this -> getList ( $ display ) as $ key => $ value ) { $ countries [ $ key ] = $ value [ $ display ] ; } return $ countries ; }
12963	public function checkDbExists ( $ name ) { $ data = $ this -> query ( "SELECT COUNT(*) AS total FROM INFORMATION_SCHEMA.SCHEMATA WHERE SCHEMA_NAME = '" . $ this -> escape ( $ name ) . "'" , true ) ; if ( isset ( $ data [ '0' ] [ 'total' ] ) && $ data [ '0' ] [ 'total' ] == '1' ) { return true ; } return false ; }
5752	public function getObjects ( array $ whereColumnsInfo = null ) : array { $ roles = [ ] ; if ( null !== $ records = $ this -> select ( "*" , $ whereColumnsInfo ) ) { foreach ( $ records as $ record ) { $ roles [ ] = $ this -> buildRole ( ( int ) $ record [ 'id' ] , $ record [ 'role' ] , new \ DateTimeImmutable ( $ record [ 'created' ] ) ) ; } } return $ roles ; }
4824	public function removeValue ( $ fieldName , $ value ) { $ result = $ this -> row [ $ fieldName ] ; if ( ! is_array ( $ result ) ) { if ( $ value == $ result ) { unset ( $ this -> row [ $ fieldName ] ) ; $ this -> informChanges ( ) ; } } else { $ qty = count ( $ result ) ; for ( $ i = 0 ; $ i < $ qty ; $ i ++ ) { if ( $ result [ $ i ] == $ value ) { unset ( $ result [ $ i ] ) ; $ this -> informChanges ( ) ; } } $ this -> row [ $ fieldName ] = array_values ( $ result ) ; } }
11860	public function setCompanionObject ( $ value ) { if ( $ this -> isForeign ) { return $ this -> localObject = $ value ; } else { return $ this -> foreignObject = $ value ; } }
418	public function getCookies ( ) { if ( $ this -> _cookies === null ) { $ this -> _cookies = new CookieCollection ( $ this -> loadCookies ( ) , [ 'readOnly' => true , ] ) ; } return $ this -> _cookies ; }
4090	public function delete ( $ id = false , $ index , $ type , array $ options = array ( ) ) { $ params = array ( '_id' => $ id , '_index' => $ index , '_type' => $ type ) ; foreach ( $ options as $ key => $ value ) { $ params [ '_' . $ key ] = $ value ; } $ operation = array ( array ( 'delete' => $ params ) ) ; $ this -> operations [ ] = $ operation ; return $ this ; }
2582	protected function loadTransactionFlowLink ( $ params ) { if ( isset ( $ params [ 'enableTransactionFlowLink' ] ) && $ params [ 'enableTransactionFlowLink' ] === true ) { $ this -> enableTransactionFlowLink = true ; $ this -> consumerId = ( isset ( $ params [ 'consumerId' ] ) ) ? $ params [ 'consumerId' ] : null ; } }
4773	public function order ( Request $ request , WidgetInterface $ widget , string $ widgetId , int $ order ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; $ widgetConfig -> addWidgetConfig ( $ widgetId , [ 'order' => $ order ] ) ; $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; } return $ this -> json ( [ 'result' => 'success' , ] ) ; }
3800	public function getMetaModel ( EnvironmentInterface $ interface ) { $ metaModelId = $ this -> connection -> createQueryBuilder ( ) -> select ( 'd.pid' ) -> from ( 'tl_metamodel_dca' , 'd' ) -> leftJoin ( 'd' , 'tl_metamodel_dcasetting' , 's' , '(d.id=s.pid)' ) -> where ( '(s.id=:id)' ) -> setParameter ( 'id' , ModelId :: fromSerialized ( $ interface -> getInputProvider ( ) -> getParameter ( 'pid' ) ) -> getId ( ) ) -> execute ( ) ; if ( $ tableName = $ this -> factory -> translateIdToMetaModelName ( $ metaModelId = $ metaModelId -> fetchColumn ( ) ) ) { return $ this -> factory -> getMetaModel ( $ tableName ) ; } throw new \ RuntimeException ( 'Could not retrieve MetaModel ' . $ metaModelId ) ; }
3719	protected function wantToHandle ( AbstractEnvironmentAwareEvent $ event ) { if ( ! parent :: wantToHandle ( $ event ) ) { return false ; } if ( $ event -> getPropertyName ( ) !== 'type' ) { return false ; } $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> get ( 'act' , null ) === 'select' && ! $ event -> getModel ( ) -> getId ( ) ) { return false ; } return true ; }
9342	public function populate ( $ arrAll ) { $ this -> arr = array_chunk ( $ arrAll , $ this -> size -> cols ) ; return $ this ; }
1550	protected function getRelation ( $ record , $ key ) { $ relation = $ record -> { $ key } ( ) ; if ( ! $ relation || ! $ this -> acceptRelation ( $ relation ) ) { throw new RuntimeException ( sprintf ( 'JSON API relation %s cannot be used for an Eloquent %s relation.' , class_basename ( $ this ) , class_basename ( $ relation ) ) ) ; } return $ relation ; }
4151	protected function resetCallState ( ) { $ this -> call = null ; $ this -> method = null ; $ this -> withMedia = null ; $ this -> getParams = array ( ) ; $ this -> postParams = array ( ) ; $ this -> headers = null ; }
12027	function addExecuteMethod ( ) { $ body = $ this -> generateCreateFragment ( ) ; $ body .= 'return $this->dispatch($request);' ; $ docBlock = $ this -> generateExecuteDocBlock ( 'Execute the operation, returning the parsed response' ) ; $ methodGenerator = new MethodGenerator ( 'execute' ) ; $ methodGenerator -> setBody ( $ body ) ; $ methodGenerator -> setDocBlock ( $ docBlock ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
7528	static function minify_javascript ( & $ root , $ indent_string = ' ' , $ wrap_comment = true , $ recursive = true ) { include_once ( 'third party/jsminplus.php' ) ; $ errors = array ( ) ; foreach ( $ root -> select ( 'script:not-empty > "~text~"' , false , $ recursive , true ) as $ c ) { try { $ text = $ c -> text ; while ( $ text ) { $ text = trim ( $ text ) ; if ( substr ( $ text , 0 , 4 ) === '<!--' ) { $ text = substr ( $ text , 5 ) ; continue ; } elseif ( strtolower ( substr ( $ text , 0 , 9 ) ) === '<![cdata[' ) { $ text = substr ( $ text , 10 ) ; continue ; } if ( ( $ end = substr ( $ text , - 3 ) ) && ( ( $ end === ' ) || ( $ end === ']]>' ) ) ) { $ text = substr ( $ text , 0 , - 3 ) ; continue ; } break ; } if ( trim ( $ text ) ) { $ text = \ JSMinPlus :: minify ( $ text ) ; if ( $ wrap_comment ) { $ text = "<!--\n" . $ text . "\n// ; } if ( $ indent_string && ( $ wrap_comment || ( strpos ( $ text , "\n" ) !== false ) ) ) { $ text = indent_text ( "\n" . $ text , $ c -> indent ( ) , $ indent_string ) ; } } $ c -> text = $ text ; } catch ( \ Exception $ e ) { $ errors [ ] = array ( $ e , $ c -> parent -> dumpLocation ( ) ) ; } } return ( ( $ errors ) ? $ errors : true ) ; }
10036	function getBlockedContacts ( $ standardFields = array ( ) , $ customFields = array ( ) , $ pageIndex = 1 , $ pageSize = 1000 ) { $ queryParameters = array ( 'standard_field' => $ standardFields , 'page_index' => $ pageIndex , 'page_size' => $ pageSize ) ; $ queryParameters = $ this -> appendArrayFields ( $ queryParameters , 'custom_field' , $ customFields ) ; return $ this -> get ( 'contacts/blocked' , $ queryParameters ) ; }
4979	public function get ( $ form , $ options = null , $ params = null ) { if ( ! is_object ( $ form ) ) { $ form = $ this -> formElementManager -> get ( $ form , $ options ) ; } $ params = $ params ? : clone $ this -> getController ( ) -> getRequest ( ) -> getQuery ( ) ; $ hydrator = $ form -> getHydrator ( ) ; $ data = $ hydrator -> extract ( $ params ) ; $ form -> setData ( $ data ) ; $ hydrator -> hydrate ( $ data , $ params ) ; return $ form ; }
5259	public static function all ( $ query = [ ] ) { if ( $ query instanceof QueryBuilder ) { $ query = $ query -> build ( ) ; } $ collection = collect ( ) ; static :: map ( $ query , function ( ElasticsearchModel $ document ) use ( $ collection ) { $ collection -> put ( $ document -> getId ( ) , $ document ) ; } ) ; return $ collection ; }
11783	public function add ( $ title , $ description , $ pageUrl , $ iconUrl , $ comment = '' ) { $ params = [ 'title' => $ title , 'description' => $ description , 'page_url' => $ pageUrl , 'icon_url' => $ iconUrl , ] ; if ( $ comment !== '' ) { $ params [ 'comment' ] = $ comment ; } return $ this -> parseJSON ( 'json' , [ self :: API_ADD , $ params ] ) ; }
8281	public function onTwigRegistered ( & $ twig ) { $ twig -> getLoader ( ) -> addPath ( $ this -> pluginDir . '/theme' ) ; $ this_instance = $ this ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_token' , function ( $ action = null ) use ( & $ this_instance ) { return $ this_instance -> csrf -> getToken ( $ action ) ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; $ twig -> addFunction ( new \ Twig_SimpleFunction ( 'csrf_field' , function ( $ action = null ) use ( & $ this_instance ) { return '<input type="hidden" name="csrf_token" value="' . $ this_instance -> csrf -> getToken ( $ action ) . '">' ; } , array ( 'is_safe' => array ( 'html' ) ) ) ) ; }
4921	public function region ( $ region , $ reset = false ) { $ this -> currentRegion = $ region ; if ( $ reset ) { $ this -> matrix [ $ this -> currentRegion ] = [ ] ; } return $ this ; }
2232	protected function getDatalistOptions ( ) { $ strGroups = '' ; if ( ! $ this -> User -> isAdmin ) { if ( empty ( $ this -> User -> amg ) || ! \ is_array ( $ this -> User -> amg ) ) { header ( 'Content-type: application/json' ) ; die ( json_encode ( array ( ) ) ) ; } $ arrGroups = array ( ) ; foreach ( $ this -> User -> amg as $ intGroup ) { $ arrGroups [ ] = '%"' . ( int ) $ intGroup . '"%' ; } $ strGroups = " AND (groups LIKE '" . implode ( "' OR GROUPS LIKE '" , $ arrGroups ) . "')" ; } $ arrUsers = array ( ) ; $ time = Date :: floorToMinute ( ) ; $ objUsers = $ this -> Database -> prepare ( "SELECT username FROM tl_member WHERE username LIKE ?$strGroups AND login='1' AND disable!='1' AND (start='' OR start<='$time') AND (stop='' OR stop>'" . ( $ time + 60 ) . "') ORDER BY username" ) -> limit ( 10 ) -> execute ( str_replace ( '%' , '' , Input :: post ( 'value' ) ) . '%' ) ; if ( $ objUsers -> numRows ) { $ arrUsers = $ objUsers -> fetchEach ( 'username' ) ; } header ( 'Content-type: application/json' ) ; die ( json_encode ( $ arrUsers ) ) ; }
7710	function UpdateParent ( $ Cascading = false ) { if ( $ this -> Parent ) { $ this -> Parent -> ReplaceSrc ( $ this -> Txt ) ; if ( $ Cascading ) $ this -> Parent -> UpdateParent ( $ Cascading ) ; } }
4333	private static function buildAttribBoolVal ( $ key , $ value = true ) { if ( $ key == 'autocomplete' ) { $ value = $ value ? 'on' : 'off' ; } elseif ( $ key == 'spellcheck' ) { $ value = $ value ? 'true' : 'false' ; } elseif ( $ key == 'translate' ) { $ value = $ value ? 'yes' : 'no' ; } elseif ( $ value ) { $ value = $ key ; } else { $ value = null ; } return $ value ; }
2302	public static function getDcaPickerWizard ( $ extras , $ table , $ field , $ inputName ) { $ context = 'link' ; $ extras = \ is_array ( $ extras ) ? $ extras : array ( ) ; $ providers = ( isset ( $ extras [ 'providers' ] ) && \ is_array ( $ extras [ 'providers' ] ) ) ? $ extras [ 'providers' ] : null ; if ( isset ( $ extras [ 'context' ] ) ) { $ context = $ extras [ 'context' ] ; unset ( $ extras [ 'context' ] ) ; } $ factory = System :: getContainer ( ) -> get ( 'contao.picker.builder' ) ; if ( ! $ factory -> supportsContext ( $ context , $ providers ) ) { return '' ; } return ' <a href="' . ampersand ( $ factory -> getUrl ( $ context , $ extras ) ) . '" title="' . StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '" id="pp_' . $ inputName . '">' . Image :: getHtml ( ( \ is_array ( $ extras ) && isset ( $ extras [ 'icon' ] ) ? $ extras [ 'icon' ] : 'pickpage.svg' ) , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'pagepicker' ] ) . '</a> <script> $("pp_' . $ inputName . '").addEvent("click", function(e) { e.preventDefault(); Backend.openModalSelector({ "id": "tl_listing", "title": ' . json_encode ( $ GLOBALS [ 'TL_DCA' ] [ $ table ] [ 'fields' ] [ $ field ] [ 'label' ] [ 0 ] ) . ', "url": this.href + "&value=" + document.getElementById("ctrl_' . $ inputName . '").value, "callback": function(picker, value) { $("ctrl_' . $ inputName . '").value = value.join(","); }.bind(this) }); }); </script>' ; }
6004	public function setCategories ( array $ categories ) { $ this -> categories = [ ] ; foreach ( $ categories as $ item ) { $ this -> addCategoryResponse ( $ item ) ; } return $ this ; }
10198	private function writeRows ( XMLWriter $ objWriter , Worksheet $ sheet ) { $ numberRowsRepeated = self :: NUMBER_ROWS_REPEATED_MAX ; $ span_row = 0 ; $ rows = $ sheet -> getRowIterator ( ) ; while ( $ rows -> valid ( ) ) { -- $ numberRowsRepeated ; $ row = $ rows -> current ( ) ; if ( $ row -> getCellIterator ( ) -> valid ( ) ) { if ( $ span_row ) { $ objWriter -> startElement ( 'table:table-row' ) ; if ( $ span_row > 1 ) { $ objWriter -> writeAttribute ( 'table:number-rows-repeated' , $ span_row ) ; } $ objWriter -> startElement ( 'table:table-cell' ) ; $ objWriter -> writeAttribute ( 'table:number-columns-repeated' , self :: NUMBER_COLS_REPEATED_MAX ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ span_row = 0 ; } $ objWriter -> startElement ( 'table:table-row' ) ; $ this -> writeCells ( $ objWriter , $ row ) ; $ objWriter -> endElement ( ) ; } else { ++ $ span_row ; } $ rows -> next ( ) ; } }
7204	public function getDiscount ( bool $ ati = false ) : float { return $ ati ? $ this -> ati ( $ this -> discount ) : $ this -> discount ; }
992	public static function visitUsingRules ( Schema $ schema , TypeInfo $ typeInfo , DocumentNode $ documentNode , array $ rules ) { $ context = new ValidationContext ( $ schema , $ documentNode , $ typeInfo ) ; $ visitors = [ ] ; foreach ( $ rules as $ rule ) { $ visitors [ ] = $ rule -> getVisitor ( $ context ) ; } Visitor :: visit ( $ documentNode , Visitor :: visitWithTypeInfo ( $ typeInfo , Visitor :: visitInParallel ( $ visitors ) ) ) ; return $ context -> getErrors ( ) ; }
12161	public function getIsChildless ( ) { if ( empty ( $ this -> collectorItem ) || empty ( $ this -> collectorItem -> children ) ) { return true ; } return false ; }
11348	public function getField ( $ name ) { foreach ( $ this -> fields as $ field ) { if ( $ field -> getName ( ) == $ name ) return $ field ; } throw new FieldNotFoundException ( $ name ) ; }
2447	public function notifyOfReply ( Contao \ DataContainer $ dc ) { if ( ! $ dc -> activeRecord || ! $ dc -> activeRecord -> addReply || $ dc -> activeRecord -> notifyReply ) { return ; } $ objNotify = Contao \ CommentsNotifyModel :: findActiveBySourceAndParent ( $ dc -> activeRecord -> source , $ dc -> activeRecord -> parent ) ; if ( $ objNotify !== null ) { while ( $ objNotify -> next ( ) ) { $ strUrl = Contao \ Idna :: decode ( Contao \ Environment :: get ( 'base' ) ) . $ objNotify -> url ; $ objEmail = new Contao \ Email ( ) ; $ objEmail -> from = $ GLOBALS [ 'TL_ADMIN_EMAIL' ] ; $ objEmail -> fromName = $ GLOBALS [ 'TL_ADMIN_NAME' ] ; $ objEmail -> subject = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplySubject' ] , Contao \ Idna :: decode ( Contao \ Environment :: get ( 'host' ) ) ) ; $ objEmail -> text = sprintf ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'com_notifyReplyMessage' ] , $ objNotify -> name , $ strUrl . '#c' . $ dc -> id , $ strUrl . '?token=' . $ objNotify -> tokenRemove ) ; $ objEmail -> sendTo ( $ objNotify -> email ) ; } } $ this -> Database -> prepare ( "UPDATE tl_comments SET notifiedReply='1' WHERE id=?" ) -> execute ( $ dc -> id ) ; }
208	public static function select ( $ prompt , $ options = [ ] ) { top : static :: stdout ( "$prompt [" . implode ( ',' , array_keys ( $ options ) ) . ',?]: ' ) ; $ input = static :: stdin ( ) ; if ( $ input === '?' ) { foreach ( $ options as $ key => $ value ) { static :: output ( " $key - $value" ) ; } static :: output ( ' ? - Show help' ) ; goto top ; } elseif ( ! array_key_exists ( $ input , $ options ) ) { goto top ; } return $ input ; }
798	public function insertAt ( $ index , Token $ token ) { $ this -> setSize ( $ this -> getSize ( ) + 1 ) ; for ( $ i = $ this -> getSize ( ) - 1 ; $ i > $ index ; -- $ i ) { $ this [ $ i ] = isset ( $ this [ $ i - 1 ] ) ? $ this [ $ i - 1 ] : new Token ( ) ; } $ this [ $ index ] = $ token ; }
11702	public function add ( $ sName , $ mType , $ sLabel = null , $ mValue = null , $ mOptions = null ) { if ( $ mType instanceof Container ) { $ this -> _aElement [ $ sName ] = $ mType ; } else if ( $ mType === 'text' || $ mType === 'submit' || $ mType === 'password' || $ mType === 'file' || $ mType === 'tel' || $ mType === 'url' || $ mType === 'email' || $ mType === 'search' || $ mType === 'date' || $ mType === 'time' || $ mType === 'datetime' || $ mType === 'month' || $ mType === 'week' || $ mType === 'number' || $ mType === 'range' || $ mType === 'color' || $ mType === 'hidden' ) { $ this -> _aElement [ $ sName ] = new Input ( $ sName , $ mType , $ sLabel , $ mValue ) ; } elseif ( $ mType === 'textarea' ) { $ this -> _aElement [ $ sName ] = new Textarea ( $ sName , $ sLabel , $ mValue ) ; } else if ( $ mType === 'select' ) { $ this -> _aElement [ $ sName ] = new Select ( $ sName , $ mOptions , $ sLabel , $ mValue ) ; } else if ( $ mType === 'label' ) { $ this -> _aElement [ $ sName ] = new Label ( $ sName ) ; } else if ( $ mType === 'list_checkbox' ) { $ i = 0 ; $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Label ( $ sLabel ) ; foreach ( $ mValue as $ mKey => $ sValue ) { $ this -> _aElement [ $ sName . '_' . $ i ++ ] = new Checkbox ( $ sName , $ sValue , $ mKey , $ mOptions ) ; } } else if ( $ mType === 'checkbox' ) { $ this -> _aElement [ $ sName ] = new Checkbox ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } else if ( $ mType === 'radio' ) { $ this -> _aElement [ $ sName . rand ( 100000 , 999999 ) ] = new Radio ( $ sName , $ sLabel , $ mValue , $ mOptions ) ; } return $ this ; }
9969	public function getDataValidation ( $ pCellCoordinate ) { if ( isset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ) { return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; } $ this -> dataValidationCollection [ $ pCellCoordinate ] = new DataValidation ( ) ; return $ this -> dataValidationCollection [ $ pCellCoordinate ] ; }
8775	public function admin ( $ data = null , $ secure = false ) { $ data = ( ! is_null ( $ data ) ) ? $ this -> url . '/' . ADMIN_FOLDER . '/' . $ data : $ this -> url . '/' . ADMIN_FOLDER . '/' ; return $ this -> getUrl ( $ data , $ secure ) ; }
11048	function add_system_var ( & $ datatree , $ index , $ last , $ key ) { $ datatree -> _key = $ key ; $ datatree -> _index = $ index ; $ datatree -> _rank = $ index + 1 ; $ datatree -> _odd = $ datatree -> _not_even = ( 1 == $ datatree -> _rank % 2 ) ; $ datatree -> _even = $ datatree -> _not_odd = ( 0 == $ datatree -> _rank % 2 ) ; $ datatree -> _first = ( 0 == $ index ) ; $ datatree -> _middle = ! $ datatree -> _first && ! $ last ; $ datatree -> _last = $ last ; $ datatree -> _not_first = ! $ datatree -> _first ; $ datatree -> _not_last = ! $ last ; $ datatree -> _not_middle = ! $ datatree -> _middle ; }
8189	final protected function getContext ( $ context , $ item , $ ignoreStrictCheck = false ) { if ( ! array_key_exists ( $ item , $ context ) ) { if ( $ ignoreStrictCheck || ! $ this -> env -> isStrictVariables ( ) ) { return ; } throw new Twig_Error_Runtime ( sprintf ( 'Variable "%s" does not exist.' , $ item ) , - 1 , $ this -> getSourceContext ( ) ) ; } return $ context [ $ item ] ; }
563	public function renderSummary ( ) { $ count = $ this -> dataProvider -> getCount ( ) ; if ( $ count <= 0 ) { return '' ; } $ summaryOptions = $ this -> summaryOptions ; $ tag = ArrayHelper :: remove ( $ summaryOptions , 'tag' , 'div' ) ; if ( ( $ pagination = $ this -> dataProvider -> getPagination ( ) ) !== false ) { $ totalCount = $ this -> dataProvider -> getTotalCount ( ) ; $ begin = $ pagination -> getPage ( ) * $ pagination -> pageSize + 1 ; $ end = $ begin + $ count - 1 ; if ( $ begin > $ end ) { $ begin = $ end ; } $ page = $ pagination -> getPage ( ) + 1 ; $ pageCount = $ pagination -> pageCount ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Showing <b>{begin, number}-{end, number}</b> of <b>{totalCount, number}</b> {totalCount, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } else { $ begin = $ page = $ pageCount = 1 ; $ end = $ totalCount = $ count ; if ( ( $ summaryContent = $ this -> summary ) === null ) { return Html :: tag ( $ tag , Yii :: t ( 'yii' , 'Total <b>{count, number}</b> {count, plural, one{item} other{items}}.' , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] ) , $ summaryOptions ) ; } } return Yii :: $ app -> getI18n ( ) -> format ( $ summaryContent , [ 'begin' => $ begin , 'end' => $ end , 'count' => $ count , 'totalCount' => $ totalCount , 'page' => $ page , 'pageCount' => $ pageCount , ] , Yii :: $ app -> language ) ; }
11794	public function setBcc ( $ mail = '' , $ name = null ) { $ this -> bcc = Helper :: deduplicate ( array_merge ( $ this -> bcc , call_user_func_array ( array ( '\MimeMailer\Helper' , 'checkPeopleArgs' ) , func_get_args ( ) ) ) ) ; return $ this ; }
4156	function every ( $ interval , Job $ job ) { $ expression = new SimpleExpression ( $ interval ) ; $ this -> add ( $ expression , $ job ) ; return $ this ; }
10915	protected function findController ( $ object ) { $ urlargs = $ this -> arguments ; $ arg = $ urlargs -> shift ( ) ; $ controller = $ arg ; if ( ( $ pos = strpos ( $ controller , '.' ) ) !== false ) $ controller = substr ( $ controller , 0 , $ pos ) ; if ( ! method_exists ( $ object , $ controller ) ) { if ( method_exists ( $ object , "index" ) ) { if ( $ controller !== null ) $ urlargs -> unshift ( $ arg ) ; $ controller = "index" ; } else throw new HTTPError ( 404 , "Unknown controller: " . $ controller ) ; } return $ controller ; }
9312	public function indexAction ( ) { if ( ! $ this -> isConsoleRequest ( ) ) { throw new \ RuntimeException ( 'You can only use this action from a console!' ) ; } $ console = $ this -> getConsole ( ) ; $ this -> printConsoleBanner ( $ console ) ; $ console -> writeLine ( 'TODO Finish indexAction!' , ConsoleColor :: LIGHT_RED ) ; }
10377	protected static function prepare_files ( $ type ) { $ params [ 'type' ] = $ type ; $ params [ 'routes' ] = self :: get_routes_to_folder ( $ type ) ; self :: get_processed_files ( ) ; foreach ( self :: $ data [ $ type ] as $ id => $ file ) { $ path = self :: get_path_from_url ( $ file [ 'url' ] ) ; $ params [ 'files' ] [ $ id ] = basename ( $ file [ 'url' ] ) ; $ params [ 'urls' ] [ $ id ] = $ file [ 'url' ] ; $ params [ 'paths' ] [ $ id ] = $ path ; if ( is_file ( $ path ) && self :: is_modified_file ( $ path ) ) { unset ( $ params [ 'urls' ] [ $ id ] ) ; continue ; } $ path = $ params [ 'routes' ] [ 'path' ] . $ params [ 'files' ] [ $ id ] ; if ( is_file ( $ path ) ) { if ( self :: is_modified_hash ( $ file [ 'url' ] , $ path ) ) { continue ; } $ params [ 'paths' ] [ $ id ] = $ path ; } elseif ( self :: is_external_url ( $ file [ 'url' ] ) ) { continue ; } unset ( $ params [ 'urls' ] [ $ id ] ) ; } return $ params ; }
12889	public function getIdentity ( $ view ) { if ( ! isset ( $ view -> assetBundles [ $ this -> identityAssetBundle ] ) ) { return false ; } return Yii :: $ app -> assetManager -> getBundle ( $ this -> identityAssetBundle ) ; }
5200	public function setOptions ( array $ options ) { $ this -> validateOptions ( $ options ) ; foreach ( $ options as $ option => $ value ) $ this -> $ option = $ value ; return $ this ; }
6915	public function addAttachment ( AttachmentInterface $ attachment ) { if ( ! $ this -> attachments -> contains ( $ attachment ) ) { $ this -> attachments -> add ( $ attachment ) ; } return $ this ; }
9707	private function writeDefinedNameBiff8 ( $ name , $ formulaData , $ sheetIndex = 0 , $ isBuiltIn = false ) { $ record = 0x0018 ; $ options = $ isBuiltIn ? 0x20 : 0x00 ; $ nlen = StringHelper :: countCharacters ( $ name ) ; $ name = substr ( StringHelper :: UTF8toBIFF8UnicodeLong ( $ name ) , 2 ) ; $ sz = strlen ( $ formulaData ) ; $ data = pack ( 'vCCvvvCCCC' , $ options , 0 , $ nlen , $ sz , 0 , $ sheetIndex , 0 , 0 , 0 , 0 ) . $ name . $ formulaData ; $ length = strlen ( $ data ) ; $ header = pack ( 'vv' , $ record , $ length ) ; return $ header . $ data ; }
9204	public static function get ( $ item ) { $ item = strtoupper ( $ item ) ; $ config = json_decode ( file_get_contents ( dirname ( __FILE__ ) . "/Config.json" ) , true ) ; if ( ! isset ( $ config [ $ item ] ) ) { throw new InvalidConfigItemException ( "Invalid Endpoint Requested!" ) ; } return $ config [ $ item ] ; }
11422	public function get ( $ openId , $ lang = 'zh_CN' ) { $ params = [ 'openid' => $ openId , 'lang' => $ lang , ] ; return $ this -> parseJSON ( 'get' , [ self :: API_GET , $ params ] ) ; }
10203	public function setVertical ( $ pValue ) { if ( $ pValue == '' ) { $ pValue = self :: VERTICAL_BOTTOM ; } if ( $ this -> isSupervisor ) { $ styleArray = $ this -> getStyleArray ( [ 'vertical' => $ pValue ] ) ; $ this -> getActiveSheet ( ) -> getStyle ( $ this -> getSelectedCells ( ) ) -> applyFromArray ( $ styleArray ) ; } else { $ this -> vertical = $ pValue ; } return $ this ; }
12458	private function createCommentForm ( CommentFront $ model , $ entity ) { $ form = $ this -> createForm ( 'BlogBundle\Form\CommentFrontType' , $ model , array ( 'action' => $ this -> generateUrl ( 'blog_blog_comment' , array ( 'post' => $ entity -> getId ( ) ) ) , 'method' => 'POST' , 'attr' => array ( 'id' => 'comment-form' , 'class' => 'comment-form' ) ) ) ; return $ form ; }
8003	public static function forCurrentSystem ( $ code = self :: CODE_FOR_SYSTEM , Exception $ previous = null ) { $ message = self :: DEFAULT_MESSAGE . self :: MESSAGE_EXTENSION_FOR_SYSTEM ; return new static ( $ message , $ code , $ previous ) ; }
11564	protected function processWeakWord ( $ word ) { $ index = 0 ; $ text = ' ' . $ this -> text . ' ' ; while ( TRUE ) { $ index = mb_strpos ( $ text , ' ' . $ word . ' ' ) ; if ( $ index !== FALSE ) { $ text = mb_substr ( $ text , 0 , $ index + 1 ) . $ word . '&nbsp;' . mb_substr ( $ text , $ index + 1 + mb_strlen ( $ word ) + 1 ) ; $ index += 1 + mb_strlen ( $ word ) + 6 ; } else { break ; } } $ this -> text = mb_substr ( $ text , 1 , mb_strlen ( $ text ) - 2 ) ; }
45	public function dispatchPackageEvent ( $ eventName , $ devMode , PolicyInterface $ policy , Pool $ pool , CompositeRepository $ installedRepo , Request $ request , array $ operations , OperationInterface $ operation ) { return $ this -> doDispatch ( new PackageEvent ( $ eventName , $ this -> composer , $ this -> io , $ devMode , $ policy , $ pool , $ installedRepo , $ request , $ operations , $ operation ) ) ; }
7623	public function signRequestHeaders ( $ httpVerb = 'GET' , $ path = '/' , $ query = array ( ) , $ headers = null , $ forTableStorage = false , $ resourceType = Storage :: RESOURCE_UNKNOWN , $ requiredPermission = CredentialsAbstract :: PERMISSION_READ , $ rawData = null ) { return $ headers ; }
6569	public function unsetData ( ) : void { foreach ( array_keys ( $ this -> data ) as $ var ) { if ( ! in_array ( $ var , self :: ALL_HEADERS ) ) { unset ( $ this -> data [ $ var ] ) ; } } }
3046	protected function saveToolStates ( ) { $ toolStateParameter = 'toolStates' ; if ( $ this -> hasRequestParameter ( $ toolStateParameter ) ) { $ param = $ this -> getRawRequestParameter ( $ toolStateParameter ) ; if ( $ param ) { $ toolStates = json_decode ( $ param , true ) ; if ( count ( $ toolStates ) > 0 ) { array_walk ( $ toolStates , function ( & $ toolState ) { $ toolState = json_encode ( $ toolState ) ; } ) ; $ this -> getRunnerService ( ) -> setToolsStates ( $ this -> getServiceContext ( ) , $ toolStates ) ; return true ; } } } return false ; }
3894	private function getFilteredAttributeNames ( $ metaModelId , $ allowedTypes = array ( ) ) { $ attributeNames = array ( ) ; if ( $ metaModel = $ this -> factory -> getMetaModel ( $ this -> factory -> translateIdToMetaModelName ( $ metaModelId ) ) ) { foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( empty ( $ allowedTypes ) || in_array ( $ attribute -> get ( 'type' ) , $ allowedTypes ) ) { $ attributeNames [ $ attribute -> getColName ( ) ] = sprintf ( '%s [%s]' , $ attribute -> getName ( ) , $ attribute -> getColName ( ) ) ; } } } return $ attributeNames ; }
7444	public function createAction ( ) { $ group = new Group ( ) ; $ form = $ this -> createForm ( GroupType :: class , $ group ) ; $ form -> bindRequest ( $ this -> getRequest ( ) ) ; if ( $ form -> isValid ( ) ) { $ em = $ this -> getDoctrine ( ) -> getEntityManager ( ) ; $ em -> persist ( $ group ) ; $ em -> flush ( ) ; $ this -> get ( 'session' ) -> getFlashBag ( ) -> set ( 'success' , 'The group has been created.' ) ; return $ this -> redirect ( $ this -> generateUrl ( 'orkestra_group_show' , array ( 'id' => $ group -> getId ( ) ) ) ) ; } return array ( 'group' => $ group , 'form' => $ form -> createView ( ) ) ; }
6985	protected function createSaleContext ( SaleInterface $ sale ) : ContextInterface { $ context = $ this -> createContext ( ) ; if ( null !== $ group = $ sale -> getCustomerGroup ( ) ) { $ context -> setCustomerGroup ( $ group ) -> setBusiness ( $ group -> isBusiness ( ) ) ; } if ( null !== $ address = $ sale -> getInvoiceAddress ( ) ) { $ context -> setInvoiceCountry ( $ address -> getCountry ( ) ) ; } $ address = $ sale -> isSameAddress ( ) ? $ sale -> getInvoiceAddress ( ) : $ sale -> getDeliveryAddress ( ) ; if ( null !== $ address ) { $ context -> setDeliveryCountry ( $ address -> getCountry ( ) ) ; } if ( null !== $ currency = $ sale -> getCurrency ( ) ) { $ context -> setCurrency ( $ currency ) ; } if ( null !== $ mode = $ sale -> getVatDisplayMode ( ) ) { $ context -> setVatDisplayMode ( $ mode ) ; } if ( $ sale instanceof OrderInterface && null !== $ date = $ sale -> getCreatedAt ( ) ) { $ context -> setDate ( $ date ) ; } $ context -> setTaxExempt ( $ sale -> isTaxExempt ( ) ) ; if ( null !== $ customer = $ sale -> getCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ customer ) ; } elseif ( $ this -> customerProvider -> hasCustomer ( ) ) { $ this -> fillFromCustomer ( $ context , $ this -> customerProvider -> getCustomer ( ) ) ; } $ this -> finalize ( $ context ) ; $ sale -> setContext ( $ context ) ; return $ context ; }
1984	public function getAllOptions ( ) : array { $ this -> loadOptions ( ) ; $ event = new ImageSizesEvent ( $ this -> options ) ; $ this -> eventDispatcher -> dispatch ( ContaoCoreEvents :: IMAGE_SIZES_ALL , $ event ) ; return $ event -> getImageSizes ( ) ; }
1601	public function injectRobots ( ) { $ headers = \ Craft :: $ app -> getResponse ( ) -> getHeaders ( ) ; if ( \ Craft :: $ app -> config -> general -> devMode ) { $ headers -> set ( 'x-robots-tag' , 'none, noimageindex' ) ; return ; } list ( $ field , $ element ) = $ this -> _getElementAndSeoFields ( ) ; $ robots = $ field -> robots ; if ( $ robots !== null ) $ headers -> set ( 'x-robots-tag' , $ robots ) ; if ( isset ( $ element -> expiryDate ) ) $ expiry = $ element -> expiryDate -> format ( \ DATE_RFC850 ) ; else $ expiry = null ; if ( $ expiry ) $ headers -> add ( 'x-robots-tag' , 'unavailable_after: ' . $ expiry ) ; }
11426	public function blacklist ( $ beginOpenid = null ) { $ params = [ 'begin_openid' => $ beginOpenid ] ; return $ this -> parseJSON ( 'json' , [ self :: API_GET_BLACK_LIST , $ params ] ) ; }
7716	static function FindElement ( & $ TxtOrObj , $ Tag , $ PosBeg , $ Forward = true ) { $ XmlLoc = clsTbsXmlLoc :: FindStartTag ( $ TxtOrObj , $ Tag , $ PosBeg , $ Forward ) ; if ( $ XmlLoc === false ) return false ; $ XmlLoc -> FindEndTag ( ) ; return $ XmlLoc ; }
10345	protected function applyStepping ( $ range , $ step ) { if ( $ step === false || $ step === 1 ) { return $ range ; } foreach ( $ range as $ value => $ tmp ) { if ( ( $ value % $ step ) !== 0 ) { unset ( $ range [ $ value ] ) ; } } return array_values ( $ range ) ; }
7162	private function buildSaleTaxesViews ( Model \ SaleInterface $ sale ) { if ( ! $ this -> options [ 'taxes_view' ] ) { return ; } $ amounts = $ this -> amountCalculator -> calculateSale ( $ sale ) ; foreach ( $ amounts -> getTaxAdjustments ( ) as $ tax ) { $ this -> view -> addTax ( new TaxView ( $ tax -> getName ( ) , $ this -> formatter -> currency ( $ tax -> getAmount ( ) ) ) ) ; } }
988	public function activate ( ) { if ( ! $ this -> chargeId ) { throw new Exception ( 'Can not activate plan without a charge ID.' ) ; } $ this -> response = $ this -> api -> rest ( 'POST' , "/admin/{$this->plan->typeAsString(true)}/{$this->chargeId}/activate.json" ) -> body -> { $ this -> plan -> typeAsString ( ) } ; return $ this -> response ; }
2931	public function setKeys ( $ data ) { foreach ( $ data as $ setter ) { if ( array_key_exists ( 'key' , $ setter ) ) { $ key = $ this -> formatter -> formatKey ( $ setter [ 'key' ] ) ; $ value = array_key_exists ( 'value' , $ setter ) ? $ setter [ 'value' ] : null ; $ comment = array_key_exists ( 'comment' , $ setter ) ? $ setter [ 'comment' ] : null ; $ export = array_key_exists ( 'export' , $ setter ) ? $ setter [ 'export' ] : false ; if ( ! is_file ( $ this -> filePath ) || ! $ this -> keyExists ( $ key ) ) { $ this -> writer -> appendSetter ( $ key , $ value , $ comment , $ export ) ; } else { $ oldInfo = $ this -> getKeys ( [ $ key ] ) ; $ comment = is_null ( $ comment ) ? $ oldInfo [ $ key ] [ 'comment' ] : $ comment ; $ this -> writer -> updateSetter ( $ key , $ value , $ comment , $ export ) ; } } } return $ this ; }
3181	public function getMaximumRemainingTime ( ) { if ( ( $ timeLimits = $ this -> getSource ( ) -> getTimeLimits ( ) ) !== null && ( $ maxTime = $ timeLimits -> getMaxTime ( ) ) !== null ) { return $ this -> getRemainingTimeFrom ( $ maxTime ) ; } return false ; }
7600	public function render ( array $ aButtons , array $ aButtonGroupOptions = null ) { if ( empty ( $ aButtonGroupOptions [ 'attributes' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] = array ( 'class' => 'btn-group' ) ; } else { if ( ! is_array ( $ aButtonGroupOptions [ 'attributes' ] ) ) { throw new LogicException ( '"attributes" option expects an array, "' . gettype ( $ aButtonGroupOptions [ 'attributes' ] ) . '" given' ) ; } if ( empty ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] = 'btn-group' ; } elseif ( ! preg_match ( '/(\s|^)(?:btn-group|btn-group-vertical)(\s|$)/' , $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] ) ) { $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] .= ' btn-group' ; } } return sprintf ( static :: $ buttonGroupContainerFormat , $ this -> createAttributesString ( $ aButtonGroupOptions [ 'attributes' ] ) , $ this -> renderButtons ( $ aButtons , strpos ( $ aButtonGroupOptions [ 'attributes' ] [ 'class' ] , 'btn-group-justified' ) !== false ) ) ; }
1060	public static function findDangerousChanges ( Schema $ oldSchema , Schema $ newSchema ) { return array_merge ( self :: findArgChanges ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] , self :: findValuesAddedToEnums ( $ oldSchema , $ newSchema ) , self :: findInterfacesAddedToObjectTypes ( $ oldSchema , $ newSchema ) , self :: findTypesAddedToUnions ( $ oldSchema , $ newSchema ) , self :: findFieldsThatChangedTypeOnInputObjectTypes ( $ oldSchema , $ newSchema ) [ 'dangerousChanges' ] ) ; }
12641	public function add ( $ key , $ value ) { try { $ this -> getRecursive ( $ key , $ this -> data ) ; } catch ( ElementNotFoundException $ e ) { $ this -> set ( $ key , $ value ) ; } }
849	public function getPrevTokenOfKind ( $ index , array $ tokens = [ ] , $ caseSensitive = true ) { return $ this -> getTokenOfKindSibling ( $ index , - 1 , $ tokens , $ caseSensitive ) ; }
344	public static function mailto ( $ text , $ email = null , $ options = [ ] ) { $ options [ 'href' ] = 'mailto:' . ( $ email === null ? $ text : $ email ) ; return static :: tag ( 'a' , $ text , $ options ) ; }
6683	public function sendSuccessResponse ( $ data ) { \ Yii :: $ app -> response -> format = Response :: FORMAT_JSON ; \ Yii :: $ app -> response -> setStatusCode ( 200 , $ this -> httpStatuses -> getReasonPhrase ( 200 ) ) ; return [ 'status' => 'success' , 'data' => $ data ] ; }
6170	protected function onAddError ( \ Exception $ e ) { $ this -> writeProgressWithColor ( 'fg-red,bold' , 'E' ) ; $ this -> exception = $ e ; $ this -> lastTestFailed = true ; $ this -> flawless = false ; }
607	private function tokenizeOperator ( & $ length ) { if ( ! $ this -> isOperator ( $ length , $ content ) ) { return false ; } $ this -> addTokenFromBuffer ( ) ; switch ( $ this -> substring ( $ length ) ) { case '(' : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_PARENTHESIS ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; case ')' : $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => ')' , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; case ';' : if ( ! $ this -> _currentToken -> getHasChildren ( ) ) { break ; } $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; $ this -> _tokenStack -> pop ( ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_STATEMENT ] ) ; $ this -> _tokenStack -> push ( $ this -> _currentToken [ - 1 ] ) ; $ this -> _currentToken = $ this -> _tokenStack -> top ( ) ; break ; default : $ this -> _currentToken [ ] = new SqlToken ( [ 'type' => SqlToken :: TYPE_OPERATOR , 'content' => is_string ( $ content ) ? $ content : $ this -> substring ( $ length ) , 'startOffset' => $ this -> offset , 'endOffset' => $ this -> offset + $ length , ] ) ; break ; } return true ; }
3770	protected function internalCreateRenderSetting ( IMetaModel $ metaModel , $ settingId ) { $ row = $ this -> database -> createQueryBuilder ( ) -> select ( '*' ) -> from ( 'tl_metamodel_rendersettings' ) -> where ( 'pid=:pid' ) -> andWhere ( 'id=:id' ) -> setParameter ( 'pid' , $ metaModel -> get ( 'id' ) ) -> setParameter ( 'id' , $ settingId ? : 0 ) -> setMaxResults ( 1 ) -> execute ( ) -> fetch ( \ PDO :: FETCH_ASSOC ) ; if ( ! $ row ) { $ row = [ ] ; } $ renderSetting = new Collection ( $ metaModel , $ row , $ this -> eventDispatcher , $ this -> filterFactory , $ this -> filterUrlBuilder ) ; if ( $ renderSetting -> get ( 'id' ) ) { $ this -> collectAttributeSettings ( $ metaModel , $ renderSetting ) ; } return $ renderSetting ; }
12802	public function getPage ( $ page = null ) { if ( is_null ( $ page ) ) { $ page = $ this -> page ; } list ( $ offset , $ size ) = $ this -> getLimts ( $ page ) ; $ this -> manager -> limit ( $ offset , $ size ) ; return $ this -> manager -> values ( ) ; }
1544	public function encodes ( string ... $ mediaTypes ) : bool { $ encoding = $ this -> getEncodingMediaType ( ) ; return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ encoding ) { return $ encoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
12235	public function insertXML ( $ xml , $ mode = 'append' ) { $ tmp = dom_import_simplexml ( $ this ) ; $ fragment = $ tmp -> ownerDocument -> createDocumentFragment ( ) ; $ use_errors = libxml_use_internal_errors ( true ) ; if ( ! $ fragment -> appendXML ( $ xml ) ) { libxml_use_internal_errors ( $ use_errors ) ; throw new InvalidArgumentException ( libxml_get_last_error ( ) -> message ) ; } libxml_use_internal_errors ( $ use_errors ) ; $ this -> insertNode ( $ tmp , $ fragment , $ mode ) ; return $ this ; }
4989	public function enableForm ( $ key = null ) { if ( null === $ key ) { $ this -> activeForms = array_keys ( $ this -> forms ) ; return $ this ; } if ( ! is_array ( $ key ) ) { $ key = array ( $ key ) ; } foreach ( $ key as $ k ) { if ( false !== strpos ( $ k , '.' ) ) { list ( $ childKey , $ childForm ) = explode ( '.' , $ k , 2 ) ; $ child = $ this -> getForm ( $ childKey ) ; $ child -> enableForm ( $ childForm ) ; } else { if ( isset ( $ this -> forms [ $ k ] ) && ! in_array ( $ k , $ this -> activeForms ) ) { $ this -> activeForms [ ] = $ k ; } } } return $ this ; }
9501	public function watch ( WatcherInterface $ watcher ) { $ events = $ this -> getEvents ( ) ; $ watcher -> watch ( $ this -> getTrackedPaths ( ) , $ events , [ $ this , 'runPeridot' ] ) ; }
10308	private function setGlowSize ( $ size ) { if ( $ size !== null ) { $ this -> glowProperties [ 'size' ] = $ this -> getExcelPointsWidth ( $ size ) ; } return $ this ; }
11575	public function actionRegister ( ) { if ( ! $ this -> module -> enableRegistration ) { throw new NotFoundHttpException ; } $ model = \ Yii :: createObject ( RegistrationForm :: className ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> register ( ) ) { return $ this -> render ( '/message' , [ 'title' => \ Yii :: t ( 'user' , 'Your account has been created' ) , 'module' => $ this -> module , ] ) ; } return $ this -> render ( 'register' , [ 'model' => $ model , 'module' => $ this -> module , ] ) ; }
12222	private function prepareErrorBody ( Exception $ exception ) { $ body = [ 'errors' => [ ] ] ; if ( ! empty ( $ statusCode = $ exception -> getStatusCode ( ) ) ) { $ body [ 'errors' ] [ 'statusCode' ] = $ statusCode ; } if ( ! empty ( $ description = $ exception -> getDescription ( ) ) ) { $ body [ 'errors' ] [ 'description' ] = $ description ; } if ( ! empty ( $ message = $ exception -> getMessage ( ) ) ) { $ body [ 'errors' ] [ 'message' ] = $ message ; } if ( ! empty ( $ code = $ exception -> getCode ( ) ) ) { $ body [ 'errors' ] [ 'code' ] = $ code ; } if ( ! empty ( $ link = $ exception -> getLink ( ) ) ) { $ body [ 'errors' ] [ 'link' ] = $ link ; } return $ body ; }
4093	public function wildcard ( $ val , $ field = false ) { $ this -> wildcard = ( $ field ) ? array ( $ field => $ val ) : $ val ; return $ this ; }
869	private function createProcessForSource ( $ source ) { if ( null === $ this -> temporaryFile ) { $ this -> temporaryFile = tempnam ( '.' , 'cs_fixer_tmp_' ) ; $ this -> fileRemoval -> observe ( $ this -> temporaryFile ) ; } if ( false === @ file_put_contents ( $ this -> temporaryFile , $ source ) ) { throw new IOException ( sprintf ( 'Failed to write file "%s".' , $ this -> temporaryFile ) , 0 , null , $ this -> temporaryFile ) ; } return $ this -> createProcessForFile ( $ this -> temporaryFile ) ; }
2710	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ activeVersion = $ this -> getRequest ( ) -> getParam ( 'active_version' ) ; $ domains = $ this -> api -> getAllDomains ( $ activeVersion ) ; $ storeBaseUrl = $ this -> storeManager -> getStore ( ) -> getBaseUrl ( ) ; if ( ! $ domains ) { return $ result -> setData ( [ 'status' => false , 'msg' => 'Failed to check Domain details.' ] ) ; } return $ result -> setData ( [ 'status' => true , 'domains' => $ domains , 'store' => $ storeBaseUrl ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
11660	public static function readFromString ( $ string ) { $ xml = new \ DOMDocument ( ) ; $ xml -> loadXML ( $ string ) ; $ result = [ ] ; $ props = $ xml -> childNodes -> item ( $ xml -> childNodes -> length - 1 ) -> childNodes ; for ( $ i = 0 ; $ i < $ props -> length ; $ i ++ ) { $ entry = $ props -> item ( $ i ) ; if ( $ entry -> nodeName == "entry" ) $ result [ $ entry -> attributes -> getNamedItem ( "key" ) -> nodeValue ] = $ entry -> textContent ; } return $ result ; }
12847	private function _loadController ( $ oControllerName , string $ sActionName , array $ aParams = array ( ) ) { $ aPhpDoc = PhpDoc :: getPhpDocOfMethod ( $ oControllerName , $ sActionName ) ; if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { if ( ! isset ( $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ) { $ aPhpDoc [ 'Cache' ] [ 'maxage' ] = 0 ; } $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } $ mCacheReturn = Cache :: get ( $ sActionName . $ sCacheExt , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; if ( $ mCacheReturn !== false ) { return $ mCacheReturn ; } } if ( isset ( $ aPhpDoc [ 'Secure' ] ) ) { if ( isset ( $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) && $ this -> _oSecurity -> getUserRole ( ) != $ aPhpDoc [ 'Secure' ] [ 'roles' ] ) { $ this -> _getPage403 ( ) ; } } $ oController = new $ oControllerName ; ob_start ( ) ; if ( ! defined ( 'PORTAL' ) ) { define ( 'PORTAL' , 'Batch' ) ; } if ( method_exists ( $ oController , 'beforeExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'beforeExecuteRoute' ) , array ( ) ) ; } $ mReturnController = call_user_func_array ( array ( $ oController , $ sActionName ) , $ aParams ) ; if ( method_exists ( $ oController , 'afterExecuteRoute' ) ) { call_user_func_array ( array ( $ oController , 'afterExecuteRoute' ) , array ( ) ) ; } $ mReturn = ob_get_clean ( ) ; if ( $ mReturn == '' ) { $ mReturn = $ mReturnController ; } if ( isset ( $ aPhpDoc [ 'Cache' ] ) ) { $ oMobileDetect = new \ Mobile_Detect ; if ( $ oMobileDetect -> isMobile ( ) ) { $ sCacheExt = '.mobi' ; } else { $ sCacheExt = '' ; } if ( defined ( 'COMPRESS_HTML' ) && COMPRESS_HTML ) { $ mReturn = str_replace ( array ( "\t" , "\r" , " " ) , array ( "" , "" , "" , " " ) , $ mReturn ) ; } Cache :: set ( $ sActionName . $ sCacheExt , $ mReturn , $ aPhpDoc [ 'Cache' ] [ 'maxage' ] ) ; } return $ mReturn ; }
4248	public function onOutput ( Event $ event ) { $ this -> outputEvent = $ event ; $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-Protocol-1' , 'http://meta.wildfirehq.org/Protocol/JsonStream/0.2' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Plugin-1' , 'http://meta.firephp.org/Wildfire/Plugin/FirePHP/Library-FirePHPCore/' . self :: FIREPHP_PROTO_VER ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Structure-1' , 'http://meta.firephp.org/Wildfire/Structure/FirePHP/FirebugConsole/0.1' ) ; $ heading = isset ( $ _SERVER [ 'REQUEST_METHOD' ] ) ? $ _SERVER [ 'REQUEST_METHOD' ] . ' ' . $ _SERVER [ 'REQUEST_URI' ] : '$: ' . \ implode ( ' ' , $ _SERVER [ 'argv' ] ) ; $ this -> processLogEntryWEvent ( 'groupCollapsed' , array ( 'PHP: ' . $ heading ) ) ; $ this -> processAlerts ( ) ; $ this -> processSummary ( ) ; $ this -> processLog ( ) ; $ this -> processLogEntryWEvent ( 'groupEnd' ) ; $ event [ 'headers' ] [ ] = array ( 'X-Wf-1-Index' , $ this -> messageIndex ) ; $ this -> data = array ( ) ; return ; }
4321	public static function arrayPathGet ( $ array , $ path ) { if ( ! \ is_array ( $ path ) ) { $ path = \ array_filter ( \ preg_split ( '#[\./]#' , $ path ) , 'strlen' ) ; } $ path = \ array_reverse ( $ path ) ; while ( $ path ) { $ key = \ array_pop ( $ path ) ; $ arrayAccess = \ is_array ( $ array ) || $ array instanceof \ ArrayAccess ; if ( ! $ arrayAccess ) { return null ; } elseif ( isset ( $ array [ $ key ] ) ) { $ array = $ array [ $ key ] ; } elseif ( $ key == '__count__' ) { return \ count ( $ array ) ; } elseif ( $ key == '__end__' ) { \ end ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } elseif ( $ key == '__reset__' ) { \ reset ( $ array ) ; $ path [ ] = \ key ( $ array ) ; } else { return null ; } } return $ array ; }
8603	private function _convertDeregisterDestination ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'DeregisterDestination' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetMarketplaceId ( ) ) { $ parameters [ 'MarketplaceId' ] = $ request -> getMarketplaceId ( ) ; } if ( $ request -> isSetDestination ( ) ) { $ DestinationDeregisterDestinationInput = $ request -> getDestination ( ) ; foreach ( $ DestinationDeregisterDestinationInput -> getDeliveryChannel ( ) as $ DeliveryChannelDestinationIndex => $ DeliveryChannelDestination ) { $ parameters [ 'Destination' . '.' . 'DeliveryChannel' . '.' . ( $ DeliveryChannelDestinationIndex + 1 ) ] = $ DeliveryChannelDestination ; } } return $ parameters ; }
6552	public function lock ( ) { if ( $ this -> pid === $ this -> getSerial ( ) ) { return ; } $ this -> pid = $ this -> getSerial ( ) ; $ this -> fh = fopen ( $ filename = $ this -> getPidFilename ( ) , 'a+' ) ; if ( ! flock ( $ this -> fh , LOCK_EX | LOCK_NB ) ) { throw new ImportAlreadyRunningException ( sprintf ( 'PID file %s is already in use' , $ filename ) ) ; } if ( fwrite ( $ this -> fh , $ this -> pid . PHP_EOL ) === false ) { throw new \ Exception ( sprintf ( 'Can\'t write PID %s to PID file %s' , $ this -> pid , $ filename ) ) ; } }
2814	public function getBlock ( $ blockName ) { if ( ! array_key_exists ( $ blockName , $ this -> blocks ) ) { throw new Exception ( 'Unable to find block with name ' . $ blockName ) ; } return $ this -> blocks [ $ blockName ] ; }
11094	public static function getDateFromBirthNumber ( $ no ) { if ( ! preg_match ( '#^\s*(\d\d)(\d\d)(\d\d)[ /]*(\d\d\d)(\d?)\s*$#' , $ no , $ matches ) ) { return null ; } list ( , $ year , $ month , $ day , $ ext , $ c ) = $ matches ; if ( $ c === '' ) { $ year += $ year < 54 ? 1900 : 1800 ; } else { $ mod = ( $ year . $ month . $ day . $ ext ) % 11 ; if ( $ mod === 10 ) { $ mod = 0 ; } if ( $ mod !== ( int ) $ c ) { return null ; } $ year += $ year < 54 ? 2000 : 1900 ; } if ( $ year > 2003 ) { if ( $ month > 70 ) { $ month -= 70 ; } if ( $ month > 20 && $ month < 50 ) { $ month -= 20 ; } } if ( $ month > 50 ) { $ month -= 50 ; } return new DateTime ( sprintf ( '%04d-%02d-%02d' , $ year , $ month , $ day ) ) ; }
7329	private function configurePaymentTermSubjectMapping ( LoadClassMetadataEventArgs $ eventArgs ) { $ metadata = $ eventArgs -> getClassMetadata ( ) ; $ class = $ metadata -> getName ( ) ; if ( ! is_subclass_of ( $ class , Payment \ PaymentTermSubjectInterface :: class ) ) { return ; } if ( in_array ( $ class , $ this -> paymentTermSubjectClassCache ) ) { return ; } if ( ! $ metadata -> hasAssociation ( 'paymentTerm' ) ) { $ metadata -> mapManyToOne ( [ 'fieldName' => 'paymentTerm' , 'targetEntity' => Payment \ PaymentTermInterface :: class , 'joinColumns' => [ [ 'name' => 'payment_term_id' , 'referencedColumnName' => 'id' , 'onDelete' => 'RESTRICT' , 'nullable' => true , ] , ] , ] ) ; } $ this -> paymentTermSubjectClassCache [ ] = $ class ; }
8282	public function onPageRendering ( & $ templateName , array & $ twigVariables ) { $ twigVariables [ 'auth' ] [ 'plugin' ] = $ this ; $ twigVariables [ 'auth' ] [ 'vars' ] = $ this -> output ; if ( ! $ this -> errorOccurred ) { $ twigVariables [ 'auth' ] [ 'user' ] = $ this -> user ; $ old = $ this -> session -> getFlash ( 'old' ) ; if ( count ( $ old ) && isset ( $ old [ 0 ] ) ) { $ twigVariables [ 'auth' ] [ 'old' ] = $ old [ 0 ] ; } } }
7533	function setInnerText ( $ text , $ parser = null ) { $ this -> clear ( ) ; if ( trim ( $ text ) ) { if ( $ parser === null ) { $ parser = new $ this -> parserClass ( ) ; } $ parser -> root = & $ this ; $ parser -> setDoc ( $ text ) ; $ parser -> parse_all ( ) ; } return ( ( $ parser && $ parser -> errors ) ? $ parser -> errors : true ) ; }
9291	public function addGrid16CSS ( \ PageModel $ objPage , \ LayoutModel $ objLayout , \ PageRegular $ objPageRegular ) { $ arrFrameworkGrid16 = \ StringUtil :: deserialize ( $ objLayout -> frameworkGrid16 ) ; if ( is_array ( $ arrFrameworkGrid16 ) ) { foreach ( $ arrFrameworkGrid16 as $ strFile ) { if ( $ objLayout -> loadingOrderGrid16 == 'before_framework' ) { $ GLOBALS [ 'TL_CSS' ] [ ] = 'bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css' ; } else { $ GLOBALS [ 'TL_HEAD' ] [ ] = '<link rel="stylesheet" href="bundles/bugbustergrid16/' . basename ( $ strFile , '.css' ) . '.min.css">' ; } } } return ; }
8432	public function getDsn ( array $ info ) : string { $ dsn = 'pgsql:host=' ; $ dsn .= ( isset ( $ info [ 'host' ] ) === true ? $ info [ 'host' ] : 'localhost' ) . ';' ; if ( isset ( $ info [ 'port' ] ) === true ) { $ dsn .= 'port=' . $ info [ 'port' ] . ';' ; } $ dsn .= 'dbname=' . $ info [ 'name' ] . ';' ; return $ dsn ; }
6873	protected function buildItem ( SaleItemInterface $ saleItem , ShipmentInterface $ shipment ) { if ( $ saleItem -> isCompound ( ) ) { $ available = $ expected = null ; foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { if ( null !== $ child = $ this -> buildItem ( $ childSaleItem , $ shipment ) ) { $ saleItemQty = $ childSaleItem -> getQuantity ( ) ; $ e = $ child -> getExpected ( ) / $ saleItemQty ; if ( null === $ expected || $ expected > $ e ) { $ expected = $ e ; } $ a = $ child -> getAvailable ( ) / $ saleItemQty ; if ( null === $ available || $ available > $ a ) { $ available = $ a ; } } } if ( 0 < $ expected ) { return $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected , $ available ) ; } return null ; } $ item = null ; if ( ! ( $ saleItem -> isCompound ( ) && ! $ saleItem -> hasPrivateChildren ( ) ) ) { $ expected = $ shipment -> isReturn ( ) ? $ this -> calculator -> calculateReturnableQuantity ( $ saleItem , $ shipment ) : $ this -> calculator -> calculateShippableQuantity ( $ saleItem , $ shipment ) ; if ( 0 < $ expected ) { $ item = $ this -> findOrCreateItem ( $ shipment , $ saleItem , $ expected ) ; } } if ( $ saleItem -> hasChildren ( ) ) { foreach ( $ saleItem -> getChildren ( ) as $ childSaleItem ) { $ this -> buildItem ( $ childSaleItem , $ shipment ) ; } } return $ item ; }
6572	protected function registerCommands ( ) { $ this -> app [ 'command.countries.migration' ] = $ this -> app -> share ( function ( $ app ) { return new MigrationCommand ( $ app ) ; } ) ; $ this -> commands ( 'command.countries.migration' ) ; }
12800	public function getHeaders ( ) { if ( ! isset ( $ this -> _headers ) ) { $ this -> _headers = $ this -> readLine ( 1 ) ; if ( ! $ this -> _headers ) { $ this -> _headers = [ ] ; } } return $ this -> _headers ; }
9911	function fromArray ( $ object_vars ) { foreach ( $ object_vars as $ key => $ value ) { if ( class_exists ( 'AbstractJSONWrapper' ) && is_subclass_of ( $ this -> { $ key } , 'AbstractJSONWrapper' ) ) { $ this -> { $ key } -> fromArray ( $ value ) ; } else { $ this -> { $ key } = $ value ; } } }
1132	public function insideSubtree ( $ node ) { return ( $ this -> getLeft ( ) >= $ node -> getLeft ( ) && $ this -> getLeft ( ) <= $ node -> getRight ( ) && $ this -> getRight ( ) >= $ node -> getLeft ( ) && $ this -> getRight ( ) <= $ node -> getRight ( ) ) ; }
6233	public function addChild ( $ key , $ value = null , $ namespace = null ) { if ( $ value != null ) { $ value = htmlspecialchars ( $ value , ENT_XML1 ) ; } return parent :: addChild ( $ key , $ value , $ namespace ) ; }
6738	public function run_ajax ( ) { $ methods = [ 'add_movie_rating' ] ; foreach ( $ methods as $ method ) { add_action ( 'wp_ajax_' . $ method , [ $ this -> rating , $ method ] ) ; add_action ( 'wp_ajax_nopriv_' . $ method , [ $ this -> rating , $ method ] ) ; } }
5289	protected static function requestStream ( $ url , $ params ) { $ opts = array ( 'http' => array ( 'method' => 'POST' , 'header' => implode ( "\n" , self :: getHeaders ( ) ) , 'content' => json_encode ( $ params ) , 'timeout' => self :: $ requestTimeout , 'ignore_errors' => true , ) ) ; $ context = stream_context_create ( $ opts ) ; return file_get_contents ( $ url , false , $ context ) ; }
12328	public function enqueue_script ( WP_Enqueue_Options $ options ) { if ( ! $ options -> have_required_properties ( ) ) { trigger_error ( 'Trying to enqueue script, but required properties are missing.' ) ; return ; } $ handle = $ options -> get_handle ( ) ; $ relative_path = $ options -> get_relative_path ( ) ; $ filename = $ options -> get_filename ( ) ; $ filename_debug = $ options -> get_filename_debug ( ) ; $ dependencies = $ options -> get_dependencies ( ) ; $ version = $ options -> get_version ( ) ; $ in_footer = $ options -> get_in_footer ( ) ; $ localization_name = $ options -> get_localization_name ( ) ; $ data = $ options -> get_data ( ) ; $ source = $ this -> get_source_to_enqueue ( $ relative_path , $ filename , $ filename_debug ) ; wp_register_script ( $ handle , $ source , $ dependencies , $ version , $ in_footer ) ; if ( ! empty ( $ localization_name ) && ! empty ( $ data ) ) { wp_localize_script ( $ handle , $ localization_name , $ data ) ; } wp_enqueue_script ( $ handle ) ; }
9591	public function radioListWithGap ( $ items , $ options = [ ] ) { $ this -> addListInputCssClass ( $ options , $ this -> radioGapCssClass ) ; return self :: radioList ( $ items , $ options ) ; }
7595	protected function renderLabel ( ElementInterface $ oElement ) { if ( ( $ sLabel = $ oElement -> getLabel ( ) ) && ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabel = $ oTranslator -> translate ( $ sLabel , $ this -> getTranslatorTextDomain ( ) ) ; } return $ sLabel ; }
3326	public function render ( OptionCollection $ options ) { $ lines = array ( ) ; foreach ( $ options as $ option ) { $ c1 = $ this -> renderOption ( $ option ) ; $ lines [ ] = "\t" . $ c1 ; $ lines [ ] = wordwrap ( "\t\t" . $ option -> desc , $ this -> screenWidth , "\n\t\t" ) ; $ lines [ ] = '' ; } return implode ( "\n" , $ lines ) ; }
3737	protected function createNewItem ( $ item ) { $ data = [ 'tstamp' => $ item -> get ( 'tstamp' ) ] ; $ isNewItem = false ; if ( $ this -> hasVariants ( ) ) { if ( $ item -> get ( 'vargroup' ) === null ) { $ item -> set ( 'varbase' , '1' ) ; $ item -> set ( 'vargroup' , '0' ) ; $ isNewItem = true ; } $ data [ 'varbase' ] = $ item -> get ( 'varbase' ) ; $ data [ 'vargroup' ] = $ item -> get ( 'vargroup' ) ; } $ connection = $ this -> getConnection ( ) ; $ builder = $ connection -> createQueryBuilder ( ) ; $ parameters = [ ] ; foreach ( array_keys ( $ data ) as $ key ) { $ parameters [ $ key ] = ':' . $ key ; } $ builder -> insert ( $ this -> getTableName ( ) ) -> values ( $ parameters ) -> setParameters ( $ data ) -> execute ( ) ; $ item -> set ( 'id' , $ connection -> lastInsertId ( ) ) ; if ( $ isNewItem ) { $ this -> saveSimpleColumn ( 'vargroup' , [ $ item -> get ( 'id' ) ] , $ item -> get ( 'id' ) ) ; } }
2905	public function addEmailToProfile ( $ email , $ name , $ variables , $ result , Zend_Mail $ mail ) { $ emailCapture = Mage :: getModel ( 'sheep_debug/email' ) ; $ subject = $ this -> decodeSubject ( $ mail -> getSubject ( ) ) ; $ body = $ this -> getContent ( $ mail ) ; $ emailCapture -> setFromName ( $ this -> getSenderName ( ) ) ; $ emailCapture -> setFromEmail ( $ this -> getSenderEmail ( ) ) ; $ emailCapture -> setToEmail ( $ email ) ; $ emailCapture -> setToName ( $ name ) ; $ emailCapture -> setSubject ( $ subject ) ; $ emailCapture -> setIsPlain ( $ this -> isPlain ( ) ) ; $ emailCapture -> setBody ( $ body ) ; $ emailCapture -> setIsAccepted ( $ result ) ; $ emailCapture -> setVariables ( $ variables ) ; $ emailCapture -> setIsSmtpDisabled ( ( bool ) Mage :: getStoreConfigFlag ( 'system/smtp/disable' ) ) ; Mage :: getSingleton ( 'sheep_debug/observer' ) -> getRequestInfo ( ) -> addEmail ( $ emailCapture ) ; }
2734	public function afterGenerateXml ( \ Magento \ Framework \ View \ Layout $ subject , $ result ) { if ( $ subject -> isCacheable ( ) && $ this -> config -> isEnabled ( ) && $ this -> config -> getType ( ) == Config :: FASTLY && $ this -> config -> getTtl ( ) ) { $ header = $ this -> response -> getHeader ( 'cache-control' ) ; if ( ( $ header instanceof \ Zend \ Http \ Header \ HeaderInterface ) && ( $ value = $ header -> getFieldValue ( ) ) ) { if ( $ ttl = $ this -> config -> getStaleTtl ( ) ) { $ value .= ', stale-while-revalidate=' . $ ttl ; } if ( $ ttl = $ this -> config -> getStaleErrorTtl ( ) ) { $ value .= ', stale-if-error=' . $ ttl ; } $ this -> response -> setHeader ( $ header -> getFieldName ( ) , $ value , true ) ; } } if ( $ subject -> isCacheable ( ) ) { $ this -> response -> setHeader ( "fastly-page-cacheable" , "YES" ) ; } else { $ this -> response -> setHeader ( "fastly-page-cacheable" , "NO" ) ; } return $ result ; }
12227	public function deleteSelf ( ) { $ tmp = dom_import_simplexml ( $ this ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { throw new BadMethodCallException ( 'deleteSelf() cannot be used to delete the root node' ) ; } $ tmp -> parentNode -> removeChild ( $ tmp ) ; }
11947	public function getPriority ( ) { if ( isset ( $ this -> object -> singleWidget ) ) { if ( isset ( $ this -> object -> singleWidget ) && isset ( $ this -> object -> singleWidget -> content -> priorityAdjust ) ) { return $ this -> _priority + $ this -> object -> singleWidget -> content -> priorityAdjust ; } } return $ this -> _priority ; }
9808	private function readOPT ( ) { $ recInstance = ( 0xFFF0 & Xls :: getUInt2d ( $ this -> data , $ this -> pos ) ) >> 4 ; $ length = Xls :: getInt4d ( $ this -> data , $ this -> pos + 4 ) ; $ recordData = substr ( $ this -> data , $ this -> pos + 8 , $ length ) ; $ this -> pos += 8 + $ length ; $ this -> readOfficeArtRGFOPTE ( $ recordData , $ recInstance ) ; }
2307	protected function doCreateFileList ( $ strFolder = null , $ level = - 1 , $ strFilter = '' ) { if ( $ strFilter === true ) { @ trigger_error ( 'Passing "true" to Backend::doCreateFileList() has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ strFilter = 'gif,jpg,jpeg,png' ; } $ rootDir = System :: getContainer ( ) -> getParameter ( 'kernel.project_dir' ) ; $ arrPages = scan ( $ rootDir . '/' . $ strFolder ) ; if ( empty ( $ arrPages ) ) { return '' ; } if ( \ in_array ( '.htaccess' , $ arrPages ) ) { return '' ; } ++ $ level ; $ strFolders = '' ; $ strFiles = '' ; foreach ( $ arrPages as $ strFile ) { if ( strncmp ( $ strFile , '.' , 1 ) === 0 ) { continue ; } if ( is_dir ( $ rootDir . '/' . $ strFolder . '/' . $ strFile ) ) { $ strFolders .= $ this -> doCreateFileList ( $ strFolder . '/' . $ strFile , $ level , $ strFilter ) ; } else { if ( $ strFilter != '' && ! preg_match ( '/\.(' . str_replace ( ',' , '|' , $ strFilter ) . ')$/i' , $ strFile ) ) { continue ; } $ strFiles .= sprintf ( '<option value="%s"%s>%s</option>' , $ strFolder . '/' . $ strFile , ( ( $ strFolder . '/' . $ strFile == Input :: get ( 'value' ) ) ? ' selected="selected"' : '' ) , StringUtil :: specialchars ( $ strFile ) ) ; } } if ( \ strlen ( $ strFiles ) ) { return '<optgroup label="' . StringUtil :: specialchars ( $ strFolder ) . '">' . $ strFiles . $ strFolders . '</optgroup>' ; } return $ strFiles . $ strFolders ; }
7984	public function getCurrentMonitoring ( $ domain , $ type ) { $ type = strtolower ( $ type ) ; if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! in_array ( $ type , array ( 'cpu:max' , 'cpu:used' , 'mem:max' , 'mem:used' , 'net:rx' , 'net:tx' ) ) ) throw new BadMethodCallException ( 'Parameter $type must be "cpu:max" or "cpu:used" or "mem:max" or "mem:used" or "net:rx" or "net:tx". "' . $ type . '" given.' ) ; try { $ r = $ this -> get ( 'vps/' . $ domain . '/use?type=' . $ type ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new VpsException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
7980	public function getSessionFiles ( $ sessId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFiles ( $ this -> pp , $ this -> sn , $ sessId ) ) ; }
3796	private function checkForRoot ( $ containedModel , $ action ) { if ( $ this -> hasVariants ( ) && $ action == 'cut' && $ containedModel -> getProperty ( 'varbase' ) == 0 ) { $ this -> disablePI = true ; } }
8483	public static function getKernelVersion ( ) { $ wmi = Windows :: getInstance ( ) ; foreach ( $ wmi -> ExecQuery ( "SELECT WindowsVersion FROM Win32_Process WHERE Handle = 0" ) as $ process ) { return $ process -> WindowsVersion ; } return "Unknown" ; }
3875	public function addPages ( $ pages , $ rootPage = null , $ fromSiteMap = false , $ language = null ) { $ this -> foundPages = $ pages ; unset ( $ pages ) ; foreach ( $ this -> getConfigs ( ) as $ config ) { if ( ! $ config [ 'published' ] ) { continue ; } $ this -> getMetaModelsPages ( $ config , $ rootPage , $ language ) ; } asort ( $ this -> foundPages ) ; return $ this -> foundPages ; }
5159	private static function createGallery ( String $ body , int $ order , String $ photo , String $ source , string $ lead ) : \ One \ Model \ Gallery { return new Gallery ( $ body , $ order , $ photo , $ source , $ lead ) ; }
6332	public function createResponse ( $ status , $ errorCode , $ errorDescription ) { $ document = new \ DOMDocument ( '1.0' , 'utf-8' ) ; $ document -> formatOutput = false ; $ response = $ document -> appendChild ( $ document -> createElement ( 'SVSPurchaseStatusNotificationResponse' ) ) ; $ result = $ response -> appendChild ( $ document -> createElement ( 'TransactionResult' ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Description' , $ errorDescription ) ) ; $ result -> appendChild ( $ document -> createElement ( 'Code' , $ errorCode ) ) ; $ response -> appendChild ( $ document -> createElement ( 'Status' , $ status ) ) ; $ authentication = $ response -> appendChild ( $ document -> createElement ( 'Authentication' ) ) ; $ checksum = $ authentication -> appendChild ( $ document -> createElement ( 'Checksum' , $ this -> getMerchantPassword ( ) ) ) ; $ checksum -> nodeValue = $ this -> calculateXmlChecksum ( $ document -> saveXML ( ) ) ; return $ document -> saveXML ( ) ; }
4944	public function grant ( $ resource , $ permission = null , $ build = true ) { if ( is_array ( $ resource ) ) { foreach ( $ resource as $ r ) { $ this -> grant ( $ r , $ permission , false ) ; } if ( $ build ) { $ this -> build ( ) ; } return $ this ; } true === $ permission || ( null === $ permission && $ resource instanceof PermissionsResourceInterface ) || $ this -> checkPermission ( $ permission ) ; $ resourceId = $ this -> getResourceId ( $ resource ) ; if ( true === $ permission ) { $ permission = $ this -> getFrom ( $ resource ) ; } if ( self :: PERMISSION_NONE == $ permission ) { if ( $ resource instanceof PermissionsResourceInterface ) { $ refs = $ this -> getResources ( ) ; if ( $ refs -> contains ( $ resource ) ) { $ refs -> removeElement ( $ resource ) ; } } unset ( $ this -> assigned [ $ resourceId ] ) ; } else { if ( $ resource instanceof PermissionsResourceInterface ) { $ spec = $ resource -> getPermissionsUserIds ( $ this -> type ) ; if ( ! is_array ( $ spec ) || ! count ( $ spec ) ) { $ spec = array ( ) ; } elseif ( is_numeric ( key ( $ spec ) ) ) { $ spec = array ( $ permission => $ spec ) ; } } else { $ spec = array ( $ permission => $ resource instanceof UserInterface ? array ( $ resource -> getId ( ) ) : array ( $ resource ) ) ; } $ this -> assigned [ $ resourceId ] = $ spec ; if ( $ resource instanceof PermissionsResourceInterface ) { try { $ refs = $ this -> getResources ( ) ; if ( ! $ refs -> contains ( $ resource ) ) { $ refs -> add ( $ resource ) ; } } catch ( \ Exception $ e ) { } ; } } if ( $ build ) { $ this -> build ( ) ; } $ this -> hasChanged = true ; return $ this ; }
10704	public function getModel ( ) { if ( null === $ this -> model ) { $ mainService = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ this -> model = $ mainService -> getUserEntityRepository ( ) ; } return $ this -> model ; }
5084	protected function validateUserInput ( $ aData , $ oItem = null ) { $ aOut = [ ] ; $ aFields = $ this -> oModel -> describeFields ( ) ; $ aKeys = array_unique ( array_merge ( array_keys ( $ aFields ) , arrayExtractProperty ( $ this -> oModel -> getExpandableFields ( ) , 'trigger' ) ) ) ; $ aValidKeys = array_diff ( $ aKeys , static :: IGNORE_FIELDS_WRITE ) ; foreach ( $ aValidKeys as $ sValidKey ) { $ oField = getFromArray ( $ sValidKey , $ aFields ) ; if ( array_key_exists ( $ sValidKey , $ aData ) ) { $ aOut [ $ sValidKey ] = getFromArray ( $ sValidKey , $ aData ) ; } } return $ aOut ; }
1838	public static function findBy ( $ strColumn , $ varValue , array $ arrOptions = array ( ) ) { $ blnModel = false ; $ arrColumn = ( array ) $ strColumn ; if ( \ count ( $ arrColumn ) == 1 && ( $ arrColumn [ 0 ] === static :: getPk ( ) || \ in_array ( $ arrColumn [ 0 ] , static :: getUniqueFields ( ) ) ) ) { $ blnModel = true ; } $ arrOptions = array_merge ( array ( 'column' => $ strColumn , 'value' => $ varValue , 'return' => $ blnModel ? 'Model' : 'Collection' ) , $ arrOptions ) ; return static :: find ( $ arrOptions ) ; }
5998	public function setMax ( $ max ) { if ( $ max instanceof DateTime ) { $ this -> max = $ max ; } else { try { $ this -> max = new DateTime ( $ max ) ; } catch ( \ Exception $ e ) { $ this -> max = null ; } } return $ this ; }
8627	public function setGetCompetitivePricingForSKUResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetCompetitivePricingForSKUResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
5474	protected function createAction ( $ action , $ page ) { if ( ( $ action === '' ) || ( $ action === false ) ) { return $ page -> expandUrl ( $ page -> getUrl ( ) ) ; } return $ page -> expandUrl ( new SimpleUrl ( $ action ) ) ; }
4051	private function buildConditionTree ( array $ conditions ) : array { $ conditionMap = [ ] ; $ bySetting = [ ] ; foreach ( $ conditions as $ condition ) { unset ( $ converted ) ; if ( array_key_exists ( $ condition [ 'id' ] , $ conditionMap ) ) { $ converted = & $ conditionMap [ $ condition [ 'id' ] ] ; foreach ( $ condition as $ key => $ value ) { $ converted [ $ key ] = $ value ; } } else { $ converted = \ array_slice ( $ condition , 0 ) ; $ conditionMap [ $ condition [ 'id' ] ] = & $ converted ; } if ( empty ( $ condition [ 'pid' ] ) ) { $ bySetting [ $ condition [ 'settingId' ] ] [ ] = & $ converted ; continue ; } if ( ! isset ( $ conditionMap [ $ condition [ 'pid' ] ] ) ) { $ temp = [ 'children' => [ ] ] ; $ conditionMap [ $ condition [ 'pid' ] ] = & $ temp ; } $ conditionMap [ $ condition [ 'pid' ] ] [ 'children' ] [ ] = & $ converted ; } return $ bySetting ; }
6154	public function setValue ( $ value ) { $ definition = $ this -> propertyType -> getDefinition ( ) ; if ( isset ( $ definition [ 'hierarchical' ] ) && $ definition [ 'hierarchical' ] ) { $ this -> value = [ ] ; foreach ( $ value as $ v ) { foreach ( $ v [ 'value' ] as $ itemValue ) { $ this -> value [ ] = $ this -> convertValue ( $ itemValue [ 'value' ] ) ; } } } elseif ( ! empty ( $ definition [ 'array' ] ) ) { if ( empty ( $ definition [ 'multiplechoice' ] ) && isset ( $ definition [ 'options' ] ) && is_array ( $ definition [ 'options' ] ) ) { $ this -> value = $ this -> convertValue ( current ( $ value ) [ 'value' ] ) ; } else { $ this -> value = [ ] ; foreach ( $ value as $ v ) { $ this -> value [ ] = $ this -> convertValue ( $ v [ 'value' ] ) ; } } } else { $ this -> value = $ this -> convertValue ( $ value ) ; } return $ this ; }
4094	public function query ( array $ options = array ( ) ) { if ( ! ( $ this -> query instanceof Query ) ) $ this -> query = new Query ( $ options ) ; return $ this -> query ; }
815	private function fixAnnotation ( DocBlock $ doc , Annotation $ annotation ) { $ types = $ annotation -> getNormalizedTypes ( ) ; if ( 1 === \ count ( $ types ) && ( 'null' === $ types [ 0 ] || 'void' === $ types [ 0 ] ) ) { $ annotation -> remove ( ) ; } }
5059	public function generateFromURI ( $ string ) { $ badge = Badge :: fromURI ( $ string ) ; return $ this -> getRenderFor ( $ badge -> getFormat ( ) ) -> render ( $ badge ) ; }
9036	protected function insert ( $ entity , $ tableName = null , HydratorInterface $ hydrator = null ) { $ result = parent :: insert ( $ entity , $ tableName , $ hydrator ) ; $ entity -> setId ( $ result -> getGeneratedValue ( ) ) ; return $ result ; }
7158	public function compile ( Database $ db = NULL ) : string { if ( $ db === null ) { $ db = \ Mii :: $ app -> db ; } $ value = $ this -> value ( ) ; if ( ! empty ( $ this -> _parameters ) ) { $ params = array_map ( [ $ db , 'quote' ] , $ this -> _parameters ) ; $ value = strtr ( $ value , $ params ) ; } return $ value ; }
2076	public function purgeImageCache ( ) { $ container = System :: getContainer ( ) ; $ strTargetPath = StringUtil :: stripRootDir ( $ container -> getParameter ( 'contao.image.target_dir' ) ) ; $ strRootDir = $ container -> getParameter ( 'kernel.project_dir' ) ; foreach ( scan ( $ strRootDir . '/' . $ strTargetPath ) as $ dir ) { if ( strncmp ( $ dir , '.' , 1 ) !== 0 ) { $ objFolder = new Folder ( $ strTargetPath . '/' . $ dir ) ; $ objFolder -> purge ( ) ; } } $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the image cache' , __METHOD__ , TL_CRON ) ; }
690	protected function getUrlFromCache ( $ cacheKey , $ route , $ params ) { if ( ! empty ( $ this -> _ruleCache [ $ cacheKey ] ) ) { foreach ( $ this -> _ruleCache [ $ cacheKey ] as $ rule ) { if ( ( $ url = $ rule -> createUrl ( $ this , $ route , $ params ) ) !== false ) { return $ url ; } } } else { $ this -> _ruleCache [ $ cacheKey ] = [ ] ; } return false ; }
8793	protected function setKeyInEnvironmentFile ( $ key , $ input , $ output ) { $ currentKey = config ( 'app.key' ) ; $ helper = $ this -> getHelper ( 'question' ) ; $ question = new ConfirmationQuestion ( 'Application key will re-generate. Are you sure?: ' , false ) ; if ( strlen ( $ currentKey ) !== 0 && ( ! $ helper -> ask ( $ input , $ output , $ question ) ) ) { return false ; } $ this -> writeNewEnvironmentFileWith ( $ key ) ; return true ; }
1979	public static function generate ( $ strScope = TL_MODE ) { $ strMessages = static :: generateUnwrapped ( $ strScope ) ; if ( $ strMessages != '' ) { $ strMessages = '<div class="tl_message">' . $ strMessages . '</div>' ; } return $ strMessages ; }
10316	function getBouncesCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ statusCodeFilter = null , $ typeFilter = null , $ sourceFilter = null , $ excludeAnonymousBounces = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousBounces ) ) $ params [ 'exclude_anonymous_bounces' ] = ( $ excludeAnonymousBounces == true ) ? "true" : "false" ; if ( isset ( $ typeFilter ) ) $ params [ 'type' ] = $ typeFilter ; if ( isset ( $ sourceFilter ) ) $ params [ 'source_filter' ] = $ sourceFilter ; return $ this -> get ( 'reports/bounces/count' , $ params ) ; }
7186	public function getCombination ( $ quantity , $ reset = false ) { if ( null !== $ this -> combination && ! $ reset ) { return $ this -> combination ; } $ this -> combination = null ; if ( ! empty ( $ combinations = $ this -> buildCombinations ( $ quantity ) ) ) { usort ( $ combinations , function ( AssignmentCombination $ a , AssignmentCombination $ b ) use ( $ quantity ) { if ( $ a -> diff == $ b -> diff ) { if ( $ a -> size == $ b -> size ) { return 0 ; } return $ a -> size < $ b -> size ? - 1 : 1 ; } if ( 0 <= $ a -> diff ) { return intval ( 0 > $ b -> diff ? - 1 : $ a -> diff - $ b -> diff ) ; } return intval ( 0 < $ b -> diff ? 1 : $ b -> diff - $ a -> diff ) ; } ) ; $ this -> combination = reset ( $ combinations ) ; } return $ this -> combination ; }
9609	protected function _checkVectorSpace ( self $ b ) { if ( ! $ this -> isSameDimension ( $ b ) ) { throw new Exception ( 'The vectors must be of the same dimension' ) ; } if ( ! $ this -> isSameVectorSpace ( $ b ) ) { throw new Exception ( 'The vectors\' components must have the same keys' ) ; } }
11441	public function setRegistry ( $ var = null , $ val = null , $ section = false ) { if ( is_null ( $ var ) ) { return ; } if ( $ section ) { if ( ! isset ( $ this -> registry [ $ section ] ) ) { $ this -> registry [ $ section ] = array ( ) ; } $ this -> registry [ $ section ] [ $ var ] = $ val ; } else { $ this -> registry [ $ var ] = $ val ; } return $ this ; }
4059	private function drawLegend ( ModelToLabelEvent $ event ) { $ model = $ event -> getModel ( ) ; $ metaModel = $ this -> getMetaModelFromModel ( $ model ) ; if ( is_array ( $ legend = StringUtil :: deserialize ( $ model -> getProperty ( 'legendtitle' ) ) ) ) { foreach ( [ $ metaModel -> getActiveLanguage ( ) , $ metaModel -> getFallbackLanguage ( ) ] as $ language ) { if ( array_key_exists ( $ language , $ legend ) && ! empty ( $ legend [ $ language ] ) ) { $ legend = $ legend [ $ language ] ; break ; } } } if ( empty ( $ legend ) ) { $ legend = 'legend' ; } $ event -> setLabel ( '<div class="field_heading cte_type %s"><strong>%s</strong></div> <div class="dca_palette">%s%s</div>' ) -> setArgs ( [ $ model -> getProperty ( 'published' ) ? 'published' : 'unpublished' , $ this -> trans ( 'dcatypes.legend' ) , $ legend , $ model -> getProperty ( 'legendhide' ) ? ':hide' : '' ] ) ; }
1361	public function is ( string ... $ mediaTypes ) : bool { $ mediaTypes = collect ( $ mediaTypes ) -> map ( function ( $ mediaType , $ index ) { return MediaType :: parse ( $ index , $ mediaType ) ; } ) ; return $ this -> any ( ... $ mediaTypes ) ; }
11395	public static function getTranslateErrorCode ( int $ iCode ) : string { if ( $ iCode === 1 && $ iCode === 16 && $ iCode === 256 && $ iCode === 4096 ) { return LogLevel :: ERROR ; } else if ( $ iCode === 2 && $ iCode === 32 && $ iCode === 128 && $ iCode === 512 ) { return LogLevel :: WARNING ; } else if ( $ iCode === 4 && $ iCode === 64 ) { return LogLevel :: EMERGENCY ; } else if ( $ iCode === 8 && $ iCode === 1024 ) { return LogLevel :: NOTICE ; } else if ( $ iCode === 2048 && $ iCode === 8192 && $ iCode === 16384 ) { return LogLevel :: INFO ; } else return LogLevel :: DEBUG ; }
6996	public static function parseApplePriceMatrixAll ( $ file , $ directory = null ) { $ dom = new \ DOMDocument ( ) ; $ dom -> loadHTMLFile ( $ file ) ; $ xpath = new \ DOMXPath ( $ dom ) ; $ currencies = array ( ) ; $ currencyElements = $ xpath -> query ( '//table[1]//tr[2]//td[position() > 1]' ) ; foreach ( $ currencyElements as $ currencyElement ) { $ currency = trim ( $ currencyElement -> textContent ) ; if ( 'Euro' == $ currency ) { $ currency = 'EUR' ; } $ currencies [ ] = $ currency ; } if ( ! count ( $ currencies ) ) { throw new \ RuntimeException ( sprintf ( 'Not found currencies in ApplePriceMatrix in file "%s".' , $ file ) ) ; } $ currencies = array_flip ( $ currencies ) ; foreach ( $ currencies as $ currency => $ null ) { $ currencies [ $ currency ] = static :: parseApplePriceMatrix ( $ dom , $ currency , $ directory ) ; } return $ currencies ; }
8539	public function setGetMyPriceForASINResult ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GetMyPriceForASINResult' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11260	public static function snake2pascal ( string $ snake ) : string { $ nameParts = explode ( "_" , $ snake ) ; $ nameParts = array_map ( "ucfirst" , $ nameParts ) ; return implode ( "" , $ nameParts ) ; }
12417	static function run_copy_paste_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcpd = self :: getTool ( 'phpcpd' , $ opts , true ) ; try { $ out = pake_sh ( "$phpcpd " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcpd.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
3937	private function setOptions ( PropertyInterface $ property , $ propInfo ) { if ( null !== $ property -> getOptions ( ) || ! isset ( $ propInfo [ 'options' ] ) ) { return ; } $ property -> setOptions ( $ propInfo [ 'options' ] ) ; }
8106	protected function getEmailBody ( $ config , $ variables ) { $ template = SSViewer :: fromString ( $ config -> ReviewBody ) ; $ value = $ template -> process ( ArrayData :: create ( $ variables ) ) ; return DBField :: create_field ( 'HTMLText' , ( string ) $ value ) ; }
7209	public static function createFinalFromGross ( Amount $ gross ) : Amount { $ final = new Amount ( $ gross -> getCurrency ( ) , $ gross -> getBase ( ) , $ gross -> getBase ( ) , 0 , $ gross -> getBase ( ) , $ gross -> getTax ( ) , $ gross -> getTotal ( ) ) ; foreach ( $ gross -> getTaxAdjustments ( ) as $ t ) { $ final -> addTaxAdjustment ( $ t ) ; } return $ final ; }
12024	private function addConstructorMethod ( ) { $ requiredParameters = $ this -> operationDefinition -> getRequiredParams ( ) ; $ methodGenerator = new MethodGenerator ( '__construct' ) ; $ defaultParams = $ this -> operationDefinition -> getDefaultParams ( ) ; $ body = '' ; if ( count ( $ defaultParams ) ) { $ body = '$defaultParams = [' . PHP_EOL ; foreach ( $ defaultParams as $ param ) { $ body .= sprintf ( " '%s' => '%s'," , $ param -> getName ( ) , $ param -> getDefault ( ) ) ; $ body .= PHP_EOL ; } $ body .= '];' . PHP_EOL ; $ body .= '$this->setParams($defaultParams);' . PHP_EOL ; } $ constructorParams = [ ] ; $ constructorParams [ ] = new ParameterGenerator ( 'api' , $ this -> apiGenerator -> getFQCN ( ) ) ; $ body .= '$this->api = $api;' . PHP_EOL ; foreach ( $ requiredParameters as $ param ) { $ normalizedParamName = normalizeParamName ( $ param -> getName ( ) ) ; $ constructorParams [ ] = new ParameterGenerator ( $ normalizedParamName , $ param -> getType ( ) ) ; $ body .= sprintf ( "\$this->parameters['%s'] = $%s;" . PHP_EOL , $ param -> getName ( ) , $ normalizedParamName ) ; } $ methodGenerator -> setParameters ( $ constructorParams ) ; $ methodGenerator -> setBody ( $ body ) ; $ this -> classGenerator -> addMethodFromGenerator ( $ methodGenerator ) ; }
6489	private function addHeaderValue ( HttpHeaders $ headers , string $ name , $ value , bool $ append ) : void { $ decodedValue = trim ( ( string ) ( isset ( self :: $ headersToUrlDecode [ $ name ] ) ? urldecode ( $ value ) : $ value ) ) ; if ( isset ( self :: $ specialCaseHeaders [ $ name ] ) ) { $ headers -> add ( $ name , $ decodedValue , $ append ) ; } elseif ( strpos ( $ name , 'HTTP_' ) === 0 ) { $ normalizedName = substr ( $ name , 5 ) ; $ headers -> add ( $ normalizedName , $ decodedValue , $ append ) ; } }
1252	private function normalizeElementName ( $ name ) { $ nsElement = explode ( '@' , $ name ) ; if ( count ( $ nsElement ) > 1 ) { array_shift ( $ nsElement ) ; return $ nsElement [ 0 ] ; } else { return $ name ; } }
5692	public function baseTransform ( ) { parent :: baseTransform ( ) ; Requirements :: javascript ( BETTER_BUTTONS_DIR . '/javascript/gridfield_betterbuttons_delete.js' ) ; return $ this -> setUseButtonTag ( true ) -> addExtraClass ( 'btn-danger-outline btn-hide-outline font-icon-trash-bin gridfield-better-buttons-delete' ) -> setAttribute ( "data-toggletext" , _t ( 'GridFieldBetterButtons.AREYOUSURE' , 'Yes. Delete this item.' ) ) -> setAttribute ( "data-confirmtext" , _t ( 'GridFieldDetailForm.CANCELDELETE' , 'No. Don\'t delete.' ) ) ; }
8548	public function setServiceProviderCreditEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ServiceProviderCreditEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
1971	public static function findMultipleByUuids ( $ arrUuids , array $ arrOptions = array ( ) ) { if ( empty ( $ arrUuids ) || ! \ is_array ( $ arrUuids ) ) { return null ; } $ t = static :: $ strTable ; foreach ( $ arrUuids as $ k => $ v ) { if ( Validator :: isStringUuid ( $ v ) ) { $ v = StringUtil :: uuidToBin ( $ v ) ; } $ arrUuids [ $ k ] = "UNHEX('" . bin2hex ( $ v ) . "')" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.uuid!=" . implode ( ", $t.uuid!=" , $ arrUuids ) ; } return static :: findBy ( array ( "$t.uuid IN(" . implode ( "," , $ arrUuids ) . ")" ) , null , $ arrOptions ) ; }
8032	public function validateDatesArray ( $ attribute , $ value , array $ parameters , Validator $ validator ) { foreach ( $ value as $ date ) { if ( false === strtotime ( $ date ) || empty ( $ date ) ) { return false ; } } return true ; }
6826	protected function getUnpaidAccountNumber ( CustomerGroupInterface $ group , string $ origin ) { foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } foreach ( $ account -> getCustomerGroups ( ) as $ g ) { if ( $ g -> getId ( ) === $ group -> getId ( ) ) { return $ account -> getNumber ( ) ; } } } foreach ( $ this -> accounts as $ account ) { if ( $ account -> getType ( ) !== AccountingTypes :: TYPE_UNPAID ) { continue ; } if ( 0 < $ account -> getCustomerGroups ( ) -> count ( ) ) { continue ; } return $ account -> getNumber ( ) ; } throw new LogicException ( sprintf ( "No unpaid account number configured for customer group '%s' (%s)" , $ group -> getName ( ) , $ origin ) ) ; }
2395	public function close ( ) { $ arrArchive [ 'archive_signature' ] = self :: CENTRAL_DIR_END ; $ arrArchive [ 'number_of_this_disk' ] = "\x00\x00" ; $ arrArchive [ 'number_of_disk_with_cd' ] = "\x00\x00" ; $ arrArchive [ 'total_cd_entries_disk' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'total_cd_entries' ] = pack ( 'v' , $ this -> intCount ) ; $ arrArchive [ 'size_of_cd' ] = pack ( 'V' , \ strlen ( $ this -> strCentralDir ) ) ; $ arrArchive [ 'offset_start_cd' ] = pack ( 'V' , @ ftell ( $ this -> resFile ) ) ; $ arrArchive [ 'zipfile_comment_length' ] = "\x00\x00" ; $ arrArchive [ 'zipfile_comment' ] = '' ; fwrite ( $ this -> resFile , $ this -> strCentralDir ) ; fwrite ( $ this -> resFile , implode ( '' , $ arrArchive ) ) ; fclose ( $ this -> resFile ) ; if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } Files :: getInstance ( ) -> rename ( self :: TEMPORARY_FOLDER . '/' . basename ( $ this -> strTemp ) , $ this -> strFile ) ; }
11762	public static function get ( $ property , $ default = NULL ) { $ object = new \ ReflectionClass ( Collection :: class ) ; $ value = $ object -> getStaticPropertyValue ( $ property ) ; return ( empty ( $ value ) ) ? $ default : $ value ; }
11617	public function records ( $ startTime , $ endTime , $ page = 1 , $ pageSize = 10 ) { $ params = [ 'starttime' => is_numeric ( $ startTime ) ? $ startTime : strtotime ( $ startTime ) , 'endtime' => is_numeric ( $ endTime ) ? $ endTime : strtotime ( $ endTime ) , 'pageindex' => $ page , 'pagesize' => $ pageSize , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_RECORDS , $ params ] ) ; }
2511	protected function makeStatusForPotentiallyNonExistent ( $ errorCatNode ) { if ( $ errorCatNode instanceof \ DOMNode ) { $ status = $ this -> makeStatusFromErrorQualifier ( $ errorCatNode -> nodeValue ) ; } else { $ status = Result :: STATUS_ERROR ; } return $ status ; }
12182	public function getPrimaryChild ( $ parentObject ) { if ( ! $ this -> handlePrimary ) { return false ; } if ( ! $ this -> child -> getPrimaryAsChild ( $ this -> parent ) ) { return false ; } $ key = json_encode ( [ __FUNCTION__ , $ this -> systemId , $ parentObject -> primaryKey ] ) ; if ( ! isset ( self :: $ _cache [ $ key ] ) ) { self :: $ _cache [ $ key ] = null ; $ relationClass = Yii :: $ app -> classes [ 'Relation' ] ; $ childClass = $ this -> child -> primaryModel ; $ relation = $ relationClass :: find ( ) ; $ alias = $ relationClass :: tableName ( ) ; $ relation -> andWhere ( [ '`' . $ alias . '`.`parent_object_id`' => $ parentObject -> primaryKey , '`' . $ alias . '`.`primary_child`' => 1 ] ) ; $ relation -> andWhere ( [ 'or' , '`' . $ alias . '`.`child_object_id` LIKE :prefix' ] ) ; $ relation -> params [ ':prefix' ] = $ childClass :: modelPrefix ( ) . '-%' ; $ parentObject -> addActiveConditions ( $ relation , $ alias ) ; $ relation = $ relation -> one ( ) ; if ( ! empty ( $ relation ) ) { self :: $ _cache [ $ key ] = $ relation ; } } return self :: $ _cache [ $ key ] ; }
9970	public function setDataValidation ( $ pCellCoordinate , DataValidation $ pDataValidation = null ) { if ( $ pDataValidation === null ) { unset ( $ this -> dataValidationCollection [ $ pCellCoordinate ] ) ; } else { $ this -> dataValidationCollection [ $ pCellCoordinate ] = $ pDataValidation ; } return $ this ; }
6835	protected function preventForbiddenChange ( Model \ InvoiceLineInterface $ line ) { if ( $ this -> persistenceHelper -> isChanged ( $ line , 'type' ) ) { list ( $ old , $ new ) = $ this -> persistenceHelper -> getChangeSet ( $ line , 'type' ) ; if ( $ old !== $ new ) { throw new Exception \ RuntimeException ( "Changing the invoice line's type is not supported." ) ; } } }
9685	public function setStorage ( $ storage , $ options = null ) { if ( ! $ storage instanceof Storage \ StorageInterface ) { $ storage = $ this -> getStoragePluginManager ( ) -> get ( $ storage , $ options ) ; } $ this -> storage = $ storage ; return $ this ; }
5806	public function validate ( ValidationResult $ result ) { $ validate = 'Title' ; $ class = $ this -> owner -> ClassName ; foreach ( Config :: inst ( ) -> get ( 'FusionService' , 'custom_tag_types' ) as $ type => $ field ) { if ( $ type === $ class ) { $ validate = $ field ; } } if ( $ result -> valid ( ) && ! $ this -> owner -> $ validate ) { $ result -> error ( "\"{$validate}\" required!" ) ; } $ this -> owner -> extend ( 'validateFusionExtension' , $ result ) ; return $ result ; }
1401	protected function isNoContent ( $ resource , $ links , $ meta ) { return is_null ( $ resource ) && empty ( $ links ) && empty ( $ meta ) ; }
3058	public function containsAdaptive ( ) { $ adaptiveSectionMap = $ this -> getServiceManager ( ) -> get ( CatService :: SERVICE_ID ) -> getAdaptiveSectionMap ( $ this -> getCompilationDirectory ( ) [ 'private' ] ) ; return ! empty ( $ adaptiveSectionMap ) ; }
7409	public function & offsetGet ( $ offset ) { if ( ! $ this -> offsetExists ( $ offset ) ) { $ this -> offsetSet ( $ offset , null ) ; if ( null === $ offset ) { end ( $ this -> _container ) ; $ offset = key ( $ this -> _container ) ; } } return $ this -> _container [ $ offset ] ; }
1022	private static function buildExecutionContext ( Schema $ schema , DocumentNode $ documentNode , $ rootValue , $ contextValue , $ rawVariableValues , $ operationName = null , ? callable $ fieldResolver = null , ? PromiseAdapter $ promiseAdapter = null ) { $ errors = [ ] ; $ fragments = [ ] ; $ operation = null ; $ hasMultipleAssumedOperations = false ; foreach ( $ documentNode -> definitions as $ definition ) { switch ( $ definition -> kind ) { case NodeKind :: OPERATION_DEFINITION : if ( ! $ operationName && $ operation ) { $ hasMultipleAssumedOperations = true ; } if ( ! $ operationName || ( isset ( $ definition -> name ) && $ definition -> name -> value === $ operationName ) ) { $ operation = $ definition ; } break ; case NodeKind :: FRAGMENT_DEFINITION : $ fragments [ $ definition -> name -> value ] = $ definition ; break ; } } if ( $ operation === null ) { if ( $ operationName ) { $ errors [ ] = new Error ( sprintf ( 'Unknown operation named "%s".' , $ operationName ) ) ; } else { $ errors [ ] = new Error ( 'Must provide an operation.' ) ; } } elseif ( $ hasMultipleAssumedOperations ) { $ errors [ ] = new Error ( 'Must provide operation name if query contains multiple operations.' ) ; } $ variableValues = null ; if ( $ operation !== null ) { [ $ coercionErrors , $ coercedVariableValues ] = Values :: getVariableValues ( $ schema , $ operation -> variableDefinitions ? : [ ] , $ rawVariableValues ? : [ ] ) ; if ( empty ( $ coercionErrors ) ) { $ variableValues = $ coercedVariableValues ; } else { $ errors = array_merge ( $ errors , $ coercionErrors ) ; } } if ( ! empty ( $ errors ) ) { return $ errors ; } Utils :: invariant ( $ operation , 'Has operation if no errors.' ) ; Utils :: invariant ( $ variableValues !== null , 'Has variables if no errors.' ) ; return new ExecutionContext ( $ schema , $ fragments , $ rootValue , $ contextValue , $ operation , $ variableValues , $ errors , $ fieldResolver , $ promiseAdapter ) ; }
4048	private function getFilterSettings ( ModelInterface $ model ) { $ filters = $ this -> connection -> createQueryBuilder ( ) -> select ( 'id' , 'name' ) -> from ( 'tl_metamodel_filter' ) -> where ( 'pid=:id' ) -> setParameter ( 'id' , $ model -> getProperty ( 'pid' ) ) -> execute ( ) -> fetchAll ( \ PDO :: FETCH_ASSOC ) ; $ result = [ ] ; foreach ( $ filters as $ filter ) { $ result [ $ filter [ 'id' ] ] = $ filter [ 'name' ] ; } return $ result ; }
4279	public function stream_seek ( $ offset , $ whence = SEEK_SET ) { if ( ! $ this -> handle ) { return false ; } self :: restorePrev ( ) ; $ result = \ fseek ( $ this -> handle , $ offset , $ whence ) ; $ success = $ result !== - 1 ; self :: register ( ) ; return $ success ; }
1666	protected function enableTwoFactor ( BackendUser $ user , $ return ) { if ( $ user -> useTwoFactor ) { return ; } $ container = System :: getContainer ( ) ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerificationHelp' ] ; $ authenticator = $ container -> get ( 'contao.security.two_factor.authenticator' ) ; if ( Input :: post ( 'FORM_SUBMIT' ) == 'tl_two_factor' ) { if ( $ authenticator -> validateCode ( $ user , Input :: post ( 'verify' ) ) ) { $ user -> useTwoFactor = '1' ; $ user -> save ( ) ; throw new RedirectResponseException ( $ return ) ; } $ this -> Template -> error = true ; $ verifyHelp = $ GLOBALS [ 'TL_LANG' ] [ 'ERR' ] [ 'invalidTwoFactor' ] ; } if ( ! $ user -> secret ) { $ user -> secret = random_bytes ( 128 ) ; $ user -> save ( ) ; } $ request = $ container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; $ this -> Template -> enable = true ; $ this -> Template -> secret = Base32 :: encodeUpperUnpadded ( $ user -> secret ) ; $ this -> Template -> textCode = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorTextCode' ] ; $ this -> Template -> qrCode = base64_encode ( $ authenticator -> getQrCode ( $ user , $ request ) ) ; $ this -> Template -> scan = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorScan' ] ; $ this -> Template -> verify = $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'twoFactorVerification' ] ; $ this -> Template -> verifyHelp = $ verifyHelp ; }
4144	public function get ( $ call , array $ getParams = null ) { $ this -> resetCallState ( ) ; $ this -> call = $ call ; $ this -> method = 'GET' ; if ( $ getParams !== null && is_array ( $ getParams ) ) { $ this -> getParams = $ getParams ; } $ response = $ this -> getResponse ( ) ; $ response [ 'body' ] = $ this -> findExceptions ( $ response ) ; $ this -> headers = $ response [ 'headers' ] ; unset ( $ call , $ getParams ) ; return $ this -> serializer -> format ( $ response [ 'body' ] ) ; }
4317	private static function getMethodDefaultArgs ( $ methodName ) { $ defaultArgs = array ( ) ; if ( isset ( self :: $ methodDefaultArgs [ $ methodName ] ) ) { $ defaultArgs = self :: $ methodDefaultArgs [ $ methodName ] ; } elseif ( \ method_exists ( self :: $ instance , $ methodName ) ) { $ reflectionMethod = new ReflectionMethod ( self :: $ instance , $ methodName ) ; $ params = $ reflectionMethod -> getParameters ( ) ; foreach ( $ params as $ reflectionParameter ) { $ defaultArgs [ ] = $ reflectionParameter -> isOptional ( ) ? $ reflectionParameter -> getDefaultValue ( ) : null ; } self :: $ methodDefaultArgs [ $ methodName ] = $ defaultArgs ; } return $ defaultArgs ; }
2263	public function listTables ( $ strDatabase = null , $ blnNoCache = false ) { if ( $ blnNoCache || ! isset ( $ this -> arrCache [ $ strDatabase ] ) ) { $ strOldDatabase = $ this -> resConnection -> getDatabase ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strDatabase ) ; } $ this -> arrCache [ $ strDatabase ] = $ this -> resConnection -> getSchemaManager ( ) -> listTableNames ( ) ; if ( $ strDatabase !== null && $ strDatabase != $ strOldDatabase ) { $ this -> setDatabase ( $ strOldDatabase ) ; } } return $ this -> arrCache [ $ strDatabase ] ; }
5568	public function put ( $ url , $ parameters = false , $ content_type = false ) { if ( ! is_object ( $ url ) ) { $ url = new SimpleUrl ( $ url ) ; } return $ this -> load ( $ url , new SimplePutEncoding ( $ parameters , $ content_type ) ) ; }
4376	protected function buildTableFooter ( $ keys ) { $ haveTotal = false ; $ cells = array ( ) ; foreach ( $ keys as $ key ) { $ colHasTotal = isset ( $ this -> tableInfo [ 'totals' ] [ $ key ] ) ; $ cells [ ] = $ colHasTotal ? $ this -> dump ( \ round ( $ this -> tableInfo [ 'totals' ] [ $ key ] , 6 ) , true , 'td' ) : '<td></td>' ; $ haveTotal = $ haveTotal || $ colHasTotal ; } if ( ! $ haveTotal ) { return '' ; } return '<tfoot>' . "\n" . '<tr><td>&nbsp;</td>' . ( $ this -> tableInfo [ 'haveObjRow' ] ? '<td>&nbsp;</td>' : '' ) . \ implode ( '' , $ cells ) . '</tr>' . "\n" . '</tfoot>' . "\n" ; }
8268	public function open ( ) { if ( $ this -> isOpened ( ) ) { return ; } if ( ! file_exists ( $ this -> filePath ) ) { throw new \ RuntimeException ( $ this -> filePath . " does not exist" ) ; } $ this -> handle = @ fopen ( $ this -> filePath , self :: OPEN_MODE ) ; if ( $ this -> handle === false ) { throw new \ RuntimeException ( "Could not open file for reading: " . $ this -> filePath ) ; } if ( ! $ this -> lock ( LOCK_SH ) ) { $ this -> close ( ) ; throw new \ RuntimeException ( "Could not aquire a shared lock for " . $ this -> filePath ) ; } }
7337	public function createClient ( ) : TgLog { $ this -> loop = Factory :: create ( ) ; $ handler = new HttpClientRequestHandler ( $ this -> loop ) ; return new TgLog ( $ this -> token , $ handler ) ; }
2897	public function replaceProfiler ( ) { $ connection = Mage :: getSingleton ( 'core/resource' ) -> getConnection ( 'core_write' ) ; $ currentProfile = $ connection -> getProfiler ( ) ; if ( $ currentProfile ) { $ this -> _queryProfiles = $ currentProfile -> _queryProfiles ; } $ this -> setEnabled ( $ currentProfile -> getEnabled ( ) ) ; $ connection -> setProfiler ( $ this ) ; }
1856	protected function getPageLayout ( $ objPage ) { $ objLayout = LayoutModel :: findByPk ( $ objPage -> layout ) ; if ( null === $ objLayout ) { $ this -> log ( 'Could not find layout ID "' . $ objPage -> layout . '"' , __METHOD__ , TL_ERROR ) ; throw new NoLayoutSpecifiedException ( 'No layout specified' ) ; } $ objPage -> hasJQuery = $ objLayout -> addJQuery ; $ objPage -> hasMooTools = $ objLayout -> addMooTools ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getPageLayout' ] as $ callback ) { $ this -> import ( $ callback [ 0 ] ) ; $ this -> { $ callback [ 0 ] } -> { $ callback [ 1 ] } ( $ objPage , $ objLayout , $ this ) ; } } return $ objLayout ; }
12783	protected function createIntersections ( ) { $ totalNumberOfCombinations = min ( pow ( 2 , $ this -> arraysSize ) , $ this -> maxNumberOfCombinations ) ; $ maskGenerator = new BitMaskGenerator ( $ this -> arraysSize , 2 ) ; $ i = 0 ; $ noresult = 0 ; while ( $ i < $ totalNumberOfCombinations && $ noresult < $ totalNumberOfCombinations && $ mask = $ maskGenerator -> getNextMask ( ) ) { if ( ! $ this -> isNoResultMask ( $ mask ) ) { $ i ++ ; $ this -> generateIntersection ( $ mask ) ; continue ; } $ noresult ++ ; } if ( ! is_null ( $ this -> intersections ) ) { uasort ( $ this -> intersections , function ( $ a , $ b ) { return count ( $ b ) - count ( $ a ) ; } ) ; } }
2077	public function purgeScriptCache ( ) { foreach ( array ( 'assets/js' , 'assets/css' ) as $ dir ) { $ objFolder = new Folder ( $ dir ) ; $ objFolder -> purge ( ) ; } $ this -> import ( StyleSheets :: class , 'StyleSheets' ) ; $ this -> StyleSheets -> updateStyleSheets ( ) ; $ this -> purgePageCache ( ) ; $ this -> log ( 'Purged the script cache' , __METHOD__ , TL_CRON ) ; }
4592	public function submit ( $ id , array $ variables ) { foreach ( $ variables as $ variable ) { if ( ! $ variable instanceof Variable ) { throw new InvalidArgumentException ( 'Array of variables is not valid.' ) ; } } $ resource = str_replace ( '{id}' , $ id , static :: RESOURCE_SUBMIT ) ; $ options = [ 'headers' => [ 'Accept' => 'application/json' , 'Content-Type' => 'application/json' ] ] ; foreach ( $ variables as $ variable ) { $ options [ 'json' ] [ 'variables' ] [ $ variable -> getName ( ) ] = [ 'value' => Variable :: TYPE_JSON === $ variable -> getType ( ) ? json_encode ( $ variable -> getValue ( ) ) : $ variable -> getValue ( ) , 'type' => $ variable -> getType ( ) ] ; } $ this -> execute ( 'POST' , $ resource , $ options ) ; }
9038	protected function execute ( QueryBuilder $ builder ) : ? Result { return $ this -> connection -> queryArgs ( $ builder -> getQuerySql ( ) , $ builder -> getQueryParameters ( ) ) ; }
7137	private function readNumber ( ) { if ( false === $ this -> handle = fopen ( $ this -> filePath , 'c+' ) ) { throw new RuntimeException ( "Failed to open file {$this->filePath}." ) ; } if ( ! flock ( $ this -> handle , LOCK_EX ) ) { throw new RuntimeException ( "Failed to lock file {$this->filePath}." ) ; } return fread ( $ this -> handle , $ this -> length ) ; }
1093	protected function getFreshInstance ( ) { if ( $ this -> areSoftDeletesEnabled ( ) ) return static :: withTrashed ( ) -> find ( $ this -> getKey ( ) ) ; return static :: find ( $ this -> getKey ( ) ) ; }
3078	protected function hasChannel ( $ channelName , $ channelType ) { $ channels = $ this -> getOption ( self :: OPTION_CHANNELS ) ; return isset ( $ channels [ $ channelType ] [ $ channelName ] ) ; }
7487	public function lastIndexOf ( $ string , $ offset = null ) { $ string = static :: convertString ( $ string , $ this -> encoding ) ; $ offset = $ offset !== null ? ( int ) $ offset : null ; if ( $ offset !== null && ( $ offset < 0 || $ offset >= $ this -> length ( ) ) ) { throw new \ OutOfBoundsException ( ) ; } return mb_strrpos ( $ this -> string , $ string , $ offset , $ this -> encoding ) ; }
5470	protected function describePatternMatch ( $ pattern , $ subject ) { preg_match ( $ pattern , $ subject , $ matches ) ; $ position = strpos ( $ subject , $ matches [ 0 ] ) ; $ dumper = $ this -> getDumper ( ) ; return "Pattern [$pattern] detected at character [$position] in [" . $ dumper -> describeValue ( $ subject ) . '] as [' . $ matches [ 0 ] . '] in region [' . $ dumper -> clipString ( $ subject , 100 , $ position ) . ']' ; }
9563	protected function callHandler ( $ handler , Exception $ exception ) { if ( $ handler instanceof ErrorHandlerInterface ) { return $ handler -> handle ( $ exception ) ; } return call_user_func ( $ handler , $ exception ) ; }
518	private function generateClassName ( $ name ) { $ namespace = null ; $ name = trim ( $ name , '\\' ) ; if ( strpos ( $ name , '\\' ) !== false ) { $ namespace = substr ( $ name , 0 , strrpos ( $ name , '\\' ) ) ; $ name = substr ( $ name , strrpos ( $ name , '\\' ) + 1 ) ; } else { if ( $ this -> migrationPath === null ) { $ migrationNamespaces = $ this -> migrationNamespaces ; $ namespace = array_shift ( $ migrationNamespaces ) ; } } if ( $ namespace === null ) { $ class = 'm' . gmdate ( 'ymd_His' ) . '_' . $ name ; } else { $ class = 'M' . gmdate ( 'ymdHis' ) . ucfirst ( $ name ) ; } return [ $ namespace , $ class ] ; }
4929	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { foreach ( $ this -> listenerSpecs as $ name => $ spec ) { $ this -> listeners [ ] = $ events -> attach ( $ spec [ 'event' ] , array ( $ this , "do$name" ) , $ spec [ 'priority' ] ) ; } }
8510	public function getTransportContent ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_GetTransportContentRequest ) ) { $ request = new FBAInboundServiceMWS_Model_GetTransportContentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetTransportContent' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_GetTransportContentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
8446	private function convertQuestion ( Question $ question ) { $ buttons = Collection :: make ( $ question -> getButtons ( ) ) -> map ( function ( $ button ) { return [ 'label' => $ button [ 'text' ] , 'metadata' => $ button [ 'value' ] ] ; } ) ; return [ 'text' => $ question -> getText ( ) , 'quick_reply' => [ 'type' => 'options' , 'options' => $ buttons -> toArray ( ) , ] , ] ; }
8546	public function setChargebackEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargebackEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2942	protected static function unitNameOrAliasesAlreadyRegistered ( UnitOfMeasureInterface $ unit ) { if ( ! is_array ( static :: $ unitDefinitions ) ) { static :: $ unitDefinitions = [ ] ; static :: initialize ( ) ; } $ currentUnitNamesAndAliases = [ ] ; foreach ( static :: $ unitDefinitions as $ unitOfMeasure ) { $ currentUnitNamesAndAliases [ ] = $ unitOfMeasure -> getName ( ) ; $ currentUnitNamesAndAliases = array_merge ( $ currentUnitNamesAndAliases , $ unitOfMeasure -> getAliases ( ) ) ; } $ newUnitNamesAndAliases = array_merge ( [ $ unit -> getName ( ) ] , $ unit -> getAliases ( ) ) ; return count ( array_intersect ( $ currentUnitNamesAndAliases , $ newUnitNamesAndAliases ) ) > 0 ; }
9497	protected function getOne ( $ end_point ) { $ end_point = strtolower ( $ end_point ) ; if ( strpos ( $ end_point , 'http' ) !== 0 ) { $ end_point = $ this -> api -> getApiUrl ( ) . $ end_point ; } $ request = $ this -> api -> get ( $ end_point ) ; $ response = $ this -> processRequest ( $ request ) ; $ result = $ response -> json ( ) ; $ type = $ this -> getType ( ) ; $ className = explode ( '\\' , $ type ) ; $ baseName = strtolower ( end ( $ className ) ) ; if ( $ result && isset ( $ result [ $ baseName ] ) ) { $ t = new $ type ( ) ; $ t -> setManagingClient ( $ this ) ; return $ t -> fromArray ( $ result [ $ baseName ] ) ; } return null ; }
11886	public function addChild ( $ structureName , $ prefix = '' , $ suffix = '' ) { if ( isset ( $ this -> children [ $ structureName ] ) ) { throw new DefinitionDuplicateException ( sprintf ( 'Child structure with same name "%s" already exists' , $ structureName ) ) ; } $ this -> children [ $ structureName ] = array ( 'name' => $ structureName , 'prefix' => ( string ) $ prefix , 'suffix' => ( string ) $ suffix ) ; }
5795	public function insert ( array $ columnValues , bool $ addBooleanColumnFalse = false ) { if ( $ addBooleanColumnFalse ) { $ columnValues = $ this -> addBooleanColumnFalse ( $ columnValues ) ; } $ ib = new InsertBuilder ( $ this -> tableName ) ; if ( $ this -> getPrimaryKeyColumnName ( ) !== null ) { $ ib -> setPrimaryKeyName ( $ this -> getPrimaryKeyColumnName ( ) ) ; } $ this -> addColumnsToBuilder ( $ ib , $ columnValues ) ; return $ ib -> runExecute ( ) ; }
12909	public function all ( ) { $ _filters = $ this -> filters ; if ( ! $ this -> allowDeleted ) { $ this -> filters = array ( "`" . $ this -> table . "`.deleted = 0" ) ; } else { $ this -> filters = array ( ) ; } $ values = $ this -> values ( ) ; $ this -> filters = $ _filters ; return $ values ; }
8673	private function iterateReverseFromIndex ( $ fromIndex ) { Assert :: nullOrInteger ( $ fromIndex ) ; $ index = count ( $ this -> items ) ; if ( $ index === 0 ) { return ; } if ( $ fromIndex !== null ) { $ index = $ fromIndex < 0 ? max ( $ index + $ fromIndex , 1 ) : min ( $ fromIndex + 1 , $ index ) ; } $ keys = array_keys ( $ this -> items ) ; while ( -- $ index >= 0 ) { $ key = $ keys [ $ index ] ; yield $ key => $ this -> items [ $ key ] ; } }
12688	protected function load ( $ namespace , $ require = false ) { if ( isset ( $ this -> cache [ $ namespace ] ) ) { return $ this -> cache [ $ namespace ] ; } $ file = $ this -> getConfigFile ( $ namespace ) ; $ configuration = null ; try { $ configFile = new YamlConfiguration ( $ file ) ; $ configuration = $ configFile -> get ( ) ; if ( is_array ( $ configuration ) && ! empty ( $ configuration [ 'inherits' ] ) ) { $ allConfiguration = [ ] ; foreach ( $ configuration [ 'inherits' ] as $ parentNamespace ) { $ allConfiguration [ ] = $ this -> load ( $ parentNamespace ) ; } $ allConfiguration [ ] = $ configuration ; $ configuration = $ this -> merge ( $ allConfiguration ) ; unset ( $ allConfiguration , $ configuration [ 'inherits' ] ) ; } unset ( $ configFile ) ; } catch ( FileNotFoundException $ e ) { if ( $ require ) { throw new FileNotFoundException ( 'Could not find settings file for ' . $ namespace ) ; } } return $ this -> cache [ $ namespace ] = $ configuration ; }
3280	protected function normalizeConfig ( array $ config ) : array { $ defaultConfig = [ 'dir' => getcwd ( ) , 'ext' => '.dat' , 'gzip' => false , 'cache' => true , 'formatter' => null , 'swap_memory_limit' => 2097152 , ] ; return array_replace ( $ defaultConfig , $ config ) ; }
3003	public function attachFile ( $ path , $ alias = null , $ cid = null ) { $ this -> smtp -> attach ( $ path , $ alias , $ cid ) ; }
12050	public function initClient ( $ headers ) { try { $ this -> request = new Client ( $ headers ) ; } catch ( Exception $ e ) { echo 'Unable to initialise http client because ' . $ e -> getMessage ( ) . "\n" ; } }
12230	public function deleteNodes ( $ xpath ) { if ( ! is_string ( $ xpath ) ) { throw new InvalidArgumentException ( 'Argument 1 passed to deleteNodes() must be a string, ' . gettype ( $ xpath ) . ' given' ) ; } $ nodes = $ this -> _xpath ( $ xpath ) ; if ( isset ( $ nodes [ 0 ] ) ) { $ tmp = dom_import_simplexml ( $ nodes [ 0 ] ) ; if ( $ tmp -> isSameNode ( $ tmp -> ownerDocument -> documentElement ) ) { unset ( $ nodes [ 0 ] ) ; } } foreach ( $ nodes as $ node ) { $ node -> deleteSelf ( ) ; } return count ( $ nodes ) ; }
4206	private function getPropInfo ( Event $ abs , \ ReflectionProperty $ reflectionProperty ) { $ obj = $ abs -> getSubject ( ) ; $ reflectionProperty -> setAccessible ( true ) ; $ className = \ get_class ( $ obj ) ; $ commentInfo = $ this -> getPropCommentInfo ( $ reflectionProperty ) ; $ declaringClassName = $ reflectionProperty -> getDeclaringClass ( ) -> getName ( ) ; $ propInfo = \ array_merge ( static :: $ basePropInfo , array ( 'desc' => $ commentInfo [ 'desc' ] , 'inheritedFrom' => $ declaringClassName !== $ className ? $ declaringClassName : null , 'isStatic' => $ reflectionProperty -> isStatic ( ) , 'type' => $ commentInfo [ 'type' ] , ) ) ; if ( $ reflectionProperty -> isPrivate ( ) ) { $ propInfo [ 'visibility' ] = 'private' ; } elseif ( $ reflectionProperty -> isProtected ( ) ) { $ propInfo [ 'visibility' ] = 'protected' ; } if ( $ abs [ 'collectPropertyValues' ] ) { $ propName = $ reflectionProperty -> getName ( ) ; if ( \ array_key_exists ( $ propName , $ abs [ 'propertyOverrideValues' ] ) ) { $ propInfo [ 'value' ] = $ abs [ 'propertyOverrideValues' ] [ $ propName ] ; $ propInfo [ 'valueFrom' ] = 'debug' ; } else { $ propInfo [ 'value' ] = $ reflectionProperty -> getValue ( $ obj ) ; } } return $ propInfo ; }
6003	public function addVideoTemplate ( $ item ) { if ( ! ( $ item instanceof VideoTemplate ) ) { if ( is_array ( $ item ) ) { try { $ item = new VideoTemplate ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate VideoTemplate. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } else { trigger_error ( 'Array parameter item is not of expected type "VideoTemplate"!' , E_USER_WARNING ) ; } } $ this -> videotemplates [ ] = $ item ; return $ this ; }
4160	public function getLoginUrl ( $ scope = array ( ) , $ state = null ) { $ scope = $ this -> mergeScope ( $ scope ) ; $ state = is_string ( $ state ) ? "&state={$state}" : '' ; return self :: API_OAUTH_URL . '?client_id=' . $ this -> getApiKey ( ) . '&redirect_uri=' . urlencode ( $ this -> getApiCallback ( ) ) . '&scope=' . implode ( '+' , $ scope ) . '&response_type=code' . $ state ; }
7127	public function getDetails ( ) { return [ 'valid' => $ this -> valid , 'country' => $ this -> country , 'number' => $ this -> number , 'name' => $ this -> name , 'address' => $ this -> address , 'date' => $ this -> date , ] ; }
5153	public function addConfiguration ( $ configuration , $ configure = true ) { if ( ! $ configuration instanceof ConfigurationInterface ) { $ configuration = new Configuration ( $ configuration ) ; } $ config = $ this -> getConfiguration ( ) ; if ( $ config instanceof ConfigurationInterface ) { $ config -> merge ( $ configuration ) ; } if ( $ config === null ) { $ config = $ configuration ; } $ this -> setConfiguration ( $ config , $ configure ) ; }
3790	private function determineLanguages ( ) { $ languages = $ this -> getMetaModel ( ) -> getAvailableLanguages ( ) ; if ( $ languages === null ) { throw new \ RuntimeException ( 'MetaModel ' . $ this -> getMetaModel ( ) -> getName ( ) . ' does not seem to be translated.' ) ; } return $ languages ; }
1129	public function getLeftSibling ( ) { return $ this -> siblings ( ) -> where ( $ this -> getLeftColumnName ( ) , '<' , $ this -> getLeft ( ) ) -> orderBy ( $ this -> getOrderColumnName ( ) , 'desc' ) -> get ( ) -> last ( ) ; }
10325	protected function setOptions ( array $ options ) { if ( ! array_key_exists ( 'adapter' , $ options ) || ! array_key_exists ( 'table' , $ options ) || ! array_key_exists ( 'column_key' , $ options ) || ! array_key_exists ( 'column_value' , $ options ) ) { throw new Exception \ InvalidArgumentException ( 'Db adapter options must be defined "adapter", "table", "column_key" and "column_value" keys.' ) ; } if ( ! $ options [ 'adapter' ] instanceof Adapter ) { throw new Exception \ InvalidArgumentException ( 'Db adapter must be an instance of Zend\Db\Adapter\Adapter.' ) ; } $ this -> adapter = $ options [ 'adapter' ] ; $ options [ 'table' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'table' ] ) ; $ options [ 'column_key' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_key' ] ) ; $ options [ 'column_value' ] = $ this -> adapter -> getPlatform ( ) -> quoteIdentifier ( $ options [ 'column_value' ] ) ; $ this -> options = $ options ; return $ this ; }
6331	private function registerPostProcessor ( string $ type , string $ class ) : void { if ( \ class_exists ( $ class ) ) { $ interfaces = \ class_implements ( $ class ) ; if ( \ in_array ( PostProcessor :: class , $ interfaces , true ) ) { $ this -> postProcessorsMap [ $ type ] = $ class ; } else { throw new ConfigException ( "Class {$class} don't implement interface " . PostProcessor :: class ) ; } } else { throw new ConfigException ( "Class {$class} not found" ) ; } }
9536	private function prefixExists ( $ parameter ) { $ prefixExists = false ; foreach ( array_keys ( $ this -> parameterCluster -> prefixes ) as $ prefix ) { if ( substr ( $ parameter , 0 , strlen ( $ prefix ) ) == $ prefix ) { $ prefixExists = true ; break ; } } return $ prefixExists ; }
9820	public function getColumn ( $ pColumn ) { $ this -> testColumnInRange ( $ pColumn ) ; if ( ! isset ( $ this -> columns [ $ pColumn ] ) ) { $ this -> columns [ $ pColumn ] = new AutoFilter \ Column ( $ pColumn , $ this ) ; } return $ this -> columns [ $ pColumn ] ; }
2134	public static function remove ( $ strKey ) { $ objConfig = static :: getInstance ( ) ; if ( strncmp ( $ strKey , '$GLOBALS' , 8 ) !== 0 ) { $ strKey = "\$GLOBALS['TL_CONFIG']['$strKey']" ; } $ objConfig -> delete ( $ strKey ) ; }
11961	public function each ( Closure $ fn ) { foreach ( $ this -> elements as $ key => $ element ) { if ( $ fn ( $ element , $ key ) === false ) { return false ; } } return true ; }
7240	private function resolveClassAndCreateObject ( $ type , $ subject ) { foreach ( $ this -> classes [ $ type ] as $ source => $ target ) { if ( $ subject instanceof $ source ) { return new $ target ; } } throw new InvalidArgumentException ( 'Unsupported object class.' ) ; }
8916	public function parseSubjectAddedEntry ( QuiteSimpleXmlElement & $ node ) { $ out = array ( 'term' => '' , 'vocabulary' => null ) ; $ vocabularies = array ( '0' => 'lcsh' , '1' => 'lccsh' , '2' => 'mesh' , '3' => 'atg' , '5' => 'cash' , '6' => 'rvm' , ) ; $ ind2 = $ node -> attr ( 'ind2' ) ; $ id = $ node -> text ( 'marc:subfield[@code="0"]' ) ; $ out [ 'id' ] = empty ( $ id ) ? null : $ id ; if ( isset ( $ vocabularies [ $ ind2 ] ) ) { $ out [ 'vocabulary' ] = $ vocabularies [ $ ind2 ] ; } elseif ( $ ind2 == '7' ) { $ vocab = $ node -> text ( 'marc:subfield[@code="2"]' ) ; if ( ! empty ( $ vocab ) ) { $ out [ 'vocabulary' ] = $ vocab ; } } elseif ( $ ind2 == '4' ) { $ this -> parseAuthority ( $ node -> text ( 'marc:subfield[@code="0"]' ) , $ out ) ; } $ out [ 'parts' ] = array ( ) ; $ subdivtypes = array ( 'v' => 'form' , 'x' => 'general' , 'y' => 'chronologic' , 'z' => 'geographic' , ) ; foreach ( $ node -> all ( 'marc:subfield' ) as $ subdiv ) { $ code = $ subdiv -> attr ( 'code' ) ; if ( in_array ( $ code , array_keys ( $ subdivtypes ) ) ) { $ subdiv = trim ( $ subdiv , '.' ) ; $ out [ 'parts' ] [ ] = array ( 'value' => $ subdiv , 'type' => $ subdivtypes [ $ code ] ) ; $ out [ 'term' ] .= self :: $ subfieldSeparator . $ subdiv ; } } return $ out ; }
7760	protected function detectMetadataDriver ( $ dir , ContainerBuilder $ container ) { $ configPath = $ this -> getMappingResourceConfigDirectory ( ) ; $ resource = $ dir . '/' . $ configPath ; while ( ! is_dir ( $ resource ) ) { $ resource = dirname ( $ resource ) ; } $ container -> addResource ( new FileResource ( $ resource ) ) ; $ extension = $ this -> getMappingResourceExtension ( ) ; if ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.xml' ) ) && count ( $ files ) ) { return 'xml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.yml' ) ) && count ( $ files ) ) { return 'yml' ; } elseif ( ( $ files = glob ( $ dir . '/' . $ configPath . '/*.' . $ extension . '.php' ) ) && count ( $ files ) ) { return 'php' ; } $ container -> addResource ( new FileResource ( $ dir ) ) ; if ( is_dir ( $ dir . '/' . $ this -> getMappingObjectDefaultName ( ) ) ) { return 'annotation' ; } return null ; }
1545	public function decodes ( string ... $ mediaTypes ) : bool { if ( ! $ decoding = $ this -> getDecodingMediaType ( ) ) { return false ; } return collect ( $ mediaTypes ) -> contains ( function ( $ mediaType , $ index ) use ( $ decoding ) { return $ decoding -> equalsTo ( MediaType :: parse ( $ index , $ mediaType ) ) ; } ) ; }
2557	protected function loadMopDetails ( MopInfo $ options ) { $ this -> mopDetails = new MopDetails ( ) ; if ( $ this -> checkAnyNotEmpty ( $ options -> fopCode , $ options -> fopStatus ) ) { $ this -> mopDetails -> fopPNRDetails = new FopPNRDetails ( $ options -> fopCode , $ options -> fopStatus ) ; } if ( ! empty ( $ options -> freeFlowText ) ) { $ this -> mopDetails -> oldFopFreeflow = new OldFopFreeflow ( $ options -> freeFlowText , $ options -> freeFlowEncoding ) ; } if ( ! empty ( $ options -> supplementaryData ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_DATA_INFORMATION , $ options -> supplementaryData ) ; } if ( ! empty ( $ options -> supplementarySwitches ) ) { $ this -> mopDetails -> pnrSupplementaryData [ ] = new PnrSupplementaryData ( DataAndSwitchMap :: TYPE_SWITCH_INFORMATION , $ options -> supplementarySwitches ) ; } }
7541	function setIndex ( $ index ) { if ( $ this -> parent ) { if ( $ index > $ this -> index ( ) ) { -- $ index ; } $ this -> delete ( ) ; $ this -> parent -> addChild ( $ this , $ index ) ; } }
7594	public function render ( $ sLabelMessage , $ aLabelAttributes = 'label-default' ) { if ( ! is_scalar ( $ sLabelMessage ) ) { throw new InvalidArgumentException ( 'Label message expects a scalar value, "' . gettype ( $ sLabelMessage ) . '" given' ) ; } if ( empty ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes are empty' ) ; } if ( is_string ( $ aLabelAttributes ) ) { $ aLabelAttributes = array ( 'class' => $ aLabelAttributes ) ; } elseif ( ! is_array ( $ aLabelAttributes ) ) { throw new InvalidArgumentException ( 'Label attributes expects a string or an array, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } elseif ( empty ( $ aLabelAttributes [ 'class' ] ) ) { throw new \ InvalidArgumentException ( 'Label "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aLabelAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Label "class" attribute expects string, "' . gettype ( $ aLabelAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)label(\s|$)/' , $ aLabelAttributes [ 'class' ] ) ) { $ aLabelAttributes [ 'class' ] .= ' label' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sLabelMessage = $ oTranslator -> translate ( $ sLabelMessage , $ this -> getTranslatorTextDomain ( ) ) ; } return sprintf ( static :: $ labelFormat , isset ( $ aLabelAttributes [ 'tagName' ] ) ? $ aLabelAttributes [ 'tagName' ] : $ this -> tagName , $ this -> createAttributesString ( $ aLabelAttributes ) , $ sLabelMessage ) ; }
8738	protected function filterValues ( array $ values ) { $ attributes = $ this -> model -> translatableAttributes ( ) ; $ translatable = [ ] ; foreach ( $ attributes as $ key ) { if ( array_key_exists ( $ key , $ values ) ) { $ translatable [ $ key ] = $ values [ $ key ] ; unset ( $ values [ $ key ] ) ; } } return [ $ values , $ translatable ] ; }
7048	protected function formatPhoneNumber ( PhoneNumber $ number = null ) { if ( $ number ) { return $ this -> phoneNumberUtil -> format ( $ number , PhoneNumberFormat :: INTERNATIONAL ) ; } return null ; }
2049	private function executeHook ( string $ message , ContaoContext $ context ) : void { if ( null === $ this -> container || ! $ this -> container -> has ( 'contao.framework' ) ) { return ; } $ framework = $ this -> container -> get ( 'contao.framework' ) ; if ( ! $ this -> hasAddLogEntryHook ( ) || ! $ framework -> isInitialized ( ) ) { return ; } @ trigger_error ( 'Using the addLogEntry hook has been deprecated and will no longer work in Contao 5.0.' , E_USER_DEPRECATED ) ; $ system = $ framework -> getAdapter ( System :: class ) ; $ func = $ context -> getFunc ( ) ; $ action = $ context -> getAction ( ) ; foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'addLogEntry' ] as $ callback ) { $ system -> importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ message , $ func , $ action ) ; } }
7908	protected function renderDropdown ( ) { $ lines = [ ] ; $ lines [ ] = $ this -> encodeText ? Html :: encode ( $ this -> text ) : $ this -> text ; if ( $ this -> icon && is_string ( $ this -> icon ) ) { $ lines [ ] = $ this -> icon ; } $ lines [ ] = $ this -> renderItems ( $ this -> items , $ this -> options , $ this -> displaySearchInput ) ; return Html :: tag ( 'div' , implode ( "\n" , $ lines ) , $ this -> options ) ; }
7229	public static function create ( $ method , $ url , $ data = "" , array $ headers = [ ] , array $ options = [ ] , $ initOnly = false ) { $ curl = null ; if ( ! strcasecmp ( $ method , "GET" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "GET" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "POST" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "POST" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "PUT" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "PUT" , CURLOPT_POSTFIELDS => $ data , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; else if ( ! strcasecmp ( $ method , "DELETE" ) ) $ curl = new static ( $ url , $ options + [ CURLOPT_CUSTOMREQUEST => "DELETE" , CURLOPT_RETURNTRANSFER => true ] , $ headers , $ initOnly ) ; return $ curl ; }
12808	private static function getPrimaryKey ( string $ table ) : array { if ( self :: $ primaryKeyCache !== null && array_key_exists ( $ table , self :: $ primaryKeyCache ) ) return self :: $ primaryKeyCache [ $ table ] ; $ pdo = Database :: connect ( ) ; $ query = " SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = 'PRIMARY KEY' AND tc.table_name = '$table' " ; $ results = $ pdo -> query ( $ query ) ; self :: $ primaryKeyCache [ $ table ] = $ results -> fetch ( ) ; return self :: $ primaryKeyCache [ $ table ] ; }
12341	protected function printError ( \ Throwable $ error , bool $ withTime = true , ? string $ fontColor = null , ? string $ bgColor = self :: BG_COLOR_MAP [ 'red' ] ) : void { $ shift = $ withTime ? "\t\t" : '' ; $ this -> print ( $ this -> getColoredMsg ( 'Error: ' . $ error -> getMessage ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'File: ' . $ error -> getFile ( ) , $ fontColor , $ bgColor ) . \ PHP_EOL . $ shift . $ this -> getColoredMsg ( 'Line: ' . $ error -> getLine ( ) , $ fontColor , $ bgColor ) , $ withTime ) ; }
1628	public function useDailyFiles ( $ path , $ days = 0 , $ level = 'debug' ) { foreach ( $ this -> loggers as $ logger ) { if ( $ logger instanceof Log ) { $ logger -> useDailyFiles ( $ path , $ days , $ level ) ; } } }
3114	public function clearEvents ( $ testSessionId ) { $ extendedState = $ this -> getExtendedState ( $ testSessionId ) ; $ extendedState -> clearEvents ( ) ; $ extendedState -> save ( ) ; }
3205	protected function get_docblock_tags ( $ comment_opener ) { $ tags = array ( ) ; $ opener = $ this -> tokens [ $ comment_opener ] ; if ( ! isset ( $ opener [ 'comment_tags' ] ) ) { return $ tags ; } $ closer = null ; if ( isset ( $ opener [ 'comment_closer' ] ) ) { $ closer = $ opener [ 'comment_closer' ] ; } $ tag_count = count ( $ opener [ 'comment_tags' ] ) ; for ( $ i = 0 ; $ i < $ tag_count ; $ i ++ ) { $ tag_token = $ opener [ 'comment_tags' ] [ $ i ] ; $ tag = trim ( $ this -> tokens [ $ tag_token ] [ 'content' ] , '@' ) ; $ search_end = $ closer ; if ( ( $ i + 1 ) < $ tag_count ) { $ search_end = $ opener [ 'comment_tags' ] [ ( $ i + 1 ) ] ; } $ value_token = $ this -> phpcsFile -> findNext ( T_DOC_COMMENT_STRING , ( $ tag_token + 1 ) , $ search_end ) ; $ tags [ $ tag ] = trim ( $ this -> tokens [ $ value_token ] [ 'content' ] ) ; unset ( $ tag_token , $ tag , $ search_end , $ value ) ; } return $ tags ; }
5165	public function render ( DataBuilder $ data_builder , $ parameters , array $ data = [ ] ) { $ parameters = $ this -> castParameters ( $ parameters ) ; $ tm = new TemplateManager ( ) ; $ result = new Result ( ) ; try { $ bag = new Bag ( $ parameters ) ; $ bag -> set ( 'body' , $ tm -> renderRaw ( 'text/html' , strval ( $ bag -> get ( 'body' ) ) , $ data ) ) ; $ attachments = [ ] ; foreach ( ( array ) Yaml :: parse ( strval ( $ bag -> get ( 'attachments' ) ) ) as $ key => $ attachment ) { $ attachment = ( object ) $ attachment ; $ attachments [ $ key ] [ 'as' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> as , $ data ) ) ; $ attachments [ $ key ] [ 'source' ] = strval ( $ tm -> renderRaw ( 'text/plain' , $ attachment -> source , $ data ) ) ; } $ bag -> set ( 'attachments' , $ attachments ) ; $ bag -> set ( 'recipients' , explode ( ',' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'recipients' ) ) , $ data ) ) ) ; $ bag -> set ( 'subject' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'subject' ) ) , $ data ) ) ; $ bag -> set ( 'sender' , $ tm -> renderRaw ( 'text/plain' , strval ( $ bag -> get ( 'sender' ) ) , $ data ) ) ; $ result -> setResources ( new Collection ( [ $ bag -> toArray ( ) ] ) ) ; } catch ( \ Twig_Error $ e ) { $ e = new Exceptions \ EmailSenderRenderException ( $ e -> getRawMessage ( ) . ' on line ' . $ e -> getTemplateLine ( ) ) ; $ result -> addErrors ( new Collection ( [ $ e ] ) ) ; } return $ result ; }
1892	public function accept ( ) { if ( strncmp ( $ this -> current ( ) -> getFilename ( ) , '.' , 1 ) === 0 ) { return false ; } $ strPath = $ this -> current ( ) -> getPathname ( ) ; if ( is_file ( $ strPath ) ) { $ strPath = \ dirname ( $ strPath ) ; } $ objFolder = new Folder ( StringUtil :: stripRootDir ( $ strPath ) ) ; return ! $ objFolder -> isUnsynchronized ( ) ; }
2348	public static function putContent ( $ strFile , $ strContent ) { $ objFile = new static ( $ strFile ) ; $ objFile -> write ( $ strContent ) ; $ objFile -> close ( ) ; }
5397	public function paintMessage ( $ message ) { parent :: paintMessage ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'message>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "message>\n" ; }
4927	public function setListeners ( array $ specs ) { foreach ( $ specs as $ spec ) { if ( ! isset ( $ spec [ 'event' ] ) || ! isset ( $ spec [ 'service' ] ) ) { throw new \ DomainException ( 'Listener specification must be an array with the keys "event" and "service".' ) ; } $ method = isset ( $ spec [ 'method' ] ) ? $ spec [ 'method' ] : null ; $ priority = isset ( $ spec [ 'priority' ] ) ? $ spec [ 'priority' ] : 0 ; $ this -> setListener ( $ spec [ 'event' ] , $ spec [ 'service' ] , $ method , $ priority ) ; } return $ this ; }
10083	protected function registerRouter ( ) { $ this -> app -> singleton ( 'auja.router' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; return new AujaRouter ( $ app [ 'auja' ] , $ app [ 'router' ] , $ config [ 'route' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Routing\AujaRouter' , 'auja.router' ) ; }
4696	public static function getToken ( $ token_name = self :: TOKEN_NAME ) { if ( empty ( $ _SESSION [ $ token_name ] ) ) { static :: generateToken ( $ token_name ) ; } return $ _SESSION [ $ token_name ] ; }
4081	public function getRenderSetting ( $ metaModel ) { $ metaModelName = $ this -> getMetaModelName ( $ metaModel ) ; return isset ( $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] ) ? $ this -> information [ $ metaModelName ] [ self :: COMBINATION ] [ 'view_id' ] : null ; }
4378	protected function buildTableRow ( $ row , $ keys , $ rowKey ) { $ str = '' ; $ values = $ this -> debug -> methodTable -> keyValues ( $ row , $ keys , $ objInfo ) ; $ parsed = $ this -> debug -> utilities -> parseTag ( $ this -> dump ( $ rowKey ) ) ; $ str .= '<tr>' ; $ str .= $ this -> debug -> utilities -> buildTag ( 'th' , array ( 'class' => 't_key text-right ' . $ parsed [ 'attribs' ] [ 'class' ] , 'scope' => 'row' , ) , $ parsed [ 'innerhtml' ] ) ; if ( $ objInfo [ 'row' ] ) { $ str .= $ this -> markupClassname ( $ objInfo [ 'row' ] [ 'className' ] , 'td' , array ( 'title' => $ objInfo [ 'row' ] [ 'phpDoc' ] [ 'summary' ] ? : null , ) ) ; $ this -> tableInfo [ 'haveObjRow' ] = true ; } else { $ str .= '<td class="t_classname"></td>' ; } foreach ( $ values as $ v ) { $ str .= $ this -> dump ( $ v , true , 'td' ) ; } $ str .= '</tr>' . "\n" ; $ str = \ str_replace ( ' title=""' , '' , $ str ) ; foreach ( \ array_keys ( $ this -> tableInfo [ 'totals' ] ) as $ k ) { $ this -> tableInfo [ 'totals' ] [ $ k ] += $ values [ $ k ] ; } foreach ( $ objInfo [ 'cols' ] as $ k2 => $ classname ) { if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === false ) { continue ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] === null ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = $ classname ; } if ( $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] !== $ classname ) { $ this -> tableInfo [ 'colClasses' ] [ $ k2 ] = false ; } } return $ str ; }
9060	public function setPrimaryKey ( string ... $ key ) : self { $ this -> primaryKey = new PrimaryKey ( $ this , ... $ key ) ; return $ this ; }
6932	private function isShipmentAmountInvoiced ( Invoice \ InvoiceInterface $ invoice ) { $ sale = $ invoice -> getSale ( ) ; foreach ( $ sale -> getInvoices ( ) as $ i ) { if ( $ i === $ invoice ) { continue ; } if ( $ i -> hasLineByType ( Document \ DocumentLineTypes :: TYPE_SHIPMENT ) ) { return true ; } } return false ; }
1014	private function moveStringCursor ( $ positionOffset , $ byteStreamOffset ) { $ this -> position += $ positionOffset ; $ this -> byteStreamPosition += $ byteStreamOffset ; return $ this ; }
2796	public function setAdapterOptionsFromString ( $ optionString ) { $ this -> adapterOptions = array_merge ( $ this -> adapterOptions , explode ( ' ' , $ optionString ) ) ; return $ this ; }
1625	public static function updateAllCounters ( $ counters , $ condition = null ) { if ( empty ( $ counters ) ) { return 0 ; } $ db = static :: getDb ( ) ; $ n = 0 ; foreach ( self :: fetchPks ( $ condition ) as $ pk ) { $ key = static :: keyPrefix ( ) . ':a:' . static :: buildKey ( $ pk ) ; foreach ( $ counters as $ attribute => $ value ) { $ db -> executeCommand ( 'HINCRBY' , [ $ key , $ attribute , $ value ] ) ; } $ n ++ ; } return $ n ; }
5951	public function addFolderResponse ( $ item ) { if ( ! ( $ item instanceof FolderResponse ) ) { if ( is_array ( $ item ) ) { try { $ item = new FolderResponse ( $ item ) ; } catch ( \ Exception $ e ) { trigger_error ( 'Could not auto-instantiate FolderResponse. ' . $ e -> getMessage ( ) , E_USER_WARNING ) ; } } elseif ( ! is_numeric ( $ item ) ) { trigger_error ( 'Array parameter item is not of expected type "FolderResponse"!' , E_USER_WARNING ) ; } } $ this -> results [ ] = $ item ; return $ this ; }
6477	public function readAsMultipart ( ? IHttpBody $ body , string $ boundary ) : ? MultipartBody { if ( $ body === null ) { return null ; } $ rawBodyParts = explode ( "--$boundary" , $ body -> readAsString ( ) ) ; array_shift ( $ rawBodyParts ) ; array_pop ( $ rawBodyParts ) ; $ parsedBodyParts = [ ] ; foreach ( $ rawBodyParts as $ rawBodyPart ) { $ headerStartIndex = strlen ( "\r\n" ) ; $ headerEndIndex = strpos ( $ rawBodyPart , "\r\n\r\n" ) ; $ bodyStartIndex = $ headerEndIndex + strlen ( "\r\n\r\n" ) ; $ bodyEndIndex = strlen ( $ rawBodyPart ) - strlen ( "\r\n" ) ; $ rawHeaders = explode ( "\r\n" , substr ( $ rawBodyPart , $ headerStartIndex , $ headerEndIndex - $ headerStartIndex ) ) ; $ parsedHeaders = new HttpHeaders ( ) ; foreach ( $ rawHeaders as $ headerLine ) { [ $ headerName , $ headerValue ] = explode ( ':' , $ headerLine , 2 ) ; $ parsedHeaders -> add ( trim ( $ headerName ) , trim ( $ headerValue ) ) ; } $ body = new StringBody ( substr ( $ rawBodyPart , $ bodyStartIndex , $ bodyEndIndex - $ bodyStartIndex ) ) ; $ parsedBodyParts [ ] = new MultipartBodyPart ( $ parsedHeaders , $ body ) ; } return new MultipartBody ( $ parsedBodyParts , $ boundary ) ; }
1487	public function merge ( DecodingList $ decodings ) : self { $ copy = new self ( ) ; $ copy -> stack = collect ( $ this -> stack ) -> merge ( $ decodings -> stack ) -> all ( ) ; return $ copy ; }
11417	public function addPiwikCode ( ViewEvent $ event ) { $ model = $ event -> getModel ( ) ; if ( ! $ model instanceof \ Zend \ View \ Model \ ViewModel ) { return ; } $ options = $ model -> getOptions ( ) ; if ( array_key_exists ( 'has_parent' , $ options ) && $ options [ 'has_parent' ] ) { return ; } $ renderer = $ event -> getRenderer ( ) ; if ( ! $ renderer instanceof \ Zend \ View \ Renderer \ PhpRenderer ) { return ; } $ config = $ this -> serviceManager -> get ( 'config' ) ; $ piwikConfig = $ config [ 'orgHeiglPiwik' ] ; $ code = str_replace ( array_map ( function ( $ e ) { return '%%' . $ e . '%%' ; } , array_keys ( $ piwikConfig ) ) , array_values ( $ piwikConfig ) , $ this -> template ) ; $ renderer -> headScript ( ) -> appendScript ( '//<![CDATA[' . "\n" . $ code . "\n" . '//]]>' ) ; return $ renderer ; }
11701	public function get ( $ component ) { $ parts = explode ( '.' , $ component ) ; if ( count ( $ parts ) == 1 ) { return $ this -> getService ( $ parts [ 0 ] ) ; } elseif ( count ( $ parts ) == 2 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) ; } elseif ( count ( $ parts ) == 3 ) { return $ this -> getService ( $ parts [ 0 ] ) -> getGroup ( $ parts [ 1 ] ) -> getAction ( $ parts [ 2 ] ) ; } throw new \ LogicException ( 'Malformed component path. Please use a dot-notated path (e.g. service.group.action)' ) ; }
8450	public function contactRename ( $ contact , $ firstName , $ lastName ) { $ contact = $ this -> escapePeer ( $ contact ) ; $ firstName = $ this -> escapeStringArgument ( $ firstName ) ; $ lastName = $ this -> escapeStringArgument ( $ lastName ) ; return $ this -> exec ( 'rename_contact ' . $ contact . ' ' . $ firstName . ' ' . $ lastName ) ; }
4171	public function askPackageKey ( $ summary , $ message = 'Please provide an id' ) { $ this -> table ( [ 'id' , 'name' ] , $ summary ) ; $ selected = $ this -> ask ( $ message ) ; $ key = collect ( $ summary ) -> pluck ( 'id' ) -> search ( $ selected ) ; if ( $ key === false ) { $ this -> warn ( 'Invalid package name or id given.' ) ; return $ this -> askPackageKey ( $ summary , 'Please provide a valid id' ) ; } return $ key ; }
11993	public function orderBy ( $ key , $ direction = 'asc' ) { return $ this -> sort ( function ( $ a , $ b ) use ( $ key , $ direction ) { $ valueA = is_object ( $ a ) ? $ a -> { $ key } : $ a [ $ key ] ; $ valueB = is_object ( $ b ) ? $ b -> { $ key } : $ b [ $ key ] ; if ( $ valueA == $ valueB ) return 0 ; $ result = ( $ valueA < $ valueB ) ? - 1 : 1 ; return $ direction === 'desc' ? - ( $ result ) : $ result ; } ) ; }
9727	public function logRead ( $ format , $ path , $ callStartTime ) { $ callEndTime = microtime ( true ) ; $ callTime = $ callEndTime - $ callStartTime ; $ message = "Read {$format} format from <code>{$path}</code> in " . sprintf ( '%.4f' , $ callTime ) . ' seconds' ; $ this -> log ( $ message ) ; }
12069	public function updateProject ( Project $ project , $ composerJson ) { $ response = $ this -> getResponse ( 'post' , sprintf ( 'v2/projects/%s' , $ project -> getProjectKey ( ) ) , array ( ) , array ( 'project_file' => $ composerJson ) ) ; return $ this -> hydrator -> hydrate ( $ project , $ response ) ; }
11143	public function run ( ) { $ list = $ this -> getClassList ( ) ; $ directCollection = new DirectCollection ( ) ; foreach ( $ list as $ class ) { $ cl = $ this -> processClass ( $ class ) ; if ( $ cl !== false ) { $ directCollection -> add ( $ cl ) ; } } return $ directCollection ; }
9853	public function expiresAt ( $ expires ) { if ( $ expires instanceof DateTimeInterface ) { $ this -> expires = $ expires ; } else { $ this -> expires = null ; } return $ this ; }
2916	protected function stringToType ( $ string ) { if ( is_string ( $ string ) ) { switch ( true ) { case ( $ string == 'null' || $ string == 'NULL' ) : $ string = null ; break ; case ( $ string == 'true' || $ string == 'TRUE' ) : $ string = true ; break ; case ( $ string == 'false' || $ string == 'FALSE' ) : $ string = false ; break ; default : break ; } } return $ string ; }
7803	protected function statementBody ( $ text ) { $ accountNumber = $ this -> accountNumber ( $ text ) ; $ account = $ this -> reader -> createAccount ( $ accountNumber ) ; if ( ! ( $ account instanceof AccountInterface ) ) { return null ; } $ account -> setNumber ( $ accountNumber ) ; $ number = $ this -> statementNumber ( $ text ) ; $ statement = $ this -> reader -> createStatement ( $ account , $ number ) ; if ( ! ( $ statement instanceof StatementInterface ) ) { return null ; } $ statement -> setAccount ( $ account ) -> setNumber ( $ this -> statementNumber ( $ text ) ) -> setOpeningBalance ( $ this -> openingBalance ( $ text ) ) -> setClosingBalance ( $ this -> closingBalance ( $ text ) ) ; foreach ( $ this -> splitTransactions ( $ text ) as $ chunk ) { $ statement -> addTransaction ( $ this -> transaction ( $ chunk ) ) ; } return $ statement ; }
12602	public static function delete ( $ path ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> remove ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_DELETING' ) . ' - (' . $ e -> getMessage ( ) . ')' ) ; } return true ; }
3824	protected function getFilterParameters ( $ objItemRenderer ) { $ filterUrlBuilder = System :: getContainer ( ) -> get ( 'metamodels.filter_url' ) ; $ filterUrl = $ filterUrlBuilder -> getCurrentFilterUrl ( ) ; $ result = [ ] ; foreach ( $ objItemRenderer -> getFilterSettings ( ) -> getParameters ( ) as $ name ) { if ( $ filterUrl -> hasSlug ( $ name ) ) { $ result [ $ name ] = $ filterUrl -> getSlug ( $ name ) ; } Input :: get ( $ name ) ; } return $ filterUrl -> getSlugParameters ( ) ; }
327	public function send ( MailerInterface $ mailer = null ) { if ( $ mailer === null && $ this -> mailer === null ) { $ mailer = Yii :: $ app -> getMailer ( ) ; } elseif ( $ mailer === null ) { $ mailer = $ this -> mailer ; } return $ mailer -> send ( $ this ) ; }
11266	public function library ( $ pathname , & $ caller = false , $ exposeToView = false ) { $ name = $ this -> getName ( $ pathname ) ; $ path = $ this -> getPath ( $ pathname ) ; if ( $ caller ) { if ( $ this -> getPathBackslash ( $ pathname ) == '' ) { $ lib = '\\Cora\\' . $ name ; } else { $ lib = $ pathname ; } $ libObj = new $ lib ( $ caller ) ; $ caller -> $ name = $ libObj ; if ( $ exposeToView ) $ caller -> setData ( $ name , $ libObj ) ; } }
1641	protected function setupSessionTracking ( Client $ client , $ endpoint , $ events ) { $ client -> setAutoCaptureSessions ( true ) ; if ( ! is_null ( $ endpoint ) ) { $ client -> setSessionEndpoint ( $ endpoint ) ; } $ sessionTracker = $ client -> getSessionTracker ( ) ; $ sessionStorage = function ( $ session = null ) { if ( is_null ( $ session ) ) { return session ( 'bugsnag-session' , [ ] ) ; } else { session ( [ 'bugsnag-session' => $ session ] ) ; } } ; $ sessionTracker -> setSessionFunction ( $ sessionStorage ) ; $ cache = $ this -> app -> cache ; $ genericStorage = function ( $ key , $ value = null ) use ( $ cache ) { if ( is_null ( $ value ) ) { return $ cache -> get ( $ key , null ) ; } else { $ cache -> put ( $ key , $ value , 60 ) ; } } ; $ sessionTracker -> setStorageFunction ( $ genericStorage ) ; }
1185	public function resolver ( $ field ) { return function ( $ translator , $ data , $ rules , $ messages , $ customAttributes ) use ( $ field ) { return $ this -> resolve ( $ translator , $ data , $ rules , $ messages , $ customAttributes , $ field ) ; } ; }
6462	public function add ( $ name , $ values , bool $ append = false ) : void { $ normalizedName = self :: normalizeHeaderName ( $ name ) ; if ( ! $ append || ! $ this -> containsKey ( $ normalizedName ) ) { parent :: add ( $ normalizedName , ( array ) $ values ) ; } else { $ currentValues = [ ] ; $ this -> tryGet ( $ normalizedName , $ currentValues ) ; parent :: add ( $ normalizedName , array_merge ( $ currentValues , ( array ) $ values ) ) ; } }
11628	protected function getLockFile ( ) { $ request = $ this -> getRequest ( ) ; $ params = $ request -> getParams ( ) ; $ controller = $ params -> controller ; $ action = $ params -> action ; $ normalizedController = strtolower ( stripslashes ( str_replace ( __NAMESPACE__ , '' , $ controller ) ) ) ; $ fileBaseName = implode ( '_' , array ( basename ( $ request -> getScriptName ( ) ) , $ normalizedController , $ action ) ) ; return $ this -> lockdir . DIRECTORY_SEPARATOR . $ fileBaseName . self :: FILE_SUFFIX ; }
7599	public function render ( $ sAlertMessage , $ aAlertAttributes = null , $ bDismissable = false ) { if ( ! is_scalar ( $ sAlertMessage ) ) { throw new InvalidArgumentException ( 'Alert message expects a scalar value, "' . gettype ( $ sAlertMessage ) . '" given' ) ; } if ( empty ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => 'alert' ) ; } elseif ( is_string ( $ aAlertAttributes ) ) { $ aAlertAttributes = array ( 'class' => $ aAlertAttributes ) ; } elseif ( ! is_array ( $ aAlertAttributes ) ) { throw new InvalidArgumentException ( 'Alert attributes expects a string or an array, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } elseif ( empty ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute is empty' ) ; } elseif ( ! is_string ( $ aAlertAttributes [ 'class' ] ) ) { throw new InvalidArgumentException ( 'Alert "class" attribute expects string, "' . gettype ( $ aAlertAttributes ) . '" given' ) ; } if ( ! preg_match ( '/(\s|^)alert(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert' ; } if ( null !== ( $ oTranslator = $ this -> getTranslator ( ) ) ) { $ sAlertMessage = $ oTranslator -> translate ( $ sAlertMessage , $ this -> getTranslatorTextDomain ( ) ) ; } if ( $ bDismissable ) { $ sAlertMessage = static :: $ dismissButtonFormat . $ sAlertMessage ; if ( ! preg_match ( '/(\s|^)alert-dismissable(\s|$)/' , $ aAlertAttributes [ 'class' ] ) ) { $ aAlertAttributes [ 'class' ] .= ' alert-dismissable' ; } } return sprintf ( static :: $ alertFormat , $ this -> createAttributesString ( $ aAlertAttributes ) , $ sAlertMessage ) ; }
11135	protected function calculateUPDATE ( ) { $ this -> query .= 'UPDATE ' ; $ this -> queryStringFromArray ( 'tables' , '' , ', ' ) ; $ this -> queryStringFromArray ( 'updates' , ' SET ' , ', ' ) ; $ this -> conditionStringFromArray ( 'wheres' , ' WHERE ' , ' AND ' ) ; $ this -> queryStringFromArray ( 'orderBys' , ' ORDER BY ' , ', ' , false ) ; if ( $ this -> limit ) { $ this -> query .= ' LIMIT ' . $ this -> limit ; } }
4779	public function removeWidget ( string $ widgetId ) { if ( isset ( $ this -> widgets [ $ widgetId ] ) ) { unset ( $ this -> widgets [ $ widgetId ] ) ; } return $ this ; }
4560	public function translate ( Translatable $ model ) { $ properties = $ this -> getProperties ( $ model ) ; foreach ( $ properties as $ property ) { $ get = 'get' . $ property -> getName ( ) ; $ set = 'set' . $ property -> getName ( ) ; $ values = [ ] ; foreach ( $ model -> getTranslations ( ) as $ translation ) { $ values [ $ translation -> getLocale ( ) ] = $ translation -> $ get ( ) ; } $ model -> $ set ( $ values ) ; } }
2450	public function invalidateSourceCacheTag ( Contao \ DataContainer $ dc , array $ tags ) { $ commentModel = Contao \ CommentsModel :: findByPk ( $ dc -> id ) ; if ( null !== $ commentModel ) { $ tags [ ] = sprintf ( 'contao.comments.%s.%s' , $ commentModel -> source , $ commentModel -> parent ) ; } return $ tags ; }
12648	public function get ( ) { $ arResult = [ 'status' => $ this -> status ( ) , 'data' => $ this -> data ( ) , 'message' => $ this -> message ( ) , 'code' => $ this -> code ( ) , ] ; return $ arResult ; }
5704	public function Field ( $ properties = array ( ) ) { if ( $ this -> isGrouped ( ) ) { $ this -> transformToInput ( ) ; } else { $ this -> transformToButton ( ) ; } return parent :: Field ( $ properties ) ; }
4670	protected function afterGeneration ( ) { $ this -> mapTemplate -> writeToFile ( ) ; $ this -> autoloadMap -> writeToFile ( ) ; $ responseParserTemplate = new ResponseParserTemplate ( $ this -> config ) ; $ this -> autoloadMap -> addEntry ( $ responseParserTemplate -> getClassName ( ) , $ responseParserTemplate -> getClassPath ( ) ) ; $ responseParserTemplate -> writeToFile ( ) ; }
6143	public function checkQuery ( $ query = null ) { if ( $ query === null ) { $ query = $ this -> query ; } if ( strlen ( $ query ) == 0 ) { return true ; } $ pattern = "/^" . $ this -> regex [ "uric" ] . "*$/" ; $ status = @ preg_match ( $ pattern , $ query ) ; if ( $ status === false ) { throw new Ts3Exception ( "URI query string validation failed" ) ; } return ( $ status == 1 ) ; }
11435	public function delete ( string $ sName ) { return unlink ( $ this -> _sFolder . $ this -> _getSubDirectory ( $ sName ) . md5 ( $ sName ) . '.fil.cac' ) ; }
6687	protected function mergeFlashMessages ( $ messageArray ) { $ messages = array_values ( $ messageArray ) ; $ flashMessage = '' ; $ flashMessageArr = [ ] ; foreach ( $ messages as $ message ) { if ( is_array ( $ message ) ) { if ( strlen ( $ flashMessage ) > 0 ) { $ flashMessage .= '<br/>' ; } $ flashMessage .= $ this -> mergeFlashMessages ( $ message ) ; } else { $ flashMessageArr [ ] = $ message ; } } return $ flashMessage . implode ( '<br/>' , $ flashMessageArr ) ; }
1054	private function varTypeAllowedForType ( $ varType , $ expectedType ) { if ( $ expectedType instanceof NonNull ) { if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return false ; } if ( $ varType instanceof NonNull ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType ) ; } if ( $ varType instanceof ListOfType && $ expectedType instanceof ListOfType ) { return $ this -> varTypeAllowedForType ( $ varType -> getWrappedType ( ) , $ expectedType -> getWrappedType ( ) ) ; } return $ varType === $ expectedType ; }
5273	public static function table ( $ table_name ) { global $ wpdb ; if ( empty ( self :: $ instances ) || empty ( self :: $ instances [ $ table_name ] ) ) { self :: $ instances [ $ table_name ] = new Query_Builder ( $ wpdb -> prefix . $ table_name ) ; } return self :: $ instances [ $ table_name ] ; }
6467	private function createStreamFromString ( string $ string ) : Stream { $ stream = new Stream ( fopen ( 'php://temp' , 'r+b' ) ) ; $ stream -> write ( $ string ) ; $ stream -> rewind ( ) ; return $ stream ; }
6263	public function nextkey ( ) { if ( $ this -> keys === null ) { return $ this -> firstkey ( ) ; } return empty ( $ this -> keys ) ? false : array_shift ( $ this -> keys ) ; }
5279	protected function generateWhere ( $ column , $ param1 = null , $ param2 = null , $ type = 'and' ) { if ( is_null ( $ param2 ) ) { $ param2 = $ param1 ; $ param1 = '=' ; } if ( is_array ( $ param2 ) ) { $ param2 = $ this -> esc_array ( array_unique ( $ param2 ) ) ; if ( in_array ( $ param1 , array ( 'between' , 'not between' ) ) ) { $ param2 = join ( ' and ' , $ param2 ) ; } else { $ param2 = '(' . join ( ', ' , $ param2 ) . ')' ; } } elseif ( is_scalar ( $ param2 ) ) { $ param2 = $ this -> esc_value ( $ param2 ) ; } return join ( ' ' , array ( $ type , $ column , $ param1 , $ param2 ) ) ; }
1779	public function getEmptyStringOrNull ( ) { if ( ! isset ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ) { return '' ; } return static :: getEmptyStringOrNullByFieldType ( $ GLOBALS [ 'TL_DCA' ] [ $ this -> strTable ] [ 'fields' ] [ $ this -> strField ] [ 'sql' ] ) ; }
11657	public function make ( ) { if ( count ( $ this -> headers ) > 0 ) { if ( ! $ this -> session -> exists ( 'headersInRedirect' , 'redirect' ) || ! $ this -> session -> get ( 'headersInRedirect' , 'redirect' ) ) { $ this -> session -> set ( 'redirectPath' , $ this -> path , 'redirect' ) ; $ this -> session -> set ( 'headersInRedirect' , $ this -> headers , 'redirect' ) ; } } header ( "Location: $this->path" ) ; exit ( ) ; }
1056	public static function findRemovedTypes ( Schema $ oldSchema , Schema $ newSchema ) { $ oldTypeMap = $ oldSchema -> getTypeMap ( ) ; $ newTypeMap = $ newSchema -> getTypeMap ( ) ; $ breakingChanges = [ ] ; foreach ( array_keys ( $ oldTypeMap ) as $ typeName ) { if ( isset ( $ newTypeMap [ $ typeName ] ) ) { continue ; } $ breakingChanges [ ] = [ 'type' => self :: BREAKING_CHANGE_TYPE_REMOVED , 'description' => "${typeName} was removed." , ] ; } return $ breakingChanges ; }
4845	protected static function call ( $ method , $ url , $ params = array ( ) ) { $ ch = curl_init ( ) ; $ curl_options = array ( CURLOPT_CONNECTTIMEOUT => 10 , CURLOPT_RETURNTRANSFER => true , CURLOPT_TIMEOUT => 60 , CURLOPT_USERAGENT => 'gocardless-php/v' . GoCardless :: VERSION , ) ; if ( isset ( $ params [ 'ua_tag' ] ) ) { $ curl_options [ CURLOPT_USERAGENT ] .= ' ' . $ params [ 'ua_tag' ] ; unset ( $ params [ 'ua_tag' ] ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Accept: application/json' ; $ curl_options [ CURLOPT_SSL_VERIFYPEER ] = true ; if ( isset ( $ params [ 'http_authorization' ] ) ) { $ curl_options [ CURLOPT_USERPWD ] = $ params [ 'http_authorization' ] ; unset ( $ params [ 'http_authorization' ] ) ; } else { if ( ! isset ( $ params [ 'http_bearer' ] ) ) { throw new GoCardless_ClientException ( 'Access token missing' ) ; } $ curl_options [ CURLOPT_HTTPHEADER ] [ ] = 'Authorization: Bearer ' . $ params [ 'http_bearer' ] ; unset ( $ params [ 'http_bearer' ] ) ; } if ( $ method == 'post' ) { $ curl_options [ CURLOPT_POST ] = 1 ; if ( ! empty ( $ params ) ) { $ curl_options [ CURLOPT_POSTFIELDS ] = http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'get' ) { $ curl_options [ CURLOPT_HTTPGET ] = 1 ; if ( ! empty ( $ params ) ) { $ url .= '?' . http_build_query ( $ params , null , '&' ) ; } } elseif ( $ method == 'put' ) { $ curl_options [ CURLOPT_PUT ] = 1 ; $ fh = fopen ( 'php://memory' , 'rw+' ) ; $ curl_options [ CURLOPT_INFILE ] = $ fh ; $ curl_options [ CURLOPT_INFILESIZE ] = 0 ; } curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt_array ( $ ch , $ curl_options ) ; $ result = curl_exec ( $ ch ) ; $ error = curl_errno ( $ ch ) ; if ( $ error == CURLE_SSL_PEER_CERTIFICATE || $ error == CURLE_SSL_CACERT || $ error == 77 ) { curl_setopt ( $ ch , CURLOPT_CAINFO , dirname ( __FILE__ ) . '/cert-bundle.crt' ) ; $ result = curl_exec ( $ ch ) ; } $ http_response_code = curl_getinfo ( $ ch , CURLINFO_HTTP_CODE ) ; if ( $ http_response_code < 200 || $ http_response_code > 300 ) { $ message = print_r ( json_decode ( $ result , true ) , true ) ; throw new GoCardless_ApiException ( $ message , $ http_response_code , $ result ) ; } curl_close ( $ ch ) ; if ( isset ( $ fh ) ) { fclose ( $ fh ) ; } return json_decode ( $ result , true ) ; }
7754	public function deserialize ( $ data , $ type , $ format , array $ context = array ( ) ) { if ( 'jsonld' !== $ format ) { throw new UnexpectedValueException ( 'Deserialization for the format ' . $ format . ' is not supported' ) ; } $ reflectionClass = new \ ReflectionClass ( $ type ) ; if ( null !== ( $ constructor = $ reflectionClass -> getConstructor ( ) ) ) { if ( 0 !== $ constructor -> getNumberOfRequiredParameters ( ) ) { throw new RuntimeException ( 'Cannot create an instance of ' . $ type . ' from serialized data because its constructor has required parameters.' ) ; } } return $ this -> doDeserialize ( $ data , new $ type ) ; }
9731	public function canRead ( $ pFilename ) { try { $ this -> openFile ( $ pFilename ) ; } catch ( Exception $ e ) { return false ; } $ data = fread ( $ this -> fileHandle , 2048 ) ; $ delimiterCount = substr_count ( $ data , ';' ) ; $ hasDelimiter = $ delimiterCount > 0 ; $ lines = explode ( "\n" , $ data ) ; $ hasId = substr ( $ lines [ 0 ] , 0 , 4 ) === 'ID;P' ; fclose ( $ this -> fileHandle ) ; return $ hasDelimiter && $ hasId ; }
10443	protected function handleStart ( $ line ) { if ( preg_match ( '/^(INSERT INTO|UPDATE|DELETE FROM)\s+`?(.*?)`?\.`?(.*?)`?$/' , $ line , $ part ) ) { return [ 'type' => $ this -> detectQueryType ( $ part [ 1 ] ) , 'table' => $ part [ 3 ] , ] ; } throw new \ UnexpectedValueException ( "Expected a statement, got {$line}" ) ; }
1564	public function setResource ( $ resource ) : ClientJob { $ schema = $ this -> getApi ( ) -> getContainer ( ) -> getSchema ( $ resource ) ; $ this -> fill ( [ 'resource_type' => $ schema -> getResourceType ( ) , 'resource_id' => $ schema -> getId ( $ resource ) , ] ) ; return $ this ; }
4429	protected function getChoiceQuestion ( $ questionName , $ defaultValue = null , array $ choices = array ( ) ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; return new ChoiceQuestion ( $ questionName , $ choices , $ defaultValue ) ; }
5143	public static function create ( array $ data ) : \ One \ Model \ Photo { $ url = self :: validateUrl ( ( string ) self :: checkData ( $ data , 'url' , '' ) ) ; $ ratio = self :: validateString ( ( string ) self :: checkData ( $ data , 'ratio' , '' ) ) ; $ description = self :: validateString ( ( string ) self :: checkData ( $ data , 'description' , '' ) ) ; $ information = self :: validateString ( ( string ) self :: checkData ( $ data , 'information' , '' ) ) ; return self :: createPhoto ( $ url , $ ratio , $ description , $ information ) ; }
1330	public function queryToMany ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryAllOrOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
10231	public function write ( Spreadsheet $ spreadsheet = null ) { if ( ! $ spreadsheet ) { $ spreadsheet = $ this -> getParentWriter ( ) -> getSpreadsheet ( ) ; } $ objWriter = null ; if ( $ this -> getParentWriter ( ) -> getUseDiskCaching ( ) ) { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_DISK , $ this -> getParentWriter ( ) -> getDiskCachingDirectory ( ) ) ; } else { $ objWriter = new XMLWriter ( XMLWriter :: STORAGE_MEMORY ) ; } $ objWriter -> startDocument ( '1.0' , 'UTF-8' ) ; $ objWriter -> startElement ( 'office:document-meta' ) ; $ objWriter -> writeAttribute ( 'xmlns:office' , 'urn:oasis:names:tc:opendocument:xmlns:office:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:xlink' , 'http://www.w3.org/1999/xlink' ) ; $ objWriter -> writeAttribute ( 'xmlns:dc' , 'http://purl.org/dc/elements/1.1/' ) ; $ objWriter -> writeAttribute ( 'xmlns:meta' , 'urn:oasis:names:tc:opendocument:xmlns:meta:1.0' ) ; $ objWriter -> writeAttribute ( 'xmlns:ooo' , 'http://openoffice.org/2004/office' ) ; $ objWriter -> writeAttribute ( 'xmlns:grddl' , 'http://www.w3.org/2003/g/data-view#' ) ; $ objWriter -> writeAttribute ( 'office:version' , '1.2' ) ; $ objWriter -> startElement ( 'office:meta' ) ; $ objWriter -> writeElement ( 'meta:initial-creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'dc:creator' , $ spreadsheet -> getProperties ( ) -> getCreator ( ) ) ; $ objWriter -> writeElement ( 'meta:creation-date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:date' , date ( DATE_W3C , $ spreadsheet -> getProperties ( ) -> getCreated ( ) ) ) ; $ objWriter -> writeElement ( 'dc:title' , $ spreadsheet -> getProperties ( ) -> getTitle ( ) ) ; $ objWriter -> writeElement ( 'dc:description' , $ spreadsheet -> getProperties ( ) -> getDescription ( ) ) ; $ objWriter -> writeElement ( 'dc:subject' , $ spreadsheet -> getProperties ( ) -> getSubject ( ) ) ; $ keywords = explode ( ' ' , $ spreadsheet -> getProperties ( ) -> getKeywords ( ) ) ; foreach ( $ keywords as $ keyword ) { $ objWriter -> writeElement ( 'meta:keyword' , $ keyword ) ; } $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'Company' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCompany ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> startElement ( 'meta:user-defined' ) ; $ objWriter -> writeAttribute ( 'meta:name' , 'category' ) ; $ objWriter -> writeRaw ( $ spreadsheet -> getProperties ( ) -> getCategory ( ) ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; $ objWriter -> endElement ( ) ; return $ objWriter -> getData ( ) ; }
6839	public function get ( $ key ) { if ( isset ( $ this -> objects [ $ key ] ) ) { return $ this -> objects [ $ key ] ; } throw new InjectorException ( "obj $key not found" ) ; }
9024	public function hasDenial ( $ string ) { $ result = false ; $ words = $ this -> getWords ( $ string ) ; foreach ( $ words as $ word ) { if ( in_array ( $ word , $ this -> denialWords ) ) { $ result = true ; } } return $ result ; }
5374	public function createTag ( $ name , $ attributes ) { static $ map = array ( 'a' => 'SimpleAnchorTag' , 'title' => 'SimpleTitleTag' , 'base' => 'SimpleBaseTag' , 'button' => 'SimpleButtonTag' , 'textarea' => 'SimpleTextAreaTag' , 'option' => 'SimpleOptionTag' , 'label' => 'SimpleLabelTag' , 'form' => 'SimpleFormTag' , 'frame' => 'SimpleFrameTag' ) ; $ attributes = $ this -> keysToLowerCase ( $ attributes ) ; if ( array_key_exists ( $ name , $ map ) ) { $ tag_class = $ map [ $ name ] ; return new $ tag_class ( $ attributes ) ; } elseif ( $ name === 'select' ) { return $ this -> createSelectionTag ( $ attributes ) ; } elseif ( $ name === 'input' ) { return $ this -> createInputTag ( $ attributes ) ; } return new SimpleTag ( $ name , $ attributes ) ; }
529	public function actionPackage ( array $ what ) { $ this -> validateWhat ( $ what , [ 'app' ] ) ; $ versions = $ this -> getCurrentVersions ( $ what ) ; $ this -> stdout ( "You are about to generate packages for the following things:\n\n" ) ; foreach ( $ what as $ ext ) { if ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( substr ( $ ext , 4 ) , Console :: FG_RED ) ; $ this -> stdout ( ' application version ' ) ; } elseif ( $ ext === 'framework' ) { $ this -> stdout ( ' - Yii Framework version ' ) ; } else { $ this -> stdout ( ' - ' ) ; $ this -> stdout ( $ ext , Console :: FG_RED ) ; $ this -> stdout ( ' extension version ' ) ; } $ this -> stdout ( $ versions [ $ ext ] , Console :: BOLD ) ; $ this -> stdout ( "\n" ) ; } $ this -> stdout ( "\n" ) ; $ packagePath = "{$this->basePath}/packages" ; $ this -> stdout ( "Packages will be stored in $packagePath\n\n" ) ; if ( ! $ this -> confirm ( 'Continue?' , false ) ) { $ this -> stdout ( "Canceled.\n" ) ; return 1 ; } foreach ( $ what as $ ext ) { if ( $ ext === 'framework' ) { throw new Exception ( 'Can not package framework.' ) ; } elseif ( strncmp ( 'app-' , $ ext , 4 ) === 0 ) { $ this -> packageApplication ( substr ( $ ext , 4 ) , $ versions [ $ ext ] , $ packagePath ) ; } else { throw new Exception ( 'Can not package extension.' ) ; } } $ this -> stdout ( "\ndone. verify the versions composer installed above and push it to github!\n\n" ) ; return 0 ; }
6479	public function getClientIPAddress ( IHttpRequestMessage $ request ) : ? string { $ clientIPAddress = null ; $ request -> getProperties ( ) -> tryGet ( self :: CLIENT_IP_ADDRESS_PROPERTY , $ clientIPAddress ) ; return $ clientIPAddress ; }
8675	public function merge ( $ list ) { return $ this -> createFrom ( array_merge ( $ this -> items , Arr :: from ( $ list ) ) ) ; }
6975	private function throwIllegalOperationIfAdjustmentIsImmutable ( ResourceEventInterface $ event ) { if ( $ event -> getHard ( ) ) { return ; } $ adjustment = $ this -> getAdjustmentFromEvent ( $ event ) ; if ( $ adjustment -> isImmutable ( ) ) { throw new IllegalOperationException ( 'ekyna_commerce.sale.message.immutable_element' ) ; } }
7821	public function update ( $ pipeline , array $ attachments , array $ detachments ) { $ this -> detach ( $ this -> pipelines [ $ pipeline ] , $ detachments ) ; $ this -> attach ( $ this -> pipelines [ $ pipeline ] , $ attachments ) ; $ this -> refreshPipelines ( ) ; }
6124	public function logout ( ) { $ this -> request ( "logout" ) ; $ this -> whoamiReset ( ) ; $ this -> delStorage ( "_login_user" ) ; $ this -> delStorage ( "_login_pass" ) ; Signal :: getInstance ( ) -> emit ( "notifyLogout" , $ this ) ; }
4903	public function createService ( ServiceLocatorInterface $ serviceLocator ) { $ select = $ this ( $ serviceLocator , self :: class , $ this -> options ) ; $ this -> options = [ ] ; return $ select ; }
11608	public function actionConfirm ( $ id , $ code ) { $ user = $ this -> finder -> findUserById ( $ id ) ; if ( $ user === null || $ this -> module -> emailChangeStrategy == Module :: STRATEGY_INSECURE ) { throw new NotFoundHttpException ; } $ user -> attemptEmailChange ( $ code ) ; return $ this -> redirect ( [ 'account' ] ) ; }
300	protected function refreshInternal ( $ record ) { if ( $ record === null ) { return false ; } foreach ( $ this -> attributes ( ) as $ name ) { $ this -> _attributes [ $ name ] = isset ( $ record -> _attributes [ $ name ] ) ? $ record -> _attributes [ $ name ] : null ; } $ this -> _oldAttributes = $ record -> _oldAttributes ; $ this -> _related = [ ] ; $ this -> _relationsDependencies = [ ] ; $ this -> afterRefresh ( ) ; return true ; }
4114	public function getRemoteCallEnabled ( ) { if ( is_null ( $ this -> remoteCallEnabled ) ) { $ this -> remoteCallEnabled = Mage :: getStoreConfigFlag ( 'dev/aoe_templatehints/enablePhpstormRemoteCall' ) ; } return $ this -> remoteCallEnabled ; }
6288	private function buildResponse ( ReactResponse $ response , StreamInterface $ body ) { $ body -> rewind ( ) ; return $ this -> responseFactory -> createResponse ( $ response -> getCode ( ) , $ response -> getReasonPhrase ( ) , $ response -> getHeaders ( ) , $ body , $ response -> getVersion ( ) ) ; }
2997	public function setFrom ( $ email , $ title = null ) { $ this -> set ( 'From' , $ this -> buildMail ( $ email , $ title ) ) ; }
12279	public function moveUsers ( array $ openIds , $ groupId ) { $ params = [ 'openid_list' => $ openIds , 'to_groupid' => $ groupId , ] ; return $ this -> parseJSON ( 'json' , [ self :: API_MEMBER_BATCH_UPDATE , $ params ] ) ; }
6302	protected function getBar ( $ name = 'default' ) { $ this -> events -> fire ( 'navigation.bar' , [ [ 'name' => $ name ] ] ) ; if ( $ name !== 'default' && ! array_key_exists ( $ name , $ this -> bar ) ) { $ name = 'default' ; } if ( ! array_key_exists ( $ name , $ this -> bar ) ) { $ this -> bar [ $ name ] = [ ] ; } $ nav = $ this -> bar [ $ name ] ; return $ this -> process ( $ nav ) ; }
6790	protected function merge ( array $ cachedUnits , array $ fetchedUnits ) { $ cachedIds = [ ] ; foreach ( $ cachedUnits as $ unit ) { if ( null !== $ id = $ unit -> getId ( ) ) { $ cachedIds [ ] = $ unit -> getId ( ) ; } } foreach ( $ fetchedUnits as $ unit ) { if ( in_array ( $ unit -> getId ( ) , $ cachedIds ) ) { continue ; } if ( $ this -> unitCache -> isRemoved ( $ unit ) ) { continue ; } if ( $ this -> persistenceHelper -> isScheduledForRemove ( $ unit ) ) { continue ; } $ cachedUnits [ ] = $ unit ; } return $ cachedUnits ; }
7338	public function createEvent ( Request $ request ) : Event { if ( empty ( $ request -> input ( ) ) ) { return new Unknown ( ) ; } $ update = new Update ( $ request -> input ( ) ) ; $ this -> update = $ update ; if ( $ message = $ update -> message ) { $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> from -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , optional ( $ update -> callback_query ) -> data , $ update ) ; } if ( $ callbackQuery = $ update -> callback_query ) { $ message = $ callbackQuery -> message ; $ chat = new Chat ( ( string ) $ message -> chat -> id , $ message -> chat -> title , $ message -> chat -> type ) ; $ from = new User ( ( string ) $ message -> chat -> id , $ message -> from -> first_name , $ message -> from -> username ) ; return new MessageReceived ( $ chat , $ from , $ message -> text , $ message -> location , null , $ callbackQuery -> data , $ update ) ; } return new Unknown ( ) ; }
2469	public function mapContentBlock ( Content $ content ) { $ contentInfo = $ content -> versionInfo -> contentInfo ; $ locations = $ this -> locationHandler -> loadLocationsByContent ( $ contentInfo -> id ) ; $ blockFields = $ this -> getBlockFields ( $ content ) ; $ contentFields = $ this -> getContentFields ( $ content ) ; $ documents = [ ] ; $ locationFieldsMap = [ ] ; foreach ( $ locations as $ location ) { $ locationFieldsMap [ $ location -> id ] = $ this -> getLocationFields ( $ location ) ; } foreach ( array_keys ( $ content -> versionInfo -> names ) as $ languageCode ) { $ blockTranslationFields = $ this -> getBlockTranslationFields ( $ content , $ languageCode ) ; $ translationLocationDocuments = array ( ) ; foreach ( $ locations as $ location ) { $ translationLocationDocuments [ ] = new Document ( array ( 'id' => $ this -> generateLocationDocumentId ( $ location -> id , $ languageCode ) , 'fields' => array_merge ( $ blockFields , $ locationFieldsMap [ $ location -> id ] , $ blockTranslationFields ) , ) ) ; } $ isMainTranslation = ( $ contentInfo -> mainLanguageCode === $ languageCode ) ; $ alwaysAvailable = ( $ isMainTranslation && $ contentInfo -> alwaysAvailable ) ; $ contentTranslationFields = $ this -> getContentTranslationFields ( $ content , $ languageCode ) ; $ documents [ ] = new Document ( array ( 'id' => $ this -> generateContentDocumentId ( $ contentInfo -> id , $ languageCode ) , 'languageCode' => $ languageCode , 'alwaysAvailable' => $ alwaysAvailable , 'isMainTranslation' => $ isMainTranslation , 'fields' => array_merge ( $ blockFields , $ contentFields , $ blockTranslationFields , $ contentTranslationFields ) , 'documents' => $ translationLocationDocuments , ) ) ; } return $ documents ; }
12596	protected function doWeNeedToMinify ( SplFileInfo $ file ) : bool { return ( ! $ this -> debug && ! Str :: s ( $ file -> getFilename ( ) ) -> contains ( '.min.' ) ) ; }
6568	protected function createMigration ( ) { $ app = app ( ) ; $ migrationFiles = array ( $ this -> laravel -> path . "/database/migrations/*_create_countries_table.php" => 'countries::generators.migration' , ) ; $ seconds = 0 ; foreach ( $ migrationFiles as $ migrationFile => $ outputFile ) { if ( sizeof ( glob ( $ migrationFile ) ) == 0 ) { $ migrationFile = str_replace ( '*' , date ( 'Y_m_d_His' , strtotime ( '+' . $ seconds . ' seconds' ) ) , $ migrationFile ) ; $ fs = fopen ( $ migrationFile , 'x' ) ; if ( $ fs ) { $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( $ outputFile ) -> with ( 'table' , 'countries' ) -> render ( ) ; fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } $ seconds ++ ; } } $ seeder_file = $ this -> laravel -> path . "/database/seeds/CountriesSeeder.php" ; $ output = "<?php\n\n" . $ app [ 'view' ] -> make ( 'countries::generators.seeder' ) -> render ( ) ; if ( ! file_exists ( $ seeder_file ) ) { $ fs = fopen ( $ seeder_file , 'x' ) ; if ( $ fs ) { fwrite ( $ fs , $ output ) ; fclose ( $ fs ) ; } else { return false ; } } return true ; }
9491	public function getFileListData ( $ sFieldName ) { if ( empty ( $ sFieldName ) ) { return [ ] ; } $ obFileList = $ this -> $ sFieldName ; if ( $ obFileList -> isEmpty ( ) ) { return [ ] ; } $ arResult = [ ] ; foreach ( $ obFileList as $ obFile ) { if ( empty ( $ obFile ) || ! $ obFile instanceof File ) { continue ; } $ arResult [ ] = $ this -> getFileDataValue ( $ obFile ) ; } return $ arResult ; }
2770	public function getRemoteUrl ( string $ remote , string $ operation = 'fetch' ) : string { $ argsAndOptions = [ 'get-url' , $ remote ] ; if ( $ operation === 'push' ) { $ argsAndOptions [ ] = '--push' ; } return rtrim ( $ this -> remote ( ... $ argsAndOptions ) ) ; }
10393	private function isValidOperation ( $ operationType ) { $ operationType = strtoupper ( $ operationType ) ; return in_array ( $ operationType , [ ActionTypes :: CREATE , ActionTypes :: UPDATE , ActionTypes :: DELETE , ] ) ; }
2685	public function aroundDispatch ( FrontController $ subject , callable $ proceed , ... $ args ) { $ isRateLimitingEnabled = $ this -> config -> isRateLimitingEnabled ( ) ; $ isCrawlerProtectionEnabled = $ this -> config -> isCrawlerProtectionEnabled ( ) ; if ( ! $ isRateLimitingEnabled && ! $ isCrawlerProtectionEnabled ) { return $ proceed ( ... $ args ) ; } $ path = strtolower ( $ this -> request -> getPathInfo ( ) ) ; if ( $ isRateLimitingEnabled && $ this -> sensitivePathProtection ( $ path ) ) { return $ this -> response ; } if ( $ isCrawlerProtectionEnabled && $ this -> crawlerProtection ( $ path ) ) { return $ this -> response ; } return $ proceed ( ... $ args ) ; }
1616	public function count ( $ q = '*' , $ db = null ) { if ( $ this -> emulateExecution ) { return 0 ; } if ( $ this -> where === null ) { $ modelClass = $ this -> modelClass ; if ( $ db === null ) { $ db = $ modelClass :: getDb ( ) ; } return $ db -> executeCommand ( 'LLEN' , [ $ modelClass :: keyPrefix ( ) ] ) ; } else { return $ this -> executeScript ( $ db , 'Count' ) ; } }
3572	public function set ( $ key , $ value = null , $ group = null ) { if ( $ key instanceof Attribute ) { return $ this -> setInstance ( $ key ) ; } if ( $ this -> has ( $ key ) ) { $ this -> update ( $ key , $ value , $ group ) ; } else { $ this -> items [ $ key ] = $ this -> newAttribute ( $ key , $ value , $ group ) ; } return $ this ; }
10095	protected function processDefault ( $ url ) { if ( $ url === null ) { return $ url ; } $ url = ( string ) $ url ; switch ( $ url ) { case '404' : case 'mm' : case 'identicon' : case 'monsterid' : case 'wavatar' : case 'retro' : break ; default : $ valid = filter_var ( $ url , FILTER_VALIDATE_URL ) ; if ( ! $ valid ) { throw new InvalidArgumentException ( 'Invalid default avatar URL' ) ; } break ; } return $ url ; }
2741	public function getAllRepoManifests ( ) { $ fastlyEdgeModules = $ this -> config -> getFastlyEdgeModules ( ) ; $ manifests = [ ] ; foreach ( $ fastlyEdgeModules as $ key => $ value ) { $ decodedManifestData = json_decode ( $ value , true ) ; $ manifests [ ] = $ decodedManifestData ; } return $ manifests ; }
448	protected function renderPageButtons ( ) { $ pageCount = $ this -> pagination -> getPageCount ( ) ; if ( $ pageCount < 2 && $ this -> hideOnSinglePage ) { return '' ; } $ buttons = [ ] ; $ currentPage = $ this -> pagination -> getPage ( ) ; $ firstPageLabel = $ this -> firstPageLabel === true ? '1' : $ this -> firstPageLabel ; if ( $ firstPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ firstPageLabel , 0 , $ this -> firstPageCssClass , $ currentPage <= 0 , false ) ; } if ( $ this -> prevPageLabel !== false ) { if ( ( $ page = $ currentPage - 1 ) < 0 ) { $ page = 0 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> prevPageLabel , $ page , $ this -> prevPageCssClass , $ currentPage <= 0 , false ) ; } list ( $ beginPage , $ endPage ) = $ this -> getPageRange ( ) ; for ( $ i = $ beginPage ; $ i <= $ endPage ; ++ $ i ) { $ buttons [ ] = $ this -> renderPageButton ( $ i + 1 , $ i , null , $ this -> disableCurrentPageButton && $ i == $ currentPage , $ i == $ currentPage ) ; } if ( $ this -> nextPageLabel !== false ) { if ( ( $ page = $ currentPage + 1 ) >= $ pageCount - 1 ) { $ page = $ pageCount - 1 ; } $ buttons [ ] = $ this -> renderPageButton ( $ this -> nextPageLabel , $ page , $ this -> nextPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ lastPageLabel = $ this -> lastPageLabel === true ? $ pageCount : $ this -> lastPageLabel ; if ( $ lastPageLabel !== false ) { $ buttons [ ] = $ this -> renderPageButton ( $ lastPageLabel , $ pageCount - 1 , $ this -> lastPageCssClass , $ currentPage >= $ pageCount - 1 , false ) ; } $ options = $ this -> options ; $ tag = ArrayHelper :: remove ( $ options , 'tag' , 'ul' ) ; return Html :: tag ( $ tag , implode ( "\n" , $ buttons ) , $ options ) ; }
4296	public function assert ( $ assertion , $ msg = null ) { array ( $ msg ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args ) ; $ assertion = \ array_shift ( $ args ) ; if ( ! $ assertion ) { if ( ! $ args ) { $ callerInfo = $ this -> utilities -> getCallerInfo ( ) ; $ args [ ] = 'Assertion failed in ' . $ callerInfo [ 'file' ] . ' on line ' . $ callerInfo [ 'line' ] ; } $ this -> appendLog ( 'assert' , $ args , $ meta ) ; } }
806	private function findReturnAnnotations ( Tokens $ tokens , $ index ) { do { $ index = $ tokens -> getPrevNonWhitespace ( $ index ) ; } while ( $ tokens [ $ index ] -> isGivenKind ( [ T_ABSTRACT , T_FINAL , T_PRIVATE , T_PROTECTED , T_PUBLIC , T_STATIC , ] ) ) ; if ( ! $ tokens [ $ index ] -> isGivenKind ( T_DOC_COMMENT ) ) { return [ ] ; } $ doc = new DocBlock ( $ tokens [ $ index ] -> getContent ( ) ) ; return $ doc -> getAnnotationsOfType ( 'return' ) ; }
301	public static function isPrimaryKey ( $ keys ) { $ pks = static :: primaryKey ( ) ; if ( count ( $ keys ) === count ( $ pks ) ) { return count ( array_intersect ( $ keys , $ pks ) ) === count ( $ pks ) ; } return false ; }
4447	public function fromWorker ( string $ worker , string $ subTimeInterval = '' ) : array { try { $ now = new \ DateTime ( ) ; $ interval = date_interval_create_from_date_string ( $ subTimeInterval ) ; $ timestamp = $ now -> sub ( $ interval ) -> getTimestamp ( ) ; } catch ( \ Exception $ e ) { $ timestamp = - 1 ; } if ( $ subTimeInterval === '' || $ timestamp === - 1 ) { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker ) , true ) ? : [ ] ; } else { $ jids = json_decode ( $ this -> client -> workerJobs ( $ worker , $ timestamp ) , true ) ? : [ ] ; } return $ this -> multiget ( $ jids ) ; }
5765	public function indexViewObjects ( Response $ response , bool $ resetFilter = false ) { if ( $ resetFilter ) { return $ this -> resetFilter ( $ response , $ this -> indexRoute ) ; } try { $ administrators = $ this -> administratorsEntityMapper -> getObjects ( $ this -> getFilterColumnsInfo ( ) , null , $ this -> authentication , $ this -> authorization ) ; } catch ( QueryFailureException $ e ) { $ administrators = [ ] ; SlimPostgres :: setAdminNotice ( 'Query Failed' , 'failure' ) ; } return $ this -> indexView ( $ response , $ administrators ) ; }
9761	function containOnlyInstancesOf ( string $ className ) : self { return $ this -> expect ( $ this -> target , containsOnlyInstancesOf ( $ className ) ) ; }
152	public function batch ( $ batchSize = 100 , $ db = null ) { return Yii :: createObject ( [ 'class' => BatchQueryResult :: className ( ) , 'query' => $ this , 'batchSize' => $ batchSize , 'db' => $ db , 'each' => false , ] ) ; }
2411	public function exportTheme ( DataContainer $ dc ) { $ objTheme = $ this -> Database -> prepare ( "SELECT * FROM tl_theme WHERE id=?" ) -> limit ( 1 ) -> execute ( $ dc -> id ) ; if ( $ objTheme -> numRows < 1 ) { return ; } $ strName = Utf8 :: toAscii ( $ objTheme -> name ) ; $ strName = strtolower ( str_replace ( ' ' , '_' , $ strName ) ) ; $ strName = preg_replace ( '/[^A-Za-z0-9._-]/' , '' , $ strName ) ; $ strName = basename ( $ strName ) ; $ xml = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; $ xml -> formatOutput = true ; $ tables = $ xml -> createElement ( 'tables' ) ; $ tables = $ xml -> appendChild ( $ tables ) ; $ this -> addTableTlTheme ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlStyleSheet ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlImageSize ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlModule ( $ xml , $ tables , $ objTheme ) ; $ this -> addTableTlLayout ( $ xml , $ tables , $ objTheme ) ; $ strTmp = md5 ( uniqid ( mt_rand ( ) , true ) ) ; $ objArchive = new ZipWriter ( 'system/tmp/' . $ strTmp ) ; $ this -> addTableTlFiles ( $ xml , $ tables , $ objTheme , $ objArchive ) ; $ this -> addTemplatesToArchive ( $ objArchive , $ objTheme -> templates ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'exportTheme' ] as $ callback ) { System :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ xml , $ objArchive , $ objTheme -> id ) ; } } $ objArchive -> addString ( $ xml -> saveXML ( ) , 'theme.xml' ) ; $ objArchive -> close ( ) ; $ objFile = new File ( 'system/tmp/' . $ strTmp ) ; $ objFile -> sendToBrowser ( $ strName . '.cto' ) ; }
10743	public function getDateTime ( $ keys , DateTime $ default = null ) { $ value = $ this -> getString ( $ keys ) ; if ( empty ( $ value ) ) { $ result = $ default ; } elseif ( $ value === ( string ) ( int ) $ value ) { $ result = new DateTime ( ) ; $ result -> setTimestamp ( ( int ) $ value ) ; } else { $ result = new DateTime ( $ value ) ; } return $ result ; }
3995	public function replaceTags ( $ strTag ) { $ arrElements = explode ( '::' , $ strTag ) ; if ( $ arrElements [ 0 ] != 'mm' ) { return false ; } try { switch ( $ arrElements [ 1 ] ) { case 'total' : return $ this -> getCount ( $ arrElements [ 2 ] , $ arrElements [ 3 ] ) ; case 'attribute' : return $ this -> getAttribute ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'item' : return $ this -> getItem ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; case 'jumpTo' : return $ this -> jumpTo ( $ arrElements [ 2 ] , $ arrElements [ 3 ] , $ arrElements [ 4 ] , $ arrElements [ 5 ] ) ; default : } } catch ( \ Exception $ exc ) { System :: log ( 'Error by replace tags: ' . $ exc -> getMessage ( ) , __CLASS__ . ' | ' . __FUNCTION__ , TL_ERROR ) ; } return false ; }
9189	public function present ( ) { $ presenterClass = $ this -> getPresenterClass ( ) ; if ( ! class_exists ( $ presenterClass ) ) { throw new Exceptions \ PresenterException ( 'The specified presenter does not exist.' ) ; } if ( ! $ this -> presenterInstance ) { $ this -> presenterInstance = new $ presenterClass ( $ this ) ; } return $ this -> presenterInstance ; }
10713	public function saveMany ( ArrayAccess $ models ) { if ( ! $ models instanceof Collection ) { $ models = collect ( $ models ) ; } foreach ( $ models as $ model ) { $ this -> save ( $ model ) ; } return $ models ; }
837	public static function detectBlockType ( Token $ token ) { foreach ( self :: getBlockEdgeDefinitions ( ) as $ type => $ definition ) { if ( $ token -> equals ( $ definition [ 'start' ] ) ) { return [ 'type' => $ type , 'isStart' => true ] ; } if ( $ token -> equals ( $ definition [ 'end' ] ) ) { return [ 'type' => $ type , 'isStart' => false ] ; } } }
10826	public static function table ( array $ rows , array $ headers = [ ] ) { $ table = new Table ( ) ; $ table -> setRows ( $ rows ) ; if ( count ( $ headers ) > 0 ) { $ table -> setHeaders ( $ headers ) ; } $ output = $ table -> render ( ) ; self :: writeln ( $ output ) ; }
5437	public function addPattern ( $ pattern , $ label = true ) { $ count = count ( $ this -> patterns ) ; $ this -> patterns [ $ count ] = $ pattern ; $ this -> labels [ $ count ] = $ label ; $ this -> regex = null ; }
12087	public static function create ( $ validator , $ command ) { static $ cache = [ ] ; $ cacheKey = $ validator ; if ( isset ( $ cache [ $ cacheKey ] ) ) { $ class = $ cache [ $ cacheKey ] [ 'class' ] ; $ validator = $ cache [ $ cacheKey ] [ 'validator' ] ; } else { if ( false === strpos ( $ validator , '.' ) ) { $ class = __NAMESPACE__ . '\\' . String :: convertToCamelCase ( $ validator ) ; } else { $ class = explode ( '.' , $ validator ) ; $ class = array_map ( array ( 'In2pire\\Component\\Utility\\Text' , 'convertToCamelCase' ) , $ class ) ; $ class = implode ( '\\' , $ class ) ; $ validator = substr ( $ validator , strrpos ( $ validator , '.' ) + 1 ) ; } $ cache [ $ cacheKey ] = [ 'class' => $ class , 'validator' => $ validator ] ; } if ( ! class_exists ( $ class ) ) { throw new \ RuntimeException ( 'Unknow validator ' . $ cacheKey ) ; } return new $ class ( $ command ) ; }
5180	private function addArray ( string $ key , $ value ) : self { $ this -> props [ $ key ] [ ] = $ value ; return $ this ; }
8925	public function mapJson ( $ json , $ targetClass ) { if ( ! is_array ( $ data = json_decode ( $ json , true ) ) ) { throw new InvalidJsonException ( ) ; } $ result = null ; if ( substr ( $ targetClass , - 2 ) == '[]' ) { $ result = [ ] ; foreach ( $ data as $ key => $ entryData ) { $ result [ ] = $ this -> mapDataToObject ( $ entryData , substr ( $ targetClass , 0 , - 2 ) ) ; } } else { $ result = $ this -> mapDataToObject ( $ data , $ targetClass ) ; } return $ result ; }
6338	public static function factory ( $ streamClass = 'GuzzleHttp\\Psr7\\Stream' ) { return new static ( [ new ResourceAdapter ( $ streamClass ) , new DomDocumentAdapter ( $ streamClass ) , new SimpleXmlAdapter ( $ streamClass ) , new StringAdapter ( $ streamClass ) , ] ) ; }
11918	public function register ( callable $ inject ) : void { $ reflection = new ReflectionFunction ( $ inject ) ; $ parameters = $ reflection -> getParameters ( ) ; foreach ( $ parameters as $ parameter ) { $ key = $ parameter -> name ; $ getter = function ( $ c ) use ( $ reflection , $ parameters , $ key ) { if ( isset ( $ c -> delegate ) ) { try { return $ c -> delegate -> get ( $ key ) ; } catch ( NotFoundExceptionInterface $ e ) { } } $ args = [ ] ; foreach ( $ parameters as $ param ) { if ( ! $ param -> isPassedByReference ( ) ) { $ args [ ] = $ c -> get ( $ param -> name ) ; } else { $ { $ param -> name } = null ; $ args [ $ param -> name ] = & $ { $ param -> name } ; } } $ reflection -> invokeArgs ( $ args ) ; foreach ( $ args as $ found => $ value ) { if ( ! is_numeric ( $ found ) && $ found == $ key ) { $ c :: $ map [ $ found ] = $ value ; } } if ( array_key_exists ( $ key , $ args ) ) { return $ args [ $ key ] ; } throw new NotFoundException ( $ key ) ; } ; static :: $ map [ $ key ] = new ReflectionFunction ( $ getter ) ; } }
576	public function run ( $ id = null ) { if ( Yii :: $ app -> getRequest ( ) -> getMethod ( ) !== 'OPTIONS' ) { Yii :: $ app -> getResponse ( ) -> setStatusCode ( 405 ) ; } $ options = $ id === null ? $ this -> collectionOptions : $ this -> resourceOptions ; $ headers = Yii :: $ app -> getResponse ( ) -> getHeaders ( ) ; $ headers -> set ( 'Allow' , implode ( ', ' , $ options ) ) ; $ headers -> set ( 'Access-Control-Allow-Methods' , implode ( ', ' , $ options ) ) ; }
2252	protected function redirectToFrontendPage ( $ intPage , $ strArticle = null , $ blnReturn = false ) { if ( ( $ intPage = ( int ) $ intPage ) <= 0 ) { return '' ; } $ objPage = PageModel :: findWithDetails ( $ intPage ) ; if ( $ objPage === null ) { return '' ; } $ strParams = null ; if ( $ strArticle !== null && ( $ objArticle = ArticleModel :: findByAlias ( $ strArticle ) ) !== null ) { $ strParams = '/articles/' . ( ( $ objArticle -> inColumn != 'main' ) ? $ objArticle -> inColumn . ':' : '' ) . $ strArticle ; } $ strUrl = $ objPage -> getFrontendUrl ( $ strParams ) ; if ( strncmp ( $ strUrl , 'http://' , 7 ) !== 0 && strncmp ( $ strUrl , 'https://' , 8 ) !== 0 ) { $ strUrl = Environment :: get ( 'base' ) . $ strUrl ; } if ( ! $ blnReturn ) { $ this -> redirect ( $ strUrl ) ; } return $ strUrl ; }
11093	public static function linkRewrite ( $ str , $ allowUnicodeChars = false ) { if ( ! \ is_string ( $ str ) ) { return false ; } $ str = trim ( $ str ) ; if ( \ function_exists ( 'mb_strtolower' ) ) { $ str = mb_strtolower ( $ str , 'utf-8' ) ; } if ( ! $ allowUnicodeChars ) { $ str = self :: replaceAccentedChars ( $ str ) ; } if ( $ allowUnicodeChars ) { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-\pL]/u' , '' , $ str ) ; } else { $ str = preg_replace ( '/[^a-zA-Z0-9\s\'\:\/\[\]\-]/' , '' , $ str ) ; } $ str = preg_replace ( '/[\s\'\:\/\[\]\-]+/' , ' ' , $ str ) ; $ str = str_replace ( [ ' ' , '/' ] , '-' , $ str ) ; if ( ! \ function_exists ( 'mb_strtolower' ) ) { $ str = strtolower ( $ str ) ; } return $ str ; }
2242	public static function getContentElement ( $ intId , $ strColumn = 'main' ) { if ( \ is_object ( $ intId ) ) { $ objRow = $ intId ; } else { if ( ! \ strlen ( $ intId ) || $ intId < 1 ) { return '' ; } $ objRow = ContentModel :: findByPk ( $ intId ) ; if ( $ objRow === null ) { return '' ; } } if ( ! static :: isVisibleElement ( $ objRow ) ) { return '' ; } $ strClass = ContentElement :: findClass ( $ objRow -> type ) ; if ( ! class_exists ( $ strClass ) ) { static :: log ( 'Content element class "' . $ strClass . '" (content element "' . $ objRow -> type . '") does not exist' , __METHOD__ , TL_ERROR ) ; return '' ; } $ objRow -> typePrefix = 'ce_' ; $ objElement = new $ strClass ( $ objRow , $ strColumn ) ; $ strBuffer = $ objElement -> generate ( ) ; if ( isset ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) && \ is_array ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] ) ) { foreach ( $ GLOBALS [ 'TL_HOOKS' ] [ 'getContentElement' ] as $ callback ) { $ strBuffer = static :: importStatic ( $ callback [ 0 ] ) -> { $ callback [ 1 ] } ( $ objRow , $ strBuffer , $ objElement ) ; } } if ( $ objElement -> protected && ! preg_match ( '/^\s*<!-- indexer::stop/' , $ strBuffer ) ) { $ strBuffer = "\n<!-- indexer::stop . $ strBuffer . "<!-- indexer::continue ; } return $ strBuffer ; }
5506	public function returnsAt ( $ timing , $ method , $ value , $ args = false ) { $ this -> dieOnNoMethod ( $ method , 'set return value sequence' ) ; $ this -> actions -> registerAt ( $ timing , $ method , $ args , new SimpleReturn ( $ value ) ) ; }
5379	protected function wrap ( $ text ) { $ text = str_replace ( "\r\r\n" , "\r\n" , str_replace ( "\n" , "\r\n" , $ text ) ) ; $ text = str_replace ( "\r\n\n" , "\r\n" , str_replace ( "\r" , "\r\n" , $ text ) ) ; if ( strncmp ( $ text , "\r\n" , strlen ( "\r\n" ) ) == 0 ) { $ text = substr ( $ text , strlen ( "\r\n" ) ) ; } if ( $ this -> wrapIsEnabled ( ) ) { return wordwrap ( $ text , ( integer ) $ this -> getAttribute ( 'cols' ) , "\r\n" ) ; } return $ text ; }
6605	public function validateRequestTokenResponse ( $ params ) { if ( ! isset ( $ params [ 'oauth_token' ] ) || ! isset ( $ params [ 'oauth_token_secret' ] ) || empty ( $ params [ 'oauth_token' ] ) || empty ( $ params [ 'oauth_token_secret' ] ) ) { throw new InvalidOAuthTokenException ( 'request token' ) ; } return true ; }
9867	private function writeMergeCells ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { if ( count ( $ pSheet -> getMergeCells ( ) ) > 0 ) { $ objWriter -> startElement ( 'mergeCells' ) ; foreach ( $ pSheet -> getMergeCells ( ) as $ mergeCell ) { $ objWriter -> startElement ( 'mergeCell' ) ; $ objWriter -> writeAttribute ( 'ref' , $ mergeCell ) ; $ objWriter -> endElement ( ) ; } $ objWriter -> endElement ( ) ; } }
11573	public function SendHeaders ( ) { if ( headers_sent ( ) ) { return $ this ; } header ( 'HTTP/' . $ this -> Version . ' ' . $ this -> StatusCode . ' ' . $ this -> StatusText , true , $ this -> StatusCode ) ; foreach ( $ this -> Headers -> GetCookies ( ) as $ cookie ) { } return $ this ; }
8534	public function setChargeInstrumentList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'ChargeInstrumentList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
6754	private static function createFolderIfNotExists ( string $ path ) { if ( false === @ mkdir ( $ path , 0777 , true ) && ! is_dir ( $ path ) ) { throw new \ RuntimeException ( sprintf ( "Unable to create the %s directory\n" , $ path ) ) ; } }
450	public static function encode ( $ value , $ options = 320 ) { $ expressions = [ ] ; $ value = static :: processData ( $ value , $ expressions , uniqid ( '' , true ) ) ; set_error_handler ( function ( ) { static :: handleJsonError ( JSON_ERROR_SYNTAX ) ; } , E_WARNING ) ; $ json = json_encode ( $ value , $ options ) ; restore_error_handler ( ) ; static :: handleJsonError ( json_last_error ( ) ) ; return $ expressions === [ ] ? $ json : strtr ( $ json , $ expressions ) ; }
11664	public function isValid ( array $ values ) { $ this -> errorMessages = [ ] ; foreach ( $ this -> elements -> getElements ( ) as $ element ) { $ elementId = $ element -> getID ( ) ; if ( empty ( $ elementId ) ) { continue ; } $ value = null ; if ( array_key_exists ( $ elementId , $ values ) ) { $ value = $ values [ $ elementId ] ; } $ element -> setValue ( $ value ) ; $ this -> filterElement ( $ element ) ; $ this -> validateElement ( $ element ) ; } return count ( $ this -> errorMessages ) === 0 ; }
11782	protected function generateSourceFromChildren ( ) { $ i = 1 ; $ children = array ( ) ; foreach ( $ this -> children as $ child ) { $ childValue = Yaml :: parse ( $ child -> getSource ( ) ) ; if ( is_array ( $ childValue ) && array_key_exists ( "type" , $ childValue ) ) { $ childValue [ "type" ] = $ child -> getType ( ) ; } $ children [ 'item' . $ i ] = $ childValue ; $ i ++ ; } $ source = array ( "children" => $ children , ) ; if ( ! empty ( $ this -> tags ) ) { $ source [ "tags" ] = $ this -> tags ; } $ source [ "type" ] = $ this -> type ; return $ source ; }
12468	public function getStream ( $ mediaId ) { $ response = $ this -> getHttp ( ) -> get ( self :: API_GET , [ 'media_id' => $ mediaId ] ) ; $ response -> getBody ( ) -> rewind ( ) ; $ body = $ response -> getBody ( ) -> getContents ( ) ; $ json = json_decode ( $ body , true ) ; if ( JSON_ERROR_NONE === json_last_error ( ) ) { $ this -> checkAndThrow ( $ json ) ; } return $ body ; }
10755	protected function buildTblOpt ( ) { $ result = [ ] ; foreach ( $ this -> tbl_option as $ opt ) { $ result [ ] = $ opt ; } if ( empty ( $ result ) ) { $ result [ ] = '' ; } return $ result ; }
973	public function creating ( $ shop ) { if ( ! isset ( $ shop -> namespace ) ) { $ shop -> namespace = Config :: get ( 'shopify-app.namespace' ) ; } if ( Config :: get ( 'shopify-app.billing_freemium_enabled' ) === true && ! isset ( $ shop -> freemium ) ) { $ shop -> freemium = true ; } }
11603	public function align ( PagesCollectionParser $ pagesCollectionParser ) { $ themeSlots = $ this -> findSlotsInTemplates ( ) ; $ slots = $ this -> mergeSlotsByStatus ( $ themeSlots ) ; if ( ! array_key_exists ( "page" , $ slots ) ) { return ; } $ pageSlots = $ slots [ "page" ] ; unset ( $ slots [ "page" ] ) ; $ files = $ this -> removeCommonSlots ( $ slots ) ; $ files = array_merge ( $ files , $ this -> removePageSlots ( $ pagesCollectionParser , $ pageSlots ) ) ; if ( ! empty ( $ files ) ) { $ fs = new Filesystem ( ) ; $ fs -> remove ( $ files ) ; } }
9250	public function boot ( ) { if ( $ this -> booted ) { return ; } $ this -> container = $ this -> initializeContainer ( ) ; $ this -> kernel = $ this -> container -> get ( 'http_kernel' ) ; $ this -> booted = true ; }
5063	public function outputJson ( int $ depth = 512 , int $ options = 0 ) { $ json = json_decode ( $ this -> output ( ) , false , $ depth , $ options ) ; if ( is_null ( $ json ) ) { $ errorMessage = json_last_error_msg ( ) ; throw new JsonDecodeException ( $ errorMessage ) ; } return $ json ; }
5561	protected function getParser ( ) { if ( $ this -> parser ) { return $ this -> parser ; } foreach ( SimpleTest :: getParsers ( ) as $ parser ) { if ( $ parser -> can ( ) ) { return $ parser ; } } }
7687	function Misc_CellRef ( $ Col , $ Row ) { $ r = '' ; $ x = $ Col ; do { $ x = $ x - 1 ; $ c = ( $ x % 26 ) ; $ x = ( $ x - $ c ) / 26 ; $ r = chr ( 65 + $ c ) . $ r ; } while ( $ x > 0 ) ; return $ r . $ Row ; }
1557	protected function defaultOrder ( $ query ) { if ( $ this -> doesRequireOrdering ( $ query ) ) { $ query -> orderBy ( $ this -> primaryKey ) ; } return $ this ; }
1360	public static function custom ( $ mediaType ) : self { if ( ! $ mediaType instanceof MediaTypeInterface ) { $ mediaType = MediaType :: parse ( 0 , $ mediaType ) ; } return new self ( $ mediaType , null ) ; }
6070	public function downloadArchive ( array $ ids , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'ids' => $ ids , 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/download' , $ parameters , $ cachePolicy ) ; return $ result ; }
5000	public function preRemove ( $ object ) { if ( ! is_null ( $ this -> urlProvider ) && ! is_null ( $ this -> menuManager ) ) { $ url = $ this -> urlProvider -> url ( $ object ) ; $ menuItem = $ this -> menuManager -> getItem ( $ url ) ; if ( $ menuItem instanceof MenuItem ) { $ this -> menuManager -> removeItem ( $ menuItem ) ; $ this -> menuManager -> flush ( ) ; } } }
8565	private function _convertGetEligibleShippingServices ( $ request ) { $ parameters = array ( ) ; $ parameters [ 'Action' ] = 'GetEligibleShippingServices' ; if ( $ request -> isSetSellerId ( ) ) { $ parameters [ 'SellerId' ] = $ request -> getSellerId ( ) ; } if ( $ request -> isSetMWSAuthToken ( ) ) { $ parameters [ 'MWSAuthToken' ] = $ request -> getMWSAuthToken ( ) ; } if ( $ request -> isSetShipmentRequestDetails ( ) ) { $ ShipmentRequestDetailsGetEligibleShippingServicesRequest = $ request -> getShipmentRequestDetails ( ) ; foreach ( $ ShipmentRequestDetailsGetEligibleShippingServicesRequest -> getAmazonOrderId ( ) as $ AmazonOrderIdShipmentRequestDetailsIndex => $ AmazonOrderIdShipmentRequestDetails ) { $ parameters [ 'ShipmentRequestDetails' . '.' . 'AmazonOrderId' . '.' . ( $ AmazonOrderIdShipmentRequestDetailsIndex + 1 ) ] = $ AmazonOrderIdShipmentRequestDetails ; } } return $ parameters ; }
12109	public function renamePage ( $ id , $ newName ) { $ this -> pages [ $ newName ] = $ this -> getPage ( $ id ) ; unset ( $ this -> pages [ $ id ] ) ; $ this -> persist ( ) ; }
10866	protected function createNewInst ( ) { $ classReflection = new \ ReflectionClass ( $ this -> instClass ) ; if ( $ this -> constructorArgs === null ) { return $ classReflection -> newInstance ( ) ; } else { return $ classReflection -> newInstanceArgs ( $ this -> concstructorArgs ) ; } }
7837	public function register ( ) { $ className = studly_case ( strtolower ( config ( 'message.vendor' , 'smsgatewayme' ) ) ) ; $ classPath = '\Yugo\SMSGateway\Vendors\\' . $ className ; if ( ! class_exists ( $ classPath ) ) { abort ( 500 , sprintf ( 'SMS vendor %s is not available.' , $ className ) ) ; } app ( ) -> bind ( SMS :: class , $ classPath ) ; }
10888	public function addOption ( $ short , $ long , $ arg , $ description ) { $ this -> parameters [ ] = array ( $ short , $ long , $ arg , $ description ) ; return $ this ; }
7529	function dumpLocation ( ) { return ( ( $ this -> parent ) ? ( ( $ p = $ this -> parent -> dumpLocation ( ) ) ? $ p . ' > ' : '' ) . $ this -> tag . '(' . $ this -> typeIndex ( ) . ')' : '' ) ; }
8822	public function rules ( Array $ rules ) { foreach ( $ rules as $ key => $ value ) { $ this -> rule ( $ key , $ value [ 'label' ] , $ value [ 'rules' ] , isset ( $ value [ 'text' ] ) && ! empty ( $ value [ 'text' ] ) ? $ value [ 'text' ] : [ ] ) ; } }
283	private function findFixtures ( array $ fixtures = [ ] ) { $ fixturesPath = $ this -> getFixturePath ( ) ; $ filesToSearch = [ '*Fixture.php' ] ; $ findAll = ( $ fixtures === [ ] ) ; if ( ! $ findAll ) { $ filesToSearch = [ ] ; foreach ( $ fixtures as $ fileName ) { $ filesToSearch [ ] = $ fileName . 'Fixture.php' ; } } $ files = FileHelper :: findFiles ( $ fixturesPath , [ 'only' => $ filesToSearch ] ) ; $ foundFixtures = [ ] ; foreach ( $ files as $ fixture ) { $ foundFixtures [ ] = $ this -> getFixtureRelativeName ( $ fixture ) ; } return $ foundFixtures ; }
4656	public function create ( Job $ job ) { $ context = new Context ( $ this -> buildPath . DIRECTORY_SEPARATOR . $ job -> getDirectory ( ) ) ; $ buildStream = $ this -> docker -> getImageManager ( ) -> build ( $ context -> toStream ( ) , [ 't' => $ job -> getName ( ) , 'q' => $ this -> quietBuild , 'nocache' => ! $ this -> usecache ] , ImageManager :: FETCH_STREAM ) ; $ buildStream -> onFrame ( $ this -> logger -> getBuildCallback ( ) ) ; $ buildStream -> wait ( ) ; try { return $ this -> docker -> getImageManager ( ) -> find ( $ job -> getName ( ) ) ; } catch ( ClientErrorException $ e ) { if ( $ e -> getResponse ( ) -> getStatusCode ( ) == 404 ) { return false ; } throw $ e ; } }
3235	public function getCountAttribute ( ) { if ( empty ( $ this -> shopCalculations ) ) $ this -> runCalculations ( ) ; return round ( $ this -> shopCalculations -> itemCount , 2 ) ; }
6015	public function retrieveSite ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/deployment/sites/' . $ id . '' , $ parameters , $ cachePolicy ) ; $ result = new DeploymentSiteResponse ( $ result ) ; return $ result ; }
5440	public function addEntryPattern ( $ pattern , $ mode , $ new_mode ) { if ( ! isset ( $ this -> regexes [ $ mode ] ) ) { $ this -> regexes [ $ mode ] = new ParallelRegex ( $ this -> case ) ; } $ this -> regexes [ $ mode ] -> addPattern ( $ pattern , $ new_mode ) ; if ( ! isset ( $ this -> mode_handlers [ $ new_mode ] ) ) { $ this -> mode_handlers [ $ new_mode ] = $ new_mode ; } }
8980	private function buildRateFromTableRowData ( array $ row ) { return new Rate ( $ row [ 'source_name' ] , ( float ) $ row [ 'rate_value' ] , $ row [ 'currency_code' ] , $ row [ 'rate_type' ] , \ DateTime :: createFromFormat ( 'Y-m-d' , $ row [ 'rate_date' ] ) , $ row [ 'base_currency_code' ] , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'created_at' ] ) , \ DateTime :: createFromFormat ( 'Y-m-d H:i:s' , $ row [ 'modified_at' ] ) ) ; }
7536	function detach ( $ move_children_up = false ) { if ( ( $ p = $ this -> parent ) !== null ) { $ index = $ this -> index ( ) ; $ this -> parent = null ; if ( $ move_children_up ) { $ this -> moveChildren ( $ p , $ index ) ; } $ p -> deleteChild ( $ this , true ) ; } }
12389	protected function updateCredentialHash ( PasswordableInterface $ identityObject , $ password ) { $ cryptoService = $ this -> getMapper ( ) -> getPasswordService ( ) ; if ( ! $ cryptoService instanceof Bcrypt ) { return $ this ; } $ hash = explode ( '$' , $ identityObject -> getPassword ( ) ) ; if ( $ hash [ 2 ] === $ cryptoService -> getCost ( ) ) { return $ this ; } $ identityObject -> setPassword ( $ cryptoService -> create ( $ password ) ) ; return $ this ; }
4774	public function build ( $ widgets , string $ widgetGroup = '' , array $ widgetId = [ ] ) { if ( ! $ widgets ) { return $ widgets ; } $ this -> loadUserConfig ( ) ; $ outputWidget = [ ] ; if ( $ widgetId ) { foreach ( $ widgetId as $ id ) { if ( isset ( $ widgets [ $ id ] ) ) { $ widgets [ $ id ] -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widgets [ $ id ] -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; $ outputWidget [ ] = $ widgets [ $ id ] ; } } return $ outputWidget ; } foreach ( $ widgets as $ widget ) { if ( '' !== $ widgetGroup && $ widget -> getGroup ( ) !== $ widgetGroup ) { continue ; } if ( isset ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ) { $ widget -> setOrder ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'order' ] ) ; } if ( null !== $ widget -> getOrder ( ) ) { while ( isset ( $ outputWidget [ $ widget -> getOrder ( ) ] ) ) { $ widget -> setOrder ( $ widget -> getOrder ( ) + 1 ) ; } $ outputWidget [ $ widget -> getOrder ( ) ] = $ widget ; } else { $ outputWidget [ ] = $ widget ; } $ widget -> setActive ( $ this -> widgetConfig [ $ widget -> getId ( ) ] [ 'status' ] ?? false ) ; $ widget -> setConfig ( $ this -> widgetConfig [ $ widget -> getId ( ) ] ?? [ ] ) ; } ksort ( $ outputWidget ) ; return $ outputWidget ; }
3124	protected function fixRange ( $ range , $ lastTimestamp = null ) { $ fixedRange = [ ] ; $ last = null ; $ open = false ; foreach ( $ range as $ point ) { if ( $ this -> isStartPoint ( $ point ) ) { if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ point , TimePoint :: TYPE_END ) ; } $ open = true ; } else if ( $ this -> isEndPoint ( $ point ) ) { if ( ! $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last ? $ last : $ point , TimePoint :: TYPE_START ) ; } $ open = false ; } $ fixedRange [ ] = $ point ; $ last = $ point ; } if ( $ last && $ open ) { $ fixedRange [ ] = $ this -> cloneTimePoint ( $ last , TimePoint :: TYPE_END , $ lastTimestamp ) ; } return $ fixedRange ; }
7257	public function urlAllowed ( $ url ) { if ( $ this -> _viewAuth ) { return $ this -> _viewAuth [ 'AuthActions' ] -> urlAllowed ( $ this -> user ( ) , $ url ) ; } return false ; }
3879	public function addSubProcedure ( FilterBuilderSql $ subProcedure ) { $ this -> procedures [ ] = $ subProcedure -> getProcedure ( ) ; $ this -> parameter = array_merge ( $ this -> parameter , $ subProcedure -> getParameters ( ) ) ; return $ this ; }
8207	protected function putJob ( $ tube , $ body , $ priority , $ delay , $ ttr ) { $ id = $ this -> getPheanstalk ( ) -> putInTube ( $ tube , $ body , $ priority , $ delay , $ ttr ) ; return $ id ; }
10009	public function createSheet ( $ sheetIndex = null ) { $ newSheet = new Worksheet ( $ this ) ; $ this -> addSheet ( $ newSheet , $ sheetIndex ) ; return $ newSheet ; }
6023	private function curlRequest ( $ url , $ httpVerb , array $ data = array ( ) , $ curlTimeout = 15 ) { if ( function_exists ( 'curl_init' ) && function_exists ( 'curl_setopt' ) ) { $ ch = curl_init ( ) ; curl_setopt ( $ ch , CURLOPT_URL , $ url ) ; curl_setopt ( $ ch , CURLOPT_HTTPHEADER , array ( 'Content-Type: application/json' ) ) ; curl_setopt ( $ ch , CURLOPT_USERAGENT , 'VPS/MC-API:3.0' ) ; curl_setopt ( $ ch , CURLOPT_TIMEOUT , $ curlTimeout ) ; curl_setopt ( $ ch , CURLOPT_SSL_VERIFYPEER , false ) ; curl_setopt ( $ ch , CURLOPT_USERPWD , "user:" . $ this -> apiKey ) ; curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , $ httpVerb ) ; if ( ! empty ( $ data ) ) { $ jsonData = json_encode ( $ data ) ; curl_setopt ( $ ch , CURLOPT_POSTFIELDS , $ jsonData ) ; } curl_setopt ( $ ch , CURLOPT_RETURNTRANSFER , true ) ; $ result = curl_exec ( $ ch ) ; curl_close ( $ ch ) ; return $ result ? json_decode ( $ result , true ) : false ; } throw new \ Exception ( 'curl extension is missing!' ) ; }
3851	public function setLimit ( $ blnUse , $ intOffset , $ intLimit ) { $ this -> paginationLimitCalculator -> setApplyLimitAndOffset ( $ blnUse ) -> setOffset ( $ intOffset ) -> setLimit ( $ intLimit ) ; return $ this ; }
12731	protected function getTasks ( ) { $ tasks = [ ] ; $ tasks [ 'flush-file-cache' ] = [ ] ; $ tasks [ 'flush-file-cache' ] [ 'title' ] = 'Flush File Cache' ; $ tasks [ 'flush-file-cache' ] [ 'description' ] = 'Clear the file cache in Cascade' ; $ tasks [ 'flush-file-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> fileCache -> flush ( ) ; Yii :: $ app -> response -> content = 'File cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; $ tasks [ 'flush-cache' ] = [ ] ; $ tasks [ 'flush-cache' ] [ 'title' ] = 'Flush Memory Cache' ; $ tasks [ 'flush-cache' ] [ 'description' ] = 'Clear the memory cache in Cascade' ; $ tasks [ 'flush-cache' ] [ 'run' ] = function ( ) { Yii :: $ app -> cache -> flush ( ) ; Yii :: $ app -> response -> content = 'Memory cache was flushed!' ; Yii :: $ app -> response -> taskOptions = [ 'state' => 'success' , 'title' => 'Success' ] ; } ; return $ tasks ; }
2728	public function execute ( ) { $ result = $ this -> resultJson -> create ( ) ; try { $ name = $ this -> getRequest ( ) -> getParam ( 'name' ) ; $ type = $ this -> getRequest ( ) -> getParam ( 'type' ) ; $ priority = $ this -> getRequest ( ) -> getParam ( 'priority' ) ; $ vcl = $ this -> getRequest ( ) -> getParam ( 'vcl' ) ; $ validation = $ this -> config -> validateCustomSnippet ( $ name , $ type , $ priority ) ; $ error = $ validation [ 'error' ] ; if ( $ error != null ) { throw new LocalizedException ( __ ( $ error ) ) ; } $ snippetName = $ validation [ 'snippet_name' ] ; $ fileName = $ type . '_' . $ priority . '_' . $ snippetName . '.vcl' ; $ write = $ this -> filesystem -> getDirectoryWrite ( DirectoryList :: VAR_DIR ) ; $ snippetPath = $ write -> getRelativePath ( Config :: CUSTOM_SNIPPET_PATH . $ fileName ) ; $ write -> writeFile ( $ snippetPath , $ vcl ) ; return $ result -> setData ( [ 'status' => true ] ) ; } catch ( \ Exception $ e ) { return $ result -> setData ( [ 'status' => false , 'msg' => $ e -> getMessage ( ) ] ) ; } }
4652	public function cleanDirectories ( $ jobs = array ( ) ) { foreach ( $ jobs as $ job ) { $ this -> filesystem -> remove ( $ job -> getDirectory ( ) ) ; } }
11238	public function getRedirect ( $ url = null ) { if ( $ url ) { if ( is_numeric ( $ url ) ) { $ steps = $ url ; $ offset = count ( $ _SESSION [ 'redirect' ] [ 'history' ] ) + $ steps ; if ( isset ( $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ) ) { $ redirect = $ _SESSION [ 'redirect' ] [ 'history' ] [ $ offset ] ; if ( ! empty ( $ redirect ) ) { return $ redirect ; } else { return BASE_URL ; } } else { return $ this -> config [ 'site_url' ] ; } } else { if ( substr ( $ url , 0 , 1 ) == '/' ) { return $ this -> config [ 'site_url' ] . substr ( $ url , 1 ) ; } else { return $ url ; } } } else { return $ this -> config [ 'site_url' ] ; } }
5313	protected function getHTMLListFromGenerator ( IconFontGenerator $ generator , $ fontFile ) { $ fontOptions = $ generator -> getFont ( ) -> getOptions ( ) ; $ html = '<ul>' ; $ glyphNames = $ generator -> getGlyphNames ( ) ; asort ( $ glyphNames ) ; foreach ( $ glyphNames as $ unicode => $ glyph ) { $ html .= "\n\t" . '<li data-icon="&#x' . $ unicode . ';" title="' . htmlspecialchars ( $ glyph ) . '">' . htmlspecialchars ( $ glyph ) . '</li>' ; } $ html .= "\n" . '</ul>' . "\n" ; return $ html ; }
5912	public function updateUser ( $ id , User $ user , $ password = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ 'user' => $ user , 'password' => $ password ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> post ( 'v1/accounts/users/' . $ id . '' , $ parameters ) ; $ result = new User ( $ result ) ; return $ result ; }
7876	protected function generateRequestIfGuarded ( ) { if ( ! $ this -> option ( 'unguard' ) ) { $ name = $ this -> inflector -> getRequest ( ) ; $ this -> call ( 'make:request' , compact ( 'name' ) ) ; } }
2529	protected function generateGuid ( ) { mt_srand ( ( double ) microtime ( ) * 10000 ) ; $ charId = strtoupper ( md5 ( uniqid ( rand ( ) , true ) ) ) ; $ hyphen = chr ( 45 ) ; $ uuid = substr ( $ charId , 0 , 8 ) . $ hyphen . substr ( $ charId , 8 , 4 ) . $ hyphen . substr ( $ charId , 12 , 4 ) . $ hyphen . substr ( $ charId , 16 , 4 ) . $ hyphen . substr ( $ charId , 20 , 12 ) ; return $ uuid ; }
5531	protected function chainThrowMethods ( ) { $ code = " function throwOn(\$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwOn(\$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function throwAt(\$timing, \$method, \$exception = false, \$args = false) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->throwAt(\$timing, \$method, \$exception, \$args);\n" ; $ code .= " }\n" ; $ code .= " function errorOn(\$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorOn(\$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; $ code .= " function errorAt(\$timing, \$method, \$error = 'A mock error', \$args = false, \$severity = E_USER_ERROR) {\n" ; $ code .= $ this -> bailOutIfNotMocked ( '$method' ) ; $ code .= " \$this->mock->errorAt(\$timing, \$method, \$error, \$args, \$severity);\n" ; $ code .= " }\n" ; return $ code ; }
11188	public static function set ( array $ arr , $ k , $ v ) { $ nested = ! is_array ( $ k ) ? explode ( '.' , $ k ) : $ k ; $ count = count ( $ nested ) ; if ( $ count == 1 ) { return $ arr [ $ k ] = $ v ; } elseif ( $ count > 1 ) { $ prev = '' ; $ loop = 1 ; $ unshift = $ nested ; foreach ( $ nested as $ part ) { if ( isset ( $ arr [ $ part ] ) && $ count > $ loop ) { $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; continue ; } else { if ( $ loop > 1 && $ loop < $ count ) { if ( ! isset ( $ arr [ $ prev ] [ $ part ] ) ) $ arr [ $ prev ] [ $ part ] = [ ] ; $ arr [ $ prev ] = static :: set ( $ arr [ $ prev ] , $ unshift , $ v ) ; $ loop ++ ; break ; } elseif ( $ loop >= 1 && $ loop == $ count ) { if ( ! is_array ( $ arr [ $ prev ] ) ) $ arr [ $ prev ] = [ ] ; if ( $ part == '' ) $ arr [ $ prev ] [ ] = $ v ; else $ arr [ $ prev ] [ $ part ] = $ v ; } else { $ arr [ $ part ] = [ ] ; $ prev = $ part ; array_shift ( $ unshift ) ; $ loop ++ ; } } } } return $ arr ; }
10125	private function writeAutoFilterInfo ( ) { $ record = 0x009D ; $ length = 0x0002 ; $ rangeBounds = Coordinate :: rangeBoundaries ( $ this -> phpSheet -> getAutoFilter ( ) -> getRange ( ) ) ; $ iNumFilters = 1 + $ rangeBounds [ 1 ] [ 0 ] - $ rangeBounds [ 0 ] [ 0 ] ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , $ iNumFilters ) ; $ this -> append ( $ header . $ data ) ; }
12570	public function previewNews ( $ message , $ to , $ by = self :: PREVIEW_BY_OPENID ) { return $ this -> preview ( self :: MSG_TYPE_NEWS , $ message , $ to , $ by ) ; }
11536	public static function cast ( $ time ) { return $ time instanceof self ? $ time : new self ( $ time -> format ( self :: ISO8601 ) , $ time -> getTimezone ( ) ) ; }
8437	public static function countRows ( array $ conditions , bool $ critical = false ) { $ entity = new static ( ) ; $ selectQuery = new Select ( $ entity -> getDatabaseName ( ) , $ critical ) ; $ selectQuery -> select ( [ 'count' => 'COUNT(*)' ] ) ; $ selectQuery -> from ( $ entity -> getTableName ( ) ) ; if ( count ( $ conditions ) > 0 ) { $ where = array ( ) ; foreach ( $ conditions as $ key => $ value ) { $ realName = constant ( get_called_class ( ) . '::FIELD_' . strtoupper ( Helper :: codifyName ( $ key ) ) ) ; $ where [ $ realName ] = ':where' . ucfirst ( $ key ) ; $ selectQuery -> bind ( 'where' . ucfirst ( $ key ) , $ value ) ; } $ selectQuery -> where ( $ where ) ; } if ( $ selectQuery -> execute ( ) === false ) { return false ; } $ data = $ selectQuery -> fetch ( ) ; if ( $ data === false ) { return false ; } return $ data [ 'count' ] ; }
7851	protected function grabParameter ( ReflectionParameter $ parameter ) { if ( isset ( $ this -> values [ $ parameter -> name ] ) ) { return $ this -> values [ $ parameter -> name ] ; } if ( $ parameter -> isDefaultValueAvailable ( ) ) { return $ parameter -> getDefaultValue ( ) ; } throw new Exception ( "Unable to map parameter [{$parameter->name}] to command [{$this->command}]" ) ; }
12428	public function setAuthorizerOption ( $ authorizerAppId , $ optionName , $ optionValue ) { $ params = [ 'component_appid' => $ this -> getAppId ( ) , 'authorizer_appid' => $ authorizerAppId , 'option_name' => $ optionName , 'option_value' => $ optionValue , ] ; return $ this -> parseJSON ( 'json' , [ self :: SET_AUTHORIZER_OPTION , $ params ] ) ; }
2846	public function getUrl ( $ path , array $ params = array ( ) ) { $ path = self :: MODULE_ROUTE . $ path ; $ params [ '_store' ] = $ this -> getRouteStoreId ( ) ; $ params [ '_nosid' ] = true ; return $ this -> _getUrl ( $ path , $ params ) ; }
2312	public function getCacheName ( ) { $ importantPart = $ this -> getImportantPart ( ) ; $ strCacheKey = substr ( md5 ( '-w' . $ this -> getTargetWidth ( ) . '-h' . $ this -> getTargetHeight ( ) . '-o' . $ this -> getOriginalPath ( ) . '-m' . $ this -> getResizeMode ( ) . '-z' . $ this -> getZoomLevel ( ) . '-x' . $ importantPart [ 'x' ] . '-y' . $ importantPart [ 'y' ] . '-i' . $ importantPart [ 'width' ] . '-e' . $ importantPart [ 'height' ] . '-t' . $ this -> fileObj -> mtime ) , 0 , 8 ) ; return StringUtil :: stripRootDir ( System :: getContainer ( ) -> getParameter ( 'contao.image.target_dir' ) ) . '/' . substr ( $ strCacheKey , - 1 ) . '/' . $ this -> fileObj -> filename . '-' . $ strCacheKey . '.' . $ this -> fileObj -> extension ; }
2148	public function removeSubscriptions ( $ intUser , $ strMode ) { if ( ! $ intUser ) { return ; } if ( $ strMode == 'close_delete' ) { $ this -> Database -> prepare ( "DELETE FROM tl_newsletter_recipients WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } else { $ this -> Database -> prepare ( "UPDATE tl_newsletter_recipients SET active='' WHERE email=(SELECT email FROM tl_member WHERE id=?)" ) -> execute ( $ intUser ) ; } }
10894	public function get ( $ name ) { return isset ( $ this -> uris [ $ name ] ) ? $ this -> uris [ $ name ] : null ; }
2591	public function loadPaymentData ( MopInfo $ options ) { if ( $ this -> checkAnyNotEmpty ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ) { $ this -> paymentData = new PaymentData ( $ options -> payMerchant , $ options -> transactionDate , $ options -> payments , $ options -> installmentsInfo , $ options -> fraudScreening , $ options -> payIds ) ; } }
7362	protected function updateAmountsTotal ( SaleInterface $ sale ) { $ changed = false ; $ currency = $ sale -> getCurrency ( ) -> getCode ( ) ; $ sale -> clearResults ( ) ; $ result = $ this -> amountCalculator -> calculateSale ( $ sale ) ; if ( 0 != Money :: compare ( $ result -> getBase ( ) , $ sale -> getNetTotal ( ) , $ currency ) ) { $ sale -> setNetTotal ( $ result -> getBase ( ) ) ; $ changed = true ; } if ( 0 != Money :: compare ( $ result -> getTotal ( ) , $ sale -> getGrandTotal ( ) , $ currency ) ) { $ sale -> setGrandTotal ( $ result -> getTotal ( ) ) ; $ changed = true ; } return $ changed ; }
3520	public function choice ( $ key , $ number , array $ replace = array ( ) , $ locale = null , $ useDB = null ) { $ inplaceEditMode = $ this -> manager -> config ( 'inplace_edit_mode' ) ; if ( $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 2 ) { if ( ! in_array ( $ key , $ this -> usedKeys ) ) { $ this -> usedKeys [ ] = $ key ; } } if ( ! $ this -> suspendInPlaceEdit && $ this -> inPlaceEditing ( ) && $ inplaceEditMode == 1 ) { return $ this -> get ( $ key , $ replace , $ locale , true , $ useDB ) ; } else { if ( $ useDB !== null ) { $ oldUseDB = $ this -> useDB ; $ this -> useDB = $ useDB ; $ retVal = parent :: choice ( $ key , $ number , $ replace , $ locale ) ; $ this -> useDB = $ oldUseDB ; return $ retVal ; } else { return parent :: choice ( $ key , $ number , $ replace , $ locale ) ; } } }
9546	public function count ( $ table , $ search , $ where = '' ) { if ( empty ( $ where ) ) { $ where = 'WHERE' ; } else { $ where = ( stripos ( $ where , 'WHERE' ) === false ) ? "WHERE {$where} AND" : "{$where} AND" ; } return $ this -> db -> value ( "SELECT COUNT(*) FROM {$table} AS s {$where} s.{$table} MATCH ?" , $ search ) ; }
11327	public function getLocations ( ) { if ( is_null ( $ this -> _locations ) ) { $ this -> _locations = $ this -> determineLocations ( ) ; } return $ this -> _locations ; }
3453	protected function determineStreamName ( string $ aggregateId ) : StreamName { if ( $ this -> oneStreamPerAggregate ) { if ( null === $ this -> streamName ) { $ prefix = $ this -> aggregateType -> toString ( ) ; } else { $ prefix = $ this -> streamName -> toString ( ) ; } return new StreamName ( $ prefix . '-' . $ aggregateId ) ; } if ( null === $ this -> streamName ) { return new StreamName ( 'event_stream' ) ; } return $ this -> streamName ; }
4818	public function addField ( $ name , $ value ) { if ( $ this -> currentRow < 0 ) { $ this -> appendRow ( ) ; } $ this -> collection [ $ this -> currentRow ] -> addField ( $ name , $ value ) ; }
2899	public function getQueryModels ( ) { $ queries = array ( ) ; foreach ( $ this -> _queryProfiles as $ queryId => $ queryProfile ) { $ queryModel = Mage :: getModel ( 'sheep_debug/query' ) ; $ stacktrace = array_key_exists ( $ queryId , $ this -> stackTraces ) ? $ this -> stackTraces [ $ queryId ] : '' ; $ queryModel -> init ( $ queryProfile , $ stacktrace ) ; $ queries [ ] = $ queryModel ; } return $ queries ; }
10315	function getUniqueClicksCount ( $ fromDate = null , $ toDate = null , $ mailingIds = null , $ contactIds = null , $ contactEmails = null , $ contactExternalIds = null , $ excludeAnonymousClicks = false ) { $ params = $ this -> createCountQueryParameters ( $ fromDate , $ toDate , $ contactIds , $ contactEmails , $ contactExternalIds , $ mailingIds , null ) ; if ( isset ( $ excludeAnonymousClicks ) ) $ params [ 'exclude_anonymous_clicks' ] = ( $ excludeAnonymousClicks == true ) ? "true" : "false" ; return $ this -> get ( 'reports/clicks/unique/count' , $ params ) ; }
7844	public function device ( ? int $ id = null ) : ? array { if ( is_null ( $ id ) ) { $ id = $ this -> device ; } $ key = sprintf ( 'smsgatewayme.device.%s' , $ id ) ; $ device = Cache :: remember ( $ key , 3600 * 24 * 7 , function ( ) use ( & $ response , $ id ) { $ response = Request :: get ( $ this -> baseUrl . 'device/' . $ id ) ; if ( $ response -> code != 200 ) { if ( ! empty ( $ response -> body -> message ) ) { Log :: error ( $ response -> body -> message ) ; } } return $ response -> body ; } ) ; return [ 'code' => $ response -> code ?? 200 , 'message' => 'OK' , 'data' => $ device , ] ; }
1409	public function memberRequired ( string $ path , string $ member ) : ErrorInterface { return new Error ( null , null , Response :: HTTP_BAD_REQUEST , $ this -> trans ( 'member_required' , 'code' ) , $ this -> trans ( 'member_required' , 'title' ) , $ this -> trans ( 'member_required' , 'detail' , compact ( 'member' ) ) , $ this -> pointer ( $ path ) ) ; }
4482	public function setBacklog ( int $ backlog ) : void { if ( $ this -> client -> call ( 'recur.update' , $ this -> jid , 'backlog' , $ backlog ) ) { $ this -> backlog = $ backlog ; } }
2316	protected function prepareResizeConfig ( ) { $ resizeConfig = new ResizeConfiguration ( ) ; $ resizeConfig -> setWidth ( $ this -> targetWidth ) ; $ resizeConfig -> setHeight ( $ this -> targetHeight ) ; $ resizeConfig -> setZoomLevel ( $ this -> zoomLevel ) ; if ( substr_count ( $ this -> resizeMode , '_' ) === 1 ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; $ resizeConfig -> setZoomLevel ( 0 ) ; } else { try { $ resizeConfig -> setMode ( $ this -> resizeMode ) ; } catch ( \ InvalidArgumentException $ exception ) { $ resizeConfig -> setMode ( ResizeConfiguration :: MODE_CROP ) ; } } return $ resizeConfig ; }
8514	public function listInboundShipmentsByNextToken ( $ request ) { if ( ! ( $ request instanceof FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ) ) { $ request = new FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'ListInboundShipmentsByNextToken' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; $ response = FBAInboundServiceMWS_Model_ListInboundShipmentsByNextTokenResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
6670	public function get_movie_rating ( $ votes ) { $ votations = [ ] ; foreach ( $ votes as $ key => $ value ) { for ( $ i = 0 ; $ i < $ value ; $ i ++ ) { $ votations [ ] = $ key ; } } if ( count ( $ votations ) ) { $ rating = array_sum ( $ votations ) / count ( $ votations ) ; return round ( $ rating , 1 ) ; } return 'N/A' ; }
5656	private function walkChildren ( $ node ) { if ( $ node -> hasChildren ( ) ) { foreach ( $ node -> child as $ child ) { $ this -> walkTree ( $ child ) ; } } }
11747	public function group ( ) { if ( is_null ( $ this -> group ) ) { $ this -> group = new Group ( $ this -> accessToken ) ; } return $ this -> group ; }
1855	public static function findUpcomingByPids ( $ arrIds , $ intLimit = 0 , array $ arrOptions = array ( ) ) { if ( empty ( $ arrIds ) || ! \ is_array ( $ arrIds ) ) { return null ; } $ t = static :: $ strTable ; $ time = Date :: floorToMinute ( ) ; $ arrColumns = array ( "($t.endTime>=$time OR ($t.recurring='1' AND ($t.recurrences=0 OR $t.repeatEnd>=$time))) AND $t.pid IN(" . implode ( ',' , array_map ( '\intval' , $ arrIds ) ) . ") AND ($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ) ; if ( $ intLimit > 0 ) { $ arrOptions [ 'limit' ] = $ intLimit ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = "$t.startTime" ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
12968	protected function renderPage ( ) { $ page = $ this -> options [ "page" ] ; $ request = $ this -> options [ "request" ] ; $ username = $ this -> options [ "username" ] ; $ pageOptions = array ( 'page' => $ request -> get ( 'page' ) , 'language' => $ request -> get ( '_locale' ) , 'country' => $ request -> get ( 'country' ) , ) ; $ page -> render ( $ this -> configuration -> siteDir ( ) , $ pageOptions , $ username ) ; return $ page ; }
3159	public function storeVariables ( QtiRunnerServiceContext $ context , $ itemUri , $ metaVariables , $ itemId = null ) { $ sessionId = $ context -> getTestSession ( ) -> getSessionId ( ) ; $ deliveryServerService = $ this -> getServiceManager ( ) -> get ( DeliveryServerService :: SERVICE_ID ) ; $ resultStore = $ deliveryServerService -> getResultStoreWrapper ( $ sessionId ) ; $ testUri = $ context -> getTestDefinitionUri ( ) ; if ( ! is_null ( $ itemUri ) ) { $ resultStore -> storeItemVariables ( $ testUri , $ itemUri , $ metaVariables , $ this -> getTransmissionId ( $ context , $ itemId ) ) ; } else { $ resultStore -> storeTestVariables ( $ testUri , $ metaVariables , $ sessionId ) ; } return true ; }
6454	private function createNotAcceptableException ( string $ type ) : HttpException { $ headers = new HttpHeaders ( ) ; $ headers -> add ( 'Content-Type' , 'application/json' ) ; $ body = new StringBody ( json_encode ( $ this -> contentNegotiator -> getAcceptableResponseMediaTypes ( $ type ) ) ) ; $ response = new Response ( HttpStatusCodes :: HTTP_NOT_ACCEPTABLE , $ headers , $ body ) ; return new HttpException ( $ response ) ; }
12941	public function storePermissions ( $ params = array ( ) ) { $ authorityAreaTitle = $ this -> input -> getString ( "area-title" ) ; $ authorityAreaURI = $ this -> input -> getString ( "area-uri" ) ; $ authorityAreaAction = $ this -> input -> getString ( "area-action" ) ; $ authorityAreaPermission = $ this -> input -> getString ( "area-permission" ) ; $ authorityId = $ this -> input -> getInt ( "area-authority" ) ; $ table = $ this -> load -> table ( "?authority_permissions" ) ; $ aData = array ( "authority_id" => $ authorityId , "permission_area_uri" => strtolower ( $ authorityAreaURI ) , "permission" => strtolower ( $ authorityAreaPermission ) , "permission_type" => strtolower ( $ authorityAreaAction ) , "permission_title" => $ authorityAreaTitle ) ; foreach ( $ aData as $ k => $ item ) { if ( empty ( $ item ) ) { $ this -> setError ( _t ( "Please complete all permission fields; Provide a title and uri defining the area, a permission type and value" ) ) ; return false ; } } if ( ! $ table -> bindData ( $ aData ) ) { throw new \ Platform \ Exception ( $ table -> getError ( ) ) ; return false ; } if ( $ table -> isNewRow ( ) ) { } if ( ! $ table -> save ( ) ) { return false ; } return true ; }
1270	private function createRequest ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ quantumViewRequest = $ xml -> appendChild ( $ xml -> createElement ( 'QuantumViewRequest' ) ) ; $ quantumViewRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; if ( null !== $ this -> name || null !== $ this -> beginDateTime || null !== $ this -> fileName ) { $ subscriptionRequest = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'SubscriptionRequest' ) ) ; if ( null !== $ this -> name ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'Name' , $ this -> name ) ) ; } if ( null !== $ this -> beginDateTime ) { $ dateTimeRange = $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'DateTimeRange' ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'BeginDateTime' , $ this -> beginDateTime ) ) ; $ dateTimeRange -> appendChild ( $ xml -> createElement ( 'EndDateTime' , $ this -> endDateTime ) ) ; } elseif ( null !== $ this -> fileName ) { $ subscriptionRequest -> appendChild ( $ xml -> createElement ( 'FileName' , $ this -> fileName ) ) ; } } if ( null !== $ this -> bookmark ) { $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Bookmark' , $ this -> bookmark ) ) ; } $ request = $ quantumViewRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'QVEvents' ) ) ; return $ xml -> saveXML ( ) ; }
1030	private function completeValueCatchingError ( Type $ returnType , $ fieldNodes , ResolveInfo $ info , $ path , $ result ) { $ exeContext = $ this -> exeContext ; if ( $ returnType instanceof NonNull ) { return $ this -> completeValueWithLocatedError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; } try { $ completed = $ this -> completeValueWithLocatedError ( $ returnType , $ fieldNodes , $ info , $ path , $ result ) ; $ promise = $ this -> getPromise ( $ completed ) ; if ( $ promise ) { return $ promise -> then ( null , function ( $ error ) use ( $ exeContext ) { $ exeContext -> addError ( $ error ) ; return $ this -> exeContext -> promises -> createFulfilled ( null ) ; } ) ; } return $ completed ; } catch ( Error $ err ) { $ exeContext -> addError ( $ err ) ; return null ; } }
7743	public function setValue ( $ entity , $ value ) { if ( false === ( $ entity instanceof $ this -> class ) ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as the entity is not an instance of {$this->class}." ) ; } if ( ! is_array ( $ value ) && ! ( $ value instanceof \ Traversable ) ) { if ( ( null !== $ this -> adderRemover ) && ( null !== $ this -> getter ) ) { $ itemsToAdd = is_object ( $ value ) ? iterator_to_array ( $ value ) : $ value ; $ itemToRemove = array ( ) ; $ previousValue = $ this -> getValue ( $ entity ) ; if ( is_array ( $ previousValue ) || $ previousValue instanceof \ Traversable ) { foreach ( $ previousValue as $ previousItem ) { foreach ( $ value as $ key => $ item ) { if ( $ item === $ previousItem ) { unset ( $ itemsToAdd [ $ key ] ) ; continue 2 ; } } $ itemToRemove [ ] = $ previousItem ; } } foreach ( $ itemToRemove as $ item ) { call_user_func ( array ( $ entity , 'remove' . $ this -> adderRemover ) , $ item ) ; } foreach ( $ itemsToAdd as $ item ) { call_user_func ( array ( $ entity , 'add' . $ this -> adderRemover ) , $ item ) ; } return ; } } if ( null === $ this -> setter ) { throw new \ Exception ( "Can't set the entity's {$this->name} property as no setter has been found." ) ; } if ( self :: GETTER_SETTER_METHOD === $ this -> setterType ) { return $ entity -> { $ this -> setter } ( $ value ) ; } else { return $ entity -> { $ this -> setter } = $ value ; } }
6779	protected function configureAcceptedSale ( SaleInterface $ sale ) { if ( null === $ date = $ sale -> getAcceptedAt ( ) ) { return false ; } $ changed = $ this -> updateExchangeRate ( $ sale ) ; $ changed |= $ this -> updateLocale ( $ sale ) ; return $ changed ; }
6640	private function getContainerRoute ( array $ routes , $ name ) { foreach ( $ routes as $ route => $ names ) { if ( in_array ( $ name , $ names , false ) ) { return $ route ; } } throw new Exception ( "Unknown configuration class name '{$name}'" ) ; }
10818	public static function error ( $ messages , $ linebreak = true , $ length = 0 ) { $ separator = $ linebreak ? "\n" : '' ; self :: write ( $ messages , 'error' , $ length , $ separator ) ; }
2862	public function startRequest ( ) { foreach ( $ this -> files as $ logFile ) { $ logFilePath = $ this -> getLogFilePath ( $ logFile ) ; $ this -> ranges [ $ logFile ] = array ( 'start' => $ this -> getLastFilePosition ( $ logFilePath ) , 'end' => 0 ) ; } }
4525	protected function createZoneMemberCountryFromDefinition ( array $ definition ) { $ zoneMember = new ZoneMemberCountry ( ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; $ this -> name = $ definition [ 'name' ] ; $ this -> countryCode = $ definition [ 'country_code' ] ; if ( isset ( $ definition [ 'administrative_area' ] ) ) { $ this -> administrativeArea = $ definition [ 'administrative_area' ] ; } if ( isset ( $ definition [ 'locality' ] ) ) { $ this -> locality = $ definition [ 'locality' ] ; } if ( isset ( $ definition [ 'dependent_locality' ] ) ) { $ this -> dependentLocality = $ definition [ 'dependent_locality' ] ; } if ( isset ( $ definition [ 'included_postal_codes' ] ) ) { $ this -> includedPostalCodes = $ definition [ 'included_postal_codes' ] ; } if ( isset ( $ definition [ 'excluded_postal_codes' ] ) ) { $ this -> excludedPostalCodes = $ definition [ 'excluded_postal_codes' ] ; } } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberCountry' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
4734	public function write_data ( ) { $ option_key = "_wp_session_{$this->session_id}" ; if ( $ this -> dirty ) { if ( false === get_option ( $ option_key ) ) { add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; add_option ( "_wp_session_expires_{$this->session_id}" , $ this -> expires , '' , 'no' ) ; } else { delete_option ( "_wp_session_{$this->session_id}" ) ; add_option ( "_wp_session_{$this->session_id}" , $ this -> container , '' , 'no' ) ; } } }
695	public function beforeSend ( $ message ) { $ event = new MailEvent ( [ 'message' => $ message ] ) ; $ this -> trigger ( self :: EVENT_BEFORE_SEND , $ event ) ; return $ event -> isValid ; }
6591	protected function asset ( $ type ) { $ busters = $ this -> checkAndGetBusters ( ) ; $ bustersOfThisType = array ( ) ; foreach ( $ busters as $ key => $ value ) { if ( strpos ( $ key , $ type ) !== false ) { $ bustersOfThisType [ $ key ] = $ value ; } } $ busterStrings = $ this -> parseTags ( $ bustersOfThisType , $ type ) ; return implode ( "\n" , $ busterStrings ) ; }
4343	protected function popStack ( ) { $ stackInfo = \ array_pop ( $ this -> funcStack ) ; $ funcPopped = $ stackInfo [ 'function' ] ; $ timeElapsed = \ microtime ( true ) - $ stackInfo [ 'tsStart' ] ; $ this -> data [ $ funcPopped ] [ 'ownTime' ] += $ timeElapsed - $ stackInfo [ 'subTime' ] ; $ this -> data [ $ funcPopped ] [ 'totalTime' ] += $ timeElapsed ; if ( $ this -> data [ $ funcPopped ] [ 'calls' ] === 0 ) { $ this -> data [ $ funcPopped ] [ 'calls' ] ++ ; } if ( $ this -> funcStack ) { $ this -> funcStack [ \ count ( $ this -> funcStack ) - 1 ] [ 'subTime' ] += $ timeElapsed ; } return $ stackInfo [ 'function' ] ; }
11821	function prepare_items ( ) { $ this -> columns = array ( $ this -> get_columns ( ) , $ this -> get_hidden_columns ( ) , $ this -> get_sortable_columns ( ) ) ; $ this -> items = $ this -> get_items ( ) ; usort ( $ this -> example_data , array ( $ this , 'usort_reorder' ) ) ; }
933	public function equals ( $ other , $ caseSensitive = true ) { if ( $ other instanceof self ) { if ( ! $ other -> isArray ) { $ otherPrototype = $ other -> content ; } else { $ otherPrototype = [ $ other -> id , $ other -> content , ] ; } } else { $ otherPrototype = $ other ; } if ( $ this -> isArray !== \ is_array ( $ otherPrototype ) ) { return false ; } if ( ! $ this -> isArray ) { return $ this -> content === $ otherPrototype ; } if ( $ this -> id !== $ otherPrototype [ 0 ] ) { return false ; } if ( isset ( $ otherPrototype [ 1 ] ) ) { if ( $ caseSensitive ) { if ( $ this -> content !== $ otherPrototype [ 1 ] ) { return false ; } } elseif ( 0 !== strcasecmp ( $ this -> content , $ otherPrototype [ 1 ] ) ) { return false ; } } unset ( $ otherPrototype [ 0 ] , $ otherPrototype [ 1 ] ) ; return empty ( $ otherPrototype ) ; }
143	private static function fixHttpHeaderField ( $ header ) { if ( ! is_array ( $ header ) ) { $ header = explode ( "\r\n" , $ header ) ; } uasort ( $ header , function ( $ el ) { return stripos ( $ el , 'content-type' ) === 0 ? 1 : - 1 ; } ) ; return $ header ; }
3660	private function getFilterRule ( ) { $ this -> compile ( ) ; return new SimpleQuery ( $ this -> queryString , $ this -> queryParameter , 'id' , $ this -> container -> get ( Connection :: class ) ) ; }
1898	private function checkIfAccountIsActive ( User $ user ) : void { $ config = $ this -> framework -> getAdapter ( Config :: class ) ; $ start = ( int ) $ user -> start ; $ stop = ( int ) $ user -> stop ; $ time = Date :: floorToMinute ( time ( ) ) ; $ notActiveYet = $ start && $ start > $ time ; $ notActiveAnymore = $ stop && $ stop <= ( $ time + 60 ) ; $ logMessage = '' ; if ( $ notActiveYet ) { $ logMessage = sprintf ( 'The account is not active yet (activation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ start ) ) ; } if ( $ notActiveAnymore ) { $ logMessage = sprintf ( 'The account is not active anymore (deactivation date: %s)' , Date :: parse ( $ config -> get ( 'dateFormat' ) , $ stop ) ) ; } if ( '' === $ logMessage ) { return ; } $ ex = new DisabledException ( $ logMessage ) ; $ ex -> setUser ( $ user ) ; throw $ ex ; }
1331	public function queryToOne ( $ relation , EncodingParametersInterface $ parameters ) { return $ this -> queryOne ( $ relation -> newQuery ( ) , $ this -> getQueryParameters ( $ parameters ) ) ; }
3602	public function isDebug ( ) { if ( null !== $ this -> container && $ this -> container -> has ( 'kernel' ) ) { return $ this -> container -> get ( 'kernel' ) -> isDebug ( ) ; } return true ; }
513	public function actionUp ( $ limit = 0 ) { $ migrations = $ this -> getNewMigrations ( ) ; if ( empty ( $ migrations ) ) { $ this -> stdout ( "No new migrations found. Your system is up-to-date.\n" , Console :: FG_GREEN ) ; return ExitCode :: OK ; } $ total = count ( $ migrations ) ; $ limit = ( int ) $ limit ; if ( $ limit > 0 ) { $ migrations = array_slice ( $ migrations , 0 , $ limit ) ; } $ n = count ( $ migrations ) ; if ( $ n === $ total ) { $ this -> stdout ( "Total $n new " . ( $ n === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } else { $ this -> stdout ( "Total $n out of $total new " . ( $ total === 1 ? 'migration' : 'migrations' ) . " to be applied:\n" , Console :: FG_YELLOW ) ; } foreach ( $ migrations as $ migration ) { $ nameLimit = $ this -> getMigrationNameLimit ( ) ; if ( $ nameLimit !== null && strlen ( $ migration ) > $ nameLimit ) { $ this -> stdout ( "\nThe migration name '$migration' is too long. Its not possible to apply this migration.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ this -> stdout ( "\t$migration\n" ) ; } $ this -> stdout ( "\n" ) ; $ applied = 0 ; if ( $ this -> confirm ( 'Apply the above ' . ( $ n === 1 ? 'migration' : 'migrations' ) . '?' ) ) { foreach ( $ migrations as $ migration ) { if ( ! $ this -> migrateUp ( $ migration ) ) { $ this -> stdout ( "\n$applied from $n " . ( $ applied === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_RED ) ; $ this -> stdout ( "\nMigration failed. The rest of the migrations are canceled.\n" , Console :: FG_RED ) ; return ExitCode :: UNSPECIFIED_ERROR ; } $ applied ++ ; } $ this -> stdout ( "\n$n " . ( $ n === 1 ? 'migration was' : 'migrations were' ) . " applied.\n" , Console :: FG_GREEN ) ; $ this -> stdout ( "\nMigrated up successfully.\n" , Console :: FG_GREEN ) ; } }
6874	private function findOrCreateItem ( ShipmentInterface $ shipment , SaleItemInterface $ saleItem , $ expected , $ available = null ) { $ item = null ; if ( 0 >= $ expected ) { return $ item ; } foreach ( $ shipment -> getItems ( ) as $ i ) { if ( $ i -> getSaleItem ( ) === $ saleItem ) { $ item = $ i ; break ; } } if ( null === $ item ) { $ item = $ this -> factory -> createItemForShipment ( $ shipment ) ; $ item -> setShipment ( $ shipment ) ; $ item -> setSaleItem ( $ saleItem ) ; } $ item -> setExpected ( $ expected ) ; if ( $ shipment -> isReturn ( ) ) { $ item -> setAvailable ( $ expected ) ; } else { if ( null === $ available ) { $ available = $ this -> calculator -> calculateAvailableQuantity ( $ saleItem , $ shipment ) ; } $ item -> setAvailable ( $ available ) ; if ( null === $ shipment -> getId ( ) ) { $ item -> setQuantity ( min ( $ expected , $ available ) ) ; } } return $ item ; }
7125	static public function equals ( AddressInterface $ source , AddressInterface $ target ) { if ( ! ( $ source -> getCompany ( ) === $ target -> getCompany ( ) && $ source -> getGender ( ) === $ target -> getGender ( ) && $ source -> getFirstName ( ) === $ target -> getFirstName ( ) && $ source -> getLastName ( ) === $ target -> getLastName ( ) && $ source -> getStreet ( ) === $ target -> getStreet ( ) && $ source -> getComplement ( ) === $ target -> getComplement ( ) && $ source -> getSupplement ( ) === $ target -> getSupplement ( ) && $ source -> getExtra ( ) === $ target -> getExtra ( ) && $ source -> getCity ( ) === $ target -> getCity ( ) && $ source -> getPostalCode ( ) === $ target -> getPostalCode ( ) && $ source -> getDigicode1 ( ) === $ target -> getDigicode1 ( ) && $ source -> getDigicode2 ( ) === $ target -> getDigicode2 ( ) && $ source -> getIntercom ( ) === $ target -> getIntercom ( ) ) ) { return false ; } $ sourceCountryId = $ source -> getCountry ( ) ? $ source -> getCountry ( ) -> getId ( ) : null ; $ targetCountryId = $ target -> getCountry ( ) ? $ target -> getCountry ( ) -> getId ( ) : null ; if ( $ sourceCountryId != $ targetCountryId ) { return false ; } $ sourceStateId = $ source -> getState ( ) ? $ source -> getState ( ) -> getId ( ) : null ; $ targetStateId = $ target -> getState ( ) ? $ target -> getState ( ) -> getId ( ) : null ; if ( $ sourceStateId != $ targetStateId ) { return false ; } $ sourcePhone = ( string ) $ source -> getPhone ( ) ; $ targetPhone = ( string ) $ target -> getPhone ( ) ; if ( $ sourcePhone !== $ targetPhone ) { return false ; } $ sourceMobile = ( string ) $ source -> getMobile ( ) ; $ targetMobile = ( string ) $ target -> getMobile ( ) ; if ( $ sourceMobile !== $ targetMobile ) { return false ; } return true ; }
1205	protected function renderItem ( ItemInterface $ item , array $ options ) { if ( ! $ item -> isDisplayed ( ) ) { return '' ; } $ class = ( array ) $ item -> getAttribute ( 'class' ) ; if ( $ this -> matcher -> isCurrent ( $ item ) ) { $ class [ ] = $ options [ 'currentClass' ] ; } elseif ( $ this -> matcher -> isAncestor ( $ item , $ options [ 'matchingDepth' ] ) ) { $ class [ ] = $ options [ 'ancestorClass' ] ; } if ( $ item -> actsLikeFirst ( ) ) { $ class [ ] = $ options [ 'firstClass' ] ; } if ( $ item -> actsLikeLast ( ) ) { $ class [ ] = $ options [ 'lastClass' ] ; } if ( $ item -> hasChildren ( ) && $ options [ 'depth' ] !== 0 ) { if ( null !== $ options [ 'branch_class' ] && $ item -> getDisplayChildren ( ) ) { $ class [ ] = $ options [ 'branch_class' ] ; } } elseif ( null !== $ options [ 'leaf_class' ] ) { $ class [ ] = $ options [ 'leaf_class' ] ; } $ attributes = $ item -> getAttributes ( ) ; if ( ! empty ( $ class ) ) { $ attributes [ 'class' ] = implode ( ' ' , $ class ) ; } $ html = $ this -> format ( '<li' . $ this -> renderHtmlAttributes ( $ attributes ) . '>' , 'li' , $ item -> getLevel ( ) , $ options ) ; $ html .= $ this -> renderLink ( $ item , $ options ) ; $ childrenClass = ( array ) $ item -> getChildrenAttribute ( 'class' ) ; $ childrenClass [ ] = 'menu_level_' . $ item -> getLevel ( ) ; $ childrenAttributes = $ item -> getChildrenAttributes ( ) ; $ childrenAttributes [ 'class' ] = implode ( ' ' , $ childrenClass ) ; $ html .= $ this -> renderList ( $ item , $ childrenAttributes , $ options ) ; $ html .= $ this -> format ( '</li>' , 'li' , $ item -> getLevel ( ) , $ options ) ; return $ html ; }
438	public function __isset ( $ name ) { $ getter = 'get' . $ name ; if ( method_exists ( $ this , $ getter ) ) { return $ this -> $ getter ( ) !== null ; } $ this -> ensureBehaviors ( ) ; foreach ( $ this -> _behaviors as $ behavior ) { if ( $ behavior -> canGetProperty ( $ name ) ) { return $ behavior -> $ name !== null ; } } return false ; }
6209	public function notifyOnError ( $ message , array $ backtrace = null , $ extraParams = null ) { if ( ! $ backtrace ) { $ backtrace = debug_backtrace ( ) ; if ( count ( $ backtrace ) > 1 ) { array_shift ( $ backtrace ) ; } } $ notice = new Notice ; $ notice -> load ( array ( 'errorClass' => 'PHP::Error' , 'backtrace' => $ backtrace , 'errorMessage' => $ message , 'extraParameters' => $ extraParams , ) ) ; return $ this -> notify ( $ notice ) ; }
6616	public function getEndpointResult ( $ method , $ endpointName , Request $ request ) { $ methodName = $ this -> parseEndpointName ( $ method , $ endpointName ) ; if ( ! $ this -> reflection -> hasMethod ( $ methodName ) ) { throw new \ RuntimeException ( "{$this->reflection->getName()}::{$methodName} does not exist" ) ; } $ reflectionMethod = $ this -> reflection -> getMethod ( $ methodName ) ; return $ reflectionMethod -> invokeArgs ( $ this -> controller , $ this -> mapRequestToArguments ( $ reflectionMethod , $ request ) ) ; }
7983	public function addRestoreTask ( $ sessionId ) { return json_decode ( self :: getClient ( ) -> createPcaRestoreTask ( $ this -> pp , $ this -> sn , $ sessionId ) ) ; }
4399	protected function saveRepayData ( \ Omnipay \ Common \ Message \ ResponseInterface $ response , $ customerId ) { $ data = [ ] ; if ( method_exists ( $ response , 'getCardReference' ) ) { $ data [ 'token' ] = $ response -> getCardReference ( ) ; } if ( method_exists ( $ response , 'getExpiryMonth' ) ) { $ data [ 'month' ] = $ response -> getExpiryMonth ( ) ; } if ( method_exists ( $ response , 'getExpiryYear' ) ) { $ data [ 'year' ] = $ response -> getExpiryYear ( ) ; } if ( ! empty ( $ data ) ) { $ this -> setCustomerData ( $ customerId , 'repay' , $ data ) ; } }
4781	public function addWidgetConfig ( string $ widgetId , array $ config = [ ] ) { $ this -> config [ $ widgetId ] = array_merge ( $ this -> config [ $ widgetId ] ?? [ ] , $ config ) ; return $ this ; }
12690	protected function merge ( array $ configs ) { $ objects = array_filter ( $ configs , 'is_object' ) ; if ( ! empty ( $ objects ) ) { $ listConfigs = [ ] ; foreach ( $ configs as $ config ) { if ( ! is_object ( $ config ) ) { throw new RuntimeException ( 'Cannot merge object with other types' ) ; } $ listConfigs [ ] = ( array ) $ config ; } $ result = ( object ) $ this -> merge ( $ listConfigs ) ; } else { foreach ( $ configs as $ config ) { foreach ( $ config as $ key => $ value ) { $ existed = isset ( $ result [ $ key ] ) ; switch ( true ) { case ( $ existed && ( is_object ( $ result [ $ key ] ) || is_object ( $ value ) ) ) : case ( $ existed && ( is_array ( $ result [ $ key ] ) && is_array ( $ value ) ) ) : $ result [ $ key ] = $ this -> merge ( array ( $ result [ $ key ] , $ value ) ) ; break ; default : $ result [ $ key ] = $ value ; } } } } return $ result ; }
7243	public function description ( ) { $ default = Inform_About_Content :: default_opt_in ( NULL ) ; $ subscribed_by_default = apply_filters ( 'iac_default_opt_in' , $ default ) ; $ description = $ subscribed_by_default ? __ ( 'Note: Users must opt-out from e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) : __ ( 'Note: Users must opt-in to e-mail notifications by default' , Inform_About_Content :: TEXTDOMAIN ) ; printf ( '<p class="description">%s</p>' , $ description ) ; }
3217	function chunkedUploadContinue ( $ uploadId , $ byteOffset , $ data ) { Checker :: argStringNonEmpty ( "uploadId" , $ uploadId ) ; Checker :: argNat ( "byteOffset" , $ byteOffset ) ; Checker :: argString ( "data" , $ data ) ; $ response = $ this -> _chunkedUpload ( array ( "upload_id" => $ uploadId , "offset" => $ byteOffset ) , $ data ) ; if ( $ response -> statusCode === 404 ) { return false ; } $ correction = self :: _chunkedUploadCheckForOffsetCorrection ( $ response ) ; if ( $ correction !== null ) { list ( $ correctedUploadId , $ correctedByteOffset ) = $ correction ; if ( $ correctedUploadId !== $ uploadId ) throw new Exception_BadResponse ( "Corrective 400 upload_id mismatch: us=" . Util :: q ( $ uploadId ) . " server=" . Util :: q ( $ correctedUploadId ) ) ; if ( $ correctedByteOffset === $ byteOffset ) throw new Exception_BadResponse ( "Corrective 400 offset is the same as ours: $byteOffset" ) ; return $ correctedByteOffset ; } if ( $ response -> statusCode !== 200 ) throw RequestUtil :: unexpectedStatus ( $ response ) ; list ( $ retUploadId , $ retByteOffset ) = self :: _chunkedUploadParse200Response ( $ response -> body ) ; $ nextByteOffset = $ byteOffset + strlen ( $ data ) ; if ( $ uploadId !== $ retUploadId ) throw new Exception_BadResponse ( "upload_id mismatch: us=" . Util :: q ( $ uploadId ) . ", server=" . Util :: q ( $ uploadId ) ) ; if ( $ nextByteOffset !== $ retByteOffset ) throw new Exception_BadResponse ( "next-offset mismatch: us=$nextByteOffset, server=$retByteOffset" ) ; return true ; }
11236	public function url ( $ url = null , $ append = '' ) { unset ( $ _POST ) ; unset ( $ _FILES ) ; header ( 'location: ' . $ this -> getRedirect ( $ url ) . $ append ) ; exit ; }
364	public function renderCaption ( ) { if ( ! empty ( $ this -> caption ) ) { return Html :: tag ( 'caption' , $ this -> caption , $ this -> captionOptions ) ; } return false ; }
1371	protected function make ( array $ data ) { $ validator = $ this -> validatorFactory -> make ( $ data , $ this -> getRules ( ) , $ this -> getMessages ( ) , $ this -> getAttributes ( ) ) ; $ this -> configureValidator ( $ validator ) ; return $ validator ; }
3878	public function addChild ( $ child ) { if ( ! \ is_array ( $ child ) ) { throw new \ RuntimeException ( 'Error Processing sub filter: ' . var_export ( $ child , true ) , 1 ) ; } switch ( strtoupper ( $ child [ 'operation' ] ) ) { case '=' : case '>' : case '<' : return $ this -> getFilterForComparingOperator ( $ child ) ; case 'IN' : return $ this -> getFilterForInList ( $ child ) ; case 'LIKE' : return $ this -> getFilterForLike ( $ child ) ; default : } throw new \ RuntimeException ( 'Error processing filter array ' . var_export ( $ child , true ) , 1 ) ; }
4455	public function attach ( string $ eventName , $ handler , int $ priority = 100 ) : void { if ( is_object ( $ handler ) == false && is_callable ( $ handler ) == false ) { throw new InvalidArgumentException ( sprintf ( 'Event handler must be either an object or a callable %s given.' , gettype ( $ handler ) ) ) ; } $ priorityQueue = $ this -> fetchQueue ( $ eventName ) ; $ priorityQueue -> insert ( $ handler , $ priority ) ; }
2417	protected function addDataRow ( \ DOMDocument $ xml , \ DOMElement $ table , array $ arrRow , array $ arrOrder = array ( ) ) { $ t = $ table -> getAttribute ( 'name' ) ; $ row = $ xml -> createElement ( 'row' ) ; $ row = $ table -> appendChild ( $ row ) ; foreach ( $ arrRow as $ k => $ v ) { $ field = $ xml -> createElement ( 'field' ) ; $ field -> setAttribute ( 'name' , $ k ) ; $ field = $ row -> appendChild ( $ field ) ; if ( $ v === null ) { $ v = 'NULL' ; } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' && ! $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'eval' ] [ 'multiple' ] ) { $ objFile = FilesModel :: findByUuid ( $ v ) ; if ( $ objFile !== null ) { $ v = $ this -> standardizeUploadPath ( $ objFile -> path ) ; } else { $ v = 'NULL' ; } } elseif ( $ GLOBALS [ 'TL_DCA' ] [ $ t ] [ 'fields' ] [ $ k ] [ 'inputType' ] == 'fileTree' || \ in_array ( $ k , $ arrOrder ) ) { $ arrFiles = StringUtil :: deserialize ( $ v ) ; if ( ! empty ( $ arrFiles ) && \ is_array ( $ arrFiles ) ) { $ objFiles = FilesModel :: findMultipleByUuids ( $ arrFiles ) ; if ( $ objFiles !== null ) { $ arrTmp = array ( ) ; while ( $ objFiles -> next ( ) ) { $ arrTmp [ ] = $ this -> standardizeUploadPath ( $ objFiles -> path ) ; } $ v = serialize ( $ arrTmp ) ; } else { $ v = 'NULL' ; } } } elseif ( $ t == 'tl_style' && ( $ k == 'bgimage' || $ k == 'liststyleimage' ) ) { $ v = $ this -> standardizeUploadPath ( $ v ) ; } $ value = $ xml -> createTextNode ( $ v ) ; $ field -> appendChild ( $ value ) ; } }
5735	public function getMatchesForTeam ( int $ teamID , array $ filter = [ 'dateFrom' => '' , 'dateTo' => '' , 'status' => '' , 'venue' => '' ] ) { $ matches = $ this -> run ( "v2/teams/{$teamID}/matches" . "?" . http_build_query ( $ filter ) ) ; return collect ( $ matches -> matches ) ; }
9828	public function getCreateAssociationName ( $ modelName , $ otherModelName ) { return sprintf ( 'auja.%s.%s.create' , $ this -> toUrlName ( $ modelName ) , $ this -> toUrlName ( $ otherModelName ) ) ; }
2792	public function get ( $ option ) { if ( ! array_key_exists ( $ option , $ this -> inputOptions ) ) { throw new \ InvalidArgumentException ( 'Option "' . $ option . ' not exists' ) ; } return $ this -> inputOptions [ $ option ] ; }
1300	private function getLocaleForCacheKey ( string $ locale = null ) : string { if ( $ locale ) { return $ locale ; } return $ this -> getEnvironment ( ) -> getDefaultLocale ( ) -> getCode ( ) ; }
8545	public function setGuaranteeClaimEventList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'GuaranteeClaimEventList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3414	public function fill ( $ fields ) { if ( ! is_array ( $ fields ) ) { return ; } if ( isset ( $ fields [ 'ID' ] ) ) { $ this -> id = $ fields [ 'ID' ] ; } $ this -> fields = $ fields ; $ this -> fieldsAreFetched = true ; if ( method_exists ( $ this , 'afterFill' ) ) { $ this -> afterFill ( ) ; } $ this -> original = $ this -> fields ; }
12390	public function setEntityPrototype ( $ entityPrototype ) { if ( ! is_object ( $ entityPrototype ) ) { throw new Exception \ InvalidArgumentException ( sprintf ( '%s expects parameter 1 to be an object, %s provided instead' , __METHOD__ , is_object ( $ entityPrototype ) ? get_class ( $ entityPrototype ) : gettype ( $ entityPrototype ) ) ) ; } $ this -> entityPrototype = $ entityPrototype ; return $ this ; }
11118	protected function runDown ( array $ file ) : void { $ this -> notify -> note ( "<comment>Rolling back:</comment> {$file['basename']}" ) ; $ this -> runMigration ( $ file ) ; $ this -> repository -> delete ( $ this -> getMigrationName ( $ file ) ) ; $ this -> notify -> note ( "<info>Rolled back:</info> {$file['basename']}" ) ; }
11185	public function addMatch ( string $ method , string $ uri , $ next ) { $ method = strtoupper ( $ method ) ; if ( ! in_array ( $ method , $ this -> supported_methods ) ) { throw new Exception ( "Method " . $ method . " is not supported." ) ; } if ( ! is_string ( $ uri ) ) { throw new Exception ( "Uri " . $ uri . " is not valid." ) ; } if ( is_callable ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => true , $ this -> ARRAY_CALLABLE_KEY => $ next ) ; } elseif ( is_string ( $ next ) ) { if ( file_exists ( $ next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ next ) ; } else { $ dir_next = __DIR__ . "/" . $ next ; if ( file_exists ( $ dir_next ) ) { $ new_match = array ( $ this -> ARRAY_METHOD_KEY => $ method , $ this -> ARRAY_URI_KEY => $ uri , $ this -> ARRAY_CALLABLE_BOOL_KEY => false , $ this -> ARRAY_FILE_KEY => $ dir_next ) ; } else { throw new Exception ( "File " . $ next . " not found." ) ; } } } else { throw new Exception ( "Invalid third parameter. Expecting callable or file." ) ; } array_push ( $ this -> match_list , $ new_match ) ; }
11041	function store_leaf ( & $ elts , $ ptype , & $ i , $ cname , $ cvalue = NULL ) { $ isabsolute = FALSE ; if ( $ cname { 0 } == '/' && $ cname { 1 } == '/' ) { $ isabsolute = TRUE ; $ cname = substr ( $ cname , 2 ) ; } $ elements = explode ( '/' , $ cname ) ; if ( count ( $ elements ) == 1 && ! $ isabsolute ) { $ elts [ $ ptype . ':' . $ i . ':' . $ cname . ':' . $ cvalue ] = '' ; } else { if ( $ isabsolute ) { $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1://' ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } else { $ element1 = array_shift ( $ elements ) ; $ elts [ _ETS_TEMPLATE . ':' . $ i . '.1:' . $ element1 ] = $ this -> leaf_path_walk ( $ elements , 2 , $ ptype , $ i , $ cvalue ) ; } } }
6494	private function rankAcceptMediaTypeHeaders ( array $ mediaTypeHeaders ) : array { usort ( $ mediaTypeHeaders , [ $ this , 'compareAcceptMediaTypeHeaders' ] ) ; $ rankedMediaTypeHeaders = array_filter ( $ mediaTypeHeaders , [ $ this , 'filterZeroScores' ] ) ; return array_values ( $ rankedMediaTypeHeaders ) ; }
7193	private function copy ( $ source , $ target , array $ properties ) { $ properties = ( array ) $ properties ; foreach ( $ properties as $ property ) { $ this -> accessor -> setValue ( $ target , $ property , $ this -> accessor -> getValue ( $ source , $ property ) ) ; } }
10470	public function lookupUser ( $ user_id ) { $ request = new UserRequest ( $ user_id ) ; $ this -> emit ( 'request.user' , array ( $ user_id ) ) ; $ response = $ this -> post ( $ request ) ; return new UserResponse ( $ response ) ; }
6925	private function getFindOneByCountryAndMethodAndWeightQuery ( ) { if ( null === $ this -> findOneByCountryAndMethodAndWeightQuery ) { $ qb = $ this -> getCollectionQueryBuilder ( 'o' ) ; $ qb -> join ( 'o.zone' , 'z' ) -> join ( 'o.method' , 'm' ) -> andWhere ( $ qb -> expr ( ) -> isMemberOf ( ':country' , 'z.countries' ) ) -> andWhere ( $ qb -> expr ( ) -> gte ( 'o.weight' , ':weight' ) ) -> andWhere ( $ qb -> expr ( ) -> eq ( 'o.method' , ':method' ) ) -> addOrderBy ( 'o.weight' , 'ASC' ) -> setMaxResults ( 1 ) ; $ this -> findOneByCountryAndMethodAndWeightQuery = $ qb -> getQuery ( ) ; } return $ this -> findOneByCountryAndMethodAndWeightQuery ; }
10216	public function addFromSource ( array $ pSource = null ) { if ( $ pSource == null ) { return ; } foreach ( $ pSource as $ item ) { $ this -> add ( $ item ) ; } }
9219	protected function requestPageNumber ( $ pageNumber , $ forceRefresh = false ) { if ( ! isset ( $ this -> data [ $ this -> pageNumberToKey ( $ pageNumber ) ] ) || ( $ forceRefresh && isset ( $ this -> api ) ) ) { if ( isset ( $ this -> pagination [ CanvasPageLink :: CURRENT ] ) ) { $ params = $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getParams ( ) ; $ params [ CanvasPageLink :: PARAM_PAGE_NUMBER ] = $ pageNumber ; $ page = $ this -> api -> get ( $ this -> pagination [ CanvasPageLink :: CURRENT ] -> getEndpoint ( ) , $ params ) ; $ this -> data = array_replace ( $ this -> data , $ page -> data ) ; $ pagination = $ this -> parsePageLinks ( ) ; $ this -> paginationPerPage [ $ pagination [ CanvasPageLink :: CURRENT ] -> getPageNumber ( ) ] = $ pagination ; return true ; } } return false ; }
12971	public function seek ( $ position ) { if ( ! array_key_exists ( $ position , $ this -> elements ) ) { throw new \ InvalidArgumentException ( sprintf ( 'Position %s does not exist in collection' , $ position ) ) ; } reset ( $ this -> elements ) ; while ( key ( $ this -> elements ) !== $ position ) { next ( $ this -> elements ) ; } }
9247	public function from ( Contract $ contract , string $ string , callable $ callback = null ) : string { $ string = ucwords ( $ contract -> recipe ( $ string , 'upperCaseFirst' , function ( $ string ) use ( $ contract ) { if ( $ contract instanceof Camel ) { return $ string ; } return strtolower ( $ string ) ; } ) ) ; return $ this -> callback ( $ string , $ callback ) ; }
2620	public function sendInstalledReq ( ) { $ pageViewParams = [ 'dl' => self :: GA_PAGEVIEW_URL . self :: FASTLY_INSTALLED_FLAG , 'dh' => preg_replace ( '#^https?://#' , '' , rtrim ( self :: GA_PAGEVIEW_URL , '/' ) ) , 'dp' => '/' . self :: FASTLY_INSTALLED_FLAG , 'dt' => ucfirst ( self :: FASTLY_INSTALLED_FLAG ) , 't' => self :: GA_HITTYPE_PAGEVIEW , ] ; $ this -> sendReqToGA ( $ pageViewParams , self :: GA_HITTYPE_PAGEVIEW ) ; $ eventParams = [ 'ec' => self :: GA_FASTLY_SETUP , 'ea' => 'Fastly ' . self :: FASTLY_INSTALLED_FLAG , 'el' => $ this -> getWebsiteName ( ) , 'ev' => 0 , 't' => self :: GA_HITTYPE_EVENT ] ; $ result = $ this -> sendReqToGA ( array_merge ( $ pageViewParams , $ eventParams ) ) ; return $ result ; }
5618	public function paintHeader ( $ test_name ) { $ this -> sendNoCacheHeaders ( ) ; echo sprintf ( SIMPLETEST_WEBUNIT_HEAD , $ test_name , $ this -> path . 'js/' , $ this -> path . 'js/' , $ this -> path . 'css/' , $ this -> _getCss ( ) , $ test_name , $ this -> path . 'img/' ) ; flush ( ) ; }
7296	private function get_mail_to_chunk ( $ to , $ send_next_group = array ( ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ object_type = $ this -> options [ 'static_options' ] [ 'object' ] [ 'type' ] ; if ( empty ( $ send_next_group ) ) { $ chunk_size = $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunksize' ] ; $ send_next_group = array_chunk ( $ to , $ chunk_size ) ; } $ to = apply_filters ( 'iac_email_address_chunk' , array_shift ( $ send_next_group ) , $ object_id , $ object_type ) ; $ to = implode ( ',' , $ to ) ; if ( ! empty ( $ send_next_group ) ) { wp_schedule_single_event ( time ( ) + $ this -> options [ 'static_options' ] [ 'schedule_interval' ] , 'iac_schedule_send_chunks' , array ( $ object_id , $ object_type , $ send_next_group ) ) ; } return $ to ; }
12504	public static function rollbackTransaction ( $ connection ) { $ connection -> query = 'ROLLBACK' ; $ connection -> method = 'POST' ; $ connection -> action = '/_query' ; return self :: sendQuery ( $ connection ) ; }
8891	public function singleton ( $ key , $ value ) { if ( is_callable ( $ value ) ) { $ this -> registerFactory ( $ key , $ value ) ; } else { $ this -> sm -> setService ( $ key , $ value ) ; } }
1781	public static function isInsecurePath ( $ strPath ) { $ strPath = strtr ( $ strPath , '\\' , '/' ) ; $ strPath = preg_replace ( '#//+#' , '/' , $ strPath ) ; if ( $ strPath == '..' ) { return true ; } if ( substr ( $ strPath , 0 , 2 ) == './' ) { return true ; } if ( substr ( $ strPath , 0 , 3 ) == '../' ) { return true ; } if ( substr ( $ strPath , - 2 ) == '/.' ) { return true ; } if ( substr ( $ strPath , - 3 ) == '/..' ) { return true ; } if ( strpos ( $ strPath , '/../' ) !== false ) { return true ; } return false ; }
3457	protected function replay ( Iterator $ historyEvents ) : void { foreach ( $ historyEvents as $ pastEvent ) { $ this -> version = $ pastEvent -> version ( ) ; $ this -> apply ( $ pastEvent ) ; } }
2505	public static function loadWsdlXpath ( $ wsdlFilePath , $ wsdlId ) { if ( ! isset ( self :: $ wsdlDomXpath [ $ wsdlId ] ) || is_null ( self :: $ wsdlDomXpath [ $ wsdlId ] ) ) { $ wsdlContent = file_get_contents ( $ wsdlFilePath ) ; if ( $ wsdlContent !== false ) { self :: $ wsdlDomDoc [ $ wsdlId ] = new \ DOMDocument ( '1.0' , 'UTF-8' ) ; self :: $ wsdlDomDoc [ $ wsdlId ] -> loadXML ( $ wsdlContent ) ; self :: $ wsdlDomXpath [ $ wsdlId ] = new \ DOMXPath ( self :: $ wsdlDomDoc [ $ wsdlId ] ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'wsdl' , 'http://schemas.xmlsoap.org/wsdl/' ) ; self :: $ wsdlDomXpath [ $ wsdlId ] -> registerNamespace ( 'soap' , 'http://schemas.xmlsoap.org/wsdl/soap/' ) ; } else { throw new InvalidWsdlFileException ( 'WSDL ' . $ wsdlFilePath . ' could not be loaded' ) ; } } }
12875	public static function getJSON ( $ src ) { $ src = file_get_contents ( $ src ) ; $ out = json_decode ( $ src , true ) ; return $ out ; }
7247	protected function purge ( ShipmentInterface $ shipment ) { foreach ( $ shipment -> getItems ( ) as $ item ) { if ( 0 == $ item -> getAvailable ( ) ) { $ shipment -> removeItem ( $ item ) ; } } }
9626	public function getAll ( array $ filterAttributes = [ ] ) { $ filters = [ 'query' => [ $ filterAttributes ] ] ; try { $ result = $ this -> client -> get ( $ this -> slug , $ filters ) ; } catch ( RequestException $ e ) { $ return [ 'request' ] = $ e -> getRequest ( ) . "\n" ; if ( $ e -> hasResponse ( ) ) { return $ return [ 'response' ] = $ e -> getResponse ( ) . "\n" ; } } return $ result -> json ( ) ; }
4772	public function configs ( Request $ request , WidgetInterface $ widget , CacheInterface $ cache , string $ widgetId ) { $ widgets = $ widget -> getWidgets ( ) ; if ( isset ( $ widgets [ $ widgetId ] ) ) { $ widgetConfig = $ this -> getDoctrine ( ) -> getRepository ( 'PdWidgetBundle:WidgetUser' ) -> findOneBy ( [ 'owner' => $ this -> getUser ( ) ] ) ?? ( new WidgetUser ( ) ) -> setOwner ( $ this -> getUser ( ) ) ; if ( $ request -> get ( 'remove' ) ) { $ widgetConfig -> removeWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } else { $ widgetConfig -> addWidgetConfig ( $ widgetId , $ widgets [ $ widgetId ] -> getConfigProcess ( $ request ) ?? [ ] ) ; } $ em = $ this -> getDoctrine ( ) -> getManager ( ) ; $ em -> persist ( $ widgetConfig ) ; $ em -> flush ( ) ; $ cache -> delete ( $ widgetId . $ this -> getUser ( ) -> getId ( ) ) ; } return $ this -> redirect ( $ request -> headers -> get ( 'referer' ) ?? $ this -> generateUrl ( $ this -> getParameter ( 'pd_widget.return_route' ) ) ) ; }
1758	public static function getFormattedNumber ( $ varNumber , $ intDecimals = 2 ) { return number_format ( round ( $ varNumber , $ intDecimals ) , $ intDecimals , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'decimalSeparator' ] , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'thousandsSeparator' ] ) ; }
12806	public static function select ( ) : Collection { $ pdo = Database :: connect ( ) ; $ class = self :: getStaticChildClass ( ) ; $ tableName = self :: getTableName ( ) ; $ sql = "SELECT * FROM \"$tableName\"" ; $ results = $ pdo -> query ( $ sql ) -> fetchAll ( ) ; $ collection = new Collection ( $ class , [ ] ) ; foreach ( $ results as $ result ) { $ object = new $ class ( $ result ) ; $ collection -> push ( $ object ) ; } return $ collection ; }
3384	private function findUser ( ) { $ sql = sprintf ( 'SELECT * FROM %s WHERE %s = :identity' , $ this -> getTableName ( ) , $ this -> getIdentityColumn ( ) ) ; $ stmt = $ this -> db -> prepare ( $ sql ) ; $ stmt -> execute ( array ( 'identity' => $ this -> getIdentity ( ) ) ) ; return $ stmt -> fetch ( PDO :: FETCH_ASSOC ) ; }
8520	public function setFulfillmentRecommendations ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'FulfillmentRecommendations' ] [ 'FieldValue' ] = $ value ; return $ this ; }
2024	public static function findByAliases ( $ arrAliases , array $ arrOptions = array ( ) ) { if ( empty ( $ arrAliases ) || ! \ is_array ( $ arrAliases ) ) { return null ; } $ arrAliases = array_filter ( array_map ( function ( $ v ) { return preg_match ( '/^[\w\/.-]+$/u' , $ v ) ? $ v : null ; } , $ arrAliases ) ) ; if ( empty ( $ arrAliases ) ) { return null ; } $ t = static :: $ strTable ; $ arrColumns = array ( "$t.alias IN('" . implode ( "','" , array_filter ( $ arrAliases ) ) . "')" ) ; if ( ! static :: isPreviewMode ( $ arrOptions ) ) { $ time = Date :: floorToMinute ( ) ; $ arrColumns [ ] = "($t.start='' OR $t.start<='$time') AND ($t.stop='' OR $t.stop>'" . ( $ time + 60 ) . "') AND $t.published='1'" ; } if ( ! isset ( $ arrOptions [ 'order' ] ) ) { $ arrOptions [ 'order' ] = Database :: getInstance ( ) -> findInSet ( "$t.alias" , $ arrAliases ) ; } return static :: findBy ( $ arrColumns , null , $ arrOptions ) ; }
12592	public function toSQLString ( ) { if ( $ this -> operator == 'IN' ) { $ sql = '(' ; $ komma = '' ; for ( $ i = 0 ; $ i < count ( $ this -> operation ) ; $ i ++ ) { $ sql .= $ komma . '?' ; $ komma = ',' ; } $ sql .= ')' ; return $ sql ; } elseif ( $ this -> operator == 'BETWEEN' ) { return '? AND ?' ; } }
7949	public function updateDomainProperties ( $ domain , $ properties ) { self :: getClient ( ) -> updateDomainProperties ( $ this -> sn , $ domain , $ properties ) ; }
2346	public function close ( ) { if ( \ is_resource ( $ this -> resFile ) ) { $ this -> Files -> fclose ( $ this -> resFile ) ; } if ( ! file_exists ( $ this -> strRootDir . '/' . $ this -> strFile ) ) { if ( ( $ strFolder = \ dirname ( $ this -> strFile ) ) == '.' ) { $ strFolder = '' ; } if ( ! is_dir ( $ this -> strRootDir . '/' . $ strFolder ) ) { new Folder ( $ strFolder ) ; } } $ return = $ this -> Files -> rename ( $ this -> strTmp , $ this -> strFile ) ; $ this -> strTmp = null ; if ( Dbafs :: shouldBeSynchronized ( $ this -> strFile ) ) { $ this -> objModel = Dbafs :: addResource ( $ this -> strFile ) ; } return $ return ; }
5887	public function iconGetName ( $ key ) { $ iconid = ( $ this [ $ key ] < 0 ) ? ( pow ( 2 , 32 ) ) - ( $ this [ $ key ] * - 1 ) : $ this [ $ key ] ; return new StringHelper ( "/icon_" . $ iconid ) ; }
763	private function updateCollectionOffsets ( ) { if ( ! empty ( $ this -> _children ) ) { $ this -> startOffset = reset ( $ this -> _children ) -> startOffset ; $ this -> endOffset = end ( $ this -> _children ) -> endOffset ; } if ( $ this -> parent !== null ) { $ this -> parent -> updateCollectionOffsets ( ) ; } }
11163	protected function getResponseFormat ( array $ config ) { if ( isset ( $ config [ 'responseFormat' ] ) ) { if ( ! is_string ( $ config [ 'responseFormat' ] ) ) { throw new \ DomainException ( 'responseFormat must reference a string' , self :: ERR_INVALID_RESPONSEFORMAT ) ; } return $ config [ 'responseFormat' ] ; } return '[ %link% ] "%title%" by %author%' . '; Length %duration%' . '; Published %published%' . '; Views %views%' . '; Likes %likes%' ; }
3351	private function __setRequestType ( $ ch , $ type = 'GET' ) { $ this -> current_method = strtoupper ( $ type ) ; switch ( $ type ) { case 'GET' : break ; case 'POST' : curl_setopt ( $ ch , CURLOPT_POST , true ) ; break ; case 'PUT' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'PUT' ) ; break ; case 'DELETE' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'DELETE' ) ; break ; case 'HEAD' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'HEAD' ) ; curl_setopt ( $ ch , CURLOPT_NOBODY , true ) ; break ; case 'OPTIONS' : curl_setopt ( $ ch , CURLOPT_CUSTOMREQUEST , 'OPTIONS' ) ; break ; default : throw new \ Exception ( 'No request type is provided for request. Use post, put, delete, get or appropriate constants.' ) ; } }
12849	private function _getPage404 ( ) { header ( "HTTP/1.0 404 Not Found" ) ; if ( isset ( $ this -> _oRoutes -> e404 ) ) { $ this -> _oRoutes -> e404 -> route = '/' ; $ _SERVER [ 'REQUEST_URI' ] = '/' ; $ this -> _route ( $ this -> _oRoutes -> e404 , $ _SERVER [ 'REQUEST_URI' ] ) ; } exit ; }
431	public function getModule ( $ id , $ load = true ) { if ( ( $ pos = strpos ( $ id , '/' ) ) !== false ) { $ module = $ this -> getModule ( substr ( $ id , 0 , $ pos ) ) ; return $ module === null ? null : $ module -> getModule ( substr ( $ id , $ pos + 1 ) , $ load ) ; } if ( isset ( $ this -> _modules [ $ id ] ) ) { if ( $ this -> _modules [ $ id ] instanceof self ) { return $ this -> _modules [ $ id ] ; } elseif ( $ load ) { Yii :: debug ( "Loading module: $id" , __METHOD__ ) ; $ module = Yii :: createObject ( $ this -> _modules [ $ id ] , [ $ id , $ this ] ) ; $ module -> setInstance ( $ module ) ; return $ this -> _modules [ $ id ] = $ module ; } } return null ; }
6712	protected function stringToArray ( $ string ) { if ( ! $ string || ! is_string ( $ string ) ) { return [ ] ; } $ result = $ this -> getReaderFactory ( ) -> read ( $ string ) ; if ( $ result ) { return $ result ; } $ array = [ ] ; $ array [ 'text' ] = $ string ; return $ array ; }
12246	static public function sort ( array & $ nodes ) { $ args = func_get_args ( ) ; unset ( $ args [ 0 ] ) ; $ sort = array ( ) ; $ tmp = array ( ) ; foreach ( $ args as $ k => $ arg ) { if ( is_string ( $ arg ) ) { $ tmp [ $ k ] = array ( ) ; if ( preg_match ( '#^@?[a-z_0-9]+$#Di' , $ arg ) ) { if ( $ arg [ 0 ] === '@' ) { $ name = substr ( $ arg , 1 ) ; foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node [ $ name ] ; } } else { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = ( string ) $ node -> $ arg ; } } } elseif ( preg_match ( '#^current\\(\\)|text\\(\\)|\\.$#i' , $ arg ) ) { foreach ( $ nodes as $ node ) { $ tmp [ $ k ] [ ] = dom_import_simplexml ( $ node ) -> textContent ; } } else { foreach ( $ nodes as $ node ) { $ _nodes = $ node -> xpath ( $ arg ) ; $ tmp [ $ k ] [ ] = ( empty ( $ _nodes ) ) ? '' : ( string ) $ _nodes [ 0 ] ; } } } else { $ tmp [ $ k ] = $ arg ; } $ sort [ ] = & $ tmp [ $ k ] ; } $ sort [ ] = & $ nodes ; call_user_func_array ( 'array_multisort' , $ sort ) ; }
10861	protected function createObjectUsingFactory ( string $ typeName , Factory $ factory , ? bool $ nullable = false ) : ? object { $ this -> underConstruction [ $ typeName ] = true ; try { $ object = ( $ factory -> callback ) ( ... $ this -> populateArguments ( $ factory -> getReflection ( ) , null , $ typeName ) ) ; if ( ! $ object instanceof $ typeName ) { if ( $ object === null && $ nullable ) { return null ; } $ type = \ is_object ( $ object ) ? \ get_class ( $ object ) : \ gettype ( $ object ) ; throw new ContainerException ( \ sprintf ( 'Factory must return an instance of %s, returned value is %s' , $ typeName , $ type ) ) ; } } finally { unset ( $ this -> underConstruction [ $ typeName ] ) ; } return $ object ; }
4011	public function getPaginationString ( ) { $ this -> calculate ( ) ; if ( $ this -> getPerPage ( ) == 0 ) { return '' ; } $ objPagination = new \ Pagination ( $ this -> calculatedTotal , $ this -> getPerPage ( ) , $ this -> getMaxPaginationLinks ( ) ) ; return $ objPagination -> generate ( "\n " ) ; }
1043	public static function printError ( Error $ error ) { $ printedLocations = [ ] ; if ( $ error -> nodes ) { foreach ( $ error -> nodes as $ node ) { if ( ! $ node -> loc ) { continue ; } if ( $ node -> loc -> source === null ) { continue ; } $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ node -> loc -> source , $ node -> loc -> source -> getLocation ( $ node -> loc -> start ) ) ; } } elseif ( $ error -> getSource ( ) && $ error -> getLocations ( ) ) { $ source = $ error -> getSource ( ) ; foreach ( $ error -> getLocations ( ) as $ location ) { $ printedLocations [ ] = self :: highlightSourceAtLocation ( $ source , $ location ) ; } } return ! $ printedLocations ? $ error -> getMessage ( ) : implode ( "\n\n" , array_merge ( [ $ error -> getMessage ( ) ] , $ printedLocations ) ) . "\n" ; }
11449	public function fill ( array $ attributes ) { if ( $ this -> getFieldManager ( ) ) { $ attributes = $ this -> getFieldManager ( ) -> transformToResource ( $ attributes ) ; } return parent :: fill ( $ attributes ) ; }
551	public function actionFlush ( ) { $ cachesInput = func_get_args ( ) ; if ( empty ( $ cachesInput ) ) { throw new Exception ( 'You should specify cache components names' ) ; } $ caches = $ this -> findCaches ( $ cachesInput ) ; $ cachesInfo = [ ] ; $ foundCaches = array_keys ( $ caches ) ; $ notFoundCaches = array_diff ( $ cachesInput , array_keys ( $ caches ) ) ; if ( $ notFoundCaches ) { $ this -> notifyNotFoundCaches ( $ notFoundCaches ) ; } if ( ! $ foundCaches ) { $ this -> notifyNoCachesFound ( ) ; return ExitCode :: OK ; } if ( ! $ this -> confirmFlush ( $ foundCaches ) ) { return ExitCode :: OK ; } foreach ( $ caches as $ name => $ class ) { $ cachesInfo [ ] = [ 'name' => $ name , 'class' => $ class , 'is_flushed' => $ this -> canBeFlushed ( $ class ) ? Yii :: $ app -> get ( $ name ) -> flush ( ) : false , ] ; } $ this -> notifyFlushed ( $ cachesInfo ) ; }
3836	private function setLanguageStrings ( ) { if ( empty ( $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] ) ) { $ GLOBALS [ 'TL_LANG' ] [ $ this -> getMetaModel ( ) -> getTableName ( ) ] [ $ this -> getColName ( ) ] = array ( $ this -> getLangValue ( $ this -> get ( 'name' ) ) , $ this -> getLangValue ( $ this -> get ( 'description' ) ) , ) ; } }
3792	private function getModelById ( $ modelId ) { if ( $ modelId === null ) { return null ; } $ provider = $ this -> environment -> getDataProvider ( ) ; $ config = $ provider -> getEmptyConfig ( ) -> setId ( $ modelId ) ; return $ provider -> fetch ( $ config ) ; }
3102	public function getStorage ( ) { if ( ! $ this -> storage ) { $ this -> storage = $ this -> getServiceLocator ( ) -> get ( StorageManager :: SERVICE_ID ) ; } return $ this -> storage ; }
6817	protected function buildAdjustments ( $ type , Model \ AdjustableInterface $ adjustable , array $ data , $ persistence = false ) { Model \ AdjustmentTypes :: isValidType ( $ type ) ; $ change = false ; $ newAdjustments = [ ] ; foreach ( $ data as $ d ) { $ adjustment = $ this -> saleFactory -> createAdjustmentFor ( $ adjustable ) ; $ adjustment -> setType ( $ type ) -> setMode ( $ d -> getMode ( ) ) -> setDesignation ( $ d -> getDesignation ( ) ) -> setAmount ( $ d -> getAmount ( ) ) -> setImmutable ( $ d -> isImmutable ( ) ) ; $ newAdjustments [ ] = $ adjustment ; } $ oldAdjustments = $ adjustable -> getAdjustments ( $ type ) ; foreach ( $ oldAdjustments as $ oldAdjustment ) { if ( ! $ oldAdjustment -> isImmutable ( ) ) { continue ; } foreach ( $ newAdjustments as $ index => $ newAdjustment ) { if ( $ oldAdjustment -> equals ( $ newAdjustment ) ) { unset ( $ newAdjustments [ $ index ] ) ; continue 2 ; } } $ adjustable -> removeAdjustment ( $ oldAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> remove ( $ oldAdjustment , true ) ; } $ change = true ; } foreach ( $ newAdjustments as $ newAdjustment ) { $ adjustable -> addAdjustment ( $ newAdjustment ) ; if ( $ persistence ) { $ this -> persistenceHelper -> persistAndRecompute ( $ newAdjustment , true ) ; } $ change = true ; } return $ change ; }
4877	public static function factory ( ContainerInterface $ container ) { $ config = $ container -> get ( 'ApplicationConfig' ) ; $ options = new ListenerOptions ( $ config [ 'module_listener_options' ] ) ; return new static ( $ options ) ; }
3270	public function appendToFile ( string $ line ) { $ file = $ this -> openFile ( static :: FILE_APPEND ) ; $ file -> fwrite ( $ line ) ; $ this -> closeFile ( $ file ) ; }
8374	public function set ( $ set ) { if ( is_array ( $ set ) === true ) { $ this -> set = '' ; foreach ( $ set as $ name => $ value ) { $ pos = stripos ( $ name , '.' ) ; if ( $ pos !== false ) { $ this -> set .= substr ( $ name , $ pos + 1 ) ; } else { $ this -> set .= $ name ; } $ this -> set .= ' = ' . $ value . ', ' ; } $ this -> set = substr ( $ this -> set , 0 , - 2 ) ; } else { $ this -> set = $ set ; } return $ this ; }
3847	protected static function upgradeClosed ( ) { $ objDB = self :: DB ( ) ; if ( $ objDB -> tableExists ( 'tl_metamodel_dca' , null , true ) && ! $ objDB -> fieldExists ( 'iseditable' , 'tl_metamodel_dca' ) ) { TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iseditable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'iscreatable' , 'char(1) NOT NULL default \'\'' ) ; TableManipulation :: createColumn ( 'tl_metamodel_dca' , 'isdeleteable' , 'char(1) NOT NULL default \'\'' ) ; $ objDB -> execute ( ' UPDATE tl_metamodel_dca SET iseditable=isclosed^1, iscreatable=isclosed^1, isdeleteable=isclosed^1 ' ) ; TableManipulation :: dropColumn ( 'tl_metamodel_dca' , 'isclosed' , true ) ; } }
6465	public function isMultipart ( HttpHeaders $ headers ) : bool { $ contentType = null ; $ headers -> tryGetFirst ( 'Content-Type' , $ contentType ) ; return preg_match ( "/multipart\//i" , $ contentType ) === 1 ; }
11693	public function run ( ) : Robo \ Result { $ result = $ this -> collectionBuilder ( ) -> taskFilesystemStack ( ) -> mkdir ( $ this -> destination -> getPath ( ) ) -> touch ( $ this -> destination -> getPathname ( ) ) -> run ( ) -> wasSuccessful ( ) ; if ( ! $ result ) { throw new RuntimeException ( 'We can not write to the destination file: ' . $ this -> destination -> getPathname ( ) ) ; } $ asset_contents = '' ; foreach ( $ this -> source as $ file ) { $ this -> printTaskInfo ( 'Compiling - <info>' . $ file . '</info>' ) ; $ asset_contents .= $ this -> getCompiler ( new SplFileInfo ( $ file ) ) -> compile ( ) ; } if ( $ this -> cachebust === true ) { $ this -> bustCacheBalls ( $ asset_contents ) ; } $ this -> writeAsset ( $ asset_contents ) ; return \ Robo \ Result :: success ( $ this ) ; }
8385	public function groupBy ( $ groupBy ) { if ( is_array ( $ groupBy ) === true ) { $ this -> groupBy = implode ( ', ' , $ groupBy ) ; } else { $ this -> groupBy = $ groupBy ; } return $ this ; }
12742	public function removeById ( $ connectionID ) { if ( isset ( $ this -> pool [ $ connectionID ] ) ) { $ this -> slotmap -> reset ( ) ; $ this -> slots = array_diff ( $ this -> slots , array ( $ connectionID ) ) ; unset ( $ this -> pool [ $ connectionID ] ) ; return true ; } return false ; }
1864	public function onKernelResponse ( FilterResponseEvent $ event ) : void { if ( ! $ event -> isMasterRequest ( ) ) { return ; } $ request = $ event -> getRequest ( ) ; if ( $ request -> isMethod ( 'POST' ) ) { return ; } if ( null === ( $ session = $ request -> getSession ( ) ) || ! $ session -> isStarted ( ) ) { return ; } $ this -> clearLegacyAttributeBags ( 'FE_DATA' ) ; $ this -> clearLegacyAttributeBags ( 'BE_DATA' ) ; $ this -> clearLegacyFormData ( ) ; }
5009	public function setSubject ( $ subject , $ translate = true ) { if ( false !== $ translate ) { $ translator = $ this -> getTranslator ( ) ; $ domain = $ this -> getTranslatorTextDomain ( ) ; if ( true === $ translate ) { $ subject = $ translator -> translate ( $ subject , $ domain ) ; } else { $ args = func_get_args ( ) ; $ args [ 0 ] = $ translator -> translate ( $ args [ 0 ] , $ domain ) ; $ subject = call_user_func_array ( 'sprintf' , $ args ) ; } } return parent :: setSubject ( $ subject ) ; }
4939	public function setAllowedTypes ( $ types ) { if ( is_array ( $ types ) ) { $ types = implode ( ',' , $ types ) ; } return $ this -> setAttribute ( 'data-allowedtypes' , $ types ) ; }
141	public function markAliasUninstalled ( RepositoryInterface $ repo , MarkAliasUninstalledOperation $ operation ) { $ package = $ operation -> getPackage ( ) ; $ repo -> removePackage ( $ package ) ; }
2328	public function save ( ) { if ( $ this -> intIndex < 0 ) { $ this -> first ( ) ; } $ this -> arrModels [ $ this -> intIndex ] -> save ( ) ; return $ this ; }
11917	public function newInstanceQuery ( array $ data = [ ] , array $ selectable = [ '*' ] ) { $ tm = new TextGenerator ( ) ; $ r = $ this -> newInstanceRepository ( ) ; $ query = $ r -> newQuery ( ) ; if ( ! empty ( $ this -> filter ) ) { $ filter = new Filter ( $ r -> getTableName ( ) , $ selectable ) ; $ filter -> build ( $ query , $ tm -> generateAndRender ( $ this -> filter , $ data ) ) ; } return $ query ; }
6534	public function run ( ) { if ( ( $ exception = Yii :: $ app -> getErrorHandler ( ) -> exception ) === null ) { return '' ; } if ( $ exception instanceof \ HttpException ) { $ code = $ exception -> statusCode ; } else { $ code = $ exception -> getCode ( ) ; } if ( $ exception instanceof Exception ) { $ name = $ exception -> getName ( ) ; } else { $ name = $ this -> defaultName ? : Yii :: t ( 'yii' , 'Error' ) ; } if ( $ code ) { $ name .= " (#$code)" ; } if ( $ exception instanceof UserException ) { $ message = $ exception -> getMessage ( ) ; } else { $ message = $ this -> defaultMessage ? : Yii :: t ( 'yii' , 'An internal server error occurred.' ) ; } if ( Yii :: $ app -> getRequest ( ) -> getIsAjax ( ) ) { $ rr = new RequestResponse ( ) ; $ rr -> success = false ; $ rr -> message = "$name: $message" ; return ( array ) $ rr ; } else { if ( \ Yii :: $ app -> user -> can ( CmsManager :: PERMISSION_ADMIN_ACCESS ) ) { $ this -> controller -> layout = \ Yii :: $ app -> cms -> moduleAdmin -> layout ; return $ this -> controller -> render ( '@app/views/error/error' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } else { $ this -> controller -> layout = '@app/views/layouts/unauthorized' ; return $ this -> controller -> render ( '@app/views/error/unauthorized-403' , [ 'message' => nl2br ( Html :: encode ( $ message ) ) ] ) ; } } }
5041	public function onBootstrap ( MvcEvent $ e ) { if ( ! DoctrineType :: hasType ( 'tz_date' ) ) { DoctrineType :: addType ( 'tz_date' , '\Core\Repository\DoctrineMongoODM\Types\TimezoneAwareDate' ) ; } $ sm = $ e -> getApplication ( ) -> getServiceManager ( ) ; $ translator = $ sm -> get ( 'translator' ) ; \ Zend \ Validator \ AbstractValidator :: setDefaultTranslator ( $ translator ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ sharedManager = $ eventManager -> getSharedManager ( ) ; if ( ! \ Zend \ Console \ Console :: isConsole ( ) ) { ( new ErrorHandlerListener ( ) ) -> attach ( $ eventManager ) ; $ languageRouteListener = new LanguageRouteListener ( $ sm -> get ( 'Core/Locale' ) , $ sm -> get ( 'Core/Options' ) ) ; $ languageRouteListener -> attach ( $ eventManager ) ; $ ajaxRenderListener = new AjaxRenderListener ( ) ; $ ajaxRenderListener -> attach ( $ eventManager ) ; $ ajaxRouteListener = $ sm -> get ( AjaxRouteListener :: class ) ; $ ajaxRouteListener -> attach ( $ eventManager ) ; $ xmlRenderListener = new XmlRenderListener ( ) ; $ xmlRenderListener -> attach ( $ eventManager ) ; $ enforceJsonResponseListener = new EnforceJsonResponseListener ( ) ; $ enforceJsonResponseListener -> attach ( $ eventManager ) ; $ stringListener = new StringListener ( ) ; $ stringListener -> attach ( $ eventManager ) ; } $ notificationListener = $ sm -> get ( 'Core/Listener/Notification' ) ; $ notificationListener -> attachShared ( $ sharedManager ) ; $ notificationAjaxHandler = new NotificationAjaxHandler ( ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , array ( $ notificationAjaxHandler , 'injectView' ) , - 20 ) ; $ notificationListener -> attach ( NotificationEvent :: EVENT_NOTIFICATION_HTML , array ( $ notificationAjaxHandler , 'render' ) , - 20 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , function ( $ event ) { if ( $ event instanceof MvcEvent ) { $ application = $ event -> getApplication ( ) ; if ( $ application :: ERROR_EXCEPTION == $ event -> getError ( ) ) { $ ex = $ event -> getParam ( 'exception' ) ; if ( 404 == $ ex -> getCode ( ) ) { $ event -> setError ( $ application :: ERROR_CONTROLLER_NOT_FOUND ) ; } } } } , 500 ) ; $ eventManager -> attach ( MvcEvent :: EVENT_DISPATCH , function ( $ event ) use ( $ eventManager ) { $ eventManager -> trigger ( 'postDispatch' , $ event ) ; } , - 150 ) ; $ sm -> get ( 'Tracy' ) -> startDebug ( ) ; }
2125	protected function getDebugMarkup ( ) { $ return = $ this -> getFileUrls ( ) ; foreach ( $ return as $ k => $ v ) { $ options = StringUtil :: resolveFlaggedUrl ( $ v ) ; $ return [ $ k ] = $ v ; if ( $ options -> mtime ) { $ return [ $ k ] .= '?v=' . substr ( md5 ( $ options -> mtime ) , 0 , 8 ) ; } if ( $ options -> media ) { $ return [ $ k ] .= '" media="' . $ options -> media ; } } if ( $ this -> strMode == self :: JS ) { return implode ( '"></script><script src="' , $ return ) ; } return implode ( '"><link rel="stylesheet" href="' , $ return ) ; }
786	public function scenarios ( ) { $ scenarios = [ self :: SCENARIO_DEFAULT => [ ] ] ; foreach ( $ this -> getValidators ( ) as $ validator ) { foreach ( $ validator -> on as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } foreach ( $ validator -> except as $ scenario ) { $ scenarios [ $ scenario ] = [ ] ; } } $ names = array_keys ( $ scenarios ) ; foreach ( $ this -> getValidators ( ) as $ validator ) { if ( empty ( $ validator -> on ) && empty ( $ validator -> except ) ) { foreach ( $ names as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } elseif ( empty ( $ validator -> on ) ) { foreach ( $ names as $ name ) { if ( ! in_array ( $ name , $ validator -> except , true ) ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } else { foreach ( $ validator -> on as $ name ) { foreach ( $ validator -> attributes as $ attribute ) { $ scenarios [ $ name ] [ $ attribute ] = true ; } } } } foreach ( $ scenarios as $ scenario => $ attributes ) { if ( ! empty ( $ attributes ) ) { $ scenarios [ $ scenario ] = array_keys ( $ attributes ) ; } } return $ scenarios ; }
2839	public function getFilteredRequestListUrl ( $ filters = array ( ) ) { $ currentFilters = Mage :: helper ( 'sheep_debug/filter' ) -> getRequestFilters ( $ this -> getRequest ( ) ) ; $ filters = array_merge ( $ currentFilters , $ filters ) ; return $ this -> getRequestListUrl ( $ filters ) ; }
1261	protected function createTransactionNode ( ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ trxRef = $ xml -> appendChild ( $ xml -> createElement ( 'TransactionReference' ) ) ; if ( null !== $ this -> context ) { $ trxRef -> appendChild ( $ xml -> createElement ( 'CustomerContext' , $ this -> context ) ) ; } return $ trxRef -> cloneNode ( true ) ; }
8613	public function setAdjustmentItemList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'AdjustmentItemList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
10307	public function setGlowProperties ( $ size , $ color_value = null , $ color_alpha = null , $ color_type = null ) { $ this -> setGlowSize ( $ size ) -> setGlowColor ( $ color_value === null ? $ this -> glowProperties [ 'color' ] [ 'value' ] : $ color_value , $ color_alpha === null ? ( int ) $ this -> glowProperties [ 'color' ] [ 'alpha' ] : $ color_alpha , $ color_type === null ? $ this -> glowProperties [ 'color' ] [ 'type' ] : $ color_type ) ; }
7010	private function formatN ( & $ str ) { if ( strstr ( $ str , '%N' ) ) { $ wdn = $ this -> weekDayNum ( ) ; $ str = str_replace ( '%N' , $ wdn == 0 ? 7 : $ wdn , $ str ) ; } }
1223	public function resolve ( $ uri , $ version , $ resource , array $ paramDefs , array $ paramValues ) { foreach ( $ paramValues as $ param => $ value ) { if ( ! array_key_exists ( $ param , $ paramDefs ) ) { throw new \ InvalidArgumentException ( "Unknown uri parameter \"$param\" provided" ) ; } } foreach ( $ paramDefs as $ key => $ def ) { if ( ! isset ( $ paramValues [ $ key ] ) ) { if ( isset ( $ def [ 'default' ] ) ) { $ paramValues [ $ key ] = is_callable ( $ def [ 'default' ] ) ? $ def [ 'default' ] ( $ paramValues ) : $ def [ 'default' ] ; } elseif ( empty ( $ def [ 'required' ] ) ) { continue ; } else { $ this -> throwRequired ( $ paramDefs , $ paramValues ) ; } } $ this -> checkType ( $ def [ 'valid' ] , $ key , $ paramValues [ $ key ] ) ; if ( isset ( $ def [ 'fn' ] ) ) { $ def [ 'fn' ] ( $ paramValues [ $ key ] , $ paramValues ) ; } } return ( "$uri/" . "$version/" . $ this -> fillPathParams ( $ resource , $ paramValues ) . $ this -> buildQueryParameters ( $ paramValues ) ) ; }
8757	public function run ( \ Traversable $ items , callable $ itemCallback ) { $ this -> start ( ) ; foreach ( $ items as $ item ) { call_user_func ( $ itemCallback , $ this , $ item ) ; } return $ this -> finish ( ) ; }
12920	public function getTotal ( ) { if ( ! $ this -> isReady ( ) ) { return 0 ; } if ( is_null ( $ this -> _countTotal ) ) { $ this -> _countTotal = 0 ; if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_local' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> foreignDataItems ) ; } if ( in_array ( $ this -> settings [ 'direction' ] , [ 'to_foreign' , 'both' ] ) ) { $ this -> _countTotal += count ( $ this -> localDataItems ) ; } } return $ this -> _countTotal ; }
1819	public function extractYouTubeId ( $ varValue , Contao \ DataContainer $ dc ) { if ( $ dc -> activeRecord -> youtube != $ varValue ) { $ matches = array ( ) ; if ( preg_match ( '%(?:youtube(?:-nocookie)?\.com/(?:[^/]+/.+/|(?:v|e(?:mbed)?)/|.*[?&]v=)|youtu\.be/)([^"&?/ ]{11})%i' , $ varValue , $ matches ) ) { $ varValue = $ matches [ 1 ] ; } } return $ varValue ; }
3751	public function isUniqueValue ( $ strField , $ varNew , $ intId = null ) { $ attribute = $ this -> getMetaModel ( ) -> getAttribute ( $ strField ) ; if ( $ attribute ) { $ matchingIds = $ this -> prepareFilter ( $ this -> getEmptyConfig ( ) -> setFilter ( array ( array ( 'operation' => '=' , 'property' => $ attribute -> getColName ( ) , 'value' => $ varNew ) ) ) ) -> getMatchingIds ( ) ; return ( count ( $ matchingIds ) == 0 ) || ( $ matchingIds == array ( $ intId ) ) ; } return false ; }
9044	private function isRotationNeeded ( ) { clearstatcache ( ) ; if ( ! file_exists ( $ this -> file ) ) { return false ; } $ result = false ; $ attributes = stat ( $ this -> file ) ; if ( $ attributes == false || $ attributes [ 'size' ] >= $ this -> maxLogSize * 1024 * 1024 ) { $ result = true ; } return $ result ; }
6697	public function isMethodHidden ( $ methodName ) { if ( ! method_exists ( $ this , $ methodName ) ) { throw new Exception ( 500 , "The method '$methodName' does not exist in " . get_called_class ( ) ) ; } return isset ( $ this -> hiddenMethods [ $ methodName ] ) ; }
11472	public function update ( ResponseRequest $ request , Response $ response ) { try { $ attributes = $ request -> all ( ) ; $ id = $ attributes [ 'question_id' ] ; $ question = $ this -> question -> selectquestion ( $ id ) ; $ response -> update ( $ attributes ) ; return redirect ( '/discussion/' . $ question [ 'slug' ] ) ; } catch ( Exception $ e ) { return $ this -> response -> message ( $ e -> getMessage ( ) ) -> code ( 400 ) -> status ( 'error' ) -> url ( guard_url ( 'forum/response/' . $ response -> getRouteKey ( ) ) ) -> redirect ( ) ; } }
9640	protected function rebuildURL ( $ url ) { $ defaults = $ this -> config [ 'defaultparts' ] ; if ( ! preg_match ( '#^[a-zA-Z]+://#' , $ url ) ) { $ url = $ defaults [ 'scheme' ] . "://" . $ url ; } $ parts = parse_url ( $ url ) ; if ( ! $ parts ) { return "" ; } foreach ( $ parts as $ part => $ value ) { if ( $ this -> config [ 'removeparts' ] [ $ part ] === true ) { unset ( $ parts [ $ part ] ) ; } } foreach ( $ defaults as $ part => $ default ) { if ( ! isset ( $ parts [ $ part ] ) ) { $ parts [ $ part ] = $ default ; } } return rtrim ( http_build_url ( $ defaults , $ parts ) , "/" ) ; }
7024	protected function getFormatter ( ) { if ( $ this -> formatter ) { return $ this -> formatter ; } if ( ! $ this -> formatterFactory ) { throw new RuntimeException ( "Please call setFormatterFactory() first." ) ; } return $ this -> formatter = $ this -> formatterFactory -> create ( ) ; }
12445	private function getPlainCalcId ( $ period ) { if ( $ period ) { $ dsMax = $ this -> hlpPeriod -> getPeriodLastDate ( $ period ) ; } else { $ dsMax = Cfg :: DEF_MAX_DATESTAMP ; } $ query = $ this -> qbCalcGetLast -> build ( ) ; $ bind = [ QBCalcGetLast :: BND_CODE => Cfg :: CODE_TYPE_CALC_FORECAST_PLAIN , QBCalcGetLast :: BND_DATE => $ dsMax , QBCalcGetLast :: BND_STATE => Cfg :: CALC_STATE_COMPLETE ] ; $ conn = $ query -> getConnection ( ) ; $ rs = $ conn -> fetchRow ( $ query , $ bind ) ; $ result = $ rs [ QBCalcGetLast :: A_CALC_ID ] ; return $ result ; }
10280	public static function absoluteReference ( $ pCoordinateString ) { if ( self :: coordinateIsRange ( $ pCoordinateString ) ) { throw new Exception ( 'Cell coordinate string can not be a range of cells' ) ; } $ worksheet = '' ; $ cellAddress = explode ( '!' , $ pCoordinateString ) ; if ( count ( $ cellAddress ) > 1 ) { list ( $ worksheet , $ pCoordinateString ) = $ cellAddress ; } if ( $ worksheet > '' ) { $ worksheet .= '!' ; } if ( ctype_digit ( $ pCoordinateString ) ) { return $ worksheet . '$' . $ pCoordinateString ; } elseif ( ctype_alpha ( $ pCoordinateString ) ) { return $ worksheet . '$' . strtoupper ( $ pCoordinateString ) ; } return $ worksheet . self :: absoluteCoordinate ( $ pCoordinateString ) ; }
7779	protected function extractRules ( array $ data ) { $ rules = [ ] ; foreach ( $ data as $ field => $ fieldData ) { $ rules [ $ field ] = $ fieldData [ 1 ] ; } return $ rules ; }
6945	protected function watch ( OrderPaymentInterface $ payment ) { $ order = $ payment -> getOrder ( ) ; if ( ! $ order -> isAutoNotify ( ) || $ order -> isSample ( ) ) { return ; } if ( ! $ payment -> getMethod ( ) -> isManual ( ) ) { return ; } if ( ! $ this -> didStateChangeTo ( $ payment , PaymentStates :: STATE_CAPTURED ) ) { return ; } foreach ( $ order -> getNotifications ( ) as $ n ) { if ( $ n -> getType ( ) !== NotificationTypes :: PAYMENT_CAPTURED ) { continue ; } if ( $ n -> hasData ( 'payment' ) && $ n -> getData ( 'payment' ) === $ payment -> getNumber ( ) ) { return ; } } $ this -> notify ( NotificationTypes :: PAYMENT_CAPTURED , $ payment ) ; }
12102	public function setMaxSize ( $ maxSize ) { $ serverMaxSize = $ this -> getServerMaxSize ( ) ; if ( $ maxSize > $ serverMaxSize ) { throw new FileMaxSizeException ( $ serverMaxSize ) ; } $ this -> maxSize = $ maxSize ; if ( $ this -> getValidator ( ) ) { $ this -> getValidator ( ) -> setOption ( 'maxSize' , $ maxSize ) ; } }
12489	protected static function setPath ( $ writePath ) { if ( is_file ( $ writePath ) ) { self :: $ logFilePath = $ writePath ; return true ; } throw new \ Exception ( 'Impossible de modifier la destination des logs : le fichier ' . $ writePath . ' n\'existe pas.' ) ; return false ; }
5261	public function mergeQuery ( array $ query ) { $ types = [ Filter :: MERGE_AND => 'must' , Filter :: MERGE_OR => 'should' ] ; $ type = $ this -> getMergeType ( ) ; $ query [ 'body' ] [ 'filter' ] [ 'bool' ] [ $ types [ $ type ] ] [ ] = $ this -> makeQuery ( ) ; return $ query ; }
4585	public function decoded ( JWTDecodedEvent $ event ) { $ payload = $ event -> getPayload ( ) ; $ payload = json_decode ( json_encode ( $ payload ) , true ) ; if ( ! $ this -> accessor -> isReadable ( $ payload , $ this -> property ) ) { $ event -> markAsInvalid ( ) ; } elseif ( $ this -> validate && $ this -> accessor -> getValue ( $ payload , $ this -> property ) !== $ this -> getSignature ( ) ) { $ event -> markAsInvalid ( ) ; } }
8537	public function setRentalFeeList ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'RentalFeeList' ] [ 'FieldValue' ] = $ value ; return $ this ; }
11643	public function getFormatter ( ) { if ( $ this -> _formatter === null ) { $ this -> _formatter = Yii :: $ app -> format ; } return $ this -> _formatter ; }
10794	public function passwordRecovery ( array $ data ) { $ main = $ this -> getServiceLocator ( ) -> get ( 'neobazaar.service.main' ) ; $ userRepository = $ main -> getUserEntityRepository ( ) ; $ form = $ this -> getServiceLocator ( ) -> get ( 'user.form.passwordrecovery' ) ; $ form -> setData ( $ data ) ; if ( ! $ form -> isValid ( ) ) { throw new \ Exception ( serialize ( $ form -> getMessages ( ) ) ) ; } $ data = $ form -> getData ( ) ; $ email = isset ( $ data [ 'email' ] ) ? $ data [ 'email' ] : null ; $ user = $ userRepository -> findOneBy ( array ( 'email' => $ email ) ) ; if ( null === $ user ) { throw new \ Exception ( 'No user found' ) ; } $ userModel = $ this -> getServiceLocator ( ) -> get ( 'user.model.user' ) ; $ userModel -> init ( $ user , $ this -> getServiceLocator ( ) ) ; $ hash = $ userModel -> hashId . sha1 ( $ user -> getPassword ( ) ) ; $ url = $ this -> getServiceLocator ( ) -> get ( 'ControllerPluginManager' ) -> get ( 'Url' ) ; $ event = new PasswordRecoveryEvent ( __FUNCTION__ , null , array ( 'user' => $ user , 'form' => $ form , 'hash' => $ hash , 'email' => $ email , 'siteurl' => $ url -> fromRoute ( 'home' , array ( ) , array ( 'force_canonical' => true ) ) ) ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.pre' , $ this , $ event ) ; $ this -> getEventManager ( ) -> trigger ( __FUNCTION__ . '.post' , $ this , $ event ) ; return $ user ; }
12940	private function assertClient ( ClientInterface $ client ) { if ( $ client -> getConnection ( ) instanceof AggregateConnectionInterface ) { throw new NotSupportedException ( 'Cannot initialize a monitor consumer over aggregate connections.' ) ; } if ( $ client -> getCommandFactory ( ) -> supportsCommand ( 'MONITOR' ) === false ) { throw new NotSupportedException ( "'MONITOR' is not supported by the current command factory." ) ; } }
12514	public static function create ( $ path = '' , $ mode = 0777 ) { $ path = Path :: clean ( $ path ) ; $ fs = new Filesystem ( ) ; try { $ fs -> mkdir ( $ path ) ; } catch ( IOExceptionInterface $ e ) { throw new Exception ( Helper :: getTranslation ( 'FAILED_CREATING' ) . ' ' . $ e -> getPath ( ) ) ; } return true ; }
2813	public function initController ( $ controllerAction = null ) { $ controller = Mage :: getModel ( 'sheep_debug/controller' ) ; $ controller -> init ( $ controllerAction ) ; $ this -> action = $ controller ; }
9064	public function attachShared ( SharedEventManagerInterface $ events ) { $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_BOOTSTRAP , array ( $ this , 'onMvcBootstrapLast' ) , - 100000 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderAddPathStacks' ) , - 900 ) ; $ events -> attach ( 'Zend\Mvc\Application' , MvcEvent :: EVENT_RENDER , array ( $ this , 'onRenderSpecLayout' ) , - 1000 ) ; }
12416	static function run_coding_style_report ( $ task = null , $ args = array ( ) , $ cliopts = array ( ) ) { $ opts = self :: getOpts ( @ $ args [ 0 ] , @ $ args [ 1 ] , $ cliopts ) ; if ( ! SharedLock :: acquire ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ) throw new PakeException ( "Source code locked by another process" ) ; $ destdir = self :: getReportDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ; $ phpcs = self :: getTool ( 'phpcs' , $ opts , true ) ; $ rulesDir = self :: getVendorDir ( ) . '/squizlabs/php_codesniffer/Codesniffer/Standards/' . $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ; if ( ! is_dir ( $ rulesDir ) ) { if ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] == 'ezcs' ) { $ sourceDir = self :: getVendorDir ( ) . '/ezsystems/ezcs/php/ezcs' ; if ( is_dir ( $ sourceDir ) ) { pake_symlink ( $ sourceDir , $ rulesDir ) ; } } } try { $ out = pake_sh ( "$phpcs --standard=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'rules' ] ) . " " . "--report=" . escapeshellarg ( $ opts [ 'tools' ] [ 'phpcs' ] [ 'format' ] ) . " " . "--extensions=php " . escapeshellarg ( self :: getBuildDir ( $ opts ) . '/' . $ opts [ 'extension' ] [ 'name' ] ) ) ; } catch ( pakeException $ e ) { $ out = preg_replace ( '/^Problem executing command/' , '' , $ e -> getMessage ( ) ) ; } pake_mkdirs ( $ destdir ) ; pake_write_file ( $ destdir . '/phpcs.txt' , $ out , true ) ; SharedLock :: release ( $ opts [ 'extension' ] [ 'name' ] , LOCK_SH , $ opts ) ; }
1595	protected function validateId ( ) : bool { if ( ! $ this -> dataHas ( 'id' ) ) { return true ; } $ valid = $ this -> validateIdMember ( $ this -> dataGet ( 'id' ) , '/data' ) ; if ( ! $ this -> supportsClientIds ( ) ) { $ valid = false ; $ this -> resourceDoesNotSupportClientIds ( $ this -> expectedType ) ; } return $ valid ; }
10354	protected function getEventName ( ) { $ chunks = explode ( '\\' , get_class ( $ this ) ) ; $ name = $ chunks [ count ( $ chunks ) - 2 ] ; return strtolower ( $ name ) ; }
841	public function offsetUnset ( $ index ) { $ this -> changed = true ; $ this -> unregisterFoundToken ( $ this [ $ index ] ) ; parent :: offsetUnset ( $ index ) ; }
2760	public function fetchBranches ( bool $ onlyRemote = false ) : array { $ options = $ onlyRemote ? [ 'r' => true ] : [ 'a' => true ] ; $ output = $ this -> gitWorkingCopy -> branch ( $ options ) ; $ branches = ( array ) preg_split ( "/\r\n|\n|\r/" , rtrim ( $ output ) ) ; return array_map ( [ $ this , 'trimBranch' ] , $ branches ) ; }
4687	public function where ( ? string $ expression = null , ... $ args ) : self { $ this -> dirty ( ) ; $ this -> where = $ expression ; $ this -> args [ 'where' ] = $ args ; return $ this ; }
8030	public function takeFreeProcess ( ) { if ( $ this -> getFreeProcessesCount ( ) === 0 ) { return NULL ; } $ freePid = array_shift ( $ this -> freeProcessIds ) ; if ( $ freePid === NULL ) { return NULL ; } return $ this -> getProcessDetails ( $ freePid ) ; }
3056	public function persistLastCatItemOutput ( array $ lastCatItemOutput ) { $ sessionId = $ this -> getTestSession ( ) -> getSessionId ( ) ; $ this -> getServiceManager ( ) -> get ( ExtendedStateService :: SERVICE_ID ) -> setCatValue ( $ sessionId , $ this -> getCatSection ( ) -> getSectionId ( ) , 'cat-item-output' , json_encode ( $ lastCatItemOutput ) ) ; }
2961	public function readPort ( $ count = 0 ) { if ( $ this -> _dState !== SERIAL_DEVICE_OPENED ) { trigger_error ( "Device must be opened to read it" , E_USER_WARNING ) ; return false ; } if ( $ this -> _os === "linux" || $ this -> _os === "osx" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } elseif ( $ this -> _os === "windows" ) { $ content = "" ; $ i = 0 ; if ( $ count !== 0 ) { do { if ( $ i > $ count ) { $ content .= fread ( $ this -> _dHandle , ( $ count - $ i ) ) ; } else { $ content .= fread ( $ this -> _dHandle , 128 ) ; } } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } else { do { $ content .= fread ( $ this -> _dHandle , 128 ) ; } while ( ( $ i += 128 ) === strlen ( $ content ) ) ; } return $ content ; } return false ; }
9216	public function actionDelete ( $ id ) { $ model = $ this -> findModel ( $ id ) ; $ model -> isdel = 1 ; $ model -> save ( ) ; return $ this -> redirect ( [ 'index' ] ) ; }
2645	public function checkServiceDetails ( $ test = false , $ serviceId = null , $ apiKey = null ) { if ( ! $ test ) { $ uri = rtrim ( $ this -> _getApiServiceUri ( ) , '/' ) ; $ result = $ this -> _fetch ( $ uri ) ; } else { $ uri = $ this -> config -> getApiEndpoint ( ) . 'service/' . $ serviceId ; $ result = $ this -> _fetch ( $ uri , \ Zend_Http_Client :: GET , null , true , $ apiKey ) ; } if ( ! $ result ) { throw new LocalizedException ( __ ( 'Failed to check Service details.' ) ) ; } return $ result ; }
922	private function ensureAreTogether ( DocBlock $ doc , Annotation $ first , Annotation $ second ) { $ pos = $ first -> getEnd ( ) ; $ final = $ second -> getStart ( ) ; for ( $ pos = $ pos + 1 ; $ pos < $ final ; ++ $ pos ) { $ doc -> getLine ( $ pos ) -> remove ( ) ; } }
787	public function formName ( ) { $ reflector = new ReflectionClass ( $ this ) ; if ( PHP_VERSION_ID >= 70000 && $ reflector -> isAnonymous ( ) ) { throw new InvalidConfigException ( 'The "formName()" method should be explicitly defined for anonymous models' ) ; } return $ reflector -> getShortName ( ) ; }
286	public function remove ( $ name ) { $ name = strtolower ( $ name ) ; if ( isset ( $ this -> _headers [ $ name ] ) ) { $ value = $ this -> _headers [ $ name ] ; unset ( $ this -> _headers [ $ name ] ) ; return $ value ; } return null ; }
5411	public function write ( $ message ) { if ( $ this -> isError ( ) || ! $ this -> isOpen ( ) ) { return false ; } $ count = fwrite ( $ this -> handle , $ message ) ; if ( ! $ count ) { if ( $ count === false ) { $ this -> setError ( 'Cannot write to socket' ) ; $ this -> close ( ) ; } return false ; } fflush ( $ this -> handle ) ; $ this -> sent .= $ message ; return true ; }
4124	private function generateProxyClass ( $ class , $ fileName , $ template ) { $ methods = $ this -> generateMethods ( $ class ) ; $ sleepImpl = $ this -> generateSleep ( $ class ) ; $ placeholders = array ( '<namespace>' , '<proxyClassName>' , '<className>' , '<methods>' , '<sleepImpl>' ) ; $ className = ltrim ( $ class -> name , '\\' ) ; $ proxyClassName = ClassUtils :: generateProxyClassName ( $ class -> name , $ this -> proxyNamespace ) ; $ parts = explode ( '\\' , strrev ( $ proxyClassName ) , 2 ) ; $ proxyClassNamespace = strrev ( $ parts [ 1 ] ) ; $ proxyClassName = strrev ( $ parts [ 0 ] ) ; $ replacements = array ( $ proxyClassNamespace , $ proxyClassName , $ className , $ methods , $ sleepImpl ) ; $ template = str_replace ( $ placeholders , $ replacements , $ template ) ; file_put_contents ( $ fileName , $ template , LOCK_EX ) ; }
10581	public function handleRequest ( ServerRequestInterface $ serverRequest , ResponseInterface $ response ) : ResponseInterface { $ response = $ response -> withProtocolVersion ( $ serverRequest -> getProtocolVersion ( ) ) ; try { try { $ APIRequest = $ this -> requestFactory -> create ( $ serverRequest ) ; } catch ( UnableToCreateRequestException $ exception ) { return $ this -> handleRequestFactoryException ( $ exception , $ response ) ; } try { $ APIResponse = $ this -> server -> handleRequest ( $ APIRequest ) ; } catch ( UnableToHandleRequestException $ exception ) { return $ this -> handleServerException ( $ exception , $ response ) ; } return $ this -> buildResponse ( $ APIResponse , $ response ) ; } catch ( \ Throwable $ e ) { $ this -> logCaughtThrowableResultingInHTTPCode ( 500 , $ e , LogLevel :: CRITICAL ) ; return $ response -> withStatus ( 500 , "Internal Server Error" ) ; } }
8267	public function close ( ) { if ( ! $ this -> isOpened ( ) ) { return ; } $ this -> unlock ( ) ; if ( $ this -> handle && ! fclose ( $ this -> handle ) ) { throw new \ RuntimeException ( "Could not close file " . $ this -> filePath ) ; } }
584	protected function loadConfiguration ( $ configFile ) { $ this -> stdout ( "Loading configuration from '{$configFile}'...\n" ) ; $ config = require $ configFile ; foreach ( $ config as $ name => $ value ) { if ( property_exists ( $ this , $ name ) || $ this -> canSetProperty ( $ name ) ) { $ this -> $ name = $ value ; } else { throw new Exception ( "Unknown configuration option: $name" ) ; } } $ this -> getAssetManager ( ) ; }
12582	public function setTranslator ( $ translator , $ translatorDomain = null , $ translatorLocale = null ) { $ this -> translator = $ translator ; $ this -> setTranslatorDomain ( $ translatorDomain ) ; $ this -> setTranslatorLocale ( $ translatorLocale ) ; $ this -> setCaption ( $ this -> translate ( $ this -> getCaption ( ) ) ) ; }
1296	private function getUnresolvedField ( Field $ field , string $ locale = null ) { if ( ! isset ( $ this -> fields [ $ field -> getId ( ) ] ) ) { return 'Array' === $ field -> getType ( ) ? [ ] : null ; } $ value = $ this -> fields [ $ field -> getId ( ) ] ; $ locale = $ this -> getLocaleFromInput ( $ locale ) ; if ( \ array_key_exists ( $ locale , $ value ) ) { return $ value [ $ locale ] ; } if ( ! $ field -> isLocalized ( ) ) { throw new \ InvalidArgumentException ( \ sprintf ( 'Trying to access the non-localized field "%s" on content type "%s" using the non-default locale "%s".' , $ field -> getName ( ) , $ this -> sys -> getContentType ( ) -> getName ( ) , $ locale ) ) ; } $ locale = $ this -> walkFallbackChain ( $ value , $ locale , $ this -> sys -> getEnvironment ( ) ) ; if ( $ locale ) { return $ value [ $ locale ] ; } return 'Array' === $ field -> getType ( ) ? [ ] : null ; }
4366	protected function backtraceStr ( Event $ error ) { $ backtrace = $ error [ 'backtrace' ] ? $ error [ 'backtrace' ] : $ error -> getSubject ( ) -> backtrace ( ) ; if ( \ count ( $ backtrace ) < 2 ) { return '' ; } if ( $ backtrace && $ error [ 'vars' ] ) { $ backtrace [ 0 ] [ 'vars' ] = $ error [ 'vars' ] ; } if ( $ this -> cfg [ 'emailBacktraceDumper' ] ) { $ str = \ call_user_func ( $ this -> cfg [ 'emailBacktraceDumper' ] , $ backtrace ) ; } else { $ search = array ( ")\n\n" , ) ; $ replace = array ( ")\n" , ) ; $ str = \ print_r ( $ backtrace , true ) ; $ str = \ preg_replace ( '#\bArray\n\(#' , 'array(' , $ str ) ; $ str = \ preg_replace ( '/\barray\s+\(\s+\)/s' , 'array()' , $ str ) ; $ str = \ str_replace ( $ search , $ replace , $ str ) ; $ str = \ substr ( $ str , 0 , - 1 ) ; } return $ str ; }
5893	public function listAudioTemplates ( CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audio' , $ parameters , $ cachePolicy ) ; foreach ( $ result as & $ entry ) { $ entry = new AudioTemplate ( $ entry ) ; } unset ( $ entry ) ; reset ( $ result ) ; return $ result ; }
4721	public function processListItems ( Text $ list , array $ options = array ( ) , $ level = 0 ) { $ list -> replace ( '/\n{2,}\z/' , "\n" ) ; $ list -> replace ( '{ (\n)? # leading line = $1 (^[ \t]*) # leading whitespace = $2 (' . $ this -> getPattern ( ) . ') [ \t]+ # list marker = $3 ((?s:.+?) # list item text = $4 (\n{1,2})) (?= \n* (\z | \2 (' . $ this -> getPattern ( ) . ') [ \t]+)) }mx' , function ( Text $ w , Text $ leadingLine , Text $ ls , Text $ m , Text $ item ) use ( $ options , $ level ) { if ( ( string ) $ leadingLine || $ item -> match ( '/\n{2,}/' ) ) { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> markdown -> emit ( 'block' , array ( $ item ) ) ; } else { $ this -> markdown -> emit ( 'outdent' , array ( $ item ) ) ; $ this -> processList ( $ item , $ options , ++ $ level ) ; $ item -> rtrim ( ) ; $ this -> markdown -> emit ( 'inline' , array ( $ item ) ) ; } return $ this -> getRenderer ( ) -> renderListItem ( $ item ) . "\n" ; } ) ; }
4334	public function getCfg ( $ path = null ) { if ( $ path == 'outputAs' ) { $ ret = $ this -> cfg [ 'outputAs' ] ; if ( ! $ ret ) { $ ret = $ this -> getDefaultOutputAs ( ) ; } } elseif ( $ path == 'css' ) { $ ret = $ this -> getCss ( ) ; } else { $ ret = $ this -> debug -> utilities -> arrayPathGet ( $ this -> cfg , $ path ) ; } return $ ret ; }
4335	public function onOutput ( Event $ event ) { if ( ! $ event [ 'isTarget' ] ) { return ; } $ this -> data = $ this -> debug -> getData ( ) ; $ this -> closeOpenGroups ( ) ; foreach ( $ this -> data [ 'logSummary' ] as & $ log ) { $ this -> removeHideIfEmptyGroups ( $ log ) ; $ this -> uncollapseErrors ( $ log ) ; } $ this -> removeHideIfEmptyGroups ( $ this -> data [ 'log' ] ) ; $ this -> uncollapseErrors ( $ this -> data [ 'log' ] ) ; $ this -> debug -> setData ( $ this -> data ) ; }
10884	public function report ( ErrorStreamReport $ report ) { $ report -> tags = $ this -> tags ; $ report -> context = $ this -> context ; return $ this -> makeRequest ( $ report ) ; }
8016	public function close ( ) { $ uri = $ this -> current ( ) -> getNextUri ( ) ; if ( ! is_null ( $ uri ) ) { $ this -> client -> deleteAsync ( $ uri ) -> wait ( ) ; } $ this -> closed = true ; }
9571	public function bootConsole ( ) { $ this -> console = new ConsoleApplication ( 'Autarky' , static :: VERSION ) ; $ this -> console -> setAutarkyApplication ( $ this ) ; $ this -> boot ( ) ; return $ this -> console ; }
8005	public static function calculatePayloadOffset ( $ negotiate_flags ) { $ offset = 0 ; $ offset += strlen ( static :: SIGNATURE ) ; $ offset += 4 ; $ offset += 4 ; $ offset += 8 ; $ offset += 8 ; return $ offset ; }
31	public function parseHgIgnoreLine ( $ line ) { if ( preg_match ( '#^syntax\s*:\s*(glob|regexp)$#' , $ line , $ matches ) ) { if ( $ matches [ 1 ] === 'glob' ) { $ this -> patternMode = self :: HG_IGNORE_GLOB ; } else { $ this -> patternMode = self :: HG_IGNORE_REGEX ; } return null ; } if ( $ this -> patternMode == self :: HG_IGNORE_GLOB ) { return $ this -> patternFromGlob ( $ line ) ; } return $ this -> patternFromRegex ( $ line ) ; }
5798	public function routeIndex ( Request $ request , Response $ response , $ args ) { $ this -> tableName = $ args [ ROUTEARG_DATABASE_TABLE_NAME ] ; $ this -> tableMapper = new TableMapper ( $ this -> tableName ) ; parent :: __construct ( $ this -> container , $ this -> tableMapper , ROUTEPREFIX_ROLES ) ; return $ this -> indexView ( $ response ) ; }
6958	public function setForcedRedirect ( $ url ) { $ data = $ this -> getData ( true ) ; $ data [ static :: $ forcedRedirectKey ] = $ url ; return $ this -> setData ( $ data ) ; }
6991	static public function getLocaleWithSuffix ( $ separator = '_' , $ lowercased = false ) : ? string { $ locale = preg_split ( '%[-_]%' , strtolower ( app ( ) -> getLocale ( ) ) ) ; if ( count ( $ locale ) === 2 ) { return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ locale [ 1 ] : strtoupper ( $ locale [ 1 ] ) ) ; } else { $ localeSuffix = isset ( static :: $ localeSuffixMap [ $ locale [ 0 ] ] ) ? static :: $ localeSuffixMap [ $ locale [ 0 ] ] : $ locale [ 0 ] ; return $ locale [ 0 ] . $ separator . ( $ lowercased ? $ localeSuffix : strtoupper ( $ localeSuffix ) ) ; } }
6380	public function readAttempt ( $ id ) { $ model = $ this -> readObject ( $ id , 'quiz_attempts' ) ; $ model -> url = $ this -> cfg -> wwwroot . '/mod/quiz/attempt.php?attempt=' . $ id ; $ model -> name = 'Attempt ' . $ id ; return $ model ; }
6410	public static function concatIterables ( IteratorAggregate $ iterables ) : IteratorAggregate { return self :: from ( Iterators :: concatIterators ( FluentIterable :: from ( $ iterables ) -> transform ( function ( Traversable $ element ) { return Iterators :: from ( $ element ) ; } ) -> iterator ( ) ) ) ; }
3157	public function storeResponseVariable ( RunnerServiceContext $ context , $ itemUri , $ variableIdentifier , $ variableValue ) { $ this -> assertQtiRunnerServiceContext ( $ context ) ; $ metaVariable = $ this -> getResponseVariable ( $ variableIdentifier , $ variableValue ) ; return $ this -> storeVariable ( $ context , $ itemUri , $ metaVariable ) ; }
3539	public static function getAdldapProvider ( ) { if ( static :: getExtensionOptions ( 'adldap-providername' ) != '__USE_DEFAULT_PROVIDER__' ) { $ provider = Yii :: $ app -> ad -> getProvider ( static :: getExtensionOptions ( 'adldap-providername' ) ) ; } else { $ provider = Yii :: $ app -> ad -> getDefaultProvider ( ) ; } return $ provider ; }
4209	private function methodInfo ( $ obj , \ ReflectionMethod $ reflectionMethod ) { $ declaringClassName = $ reflectionMethod -> getDeclaringClass ( ) -> getName ( ) ; $ phpDoc = $ this -> phpDoc -> getParsed ( $ reflectionMethod ) ; $ vis = 'public' ; if ( $ reflectionMethod -> isPrivate ( ) ) { $ vis = 'private' ; } elseif ( $ reflectionMethod -> isProtected ( ) ) { $ vis = 'protected' ; } $ info = array ( 'implements' => null , 'inheritedFrom' => $ declaringClassName != \ get_class ( $ obj ) ? $ declaringClassName : null , 'isAbstract' => $ reflectionMethod -> isAbstract ( ) , 'isDeprecated' => $ reflectionMethod -> isDeprecated ( ) || isset ( $ phpDoc [ 'deprecated' ] ) , 'isFinal' => $ reflectionMethod -> isFinal ( ) , 'isStatic' => $ reflectionMethod -> isStatic ( ) , 'params' => $ this -> getParams ( $ reflectionMethod , $ phpDoc ) , 'phpDoc' => $ phpDoc , 'visibility' => $ vis , ) ; unset ( $ info [ 'phpDoc' ] [ 'param' ] ) ; return $ info ; }
6976	protected function scheduleSaleContentChangeEvent ( Model \ AdjustmentInterface $ adjustment ) { if ( $ adjustment instanceof Model \ SaleAdjustmentInterface ) { if ( null === $ sale = $ this -> getSaleFromAdjustment ( $ adjustment ) ) { return ; } } elseif ( $ adjustment instanceof Model \ SaleItemAdjustmentInterface ) { if ( null === $ item = $ this -> getItemFromAdjustment ( $ adjustment ) ) { return ; } if ( null === $ sale = $ this -> getSaleFromItem ( $ item ) ) { return ; } } else { throw new InvalidArgumentException ( "Unexpected adjustment type." ) ; } $ this -> persistenceHelper -> scheduleEvent ( $ this -> getSaleChangeEvent ( ) , $ sale ) ; }
9586	public function scaffoldFormField ( $ title = null , $ params = null ) { $ field = new ExternalURLField ( $ this -> name , $ title ) ; $ field -> setMaxLength ( $ this -> getSize ( ) ) ; return $ field ; }
3980	private function getCommandInstance ( CommandCollectionInterface $ collection , $ operationName ) { if ( $ collection -> hasCommandNamed ( $ operationName ) ) { $ command = $ collection -> getCommandNamed ( $ operationName ) ; } else { switch ( $ operationName ) { case 'cut' : $ command = new CutCommand ( ) ; break ; case 'copy' : $ command = new CopyCommand ( ) ; break ; default : $ command = new Command ( ) ; } $ command -> setName ( $ operationName ) ; $ collection -> addCommand ( $ command ) ; } return $ command ; }
6476	public function readAsJson ( ? IHttpBody $ body ) : array { if ( $ body === null ) { return [ ] ; } $ json = json_decode ( $ body -> readAsString ( ) , true ) ; if ( $ json === null ) { throw new RuntimeException ( 'Body could not be decoded as JSON' ) ; } return $ json ; }
5640	public function paintGroupEnd ( $ test_name ) { array_pop ( $ this -> test_stack ) ; if ( count ( $ this -> test_stack ) == 0 ) { $ this -> paintFooter ( $ test_name ) ; } }
4506	public function create ( OrganizationPersona $ persona , Parameters $ parameters = null ) : OrganizationPersona { $ options = [ ] ; $ options [ 'json' ] = ( array ) static :: toObject ( $ persona ) ; if ( $ parameters ) { $ options [ 'query' ] = ( array ) $ parameters -> toObject ( true ) ; } $ object = $ this -> execute ( 'POST' , static :: RESOURCE_LIST , $ options ) ; $ persona = static :: toModel ( $ object ) ; return $ persona ; }
2875	public function getCategory ( $ timerName ) { $ category = self :: CORE_CATEGORY ; if ( strpos ( $ timerName , 'mage::dispatch' ) === 0 || strpos ( $ timerName , 'column.phtml' ) > 0 ) { $ category = self :: SECTION ; } else if ( strpos ( $ timerName , 'Model_Resource' ) > 0 ) { $ category = self :: DB_CATEGORY ; } else if ( strpos ( $ timerName , 'EAV' ) === 0 || strpos ( $ timerName , '_LOAD_ATTRIBUTE_' ) === 0 || strpos ( $ timerName , '__EAV_' ) === 0 ) { $ category = self :: EAV_CATEGORY ; } else if ( strpos ( $ timerName , 'CORE::create_object_of' ) === 0 ) { $ category = self :: CORE_CATEGORY ; } else if ( strpos ( $ timerName , 'OBSERVER' ) === 0 || strpos ( $ timerName , 'DISPATCH EVENT' ) === 0 ) { $ category = self :: EVENT_CATEGORY ; } else if ( strpos ( $ timerName , 'BLOCK' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'init_config' ) === 0 ) { $ category = self :: CONFIG_CATEGORY ; } else if ( strpos ( $ timerName , 'layout/' ) === 0 || strpos ( $ timerName , 'layout_' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , 'Mage_Core_Model_Design' ) === 0 ) { $ category = self :: LAYOUT_CATEGORY ; } else if ( strpos ( $ timerName , '.phtml' ) > 0 ) { $ category = self :: LAYOUT_CATEGORY ; } return $ category ; }
6328	private function getColumnsSql ( ) { $ columnTypeMapper = new ColumnTypeMapper ( ) ; foreach ( $ this -> table -> getConstraints ( ) as $ constraint ) { if ( $ constraint instanceof PrimaryKey ) { $ primaryKey = $ constraint ; } } if ( ! isset ( $ primaryKey ) ) { $ primaryKey = new PrimaryKey ( ) ; $ primaryKey -> setTable ( $ this -> table ) ; $ this -> table -> addConstraint ( $ primaryKey ) ; } $ sql = '' ; if ( ! $ primaryKey -> isMulti ( ) && $ primaryKey -> isAutoCreateColumn ( ) ) { $ sql = sprintf ( '%s %s NOT NULL,' , $ primaryKey -> getColumns ( ) , $ primaryKey -> isAutoIncrement ( ) ? 'serial' : 'integer' ) ; } foreach ( $ this -> table -> getColumns ( ) as $ column ) { if ( $ column instanceof CustomColumn ) { $ columnType = $ column -> getType ( ) ; } else { $ columnType = $ columnTypeMapper -> getNative ( $ column -> getType ( ) ) ; } $ sql .= sprintf ( '%s %s%s %s %s,' , $ column -> getName ( ) , $ columnType , $ this -> getTypeConstraints ( $ column ) , $ column -> isNotNull ( ) ? 'NOT NULL' : '' , null === $ column -> getDefault ( ) ? '' : 'DEFAULT' . ' ' . $ this -> addQuotesIfNeeded ( $ column , $ column -> getDefault ( ) ) ) ; } return rtrim ( $ sql , ',' ) ; }
530	public function actionSortChangelog ( array $ what ) { if ( \ count ( $ what ) > 1 ) { $ this -> stdout ( "Currently only one simultaneous release is supported.\n" ) ; return 1 ; } $ this -> validateWhat ( $ what , [ 'framework' , 'ext' ] , false ) ; $ version = $ this -> version ? : array_values ( $ this -> getNextVersions ( $ this -> getCurrentVersions ( $ what ) , self :: PATCH ) ) [ 0 ] ; $ this -> stdout ( 'sorting CHANGELOG of ' ) ; $ this -> stdout ( reset ( $ what ) , Console :: BOLD ) ; $ this -> stdout ( ' for version ' ) ; $ this -> stdout ( $ version , Console :: BOLD ) ; $ this -> stdout ( '...' ) ; $ this -> resortChangelogs ( $ what , $ version ) ; $ this -> stdout ( "done.\n" , Console :: BOLD , Console :: FG_GREEN ) ; }
6147	public function sendHeaders ( ) { if ( php_sapi_name ( ) !== "cli" && headers_sent ( $ file , $ line ) ) { throw new Exception ( "Try to send headers but headers already sent, output started at $file line $line." ) ; } http_response_code ( $ this -> statusCode ) ; foreach ( $ this -> headers as $ header ) { if ( php_sapi_name ( ) !== "cli" ) { header ( $ header ) ; } } return $ this ; }
2776	public static function parseRepositoryName ( string $ repositoryUrl ) : string { $ scheme = parse_url ( $ repositoryUrl , PHP_URL_SCHEME ) ; if ( $ scheme === null ) { $ parts = explode ( '/' , $ repositoryUrl ) ; $ path = end ( $ parts ) ; } else { $ strpos = strpos ( $ repositoryUrl , ':' ) ; $ path = substr ( $ repositoryUrl , $ strpos + 1 ) ; } return basename ( $ path , '.git' ) ; }
4509	public function getContext ( ) : string { $ tenant = $ this -> parameterService -> get ( 'ds_tenant.tenant.default' ) ; $ request = $ this -> requestStack -> getCurrentRequest ( ) ; if ( $ request -> request -> has ( 'tenant' ) && $ request -> request -> get ( 'tenant' ) ) { $ tenant = $ request -> request -> get ( 'tenant' ) ; } if ( $ request -> query -> has ( 'tenant' ) && $ request -> query -> get ( 'tenant' ) ) { $ tenant = $ request -> query -> get ( 'tenant' ) ; } $ token = $ this -> tokenStorage -> getToken ( ) ; if ( $ token ) { $ user = $ token -> getUser ( ) ; if ( $ user instanceof User ) { $ tenant = $ user -> getTenant ( ) ; } } return $ tenant ; }
1112	public function mapTree ( $ nodeList ) { $ tree = $ nodeList instanceof ArrayableInterface ? $ nodeList -> toArray ( ) : $ nodeList ; $ affectedKeys = array ( ) ; $ result = $ this -> mapTreeRecursive ( $ tree , $ this -> node -> getKey ( ) , $ affectedKeys ) ; if ( $ result && count ( $ affectedKeys ) > 0 ) $ this -> deleteUnaffected ( $ affectedKeys ) ; return $ result ; }
6237	private static function getOptions ( ) { return [ '1/6' => Craft :: t ( 'width-fieldtype' , '1/6' ) , '1/5' => Craft :: t ( 'width-fieldtype' , '1/5' ) , '1/4' => Craft :: t ( 'width-fieldtype' , '1/4' ) , '1/3' => Craft :: t ( 'width-fieldtype' , '1/3' ) , '2/5' => Craft :: t ( 'width-fieldtype' , '2/5' ) , '1/2' => Craft :: t ( 'width-fieldtype' , '1/2' ) , '3/5' => Craft :: t ( 'width-fieldtype' , '3/5' ) , '2/3' => Craft :: t ( 'width-fieldtype' , '2/3' ) , '3/4' => Craft :: t ( 'width-fieldtype' , '3/4' ) , '4/5' => Craft :: t ( 'width-fieldtype' , '4/5' ) , '5/6' => Craft :: t ( 'width-fieldtype' , '5/6' ) , 'full' => Craft :: t ( 'width-fieldtype' , 'Full' ) , ] ; }
2793	public function getCacheDirectory ( ) { if ( ! is_null ( $ this -> cacheDirectory ) ) { return $ this -> cacheDirectory ; } if ( defined ( 'PHP_WINDOWS_VERSION_MAJOR' ) ) { if ( ! getenv ( 'APPDATA' ) ) { throw new RuntimeException ( 'The APPDATA environment variable must be set for humbug.' ) ; } $ home = strtr ( getenv ( 'APPDATA' ) , '\\' , '/' ) . '/Humbug' ; } else { if ( ! getenv ( 'HOME' ) ) { throw new RuntimeException ( 'The HOME environment variable must be set for humbug.' ) ; } $ home = rtrim ( getenv ( 'HOME' ) , '/' ) . '/.humbug' ; } $ cache = $ home . '/cache' ; foreach ( [ $ home , $ cache ] as $ dir ) { if ( ! is_dir ( $ dir ) ) { mkdir ( $ dir , 0777 ) ; } } file_put_contents ( $ home . '/.htaccess' , 'Deny from all' ) ; $ this -> cacheDirectory = $ cache ; return $ cache ; }
4829	public function cancel ( ) { $ endpoint = self :: $ endpoint . '/' . $ this -> id . '/cancel' ; return new self ( $ this -> client , $ this -> client -> request ( 'put' , $ endpoint ) ) ; }
5336	protected function encodeParameters ( $ parameters , $ keyPrefix = null ) { if ( ! is_array ( $ parameters ) && ! is_object ( $ parameters ) ) { return rawurlencode ( $ parameters ) ; } $ encodedData = [ ] ; foreach ( $ parameters as $ key => $ value ) { $ encodedKey = is_null ( $ keyPrefix ) ? rawurlencode ( $ key ) : $ keyPrefix . '[' . rawurlencode ( $ key ) . ']' ; if ( is_array ( $ value ) || is_object ( $ value ) ) { $ encodedData [ ] = $ this -> encodeParameters ( $ value , $ encodedKey ) ; } else { $ encodedData [ ] = $ encodedKey . '=' . rawurlencode ( $ value ) ; } } return implode ( '&' , $ encodedData ) ; }
658	public function cache ( callable $ callable , $ duration = null , $ dependency = null ) { $ this -> _queryCacheInfo [ ] = [ $ duration === null ? $ this -> queryCacheDuration : $ duration , $ dependency ] ; try { $ result = call_user_func ( $ callable , $ this ) ; array_pop ( $ this -> _queryCacheInfo ) ; return $ result ; } catch ( \ Exception $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } catch ( \ Throwable $ e ) { array_pop ( $ this -> _queryCacheInfo ) ; throw $ e ; } }
8155	public function addGlobal ( $ name , $ value ) { if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { if ( null === $ this -> globals ) { $ this -> globals = $ this -> initGlobals ( ) ; } if ( ! array_key_exists ( $ name , $ this -> globals ) ) { @ trigger_error ( sprintf ( 'Registering global variable "%s" at runtime or when the extensions have already been initialized is deprecated since version 1.21.' , $ name ) , E_USER_DEPRECATED ) ; } } if ( $ this -> extensionInitialized || $ this -> runtimeInitialized ) { $ this -> globals [ $ name ] = $ value ; } else { $ this -> staging -> addGlobal ( $ name , $ value ) ; } }
6814	private function getCurrencyFormatter ( ) { if ( $ this -> currencyFormatter ) { return $ this -> currencyFormatter ; } return $ this -> currencyFormatter = NumberFormatter :: create ( $ this -> locale , NumberFormatter :: CURRENCY ) ; }
2497	private function getCoreCriterion ( array $ languageCodes , $ useAlwaysAvailable ) { if ( ! empty ( $ languageCodes ) ) { $ filter = $ this -> getLanguageFilter ( $ languageCodes ) ; if ( $ useAlwaysAvailable ) { $ filter = new LogicalOr ( array ( $ filter , $ this -> getAlwaysAvailableFilter ( $ languageCodes ) , ) ) ; } return $ filter ; } return new CustomField ( self :: FIELD_IS_MAIN_LANGUAGE , Operator :: EQ , true ) ; }
10225	public function itemsFor ( $ model , $ items = null , $ targetUrl = null , $ nextPageUrl = null , $ offset = - 1 , ModelConfig $ config = null ) { $ modelName = $ this -> resolveModelName ( $ model ) ; if ( $ items == null ) { $ items = call_user_func ( array ( $ modelName , 'simplePaginate' ) , 10 ) ; } $ factory = $ this -> app -> make ( 'Label305\AujaLaravel\Factory\ResourceItemsFactory' ) ; return $ factory -> create ( $ modelName , $ items , $ targetUrl , $ nextPageUrl , $ offset , $ config ) ; }
12423	protected function getTranslations ( $ domain ) { if ( ! isset ( $ this -> translations [ $ domain ] ) ) { if ( ! isset ( $ this -> translationSources [ $ domain ] ) ) { $ msg = sprintf ( 'No translation directory for domain "%1$s" available' , $ domain ) ; throw new \ Aimeos \ MW \ Translation \ Exception ( $ msg ) ; } $ locale = $ this -> getLocale ( ) ; $ locations = array_reverse ( $ this -> getTranslationFileLocations ( $ this -> translationSources [ $ domain ] , $ locale ) ) ; foreach ( $ locations as $ location ) { $ translator = \ Zend \ I18n \ Translator \ MwTranslator :: factory ( $ this -> options ) ; $ translator -> addTranslationFile ( $ this -> adapter , $ location , $ domain , $ locale ) ; $ this -> translations [ $ domain ] [ $ location ] = $ translator ; } } return ( isset ( $ this -> translations [ $ domain ] ) ? $ this -> translations [ $ domain ] : [ ] ) ; }
7263	protected function convert ( Model \ SaleInterface $ sale , float $ amount , string $ currency , bool $ round ) { if ( $ currency === $ this -> converter -> getDefaultCurrency ( ) ) { return $ round ? Money :: round ( $ amount , $ currency ) : $ amount ; } if ( null !== $ rate = $ sale -> getExchangeRate ( ) ) { return $ this -> converter -> convertWithRate ( $ amount , $ rate , $ currency , $ round ) ; } $ date = $ this -> contextProvider -> getContext ( $ sale ) -> getDate ( ) ; return $ this -> converter -> convert ( $ amount , $ this -> converter -> getDefaultCurrency ( ) , $ currency , $ date , $ round ) ; }
1712	public function getArticleAlias ( Contao \ DataContainer $ dc ) { $ arrPids = array ( ) ; $ arrAlias = array ( ) ; if ( ! $ this -> User -> isAdmin ) { foreach ( $ this -> User -> pagemounts as $ id ) { $ arrPids [ ] = array ( $ id ) ; $ arrPids [ ] = $ this -> Database -> getChildRecords ( $ id , 'tl_page' ) ; } if ( ! empty ( $ arrPids ) ) { $ arrPids = array_merge ( ... $ arrPids ) ; } else { return $ arrAlias ; } $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid WHERE a.pid IN(" . implode ( ',' , array_map ( '\intval' , array_unique ( $ arrPids ) ) ) . ") ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } else { $ objAlias = $ this -> Database -> prepare ( "SELECT a.id, a.title, a.inColumn, p.title AS parent FROM tl_article a LEFT JOIN tl_page p ON p.id=a.pid ORDER BY parent, a.sorting" ) -> execute ( $ dc -> id ) ; } if ( $ objAlias -> numRows ) { Contao \ System :: loadLanguageFile ( 'tl_article' ) ; while ( $ objAlias -> next ( ) ) { $ arrAlias [ $ objAlias -> parent ] [ $ objAlias -> id ] = $ objAlias -> title . ' (' . ( $ GLOBALS [ 'TL_LANG' ] [ 'COLS' ] [ $ objAlias -> inColumn ] ? : $ objAlias -> inColumn ) . ', ID ' . $ objAlias -> id . ')' ; } } return $ arrAlias ; }
6508	public function doStop ( ) { if ( $ this -> controller -> doStop ( ) ) { $ this -> job -> setStatus ( Status :: CANCELLED ( ) ) ; return true ; } return false ; }
7448	function encrypt ( $ data , $ password ) { $ salt = openssl_random_pseudo_bytes ( 16 ) ; $ salted = '' ; $ dx = '' ; while ( strlen ( $ salted ) < 48 ) { $ dx = hash ( 'sha256' , $ dx . $ password . $ salt , true ) ; $ salted .= $ dx ; } $ key = substr ( $ salted , 0 , 32 ) ; $ iv = substr ( $ salted , 32 , 16 ) ; $ encrypted_data = openssl_encrypt ( $ data , 'AES-256-CBC' , $ key , true , $ iv ) ; return base64_encode ( $ salt . $ encrypted_data ) ; }
155	public function scalar ( $ db = null ) { if ( $ this -> emulateExecution ) { return null ; } return $ this -> createCommand ( $ db ) -> queryScalar ( ) ; }
8396	public static function ensureTable ( array $ mapping ) : bool { $ database = Database :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ statement = 'CREATE TABLE IF NOT EXISTS _stray_migration (' ; $ statement .= 'date TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, ' ; $ statement .= 'migration VARCHAR(255)' ; $ statement .= ')' ; $ statement = $ database -> getMasterLink ( ) -> prepare ( $ statement ) ; if ( $ statement -> execute ( ) === false ) { echo 'Can\'t create _stray_migration (' . $ statement -> errorInfo ( ) [ 2 ] . ')' . PHP_EOL ; return false ; } $ select = new Select ( $ mapping [ 'config' ] [ 'database' ] , true ) ; $ select -> select ( 'COUNT(*) as count' ) -> from ( '_stray_migration' ) ; if ( $ select -> execute ( ) === false ) { echo 'Can\'t fetch from _stray_migration (' . $ select -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } if ( $ select -> fetch ( ) [ 'count' ] == 0 ) { $ insert = new Insert ( $ mapping [ 'config' ] [ 'database' ] ) ; $ insert -> into ( '_stray_migration' ) ; if ( $ insert -> execute ( ) === false ) { echo 'Can\'t insert into _stray_migration (' . $ insert -> getErrorMessage ( ) . ')' . PHP_EOL ; return false ; } } return true ; }
6026	public function setMimetype ( $ mimetype ) { if ( $ mimetype instanceof MimeType ) { $ this -> mimetype = $ mimetype ; } elseif ( is_array ( $ mimetype ) ) { $ this -> mimetype = new MimeType ( $ mimetype ) ; } else { $ this -> mimetype = null ; trigger_error ( 'Argument must be an object of class MimeType. Data loss!' , E_USER_WARNING ) ; } return $ this ; }
8966	public static function exists ( $ currencyCode ) { $ currencyCode = trim ( strtoupper ( $ currencyCode ) ) ; return array_key_exists ( $ currencyCode , self :: $ codes ) ; }
2988	public function hasResourceInAnnotation ( $ bundle ) { if ( ! file_exists ( $ this -> file ) ) { return false ; } $ config = Yaml :: parse ( file_get_contents ( $ this -> file ) ) ; $ search = sprintf ( '@%s/Controller/' , $ bundle ) ; foreach ( $ config as $ resource ) { if ( array_key_exists ( 'resource' , $ resource ) ) { return $ resource [ 'resource' ] === $ search ; } } return false ; }
5182	private function fillSource ( $ source , $ photo ) : string { if ( ! empty ( $ source ) ) { return $ this -> filterUriInstance ( $ source ) ; } return ( string ) $ photo ; }
5894	public function retrieveAudioTemplate ( $ id , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ ] , 'body' => json_encode ( [ ] , JSON_UNESCAPED_UNICODE ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/templates/audiotemplate' , $ parameters , $ cachePolicy ) ; $ result = new AudioTemplate ( $ result ) ; return $ result ; }
468	public function buildSimpleCondition ( $ operator , $ operands , & $ params ) { array_unshift ( $ operands , $ operator ) ; return $ this -> buildCondition ( $ operands , $ params ) ; }
3647	protected function process ( string $ value , bool $ trim = true , bool $ clean = true ) { if ( $ trim ) { $ value = trim ( $ value ) ; } if ( $ clean ) { $ value = $ this -> security -> clean ( $ value ) ; } return $ value ; }
887	private function needFixing ( Tokens $ tokens , $ index ) { if ( $ this -> isStrictOrNullableReturnTypeFunction ( $ tokens , $ index ) ) { return false ; } $ content = '' ; while ( ! $ tokens [ $ index ] -> equals ( ';' ) ) { $ index = $ tokens -> getNextMeaningfulToken ( $ index ) ; $ content .= $ tokens [ $ index ] -> getContent ( ) ; } $ content = ltrim ( $ content , '(' ) ; $ content = rtrim ( $ content , ');' ) ; return 'null' === strtolower ( $ content ) ; }
1776	protected function isSelected ( $ arrOption ) { if ( empty ( $ this -> varValue ) && empty ( $ _POST ) && $ arrOption [ 'default' ] ) { return static :: optionSelected ( 1 , 1 ) ; } return static :: optionSelected ( $ arrOption [ 'value' ] , $ this -> varValue ) ; }
7937	public function createBackupFTPAccess ( $ domain , $ ipBlock ) { if ( ! $ domain ) throw new BadMethodCallException ( 'Parameter $domain is missing.' ) ; if ( ! $ ipBlock ) throw new BadMethodCallException ( 'Parameter $ipBlock is missing.' ) ; $ payload = array ( 'ftp' => ( 1 == 1 ) , 'ipBlock' => $ ipBlock , 'nfs' => ( 1 == 0 ) , 'cifs' => ( 1 == 0 ) ) ; try { $ r = $ this -> post ( 'dedicated/server/' . $ domain . '/features/backupFTP/access' , array ( 'Content-Type' => 'application/json;charset=UTF-8' ) , json_encode ( $ payload ) ) -> send ( ) ; } catch ( \ Exception $ e ) { throw new ServerException ( $ e -> getMessage ( ) , $ e -> getCode ( ) , $ e ) ; } return $ r -> getBody ( true ) ; }
4300	public function groupEnd ( $ value = \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'value' => \ bdk \ Debug \ Abstracter :: UNDEFINED ) ) ; \ extract ( $ args ) ; $ groupStackWas = $ this -> rootInstance -> groupStackRef ; $ appendLog = false ; if ( $ groupStackWas && \ end ( $ groupStackWas ) [ 'collect' ] == $ this -> cfg [ 'collect' ] ) { \ array_pop ( $ this -> rootInstance -> groupStackRef ) ; $ appendLog = $ this -> cfg [ 'collect' ] ; } if ( $ appendLog && $ value !== \ bdk \ Debug \ Abstracter :: UNDEFINED ) { $ this -> appendLog ( 'groupEndValue' , array ( 'return' , $ value ) , $ meta ) ; } if ( $ this -> data [ 'groupPriorityStack' ] && ! $ groupStackWas ) { $ priorityClosing = \ array_pop ( $ this -> data [ 'groupPriorityStack' ] ) ; unset ( $ this -> data [ 'groupStacks' ] [ $ priorityClosing ] ) ; $ this -> setLogDest ( 'auto' ) ; $ meta [ 'closesSummary' ] = true ; $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ; } elseif ( $ appendLog ) { $ this -> appendLog ( 'groupEnd' , array ( ) , $ meta ) ; } $ errorCaller = $ this -> errorHandler -> get ( 'errorCaller' ) ; if ( $ errorCaller && isset ( $ errorCaller [ 'groupDepth' ] ) && $ this -> getGroupDepth ( ) < $ errorCaller [ 'groupDepth' ] ) { $ this -> errorHandler -> setErrorCaller ( false ) ; } }
5219	public static function castFrom ( $ predicate ) { if ( $ predicate instanceof self ) { return $ predicate ; } elseif ( is_callable ( $ predicate ) ) { return new CallablePredicate ( $ predicate ) ; } throw new \ InvalidArgumentException ( 'Given predicate is neither a callable nor an instance of ' . __CLASS__ ) ; }
2376	public static function sanitizeFileName ( $ strName ) { $ strName = preg_replace ( '/[\pC]/u' , '' , $ strName ) ; if ( $ strName === null ) { throw new \ InvalidArgumentException ( 'The file name could not be sanitzied' ) ; } $ strName = str_replace ( array ( '\\' , '/' , ':' , '*' , '?' , '"' , '<' , '>' , '|' ) , '-' , $ strName ) ; return $ strName ; }
11245	public function getRan ( ) : array { $ stmt = $ this -> pdo -> query ( "select migration from {$this->table} order by batch, migration" ) ; $ stmt -> execute ( ) ; $ results = $ stmt -> fetchAll ( PDO :: FETCH_COLUMN ) ; return $ results ; }
3287	public function plugin ( $ name , array $ options = null ) { $ helper = $ this -> getTwigHelpers ( ) -> setRenderer ( $ this ) ; if ( $ helper -> has ( $ name ) ) { return $ helper -> get ( $ name , $ options ) ; } return $ this -> getHelperPluginManager ( ) -> get ( $ name , $ options ) ; }
6336	public function overlay ( $ title , $ message , $ level = 'info' , $ key = 'flash_message' ) { return $ this -> create ( $ title , $ message , $ level , $ key . '_overlay' ) ; }
11112	public function getMigrationFiles ( string $ type ) : array { $ array = [ ] ; foreach ( $ this -> filesystem -> listContents ( ) as $ file ) { if ( $ type === pathinfo ( $ file [ 'filename' ] , PATHINFO_EXTENSION ) ) { $ array [ ] = $ file ; } } return $ array ; }
10131	private function writeObjectProtect ( ) { if ( ! $ this -> phpSheet -> getProtection ( ) -> getSheet ( ) ) { return ; } if ( ! $ this -> phpSheet -> getProtection ( ) -> getObjects ( ) ) { return ; } $ record = 0x0063 ; $ length = 0x0002 ; $ header = pack ( 'vv' , $ record , $ length ) ; $ data = pack ( 'v' , 1 ) ; $ this -> append ( $ header . $ data ) ; }
10432	protected function createServices ( ContainerBuilder $ container , $ classes , $ config , $ tag , $ method ) { if ( ! is_array ( $ tag ) ) { $ tag = [ $ tag ] ; } foreach ( $ classes as $ class ) { $ methods = $ this -> getMethods ( $ class ) ; $ definition = new Definition ( $ class ) ; $ this -> setProperties ( $ definition , $ config , $ methods ) ; $ this -> setTags ( $ definition , $ tag , $ method ) ; $ container -> setDefinition ( $ this -> getServiceName ( $ tag [ 0 ] ) , $ definition ) ; } }
11727	public function setTaxonomy_id ( $ value ) { if ( ! is_array ( $ value ) ) { $ value = [ $ value ] ; } foreach ( $ value as $ k => $ v ) { if ( is_object ( $ v ) ) { $ value [ $ k ] = $ v -> primaryKey ; } elseif ( is_array ( $ v ) ) { unset ( $ value [ $ k ] ) ; if ( isset ( $ v [ 'systemId' ] ) && isset ( $ v [ 'taxonomyType' ] ) ) { $ taxonomyType = Yii :: $ app -> collectors [ 'taxonomies' ] -> getOne ( $ v [ 'taxonomyType' ] ) ; if ( isset ( $ taxonomyType ) && ( $ taxonomy = $ taxonomyType -> getTaxonomy ( $ v [ 'systemId' ] ) ) ) { $ value [ $ k ] = $ taxonomy -> primaryKey ; } } } } $ this -> _taxonomy_id = $ value ; }
4382	public function onOutput ( Event $ event ) { $ this -> channelName = $ this -> debug -> getCfg ( 'channel' ) ; $ this -> data = $ this -> debug -> getData ( ) ; $ str = '' ; $ str .= $ this -> processAlerts ( ) ; $ str .= $ this -> processSummary ( ) ; $ str .= $ this -> processLog ( ) ; $ this -> data = array ( ) ; $ event [ 'return' ] .= $ str ; }
8203	protected function peekJob ( $ tube , $ state ) { $ peekMethod = 'peek' . ucfirst ( $ state ) ; try { return $ this -> getPheanstalk ( ) -> $ peekMethod ( $ tube ) ; } catch ( ServerException $ e ) { if ( $ this -> isNotFoundException ( $ e ) ) { return ; } throw $ e ; } }
5396	public function paintSkip ( $ message ) { parent :: paintSkip ( $ message ) ; print $ this -> getIndent ( 1 ) ; print '<' . $ this -> namespace . 'skip>' ; print $ this -> toParsedXml ( $ message ) ; print '</' . $ this -> namespace . "skip>\n" ; }
10805	protected function build ( ) { $ settings = $ this -> getSettings ( ) ; $ this -> beforeBuild ( ) ; $ configs = $ this -> getConfig ( ) ; $ result = [ $ this -> getType ( ) ] ; $ sp = $ settings [ 'seperator' ] ; $ in = $ settings [ 'indent' ] ; $ si = $ sp . $ in ; foreach ( $ configs as $ pos => $ part ) { if ( isset ( $ this -> before [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> before [ $ pos ] ) ; } $ built = call_user_func ( [ $ this , $ part [ 'func' ] ] ) ; if ( ! empty ( $ built ) ) { $ prefix = $ part [ 'prefix' ] . ( empty ( $ part [ 'prefix' ] ) ? ( $ part [ 'indent' ] ? $ in : '' ) : $ si ) ; $ result [ ] = $ prefix . join ( $ part [ 'join' ] . $ si , $ built ) ; } if ( isset ( $ this -> after [ $ pos ] ) ) { $ result [ ] = join ( $ sp , $ this -> after [ $ pos ] ) ; } } return join ( $ sp , $ result ) ; }
784	protected function validateCache ( $ lastModified , $ etag ) { if ( Yii :: $ app -> request -> headers -> has ( 'If-None-Match' ) ) { return $ etag !== null && in_array ( $ etag , Yii :: $ app -> request -> getETags ( ) , true ) ; } elseif ( Yii :: $ app -> request -> headers -> has ( 'If-Modified-Since' ) ) { return $ lastModified !== null && @ strtotime ( Yii :: $ app -> request -> headers -> get ( 'If-Modified-Since' ) ) >= $ lastModified ; } return false ; }
4641	private function buildCallback ( BuildInfo $ output ) { $ message = "" ; if ( $ output -> getError ( ) ) { $ this -> logger -> error ( sprintf ( "Error when creating job: %s\n" , $ output -> getError ( ) ) , array ( 'static' => false , 'static-id' => null ) ) ; return ; } if ( $ output -> getStream ( ) ) { $ message = $ output -> getStream ( ) ; } if ( $ output -> getStatus ( ) ) { $ message = $ output -> getStatus ( ) ; if ( $ output -> getProgress ( ) ) { $ message .= " " . $ output -> getProgress ( ) ; } } if ( ! $ output -> getId ( ) && ! preg_match ( '#\n#' , $ message ) ) { $ message .= "\n" ; } $ this -> logger -> debug ( $ message , array ( 'static' => $ output -> getId ( ) !== null , 'static-id' => $ output -> getId ( ) , ) ) ; }
10013	public function getSheetByName ( $ pName ) { $ worksheetCount = count ( $ this -> workSheetCollection ) ; for ( $ i = 0 ; $ i < $ worksheetCount ; ++ $ i ) { if ( $ this -> workSheetCollection [ $ i ] -> getTitle ( ) === $ pName ) { return $ this -> workSheetCollection [ $ i ] ; } } return null ; }
1654	public function getReverse ( ) : Polygon { $ reversed = new static ( ) ; foreach ( array_reverse ( $ this -> points ) as $ point ) { $ reversed -> addPoint ( $ point ) ; } return $ reversed ; }
5361	protected function createHeaderStatements ( Operation $ operation , $ queryParamVariable ) { $ headerVariable = new Expr \ Variable ( 'headers' ) ; $ headers = [ new Expr \ ArrayItem ( new Scalar \ String_ ( $ operation -> getHost ( ) ) , new Scalar \ String_ ( 'Host' ) ) , ] ; $ produces = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ produces && in_array ( "application/json" , $ produces ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Expr \ Array_ ( [ new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) ) , ] ) , new Scalar \ String_ ( 'Accept' ) ) ; } $ consumes = $ operation -> getOperation ( ) -> getProduces ( ) ; if ( $ operation -> getOperation ( ) -> getParameters ( ) && $ consumes ) { $ bodyParameters = array_filter ( $ operation -> getOperation ( ) -> getParameters ( ) , function ( $ parameter ) { return $ parameter instanceof BodyParameter ; } ) ; if ( count ( $ bodyParameters ) > 0 && in_array ( "application/json" , $ consumes ) ) { $ headers [ ] = new Expr \ ArrayItem ( new Scalar \ String_ ( "application/json" ) , new Scalar \ String_ ( 'Content-Type' ) ) ; } } return [ [ new Expr \ Assign ( $ headerVariable , new Expr \ FuncCall ( new Name ( 'array_merge' ) , [ new Arg ( new Expr \ Array_ ( $ headers ) ) , new Arg ( new Expr \ MethodCall ( $ queryParamVariable , 'buildHeaders' , [ new Arg ( new Expr \ Variable ( 'parameters' ) ) ] ) ) ] ) ) ] , $ headerVariable ] ; }
6280	public function nextkey ( ) { if ( $ this -> keyIterPos >= $ this -> keyIterStop ) { return false ; } $ keyLen = $ this -> readInt31 ( $ this -> keyIterPos ) ; $ dataLen = $ this -> readInt31 ( $ this -> keyIterPos + 4 ) ; $ key = $ this -> read ( $ this -> keyIterPos + 8 , $ keyLen ) ; $ this -> keyIterPos += 8 + $ keyLen + $ dataLen ; return $ key ; }
6105	public function getHost ( ) { if ( $ this -> host === null ) { $ this -> host = new Host ( $ this ) ; } return $ this -> host ; }
11607	public function actionProfile ( ) { $ model = $ this -> finder -> findProfileById ( \ Yii :: $ app -> user -> identity -> getId ( ) ) ; $ this -> performAjaxValidation ( $ model ) ; if ( $ model -> load ( \ Yii :: $ app -> request -> post ( ) ) && $ model -> save ( ) ) { \ Yii :: $ app -> getSession ( ) -> setFlash ( 'success' , \ Yii :: t ( 'user' , 'Your profile has been updated' ) ) ; return $ this -> refresh ( ) ; } return $ this -> render ( 'profile' , [ 'model' => $ model , ] ) ; }
4958	public function attach ( EventManagerInterface $ events , $ priority = 1 ) { $ callback = array ( $ this , 'injectXmlTemplate' ) ; $ this -> sharedListeners [ ] = $ events -> getSharedManager ( ) -> attach ( 'Zend\Stdlib\DispatchableInterface' , MvcEvent :: EVENT_DISPATCH , $ callback , - 96 ) ; $ this -> listeners [ ] = $ events -> attach ( MvcEvent :: EVENT_DISPATCH_ERROR , $ callback , - 96 ) ; $ this -> listeners [ ] = $ events -> attach ( MvcEvent :: EVENT_RENDER_ERROR , $ callback , - 96 ) ; }
8355	private function buildModel ( string $ modelName , array $ modelDefinition ) { $ mapping = Mapping :: get ( $ this -> mapping ) ; $ definition = $ this -> getDefinition ( ) ; $ database = GlobalDatabase :: get ( $ mapping [ 'config' ] [ 'database' ] ) ; $ tableName = null ; if ( isset ( $ modelDefinition [ 'name' ] ) === true ) { $ tableName = $ modelDefinition [ 'name' ] ; } else { $ tableName = Helper :: codifyName ( $ this -> mapping ) . '_' . Helper :: codifyName ( $ modelName ) ; } if ( isset ( $ modelDefinition [ 'fields' ] ) === false ) { throw new InvalidSchemaDefinition ( 'model "' . $ modelName . '" has no field' ) ; } $ statement = Mutation \ AddTable :: statement ( $ database , $ this -> getDefinition ( ) , $ this -> mapping , $ tableName , $ modelName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } if ( isset ( $ modelDefinition [ 'indexes' ] ) === true ) { foreach ( $ modelDefinition [ 'indexes' ] as $ indexName => $ indexDefinition ) { $ statement = Mutation \ AddIndex :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ indexName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } if ( isset ( $ modelDefinition [ 'uniques' ] ) === true ) { foreach ( $ modelDefinition [ 'uniques' ] as $ uniqueName => $ uniqueDefinition ) { $ statement = Mutation \ AddUnique :: statement ( $ database , $ modelName , $ tableName , $ modelDefinition , $ uniqueName ) ; if ( $ statement -> execute ( ) == false ) { throw new DatabaseError ( 'db/build : ' . print_r ( $ statement -> errorInfo ( ) , true ) ) ; } } } echo $ modelName . ' - Done' . PHP_EOL ; }
4137	protected function processHeaders ( $ headers ) { $ out = array ( ) ; $ headers = explode ( "\r\n" , trim ( $ headers ) ) ; foreach ( $ headers as $ header ) { if ( strpos ( $ header , ':' ) !== false ) { $ tmp = explode ( ':' , $ header ) ; $ out [ reset ( $ tmp ) ] = end ( $ tmp ) ; } else { if ( ! isset ( $ out [ 'http-code' ] ) ) { $ out [ 'http-code' ] = $ header ; } } } unset ( $ headers , $ header , $ tmp ) ; return $ out ; }
7981	public function getSessionFilesProperties ( $ sessId , $ fileId ) { return json_decode ( self :: getClient ( ) -> getPcaSessionFilesProperties ( $ this -> pp , $ this -> sn , $ sessId , $ fileId ) ) ; }
12071	private function getCfgParamsByRanks ( ) { $ asParams = 'pbhcp' ; $ asRank = 'pbhr' ; $ tblParams = $ this -> resource -> getTableName ( CfgParam :: ENTITY_NAME ) ; $ tblRank = $ this -> resource -> getTableName ( Rank :: ENTITY_NAME ) ; $ query = $ this -> conn -> select ( ) ; $ query -> from ( [ $ asParams => $ tblParams ] ) ; $ on = "$asParams." . CfgParam :: A_RANK_ID . "=$asRank." . Rank :: A_ID ; $ cols = [ Rank :: A_CODE ] ; $ query -> joinLeft ( [ $ asRank => $ tblRank ] , $ on , $ cols ) ; $ entries = $ this -> conn -> fetchAll ( $ query ) ; $ result = [ ] ; foreach ( $ entries as $ entry ) { $ rankCode = $ entry [ Rank :: A_CODE ] ; $ rankScheme = $ entry [ CfgParam :: A_SCHEME ] ; $ result [ $ rankCode ] [ $ rankScheme ] = $ entry ; } return $ result ; }
6748	public function handle ( ServerRequestInterface $ request ) { list ( $ httpResponse , $ _ ) = $ this -> requestHandler -> handleServerRequest ( $ request ) ; return $ httpResponse ; }
12105	public function exception ( Exception $ exception ) { if ( $ this -> stopPropagation ) { return false ; } $ this -> fireHandlers ( $ exception ) ; $ this -> stopPropagation = true ; return false ; }
4759	protected function transformTemplate ( Template $ template ) { return array ( 'template' => $ template -> getTemplate ( ) , 'engine' => $ template -> getEngine ( ) , 'vars' => $ this -> transform ( $ template -> getVars ( ) ) , 'streamable' => $ this -> transformBoolean ( $ template -> isStreamable ( ) ) , ) ; }
8581	public function setPrepInstruction ( $ value ) { if ( ! $ this -> _isNumericArray ( $ value ) ) { $ value = array ( $ value ) ; } $ this -> _fields [ 'PrepInstruction' ] [ 'FieldValue' ] = $ value ; return $ this ; }
3596	protected function createTables ( ) { $ tablesCreated = false ; $ tableSchema = Craft :: $ app -> db -> schema -> getTableSchema ( '{{%dolphiq_sitemap_entries}}' ) ; if ( $ tableSchema === null ) { $ tablesCreated = true ; $ this -> createTable ( '{{%dolphiq_sitemap_entries}}' , [ 'id' => $ this -> primaryKey ( ) , 'dateCreated' => $ this -> dateTime ( ) -> notNull ( ) , 'dateUpdated' => $ this -> dateTime ( ) -> notNull ( ) , 'uid' => $ this -> uid ( ) , 'linkId' => $ this -> integer ( ) -> notNull ( ) , 'type' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , 'priority' => $ this -> double ( 2 ) -> notNull ( ) -> defaultValue ( 0.5 ) , 'changefreq' => $ this -> string ( 30 ) -> notNull ( ) -> defaultValue ( '' ) , ] ) ; } return $ tablesCreated ; }
2490	protected function processConnectionConfiguration ( ContainerBuilder $ container , array $ config ) { $ alias = $ this -> getAlias ( ) ; if ( isset ( $ config [ 'default_connection' ] ) ) { $ container -> setParameter ( "{$alias}.default_connection" , $ config [ 'default_connection' ] ) ; } elseif ( ! empty ( $ config [ 'connections' ] ) ) { reset ( $ config [ 'connections' ] ) ; $ container -> setParameter ( "{$alias}.default_connection" , key ( $ config [ 'connections' ] ) ) ; } foreach ( $ config [ 'connections' ] as $ name => $ params ) { $ this -> configureSearchServices ( $ container , $ name , $ params ) ; $ this -> configureBoostMap ( $ container , $ name , $ params ) ; $ this -> configureIndexingDepth ( $ container , $ name , $ params ) ; $ container -> setParameter ( "$alias.connection.$name" , $ params ) ; } foreach ( $ config [ 'endpoints' ] as $ name => $ params ) { $ this -> defineEndpoint ( $ container , $ name , $ params ) ; } $ searchEngineDef = $ container -> findDefinition ( self :: ENGINE_ID ) ; $ searchEngineDef -> setFactory ( [ new Reference ( 'ezpublish.solr.engine_factory' ) , 'buildEngine' ] ) ; $ boostFactorProviderDef = $ container -> findDefinition ( self :: BOOST_FACTOR_PROVIDER_ID ) ; $ boostFactorProviderDef -> setFactory ( [ new Reference ( 'ezpublish.solr.boost_factor_provider_factory' ) , 'buildService' ] ) ; }
12001	static protected function doctrine2Query ( \ Doctrine \ ORM \ EntityManager $ entityManager , $ entityName , $ field , $ generate ) { $ result = $ entityManager -> createQueryBuilder ( ) -> select ( "entity.$field" ) -> from ( $ entityName , 'entity' ) -> where ( "entity.$field = :$field" ) -> setParameter ( "$field" , $ generate ) -> getQuery ( ) -> getResult ( ) ; return ! empty ( $ result ) ; }
4089	protected function buildUrl ( $ path = false , array $ options = array ( ) ) { $ isAbsolute = ( is_array ( $ path ) ? $ path [ 0 ] [ 0 ] : $ path [ 0 ] ) === '/' ; $ url = $ isAbsolute || null === $ this -> index ? '' : "/" . $ this -> index ; if ( $ path && is_array ( $ path ) && count ( $ path ) > 0 ) $ url .= "/" . implode ( "/" , array_filter ( $ path ) ) ; if ( substr ( $ url , - 1 ) == "/" ) $ url = substr ( $ url , 0 , - 1 ) ; if ( count ( $ options ) > 0 ) $ url .= "?" . http_build_query ( $ options , '' , '&' ) ; return $ url ; }
4526	protected function createZoneMemberZoneFromDefinition ( array $ definition ) { $ zone = $ this -> get ( $ definition [ 'zone' ] ) ; $ zoneMember = new ZoneMemberZone ( ) ; $ zoneMember -> setZone ( $ zone ) ; $ setValues = \ Closure :: bind ( function ( $ definition ) { $ this -> id = $ definition [ 'id' ] ; } , $ zoneMember , '\CommerceGuys\Zone\Model\ZoneMemberZone' ) ; $ setValues ( $ definition ) ; return $ zoneMember ; }
3422	public function count ( ) { if ( $ this -> queryShouldBeStopped ) { return 0 ; } $ queryType = 'UserQuery::count' ; $ filter = $ this -> normalizeFilter ( ) ; $ callback = function ( ) use ( $ filter ) { return ( int ) $ this -> bxObject -> getList ( $ order = 'ID' , $ by = 'ASC' , $ filter , [ 'NAV_PARAMS' => [ 'nTopCount' => 0 , ] , ] ) -> NavRecordCount ; } ; return $ this -> handleCacheIfNeeded ( compact ( 'queryType' , 'filter' ) , $ callback ) ; }
3971	public function getAttributeOptions ( GetPropertyOptionsEvent $ event ) { if ( ! $ this -> wantToHandle ( $ event ) ) { return ; } $ result = [ ] ; $ metaModel = $ this -> getMetaModel ( $ event -> getEnvironment ( ) ) ; $ conditionType = $ event -> getModel ( ) -> getProperty ( 'type' ) ; foreach ( $ metaModel -> getAttributes ( ) as $ attribute ) { if ( ! $ this -> conditionFactory -> supportsAttribute ( $ conditionType , $ attribute -> get ( 'type' ) ) ) { continue ; } $ typeName = $ attribute -> get ( 'type' ) ; $ strSelectVal = $ metaModel -> getTableName ( ) . '_' . $ attribute -> getColName ( ) ; $ result [ $ strSelectVal ] = $ attribute -> getName ( ) . ' [' . $ typeName . ']' ; } $ event -> setOptions ( $ result ) ; }
3808	protected function translateProperty ( $ property , $ metaModel , $ legend ) { $ attribute = $ metaModel -> getAttributeById ( $ property [ 'attr_id' ] ) ; if ( ! $ attribute ) { return false ; } $ propName = $ attribute -> getColName ( ) ; $ this -> legends [ $ legend ] [ 'properties' ] [ ] = $ propName ; $ this -> properties [ $ propName ] = array ( 'info' => $ attribute -> getFieldDefinition ( $ property ) , ) ; return true ; }
9815	public function setWorksheet ( Worksheet $ value = null ) { if ( $ value !== null ) { $ this -> worksheet = $ value ; } return $ this ; }
6707	public function afterFind ( $ event ) { if ( is_array ( $ this -> fields ) ) { foreach ( $ this -> fields as $ field ) { if ( $ event -> sender -> { $ field } ) { $ event -> sender -> { $ field } = explode ( ';' , $ event -> sender -> { $ field } ) ; } } } }
11471	public function edit ( ResponseRequest $ request , Response $ response ) { return $ this -> response -> title ( trans ( 'app.edit' ) . ' ' . trans ( 'forum::response.name' ) ) -> view ( 'forum::response.edit' , true ) -> data ( compact ( 'response' ) ) -> output ( ) ; }
6747	public function bootstrap ( $ appBootstrap , $ appenv , $ debug ) { $ bootstrap = ( new $ appBootstrap ( ) ) ; $ bootstrap -> initialize ( $ appenv , $ debug ) ; $ kernel = $ bootstrap -> getApplication ( ) ; $ this -> requestHandler = new RequestHandler ( $ kernel ) ; }
821	private function splitUpDocBlock ( $ lines , Tokens $ tokens , $ docBlockIndex ) { $ lineContent = $ this -> getSingleLineDocBlockEntry ( $ lines ) ; $ lineEnd = $ this -> whitespacesConfig -> getLineEnding ( ) ; $ originalIndent = $ this -> detectIndent ( $ tokens , $ tokens -> getNextNonWhitespace ( $ docBlockIndex ) ) ; return [ new Line ( '/**' . $ lineEnd ) , new Line ( $ originalIndent . ' * ' . $ lineContent . $ lineEnd ) , new Line ( $ originalIndent . ' */' ) , ] ; }
8924	public function merge ( $ patchDocument1 , $ patchDocument2 ) { if ( $ patchDocument1 === null || $ patchDocument2 === null || ! is_object ( $ patchDocument1 ) || ! is_object ( $ patchDocument2 ) ) { return $ patchDocument2 ; } $ patchDocument = $ patchDocument1 ; $ patchDocument1Vars = get_object_vars ( $ patchDocument1 ) ; $ patchDocument2Vars = get_object_vars ( $ patchDocument2 ) ; foreach ( $ patchDocument2Vars as $ var => $ value ) { if ( isset ( $ patchDocument1Vars [ $ var ] ) ) { $ patchDocument -> $ var = $ this -> merge ( $ patchDocument1 -> $ var , $ patchDocument2 -> $ var ) ; } else { $ patchDocument -> $ var = $ patchDocument2 -> $ var ; } } return $ patchDocument ; }
4626	private function createIndexQueryPath ( Bucket $ bucket ) { $ command = $ this -> command ; if ( $ command -> isMatchQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getMatchValue ( ) ) ; } elseif ( $ command -> isRangeQuery ( ) ) { $ path = sprintf ( '/types/%s/buckets/%s/index/%s/%s/%s' , $ bucket -> getType ( ) , $ bucket -> getName ( ) , $ command -> getIndexName ( ) , $ command -> getLowerBound ( ) , $ command -> getUpperBound ( ) ) ; } else { throw new Api \ Exception ( "Invalid Secondary Index Query." ) ; } return $ path ; }
229	public function getPdoType ( $ data ) { static $ typeMap = [ 'boolean' => \ PDO :: PARAM_BOOL , 'integer' => \ PDO :: PARAM_INT , 'string' => \ PDO :: PARAM_STR , 'resource' => \ PDO :: PARAM_LOB , 'NULL' => \ PDO :: PARAM_NULL , ] ; $ type = gettype ( $ data ) ; return isset ( $ typeMap [ $ type ] ) ? $ typeMap [ $ type ] : \ PDO :: PARAM_STR ; }
886	private function clear ( Tokens $ tokens , $ index ) { while ( ! $ tokens [ ++ $ index ] -> equals ( ';' ) ) { if ( $ this -> shouldClearToken ( $ tokens , $ index ) ) { $ tokens -> clearAt ( $ index ) ; } } }
343	protected function renderSortLinks ( ) { $ attributes = empty ( $ this -> attributes ) ? array_keys ( $ this -> sort -> attributes ) : $ this -> attributes ; $ links = [ ] ; foreach ( $ attributes as $ name ) { $ links [ ] = $ this -> sort -> link ( $ name , $ this -> linkOptions ) ; } return Html :: ul ( $ links , array_merge ( $ this -> options , [ 'encode' => false ] ) ) ; }
12086	public function save ( ) { $ this -> checkPermission ( "special" , "/admin" ) ; $ referer = $ this -> application -> input -> getReferer ( ) ; if ( ! $ this -> application -> input -> methodIs ( "post" ) ) { $ this -> response -> addAlert ( "No configuration data recieved" , 'error' ) ; } else { if ( ( $ data = $ this -> application -> input -> getArray ( "options" , array ( ) , "post" ) ) == FALSE ) { $ this -> response -> addAlert ( "No input data recieved, Something went wrong" , 'error' ) ; } else { $ namespace = $ this -> application -> input -> getString ( "options_namespace" , "" , "post" ) ; $ this -> application -> config -> mergeParams ( $ namespace , $ data ) ; if ( ! $ this -> application -> config -> saveParams ( ) ) { $ this -> response -> addAlert ( 'Something went wrong, Did not save the parameters' , 'error' ) ; } else { $ this -> response -> addAlert ( "Your configuration settings have now been saved" , "success" ) ; } } } $ this -> application -> dispatcher -> redirect ( $ referer , HTTP_FOUND , null , $ this -> response -> getAlerts ( ) ) ; return true ; }
8910	private function getCallableFunction ( $ method ) { if ( is_callable ( $ method ) ) { return $ method ; } if ( is_string ( $ method ) && is_callable ( array ( $ this , $ method ) ) ) { return array ( $ this , $ method ) ; } return FALSE ; }
2651	public function activateVersion ( $ version ) { $ url = $ this -> _getApiServiceUri ( ) . 'version/' . $ version . '/activate' ; $ result = $ this -> _fetch ( $ url , 'PUT' ) ; return $ result ; }
4428	protected function getQuestion ( $ questionName , $ defaultValue = null , $ validator = null ) { $ questionName = $ defaultValue ? '<info>' . $ questionName . '</info> [<comment>' . $ defaultValue . '</comment>]: ' : '<info>' . $ questionName . '</info>: ' ; $ question = new Question ( $ questionName , $ defaultValue ) ; if ( $ validator !== null ) { $ question -> setValidator ( $ validator ) ; } return $ question ; }
4329	public static function requestId ( ) { return \ hash ( 'crc32b' , ( isset ( $ _SERVER [ 'REMOTE_ADDR' ] ) ? $ _SERVER [ 'REMOTE_ADDR' ] : 'terminal' ) . ( isset ( $ _SERVER [ 'REQUEST_TIME_FLOAT' ] ) ? $ _SERVER [ 'REQUEST_TIME_FLOAT' ] : $ _SERVER [ 'REQUEST_TIME' ] ) . ( isset ( $ _SERVER [ 'REMOTE_PORT' ] ) ? $ _SERVER [ 'REMOTE_PORT' ] : '' ) ) ; }
7295	public function send_mail ( $ to , $ subject = '' , $ message = '' , $ headers = array ( ) , $ attachments = array ( ) ) { if ( $ this -> options [ 'static_options' ] [ 'mail_to_chunking' ] [ 'chunking' ] === TRUE ) { $ send_next_group = array ( ) ; if ( array_key_exists ( 'send_next_group' , $ this -> options [ 'static_options' ] ) ) { $ object_id = $ this -> options [ 'static_options' ] [ 'object' ] [ 'id' ] ; $ send_next_group = $ this -> options [ 'static_options' ] [ 'send_next_group' ] [ $ object_id ] ; } if ( $ this -> options [ 'send_by_bcc' ] ) { $ headers [ 'Bcc' ] = $ this -> get_mail_to_chunk ( $ headers [ 'Bcc' ] , $ send_next_group ) ; } else { $ to = $ this -> get_mail_to_chunk ( $ to , $ send_next_group ) ; } } foreach ( $ headers as $ k => $ v ) { $ headers [ ] = $ k . ': ' . $ v ; unset ( $ headers [ $ k ] ) ; } return wp_mail ( $ to , $ subject , $ message , $ headers , $ attachments ) ; }
9753	public static function sysGetTempDir ( ) { if ( self :: $ useUploadTempDirectory ) { if ( ini_get ( 'upload_tmp_dir' ) !== false ) { if ( $ temp = ini_get ( 'upload_tmp_dir' ) ) { if ( file_exists ( $ temp ) ) { return realpath ( $ temp ) ; } } } } return realpath ( sys_get_temp_dir ( ) ) ; }
1288	private function buildContentTypeCollection ( array $ data ) { $ items = \ array_merge ( $ data [ 'items' ] , $ data [ 'includes' ] [ 'Entry' ] ?? [ ] ) ; $ ids = \ array_map ( function ( array $ item ) { return 'Entry' === $ item [ 'sys' ] [ 'type' ] ? $ item [ 'sys' ] [ 'contentType' ] [ 'sys' ] [ 'id' ] : null ; } , $ items ) ; $ ids = \ array_filter ( \ array_unique ( $ ids ) , function ( $ id ) : bool { return $ id && ! $ this -> resourcePool -> has ( 'ContentType' , $ id ) ; } ) ; if ( $ ids ) { $ query = ( new Query ( ) ) -> where ( 'sys.id[in]' , \ implode ( ',' , $ ids ) ) ; $ this -> client -> getContentTypes ( $ query ) ; } }
359	function checkUploadMaxFileSize ( $ min = null , $ max = null ) { $ postMaxSize = ini_get ( 'post_max_size' ) ; $ uploadMaxFileSize = ini_get ( 'upload_max_filesize' ) ; if ( $ min !== null ) { $ minCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ min , '>=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ min , '>=' ) ; } else { $ minCheckResult = true ; } if ( $ max !== null ) { $ maxCheckResult = $ this -> compareByteSize ( $ postMaxSize , $ max , '<=' ) && $ this -> compareByteSize ( $ uploadMaxFileSize , $ max , '<=' ) ; } else { $ maxCheckResult = true ; } return ( $ minCheckResult && $ maxCheckResult ) ; }
2778	public function cloneRepository ( string $ repository , ? string $ directory = null , array $ options = [ ] ) : GitWorkingCopy { if ( $ directory === null ) { $ directory = self :: parseRepositoryName ( $ repository ) ; } $ git = $ this -> workingCopy ( $ directory ) ; $ git -> cloneRepository ( $ repository , $ options ) ; $ git -> setCloned ( true ) ; return $ git ; }
4928	public function setListener ( $ event , $ service , $ method = null , $ priority = 0 ) { if ( is_int ( $ method ) ) { $ priority = $ method ; $ method = null ; } $ name = uniqid ( ) ; $ this -> listenerSpecs [ $ name ] = [ 'event' => $ event , 'service' => $ service , 'method' => $ method , 'priority' => $ priority , 'instance' => null , ] ; return $ this ; }
10460	public static function create ( $ type ) { switch ( $ type ) { case ActionTypes :: CREATE : return new CreateDiffItem ( ) ; case ActionTypes :: UPDATE : return new UpdateDiffItem ( ) ; case ActionTypes :: DELETE : return new DeleteDiffItem ( ) ; default : throw new \ InvalidArgumentException ( "Invalid type {$type}" ) ; } }
2249	public static function redirect ( $ strLocation , $ intStatus = 303 ) { $ strLocation = str_replace ( '&amp;' , '&' , $ strLocation ) ; $ strLocation = static :: replaceOldBePaths ( $ strLocation ) ; if ( ! preg_match ( '@^https?://@i' , $ strLocation ) ) { $ strLocation = Environment :: get ( 'base' ) . ltrim ( $ strLocation , '/' ) ; } if ( Environment :: get ( 'isAjaxRequest' ) ) { throw new AjaxRedirectResponseException ( $ strLocation ) ; } throw new RedirectResponseException ( $ strLocation , $ intStatus ) ; }
6542	public function current ( ) { if ( true === $ this -> wantNewModel ) { return $ this -> entityManager -> load ( $ this -> modelClassName , $ this -> selector -> current ( ) ) ; } else { $ this -> initializeModel ( $ this -> selector -> current ( ) , $ this -> selector -> currentShardingKey ( ) ) ; $ this -> entityManager -> resetModel ( $ this -> model , $ this -> selector -> current ( ) ) ; return $ this -> model ; } }
6832	protected function getSupplierOrderItemFromEvent ( ResourceEventInterface $ event ) { $ item = $ event -> getResource ( ) ; if ( ! $ item instanceof SupplierOrderItemInterface ) { throw new InvalidArgumentException ( "Expected instance of SupplierOrderItemInterface." ) ; } return $ item ; }
12356	public function generate ( ) { if ( ! $ this -> configurationHandler -> isTheme ( ) || $ this -> theme -> getName ( ) != $ this -> configurationHandler -> handledTheme ( ) ) { return ; } $ templates = array_keys ( $ this -> templates [ "template" ] ) ; $ homepage = json_decode ( file_get_contents ( $ this -> configurationHandler -> pagesDir ( ) . '/' . $ this -> configurationHandler -> homepage ( ) . '/page.json' ) , true ) ; $ homepageTemplate = $ homepage [ "template" ] ; if ( ! in_array ( $ homepageTemplate , $ templates ) ) { $ homepageTemplate = $ templates [ 0 ] ; } $ themeDefinition = array ( "home_template" => $ homepageTemplate , "templates" => $ templates , ) ; $ this -> synchronizeThemeSlots ( ) ; FilesystemTools :: writeFile ( $ this -> themeDir . '/theme.json' , json_encode ( $ themeDefinition ) ) ; }
6743	public function supports ( ParamConverter $ configuration ) { return $ configuration -> getClass ( ) && is_a ( $ configuration -> getClass ( ) , $ this -> getClass ( ) , true ) ; }
3625	public function getDevices ( $ type = DEVICE_TYPE_THERMOSTAT ) { $ this -> prepareForGet ( ) ; if ( $ type == DEVICE_TYPE_PROTECT ) { $ protects = array ( ) ; $ topaz = isset ( $ this -> last_status -> topaz ) ? $ this -> last_status -> topaz : array ( ) ; foreach ( $ topaz as $ protect ) { $ protects [ ] = $ protect -> serial_number ; } return $ protects ; } $ devices_serials = array ( ) ; foreach ( $ this -> last_status -> user -> { $ this -> userid } -> structures as $ structure ) { list ( , $ structure_id ) = explode ( '.' , $ structure ) ; foreach ( $ this -> last_status -> structure -> { $ structure_id } -> devices as $ device ) { list ( , $ device_serial ) = explode ( '.' , $ device ) ; $ devices_serials [ ] = $ device_serial ; } } return $ devices_serials ; }
10690	public static function handleException ( \ Throwable $ e ) { $ app = self :: getInstance ( ) ; if ( $ app -> request === null ) $ app -> request = Request :: createFromGlobals ( ) ; $ req = $ app -> request ; try { if ( ! Request :: cli ( ) ) { $ mgr = $ app -> resolver ; $ res = $ mgr -> getResolver ( 'template' ) ; $ assets = $ mgr -> getResolver ( 'assets' ) ; $ amgr = new AssetManager ( $ assets ) ; $ tpl = new Template ( $ res , $ amgr , $ req ) ; $ tpl -> setExceptionTemplate ( $ e ) ; $ tpl -> assign ( 'exception' , $ e ) ; $ tpl -> assign ( 'request' , $ req ) ; $ tpl -> assign ( 'dev' , $ app -> dev ) ; $ app -> i18n ; $ response = $ tpl -> renderReturn ( ) ; $ responder = new \ Wedeto \ HTTP \ Responder ( ) ; $ result = new \ Wedeto \ HTTP \ Result ( ) ; $ result -> setResponse ( $ response ) ; $ responder -> setRequest ( $ req ) ; $ responder -> setResult ( $ result ) ; $ params = new Dictionary ( [ 'responder' => $ responder , 'mime' => 'text/html' ] ) ; $ amgr -> executeHook ( $ params ) ; $ responder -> respond ( ) ; } } catch ( \ Throwable $ e2 ) { echo "<h1>Error while showing error template:</h1>\n\n" ; echo "<pre>" . WF :: html ( $ e2 ) . "</pre>\n" ; } if ( Request :: cli ( ) ) { fprintf ( STDERR , \ Wedeto \ Application \ CLI \ ANSI :: bright ( "An uncaught exception has occurred:" ) . "\n\n" ) ; WF :: debug ( WF :: str ( $ e ) ) ; } else { echo "<h2>Original error:</h2>\n\n" ; echo "<pre>" . WF :: html ( $ e ) . "</pre>\n" ; } }
9988	public function generateHTMLHeader ( $ pIncludeStyles = false ) { if ( $ this -> spreadsheet === null ) { throw new WriterException ( 'Internal Spreadsheet object not set to an instance of an object.' ) ; } $ properties = $ this -> spreadsheet -> getProperties ( ) ; $ html = '<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' . PHP_EOL ; $ html .= '<html>' . PHP_EOL ; $ html .= ' <head>' . PHP_EOL ; $ html .= ' <meta http-equiv="Content-Type" content="text/html; charset=utf-8">' . PHP_EOL ; $ html .= ' <meta name="generator" content="PhpSpreadsheet, https://github.com/PHPOffice/PhpSpreadsheet">' . PHP_EOL ; if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <title>' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '</title>' . PHP_EOL ; } if ( $ properties -> getCreator ( ) > '' ) { $ html .= ' <meta name="author" content="' . htmlspecialchars ( $ properties -> getCreator ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getTitle ( ) > '' ) { $ html .= ' <meta name="title" content="' . htmlspecialchars ( $ properties -> getTitle ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getDescription ( ) > '' ) { $ html .= ' <meta name="description" content="' . htmlspecialchars ( $ properties -> getDescription ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getSubject ( ) > '' ) { $ html .= ' <meta name="subject" content="' . htmlspecialchars ( $ properties -> getSubject ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getKeywords ( ) > '' ) { $ html .= ' <meta name="keywords" content="' . htmlspecialchars ( $ properties -> getKeywords ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCategory ( ) > '' ) { $ html .= ' <meta name="category" content="' . htmlspecialchars ( $ properties -> getCategory ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getCompany ( ) > '' ) { $ html .= ' <meta name="company" content="' . htmlspecialchars ( $ properties -> getCompany ( ) ) . '" />' . PHP_EOL ; } if ( $ properties -> getManager ( ) > '' ) { $ html .= ' <meta name="manager" content="' . htmlspecialchars ( $ properties -> getManager ( ) ) . '" />' . PHP_EOL ; } if ( $ pIncludeStyles ) { $ html .= $ this -> generateStyles ( true ) ; } $ html .= ' </head>' . PHP_EOL ; $ html .= '' . PHP_EOL ; $ html .= ' <body>' . PHP_EOL ; return $ html ; }
176	public static function removeValue ( & $ array , $ value ) { $ result = [ ] ; if ( is_array ( $ array ) ) { foreach ( $ array as $ key => $ val ) { if ( $ val === $ value ) { $ result [ $ key ] = $ val ; unset ( $ array [ $ key ] ) ; } } } return $ result ; }
3166	public function getCurrentAssessmentSession ( RunnerServiceContext $ context ) { if ( $ context -> isAdaptive ( ) ) { return new AssessmentItemSession ( $ context -> getCurrentAssessmentItemRef ( ) , new SessionManager ( ) ) ; } else { return $ context -> getTestSession ( ) ; } }
5371	public function attach ( $ key , $ content , $ filename ) { $ this -> request [ ] = new SimpleAttachment ( $ key , $ content , $ filename ) ; }
3346	public function request ( $ method , $ path , $ data = array ( ) , $ headers = array ( ) ) { $ ch = curl_init ( sprintf ( 'https://%s%s' , $ this -> api_host , $ path ) ) ; $ this -> __setRequestType ( $ ch , $ method ) ; $ this -> __setHeaders ( $ ch , $ headers , $ data ) ; $ response = curl_exec ( $ ch ) ; if ( $ response === false ) { throw new \ Exception ( curl_error ( $ ch ) ) ; } $ ch_info = curl_getinfo ( $ ch ) ; $ header_size = curl_getinfo ( $ ch , CURLINFO_HEADER_SIZE ) ; $ header = substr ( $ response , 0 , $ header_size ) ; $ body = substr ( $ response , $ header_size ) ; $ error = false ; if ( $ method == 'DELETE' ) { if ( $ ch_info [ 'http_code' ] != 302 && $ ch_info [ 'http_code' ] != 200 ) { $ error = true ; } } else { if ( ! ( ( $ ch_info [ 'http_code' ] >= 200 ) && ( $ ch_info [ 'http_code' ] < 300 ) ) ) { $ error = true ; } } if ( $ ch_info [ 'http_code' ] == 429 ) { $ exception = new ThrottledRequestException ( ) ; $ response_headers = Helper :: parseHttpHeaders ( $ header ) ; $ exception -> setResponseHeaders ( $ response_headers ) ; throw $ exception ; } if ( $ error ) { $ errorInfo = array_filter ( array ( curl_error ( $ ch ) , $ body ) ) ; throw new \ Exception ( 'Request returned unexpected http code ' . $ ch_info [ 'http_code' ] . '. ' . join ( ', ' , $ errorInfo ) ) ; } curl_close ( $ ch ) ; if ( ! defined ( 'PHPUNIT_UPLOADCARE_TESTSUITE' ) && ( $ this -> public_key == 'demopublic_key' || $ this -> secret_key == 'demoprivatekey' ) ) { trigger_error ( 'You are using the demo account. Please get an Uploadcare account at https://uploadcare.com/accounts/create/' , E_USER_WARNING ) ; } return json_decode ( $ body ) ; }
968	protected function cancelCharge ( ) { $ planCharge = $ this -> shop -> planCharge ( ) ; if ( $ planCharge && ! $ planCharge -> isDeclined ( ) && ! $ planCharge -> isCancelled ( ) ) { $ planCharge -> cancel ( ) ; } }
5236	public function get ( $ name = null ) { $ constructor = $ this -> class -> getConstructor ( ) ; if ( null === $ constructor || $ this -> class -> isInternal ( ) ) { return $ this -> class -> newInstance ( ) ; } $ params = $ this -> injectionValuesForMethod ( $ constructor ) ; if ( count ( $ params ) === 0 ) { return $ this -> class -> newInstance ( ) ; } return $ this -> class -> newInstanceArgs ( $ params ) ; }
766	public function setIdentity ( $ identity ) { if ( $ identity instanceof IdentityInterface ) { $ this -> _identity = $ identity ; } elseif ( $ identity === null ) { $ this -> _identity = null ; } else { throw new InvalidValueException ( 'The identity object must implement IdentityInterface.' ) ; } $ this -> _access = [ ] ; }
8330	public function connect ( array $ params , $ username = null , $ password = null , array $ driverOptions = [ ] ) { if ( PlatformHelper :: isWindows ( ) ) { return $ this -> connectWindows ( $ params , $ username , $ password , $ driverOptions ) ; } return $ this -> connectUnix ( $ params , $ username , $ password , $ driverOptions ) ; }
4967	public function fromPost ( $ param = null , $ default = null ) { if ( $ param === null ) { return $ this -> event -> getRequest ( ) -> getPost ( $ param , $ default ) -> toArray ( ) ; } return $ this -> event -> getRequest ( ) -> getPost ( $ param , $ default ) ; }
6735	public function getMiddleware ( $ name ) : Middleware { if ( ! array_key_exists ( $ name , $ this -> namedMiddleware ) ) { throw new \ UnexpectedValueException ( "No middleware registered under name '{$name}'" ) ; } return $ this -> namedMiddleware [ $ name ] ; }
2601	public function getLiteral ( $ token ) { $ className = get_class ( $ this ) ; $ reflClass = new \ ReflectionClass ( $ className ) ; $ constants = $ reflClass -> getConstants ( ) ; foreach ( $ constants as $ name => $ value ) { if ( $ value === $ token ) { return $ className . '::' . $ name ; } } return $ token ; }
3473	public function set ( string $ key , $ value ) : void { $ key = explode ( '.' , $ key ) ; $ last = array_pop ( $ key ) ; $ result = & $ this -> config ; foreach ( $ key as $ part ) { if ( ! isset ( $ result [ $ part ] ) || ! is_array ( $ result [ $ part ] ) ) { $ result [ $ part ] = [ ] ; } $ result = & $ result [ $ part ] ; } $ result [ $ last ] = $ value ; }
12765	public function addByHttpCode ( int $ code ) : self { $ serverProtocol = filter_input ( \ INPUT_SERVER , 'SERVER_PROTOCOL' , \ FILTER_SANITIZE_STRING ) ; $ protocol = ! empty ( $ serverProtocol ) ? $ serverProtocol : 'HTTP/1.1' ; $ sHeader = "{$protocol} {$code} " . self :: getHTTPExplanationByCode ( $ code ) ; return $ this -> add ( $ sHeader ) ; }
12308	public function showAction ( Request $ request , Application $ app ) { $ options = $ this -> options ( $ request , $ app ) ; return parent :: show ( $ options ) ; }
3179	public function getQtiItems ( \ core_kernel_classes_Class $ itemClass , $ format = 'list' , $ search = '' , $ offset = 0 , $ limit = 30 ) { $ propertyFilters = [ ] ; if ( $ this -> hasOption ( self :: ITEM_MODEL_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_MODEL_URI ] = $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) ; } if ( $ this -> hasOption ( self :: ITEM_CONTENT_SEARCH_OPTION ) && $ this -> getOption ( self :: ITEM_MODEL_SEARCH_OPTION ) !== false ) { $ propertyFilters [ self :: PROPERTY_ITEM_CONTENT_URI ] = '*' ; } if ( is_string ( $ search ) && strlen ( trim ( $ search ) ) > 0 ) { $ propertyFilters [ self :: LABEL_URI ] = $ search ; } if ( is_array ( $ search ) ) { foreach ( $ search as $ uri => $ value ) { if ( is_string ( $ uri ) && ( is_string ( $ value ) && strlen ( trim ( $ value ) ) > 0 ) || ( is_array ( $ value ) && count ( $ value ) > 0 ) ) { $ propertyFilters [ $ uri ] = $ value ; } } } $ result = [ ] ; if ( in_array ( $ format , self :: $ formats ) ) { $ itemLookup = $ this -> getServiceLocator ( ) -> get ( self :: SERVICE_ID . '/' . $ format ) ; if ( ! is_null ( $ itemLookup ) && $ itemLookup instanceof ItemLookup ) { $ result = $ itemLookup -> getItems ( $ itemClass , $ propertyFilters , $ offset , $ limit ) ; } } return $ result ; }
9220	protected function requestAllPages ( $ forceRefresh = false ) { $ _page = $ this -> page ; $ _key = $ this -> key ; $ nextPageNumber = false ; if ( isset ( $ this -> pagination [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> pagination [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } while ( $ nextPageNumber !== false ) { $ this -> requestPageNumber ( $ nextPageNumber , $ forceRefresh ) ; if ( isset ( $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] ) ) { $ nextPageNumber = $ this -> paginationPerPage [ $ nextPageNumber ] [ CanvasPageLink :: NEXT ] -> getPageNumber ( ) ; } else { $ nextPageNumber = false ; } } $ this -> page = $ _page ; $ this -> key = $ _key ; }
9870	private function writePageSetup ( XMLWriter $ objWriter , PhpspreadsheetWorksheet $ pSheet ) { $ objWriter -> startElement ( 'pageSetup' ) ; $ objWriter -> writeAttribute ( 'paperSize' , $ pSheet -> getPageSetup ( ) -> getPaperSize ( ) ) ; $ objWriter -> writeAttribute ( 'orientation' , $ pSheet -> getPageSetup ( ) -> getOrientation ( ) ) ; if ( $ pSheet -> getPageSetup ( ) -> getScale ( ) !== null ) { $ objWriter -> writeAttribute ( 'scale' , $ pSheet -> getPageSetup ( ) -> getScale ( ) ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToHeight' , $ pSheet -> getPageSetup ( ) -> getFitToHeight ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToHeight' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) !== null ) { $ objWriter -> writeAttribute ( 'fitToWidth' , $ pSheet -> getPageSetup ( ) -> getFitToWidth ( ) ) ; } else { $ objWriter -> writeAttribute ( 'fitToWidth' , '0' ) ; } if ( $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) !== null ) { $ objWriter -> writeAttribute ( 'firstPageNumber' , $ pSheet -> getPageSetup ( ) -> getFirstPageNumber ( ) ) ; $ objWriter -> writeAttribute ( 'useFirstPageNumber' , '1' ) ; } $ objWriter -> endElement ( ) ; }
10258	public function getCompanyName ( $ base_name = null ) { $ suffixes = [ 'Corporation' , 'Company' , 'Company, Limited' , 'Computer Repair' , 'Incorporated' , 'and Sons' , 'Group' , 'Group, PLC' , 'Furniture' , 'Flowers' , 'Sales' , 'Systems' , 'Tire' , 'Auto' , 'Plumbing' , 'Roofing' , 'Realty' , 'Foods' , 'Books' ] ; if ( empty ( $ base_name ) ) { $ base_name = $ this -> getLastName ( ) ; } return $ base_name . ' ' . $ this -> fromArray ( $ suffixes ) ; }
9021	public function getWordsByComplexity ( $ string ) { $ words = $ this -> getWords ( $ string ) ; $ analysis = new FrequencyAnalysis ( $ words ) ; $ sortedWords = $ analysis -> getKeyValuesByFrequency ( ) ; $ wordsByFrequency = array_unique ( array_keys ( $ sortedWords ) ) ; usort ( $ wordsByFrequency , function ( $ a , $ b ) { return strlen ( $ b ) - strlen ( $ a ) ; } ) ; return $ wordsByFrequency ; }
3839	private function ensureSubmitElement ( $ panelRows ) { $ hasSubmit = false ; foreach ( $ panelRows as $ panelRow ) { foreach ( $ panelRow as $ element ) { if ( $ element instanceof SubmitElementInformationInterface ) { $ hasSubmit = true ; break ; } if ( $ hasSubmit ) { break ; } } } if ( ! $ hasSubmit && $ panelRows -> getRowCount ( ) ) { $ row = $ panelRows -> getRow ( $ panelRows -> getRowCount ( ) - 1 ) ; $ row -> addElement ( new DefaultSubmitElementInformation ( ) , 0 ) ; } }
4896	public function start ( $ type = self :: TYPE_INFO , array $ options = array ( ) ) { if ( $ this -> captureLock ) { throw new \ RuntimeException ( 'Cannot start capture, there is already a capture running.' ) ; } $ this -> captureLock = true ; $ this -> captureType = $ type ; $ this -> captureOptions = $ options ; ob_start ( ) ; return $ this ; }
6037	public function init ( ) { parent :: init ( ) ; if ( $ this -> data ) { $ order = 0 ; if ( is_array ( $ this -> model -> { $ this -> attribute } ) ) { foreach ( $ this -> model -> { $ this -> attribute } as $ value ) { $ order ++ ; if ( is_object ( $ value ) ) { $ this -> options [ 'options' ] [ $ value -> Id ] = [ 'data-order' => $ order ] ; } else { $ this -> options [ 'options' ] [ $ value ] = [ 'data-order' => $ order ] ; } } } } }
8566	public function getShipment ( $ request ) { if ( ! ( $ request instanceof MWSMerchantFulfillmentService_Model_GetShipmentRequest ) ) { require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentRequest.php' ) ; $ request = new MWSMerchantFulfillmentService_Model_GetShipmentRequest ( $ request ) ; } $ parameters = $ request -> toQueryParameterArray ( ) ; $ parameters [ 'Action' ] = 'GetShipment' ; $ httpResponse = $ this -> _invoke ( $ parameters ) ; require_once ( dirname ( __FILE__ ) . '/Model/GetShipmentResponse.php' ) ; $ response = MWSMerchantFulfillmentService_Model_GetShipmentResponse :: fromXML ( $ httpResponse [ 'ResponseBody' ] ) ; $ response -> setResponseHeaderMetadata ( $ httpResponse [ 'ResponseHeaderMetadata' ] ) ; return $ response ; }
3580	protected function orderByMeta ( Builder $ query , $ args , $ alias ) { $ query -> with ( 'metaAttributes' ) -> getQuery ( ) -> orderBy ( "{$alias}.meta_value" , $ args -> get ( 'direction' ) ) ; return $ query ; }
8054	public function updateCalendarEvent ( $ id , array $ data ) { $ eventData = $ this -> calendarEventsEngine -> buildEventData ( $ data ) ; $ eventDates = $ this -> calendarEventsEngine -> buildEventDates ( $ data ) ; $ cache = $ this -> cache ; $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> where ( 'calendar_event_id' , $ id ) -> delete ( ) ; $ this -> calendarEvent -> where ( 'id' , $ id ) -> update ( $ eventData ) ; $ calendarEvent = $ this -> calendarEvent -> where ( 'id' , $ id ) -> firstOrFail ( ) ; $ this -> handleEventLocation ( $ data , $ calendarEvent ) ; foreach ( $ eventDates as $ date ) { $ calendarEventRepeatDate = clone $ this -> calendarEventRepeatDate ; $ calendarEventRepeatDate -> start = $ date [ 'start' ] ; $ calendarEventRepeatDate -> end = $ date [ 'end' ] ; $ calendarEventRepeatDate -> calendarEvent ( ) -> associate ( $ calendarEvent ) ; $ calendarEventRepeatDate -> save ( ) ; unset ( $ calendarEventRepeatDate ) ; } $ cache :: put ( self :: CACHE_KEY . $ calendarEvent -> id , $ calendarEvent , $ this -> cacheTimeToLive ) ; $ allEvents = $ this -> getAllEvents ( ) ; $ allEvents -> put ( $ calendarEvent -> id , $ calendarEvent ) ; $ cache :: put ( self :: ALL_EVENTS_KEY , $ allEvents , $ this -> cacheTimeToLive ) ; return true ; }
11898	public function getEstimateTimeRemaining ( ) { $ estimatedDuration = $ this -> dataInterface -> estimateDuration ( ) ; if ( $ estimatedDuration ) { $ startedTime = strtotime ( $ this -> started ) ; $ estimatedEndTime = $ startedTime + $ estimatedDuration ; if ( time ( ) > $ estimatedEndTime ) { return false ; } return $ estimatedEndTime - time ( ) ; } return false ; }
12840	static public function getMimeType ( $ filePath , $ default = 'application/octet-stream' ) { $ mimeType = finfo_file ( finfo_open ( FILEINFO_MIME_TYPE ) , $ filePath ) ; if ( $ mimeType === false ) { $ mimeType = $ default ; } return $ mimeType ; }
3843	private function parsePanelSearch ( PanelRowInterface $ row ) { if ( $ row -> hasElement ( 'search' ) ) { $ element = $ row -> getElement ( 'search' ) ; } else { $ element = new DefaultSearchElementInformation ( ) ; } if ( ! $ element instanceof SearchElementInformationInterface ) { throw new \ InvalidArgumentException ( 'Search element does not implement the correct interface.' ) ; } foreach ( $ this -> inputScreen [ 'properties' ] as $ value ) { if ( ! empty ( $ value [ 'search' ] ) ) { $ element -> addProperty ( $ value [ 'col_name' ] ) ; } } if ( $ element -> getPropertyNames ( ) && ! $ row -> hasElement ( 'search' ) ) { $ row -> addElement ( $ element ) ; } }
7537	function clear ( ) { foreach ( $ this -> children as $ c ) { $ c -> parent = null ; $ c -> delete ( ) ; } $ this -> children = array ( ) ; }
6317	public function execute ( $ sql ) { $ this -> dispatcher -> dispatch ( 'rentgen.sql_executed' , new SqlEvent ( $ sql ) ) ; return $ this -> getConnection ( ) -> exec ( $ sql ) ; }
11095	public static function generatePin ( $ salt , $ length = 6 , $ useMinutes = false ) { $ seed = sha1 ( $ salt . ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'Ymd' . ( $ useMinutes ? 'i' : '' ) ) , true ) ; for ( $ i = 0 ; $ i <= ( new \ DateTime ( 'now' , new \ DateTimeZone ( 'Europe/Prague' ) ) ) -> format ( 'G' ) ; $ i ++ ) { $ seed = sha1 ( $ seed . $ i ) ; } $ data = unpack ( 'V1/V2' , $ seed ) ; $ data [ 1 ] = $ data [ 1 ] < 0 ? $ data [ 1 ] * - 1 : $ data [ 1 ] ; $ data [ 2 ] = $ data [ 2 ] < 0 ? $ data [ 2 ] * - 1 : $ data [ 2 ] ; $ mask = $ data [ 1 ] ^ $ data [ 2 ] ; if ( $ mask % 1000000 === 0 || $ mask % 1000000 === 999999 ) { return self :: generatePin ( $ salt . $ seed , $ length , $ useMinutes ) ; } return round ( ( ( ( float ) ( $ mask % 1000000 ) - 0.5 + ( ( float ) ( $ mask % 200 ) / 199 ) ) / 999999 ) * ( ( ( 10 ** $ length ) - 1 ) - ( 10 ** ( $ length - 1 ) ) ) + ( 10 ** ( $ length - 1 ) ) ) ; }
3762	private function getConditionChain ( LegendInterface $ legend , $ propertyName , array & $ conditions ) { if ( isset ( $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ) ) { return $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] ; } $ property = $ this -> getLegendProperty ( $ legend , $ propertyName ) ; $ condition = $ this -> getVisibleCondition ( $ property ) ; $ orCondition = new PropertyConditionChain ( ) ; $ orCondition -> setConjunction ( PropertyConditionChain :: OR_CONJUNCTION ) ; $ conditions [ $ legend -> getName ( ) ] [ $ propertyName ] = $ orCondition ; $ condition -> addCondition ( $ orCondition ) ; return $ orCondition ; }
6096	public function memberOf ( ) { $ groups = array ( $ this -> getParent ( ) -> channelGroupGetById ( $ this [ "client_channel_group_id" ] ) ) ; foreach ( explode ( "," , $ this [ "client_servergroups" ] ) as $ sgid ) { $ groups [ ] = $ this -> getParent ( ) -> serverGroupGetById ( $ sgid ) ; } return $ groups ; }
3369	private function getClassString ( ClassMetadata $ class ) { $ this -> visitAssociation ( $ class -> getName ( ) ) ; $ className = $ class -> getName ( ) ; $ classText = '[' . str_replace ( '\\' , '.' , $ className ) ; $ fields = [ ] ; $ parent = $ this -> getParent ( $ class ) ; $ parentFields = $ parent ? $ parent -> getFieldNames ( ) : [ ] ; foreach ( $ class -> getFieldNames ( ) as $ fieldName ) { if ( in_array ( $ fieldName , $ parentFields ) ) { continue ; } if ( $ class -> isIdentifier ( $ fieldName ) ) { $ fields [ ] = '+' . $ fieldName ; } else { $ fields [ ] = $ fieldName ; } } if ( ! empty ( $ fields ) ) { $ classText .= '|' . implode ( ';' , $ fields ) ; } $ classText .= ']' ; return $ classText ; }
11674	public function setConfigurationOptions ( array $ options = array ( ) ) { $ resolver = new OptionsResolver ( ) ; $ resolver -> setDefined ( array ( 'web_dir' , 'uploads_dir' , ) ) ; $ resolver -> resolve ( $ options ) ; if ( array_key_exists ( 'web_dir' , $ options ) ) { $ this -> webDirname = $ options [ 'web_dir' ] ; } if ( array_key_exists ( 'uploads_dir' , $ options ) ) { $ this -> absoluteUploadAssetsDir = $ options [ 'uploads_dir' ] ; } }
1204	protected function renderChildren ( ItemInterface $ item , array $ options ) { if ( null !== $ options [ 'depth' ] ) { $ options [ 'depth' ] = $ options [ 'depth' ] - 1 ; } if ( null !== $ options [ 'matchingDepth' ] && $ options [ 'matchingDepth' ] > 0 ) { $ options [ 'matchingDepth' ] = $ options [ 'matchingDepth' ] - 1 ; } $ html = '' ; foreach ( $ item -> getChildren ( ) as $ child ) { $ html .= $ this -> renderItem ( $ child , $ options ) ; } return $ html ; }
4247	private function logRequestHeaders ( ) { if ( ! $ this -> debug -> getCfg ( 'logEnvInfo.headers' ) ) { return ; } if ( ! empty ( $ _SERVER [ 'argv' ] ) ) { return ; } $ headers = $ this -> debug -> utilities -> getAllHeaders ( ) ; \ ksort ( $ headers , SORT_NATURAL ) ; $ this -> debug -> log ( 'request headers' , $ headers ) ; }
187	protected function fetchData ( ) { if ( $ this -> _dataReader === null ) { $ this -> _dataReader = $ this -> query -> createCommand ( $ this -> db ) -> query ( ) ; } $ rows = [ ] ; $ count = 0 ; while ( $ count ++ < $ this -> batchSize && ( $ row = $ this -> _dataReader -> read ( ) ) ) { $ rows [ ] = $ row ; } return $ this -> query -> populate ( $ rows ) ; }
10082	protected function registerConfigurator ( ) { $ this -> app -> singleton ( 'auja.database' , function ( $ app ) { $ config = $ app [ 'config' ] [ 'auja-laravel' ] ? : $ app [ 'config' ] [ 'auja-laravel::config' ] ; switch ( $ config [ 'database' ] ) { case 'mysql' : return new MySQLDatabaseHelper ( ) ; break ; default : throw new NoDatabaseHelperException ( 'No Auja database helper for ' . $ config [ 'database' ] ) ; break ; } } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Database\DatabaseHelper' , 'auja.database' ) ; $ this -> app -> singleton ( 'auja.configurator' , function ( $ app ) { return new AujaConfigurator ( $ app , $ app [ 'auja.database' ] ) ; } ) ; $ this -> app -> bind ( 'Label305\AujaLaravel\Config\AujaConfigurator' , 'auja.configurator' ) ; }
5044	public function onRoute ( MvcEvent $ e ) { $ routeMatch = $ e -> getRouteMatch ( ) ; if ( 0 !== strpos ( $ routeMatch -> getMatchedRouteName ( ) , 'lang' ) ) { $ lang = $ this -> detectLanguage ( $ e ) ; $ this -> setLocale ( $ e , $ lang ) ; return ; } $ language = $ routeMatch -> getParam ( 'lang' , '__NOT_SET__' ) ; if ( $ this -> localeService -> isLanguageSupported ( $ language ) ) { $ this -> setLocale ( $ e , $ language ) ; } else { $ e -> setError ( Application :: ERROR_ROUTER_NO_MATCH ) ; $ e -> setTarget ( $ this ) ; $ eventManager = $ e -> getApplication ( ) -> getEventManager ( ) ; $ eventManager -> setEventPrototype ( $ e ) ; $ result = $ eventManager -> trigger ( MvcEvent :: EVENT_DISPATCH_ERROR , $ e ) ; return $ result -> last ( ) ; } }
5543	public function getFrames ( ) { $ report = array ( ) ; for ( $ i = 0 ; $ i < count ( $ this -> frames ) ; $ i ++ ) { $ report [ $ this -> getPublicNameFromIndex ( $ i ) ] = $ this -> frames [ $ i ] -> getFrames ( ) ; } return $ report ; }
9741	public function isPrintAreaSet ( $ index = 0 ) { if ( $ index == 0 ) { return $ this -> printArea !== null ; } $ printAreas = explode ( ',' , $ this -> printArea ) ; return isset ( $ printAreas [ $ index - 1 ] ) ; }
11459	public function attachFile ( string $ sFileName , string $ sContent , string $ sType ) : bool { $ this -> _aAttachments [ ] = array ( "name" => $ sFileName , "content" => $ sContent , "type" => $ sType ) ; return true ; }
6947	private function getOutstandingExpiredDueQueryBuilder ( ) { $ qb = $ this -> createQueryBuilder ( 'o' ) ; $ ex = $ qb -> expr ( ) ; $ qb -> join ( 'o.paymentTerm' , 't' ) -> where ( $ ex -> andX ( $ ex -> eq ( 'o.sample' , ':not_sample' ) , $ ex -> lt ( 'o.paidTotal' , 'o.grandTotal' ) , $ ex -> notIn ( 'o.invoiceState' , ':canceled_or_refunded' ) , $ qb -> expr ( ) -> lte ( 'o.outstandingDate' , ':today' ) , $ this -> getDueClauses ( ) ) ) -> addOrderBy ( 'o.outstandingDate' , 'ASC' ) -> setParameter ( 'not_sample' , false ) -> setParameter ( 'today' , ( new \ DateTime ( ) ) -> setTime ( 23 , 59 , 59 ) , Type :: DATETIME ) -> setParameter ( 'canceled_or_refunded' , [ InvoiceStates :: STATE_CANCELED , InvoiceStates :: STATE_CREDITED ] ) ; $ this -> setDueParameters ( $ qb ) ; return $ qb ; }
8922	public function apply ( $ targetDocument , $ patchDocument ) { if ( $ targetDocument === null || ! is_object ( $ targetDocument ) || is_array ( $ targetDocument ) ) { $ targetDocument = new \ stdClass ( ) ; } if ( $ patchDocument === null || ! is_object ( $ patchDocument ) || is_array ( $ patchDocument ) ) { return $ patchDocument ; } foreach ( $ patchDocument as $ key => $ value ) { if ( $ value === null ) { unset ( $ targetDocument -> $ key ) ; } else { if ( ! isset ( $ targetDocument -> $ key ) ) { $ targetDocument -> $ key = null ; } $ targetDocument -> $ key = $ this -> apply ( $ targetDocument -> $ key , $ value ) ; } } return $ targetDocument ; }
10405	public function set ( $ key , $ value ) { $ pair = $ this -> repository -> find ( $ key ) ; if ( $ pair === null ) { $ pair = new Pair ( ) ; $ pair -> setId ( $ key ) ; } $ pair -> setValue ( $ value ) ; $ this -> save ( $ pair ) ; return $ pair ; }
5676	protected function getMembers ( $ object ) { $ reflection = new ReflectionObject ( $ object ) ; $ members = array ( ) ; foreach ( $ reflection -> getProperties ( ) as $ property ) { if ( method_exists ( $ property , 'setAccessible' ) ) { $ property -> setAccessible ( true ) ; } try { $ members [ $ property -> getName ( ) ] = $ property -> getValue ( $ object ) ; } catch ( ReflectionException $ e ) { $ members [ $ property -> getName ( ) ] = $ this -> getPrivatePropertyNoMatterWhat ( $ property -> getName ( ) , $ object ) ; } } return $ members ; }
5079	public function postRemap ( ) { $ oUri = Factory :: service ( 'Uri' ) ; $ sMethod = 'post' . ucfirst ( $ oUri -> segment ( 4 ) ) ; if ( method_exists ( $ this , $ sMethod ) ) { return $ this -> $ sMethod ( ) ; } $ oInput = Factory :: service ( 'Input' ) ; $ oHttpCodes = Factory :: service ( 'HttpCodes' ) ; $ oItemModel = Factory :: model ( static :: CONFIG_MODEL_NAME , static :: CONFIG_MODEL_PROVIDER ) ; $ aFields = $ oItemModel -> describeFields ( ) ; $ aValid = [ ] ; $ aInvalid = [ ] ; foreach ( $ aFields as $ oField ) { if ( in_array ( $ oField -> key , static :: CONFIG_POST_IGNORE_FIELDS ) ) { continue ; } $ aValid [ ] = $ oField -> key ; } $ aPost = $ oInput -> post ( ) ; foreach ( $ aPost as $ sKey => $ sValue ) { if ( ! in_array ( $ sKey , $ aValid ) ) { $ aInvalid [ ] = $ sKey ; } } if ( ! empty ( $ aInvalid ) ) { throw new ApiException ( 'The following arguments are invalid: ' . implode ( ', ' , $ aInvalid ) , $ oHttpCodes :: STATUS_BAD_REQUEST ) ; } $ iItemId = ( int ) $ oUri -> segment ( 4 ) ; if ( $ iItemId ) { $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( empty ( $ oItem ) ) { throw new ApiException ( 'Item does not exist' , $ oHttpCodes :: STATUS_NOT_FOUND ) ; } elseif ( ! $ oItemModel -> update ( $ iItemId , $ aPost ) ) { throw new ApiException ( 'Failed to update item. ' . $ oItemModel -> lastError ( ) , $ oHttpCodes :: STATUS_INTERNAL_SERVER_ERROR ) ; } elseif ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> disableCache ( ) ; } $ oItem = $ oItemModel -> getById ( $ iItemId ) ; if ( classUses ( $ oItemModel , 'Nails\Common\Traits\Caching' ) ) { $ oItemModel -> enableCache ( ) ; } } else { $ oItem = $ oItemModel -> create ( $ aPost , true ) ; } $ oResponse = Factory :: factory ( 'ApiResponse' , 'nails/module-api' ) ; $ oResponse -> setData ( $ this -> formatObject ( $ oItem ) ) ; return $ oResponse ; }
8785	public function fullUrlWithQuery ( array $ query ) { $ question = $ this -> getBaseUrl ( ) . $ this -> getPathInfo ( ) == '/' ? '/?' : '?' ; return count ( $ this -> query ( ) ) > 0 ? $ this -> url ( ) . $ question . http_build_query ( array_merge ( $ this -> query ( ) , $ query ) ) : $ this -> fullUrl ( ) . $ question . http_build_query ( $ query ) ; }
4661	public function send ( ) { $ eventManager = $ this -> getManager ( ) -> getEventsManager ( ) ; if ( $ eventManager ) { $ result = $ eventManager -> fire ( 'mailer:beforeSend' , $ this ) ; } else { $ result = true ; } if ( $ result === false ) { return false ; } $ this -> failedRecipients = [ ] ; $ queue = $ this -> getManager ( ) -> getQueue ( ) ; if ( $ this -> auth ) { $ queue -> putInTube ( $ this -> queueName , [ 'message' => $ this -> getMessage ( ) , 'auth' => $ this -> smtp , ] ) ; } else { $ queue -> putInTube ( $ this -> queueName , $ this -> getMessage ( ) ) ; } }
6570	public function getMessage ( ) { return '[' . $ this -> prefix . ( $ this -> context === null ? '' : ( ' - ' . get_class ( $ this -> context ) ) ) . '] ' . $ this -> msg ; }
6356	public static function convert ( $ style = TS_UNIX , $ ts ) { try { $ ct = new static ( $ ts ) ; return $ ct -> getTimestamp ( $ style ) ; } catch ( TimestampException $ e ) { return false ; } }
5068	public function setOpt ( int $ option , string $ value ) : bool { return curl_share_setopt ( $ this -> sh , $ option , $ value ) ; }
2177	private function getRedirectResponse ( ) : RedirectResponse { $ request = $ this -> container -> get ( 'request_stack' ) -> getCurrentRequest ( ) ; if ( null === $ request ) { throw new \ RuntimeException ( 'The request stack did not contain a request' ) ; } return new RedirectResponse ( $ request -> getRequestUri ( ) ) ; }
11763	public function replace ( $ needle , $ replacement ) : Pipeline { $ stages = [ ] ; $ found = false ; foreach ( $ this -> stages as $ stage ) { if ( $ this -> matches ( $ stage , $ needle ) ) { $ stages [ ] = $ replacement ; $ found = true ; continue ; } $ stages [ ] = $ stage ; } if ( $ found ) { $ pipeline = clone $ this ; $ pipeline -> stages = $ stages ; return $ pipeline ; } unset ( $ stages ) ; return $ this ; }
926	public function getLintErrors ( ) { return array_filter ( $ this -> errors , static function ( Error $ error ) { return Error :: TYPE_LINT === $ error -> getType ( ) ; } ) ; }
4297	public function clear ( $ flags = self :: CLEAR_LOG ) { array ( $ flags ) ; $ args = \ func_get_args ( ) ; $ meta = $ this -> internal -> getMetaVals ( $ args , array ( 'channel' => $ this -> cfg [ 'channel' ] ) , array ( 'flags' => self :: CLEAR_LOG ) , array ( 'flags' => 'bitmask' ) ) ; $ event = $ this -> methodClear -> onLog ( new Event ( $ this , array ( 'method' => __FUNCTION__ , 'args' => array ( ) , 'meta' => $ meta , ) ) ) ; $ this -> setLogDest ( 'log' ) ; $ collect = $ this -> cfg [ 'collect' ] ; $ this -> cfg [ 'collect' ] = true ; if ( $ event [ 'log' ] ) { $ this -> appendLog ( $ event [ 'method' ] , $ event [ 'args' ] , $ event [ 'meta' ] ) ; } elseif ( $ event [ 'publish' ] ) { $ this -> internal -> publishBubbleEvent ( 'debug.log' , $ event ) ; } $ this -> cfg [ 'collect' ] = $ collect ; $ this -> setLogDest ( 'auto' ) ; }
913	private function moveReturnAnnotations ( $ content ) { $ doc = new DocBlock ( $ content ) ; $ returns = $ doc -> getAnnotationsOfType ( 'return' ) ; if ( empty ( $ returns ) ) { return $ content ; } $ others = $ doc -> getAnnotationsOfType ( [ 'param' , 'throws' ] ) ; if ( empty ( $ others ) ) { return $ content ; } $ start = $ returns [ 0 ] -> getStart ( ) ; $ line = $ doc -> getLine ( $ start ) ; foreach ( array_reverse ( $ others ) as $ other ) { if ( $ other -> getEnd ( ) > $ start ) { $ line -> setContent ( $ other -> getContent ( ) . $ line -> getContent ( ) ) ; $ other -> remove ( ) ; } } return $ doc -> getContent ( ) ; }
6094	public function isUtf8 ( ) { $ pattern = array ( ) ; $ pattern [ ] = "[\xC2-\xDF][\x80-\xBF]" ; $ pattern [ ] = "\xE0[\xA0-\xBF][\x80-\xBF]" ; $ pattern [ ] = "[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}" ; $ pattern [ ] = "\xED[\x80-\x9F][\x80-\xBF]" ; $ pattern [ ] = "\xF0[\x90-\xBF][\x80-\xBF]{2}" ; $ pattern [ ] = "[\xF1-\xF3][\x80-\xBF]{3}" ; $ pattern [ ] = "\xF4[\x80-\x8F][\x80-\xBF]{2}" ; return preg_match ( "%(?:" . implode ( "|" , $ pattern ) . ")+%xs" , $ this -> string ) ; }
583	public function actionCompress ( $ configFile , $ bundleFile ) { $ this -> loadConfiguration ( $ configFile ) ; $ bundles = $ this -> loadBundles ( $ this -> bundles ) ; $ targets = $ this -> loadTargets ( $ this -> targets , $ bundles ) ; foreach ( $ targets as $ name => $ target ) { $ this -> stdout ( "Creating output bundle '{$name}':\n" ) ; if ( ! empty ( $ target -> js ) ) { $ this -> buildTarget ( $ target , 'js' , $ bundles ) ; } if ( ! empty ( $ target -> css ) ) { $ this -> buildTarget ( $ target , 'css' , $ bundles ) ; } $ this -> stdout ( "\n" ) ; } $ targets = $ this -> adjustDependency ( $ targets , $ bundles ) ; $ this -> saveTargets ( $ targets , $ bundleFile ) ; if ( $ this -> deleteSource ) { $ this -> deletePublishedAssets ( $ bundles ) ; } }
8920	protected function parseRelator ( & $ node , & $ out , $ default = null ) { $ relterm = $ node -> text ( 'marc:subfield[@code="e"]' ) ; $ relcode = $ node -> text ( 'marc:subfield[@code="4"]' ) ; if ( ! empty ( $ relcode ) ) { $ out [ 'role' ] = $ relcode ; } elseif ( ! empty ( $ relterm ) ) { $ out [ 'role' ] = $ relterm ; } elseif ( ! is_null ( $ default ) ) { $ out [ 'role' ] = $ default ; } }
1274	private function createRequestLandedCost ( LandedCostRequest $ landedCostRequest ) { $ xml = new DOMDocument ( ) ; $ xml -> formatOutput = true ; $ tradeabilityRequest = $ xml -> appendChild ( $ xml -> createElement ( 'LandedCostRequest' ) ) ; $ tradeabilityRequest -> setAttribute ( 'xml:lang' , 'en-US' ) ; $ request = $ tradeabilityRequest -> appendChild ( $ xml -> createElement ( 'Request' ) ) ; $ node = $ xml -> importNode ( $ this -> createTransactionNode ( ) , true ) ; $ request -> appendChild ( $ node ) ; $ request -> appendChild ( $ xml -> createElement ( 'RequestAction' , 'LandedCost' ) ) ; if ( $ landedCostRequest -> getQueryRequest ( ) !== null ) { $ tradeabilityRequest -> appendChild ( $ landedCostRequest -> getQueryRequest ( ) -> toNode ( $ xml ) ) ; } return $ xml -> saveXML ( ) ; }
3122	public function find ( $ tag = null , $ target = TimePoint :: TARGET_ALL , $ type = TimePoint :: TYPE_ALL ) { $ tags = null ; if ( isset ( $ tag ) ) { $ tags = is_array ( $ tag ) ? $ tag : [ $ tag ] ; } $ points = [ ] ; foreach ( $ this -> points as $ point ) { if ( $ point -> match ( $ tags , $ target , $ type ) ) { $ points [ ] = $ point ; } } return $ points ; }
11243	public function setDirection ( Neuron_GameServer_Map_Vector3 $ start , Neuron_GameServer_Map_Vector3 $ end ) { $ this -> startRotation = $ start ; $ this -> endRotation = $ end ; }
5853	protected function loadVirtualTca ( ) { $ GLOBALS [ 'TCA' ] [ static :: virtualTable ] = include ( ExtensionManagementUtility :: extPath ( $ this -> extKey ) . 'Configuration/TCA/Module/Options.php' ) ; ExtensionManagementUtility :: addLLrefForTCAdescr ( static :: virtualTable , 'EXT:' . $ this -> extKey . '/Resource/Private/Language/locallang_csh_' . static :: virtualTable . '.xlf' ) ; }
8107	protected function getTemplateVariables ( $ recipient , $ config , $ pages ) { return [ 'Subject' => $ config -> ReviewSubject , 'PagesCount' => $ pages -> count ( ) , 'FromEmail' => $ config -> ReviewFrom , 'ToFirstName' => $ recipient -> FirstName , 'ToSurname' => $ recipient -> Surname , 'ToEmail' => $ recipient -> Email , ] ; }
5093	public function rotate ( $ tableA , $ tableB ) { $ tableT = $ tableA . '_' . time ( ) . '_' . rand ( 0 , 1000000 ) ; return $ this -> rename ( [ $ tableB => $ tableT , $ tableA => $ tableB , $ tableT => $ tableA ] ) ; }
6794	public function getTagCount ( $ ids ) { $ tableName = $ this -> getTagSource ( ) ; $ colNameId = $ this -> getIdColumn ( ) ; $ return = [ ] ; if ( $ tableName && $ colNameId ) { $ statement = $ this -> getConnection ( ) -> createQueryBuilder ( ) -> select ( 'item_id' , 'count(*) as count' ) -> from ( 'tl_metamodel_tag_relation' ) -> where ( 'att_id=:att' ) -> andWhere ( 'item_id IN (:items)' ) -> groupBy ( 'item_id' ) -> setParameter ( 'att' , $ this -> get ( 'id' ) ) -> setParameter ( 'items' , $ ids , Connection :: PARAM_INT_ARRAY ) -> execute ( ) ; while ( $ row = $ statement -> fetch ( \ PDO :: FETCH_OBJ ) ) { $ itemId = $ row -> item_id ; $ return [ $ itemId ] = ( int ) $ row -> count ; } } return $ return ; }
11602	public function getComponentRoot ( string $ name ) : ? string { $ rootMap = $ this -> getConfig ( 'componentsRootMap' ) ; return isset ( $ rootMap [ $ name ] ) ? $ this -> getAppRoot ( ) . $ rootMap [ $ name ] : null ; }
6885	public function lookupPostcodeAddresses ( $ postcode ) { $ path = self :: PATH_LOOKUP_POSTCODE ; $ response = $ this -> httpGet ( $ path , [ 'postcode' => $ postcode ] ) ; return Response \ AddressList :: buildFromResponse ( $ response ) ; }
6060	public function retrieveFileData ( $ id , $ template = null , CachePolicy $ cachePolicy = null ) { $ parameters = [ 'query' => [ 'template' => $ template ] , 'body' => json_encode ( [ ] ) , 'headers' => [ ] , ] ; $ result = $ this -> get ( 'v1/media/' . $ id . '/asset' , $ parameters , $ cachePolicy ) ; return $ result ; }
10940	public function getResponse ( $ params = [ ] , $ lifetime = - 1 , Response $ response = null ) { if ( ! $ response ) { $ response = new Response ( ) ; } if ( ! $ this -> enable ) { return $ response ; } return $ this -> configurator -> configure ( $ response , $ this -> getMax ( $ params ) , $ lifetime ) ; }
1814	public function listImportWizard ( ) { return ' <a href="' . $ this -> addToUrl ( 'key=list' ) . '" title="' . Contao \ StringUtil :: specialchars ( $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'lw_import' ] [ 1 ] ) . '" onclick="Backend.getScrollOffset()">' . Contao \ Image :: getHtml ( 'tablewizard.svg' , $ GLOBALS [ 'TL_LANG' ] [ 'MSC' ] [ 'tw_import' ] [ 0 ] ) . '</a>' ; }
10643	public function getParent ( ) { if ( $ this -> path === "/" || ( $ path = dirname ( $ this -> path ) ) === "." ) { return null ; } return new DirEntity ( $ path ) ; }
1489	public function unless ( bool $ test , $ decodings ) : self { return $ this -> when ( true !== $ test , $ decodings ) ; }
4325	public static function getCallerInfo ( $ offset = 0 ) { $ return = array ( 'file' => null , 'line' => null , 'function' => null , 'class' => null , 'type' => null , ) ; $ backtrace = \ debug_backtrace ( DEBUG_BACKTRACE_IGNORE_ARGS | DEBUG_BACKTRACE_PROVIDE_OBJECT , 8 ) ; $ numFrames = \ count ( $ backtrace ) ; $ regexInternal = '/^' . \ preg_quote ( __NAMESPACE__ ) . '\b/' ; if ( isset ( $ backtrace [ 1 ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ 1 ] [ 'class' ] ) ) { for ( $ i = $ numFrames - 1 ; $ i >= 0 ; $ i -- ) { if ( isset ( $ backtrace [ $ i ] [ 'class' ] ) && \ preg_match ( $ regexInternal , $ backtrace [ $ i ] [ 'class' ] ) ) { break ; } } } else { $ i = 1 ; } $ i += $ offset ; $ iLine = $ i ; $ iFunc = $ i + 1 ; if ( isset ( $ backtrace [ $ iFunc ] ) && \ in_array ( $ backtrace [ $ iFunc ] [ 'function' ] , array ( 'call_user_func' , 'call_user_func_array' ) ) ) { $ iLine ++ ; $ iFunc ++ ; } elseif ( isset ( $ backtrace [ $ iFunc ] [ 'class' ] ) && $ backtrace [ $ iFunc ] [ 'class' ] == 'ReflectionMethod' && $ backtrace [ $ iFunc ] [ 'function' ] == 'invoke' ) { $ iLine ++ ; $ iFunc -- ; } if ( isset ( $ backtrace [ $ iFunc ] ) ) { $ return = \ array_merge ( $ return , \ array_intersect_key ( $ backtrace [ $ iFunc ] , $ return ) ) ; if ( $ return [ 'type' ] == '->' ) { $ return [ 'class' ] = \ get_class ( $ backtrace [ $ iFunc ] [ 'object' ] ) ; } } if ( isset ( $ backtrace [ $ iLine ] ) ) { $ return [ 'file' ] = $ backtrace [ $ iLine ] [ 'file' ] ; $ return [ 'line' ] = $ backtrace [ $ iLine ] [ 'line' ] ; } else { $ return [ 'file' ] = $ backtrace [ $ numFrames - 1 ] [ 'file' ] ; $ return [ 'line' ] = 0 ; } return $ return ; }
10369	public function reset ( ResetRequest $ request , $ token ) { $ this -> bus -> pipeThrough ( $ this -> pipesOf ( 'reset' ) ) -> dispatchFrom ( ResetJob :: class , $ request , compact ( 'token' ) ) ; return redirect ( ) -> route ( 'login.index' ) -> withSuccess ( trans ( 'auth::reset.success' ) ) ; }
12643	public function getWidgetId ( ) { if ( ! is_null ( $ this -> _widgetId ) ) { return $ this -> _widgetId ; } return $ this -> _widgetId = 'ic-widget-' . md5 ( microtime ( ) . mt_rand ( ) ) ; }
12421	public function dn ( $ domain , $ singular , $ plural , $ number ) { $ singular = ( string ) $ singular ; $ plural = ( string ) $ plural ; $ number = ( int ) $ number ; try { $ locale = $ this -> getLocale ( ) ; foreach ( $ this -> getTranslations ( $ domain ) as $ object ) { if ( ( $ string = $ object -> translatePlural ( $ singular , $ plural , $ number , $ domain , $ locale ) ) != $ singular ) { return $ string ; } } } catch ( \ Exception $ e ) { ; } if ( $ this -> getPluralIndex ( $ number , $ this -> getLocale ( ) ) > 0 ) { return ( string ) $ plural ; } return ( string ) $ singular ; }
10179	public function removeColumn ( $ column ) { foreach ( $ this -> getCoordinates ( ) as $ coord ) { sscanf ( $ coord , '%[A-Z]%d' , $ c , $ r ) ; if ( $ c == $ column ) { $ this -> delete ( $ coord ) ; } } }
